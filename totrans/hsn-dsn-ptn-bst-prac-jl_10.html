<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Maintainability Patterns</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">This chapter will cover <span>several </span>patterns that are related to improving code readability and the ease of maintenance. These aspects are sometimes overlooked because programmers always think that they know what they are doing. In reality, programmers do not always write code that is readable to others. Sometimes, the code could be</span> <span class="s1">too cluttered and difficult to follow, or the files may not be very well organized. These problems can often be mitigated by refactoring.</span></p>
<p class="p1"><span class="s1">Metaprogramming can be a good way to further improve readability and maintainability. In some cases, there are existing macros that we can utilize today. It would be a shame if we do not explore such opportunities. We know g</span>ood programmers always have the relentless desire for achieving excellence, so learning these techniques would be a rewarding exercise. In the subsequent sections, we will look into the following patterns:</p>
<ul>
<li>Sub-module pattern</li>
<li>Keyword definition pattern</li>
<li><span><span>Code generation pattern</span></span></li>
<li><span>Domain-specific language pattern</span></li>
</ul>
<p>By the end of this chapter, you will have learned how to organize your code better. You will be able to reduce clutter and write very concise code. In addition, if you are working on a problem with a specific industry domain, you can build your own <strong>domain-specific language</strong><span> (</span><strong>DSL</strong><span>)</span> to further express your problem clearly in your own syntax.</p>
<p><em>Let's go!</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter07">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter07</a>.</p>
<p>The code is tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sub-module pattern</h1>
                </header>
            
            <article>
                
<p>When a module becomes too large, it can be difficult to manage and comprehend. Generally, it can happen organically when the programmer keeps adding more and more functionalities to an application. So, how large is too large? It is difficult to say as it varies and depends on the programming language, the problem domain, and even the skillsets of the application maintainers. Nevertheless, it is mostly agreed upon by professionals that smaller modules are easier to manage, especially when the code is maintained by multiple developers.</p>
<p>In this section, we will explore the idea of splitting the source code of a large module into separately managed sub-modules. We will discuss how to make that decision and how to do that properly. As part of our journey, we will look into some examples and see how other experts do it in their packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding when sub-module is needed</h1>
                </header>
            
            <article>
                
<p>When should we consider creating sub-modules? There are several factors to consider:</p>
<ul>
<li>First, we could consider the size of the application. Size is an abstract concept and can be measured in several ways, some of which are mentioned here:
<ul>
<li><strong>Number of lines of code</strong>:<span> This is the simplest measure to understand the size of an application. The more lines of code in the source files, the larger the application. This is analogous to the number of pages in a book. It takes more time for you to read and understand the content for a book that has more pages.</span></li>
<li><strong>Number of functions</strong>: When there are too many functions in a single module, it is more difficult to understand and learn all those functions. When there are too many functions, the number of interactions between functions naturally increase, making the application more prone to messy spaghetti code.</li>
<li><strong>Number of data types</strong>: Every data type represents a kind of an object. It is more difficult for a developer to comprehend all the functions operating on a large number of data types because the human brain cannot handle too many concepts at the same time.</li>
</ul>
</li>
</ul>
<ul>
<li>The second thing we should consider is separation of concern. As we look into an application that comprises various components, we may logically think of them as separate things that can be managed independently. Humans are an excellent species that know how to work on items that are small and organized.</li>
<li>Lastly, we can consider the complexity of matter. Sometimes, you look at the source code and realize that the logic is difficult to grasp. Perhaps it's the domain knowledge. Or, it could be a complex algorithm. While the size of the application is not large, it may still make sense to split the code into separate files physically.</li>
</ul>
<p>So far, we have not set any concrete threshold for any of the preceding factors. That is because the decision to call something large or complex is quite subjective. A common way to do that is to have a discussion among several software engineers and make a group decision. Doing that allows us to overcome the <em>original developer bias</em>, where the person already knows everything by heart, and therefore, the person would tend to believe that the application is not too large nor too complex.</p>
<p>Suppose that you are ready to take the plunge and split part of your code into sub-modules. The next challenge is to figure out how to do it properly. The work can be part art and part science. To formalize the process for splitting source code into sub-modules, we will first discuss the concept of coupling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding afferent and efferent coupling</h1>
                </header>
            
            <article>
                
<p>Before splitting code into separate components, the first step is to analyze the existing code structure. Are there any high-level domain concepts that stand on their own? For example, a banking application may involve account management, deposit/withdrawal, balance transfer, customer notification, and so on. Each of these domain concepts can potentially be split into separate components.</p>
<p>We must also understand how components interact with each other. Here, we will talk about two concepts that originated from object-oriented programming:</p>
<ul>
<li>Afferent coupling – number of external entities that depend on the current entity</li>
<li>Efferent coupling – <span>number of </span>external entities that the current entity depends upon</li>
</ul>
<p>Let's take a look at this diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/412d1824-97f5-42e4-93f0-9ce913d61c83.png" style="width:37.00em;height:14.08em;"/></p>
<p>In this example, we can arrive at the following observations:</p>
<ul>
<li>Component A has two efferent couplings.</li>
<li>Component B has one afferent coupling and one efferent coupling.</li>
<li>Component C has one efferent coupling.</li>
<li>Component D has three afferent couplings.</li>
</ul>
<p>So, if a component is <em>used by</em> many external components, then this component has high afferent coupling. On the other hand, if a component <em>uses</em> many external components, then it has high efferent coupling. </p>
<p>These coupling characteristics help us to understand the stability requirement of a component. A component having high afferent coupling needs to be as stable as possible because making changes in this component may have a higher risk of breaking other components. That would be the case for Component D in the <span>preceding </span>example.</p>
<p>Similarly, a component having high efferent coupling means that it may be more unstable due to many possible changes from the components that it depends on. That would be the case for the preceding Component A. Hence, it would be best to reduce coupling whenever possible, whether it's afferent or efferent. A decoupled system tends to have a minimum number of afferent and efferent couplings.</p>
<p>The same concepts apply when designing sub-modules. When we split code into separate sub-modules, it would be most ideal if afferent/efferent couplings are minimized. Now, we will first take a look at the best practice of organizing files for sub-modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing sub-modules</h1>
                </header>
            
            <article>
                
<p>There are generally two patterns for organizing sub-module files. Let's take a look at each:</p>
<ul>
<li>The first one involves a simpler situation where each sub-module is fully contained in a single source file, as follows:</li>
</ul>
<pre style="padding-left: 60px">module MyPackage<br/>include("sub_module1.jl")<br/>include("sub_module2.jl")<br/>include("sub_module3.jl")<br/>end</pre>
<ul>
<li>The second one involves larger sub-modules where there could be several source files for each sub-module. In that case, the source code of a sub-module resides in a subdirectory:</li>
</ul>
<pre style="padding-left: 60px"># MyPackage.jl<br/>module MyPackage<br/>include("sub_module1/sub_module1.jl")<br/>include("sub_module2/sub_module2.jl")<br/>include("sub_module3.jl")<br/>end</pre>
<ul>
<li>Of course, the sub module's directory may include multiple files. In the preceding example, <kbd>sub_module1</kbd> may contain several more source files, which are shown in the following code snippet:</li>
</ul>
<pre style="padding-left: 60px"># sub_module1.jl<br/>module SubModule1<br/>include("file1.jl")<br/>include("file2.jl")<br/>include("file3.jl")<br/>end</pre>
<p>Next, we will look into how to reference symbols and functions between the modules and these sub-modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Referencing symbols and functions between modules and sub-modules</h1>
                </header>
            
            <article>
                
<p>A module can access its sub-modules using the regular <kbd>using</kbd> or <kbd>import</kbd> statements. In fact, a sub-module does not work any differently than an external package, except how it is being referenced.</p>
<p>Perhaps we can recall the example from <a href="48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml">Chapter 2</a>, <em>Modules, Packages, and Type Concepts</em>. Back then, we created a <kbd>Calculator</kbd> module that defines two interest rate-related functions and a <kbd>Mortgage</kbd> sub-module that defines a payment calculator function. The <kbd>Calculator</kbd> module file has the following source code:</p>
<pre># Calculator.jl<br/>module Calculator<br/><br/>include("Mortgage.jl")<br/><br/>export interest, rate<br/><br/>function interest(amount, rate)<br/>    return amount * (1 + rate)<br/>end<br/><br/>function rate(amount, interest)<br/>    return interest / amount<br/>end<br/><br/>end # module</pre>
<p>Furthermore, the sub-module contains the following code:</p>
<pre># Mortgage.jl<br/>module Mortgage<br/><br/>function payment(amount, rate, years)<br/>    # TODO code to calculate monthly payment for the loan<br/>    return 100.00<br/>end <br/><br/>end # module</pre>
<p>Let's look into how to reference functions and symbols from a sub-module and vice versa.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Referencing symbols defined in sub-modules</h1>
                </header>
            
            <article>
                
<p>To begin, we can finish our implementation of the <kbd>Mortgage</kbd> sub-module with a real implementation of the <kbd>payment</kbd> function.</p>
<p>Let's see how this works:</p>
<ol>
<li>The <kbd>payment</kbd> function takes a loan amount, an annual interest rate, the number of years for the loan, and calculates the monthly payment of the loan, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"># Mortgage.jl<br/>module Mortgage<br/><br/>function payment(amount, rate, years)<br/>    monthly_rate = rate / 12.0<br/>    factor = (1 + monthly_rate) ^ (years * 12.0)<br/>    return amount * (monthly_rate * factor / (factor - 1))<br/>end <br/><br/>end # module</pre>
<ol start="2">
<li>At this point,<span> the </span><kbd>Calculator</kbd><span> module </span>should be able to use<span> the </span><kbd>Mortgage</kbd><span> sub-</span>module as if it's yet another module, except that the notation to get access to the sub-module requires a relative path that is prefixed with a dot notation:</li>
</ol>
<pre style="padding-left: 60px"># Calculator.jl<br/>module Calculator<br/><br/># include sub-modules<br/>include("Mortgage.jl")<br/>using .Mortgage: payment<br/><br/># functions for the main module<br/>include("funcs.jl")<br/><br/>end # module</pre>
<p style="padding-left: 60px"><span>Here, we have brought the </span><kbd>payment</kbd><span> function into the current scope of the sub-module via </span><kbd>using .Mortgage: payment</kbd>. </p>
<ol start="3">
<li>In order to organize our code better, we have also moved the functions into a separate file called <kbd>funcs.jl</kbd>. The code is shown as follows:</li>
</ol>
<pre style="padding-left: 60px"># funcs.jl - common calculation functions<br/><br/>export interest, rate, mortgage<br/><br/>function interest(amount, rate)<br/>    return amount * (1 + rate)<br/>end<br/><br/>function rate(amount, interest)<br/>    return interest / amount<br/>end<br/><br/># uses payment function from Mortgage.jl<br/>function mortgage(home_price, down_payment, rate, years)<br/>    return payment(home_price - down_payment, rate, years)<br/>end</pre>
<p>As we can see, the new <kbd>mortgage</kbd> function can use the <kbd>payment</kbd> function from the Mortgage sub-module now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Referencing symbols from the parent module</h1>
                </header>
            
            <article>
                
<p>If the sub-module needs access to any symbol from the parent module, then the sub-module may use the <kbd>import</kbd> or <kbd>using</kbd> statement while adding <kbd>..</kbd> as a prefix to the name of the parent module. This is shown with the following code:</p>
<pre># Mortgage.jl<br/>module Mortgage<br/><br/># access to parent module's variable<br/>using ..Calculator: days_per_year<br/><br/>end # module  </pre>
<p>Now, the <kbd>Mortgage</kbd> sub-module has access to the <kbd>days_per_year</kbd> constant from the parent module. </p>
<p>Having the ability to reference symbols and functions between modules and sub-modules allows us to just reorganize code into various sub-modules and keep it working as before. However, the reason for separating code into sub-modules in the first place is to allow the developer to work in each module independently. In addition, having bidirectional references could lead to confusion and messy spaghetti code.</p>
<p>Next, we will discuss how to reduce such coupling among modules and sub-modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing bidirectional coupling</h1>
                </header>
            
            <article>
                
<p>When we have a module (or sub-module) referencing another sub-module and vice versa, it increases coupling between these components. Generally speaking, it is best to avoid bidirectional dependency between the parent module and the sub-module because it introduces tight coupling and makes the code difficult to understand and debug. How can we fix this? Let's explore this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing data as function arguments</h1>
                </header>
            
            <article>
                
<p>The first solution is to pass the required data as a function argument. Suppose that the <kbd>payment</kbd> function from the <kbd>Mortgage</kbd> sub-module can take a <kbd>days_per_year</kbd> <span>keyword argument,</span> then the <kbd>Calculator</kbd> module can just pass the value as follows:</p>
<pre># Calculator.jl<br/>module Calculator<br/><br/>const days_per_year = 365<br/><br/>include("Mortgage.jl")<br/>using .Mortgage: payment<br/><br/>function do_something()<br/>    return payment(1000.00, 3.25, 5; days_per_year = days_per_year)<br/>end<br/><br/>end # module</pre>
<p>Hence, the <kbd>Mortgage</kbd> sub-module does not really need to reference the <kbd>days_per_year</kbd> symbol from <kbd>Calculator</kbd> anymore, reducing any unnecessary dependency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Factoring common code as another sub-module</h1>
                </header>
            
            <article>
                
<p>Another solution is to split the dependent member into a separate sub-module and have both existing modules depend on the new sub-module.</p>
<p>Suppose that we have two sub-modules set up in a way that they use functions from each other. Consider the scenario depicted in the diagram as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/98b3b41e-4aaf-4f6e-b58f-b92714723954.png" style="width:28.58em;height:10.08em;"/></p>
<p><span>The </span><kbd>func1</kbd><span> function from the first sub-module uses </span><kbd>func6</kbd><span> from the other sub-module. And, the </span><kbd>func4</kbd><span> function from the other sub-module needs to call the </span><kbd>func3</kbd><span> function from the first module. Clearly, there is a high coupling between these two modules.</span></p>
<p>Considering the dependencies between these modules, it looks like a cycle as the first sub-module depends on the second sub-module and vice versa. To fix that, we can introduce a new sub-module to break the cycle as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d65272c2-b4ee-4f24-ab5a-4bdae82135c7.png" style="width:32.42em;height:15.83em;"/></p>
<p>Breaking the cycle has the benefit of a cleaner dependency graph. It also makes the code easier to understand.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Considering splitting into top-level modules</h1>
                </header>
            
            <article>
                
<p>If we are already considering creating sub-modules, it may be a good time to consider splitting the code into top-level modules. These top-level modules can be put together as separate Julia packages. </p>
<p>Let's take a look at the benefits and potential issues for making new top-level modules:</p>
<p>The benefits of having separate top-level modules are as follows:</p>
<ul>
<li>Each package can have its own release life cycle and version. It is possible to make changes to a package and release only that portion.</li>
<li>Version compatibility is enforced by Julia's <kbd>Pkg</kbd> system. A new version of the package may be released, and it may be used by another package as long as the package versions are compatible.</li>
<li>Packages are more reusable because they can be utilized by other applications.</li>
</ul>
<p>Potential issues with top-level modules are as follows:</p>
<ul>
<li>There is more management overhead because each package will be maintained and released independently.</li>
<li>Deployment may be more difficult since multiple packages have to be installed and inter dependent packages must obey version compatibility requirements.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the counterarguments of using sub-modules</h1>
                </header>
            
            <article>
                
<p><span><span>You</span></span> are advised to avoid this pattern under the following conditions:</p>
<ul>
<li>When the existing code base is not large enough, splitting into sub-modules too early hinders the speed of development. We should avoid doing this prematurely.</li>
<li>When there is a high coupling in the source code, it can be difficult to split the code. In that case, try to refactor the code to reduce coupling and then reconsider splitting code into sub-modules later. </li>
</ul>
<p><span>The idea of creating sub-modules does force the programmer to think about code dependencies. </span>It is a necessary step when the application eventually grows bigger.</p>
<p>Next, we will discuss the k<span>eyword definition pattern, which allows us to </span>construct objects with more readable code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keyword definition pattern</h1>
                </header>
            
            <article>
                
<p>In Julia, you can create an object using the default constructor, which accepts a list of positional arguments for each of the fields defined for the struct. For small objects, this should be simple and straightforward. For larger objects, it becomes confusing because it is hard to remember which argument corresponds to which field without referring to the struct's definition every time we write code to create such objects.</p>
<p><span>In 1956, George Miller, a psychologist, published </span><span>research that involved figuring out how many random digits a person could remember at any time, so the Bell System could decide how many numbers to use for the format of a telephone number. He found that most people can only remember five to nine digits at any time.</span></p>
<p><span>If remembering digits is difficult enough, it should be even more difficult to remember fields that come with different names and types.</span></p>
<p>We will discuss how to reduce such stress when developing Julia code, and how it can be done using the <kbd>@kwdef</kbd> macro so that the code is easy to read and maintain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Revisiting struct definitions and constructors</h1>
                </header>
            
            <article>
                
<p>Let's first take a look at how a struct is defined and what constructor is provided. Consider the use case of text style configuration for a text editing application.</p>
<p>We may define a struct as follows:</p>
<pre>struct TextStyle<br/>    font_family<br/>    font_size<br/>    font_weight<br/>    foreground_color<br/>    background_color<br/>    alignment<br/>    rotation<br/>end</pre>
<p>By default, Julia provides a constructor with positional arguments for all fields in the same order as how they are defined in the struct. So, the only way to create a <kbd>TextStyle</kbd> object is to do the following:</p>
<pre>style = TextStyle("Arial", 11, "Bold", "black", "white", "left", 0)</pre>
<p>There is nothing wrong here, but we could argue that the code is not very readable. Every time we have to write code to create a <kbd>TextStyle</kbd> object, we must ensure that all arguments are specified in the right order. In particular, as a developer, I must remember that the first three arguments represent font settings, then followed by two colors where the foreground color comes first, <span>and so on</span>. In the end, I just give up and go back to revisit the struct definition again.</p>
<p>Another issue is that we may want to have default values for some fields. For example, we want the <kbd>alignment</kbd> field to have a value of <kbd>"left"</kbd> and the <kbd>rotation</kbd> field to have <kbd>0</kbd> by default. The default constructor does not provide an easy way to do that.</p>
<p>A more sensible syntax for creating objects with so many arguments is to use keyword arguments in the constructor. Let's try to implement that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using keyword arguments in constructors</h1>
                </header>
            
            <article>
                
<p>We can always add new constructor functions to make it easier for creating objects. Using keyword arguments solves the following two problems:</p>
<ul>
<li>Code readability</li>
<li>Ability to specify default values</li>
</ul>
<p>Let's go ahead and define a new constructor as follows:</p>
<pre>function TextStyle(;<br/>        font_family,<br/>        font_size,<br/>        font_weight = "Normal",<br/>        foreground_color = "black",<br/>        background_color = "white", <br/>        alignment = "left",<br/>        rotation = 0)<br/>    return TextStyle(<br/>        font_family,<br/>        font_size,<br/>        font_weight,<br/>        foreground_color,<br/>        background_color,<br/>        alignment,<br/>        rotation)<br/>end</pre>
<p>Here, we have elected to provide default values for most of the fields except <kbd>font_family</kbd> and <kbd>font_size</kbd>. It is simply defined as a function that provides keyword arguments for all fields in the struct. Creating the <kbd>TextStyle</kbd> object is much easier and the code is more readable now. In fact, we have obtained an additional benefit that the arguments can be specified in any order, as shown here:</p>
<pre>style = TextStyle(<br/>    alignment = "left",<br/>    font_family = "Arial",<br/>    font_weight = "Bold",<br/>    font_size = 11)</pre>
<p>This is, indeed, quite a simple recipe. We can just create this kind of constructor for every struct and the problem is solved. Right? Well, yes and no. While it is fairly easy to create these constructors, it is a hassle to do that for every struct everywhere. </p>
<p>In addition, the constructor definition must specify all field names in the function arguments, and these fields repeat in the body of the function. So, it becomes quite difficult to develop and maintain. Next, we will introduce a macro to simplify our code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simplifying code with the @kwdef macro</h1>
                </header>
            
            <article>
                
<p>Given that the keyword definition pattern addresses a fairly common use case, there is already a macro provided by Julia to help define structs along with constructors accepting keyword arguments. The macro is currently not exported, but you can use it directly as follows:</p>
<pre>Base.@kwdef struct TextStyle<br/>    font_family<br/>    font_size<br/>    font_weight = "Normal"<br/>    foreground_color = "black"<br/>    background_color= "white"<br/>    alignment = "center"<br/>    rotation = 0<br/>end</pre>
<p>Basically, we can just place the <kbd>Base.@kwdef</kbd> macro in front of the type definition. As a part of the type definition, we can also provide default values. The macro automatically defines the struct and the corresponding constructor function with keyword arguments. We can see that by using the <kbd>methods</kbd> function as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/68a1d94e-98ea-4421-8749-e7ce9d0060d0.png" style="width:37.58em;height:7.83em;"/></p>
<p>From the output, we can see that the first method is the one that accepts keyword arguments. The second method is the default construct that requires positional arguments. Now, creating new objects is as convenient as we would like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bec42ace-4d81-424e-8dd6-ae877d28709f.png" style="width:37.33em;height:8.83em;"/></p>
<p>We should note that the <span>preceding </span>definition did not specify any default values for <kbd>font_family</kbd> and <kbd>font_size</kbd>. So, those fields are mandatory when creating a <kbd>TextStyle</kbd> object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/39324ebd-d6dd-4d85-b96b-0a5afab117f4.png" style="width:41.25em;height:15.67em;"/></p>
<p>Using this macro can greatly simplify object construction and make the code more readable. There is no reason not to use it everywhere.</p>
<div class="packt_infobox">As of Julia version 1.3, the <kbd>@kwdef</kbd> macro is not exported. There is a feature request to export it. Should you feel uncomfortable using non-exported features, consider using the <kbd>Parameters.jl</kbd> package instead.</div>
<p>Next, we will discuss code generation pattern, which allows us to create new functions dynamically so as to avoid writing repeated boilerplate code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code generation pattern</h1>
                </header>
            
            <article>
                
<p>New Julia programmers are often amazed by the conciseness of the language. Surprisingly, some of the very popular Julia packages are written with very little code. There are multiple reasons for that, but one major contributing factor is the ability to generate code dynamically in Julia.</p>
<p>In certain use cases, code generation can be extremely helpful. In this section, we will look into some code generation examples and try to explain how it can be done properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the file logger use case</h1>
                </header>
            
            <article>
                
<p>Let's consider a use case for building a file logging facility. </p>
<p>Suppose that we want to provide an API for logging messages to files based upon a set of logging levels. By default, we will support three levels: info, warning, and error. A logger facility is provided so that a message will be directed to a file, as long as it comes with a high enough logging level.</p>
<p>The functional requirements can be summarized as follows:</p>
<ul>
<li>An info-level logger accepts messages with info, warning, or error levels.</li>
<li>A warning-level logger <span>accepts messages with warning or error levels only.</span></li>
<li>An error-level logger <span>accepts messages with an error level only.</span></li>
</ul>
<p>To implement the file logger, we will first define some constants for the three logging levels:</p>
<pre>const INFO    = 1<br/>const WARNING = 2<br/>const ERROR   = 3</pre>
<p>These constants are designed to be in numerical order, so we can easily determine when a message has a logging level as high as what the logger can accept. Next, we define the <kbd>Logger</kbd> facility as follows:</p>
<pre>struct Logger<br/>    filename   # log file name<br/>    level      # minimum level acceptable to be logged<br/>    handle     # file handle<br/>end</pre>
<p>A <kbd>Logger</kbd> object carries the filename of the log file, the minimum level for which messages can be accepted by the logger, and a file handle that is used for saving data. We can provide a constructor for <kbd>Logger</kbd> as follows:</p>
<pre>Logger(filename, level) = Logger(filename, level, open(filename, "w"))</pre>
<p>The constructor automatically opens the specified file for writing. Now, we can develop the first logging function for info-level messages:</p>
<pre>using Dates<br/><br/>function info!(logger::Logger, args...)<br/>    if logger.level &lt;= INFO<br/>        let io = logger.handle<br/>            print(io, trunc(now(), Dates.Second), " [INFO] ")<br/>            for (idx, arg) in enumerate(args)<br/>                idx &gt; 0 &amp;&amp; print(io, " ")<br/>                print(io, arg)<br/>            end<br/>            println(io)<br/>            flush(io)<br/>        end<br/>    end<br/>end</pre>
<p>This function is designed to write the message into the file only if the <kbd>INFO</kbd> level is high enough to be accepted by the logger. It also prints the current time using the <kbd>now()</kbd> function and an <kbd>[INFO]</kbd> label in the log file. Then, it writes all the arguments separated by spaces and finally flushes the I/O buffer.</p>
<p>We can quickly test the code so far. First, we will use <kbd>info_logger</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d731f7c3-d00a-4de8-9c49-c8a7a8edf8c8.png" style="width:28.50em;height:8.92em;"/></p>
<p>The message is correctly logged in the <kbd>/tmp/info.log</kbd> file. What happens if we send an info-level message to an error-level logger? Let's take a look:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/28148c4d-920f-4977-9b26-23877000bd3f.png" style="width:31.17em;height:7.92em;"/></p>
<p>Now, this is a little more interesting. As expected, because the error-level logger only accepts a message with an <kbd>ERROR</kbd> level or higher, it did not pick up the info-level message. </p>
<p class="CDPAlignLeft CDPAlign">At this point, we may be tempted to quickly finish the two other functions: <kbd>warning!</kbd> and <kbd>error!</kbd> and call it the day. If we were determined to do that, the <kbd>warning!</kbd> function would look just like <kbd>info!</kbd>, with just a few small changes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99466ffe-e10b-46f3-8448-16b0520fe85d.png" style="width:68.83em;height:18.83em;"/></p>
<p>What are the differences between these two logging functions? Let's take a look:</p>
<ul>
<li>The function names are different: <kbd>info!</kbd> versus <kbd>warning!</kbd>.</li>
<li>The logging level constants are different: <kbd>INFO</kbd> <span>versus</span> <kbd>WARNING</kbd>.</li>
<li>The labels are different: <kbd>[INFO]</kbd> <span>versus</span> <kbd>[WARNING]</kbd>.</li>
</ul>
<p>Other than these, both functions shared the exact same code. Of course, we can just keep going and wrap up the project by writing <kbd>error!</kbd> the same way. However, this is not the best solution. Imagine that if the core logging logic needs to be changed, for example, the formatting of log messages, then we have to make the same change in three different functions. Worse yet, if we forget to modify all of these functions, then we end up with inconsistent logging formats. After all, we have violated the <strong><span>Don't Repeat Yourself</span></strong> (<strong>DRY</strong>) principle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code generation for function definitions</h1>
                </header>
            
            <article>
                
<p><span>Code generation is one way to tackle this problem, as mentioned in the preceding section. What we will do is to build up the syntax of defining the function and then throw that into a loop to define all three logging functions. Here is how the code may look:</span></p>
<pre>for level in (:info, :warning, :error)<br/>    lower_level_str = String(level)<br/>    upper_level_str = uppercase(lower_level_str)<br/>    upper_level_sym = Symbol(upper_level_str)<br/><br/>    fn = Symbol(lower_level_str * "!")<br/>    label = " [" * upper_level_str * "] "<br/><br/>    @eval function $fn(logger::Logger, args...)<br/>        if logger.level &lt;= $upper_level_sym<br/>            let io = logger.handle<br/>                print(io, trunc(now(), Dates.Second), $label)<br/>                for (idx, arg) in enumerate(args)<br/>                    idx &gt; 0 &amp;&amp; print(io, " ")<br/>                    print(io, arg)<br/>                end<br/>                println(io)<br/>                flush(io)<br/>            end<br/>        end<br/>    end<br/>end</pre>
<p>The explanation for the preceding code is as follows:</p>
<ul>
<li>As we need to define functions for three logging levels, we have created a loop that goes through a list of symbols: <kbd>:info</kbd>, <kbd>:warning</kbd>, and <kbd>:error</kbd>.</li>
<li>Inside the loop, we can see the function name as <kbd>fn</kbd>, the label as <kbd>label</kbd>, and the constant for log level comparison (such as <kbd>INFO</kbd>, <kbd>WARN</kbd>, or <kbd>ERROR</kbd>) as <kbd>upper_level_sym</kbd>.</li>
<li>We use the <kbd>@eval</kbd> macro to define the logging function, where the <kbd>fn</kbd> variables, <kbd>label</kbd>, and <kbd>upper_level_sym</kbd> are interpolated into the function body.</li>
</ul>
<p>After running the code in the Julia REPL, all three functions: <kbd>info!</kbd>, <kbd>warning!</kbd>, and <kbd>error!</kbd> should be defined already. For testing, we can call these with three different kinds of loggers.</p>
<p>Let's try <kbd>info_logger</kbd> first:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/62f6e51d-9509-4d00-9246-10768d779e96.png" style="width:29.50em;height:16.58em;"/></p>
<p>As expected, all messages are logged to the file because <kbd>info_logger</kbd> can take messages at any level. Next, let's test <kbd>error_logger</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/94f9b0a0-7fb2-4aec-80bc-2abd03890dc1.png" style="width:32.58em;height:14.83em;"/></p>
<p>In this case, only the error-level message was written to the log file. The <kbd>error_logger</kbd> code effectively filtered out any message that is lower than the error level.</p>
<p>Although we are quite satisfied with the resulting code, do we know what actually happened behind the scenes? How do we debug the code that we cannot even see? Let's take a look at this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging code generation</h1>
                </header>
            
            <article>
                
<p>Given that the code is generated behind the scene, it may feel a little awkward when we cannot even see what the generated code will look like. How can we guarantee that the generated code is exactly what we expect after all those interpolations of variables?</p>
<p>Fortunately, there is a package called <kbd>CodeTracking</kbd> that can make debugging code generation easier. We will see how it works here.</p>
<p>From the previous section, we should have generated three functions: <kbd>info!</kbd>, <kbd>warning!</kbd>, and <kbd>error!</kbd>. As these are defined as generic functions, we can examine what methods are defined for each. Let's take <kbd>error!</kbd> as an example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/86de4703-1c0c-4442-8f10-3ee14a317872.png" style="width:32.67em;height:4.33em;"/></p>
<p>In this case, we only have a single method. We can get to the method object itself using the <kbd>first</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/44a8f083-716a-46bb-a0e6-97605cdb71df.png" style="width:32.00em;height:3.17em;"/></p>
<p>Once we have a reference of the method object, we can lean on <kbd>CodeTracking</kbd> to reveal the source code of the generated function. In particular, we can use the <kbd>definition</kbd> function, which takes a method object and returns an expression object. In order to use this function, we also need to load the <kbd>Revise</kbd> package. Enough said, let's try the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed446f67-790b-493c-8c8b-62994d639e3b.png" style="width:33.58em;height:27.58em;"/></p>
<p>Here, we can clearly see that the variables are interpolated correctly; the <kbd>logger.level</kbd> variable is compared with the <kbd>ERROR</kbd> constant, and the logging label correctly contains the <kbd>[ERROR]</kbd> string.</p>
<p>We can also see that line numbers are included in the output. Since we defined the functions from the REPL, the line numbers are less useful. If we would have generated the functions from a module that is stored in a file, the filename and line number information would be much more interesting.</p>
<p>The line number nodes seem to be a bit too distracting here, though. We can easily remove them using the <kbd>rmlines</kbd><span> function from the </span><kbd>MacroTools</kbd> package:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/27505180-7291-42e6-9a58-4ae8cffb4c76.png" style="width:37.67em;height:18.83em;"/></p>
<p>The <kbd>MacroTools.postwalk</kbd> function is used to apply the <kbd>rmlines</kbd> function to every node in the abstract syntax tree. The <kbd>postwalk</kbd> function is necessary because the <kbd>rmlines</kbd> function only works with the current node.</p>
<p>Now that we understand how to do code generation properly, let's turn around and ask ourselves—is code generation really necessary? Are there any other alternatives? Let us see in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Considering options other than code generation</h1>
                </header>
            
            <article>
                
<p>Throughout this section, we have been focusing on code generation techniques. The premise is that we can easily add a new function that works just like an existing one but a little differently. In practice, code generation is not the only option we have on hand. </p>
<p>Let's continue our discussion with the same example. As we recall, we wanted to add the <kbd>warning!</kbd> and <kbd>error!</kbd> functions after defining the logic for <kbd>info!</kbd>. If we take a step back, we can generalize the <kbd>info!</kbd> function and make it handle different logging levels. This can be done as follows:</p>
<pre>function logme!(level, label, logger::Logger, args...)<br/>    if logger.level &lt;= level<br/>        let io = logger.handle<br/>            print(io, trunc(now(), Dates.Second), label)<br/>            for (idx, arg) in enumerate(args)<br/>                idx &gt; 0 &amp;&amp; print(io, " ")<br/>                print(io, arg)<br/>            end<br/>            println(io)<br/>            flush(io)<br/>        end<br/>    end<br/>end</pre>
<p>The <kbd>logme!</kbd> function looks exactly like <kbd>info!</kbd> before, except that it takes two extra arguments: <kbd>level</kbd> and <kbd>label</kbd>. These variables are taken and used in the body of the function. Now we can define all three logging functions as follows:</p>
<pre>info!   (logger::Logger, msg...) = logme!(INFO,    " [INFO] ",    logger, msg...)<br/>warning!(logger::Logger, msg...) = logme!(WARNING, " [WARNING] ", logger, msg...)<br/>error!  (logger::Logger, msg...) = logme!(ERROR,   " [ERROR] ",   logger, msg...)</pre>
<p>As we can see, we have solved the original problem using a regular structured programming technique, and we have minimized as much repetitive code as possible.</p>
<div class="packt_tip">In this case, the only variation between these functions are simple types: a constant and a string. In another situation, we may need to call different functions within the body. That is okay as well because functions are first-class in Julia, and so we could just pass around a reference of the function.</div>
<p>Can we do better? Yes. The code can be simplified a little more using closure technique. To illustrate the concept, let's define a new <kbd>make_log_func</kbd> function as follows:</p>
<pre>function make_log_func(level, label)<br/>    (logger::Logger, args...) -&gt; begin<br/>        if logger.level &lt;= level<br/>            let io = logger.handle<br/>                print(io, trunc(now(), Dates.Second), " [", label, "] ")<br/>                for (idx, arg) in enumerate(args)<br/>                    idx &gt; 0 &amp;&amp; print(io, " ")<br/>                    print(io, arg)<br/>                end<br/>                println(io)<br/>                flush(io)<br/>            end<br/>        end<br/>    end<br/>end</pre>
<p>This function takes the <kbd>level</kbd> and <kbd>label</kbd> arguments and returns an anonymous function that contains the main logging logic. The <kbd>level</kbd> and <kbd>label</kbd> arguments are captured in a closure and used inside the anonymous function. So, we can now define the logging functions more easily as follows:</p>
<pre>info!    = make_log_func(INFO,    "INFO")<br/>warning! = make_log_func(WARNING, "WARNING")<br/>error!   = make_log_func(ERROR,   "ERROR")</pre>
<p>So, three anonymous functions are defined here: <kbd>info!</kbd>, <kbd>warning!</kbd>, and <kbd>error!</kbd> and they all work equally well.</p>
<div class="packt_infobox">In computer science terms, closure is a first-class function that captures variables from an enclosing environment. <br/>
<br/>
Technically speaking, there is a non-trivial difference between the structured programming solution and closure. The former technique defines generic functions that are named functions within the module that can be extended. In contrast, anonymous functions are unique and cannot be extended.</div>
<p>In this section, we have learned how to do code generation in Julia and how to debug this code. We have also discussed how to restructure code to achieve the same effect without having to use code generation technique. Both options are available.</p>
<p>Next, we will discuss <span>DSL</span>s, which is a technique for building syntax for specific domain usage, thereby making the code much easier to read and write.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Domain-specific language pattern</h1>
                </header>
            
            <article>
                
<p>Julia is a general purpose programming language that can be used effectively for any domain problem. However, <span>Julia is also one of the few programming languages that allows the developer to build new syntax to fit a specific domain usage.</span></p>
<p><span>So, a</span> DSL <span>is an example of <strong>Structured Query Language</strong> (<strong>SQL</strong>). SQL is designed to process data in a two-dimensional table structure. It is very powerful, and yet it is only appropriate when you need to handle data in tables.</span></p>
<p>There are a few prominent areas in the Julia ecosystem where a DSL is used extensively. The one that stood out the most is the <kbd>DifferentialEquations</kbd> package, which allows you to write differential equations in a form that is very close to their original mathematical notation. For example, consider the Lorenz system equations as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f6b39340-b267-4954-8a9a-1bc151c0a186.png" style="width:11.08em;height:6.58em;"/></p>
<p>The code to define these equations can be written as follows:</p>
<pre>@ode_def begin<br/>  dx = σ * (y - x)<br/>  dy = x * (ρ - z) - y<br/>  dz = x * y - β * z<br/>end σ ρ β</pre>
<p>As we can see, the syntax almost matches with the mathematical equations.</p>
<p>After this, in the next section, we will explore how to build our own DSL for a practical use case in computer graphics called L-System.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the L-System</h1>
                </header>
            
            <article>
                
<p>An <strong>L-System</strong>, also known as <strong>Lindenmayer System</strong>, is a formal syntax for describing how organisms evolve by way of simple patterns. It was first introduced in 1968 by Aristid Lindenmayer, a Hungarian biologist and botanist. An L-System can generate interesting patterns that mimic real-life shape and form. A well-known example is the growth of a specific algae, which can be modeled as follows:</p>
<pre style="padding-left: 30px">Axiom: A<br/>  Rule: A -&gt; AB<br/>  Rule: B -&gt; A</pre>
<p>Here is how it works. We always start with the axiom, in this case, the character <kbd>A</kbd>. For each generation, we apply the rules to every character in the string. If the character is A, then it is replaced with <kbd>AB</kbd>. Similarly, if the character is <kbd>B</kbd>, it is replaced with A. Let's work through the first five iterations:</p>
<ul>
<li class="mce-root"><kbd>A</kbd></li>
<li class="mce-root"><kbd>AB</kbd></li>
<li class="mce-root"><kbd>ABA</kbd></li>
<li class="mce-root"><kbd>ABAAB</kbd></li>
<li class="mce-root"><kbd>ABAABABA</kbd></li>
</ul>
<p>You may wonder, how does it even look like an algae? Here's a visualization of the growth from the first generation to the fifth generation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/11197064-fc9c-468d-b7c4-68b402e77e67.png" style="width:46.92em;height:16.58em;"/></p>
<p>There are many softwares that can produce interesting graphical visualizations based on L-Systems. An example is <strong>My Graphics</strong>, an iOS app developed by me. The application can produce several kinds of patterns such as the <span>preceding </span>algae example. An interesting sample called a <strong>Koch</strong> curve is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7f43bf6e-dc2d-4e82-a33a-e3cabf81b3fa.png" style="width:23.58em;height:19.83em;"/></p>
<p>Enough said. From what we know so far, the concept is fairly simple. What we are going to do next is design a DSL for the L-System.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing DSL for L-System</h1>
                </header>
            
            <article>
                
<p>The characteristics of a <span>DSL</span> are that the source code should look like the original representation of the domain concept. In this case, the domain concept is described by an axiom and a set of rules. Using the algae growth example, it needs to look like the following:</p>
<pre style="padding-left: 30px">Axiom: A<br/>  Rule: A -&gt; AB<br/>  Rule: B -&gt; A</pre>
<p>If we try to write them in plain Julia language, we may end up with code like this:</p>
<pre>model = LModel("A")<br/>add_rule!(model, "A", "AB")<br/>add_rule!(model, "B", "A")</pre>
<p>As we can see, this is not ideal. While the code is neither long nor difficult to read, it does not look as clean as the L-System grammar. What we really want is to build a DSL that lets us specify the model as follows:</p>
<pre>model = @lsys begin<br/>    axiom : A<br/>    rule  : A → AB<br/>    rule  : B → A<br/>end</pre>
<p>This will be the target syntax for our DSL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reviewing the L-System core logic</h1>
                </header>
            
            <article>
                
<p>As part of this example, we will develop an L-System package <span>together. Before we jump into the DSL implementation, let's take a quick detour and understand how the core logic works. Knowledge of the API allows us to design and test DSL properly.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing the LModel object</h1>
                </header>
            
            <article>
                
<p>To develop the <kbd>LModel</kbd> object, perform the following steps:</p>
<ol>
<li>Let's first create a type called <kbd>LModel</kbd> to keep track of the axiom and the set of rules. The struct can be defined as follows:</li>
</ol>
<pre style="padding-left: 60px">struct LModel<br/>    axiom<br/>    rules<br/>end</pre>
<ol start="2">
<li>Then, we can add a constructor that populates the <kbd>axiom</kbd> field and initializes the <kbd>rules</kbd> field:</li>
</ol>
<pre style="padding-left: 60px">"Create a L-system model."<br/>LModel(axiom) = LModel([axiom], Dict())</pre>
<ol start="3">
<li>By design, the axiom is an array of a single element. The rules are captured in a dictionary for fast lookups. An <kbd>add_rule!</kbd> function is also written to append new rules to the model:</li>
</ol>
<pre style="padding-left: 60px">"Add rule to a model."<br/>function add_rule!(model::LModel, left::T, right::T) where {T &lt;: AbstractString}<br/>    model.rules[left] = split(right, "")<br/>    return nothing<br/>end</pre>
<p style="padding-left: 60px">We have used the <kbd>split</kbd> function to convert a string into an array of single-character strings. </p>
<ol start="4">
<li>Lastly, we add a <kbd>Base.show</kbd> function j<span>ust so we can display a model nicely on Terminal:</span></li>
</ol>
<pre style="padding-left: 60px">"Display model nicely."<br/>function Base.show(io::IO, model::LModel)<br/>    println(io, "LModel:")<br/>    println(io, " Axiom: ", join(model.axiom))<br/>    for k in sort(collect(keys(model.rules)))<br/>        println(io, " Rule: ", k, " → ", join(model.rules[k]))<br/>    end<br/>end</pre>
<p>Having defined these functions, we can quickly verify our code as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93e1e95f-951f-4c90-b6e4-0e5b83c6c526.png" style="width:24.33em;height:14.25em;"/></p>
<p>Next, we will work on the core logic that takes a model and keeps track of the current state of the iteration.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing the state object</h1>
                </header>
            
            <article>
                
<p>To simulate the growth of an L-System model, we can develop an <kbd>LState</kbd> type that keeps track of the current state of the growth. It's a simple type that just keeps a reference to the model, the current iteration of growth, and the current result. For this, consider the following code:</p>
<pre>struct LState<br/>    model<br/>    current_iteration<br/>    result<br/>end</pre>
<p>The constructor just needs to take the model as the only argument. It defaults <kbd>current_iteration</kbd> to <kbd>1</kbd> and defaults <kbd>result</kbd> to the axiom of the model, as shown here:</p>
<pre>"Create a L-system state from a `model`."<br/>LState(model::LModel) = LState(model, 1, model.axiom)</pre>
<p>We need a function to advance to the next stage of the growth. So, we just provide a <kbd>next</kbd> function:</p>
<pre>function next(state::LState)<br/>    new_result = []<br/>    for el in state.result<br/>        # Look up `el` from the rules dictionary and append to `new_result`.<br/>        # Just default to the element itself when it is not found<br/>        next_elements = get(state.model.rules, el, el)<br/>        append!(new_result, next_elements)<br/>    end<br/>    return LState(state.model, state.current_iteration + 1, new_result)<br/>end</pre>
<p>Basically, given the current state, it iterates all the elements of the current result and expands each element using the rules from the model. The <kbd>get</kbd> function looks up the element in the dictionary. If it is not found, it defaults to itself. The expanded elements are just appended to the <kbd>new_results</kbd> array.</p>
<p>At the end, a new <kbd>LState</kbd> object is created with the next iteration number and the new result. For a better display in Terminal, we can add a <kbd>Base.show</kbd> method for <kbd>LState</kbd> as follows:</p>
<pre>"Compact the result suitable for display"<br/>result(state::LState) = join(state.result)<br/><br/>Base.show(io::IO, s::LState) = <br/>    print(io, "LState(", s.current_iteration, "): ", result(s))</pre>
<p>The <kbd>result</kbd> function just combines all the elements of the array into a single string. The <kbd>show</kbd> function displays both the current iteration number and the result string.</p>
<p>We should have a fully functional system now. Let's try to simulate the growth of the algae:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7bb3bc5f-13e5-4d83-8a91-a198c3b367b7.png" style="width:17.92em;height:16.08em;"/></p>
<p><em>Wonderful!</em> Now that the functionalities are built, we can move on to the interesting part of this chapter—how to create a <span>DSL</span> with the L-System syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a DSL for L-System</h1>
                </header>
            
            <article>
                
<p>Recall from the previous section that we want to have a clean syntax for defining an L-System model. From a metaprogramming perspective, we just need to translate the code from one abstract syntax tree to another. The following diagram shows graphically what kind of translation is required:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/42dd569b-7dda-480b-a0d6-049a50183069.png" style="width:34.00em;height:5.75em;"/></p>
<p class="mce-root">It turns out that the translation is quite straightforward. When we encounter an axiom, we translate the code to construct<span> a new</span> <kbd>LModel</kbd> <span>object. When we encounter a rule, we translate the code to an </span><kbd>add_rule!</kbd> <span>function call.</span></p>
<p>While it seems easy enough, this kind of source-to-source translation can be greatly simplified using pre-existing tools. In particular, the MacroTools package contains some very useful macros and functions for handling these cases. Let's first learn about the tool and then we can utilize them in developing our <span>DSL</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the @capture macro </h1>
                </header>
            
            <article>
                
<p>The <kbd>MacroTools</kbd> package provides a macro called <kbd>@capture</kbd> that can be used to match an expression against a pattern. As part of the matching process, it also assigns variables for which the developer wishes to capture the matched values.</p>
<p>The <kbd>@capture</kbd> macro accepts two arguments; the first one is an expression that needs to be matched, and the second one is a pattern used for matching. Consider the following example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/31789f4e-7b08-43e4-8516-8584c39ecf21.png" style="width:20.08em;height:4.83em;"/></p>
<p>The macro returns <kbd>true</kbd> when the pattern can be matched, or else it just returns <kbd>false</kbd>. When the pattern is matched, the variables ending with an underscore will be assigned in the current environment, with the underscore stripped away from the variable name. In the <span>preceding </span>example, because <kbd>x = 1</kbd> matches <kbd>x = val_</kbd>, it has returned <kbd>true</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9a760722-e681-4140-b3f0-b16648065432.png" style="width:5.92em;height:2.50em;"/></p>
<p>Because the pattern was matched successfully, a <kbd>val</kbd> variable was also assigned with the value of <kbd>1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Matching axiom and rule statements</h1>
                </header>
            
            <article>
                
<p>We can use the same trick to extract useful information from the <kbd>axiom</kbd> and rule statements. Let's do a quick experiment for the <kbd>axiom</kbd> statement, which consists of the word axiom, a colon, and a symbol. Matching it with the <kbd>@capture</kbd> macro is pretty slick as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/449c89e9-68ce-4a4f-b9e6-b57467fd0180.png" style="width:25.00em;height:9.42em;"/></p>
<p>Matching a <kbd>rule</kbd> statement is just as easy. The only difference is that we want to match the original symbol and the corresponding replacement symbol, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7eca749b-ff39-43a6-bef2-e7996dd58f15.png" style="width:25.75em;height:12.08em;"/></p>
<p>Once matched, the <kbd>original</kbd> and <kbd>replacement</kbd> variables are assigned with the corresponding symbols from the rule. We can also observe that the matched variables are symbols rather than strings. As the <kbd>LModel</kbd> programming interface requires strings, we will have to perform an additional data conversion from the symbol in the <kbd>walk</kbd> function, which will be presented in the <em>Developing the macro for a DSL</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the postwalk function</h1>
                </header>
            
            <article>
                
<p>In order to traverse the whole abstract syntax tree, we can use the MacroTool's <kbd>postwalk</kbd> function. To understand how it works, we can play with a simple example, as outlined in the following steps:</p>
<ol>
<li>Let's create an expression object as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/793295b5-6846-4039-9f14-0958db34e525.png" style="width:12.67em;height:10.08em;"/></p>
<p style="padding-left: 60px">Here, we have used the <kbd>rmlines</kbd> function to remove the line number nodes since we do not need them in this exercise.</p>
<ol start="2">
<li>Then, we can use the <kbd>postwalk</kbd> function to traverse the tree and display everything that it has ever encountered:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c34e43a4-1669-45ba-a29e-817f56f21ab7.png" style="width:22.75em;height:23.00em;"/></p>
<p>The <kbd>postwalk</kbd> function accepts a function as its first argument and an expression as the second argument. As it traverses the tree, it calls the function with the sub-expression being visited. We can see that it considered every single leaf node (for example, <kbd>:x</kbd>) as well as every sub-tree from the expression such as <kbd>:(x = 1)</kbd>. It also includes the top-level expression as we can see at the bottom of the output. </p>
<div class="packt_tip">
<p>If we pay a little more attention to the order of the traversal, we realize that the<span> </span><kbd>postwalk</kbd><span> </span>function works from the bottom up, starting from the leaf nodes.</p>
MacroTools also provides a <kbd>prewalk</kbd> function that also traverses the tree. The difference between <kbd>prewalk</kbd> and <kbd>postwalk</kbd> is that <kbd>prewalk</kbd> would work from the top down rather than bottom up. You are encouraged to try that out and learn how they differ. <br/>
<br/>
For our use case, we can use either one.</div>
<p>Now that we know how to match expressions and traverse the tree, we have everything in our toolbox to develop our <span>DSL</span>. That's the fun part. <em>Let's go!</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing the macro for a DSL</h1>
                </header>
            
            <article>
                
<p>To support the <kbd>LModel</kbd> syntax, we have to match both the axiom and rule statements to how they are written in the model. </p>
<p>Let's get started by creating the <kbd>lsys</kbd> macro, as follows:</p>
<pre>macro lsys(ex)<br/>    return MacroTools.postwalk(walk, ex)<br/>end</pre>
<p>The macro simply uses <kbd>postwalk</kbd> to traverse the abstract syntax tree. The resulting expression is returned as is. The main translation logic actually resides in the <kbd>walk</kbd> function as follows:</p>
<pre>function walk(ex)<br/>    <br/>    match_axiom = @capture(ex, axiom : sym_)<br/>    if match_axiom<br/>        sym_str = String(sym)<br/>        return :( model = LModel($sym_str) )<br/>    end<br/>    <br/>    match_rule = @capture(ex, rule : original_ → replacement_)<br/>    if match_rule<br/>        original_str = String(original)<br/>        replacement_str = String(replacement)<br/>        return :(<br/>            add_rule!(model, $original_str, $replacement_str)<br/>        )<br/>    end<br/><br/>    return ex<br/>end</pre>
<p>Let's dissect the <span>preceding </span>code one portion at a time.</p>
<p>The <kbd>walk</kbd> function u<span>ses the <kbd>@capture</kbd> macro</span> to match the <kbd>axiom</kbd> and <kbd>rule</kbd> patterns. When there is a match, the corresponding symbols are converted to a string and then interpolated into the corresponding expression, and the final expression is returned. Consider this line of code:</p>
<pre>match_axiom = @capture(ex, axiom : sym_)</pre>
<p>The <kbd>@capture</kbd> macro call tries to match the expression with the <kbd>axiom : sym_</kbd> pattern, which is an <kbd>axiom</kbd> symbol, followed by a colon, and then followed by another symbol. Since the <kbd>sym_</kbd> target symbol ends with an underscore, if the match is successful, the <kbd>sym</kbd> variable would be assigned with the matched value. In the <kbd>algae</kbd> model example of the <em>Developing the state object</em> section, we would expect <kbd>sym</kbd> to be assigned with the <kbd>:A</kbd> symbol. Once matched, the following code is executed:</p>
<pre>    if match_axiom<br/>        sym_str = String(sym)<br/>        return :( model = LModel($sym_str) )<br/>    end</pre>
<p>The target expression simply constructs an <kbd>LModel</kbd> object and assigns it to the <kbd>model</kbd> variable. With the algae model, we can expect that the translated expression will look like this:</p>
<pre>model = LModel("A")</pre>
<p>Similarly, the <kbd>rule</kbd> statement can be matched using the pattern as follows:</p>
<pre>    match_rule = @capture(ex, rule : original_ → replacement_)</pre>
<p>The <kbd>original</kbd> and <kbd>replacement</kbd> variables are assigned, converted to a string, and interpolated into an <kbd>add_rule!</kbd> statement in the target expression.</p>
<p>From the <kbd>lsys</kbd> macro, the <kbd>walk</kbd> function is called by the <kbd>postwalk</kbd> function many times—once for each node and sub-tree of the abstract syntax tree. To see how <kbd>postwalk</kbd> generates the code, we can test it from the REPL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0cdd6c1f-f82e-4f83-9d86-35021d1b67f4.png" style="width:25.08em;height:14.17em;"/></p>
<p>As it turns out, we are not completely done yet because the translated statements sit inside a <kbd>quote</kbd> block and the return value of the block would come from the block's last expression, which is zero as the <kbd>add_rule!</kbd> function does not return any meaningful value.</p>
<p>This final change is actually the simple part. Let's modify the <kbd>@lsys</kbd> macro again as follows:</p>
<pre>macro lsys(ex)<br/>    ex = MacroTools.postwalk(walk, ex)<br/>    push!(ex.args, :( model ))<br/>    return ex<br/>end</pre>
<p>The <kbd>push!</kbd> function was used to add the <kbd>:( model )</kbd> expression at the end of the block. Let's test the macro expansion and see what it looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/952c0249-95a2-45cf-87f2-536ef8a95bb9.png" style="width:24.17em;height:13.58em;"/></p>
<p>It's good now! Finally, we can just use the macro as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ce5c24ec-e98a-4dd1-9f28-8ba825403542.png" style="width:17.58em;height:10.67em;"/></p>
<p><em>Awesome! </em>The <kbd>algae_model</kbd> example can now be constructed using our <span>little DSL. </span>As it turns out, developing a <span>DSL</span> is not difficult at all. Given excellent tools such as MacroTools, we can quickly come up with a set of translation patterns and manipulate an abstract syntax tree into whatever we want.</p>
<p><span>A DSL</span> is a great way to simplify the code and make it easier to maintain. It can be very useful in specific domain areas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have looked at several patterns related to improving the readability and maintainability of an application.</p>
<p>First, we learned about when a module becomes too large and when it should be considered for reorganization. We realized that coupling is an important consideration when splitting code into separate modules. Next, we discussed the problem of constructing objects that have many fields. We determined that using a keyword-based constructor can make the code more readable and can provide additional flexibility of supporting default values. We learned that the Julia Base module already provides a macro.</p>
<p>Then we explored how to do code generation, which is a convenient technique for dynamically defining many similar functions without having to repeat the code. We picked up a utility from <kbd>CodeTracking</kbd> to review the generated source code.</p>
<p>Finally, we went over details about how to develop DSLs. It is a good way to simplify code by mimicking the syntax with the original form of the domain concepts. We used an L-System as an example for developing a DSL. We picked up several utilities from the MacroTools package, where we can transform our source code by matching patterns. We learned how to use the <kbd>postwalk</kbd> function to examine and transform source code. And, pleasantly, we were able to complete the exercise with very little code.</p>
<p>In the next chapter, we will go over a set of patterns related to code safety. <em>Enjoy reading!</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">What is the difference between afferent and efferent coupling?</li>
<li class="mce-root">Why are bidirectional dependencies bad from a maintainability perspective?</li>
<li class="mce-root">What is an easy way to generate code on the fly?</li>
<li class="mce-root">What would be an alternative to code generation?</li>
<li class="mce-root">When and why should you consider building a <span>DSL</span>?</li>
<li class="mce-root">What are the tools available for developing a <span>DSL</span>?</li>
</ol>


            </article>

            
        </section>
    </body></html>