- en: '1'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: Principles of Artificial Intelligence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能原理
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Describe the various fields of AI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述人工智能的各个领域
- en: Explain the main learning models used in AI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释在AI中使用的的主要学习模型
- en: Explain why Python is a popular language for AI projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释为什么Python是AI项目的流行语言
- en: Model the state space in AI for a given game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为给定游戏在人工智能中建模状态空间
- en: In this chapter, you will learn about the purpose, fields, and applications
    of AI, coupled with a short summary of the features we'll use in Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解AI的目的、领域和应用程序，以及我们将使用的Python特性的简要概述。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: Before discussing different AI techniques and algorithms, we will look at the
    fundamentals of artificial intelligence and machine learning and go over a few
    basic definitions. Then, using engaging examples, we will move forward in the
    book. Real-world examples will be used to present the basic concepts of artificial
    intelligence in an easy-to-digest way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论不同的AI技术和算法之前，我们将探讨人工智能和机器学习的基础知识，并回顾一些基本定义。然后，通过引人入胜的例子，我们将继续在书中前进。将使用现实世界的例子以易于消化的方式展示人工智能的基本概念。
- en: 'If you want to be an expert at something, you need to be very good at the fundamentals.
    So, let''s begin by understanding what artificial intelligence is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在某个领域成为专家，你需要非常擅长基础知识。因此，让我们首先了解什么是人工智能：
- en: '**Definition** : Artificial Intelligence (AI) is a science that''s used to
    construct intelligence using hardware and software solutions.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**：人工智能（AI）是一门利用硬件和软件解决方案构建智能的科学。'
- en: It is inspired by reverse engineering, for example, in the way that neurons
    work in the human brain. Our brain consists of small units called neurons, and
    networks of neurons called neural networks. Beyond neural networks, there are
    many other models in neuroscience that can be used to solve real-world problems
    in artificial intelligence.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它受到逆向工程的影响，例如，在人类大脑中神经元工作的方式。我们的大脑由称为神经元的微小单元组成，以及称为神经网络的神经元网络。除了神经网络之外，还有许多其他神经科学模型可以用于解决人工智能中的现实世界问题。
- en: Machine learning is a term that is often confused with artificial intelligence.
    It originates from the 1950s, and it was first defined by Arthur Lee Samuel in
    1959.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是一个经常与人工智能混淆的术语。它起源于20世纪50年代，最早由亚瑟·李·塞缪尔在1959年定义。
- en: '**Definition** : Machine learning is a field of study concerned with giving
    computers the ability to learn without being explicitly programmed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**：机器学习是研究如何使计算机在没有明确编程的情况下获得学习能力的一个研究领域。'
- en: Tom Mitchell proposed a more mathematically precise definition of machine learning.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 托马斯·米切尔提出了一个更精确的数学定义的机器学习。
- en: '**Definition** : A computer program is said to learn from experience, E, with
    respect to a task, T, and a performance measure, P, if its performance on T, as
    measured by P, improves with experience E.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**：如果一个计算机程序在经验E、任务T和性能度量P方面，其性能随着经验E的提高而提高，那么我们说该程序从经验E中学习，关于任务T和性能度量P。'
- en: From these two definitions, we can conclude that machine learning is one way
    to achieve artificial intelligence. However, you can have artificial intelligence
    without machine learning. For instance, if you hardcode rules and decision trees,
    or you apply search techniques, you create an artificial intelligence agent, even
    though your approach has little to do with machine learning.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两个定义中，我们可以得出结论，机器学习是实现人工智能的一种方式。然而，你可以没有机器学习而拥有人工智能。例如，如果你硬编码规则和决策树，或者应用搜索技术，你创建了一个人工智能代理，尽管你的方法与机器学习关系不大。
- en: How does AI Solve Real World Problems?
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人工智能如何解决现实世界的问题？
- en: '**Artificial intelligence automates human intelligence based on the way human
    brain processes information.**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能通过模仿人类大脑处理信息的方式自动化人类智能。**'
- en: Whenever we solve a problem or interact with people, we go through a process.
    Whenever we limit the scope of a problem or interaction, this process can often
    be modeled and automated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们解决问题或与人互动时，我们都会经历一个过程。每当我们限制问题或互动的范围时，这个过程通常可以被建模和自动化。
- en: '**AI makes computers appear to think like humans.**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能使计算机看起来像人类一样思考。**'
- en: Sometimes, it feels like AI knows what we need. Just think about the personalized
    coupons you receive after shopping online. By the end of this book, you will understand
    that to choose the most successful products, you need to be shown how to maximize
    your purchases – this is a relatively simple task. However, it is also so efficient,
    that we often think that computers "know" what we need.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，感觉AI知道我们需要的。想想你在网上购物后收到的个性化优惠券。到这本书的结尾，你将理解，为了选择最成功的产品，你需要了解如何最大化你的购买——这是一个相对简单的任务。然而，它也如此高效，以至于我们常常认为计算机“知道”我们需要的。
- en: '**AI is performed by computers that are executing low-level instructions.**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**AI是由执行低级指令的计算机执行的。**'
- en: Even though a solution may appear to be intelligent, we write code, just like
    with any other software solutions. Even if we are simulating neurons, simple machine
    code and computer hardware executes the "thinking" process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个解决方案看起来很智能，我们编写的代码，就像任何其他软件解决方案一样。即使我们在模拟神经元，简单的机器代码和计算机硬件也在执行“思考”过程。
- en: Most AI applications have one primary objective. When we interact with an AI
    application, it seems human-like because it can restrict a problem domain to a
    primary objective. Therefore, we get a chance to break down complex processes
    and simulate intelligence with the help of low-level computer instructions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数AI应用都有一个主要目标。当我们与AI应用互动时，它看起来像人类，因为它可以将问题域限制在主要目标上。因此，我们有机会通过低级计算机指令来分解复杂的过程并模拟智能。
- en: '**AI may stimulate human senses and thinking processes for specialized fields.**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**AI可以刺激特定领域的人类感官和思维过程。**'
- en: We must simulate human senses and thoughts, and sometimes trick AI into believing
    that we are interacting with another human. In special cases, we can even enhance
    our own senses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须模拟人类的感觉和思维，有时甚至要欺骗AI，让它相信我们在与另一个人互动。在特殊情况下，我们甚至可以增强我们自己的感官。
- en: Similarly, when we interact with a chatbot, we expect the bot to understand
    us. We expect the chatbot or even a voice recognition system to provide a computer-human
    interface that fulfills our expectations. In order to meet these expectations,
    computers need to emulate the human thought processes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们与聊天机器人互动时，我们希望机器人能理解我们。我们希望聊天机器人或甚至语音识别系统能够提供一个满足我们期望的计算机-人界面。为了满足这些期望，计算机需要模拟人类的思维过程。
- en: Diversity of Disciplines
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学科多样性
- en: A self-driving car that couldn't sense that other cars were driving on the same
    highway would be incredibly dangerous. The AI agent needs to process and sense
    what is around it in order to drive the car. But that is itself is not enough.
    Without understanding the physics of moving objects, driving the car in a normal
    environment would be an almost impossible, not to mention deadly, task.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一辆无法感知到同一高速公路上其他车辆正在行驶的自动驾驶汽车将极其危险。AI代理需要处理和感知其周围的环境，以便驾驶汽车。但那还不够。如果不理解移动物体的物理学，在正常环境中驾驶汽车将是一项几乎不可能完成的任务，更不用说致命的任务了。
- en: 'In order to create a usable AI solution, different disciplines are involved.
    For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个可用的AI解决方案，需要涉及不同的学科。例如：
- en: '**Robotics:** To move objects in space'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器人学**：在空间中移动物体'
- en: '**Algorithm Theory:** To construct efficient algorithms'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法理论**：构建高效的算法'
- en: '**Statistics:** To derive useful results, predict the future, and analyze the
    past'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计学**：得出有用的结果，预测未来，分析过去'
- en: '**Psychology:** To model how the human brain works'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**心理学**：模拟人类大脑的工作方式'
- en: '**Software Engineering:** To create maintainable solutions that endure the
    test of time'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件工程**：创建可维护的解决方案，经受时间的考验'
- en: '**Computer Science or Computer Programming:** To implement our software solutions
    in practice'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机科学或计算机编程**：为了在实践中实施我们的软件解决方案'
- en: '**Mathematics** : To perform complex mathematical operations'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学**：执行复杂的数学运算'
- en: '**Control Theory** : To create feed-forward and feedback systems'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制理论**：创建前馈和反馈系统'
- en: '**Information Theory:** To represent, encode, decode, and compress information'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息论**：表示、编码、解码和压缩信息'
- en: '**Graph Theory:** To model and optimize different points in space and to represent
    hierarchies'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图论**：模拟和优化空间中的不同点，以及表示层次结构'
- en: '**Physics:** To model the real world'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理学**：模拟现实世界'
- en: '**Computer Graphics and Image Processing** to display and process images and
    movies'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机图形学和图像处理**：显示和处理图像和电影'
- en: In this book, we will cover a few of these disciplines. Remember, focus is power,
    and we are now focusing on a high-level understanding of artificial intelligence.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将介绍这些学科中的几个。记住，专注就是力量，我们现在正专注于对人工智能的高层次理解。
- en: Fields and Applications of Artificial Intelligence
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能的领域和应用
- en: Now that we know what Artificial Intelligence is, let's move on and investigate
    different fields in which AI is applied.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了什么是人工智能，那么让我们继续前进，调查人工智能应用的不同领域。
- en: '**Simulation of Human Behavior**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**人类行为模拟**'
- en: 'Humans have five basic senses simply divided into visual, auditory, kinesthetic,
    olfactory, and gustatory. However, for the purposes of understanding how to create
    intelligent machines, we can separate disciplines as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 人类有五种基本感官，简单分为视觉、听觉、动觉、嗅觉和味觉。然而，为了理解如何创建智能机器，我们可以将学科分为以下几类：
- en: Listening and speaking
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 听力和口语
- en: Understanding language
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解语言
- en: Remembering things
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆事物
- en: Thinking
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考
- en: Seeing
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看见
- en: Moving
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动
- en: A few of these are out of scope for us, because the purpose of this book is
    to understand the fundamentals. In order to move a robot arm, for instance, we
    would have to study complex university-level math to understand what's going on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些超出了我们的范围，因为这本书的目的是理解基础。例如，为了移动机器人手臂，我们可能需要学习复杂的大学水平数学来理解发生了什么。
- en: '**Listening and Speaking**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**听力和口语**'
- en: Using speech recognition system, AI can collect the information. Using speech
    synthesis, it can turn internal data into understandable sounds. Speech recognition
    and **speech synthesis** techniques deal with the recognition and construction
    of sounds humans emit or that humans can understand.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语音识别系统，人工智能可以收集信息。使用语音合成，它可以把内部数据转换成可理解的声音。语音识别和**语音合成**技术处理人类发出的或人类可以理解的声音的识别和构建。
- en: Imagine you are on a trip to a country where you don't speak the local language.
    You can speak into the microphone of your phone, expect it to "understand" what
    you say, and then translate it into the other language. The same can happen in
    reverse with the locals speaking and AI translating the sounds into a language
    you understand. Speech recognition and speech synthesis make this possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在一个你不会说当地语言的国家的旅行中。你可以对着手机的麦克风说话，期待它“理解”你所说的话，然后将其翻译成另一种语言。反之亦然，当地人说话，人工智能将声音翻译成你理解的语言。语音识别和语音合成使得这一切成为可能。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: An example of speech synthesis is Google Translate. You can navigate to [https://translate.google.com/](https://translate.google.com/)
    and make the translator speak words in a non-English language by clicking the
    loudspeaker button below the translated word.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 语音合成的例子是谷歌翻译。您可以访问[https://translate.google.com/](https://translate.google.com/)，点击翻译词下面的扬声器按钮，让翻译器用非英语语言朗读翻译后的单词。
- en: '**Understanding Language**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解语言**'
- en: We can understand natural language by processing it. This field is called **natural
    language processing,** or NLP for short.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过处理自然语言来理解自然语言。这个领域被称为**自然语言处理**，简称NLP。
- en: When it comes to natural language processing, we tend to learn languages based
    on **statistical learning.**
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到自然语言处理时，我们倾向于基于**统计学习**来学习语言。
- en: '**Remembering Things**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**记忆事物**'
- en: We need to represent things we know about the world. This is where creating
    **knowledge bases** and hierarchical representations called **ontologies** comes
    into play. Ontologies categorize things and ideas in our world and contain relations
    between these categories.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要表示我们对世界的了解。这就是创建**知识库**和称为**本体**的层次表示发挥作用的地方。本体将我们世界中的事物和思想分类，并包含这些类别之间的关系。
- en: '**Thinking**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**思考**'
- en: Our AI system has to be an expert in a certain domain by using an expert system.
    An **expert system** can be based on mathematical logic in a deterministic way,
    as well as in a fuzzy, non-deterministic way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的人工智能系统必须通过使用专家系统成为某个领域的专家。**专家系统**可以基于确定性数学逻辑，也可以基于模糊、非确定性的方式。
- en: The knowledge base of an expert system is represented using different techniques.
    As the problem domain grows, we create hierarchical ontologies.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 专家系统的知识库使用不同的技术来表示。随着问题领域的扩大，我们创建了层次化的本体。
- en: We can replicate this structure by modeling the network on the building blocks
    of the brain. These building blocks are called neurons, and the network itself
    is called a **neural network** .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在脑的构建块上建模网络来复制这种结构。这些构建块被称为神经元，而网络本身被称为**神经网络**。
- en: 'There is another key term you need to connect to neural networks: **deep learning**
    . Deep learning is deep because it goes beyond pattern recognition and categorization.
    Learning is imprinted into the neural structure of the network. One special deep
    learning task, for instance, is **object recognition** using **computer vision**
    .'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将另一个关键术语与神经网络联系起来：**深度学习**。深度学习之所以称为深度，是因为它超越了模式识别和分类。学习被印入了网络的神经网络结构中。例如，一个特殊的深度学习任务就是使用**计算机视觉**进行**物体识别**。
- en: '**Seeing**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉**'
- en: We have to interact with the real world through our senses. We have only touched
    upon auditory senses so far, in regard to speech recognition and synthesis. What
    if we had to see things? Then, we would have to create **computer vision** techniques
    to learn about our environment. After all, recognizing faces is useful, and most
    humans are experts at that.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过我们的感官与真实世界互动。到目前为止，我们只触及了听觉感官，在语音识别和合成方面。如果我们必须看到东西呢？那么，我们就必须创建**计算机视觉**技术来了解我们的环境。毕竟，识别面部是有用的，而且大多数人类都是这方面的专家。
- en: Computer vision depends on **image processing** . Although image processing
    is not directly an AI discipline, it is a required discipline for AI.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉依赖于**图像处理**。虽然图像处理不是直接的人工智能学科，但它却是人工智能的必备学科。
- en: '**Moving**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动**'
- en: Moving and touching are natural to us humans, but they are very complex tasks
    for computers. Moving is handled by **robotics** . This is a very math-heavy topic.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 移动和触摸对我们人类来说是自然而然的，但对计算机来说却是非常复杂的任务。移动由**机器人技术**处理。这是一个非常数学化的主题。
- en: Robotics is based on **control theory** , where you create a feedback loop and
    control the movement of your object based on the feedback gathered. Interestingly
    enough, control theory has applications in other fields that have absolutely nothing
    to do with moving objects in space. This is because the feedback loops required
    are similar to those modeled in economics.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人技术基于**控制理论**，其中你创建一个反馈回路，并根据收集到的反馈来控制你的物体运动。有趣的是，控制理论在其他领域也有应用，这些领域与在空间中移动物体毫无关系。这是因为所需的反馈回路与经济学中建模的回路相似。
- en: Simulating Intelligence – The Turing Test
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟智能 – 图灵测试
- en: Alan Turing, the inventor of the Turing machine, an abstract concept that's
    used in algorithm theory, suggested a way to test intelligence. This test is referred
    to as the **Turing test** in AI literature.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 阿兰·图灵，图灵机的发明者，一个在算法理论中使用的抽象概念，提出了一种测试智能的方法。这种测试在人工智能文献中被称为**图灵测试**。
- en: Using a text interface, an interrogator chats to a human and a chatbot. The
    job of the chatbot is to mislead the interrogator to the extent that they cannot
    tell whether the computer is human or not.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本界面，审问者与人类和聊天机器人聊天。聊天机器人的任务是误导审问者，使他们无法判断计算机是人还是机器。
- en: What disciplines do we need to pass the Turing test?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要哪些学科才能通过图灵测试？
- en: First of all, we need to understand a spoken language to know what the interrogator
    is saying. We do this by using **Natural Language Processing** **(** **NLP** **)**
    . We also have to respond.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要理解一种口语语言，以了解审问者说了什么。我们通过使用**自然语言处理**（**NLP**）来完成这项工作。我们还得做出回应。
- en: We need to be an expert on things that the human mind tends to be interested
    in. We need to build an **Expert System** of humanity, involving the taxonomy
    of objects and abstract thoughts in our world, as well as historical events and
    even emotions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要成为人类思维倾向于感兴趣的事物的专家。我们需要建立一个关于人类的知识**专家系统**，涉及我们世界中的物体分类和抽象思维，以及历史事件甚至情感。
- en: Passing the Turing test is very hard. Current predictions suggest we won't be
    able to create a system good enough to pass the Turing test until the late 2020's.
    Pushing this even further, if this is not enough, we can advance to the Total
    Turing Test, which also includes movement and vision.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图灵测试非常困难。目前的预测表明，我们可能要到2020年代后期才能创造出足够好的系统来通过图灵测试。更进一步，如果这还不够，我们可以推进到全面图灵测试，这还包括运动和视觉。
- en: AI Tools and Learning Models
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能工具和学习模型
- en: In the previous sections, we discovered the fundamentals of artificial intelligence.
    One of the core tasks for artificial intelligence is learning.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们发现了人工智能的基础。人工智能的一个核心任务是学习。
- en: '**Intelligent Agents**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能体**'
- en: When solving AI problems, we create an actor in the environment that can gather
    data from its surroundings and influence its surroundings. This actor is called
    an intelligent agent.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决人工智能问题时，我们在环境中创建一个可以收集其周围数据的演员，并影响其周围环境。这个演员被称为智能体。
- en: 'An intelligent agent:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 智能体：
- en: Is autonomous
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是自主的
- en: Observes its surroundings through sensors
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传感器观察其周围环境
- en: Acts in its environment using actuators
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器在其环境中行动
- en: Directs its activities toward achieving goals
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其活动直接指向实现目标
- en: Agents may also learn and have access to a knowledge base.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 智能体也可能学习和访问知识库。
- en: We can think of an agent as a function that maps perceptions to actions. If
    the agent has an internal knowledge base, perceptions, actions, and reactions
    may alter the knowledge base as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将智能体视为一个将感知映射到动作的函数。如果智能体有一个内部知识库，感知、动作和反应也可能改变知识库。
- en: Actions may be rewarded or punished. Setting up a correct goal and implementing
    a carrot and stick situation helps the agent learn. If goals are set up correctly,
    agents have a chance of beating the often more complex human brain. This is because
    the number one goal of the human brain is survival, regardless of the game we
    are playing. An agent's number one motive is reaching the goal itself. Therefore,
    intelligent agents do not get embarrassed when making a random move without any
    knowledge.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 行为可能会受到奖励或惩罚。设定一个正确目标并实施胡萝卜加大棒策略有助于智能体学习。如果目标设定得当，智能体有机会战胜通常更为复杂的人类大脑。这是因为人类大脑的首要目标是生存，无论我们玩什么游戏。智能体的首要动机是达到目标本身。因此，智能体在没有任何知识的情况下随机移动时不会感到尴尬。
- en: Classification and Prediction
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分类和预测
- en: 'Different goals require different processes. Let''s explore the two most popular
    types of AI reasoning: **classification** and **prediction** .'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的目标需要不同的过程。让我们探讨两种最流行的AI推理类型：**分类**和**预测**。
- en: '**Classification** is a process for figuring out how an object can be defined
    in terms of another object. For instance, a father is a male who has one or more
    children. If Jane is a parent of a child and Jane is female, then Jane is a mother.
    Also, Jane is a human, a mammal, and a living organism. We know that Jane has
    a nationality as well as a date of birth.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类**是一个确定一个对象如何用另一个对象来定义的过程。例如，父亲是一个有一个或多个孩子的男性。如果简是一个孩子的父母，并且简是女性，那么简就是一个母亲。此外，简是人类、哺乳动物和生物体。我们知道简还有国籍和出生日期。'
- en: '**Prediction** is the process of predicting things, based on patterns and probabilities.
    For instance, if a customer in a standard supermarket buys organic milk, the same
    customer is more likely to buy organic yoghurt than the average customer.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**预测**是根据模式和概率预测事物的过程。例如，如果一个在标准超市购物的顾客购买了有机牛奶，那么这个顾客比普通顾客更有可能购买有机酸奶。'
- en: Learning Models
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习模型
- en: The process of AI learning can be done in a supervised or unsupervised way.
    Supervised learning is based on labeled data and inferring functions from training
    data. Linear regression is one example. Unsupervised learning is based on unlabeled
    data and often works on cluster analysis.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能学习的过程可以是监督式或非监督式的。监督学习基于标记数据，并从训练数据中推断函数。线性回归是一个例子。非监督学习基于未标记数据，通常在聚类分析上工作。
- en: The Role of Python in Artificial Intelligence
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python在人工智能中的作用
- en: 'In order to put the basic AI concepts into practice, we need a programming
    language that supports artificial intelligence. In this book, we have chosen Python.
    There are a few reasons why Python is such a good choice for AI:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将基本的人工智能概念付诸实践，我们需要一种支持人工智能的编程语言。在这本书中，我们选择了Python。Python之所以成为人工智能的良好选择，有几个原因：
- en: Python is a **high-level programming language** . This means that you don't
    have to worry about memory allocation, pointers, or machine code in general. You
    can write code in a convenient fashion and rely on Python's robustness. Python
    is also **cross-platform compatible** .
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python是一种**高级编程语言**。这意味着你不必担心内存分配、指针或通用机器代码。你可以以方便的方式编写代码，并依赖Python的健壮性。Python也是**跨平台兼容**的。
- en: The strong emphasis on **developer experience** makes Python a very popular
    choice among software developers. In fact, according to a 2018 developer survey
    by [https://www.hackerrank.com](https://www.hackerrank.com) , across all ages,
    Python ranks as the number one preferred language of software developers. This
    is because Python is easily readable and simple. Therefore, Python is great for
    **rapid application development** .
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对**开发者体验**的强烈重视使Python成为软件开发人员非常受欢迎的选择。事实上，根据2018年[https://www.hackerrank.com](https://www.hackerrank.com)进行的一项开发者调查，在所有年龄段中，Python被评为软件开发人员首选的语言。这是因为Python易于阅读且简单。因此，Python非常适合**快速应用开发**。
- en: Despite being an interpreted language, Python is comparable to other languages
    used in data science such as R. Its main advantage is **memory efficiency** ,
    as Python can handle large, in-memory databases.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管Python是一种解释型语言，但它与数据科学中使用的其他语言（如R）相当。其主要优势是**内存效率**，因为Python可以处理大型内存数据库。
- en: Note
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Python is a multi-purpose language. It can be used to create desktop applications,
    database applications, mobile applications, as well as games. The network programming
    features of Python are also worth mentioning. Furthermore, Python is an excellent
    prototyping tool.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python是一种多用途语言。它可以用来创建桌面应用程序、数据库应用程序、移动应用程序以及游戏。Python的网络编程特性也值得提及。此外，Python是一个出色的原型设计工具。
- en: Why is Python Dominant in Machine Learning, Data Science, and AI?
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么Python在机器学习、数据科学和人工智能中占据主导地位？
- en: To understand the dominant nature of Python in machine learning, data science,
    and AI, we have to compare Python to other languages also used in these fields.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Python在机器学习、数据科学和人工智能中的主导地位，我们必须将Python与其他在这些领域中使用的语言进行比较。
- en: One of the main alternatives is R. The advantage of Python compared to R is
    that Python is more general purpose and more practical.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个主要的替代品是R。与R相比，Python的优势在于它更加通用且更实用。
- en: Compared to Java and C++, writing programs in Python is significantly faster.
    Python also provides a high degree of flexibility.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java和C++相比，用Python编写程序要快得多。Python还提供了高度的可灵活性。
- en: 'There are some languages that are similar in nature when it comes to flexibility
    and convenience: Ruby and JavaScript. Python has an advantage over these languages
    because of the AI ecosystem available for Python. In any field, open source, third-party
    library support vastly determines the success of that language. Python''s third-party
    AI library support is excellent.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在灵活性和便利性方面，有一些语言在性质上相似：Ruby和JavaScript。Python在这些语言中具有优势，因为Python拥有可用的AI生态系统。在任何领域，开源和第三方库的支持在很大程度上决定了该语言的成功。Python的第三方AI库支持非常出色。
- en: Anaconda in Python
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Anaconda在Python中
- en: We already installed Anaconda in the preface. Anaconda will be our number one
    tool when it comes to experimenting with artificial intelligence.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前言中安装了Anaconda。当涉及到实验人工智能时，Anaconda将成为我们的首选工具。
- en: This list is by far incomplete, as there are more than 700 libraries available
    in Anaconda. However, if you know these libraries, then you're off to a good start
    because you will be able to implement fundamental AI algorithms in Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表远远不完整，因为Anaconda中可用的库超过700个。然而，如果你了解这些库，那么你就已经迈出了良好的第一步，因为你可以用Python实现基本的AI算法。
- en: Anaconda comes with packages, IDEs, data visualization libraries, and high-performance
    tools for parallel computing in one place. Anaconda hides configuration problems
    and the complexity of maintaining a stack for data science, machine learning,
    and artificial intelligence. This feature is especially useful in Windows, where
    version mismatches and configuration problems tend to arise the most.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda提供了一站式的包、IDE、数据可视化库和高性能并行计算工具。Anaconda隐藏了数据科学、机器学习和人工智能配置问题以及维护堆栈的复杂性。这一特性在Windows上尤其有用，因为在那里版本不匹配和配置问题最容易出现。
- en: Anaconda comes with the IPython console, where you can write code and comments
    in documentation style. When you experiment with AI features, the flow of your
    ideas resembles an interactive tutorial where you run each step of your code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda附带IPython控制台，你可以在其中以文档风格编写代码和注释。当你实验AI功能时，你的思维流程类似于一个交互式教程，你可以运行代码的每个步骤。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: IDE stands for Integrated Development Environment. While a text editor provides
    some functionalities to highlight and format code, an IDE goes beyond the features
    of text editors by providing tools to automatically refactor, test, debug, package,
    run, and deploy code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: IDE代表集成开发环境。虽然文本编辑器提供了一些用于突出显示和格式化代码的功能，但IDE的功能超越了文本编辑器，它提供了自动重构、测试、调试、打包、运行和部署代码的工具。
- en: Python Libraries for Artificial Intelligence
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人工智能的Python库
- en: 'The list of libraries presented here is not complete as there are more than
    700 available in Anaconda. However, these specific ones will get you off to a
    good start, because they will give you a good foundation to be able to implement
    fundamental AI algorithms in Python:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的库列表并不完整，因为在Anaconda中还有700多个可用。然而，这些特定的库将帮助你有一个良好的开始，因为它们将为你提供一个坚实的基础，以便能够在Python中实现基本的AI算法：
- en: '**NumPy** : NumPy is a computing library for Python. As Python does not come
    with a built-in array data structure, we have to use a library to model vectors
    and matrices efficiently. In data science, we need these data structures to perform
    simple mathematical operations. We will extensively use NumPy in future modules.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NumPy**：NumPy是Python的计算库。由于Python没有内置的数组数据结构，我们必须使用库来高效地模拟向量和矩阵。在数据科学中，我们需要这些数据结构来执行简单的数学运算。我们将在未来的模块中广泛使用NumPy。'
- en: '**SciPy** : SciPy is an advanced library containing algorithms that are used
    for data science. It is a great complementary library to NumPy, because it gives
    you all the advanced algorithms you need, whether it be a linear algebra algorithm,
    image processing tool, or a matrix operation.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SciPy**：SciPy是一个包含用于数据科学算法的高级库。它是NumPy的一个很好的补充库，因为它为你提供了所有需要的先进算法，无论是线性代数算法、图像处理工具还是矩阵运算。'
- en: '**pandas** : pandas provides fast, flexible, and expressive data structures
    such as one-dimensional series and two-dimensional DataFrames. It efficiently
    loads, formats, and handles complex tables of different types.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pandas**：pandas提供了快速、灵活和表达性强的数据结构，如一维序列和二维DataFrame。它有效地加载、格式化和处理不同类型的复杂表格。'
- en: '**scikit-learn** : scikit-learn is Python''s main machine learning library.
    It is based on the NumPy and SciPy libraries. scikit-learn provides you with the
    functionality required to perform both classification and regression, data preprocessing,
    as well as supervised and unsupervised learning.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scikit-learn**：scikit-learn是Python的主要机器学习库。它基于NumPy和SciPy库。scikit-learn为你提供了执行分类和回归、数据预处理以及监督和非监督学习所需的功能。'
- en: '**NLTK** : We will not deal with natural language processing in this book but
    NLTK is still worth mentioning, because this library is the main natural language
    toolkit of Python. You can perform classification, tokenization, stemming, tagging,
    parsing, semantic reasoning, and many other services using this library.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NLTK**：在这本书中，我们不会处理自然语言处理，但NLTK仍然值得提及，因为这个库是Python的主要自然语言工具包。你可以使用这个库进行分类、分词、词干提取、标注、解析、语义推理以及许多其他服务。'
- en: '**TensorFlow** : TensorFlow is Google''s neural network library, and it is
    perfect for implementing deep learning artificial intelligence. The flexible core
    of TensorFlow can be used to solve a vast variety of numerical computation problems.
    Some real-world applications of TensorFlow include Google voice recognition and
    object identification.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TensorFlow**：TensorFlow是Google的神经网络库，非常适合实现深度学习人工智能。TensorFlow的灵活核心可以用来解决大量的数值计算问题。TensorFlow的一些实际应用包括Google语音识别和物体识别。'
- en: A Brief Introduction to the NumPy Library
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy库简介
- en: The NumPy library will play a major role in this book, so it is worth exploring
    it further.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy库在这本书中将扮演重要角色，因此值得进一步探索。
- en: 'After launching your IPython console, you can simply import NumPy as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动你的IPython控制台后，你可以简单地按照以下方式导入NumPy：
- en: '[PRE0]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once NumPy has been imported, you can access it using its alias, **np** . NumPy
    contains the efficient implementation of some data structures such as vectors
    and matrices. Python does not come with a built-in array structure, so NumPy''s
    array comes in handy. Let''s see how we can define vectors and matrices:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 导入NumPy后，你可以使用其别名**np**来访问它。NumPy包含一些数据结构的有效实现，如向量和矩阵。Python没有内置的数组结构，因此NumPy的数组非常有用。让我们看看我们如何定义向量和矩阵：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can declare a matrix using the following syntax:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法声明一个矩阵：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The array method creates an array data structure, while `mat` creates a matrix.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform many operations with matrices. These include addition, subtraction,
    and multiplication:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition in matrices:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Subtraction in matrices:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Multiplication in matrices:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Matrix addition and subtraction works cell by cell.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrix multiplication works according to linear algebra rules. To calculate
    matrix multiplication manually, you have to align the two matrices, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Multiplication calculation with two matrices](img/Image00001.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Multiplication calculation with two matrices'
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To get the *(i,j)th* element of the matrix, you compute the dot (scalar) product
    on the *ith* row of the matrix with the *jth* column. The scalar product of two
    vectors is the sum of the product of their corresponding coordinates.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Another frequent matrix operation is the determinant of the matrix. The determinant
    is a number associated with square matrices. Calculating the determinant using
    NumPy is easy:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output is `-3.0000000000000004` .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the determinant can be calculated as `1*3 – 2*3 = -3` . Notice
    that NumPy calculates the determinant using floating-point arithmetic, and therefore,
    the accuracy of the result is not perfect. The error is due to the way floating-points
    are represented in most programming languages.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also transpose a matrix, like so:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When calculating the transpose of a matrix, we flip its values over its main
    diagonal.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: NumPy has many other important features, and therefore, we will use it in most
    of the chapters in this book.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Matrix Operations Using NumPy'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will be using IPython and the following matrix to solve this exercise. We
    will start by understanding the NumPy syntax:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Simple Matrix](img/Image00002.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Simple Matrix'
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using NumPy, calculate the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The square of the matrix
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The determinant of the matrix
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transpose of the matrix
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin with NumPy matrix operations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Import the NumPy library.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a two-dimensional array storing the matrix:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the `np.mat` construct. If you have created an `np.array` instead of
    `np.mat` , the solution for the array multiplication will be incorrect.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NumPy supports matrix multiplication by using the asterisk:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see from the following code, the square of A has been calculated
    by performing matrix multiplication. For instance, the top-left element of the
    matrix is calculated as follows:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output is `30` .
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `np.linalg.det` to calculate the determinant of the matrix:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The output `is -9.51619735392994e-16` .
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The determinant is almost zero according to the preceding calculations. This
    inefficiency is due to floating-point arithmetic. The actual determinant is zero.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can conclude this by calculating the determinant manually:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output is `0` .
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever you work with NumPy, make sure that you factor in the possibility of
    floating-point arithmetic rounding errors, even if you appear to be working with
    integers.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `np.matrix.transpose` to get the transpose of the matrix:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If `T` is the transpose of matrix A, then `T[j][i]` is equal to `A[i][j]` .
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NumPy comes with many useful features for vectors, matrices, and other mathematical
    structures.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Python for Game AI
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An **AI game player** is nothing but an **intelligent agent** with a clear
    goal: to win the game and defeat all other players. Artificial Intelligence experiments
    have achieved surprising results when it comes to games. Today, no human can defeat
    an AI in the game of chess.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The game Go was the last game where human grandmasters could consistently defeat
    a computer player. However, in 2017, Google's game-playing AI defeated the Go
    grandmaster.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent Agents in Games
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An intelligent agent plays according to the rules of the game. The agent can
    sense the **current state** of the game through its **sensors** and can evaluate
    the **utility** of potential steps. Once the agent finds the **best possible step**
    , it performs the action using its actuators. The agent finds the best possible
    action to **reach the goal** based on the information it has. Actions are either
    **rewarded** or **punished** . The carrot and stick are excellent examples of
    rewards and punishment. Imagine a donkey in front of your cart. You put a carrot
    in front of the eyes of the donkey, so the poor animal starts walking toward it.
    As soon as the donkey stops, the rider may apply punishment with a stick. This
    is not a human way of moving, but rewards and punishment control living organisms
    to some extent. The same happens to humans at school, at work, and in everyday
    life as well. Instead of carrots and sticks, we have income and legal punishment
    to shape our behavior.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In most games and gamified applications, a good sequence of actions results
    in a reward. When a human player feels rewarded, a hormone called dopamine is
    released. Dopamine is also referred to as the chemical of reward. When a human
    achieves a goal or completes a task, dopamine is released. This hormone makes
    you feel happy. Humans tend to act in a way that maximizes their happiness. This
    sequence of actions is called a **compulsion loop** . Intelligent agents, on the
    other hand, are only interested in their goal, which is to maximize their reward
    and minimize their punishment.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: When modeling games, we must determine their **state space** . An action causes
    a **state transition** . When we explore the consequences of all possible actions,
    we get a **decision tree** . This tree goes deeper as we start exploring the possible
    future actions of all players until the game ends.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The strength of AI is the execution of millions of possible steps each second.
    Therefore, game AI often boils down to a **search exercise** . When exploring
    all of the possible sequences of moves in a game, we get the **state tree** of
    a game.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Consider a chess AI. What is the problem with evaluating all possible moves
    by building a state tree consisting of all of the possible sequences of moves?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Chess is an EXPTIME game complexity-wise. The number of possible moves explodes
    combinatorially.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'White starts with 20 possible moves: the 8 pawns may move either one or two
    steps, and the two knights may move either up-up-left, or up-up-right. Then, black
    can make any of these twenty moves. There are already 20*20 = 400 possible combinations
    after just one move per player.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: After the second move, we get 8,902 possible board constellations, and this
    number just keeps on growing. Just take seven moves, and you have to search through
    10,921,506 possible constellations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The average length of a chess game is approximately 40 moves. Some exceptional
    games take more than 200 moves to finish.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, the computer player simply does not have time to explore the
    whole state space. Therefore, the search activity has to be guided with proper
    rewards, punishment, and simplifications of the rules.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Breadth First Search and Depth First Search
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a game AI is often a search exercise. Therefore, we need to be familiar
    with the two primary search techniques: Breadth First Search (BFS) and Depth First
    Search (DFS).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'These search techniques are applied on a **directed rooted tree** . A tree
    is a data structure that has nodes, and edges connecting these nodes in such a
    way that any two nodes of the tree are connected by exactly one path:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: A directed rooted tree](img/Image00003.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: A directed rooted tree'
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When the tree is rooted, there is a special node in the tree called the root,
    where we begin our traversal. A directed tree is a tree where the edges may only
    be traversed in one direction. Nodes may be internal nodes or leaves. **Internal
    nodes** have at least one edge through which we can leave the node. A **leaf**
    has no edges pointing out from the node.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In AI search, the root of the tree is the starting state. We traverse from this
    state by generating successor nodes of the search tree. Search techniques differ
    regarding which order we visit these successor nodes in.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a tree defined by its root, and a function that generates all
    the successor nodes from the root. In this example, each node has a value and
    a depth. We start from 1 and may either increase the value by 1 or 2\. Our goal
    is to reach the value 5.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will first perform DFS on this example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that breadth first search finds the shortest path to a leaf first, because
    it enumerates all nodes in the order of increasing depth.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had to traverse a graph instead of a directed rooted tree, breadth first
    search would look different: whenever we visit a node, we would have to check
    whether the node had been visited before. If the node had been visited before,
    we would simply ignore it.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we only use **Breadth First Traversal** on trees. Depth First
    Search is surprisingly similar to Breadth First Search. The difference between
    **Depth First Traversals** and BFS is the sequence in which you access the nodes.
    While BFS visits all the children of a node before visiting any other nodes, DFS
    digs deep in the tree first:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the DFS algorithm digs deep fast. It does not necessarily find
    the shortest path first, but it is guaranteed to find a leaf before exploring
    a second path.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In game AI, the BFS algorithm is often better for the evaluation of game states,
    because DFS may get lost. Imagine starting a chess game, where a DFS algorithm
    may easily get lost in searching.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the State Space of a Game
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explore the state space of a simple game: Tic-Tac-Toe.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In Tic-Tac-Toe, a 3x3 game board is given. Two players play this game. One plays
    with the sign X, and the other plays with the sign O. X starts the game, and each
    player makes a move after the other. The goal of the game is to get three of your
    own signs horizontally, vertically, or diagonally.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s denote the cells of the Tic-Tac-Toe board as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: tic-tac-toe Board](img/Image00004.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Tic-Tac-Toe Board'
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the following example, X started at position 1\. O retaliated at position
    5, X made a move at position 9, and then O moved to position 3:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: tic-tac-toe Board with noughts and crosses](img/Image00005.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Tic-Tac-Toe Board with noughts and crosses'
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This was a mistake by the second player, because now X is forced to place a
    sign on cell 7, creating two future scenarios for winning the game. It does not
    matter whether O defends by moving to cell 4 or 8 – X will win the game by selecting
    the other unoccupied cell.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can try out the game at [http://www.half-real.net/tictactoe/](http://www.half-real.net/tictactoe/)
    .
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we will only explore the state space belonging to the cases
    when the AI player starts. We will start with an AI player that plays randomly,
    placing a sign in an empty cell. After playing with this AI player, we will create
    a complete decision tree. Once we generate all possible game states, you will
    experience their combinatoric explosion. As our goal is to make these complexities
    simple, we will use several different techniques to make the AI player smarter,
    and to reduce the size of the decision tree. By the end of this experiment, we
    will have a decision tree that has less than 200 different game endings, and as
    a bonus, the AI player will never lose a single game.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a random move, you will have to know how to choose a random element
    from a list using Python. We will use the `choice` function of the random library:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output is `6` .
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The output of the choice function is a random element of the list.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will use the factorial notation in the following exercise. Factorial is denoted
    by the "!" exclamation mark. By definition, 0! = 1, and n! = n*(n-1)!. In our
    example, 9! = 9* 8! = 9*8*7! = … = 9*8*7*6*5*4*3*2*1.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Estimating the Number of Possible States in Tic-Tac-Toe Game'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make a rough estimate of the number of possible states on each level of the
    state space of the Tic-Tac-Toe game:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: In our estimation, we will not stop until all of the cells of the board have
    been filled. A player might win before the game ends, but for the sake of uniformity,
    we will continue the game.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first player will choose one of the nine cells. The second player will choose
    one out of the eight remaining cells. The first player can then choose one out
    of the seven remaining cells. This goes on until either player wins the game,
    or the first player is forced to make the ninth and last move.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of possible decision sequences are therefore 9! = 362880\. A few
    of these sequences are invalid, because a player may win the game in less than
    nine moves. It takes at least five moves to win a game, because the first player
    needs to move three times.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To calculate the exact size of the state space, we would have to calculate the
    number of games that are won in five, six, seven, and eight steps. This calculation
    is simple, but due to its exhaustive nature, it is out of scope for us. We will
    therefore settle for the magnitude of the state space.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: After generating all possible Tic-Tac-Toe games, researchers counted 255,168
    possible games. Out of those games, 131,184 were won by the first player, 77,904
    were won by the second player, and 46,080 games ended with a draw. Visit [http://www.half-real.net/tictactoe/allgamesoftictactoe.zip](http://www.half-real.net/tictactoe/allgamesoftictactoe.zip)
    to download all possible Tic-Tac-Toe games.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even a simple game like Tic-Tac-Toe has a lot of states. Just imagine how hard
    it would be to start exploring all possible chess games. Therefore, we can conclude
    that brute-force search is rarely ideal.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Creating an AI Randomly'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we''ll create a framework for the Tic-Tac-Toe game for experimentation.
    We will be modelling the game on the assumption that the AI player always starts
    the game. Create a function that prints your internal representation and allow
    your opponent to enter a move randomly. Determine whether a player has won. To
    ensure that this happens correctly, you will need to have completed the previous
    exercises:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'We will import the choice function from the `random` library:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will model the nine cells in a simple string for simplicity. A nine-character
    long Python string stores these cells in the following order: "`123456789` ".
    Let''s determine the index triples that must contain matching signs so that a
    player wins the game:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s define the *sign* constants for empty cells, the AI, and the opponent
    player:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s create a function that prints a board. We will add an empty row before
    and after the board so that we can easily read the game state:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will describe a move of the human player. The input arguments are the boards,
    the row numbers from 1 to 3, and the column numbers from 1 to 3\. The return value
    of this function is a board containing the new move:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is time to define a random move of the AI player. We will generate all possible
    moves with the `all_moves_from_board` function, and then we will select a random
    move from the list of possible moves:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After defining the moves, we have to determine whether a player has won the
    game:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Last, but not least, we will create a game loop so that we can test the interaction
    between the computer player and the human player. Although we will carry out an
    exhaustive search in the following examples:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the `game_loop` function to run the game:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, even an opponent who's playing randomly may win from time to
    time if their opponent makes a mistake.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Generating All Possible Sequences of Steps in a Tic-Tac-Toe Game'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This activity will explore the combinatoric explosion that is possible when
    two players play randomly. We will be using a program, building on the previous
    results, that generates all possible sequences of moves between a computer player
    and a human player. Assume that the human player may make any possible move. In
    this example, given that the computer player is playing randomly, we will examine
    the wins, losses, and draws belonging to two randomly playing players:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Create a function that maps the `all_moves_from_board` function on each element
    of a list of board spaces/squares. This way, we will have all of the nodes of
    a decision tree.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The decision tree starts with `[ EMPTY_SIGN * 9 ]` , and expands after each
    move. Let''s create a `filter_wins` function that takes finished games out of
    the list of moves and appends them in an array containing the board states won
    by the AI player and the opponent player:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, with a `count_possibilities` function that prints the number of decision
    tree leaves that ended with a draw, were won by the first player, and were won
    by the second player.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have up to 9 steps in each state. In the 0th, 2nd, 4th, 6th, and 8th iteration,
    the AI player moves. In all other iterations, the opponent moves. We create all
    possible moves in all steps and take out finished games from the move list.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, execute the number of possibilities to experience the combinatoric explosion.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the tree of board states consists of 266,073 leaves. The `count_possibilities`
    function essentially implements a BFS algorithm to traverse all the possible states
    of the game. Notice that we count these states multiple times because placing
    an X in the top-right corner on step 1 and placing an X in the top-left corner
    on step 3 leads to similar possible states as starting with the top-left corner
    and then placing an X in the top-right corner. If we implemented the detection
    of duplicate states, we would have to check fewer nodes. However, at this stage,
    due to the limited depth of the game, we'll omit this step.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: A **decision tree** is very similar to the data structure examined by `count_possibilities`
    . In a decision tree, we explore the utility of each move by investigating all
    possible future steps up to a certain extent. In our example, we could calculate
    the utility of the first moves by observing the number of wins and losses after
    fixing the first few moves.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The root of the tree is the initial state. An internal state of the tree is
    a state in which a game has not been ended and moves are possible. A leaf of the
    tree contains a state where a game has ended.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 258.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have learned what Artificial Intelligence is, as well as
    its multiple disciplines.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how AI can be used to enhance or substitute human brainpower, to
    listen, speak, understand language, store and retrieve information, think, see,
    and move. Then, we moved on to learn about intelligent agents that act in their
    environment, solving a problem in a seemingly intelligent way to pursue a previously
    determined goal. When agents learn, they can learn in a supervised or an unsupervised
    way. We can use intelligent agents to classify things or make predictions about
    the future.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We then introduced Python and learned about its role in the field of Artificial
    Intelligence. We looked at a few important Python libraries for developing intelligent
    agents and preparing data for agents. As a warm-up, we concluded this chapter
    with an example, where we used the NumPy library to perform some matrix operations
    in Python. We also learned how to create a search space for a Tic Tac Toe game.
    In the next chapter, we will learn how intelligence can be imparted with the help
    of search space.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
