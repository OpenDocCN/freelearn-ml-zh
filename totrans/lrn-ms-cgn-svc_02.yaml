- en: Chapter 2. Analyzing Images to Recognize a Face
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。分析图像以识别面部
- en: '*"We can use the Computer Vision API to prove to our clients the reliability
    of the data, so they can be confident making important business decisions based
    on that information."*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"我们可以使用计算机视觉API向我们的客户证明数据的可靠性，这样他们就可以基于这些信息做出重要的商业决策，并对此充满信心。"*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Leendert de Voogd, CEO of Vigiglobe'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- Leendert de Voogd，Vigiglobe首席执行官'
- en: In the previous chapter, you were briefly introduced to Microsoft Cognitive
    Services. Throughout this chapter, we will dive into image-based APIs from the
    vision API. We will learn how to perform image analysis. Moving on, we will dive
    deeper into the Face API, which we briefly looked at in the previous chapter,
    and we will learn how you can identify people. Next, we will learn how to use
    the Face API to recognize emotions in faces. Finally, we will learn about the
    different ways to moderate content.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您简要介绍了Microsoft Cognitive Services。在本章中，我们将深入探讨视觉API中的基于图像的API。我们将学习如何执行图像分析。接下来，我们将更深入地研究Face
    API，这是我们上一章简要了解的API，我们将学习如何识别人。然后，我们将学习如何使用Face API在面部中识别情绪。最后，我们将了解不同的内容审核方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Analyzing images to identify content, metadata, and adult ratings.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析图像以识别内容、元数据和成人评级。
- en: Recognizing celebrities in images and reading text in images.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像中识别名人以及在图像中读取文本。
- en: 'Diving into the Face API:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入Face API：
- en: Learning to find the likelihood of two faces belonging to the same person
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习找到两个面部属于同一个人的可能性
- en: Grouping faces based on visual similarities and searching similar faces
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据视觉相似性分组面部并搜索相似面部
- en: Identifying a person from a face
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从面部识别一个人
- en: Recognizing emotions
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别情绪
- en: Content moderation.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容审核。
- en: Analyze an image using the Computer Vision API
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算机视觉API分析图像
- en: The Computer Vision API allows us to process an image and retrieve information
    about it. It relies on advanced algorithms to analyze the content of the image
    in different ways, based on our needs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉API允许我们处理图像并检索有关它的信息。它依赖于先进的算法，根据我们的需求以不同的方式分析图像内容。
- en: Throughout this section, we will learn how to take advantage of this API. We
    will look at the different ways to analyze an image through standalone examples.
    Some of the features we will cover will also be incorporated into our end-to-end
    application in a later chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何利用这个API。我们将通过独立的示例来查看分析图像的不同方法。我们将在后面的章节中将一些我们将要介绍的功能整合到我们的端到端应用中。
- en: 'Calling any of the APIs will return one of the following response codes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 调用任何API将返回以下响应代码之一：
- en: '| Code | Description |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `200` | Information of the extracted features in JSON format. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `200` | 以JSON格式提取的特征信息。 |'
- en: '| `400` | Typically, this means bad request. It may be an invalid image URL,
    an image that is too small or too large, an invalid image format, or any other
    errors to do with the request body. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 通常这意味着请求错误。可能是一个无效的图像URL、过小或过大的图像、无效的图像格式或与请求体相关的任何其他错误。 |'
- en: '| `415` | Unsupported media type. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `415` | 不支持的媒体类型。 |'
- en: '| `500` | Possible errors may include a failure to process the image, image
    processing timing out, or an internal server error. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `500` | 可能的错误包括处理图像失败、图像处理超时或内部服务器错误。 |'
- en: Setting up a chapter example project
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置章节示例项目
- en: 'Before we go into the specifics of the API, we need to create an example project
    for this chapter. This project will contain all of the examples, which will not
    be put into the end-to-end application at this stage:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入API的细节之前，我们需要为本章创建一个示例项目。该项目将包含所有示例，这些示例在此阶段不会放入端到端应用中：
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have not already done so, sign up for an API key for Computer Vision
    by visiting [https://portal.azure.com](https://portal.azure.com).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请访问[https://portal.azure.com](https://portal.azure.com)注册计算机视觉API密钥。
- en: Create a new project in Visual Studio using the template we created in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Microsoft Cognitive Services"),
    *Getting Started with Microsoft Cognitive Services*.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在[第1章](ch01.html "第1章. 使用Microsoft Cognitive Services入门")中创建的模板在Visual Studio中创建一个新的项目，*使用Microsoft
    Cognitive Services入门*。
- en: Right-click on the project and choose **Manage NuGet Packages**. Search for
    the `Microsoft.ProjectOxford.Vision` package and install it into the project,
    as shown in the following screenshot:![Setting up a chapter example project](img/B12373_02_01.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目并选择**管理NuGet包**。搜索`Microsoft.ProjectOxford.Vision`包并将其安装到项目中，如下面的截图所示：![设置章节示例项目](img/B12373_02_01.jpg)
- en: 'Create the following `UserControls` files and add them into the `ViewModel`
    folder:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下`UserControls`文件，并将它们添加到`ViewModel`文件夹中：
- en: '`CelebrityView.xaml`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CelebrityView.xaml`'
- en: '`DescriptionView.xaml`'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DescriptionView.xaml`'
- en: '`ImageAnalysisView.xaml`'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageAnalysisView.xaml`'
- en: '`OcrView.xaml`'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OcrView.xaml`'
- en: '`ThumbnailView.xaml`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThumbnailView.xaml`'
- en: 'Also, add the corresponding `ViewModel` instances from the following list into
    the `ViewModel` folder:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要将以下列表中的相应`ViewModel`实例添加到`ViewModel`文件夹中：
- en: '`CelebrityViewModel.cs`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CelebrityViewModel.cs`'
- en: '`DescriptionViewModel.cs`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DescriptionViewModel.cs`'
- en: '`ImageAnalysisViewModel.cs`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageAnalysisViewModel.cs`'
- en: '`OcrViewModel.cs`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OcrViewModel.cs`'
- en: '`ThumbnailViewModel.cs`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThumbnailViewModel.cs`'
- en: Go through the newly created `ViewModel` instances and make sure that all classes
    are public.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 检查新创建的`ViewModel`实例，确保所有类都是公开的。
- en: 'We will switch between the different views using a `TabControl` tag. Open the
    `MainView.xaml` file and add the following in the precreated `Grid` tag:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`TabControl`标签在不同的视图之间切换。打开`MainView.xaml`文件，并在预先创建的`Grid`标签中添加以下内容：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will add a tab bar at the top of the application that will allow you to
    navigate between the different views.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在应用程序顶部添加一个标签栏，允许您在不同视图之间导航。
- en: Next, we will add the properties and members required in our `MainViewModel.cs`
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`MainViewModel.cs`文件中所需的属性和成员。
- en: 'The following is the variable used to access the Computer Vision API:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下变量用于访问计算机视觉API：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following code declares a private variable holding the `CelebrityViewModel`
    object. It also declares the `public` property that we use to access the `ViewModel`
    in our `View`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了一个包含`CelebrityViewModel`对象的私有变量。它还声明了`public`属性，我们使用它来在我们的`View`中访问`ViewModel`：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Following the same pattern, add properties for the rest of the created `ViewModel`
    instances.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的模式，为创建的其余`ViewModel`实例添加属性。
- en: 'With all the properties in place, create the `ViewModel` instances in our constructor
    using the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有属性就绪后，使用以下代码在我们的构造函数中创建`ViewModel`实例：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note how we first create the `VisionServiceClient` object with the API key that
    we signed up for earlier and the root URI, as described in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Microsoft Cognitive Services"), *Getting Started
    with Microsoft Cognitive Services*. This is then injected into all the `ViewModel`
    instances to be used there.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们首先使用之前注册的API密钥和根URI创建`VisionServiceClient`对象，如[第1章](ch01.html "第1章. 使用Microsoft认知服务入门")中所述，*使用Microsoft认知服务入门*。然后将其注入到所有`ViewModel`实例中供使用。
- en: 'This should now compile and present you with the application shown in the following
    screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该可以编译，并显示以下截图所示的应用程序：
- en: '![Setting up a chapter example project](img/B12373_02_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![设置章节示例项目](img/B12373_02_02.jpg)'
- en: Generic image analysis
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用图像分析
- en: We start enabling generic image analysis by adding a UI to the `ImageAnalysis.xaml`
    file. All the Computer Vision example UIs will be built in the same manner.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向`ImageAnalysis.xaml`文件添加UI来开始启用通用图像分析。所有计算机视觉示例UI将以相同的方式构建。
- en: 'The UI should have two columns, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: UI应该有两个列，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first one will contain the image selection, while the second one will display
    our results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将包含图像选择，而第二个将显示我们的结果。
- en: 'In the left-hand column, we create a vertically oriented `StackPanel` label.
    To this, we add a label and a `ListBox` label. The list box will display a list
    of visual features that we can add to our analysis query. Note how we have a `SelectionChanged`
    event hooked up in the `ListBox` label in the following code. This will be added
    behind the code, and will be covered shortly:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧列中，我们创建一个垂直方向的`StackPanel`标签。为此，我们添加一个标签和一个`ListBox`标签。列表框将显示我们可以添加到我们的分析查询中的视觉特征列表。注意以下代码中`ListBox`标签中连接的`SelectionChanged`事件。这将在代码之后添加，并将在稍后介绍：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The list box will be able to select multiple items, and the items will be gathered
    in the `ViewModel`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表框将能够选择多个项目，并将项目收集在`ViewModel`中。
- en: 'In the same stack panel, we also add a button element and an image element.
    These will allow us to browse for an image, show it, and analyze it. Both the
    `Button` command and the image source are bound to the corresponding properties
    in the `ViewModel`, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个堆叠面板中，我们还添加了一个按钮元素和一个图像元素。这些将允许我们浏览图像、显示它并分析它。`Button`命令和图像源都绑定到`ViewModel`中的相应属性，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also add another vertically oriented stack panel. This will be placed in
    the right-hand column. It contains a title label, as well as a textbox, bound
    to the analysis result in our `ViewModel`, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了另一个垂直堆叠面板。这将放置在右侧列。它包含一个标题标签以及一个文本框，绑定到我们的`ViewModel`中的分析结果，如下所示：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we want to add our `SelectionChanged` event handler to our code-behind.
    Open the `ImageAnalysisView.xaml.cs` file and add the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要将我们的`SelectionChanged`事件处理程序添加到我们的代码隐藏中。打开`ImageAnalysisView.xaml.cs`文件并添加以下内容：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line of the function will give us the current `DataContext`, which
    is the `MainViewModel` class. We access the `ImageAnalysisVm` property, which
    is our `ViewModel`, and clear the selected visual features list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一行将给我们当前的`DataContext`，即`MainViewModel`类。我们访问`ImageAnalysisVm`属性，即我们的`ViewModel`，并清除选中的视觉特征列表。
- en: 'From there, we loop through the selected items from our list box. All items
    will be added to the `SelectedFeatures` list in our `ViewModel`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们遍历我们的列表框中的选中项。所有项都将添加到我们的`ViewModel`中的`SelectedFeatures`列表中：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Open the `ImageAnalysisViewModel.cs` file. Make sure that the class inherits
    the `ObservableObject` class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`ImageAnalysisViewModel.cs`文件。确保该类继承自`ObservableObject`类。
- en: 'Declare a `private` variable, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个`private`变量，如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will be used to access the Computer Vision API, and it is initialized through
    the constructor.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于访问计算机视觉API，并通过构造函数进行初始化。
- en: 'Next, we declare a private variable and the corresponding property for our
    list of visual features, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个私有变量及其对应属性，用于我们的视觉特征列表，如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In a similar manner, create a `BitmapImage` variable and property called `ImageSource`.
    Create a list of `VisualFeature` types called `SelectedFeatures` and a string
    called `AnalysisResult`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，创建一个名为`ImageSource`的`BitmapImage`变量和属性。创建一个名为`SelectedFeatures`的`VisualFeature`类型列表和一个名为`AnalysisResult`的字符串。
- en: 'We also need to declare the property for our button, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要声明我们的按钮属性，如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With that in place, we create our constructor, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们创建我们的构造函数，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The constructor takes one parameter, the `IVisionServiceClient` object, which
    we have created in our `MainViewModel` file. It assigns that parameter to the
    variable that we created earlier. Then we call an `Initialize` function, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个参数，即我们在`MainViewModel`文件中创建的`IVisionServiceClient`对象。它将该参数分配给之前创建的变量。然后我们调用一个`Initialize`函数，如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `Initialize` function, we fetch all the values from the `VisualFeature`
    variable of the `enum` type. These values are added to the features list, which
    is displayed in the UI. We also created our button, and now that we have done
    so, we need to create the corresponding action, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Initialize`函数中，我们从`enum`类型的`VisualFeature`变量中获取所有值。这些值被添加到特征列表中，该列表在UI中显示。我们还创建了我们的按钮，现在我们已经这样做，我们需要创建相应的操作，如下所示：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first lines of the preceding code are similar to what we did in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Microsoft Cognitive Services"),
    *Getting Started with Microsoft Cognitive Services*. We open a file browser and
    get the selected image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的前几行与我们在[第1章](ch01.html "第1章。使用Microsoft认知服务入门")中做的类似，*使用Microsoft认知服务入门*。我们打开文件浏览器并获取选中的图像。
- en: 'With an image selected, we run an analyze on it, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在选中图像后，我们按照以下方式对其进行分析：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We call the `AnalyzeImageAsync` function of our `_visionClient`. This function
    has four overloads, all of which are quite similar. In our case, we pass on the
    image as a `Stream` type and the `SelectedFeatures` list, containing the `VisualFeatures`
    variable to analyze.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用我们的`_visionClient`的`AnalyzeImageAsync`函数。这个函数有四个重载，它们都非常相似。在我们的情况下，我们传递一个`Stream`类型的图像和包含`VisualFeatures`变量的`SelectedFeatures`列表来分析。
- en: 'The request parameters are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请求参数如下：
- en: '| Parameter | Description |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Image (required)** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **图像（必需）** |'
- en: Can be uploaded in the form of a raw image binary or URL.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以以原始图像二进制或URL的形式上传。
- en: Can be JPEG, PNG, GIF, or BMP.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以是JPEG、PNG、GIF或BMP。
- en: File size must be less than 4 MB.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小必须小于4 MB。
- en: Image dimensions must be at least 50 x 50 pixels.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像尺寸必须至少为50 x 50像素。
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Visual features (optional)** | A list indicating the visual feature types
    to return. It can include categories, tags, descriptions, faces, image types,
    color, and whether or not it is adult content. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **可选视觉特征** | 一个指示要返回的视觉特征类型的列表。它可以包括类别、标签、描述、面部、图像类型、颜色以及是否为成人内容。|'
- en: '| **Details (optional)** | A list indicating what domain-specific details to
    return. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **详细信息（可选）** | 一个指示要返回的特定领域详细信息的列表。|'
- en: The response to this request is the `AnalysisResult` string.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对此请求的响应是`AnalysisResult`字符串。
- en: 'We then check to see if the result is `null`. If it is not, we call a function
    to parse it and assign the result to our `AnalysisResult` string, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后检查结果是否为`null`。如果不是，我们调用一个函数来解析它，并将结果分配给我们的`AnalysisResult`字符串，如下所示：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember to close the `try` clause and finish the method with the corresponding
    `catch` clause.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记得关闭`try`子句，并用相应的`catch`子句完成方法。
- en: The `AnalysisResult` string contains data according to the visual features requested
    in the API call.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnalysisResult`字符串包含根据API调用中请求的视觉特征的数据。'
- en: 'Data in the `AnalysisResult` variable is described in the following table:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnalysisResult`变量中的数据在以下表中描述：'
- en: '| Visual feature | Description |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 视觉特征 | 描述 |'
- en: '| --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Categories** | Images are categorized according to a defined taxonomy.
    This includes everything from animals, buildings, and outdoors, to people. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | 图像根据定义的分类法进行分类。这包括从动物、建筑和户外到人物的各个方面。|'
- en: '| **Tags** | Images are tagged with a list of words related to the content.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | 图像用与内容相关的单词列表进行标记。|'
- en: '| **Description** | This contains a full sentence describing the image. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 这包含一个完整句子来描述图像。|'
- en: '| **Faces** | This detects faces in images and contains face coordinates, gender,
    and age. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **面部** | 这检测图像中的面部，并包含面部坐标、性别和年龄。|'
- en: '| **ImageType** | This detects whether an image is clipart or a line drawing.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **图像类型** | 这检测图像是剪贴画还是线画。|'
- en: '| **Color** | This contains information about dominant colors, accent colors,
    and whether or not the image is in black and white. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** | 这包含有关主导颜色、强调颜色以及图像是否为黑白的详细信息。|'
- en: '| **Adult** | This detects whether an image is pornographic in nature and whether
    or not it is racy. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **成人** | 这检测图像是否具有色情性质，以及是否过于露骨。|'
- en: 'To retrieve data, for example for categories, you can use the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索数据，例如类别，你可以使用以下方法：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A successful call would present us with the following result:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用将显示以下结果：
- en: '![Generic image analysis](img/B12373_02_03.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![通用图像分析](img/B12373_02_03.jpg)'
- en: 'Sometimes, you may only be interested in the image description. In such cases,
    it is wasteful to ask for the kind of full analysis that we have just done. By
    calling the following function, you will get an array of descriptions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只对图像描述感兴趣。在这种情况下，请求我们刚刚所做的全面分析是浪费的。通过调用以下函数，你将得到一个描述数组：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this call, we have specified a URL for the image and the number of descriptions
    to return. The first parameter must always be included, but it may be an image
    upload instead of a URL. The second parameter is optional, and in cases where
    it is not provided, it defaults to one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次调用中，我们指定了图像的URL和要返回的描述数量。第一个参数必须始终包含，但它可以是图像上传而不是URL。第二个参数是可选的，如果没有提供，则默认为1。
- en: A successful query will result in an `AnalysisResult` object, which is the same
    as the one that was described in the preceding code. In this case, it will only
    contain the request ID, image metadata, and an array of captions. Each caption
    contains an image description and the confidence of that description being correct.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的查询将导致一个`AnalysisResult`对象，这与前面代码中描述的是同一个。在这种情况下，它将只包含请求ID、图像元数据和标题数组。每个标题包含一个图像描述和该描述正确性的置信度。
- en: We will add this form of image analysis to our smart-house application in a
    later chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中将这种图像分析方法添加到我们的智能家居应用程序中。
- en: Recognizing celebrities using domain models
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用领域模型识别名人
- en: One of the features of the Computer Vision API is the ability to recognize domain-specific
    content. At the time of writing, the API only supports celebrity recognition,
    where it is able to recognize around 200,000 celebrities.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉API的一个特点是能够识别特定领域的内容。在撰写本文时，该API仅支持名人识别，能够识别大约20万名名人。
- en: For this example, we choose to use an image from the internet. The UI will then
    need a textbox to input the URL. It will need a button to load the image and perform
    the domain analysis. There should be an image element to see the image and a textbox
    to output the result.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们选择使用互联网上的图片。然后UI需要一个文本框来输入URL。它需要一个按钮来加载图片并执行领域分析。应该有一个图片元素来查看图片，以及一个文本框来输出结果。
- en: The corresponding `ViewModel` should have two `string` properties for the URL
    and the analysis result. It should have a `BitmapImage` property for the image
    and an `ICommand` property for our button.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`ViewModel`应该有两个`string`属性，用于URL和分析结果。它应该有一个`BitmapImage`属性用于图片，以及一个`ICommand`属性用于我们的按钮。
- en: 'Add a `private` variable for the `IVisionServiceClient` type at the start of
    the `ViewModel`, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`的开始处添加一个`private`变量用于`IVisionServiceClient`类型，如下所示：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This should be assigned in the constructor, which will take a parameter of the
    `IVisionServiceClient` type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在构造函数中分配，该构造函数将接受`IVisionServiceClient`类型的参数。
- en: 'As we need a URL to fetch an image from the internet, we need to initialize
    the `Icommand` property with both an action and a predicate. The latter checks
    whether the URL property is set or not, as shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要一个URL从互联网上获取图片，我们需要使用动作和谓词初始化`Icommand`属性。后者检查URL属性是否已设置，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `LoadAndFindCelebrity` load creates a `Uri` with the given URL. Using this,
    it creates a `BitmapImage` and assigns this to `ImageSource`, the `BitmapImage`
    property, as shown in the following code. The image should be visible in the UI:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadAndFindCelebrity`加载操作使用给定的URL创建一个`Uri`。使用这个URL，它创建一个`BitmapImage`并将其分配给`ImageSource`属性，如下面的代码所示。图片应该在UI中可见：'
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We call the `AnalyzeImageInDomainAsync` type with the given URL, as shown in
    the following code. The first parameter we pass in is the image URL. Alternatively,
    this could have been an image that was opened as a `Stream` type:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用给定的URL调用`AnalyzeImageInDomainAsync`类型，如下面的代码所示。我们传递的第一个参数是图片URL。或者，这也可以是一个已作为`Stream`类型打开的图片：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second parameter is the domain model name, which is in a `string` format.
    As an alternative, we could have used a specific `Model` object, which can be
    retrieved by calling the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是领域模型名称，它以`string`格式存在。作为替代，我们本可以使用特定的`Model`对象，这可以通过调用以下代码来检索：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This would return an array of `Models`, which we can display and select from.
    As there is only one available at this time, there is no point in doing so.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个`Models`数组，我们可以从中显示和选择。由于目前只有一个可用，这样做没有意义。
- en: The result from `AnalyzeImageInDomainAsync` is an object of the `AnalysisInDomainResult`
    type. This object will contain the request ID, metadata of the image, and the
    result, containing an array of celebrities. In our case, we simply output the
    entire result array. Each item in this array will contain the name of the celebrity,
    the confidence of a match, and the face rectangle in the image. Do try it in the
    example code provided.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnalyzeImageInDomainAsync`的结果是`AnalysisInDomainResult`类型的对象。该对象将包含请求ID、图片元数据以及包含名人数组的结果。在我们的例子中，我们简单地输出整个结果数组。数组中的每个项目将包含名人的名字、匹配的置信度以及图像中的脸矩形。请尝试在提供的示例代码中尝试。'
- en: Utilizing optical character recognition
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用光学字符识别
- en: For some tasks, **optical character recognition** (**OCR**) can be very useful.
    Say that you took a photo of a receipt. Using OCR, you can read the amount from
    the photo itself and have it automatically added to accounting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些任务，**光学字符识别**（**OCR**）可能非常有用。比如说，你拍了一张收据的照片。使用OCR，你可以从照片本身读取金额，并自动添加到会计中。
- en: OCR will detect text in images and extract machine-readable characters. It will
    automatically detect language. Optionally, the API will detect image orientation
    and correct it before reading the text.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: OCR将检测图片中的文本并提取可读字符。它将自动检测语言。可选地，API将检测图片方向并在读取文本之前进行校正。
- en: 'To specify a language, you need to use the **BCP-47** language code. At the
    time of writing, the following languages are supported: simplified Chinese, traditional
    Chinese, Czech, Danish, Dutch, English, Finnish, French, German, Greek, Hungarian,
    Italian, Japanese, Korean, Norwegian, Polish, Portuguese, Russian, Spanish, Swedish,
    Turkish, Arabic, Romanian, Cyrillic Serbian, Latin Serbian, and Slovak.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定语言，您需要使用**BCP-47**语言代码。在撰写本文时，以下语言受到支持：简体中文、繁体中文、捷克语、丹麦语、荷兰语、英语、芬兰语、法语、德语、希腊语、匈牙利语、意大利语、日语、韩语、挪威语、波兰语、葡萄牙语、俄语、西班牙语、瑞典语、土耳其语、阿拉伯语、罗马尼亚语、西里尔塞尔维亚语、拉丁塞尔维亚语和斯洛伐克语。
- en: In the code example, the UI will have an image element. It will also have a
    button to load the image and detect text. The result will be printed to a textbox
    element.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，UI将有一个图像元素。它还将有一个按钮来加载图像并检测文本。结果将打印到文本框元素中。
- en: The `ViewModel` will need a `string` property for the result, a `BitmapImage`
    property for the image, and an `ICommand` property for the button.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`需要一个用于结果的`string`属性，一个用于图像的`BitmapImage`属性，以及一个用于按钮的`ICommand`属性。'
- en: 'Add a `private` variable to the `ViewModel` for the Computer Vision API, as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为计算机视觉API在`ViewModel`中添加一个`private`变量，如下所示：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The constructor should have one parameter of the `IVisionServiceClient` type,
    which should be assigned to the preceding variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数应有一个`IVisionServiceClient`类型的参数，该参数应分配给前面的变量。
- en: 'Create a function as a command for our button. Call it `BrowseAndAnalyze` and
    have it accept `object` as the parameter. Then, open a file browser and find an
    image to analyze. With the image selected, we run the OCR analysis, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的按钮创建一个作为命令的函数。命名为`BrowseAndAnalyze`，并接受`object`作为参数。然后打开文件浏览器并找到一个要分析的图像。选择图像后，我们运行OCR分析，如下所示：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the image opened as a `Stream` type, we call the `RecognizeTextAsync` method.
    In this case, we pass on the image as a `Stream` type, but we could just as easily
    have passed on a URL to an image.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像以`Stream`类型打开，我们调用`RecognizeTextAsync`方法。在这种情况下，我们传递图像作为`Stream`类型，但我们也可以简单地传递图像的URL。
- en: Two more parameters may be specified in this call. First, you can specify the
    language of the text. The default is unknown, which means that the API will try
    to detect the language automatically. Second, you can specify whether or not the
    API should detect the orientation of the image. The default is set to `false`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在此调用中可以指定两个更多参数。首先，您可以指定文本的语言。默认为未知，这意味着API将尝试自动检测语言。其次，您可以指定API是否应检测图像的方向。默认设置为`false`。
- en: 'If the call succeeds, it will return data in the form of an `OcrResults` object.
    We send this result to a function, the `PrintOcrResult` function, where we will
    parse it and print the text, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，它将以`OcrResults`对象的形式返回数据。我们将此结果发送到`PrintOcrResult`函数，我们将解析它并打印文本，如下所示：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, we create a `StringBuilder` object, which will hold all the text. The
    first content we add to it is the language of the text in the image, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`StringBuilder`对象，它将保存所有文本。我们首先添加到其中的内容是图像中文本的语言，如下所示：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result has an array, which contains the `Regions` property. Each item represents
    recognized text, and each region contains multiple lines. The `line` variables
    are arrays, where each item represents recognized text. Each line contains an
    array of the `Words` property. Each item in this array represents a recognized
    word.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果包含一个数组，该数组包含`Regions`属性。每个项目代表识别出的文本，每个区域包含多行。`line`变量是数组，其中每个项目代表识别出的文本。每一行包含`Words`属性的数组。该数组中的每个项目代表一个识别出的单词。
- en: 'With all the words appended to the `StringBuilder` function, we return it as
    a string. This will then be printed in the UI, as shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有单词附加到`StringBuilder`函数后，我们将其作为字符串返回。然后，它将在UI中打印出来，如下面的截图所示：
- en: '![Utilizing optical character recognition](img/B12373_02_04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![利用光学字符识别](img/B12373_02_04.jpg)'
- en: The result also contains the orientation and angle of the text. Combining this
    with the bounding box, also included, you can mark each word in the original image.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 结果还包含文本的方向和角度。结合也包括的边界框，你可以在原始图像中标记每个单词。
- en: Generating image thumbnails
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成图像缩略图
- en: In today's world, we, as developers, have to consider different screen sizes
    when displaying images. The Computer Vision API offers some help with this by
    providing the ability to generate thumbnails.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，作为开发者，我们在显示图片时必须考虑不同的屏幕尺寸。计算机视觉API通过提供生成缩略图的能力来提供一些帮助。
- en: Thumbnail generation, in itself, is not that big a deal. What makes the API
    clever is that it analyzes the image and determines the region of interest.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 缩略图生成本身并不是什么大事。使API变得聪明的是，它会分析图像并确定感兴趣的区域。
- en: It will also generate smart cropping coordinates. This means that if the specified
    aspect ratio differs from the original, it will crop the image, with a focus on
    the interesting regions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将生成智能裁剪坐标。这意味着如果指定的宽高比与原始图像不同，它将裁剪图像，重点在感兴趣的区域。
- en: In the example code, the UI consists of two image elements and one button. The
    first image is the image in its original size. The second is for the generated
    thumbnail, which we specify to be 250 x 250 pixels in size.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，UI由两个图像元素和一个按钮组成。第一个图像是原始大小的图像。第二个是生成的缩略图，我们指定其大小为250 x 250像素。
- en: The `View` model will need the corresponding properties, two `BitmapImages`
    methods to act as image sources, and one `ICommand` property for our button command.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`模型将需要相应的属性，两个`BitmapImages`方法作为图像源，以及一个`ICommand`属性用于我们的按钮命令。'
- en: 'Define a private variable in the `ViewModel`, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`中定义一个私有变量，如下所示：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will be our API access point. The constructor should accept an `IVisionServiceClient`
    object, which should be assigned to the preceding variable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的API访问点。构造函数应该接受一个`IVisionServiceClient`对象，该对象应分配给前面的变量。
- en: For the `ICommand` property, we create a function, `BrowseAndAnalyze`, accepting
    an `object` parameter. We do not need to check whether we can execute the command.
    We will browse for an image each time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ICommand`属性，我们创建一个函数`BrowseAndAnalyze`，接受一个`object`参数。我们不需要检查我们是否可以执行该命令。我们将每次都浏览一个图像。
- en: 'In the `BrowseAndAnalyze` function, we open a file dialog and select an image.
    When we have the image file path, we can generate our thumbnail, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BrowseAndAnalyze`函数中，我们打开文件对话框并选择一个图像。当我们有了图像文件路径，我们可以生成我们的缩略图，如下所示：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We open the image file so that we have a `Stream` type. This stream is the first
    parameter in our call to the `GetThumbnailAsync` method. The next two parameters
    indicate the width and height that we want for our thumbnail.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开图像文件，以便我们有一个`Stream`类型。这个流是我们调用`GetThumbnailAsync`方法的第一个参数。接下来的两个参数表示我们想要的缩略图的宽度和高度。
- en: By default, the API call will use smart cropping, so we do not have to specify
    it. If we have a case where we do not want smart cropping, we could add a `bool`
    variable as the fourth parameter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，API调用将使用智能裁剪，因此我们无需指定。如果我们有不需要智能裁剪的情况，我们可以添加一个`bool`变量作为第四个参数。
- en: 'If the call succeeds, we get a `byte` array back. This is the image data. If
    it contains data, we pass it on to a new function, `CreateThumbnail`, to create
    a `BitmapImage` object from it, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，我们将返回一个`byte`数组。这是图像数据。如果它包含数据，我们将将其传递给一个新的函数`CreateThumbnail`，从中创建一个`BitmapImage`对象，如下所示：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To create an image from a `byte` array, we create a `MemoryStream` object from
    it. We make sure that we start at the beginning of the array.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`byte`数组创建图像，我们从这个数组创建一个`MemoryStream`对象。我们确保从数组的开始处开始。
- en: 'Next, we create a `BitmapImage` object and begin to initialize it. We specify
    the `CacheOption` and set the `StreamSource` to the `MemoryStream` variables we
    created earlier. Finally, we stop the `BitmapImage` initialization and assign
    the image to our `Thumbnail` property, as shown in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`BitmapImage`对象并开始初始化它。我们指定`CacheOption`并将`StreamSource`设置为之前创建的`MemoryStream`变量。最后，我们停止`BitmapImage`的初始化并将图像分配给我们的`Thumbnail`属性，如下所示：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Close up the `try` clause and add the corresponding `catch` clause. You should
    now be able to generate thumbnails.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 收尾`try`块并添加相应的`catch`块。你现在应该能够生成缩略图。
- en: Diving deep into the Face API
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Face API
- en: The Face API has two main features. The first one is face detection and the
    other is face recognition.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Face API有两个主要功能。第一个是面部检测，另一个是面部识别。
- en: 'Face detection allows us to detect up to 64 faces in one image. We have already
    seen the basic usage. The features of face recognition are implied in its name:
    using it, we can detect whether two faces belong to the same person. We can find
    similar faces, or one in particular, and we can group similar faces. We will learn
    how to do all of this in the following sections.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 面部检测使我们能够在一张图像中检测多达64个面部。我们已经看到了基本用法。面部识别的特点隐含在其名称中：使用它，我们可以检测两个面部是否属于同一个人。我们可以找到相似的面部，或者特定的一个，并且我们可以将相似的面部分组。我们将在以下章节中学习如何做到这一切。
- en: 'When calling any of the APIs, it will respond with one of the following responses:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用任何 API 时，它将响应以下之一：
- en: '| Code | Description |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `200` | Successful call. It returns an array containing data related to the
    API call. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `200` | 调用成功。它返回一个包含与 API 调用相关的数据的数组。|'
- en: '| `400` | Request body is invalid. This can be a number of errors, depending
    on the API call. Typically, the request code is invalid. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 请求体无效。这可能是 API 调用中的多种错误，通常请求代码无效。|'
- en: '| `401` | Access denied because of an invalid subscription key. The key may
    be wrong or the account/subscription plan may be blocked. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `401` | 访问被拒绝，因为订阅密钥无效。密钥可能错误，或者账户/订阅计划可能已被阻止。|'
- en: '| `403` | Out of call volume data. You have made all the available calls to
    the API for this month. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `403` | 超出调用量数据。您已使用本月的所有可用 API 调用。|'
- en: '| `415` | Invalid media type. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `415` | 无效的媒体类型。|'
- en: '| `429` | Rate limit is exceeded. You will need to wait a period of time (less
    than one minute in the free preview) before you try again. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `429` | 超出速率限制。您需要等待一段时间（免费预览中少于一分钟）后再尝试。|'
- en: Retrieving more information from the detected faces
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从检测到的面部获取更多信息
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Microsoft Cognitive
    Services"), *Getting Started with Microsoft Cognitive Services*, we learned the
    very basic form of face detection. In the example, we retrieved a `Face` array.
    This contained information on all faces that were found in an image. In that specific
    example, we obtained information about the face rectangle, face ID, face landmarks,
    and age.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。使用 Microsoft Cognitive Services 入门") *使用 Microsoft
    Cognitive Services 入门* 中，我们学习了面部检测的基本形式。在示例中，我们检索了一个 `Face` 数组。它包含了图像中找到的所有面部信息。在特定示例中，我们获得了关于面部矩形、面部
    ID、面部特征点和年龄的信息。
- en: 'When calling the API, there are four request parameters, as shown in the following
    table:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 API 时，有四个请求参数，如下表所示：
- en: '| Parameter | Description |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `image` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `image` |'
- en: The image in which to search for faces. It will either be in the form of a URL
    or binary data.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其中搜索面部的图像。它可以是 URL 或二进制数据的形式。
- en: Supported formats are JPEG, PNG, GIF, and BMP.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的格式为 JPEG、PNG、GIF 和 BMP。
- en: The maximum file size is 4 MB.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大文件大小为 4 MB。
- en: The size of detectable faces is between 36 x 36 pixels and 4096 x 4096 pixels.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可检测到的面部大小介于 36 x 36 像素和 4096 x 4096 像素之间。
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `return FaceId` (optional) | Boolean value. This specifies whether the response
    should include the face ID or not. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `return FaceId` (optional) | 布尔值。此值指定响应是否应包含面部 ID。|'
- en: '| `return FaceLandmarks` (optional) | Boolean value. This specifies whether
    the response should include `FaceLandmarks` in detected faces. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `return FaceLandmarks` (optional) | 布尔值。此值指定响应是否应包含检测到的面部 `FaceLandmarks`。|'
- en: '| `return FaceAttributes` (optional) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `return FaceAttributes` (optional) |'
- en: String value. This is a comma-separated string containing all face attributes
    that are to be analyzed.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串值。这是一个逗号分隔的字符串，包含要分析的所有面部属性。
- en: Supported attributes are age, gender, head pose, smile, facial hair, emotion,
    and glasses.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的属性包括年龄、性别、头部姿态、微笑、面部毛发、情绪和眼镜。
- en: These attributes are still experimental, and should be treated as such.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些属性仍然是实验性的，应如此对待。
- en: '|'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If a face is successfully discovered, it will expire in 24 hours. When calling
    other parts of the Face API, you are often required to have a face ID as an input.
    In those cases, we need to detect a face first, followed by the call to the API
    we wish to use, using the detected face as a parameter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功发现面部，它将在 24 小时后过期。在调用 Face API 的其他部分时，通常需要面部 ID 作为输入。在这些情况下，我们需要首先检测面部，然后使用检测到的面部作为参数调用我们希望使用的
    API。
- en: Using this knowledge, I challenge you to play around with the example in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Microsoft Cognitive Services"),
    *Getting Started with Microsoft Cognitive Services*. Draw a rectangle around the
    face. Mark the eyes in the image.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些知识，我挑战你尝试在 [第 1 章](ch01.html "第 1 章。使用 Microsoft Cognitive Services 入门")
    *使用 Microsoft Cognitive Services 入门* 中的示例。在面部周围画一个矩形。在图像中标记眼睛。
- en: Deciding whether two faces belong to the same person
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 判断两个面部是否属于同一个人
- en: To decide whether two faces belong to the same person, we are going to call
    the `Verify` function of the API. The API allows us to detect when two faces are
    of the same person, which is called **face-to-face verification**. Detecting whether
    a face belongs to a specific person is called **face-to-person verification**.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定两个面部是否属于同一个人，我们将调用API的`Verify`函数。API允许我们检测两个面部是否属于同一个人，这被称为**面对面验证**。检测一个面部是否属于特定的人被称为**人脸对人物验证**。
- en: The UI will consist of three button elements, two image elements, and one text
    block element. Two of the buttons will be used to browse for images, which are
    then shown in each image element. The last button will run the verification. The
    text block will output the result.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: UI将包括三个按钮元素、两个图像元素和一个文本块元素。其中两个按钮将用于浏览图像，然后显示在每个图像元素中。最后一个按钮将执行验证。文本块将输出结果。
- en: Lay out the UI how you want and bind the different elements to properties in
    the `ViewModel`, as we have done previously. In the `ViewModel`, there should
    be two `BitmapImage` properties for the image elements. There should be one `string`
    property, containing the verification result. Finally, there should be three `ICommand`
    properties, one for each of our buttons.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你想要的布局来布局UI，并将不同的元素绑定到`ViewModel`中的属性，就像我们之前做的那样。在`ViewModel`中，应该有两个`BitmapImage`属性用于图像元素。应该有一个`string`属性，包含验证结果。最后，应该有三个`ICommand`属性，每个按钮一个。
- en: Remember to add the UI to the `MainView.xaml` file as a new `TabItem`. In addition,
    add the `ViewModel` to the `MainViewModel.cs` file, where you will also need to
    add a new variable for the `FaceServiceClient` variable. This should be created
    with the Face API key, which we signed up for in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Microsoft Cognitive Services"), *Getting Started with Microsoft Cognitive
    Services*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住将UI添加到`MainView.xaml`文件中作为一个新的`TabItem`。此外，将`ViewModel`添加到`MainViewModel.cs`文件中，在那里你还需要为`FaceServiceClient`变量添加一个新的变量。这个变量应该使用我们在[第1章](ch01.html
    "第1章. 使用Microsoft认知服务入门")中注册的Face API密钥创建，即*使用Microsoft认知服务入门*。
- en: 'In the `ViewModel`, we need to declare the following three `private` variables:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`中，我们需要声明以下三个`private`变量：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have seen the first one before; it will access the Face API. The two `Guid`
    variables will be assigned when we have run the face detection.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到过第一个；它将访问Face API。当进行人脸检测时，将分配两个`Guid`变量。
- en: 'The constructor accepts one parameter, which is our `FaceServiceClient` object.
    This is assigned to the previously created variable, as shown in the following
    code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个参数，即我们的`FaceServiceClient`对象。这个对象被分配给之前创建的变量，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'From the constructor, we call the `Initialize` function to create the `DelegateCommand`
    properties, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从构造函数中，我们调用`Initialize`函数来创建`DelegateCommand`属性，如下所示：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The browse commands do not need to be disabled at any point, so we just pass
    on the command function, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览命令在任何时候都不需要被禁用，所以我们只需传递命令函数，如下所示：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Both functions will look similar. We call another function to browse for an
    image and detect a face. To separate each image, we pass on the image number.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数看起来很相似。我们调用另一个函数来浏览图像并检测人脸。为了分隔每个图像，我们传递图像编号。
- en: The `BrowseImageAsync` function will accept an `int` type as a parameter. It
    returns a `BitmapImage` object, which we assign to the `BitmapImage` property
    bound to our UI. The first part opens a browse dialog and returns the selected
    image. We will jump in when we have the image and the path to that image.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowseImageAsync`函数将接受一个`int`类型的参数。它返回一个`BitmapImage`对象，我们将它分配给绑定到我们UI的`BitmapImage`属性。第一部分打开浏览对话框并返回选定的图像。当我们有了图像及其路径时，我们将跳入。'
- en: 'We open the image as a `Stream` object. The `Stream` object is used in the
    API call to detect faces. When we call the API, we can use the default call, as
    it will return the value we are interested in, as shown in the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图像作为`Stream`对象打开。`Stream`对象用于API调用以检测人脸。当我们调用API时，我们可以使用默认调用，因为它将返回我们感兴趣的价值，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the detection process has completed, we check to see which image this
    is and assign the `FaceId` parameter to the correct `Guid` variable using the
    following code. For this example, we are assuming that there will be only one
    face per image:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测过程完成后，我们检查这是哪个图像，并使用以下代码将`FaceId`参数分配给正确的`Guid`变量。对于这个例子，我们假设每个图像中只有一个面部：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finish off the function by adding catch clauses as you see fit. You also need
    to create and return a `BitmapImage` parameter from the selected image.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加适当的捕获子句来完成函数。您还需要从所选图像创建并返回一个`BitmapImage`参数。
- en: 'Before the button for the face verification is enabled, we perform a check
    to see if both face IDs have been set using the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用人脸验证按钮之前，我们使用以下代码进行检查，以查看是否已设置两个人脸ID：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `VerifyFace` function is not a complex one, as you can see in the following
    code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`VerifyFace`函数并不复杂，如下所示代码所示：'
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the face IDs set, we can make a call to the `VerifyAsync` function of
    the API. We pass on the face IDs as parameters and get a `VerifyResult` object
    in return. We use this object to provide the output, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好人脸ID后，我们可以调用API的`VerifyAsync`函数。我们将人脸ID作为参数传递，并返回一个`VerifyResult`对象。我们使用此对象提供输出，如下所示：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A successful call will return a code `200` response. The response data is a
    `bool` type variable, `isIdentical`, and a number, `confidence`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用将返回代码`200`响应。响应数据是一个`bool`类型的变量`isIdentical`和一个数字`confidence`：
- en: '![Deciding whether two faces belong to the same person](img/B12373_02_05.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![判断两张脸是否属于同一个人](img/B12373_02_05.jpg)'
- en: At the time of writing, the `NuGet` package for the Face API only allows for
    face-to-face verification. If we were calling directly to the REST API, we could
    have utilized face-to-person verification as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，人脸API的`NuGet`包仅允许进行人脸对人脸验证。如果我们直接调用REST API，我们还可以利用人脸对人员验证。
- en: To use face-to-person verification, only one image is required. You will need
    to pass on the face ID for that image. You will also need to pass on a person
    group ID, and a person ID. These are to specify a specific person group to search
    in and a certain person within that group. We will cover person groups and persons
    later in this chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用人脸对人员验证，只需要一张图像。您需要传递该图像的人脸ID。您还需要传递人员组ID和人员ID。这些是为了指定要搜索的特定人员组以及该组中的特定人员。我们将在本章后面介绍人员组和人员。
- en: Finding similar faces
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找相似人脸
- en: Using the Face API, you can find faces similar to a provided face. The API allows
    for two search modes. Match person mode is the default mode. This will match faces
    to the same person, according to an internal same-person threshold. The other
    is match face mode, which will ignore the same-person threshold. This returns
    matches that are similar, but the similarity may be low.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用人脸API，您可以找到与提供的脸相似的人脸。API允许两种搜索模式。匹配人员模式是默认模式。这将根据内部相同人员的阈值将人脸与同一人匹配。另一种是匹配人脸模式，它将忽略相同人员的阈值。这返回相似度匹配，但相似度可能较低。
- en: 'In the example code provided, we have three buttons in our UI: one for generating
    a face list, another for adding faces to the list, and, finally, one to find similar
    faces. We need a textbox to specify a name for the face list. For convenience,
    we add a list box, outputting the persisted face IDs from the face list. We also
    add an image element to show the image we are checking, and a textbox outputting
    the result.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的示例代码中，我们的UI中有三个按钮：一个用于生成人脸列表，另一个用于将人脸添加到列表中，最后一个是用于查找相似人脸。我们需要一个文本框来指定人脸列表的名称。为了方便，我们添加了一个列表框，输出从人脸列表中持久化的脸ID。我们还添加了一个图像元素来显示我们正在检查的图像，以及一个输出结果的文本框。
- en: 'In the corresponding `ViewModel`, we need to add a `BitmapImage` property for
    the image element. We need two `string` properties: one for our face-list name
    and one for the API call result. To get data to our list box, we need an `ObservableCollection`
    property containing `Guids`. The buttons need to be hooked up to individual `ICommand`
    properties.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在相应的`ViewModel`中，我们需要为图像元素添加一个`BitmapImage`属性。我们需要两个`string`属性：一个用于我们的脸列表名称，另一个用于API调用结果。为了将数据传递到我们的列表框，我们需要一个包含`Guids`的`ObservableCollection`属性。按钮需要连接到单个`ICommand`属性。
- en: 'We declare two `private` variables at the start of the `ViewModel`, as shown
    in the following code. The first one is a `bool` variable to indicate whether
    or not the face list already exists. The other is used to access the Face API:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`的开始处，我们声明了两个`private`变量，如下所示代码所示。第一个是一个`bool`变量，用于指示人脸列表是否已存在。另一个用于访问人脸API：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The constructor should accept the `FaceServiceClient` parameter, which it assigns
    to the preceding variable. It will then call an `Initialize` function, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数应接受`FaceServiceClient`参数，并将其分配给前面的变量。然后，它将调用一个`Initialize`函数，如下所示：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, we initialize the `FaceListName` property to `Chapter2`. Next, we create
    the command objects, specifying actions and predicates.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`FaceListName`属性初始化为`Chapter2`。然后，我们创建命令对象，指定动作和谓词。
- en: 'We finish the `Initialize` function by calling two functions, as shown in the
    following code. One checks whether the face list exists, while the second updates
    the list of face IDs:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用两个函数来完成`Initialize`函数，如下所示。一个检查人脸列表是否存在，而另一个更新人脸ID列表：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To check whether a given face list exists, we first need to get a list of all
    face lists. We do this by calling the `ListFaceListsAsync` method, which will
    return a `FaceListMetadata` array. We make sure that the result has data before
    we loop through the array, as shown in the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查给定的人脸列表是否存在，我们首先需要获取所有人脸列表的列表。我们通过调用`ListFaceListsAsync`方法来完成此操作，它将返回一个`FaceListMetadata`数组。在遍历数组之前，我们确保结果有数据，如下所示：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Each `FaceListMetadata` array, from the resultant array, contains a face-list
    ID, a name of the face list, and user-provided data. For this example, we are
    just interested in the name. If the face-list name that we have specified is the
    name of any face list returned, we set the `_faceListExists` parameter to `true`,
    as shown in the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果数组中，每个`FaceListMetadata`数组都包含一个人脸列表ID、人脸列表名称和用户提供的资料。对于本例，我们只对名称感兴趣。如果指定的人脸列表名称是返回的任何人脸列表的名称，我们将`_faceListExists`参数设置为`true`，如下所示：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the face list exists, we can update the list of face IDs.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人脸列表存在，我们可以更新人脸ID列表。
- en: 'To get the faces in a face list, we need to get the face list first. This is
    done with a call to the Face API''s function, the `GetFaceListAsync` method. This
    requires the face-list ID to be passed as a parameter. The face-list ID needs
    to be in lowercase or digits, and can contain a maximum of 64 characters. For
    the sake of simplicity, we use the face-list name as the face ID, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取人脸列表中的面孔，我们首先需要获取人脸列表。这通过调用人脸API的`GetFaceListAsync`方法来完成。这需要将人脸列表ID作为参数传递。人脸列表ID需要是小写字母或数字，且最多可包含64个字符。为了简化，我们使用人脸列表名称作为人脸ID，如下所示：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The result of this API call is a `FaceList` object, containing the face-list
    ID and face-list name. It also contains user-provided data and an array of persisted
    faces.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此API调用的结果是包含人脸列表ID和人脸列表名称的`FaceList`对象。它还包含用户提供的资料和持久化面孔的数组。
- en: 'We check whether we have any data and then get the array of persisted faces.
    Looping through this array, we are able to get the `PersistedFaceId` parameter
    (as a `guid` variable) and user-provided data of each item. The persisted face
    ID is added to the `FaceIds ObservableCollection`, as shown in the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查是否有数据，然后获取持久化面孔的数组。通过遍历这个数组，我们能够获取每个项目的`PersistedFaceId`参数（作为一个`guid`变量）和用户提供的资料。持久化的人脸ID被添加到`FaceIds
    ObservableCollection`中，如下所示：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finish the function by adding the corresponding `catch` clause.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加相应的`catch`子句来完成函数。
- en: 'If the face list does not exist and we have specified a face-list name, then
    we can create a new face list, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人脸列表不存在且我们指定了人脸列表名称，则可以创建一个新的人脸列表，如下所示：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: First, we check to see that the face list does not exist. Using the `_faceServiceClient`
    parameter, you are required to pass on a face-list ID, a face-list name, and user
    data. As seen previously, the face-list ID needs to be lowercase characters or
    digits.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查人脸列表是否存在。使用`_faceServiceClient`参数，您需要传递人脸列表ID、人脸列表名称和用户数据。如前所述，人脸列表ID需要是小写字母或数字。
- en: Using the REST API, the user parameter is optional, and as such, you would not
    have to provide it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST API时，用户参数是可选的，因此您不必提供它。
- en: After we have created a face list, we want to ensure that it exists. We do this
    by a call to the previously created `DoesFaceListExistAsync` function. Add the
    `catch` clause to finish the function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建人脸列表后，我们想要确保它存在。我们通过调用之前创建的`DoesFaceListExistAsync`函数来完成此操作。添加`catch`子句以完成函数。
- en: If the named face list exists, we can add faces to this list. Add the `AddExampleFacesToList`
    function. It should accept `object` as a parameter. I will leave the details of
    adding the images up to you. In the provided example, we get a list of images
    from a given directory and loop through it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命名的人脸列表存在，我们可以向此列表添加面孔。添加`AddExampleFacesToList`函数。它应该接受`object`作为参数。我将把添加图像的细节留给你。在提供的示例中，我们从给定的目录中获取图像列表并遍历它。
- en: 'With the file path of a given image, we open the image as a `Stream`. To optimize
    it for our similarity operation, we find the `FaceRectangle` parameter in an image.
    As there should be only one face per image in the face list, we select the first
    element in the `Face` array, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定图像的文件路径，我们将图像作为`Stream`打开。为了优化我们的相似性操作，我们在图像中找到`FaceRectangle`参数。由于人脸列表中每张图像应该只有一个面部，我们在`Face`数组中选择第一个元素，如下所示：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Adding the face to the face list is as simple as calling the `AddFaceToFaceListAsync`
    function. We need to specify the face-list ID and the image. The image may come
    from a `Stream` (as in our case) or a URL. Optionally, we can add user data and
    the face rectangle of the image, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将人脸添加到人脸列表就像调用`AddFaceToFaceListAsync`函数一样简单。我们需要指定人脸列表ID和图像。图像可能来自`Stream`（如我们的情况）或URL。可选地，我们可以添加用户数据和图像的人脸矩形，如下所示：
- en: '[PRE51]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The result of the API call is an `AddPersistedFaceResult` variable. This contains
    the persisted face ID, which is different from a face ID in the `DetectAsync`
    call. A face added to a face list will not expire until it is deleted.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: API调用的结果是`AddPersistedFaceResult`变量。它包含持久化的人脸ID，这与`DetectAsync`调用中的人脸ID不同。添加到人脸列表中的人脸不会过期，直到被删除。
- en: We finish the function by calling the `UpdateFaceGuidsAsync` method.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`UpdateFaceGuidsAsync`方法来完成函数。
- en: Finally, we create our `FindSimilarFace` function, also accepting `object` as
    a parameter. To be able to search for similar faces, we need a face ID (the `Guid`
    variable) from the `DetectAsync` method. This can be called with a local image
    or from a URL. The example code opens a file browser and allows the user to browse
    for an image.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的`FindSimilarFace`函数，也接受`object`作为参数。为了能够搜索相似的人脸，我们需要从`DetectAsync`方法中获取人脸ID（`Guid`变量）。这可以通过本地图像或从URL调用。示例代码打开文件浏览器，允许用户浏览图像。
- en: 'With the face ID, we can search for similar faces, as shown in the following
    code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用人脸ID，我们可以搜索相似的人脸，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We call the `FindSimilarAsync` function. The first parameter is the face ID
    of the face we specified. The next parameter is the face-list ID, and the final
    parameter is the number of candidate faces returned. The default for this is 20,
    so it is often best to specify a number.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`FindSimilarAsync`函数。第一个参数是我们指定的面部ID。下一个参数是面部列表ID，最后一个参数是返回的候选面部数量。默认值为20，因此通常最好指定一个数字。
- en: Instead of using a face list to find similar faces, you can use an array of
    the `Guid` variable. That array should contain face IDs retrieved from the `DetectAsync`
    method.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用人脸列表查找相似人脸相比，您可以使用`Guid`变量的数组。该数组应包含从`DetectAsync`方法检索到的人脸ID。
- en: At the time of writing, the NuGet API package only supports match person mode.
    If you are using the REST API directly, you can specify the mode as a parameter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，NuGet API包仅支持匹配人员模式。如果您直接使用REST API，您可以指定模式作为参数。
- en: Depending on the mode selected, the result will contain either the face ID or
    the persisted face ID of similar faces. It will also contain the confidence of
    the similarity of the given face.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 根据选择的模式，结果将包含相似人脸的ID或持久化人脸ID。它还将包含给定人脸相似度的置信度。
- en: 'To delete a face from the face list, call the following function in the Face
    API:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要从人脸列表中删除人脸，请在Face API中调用以下函数：
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To delete a face list, call the following function in the Face API:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除人脸列表，请在Face API中调用以下函数：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To update a face list, call the following function in the Face API:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新人脸列表，请在Face API中调用以下函数：
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Grouping similar faces
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对相似人脸进行分组
- en: If you have several images of faces, one thing you may want to do is group the
    faces. Typically, you will want to group faces based on similarity, which is a
    feature the Face API provides.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个人脸图像，您可能想对人脸进行分组。通常，您将希望根据相似性对人脸进行分组，这是Face API提供的一项功能。
- en: By providing the API with a list of face IDs, it will respond with one or more
    groups. One group consists of faces that are similar looking. Usually, this means
    that the faces belong to the same person. Faces that cannot find any similar counterparts
    are placed in a group we'll call `MessyGroup`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向API提供人脸ID列表，它将响应一个或多个组。一个组由外观相似的人脸组成。通常，这意味着这些人脸属于同一个人。找不到任何相似对应物的人脸将被放置在我们称之为`MessyGroup`的组中。
- en: Create a new `View` called `FaceGroupingView.xaml`. The `View` should have six
    image elements, with corresponding titles and textboxes for face IDs. It should
    also have a button for our group command and a textbox to output the grouping
    result.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`View`，名为`FaceGroupingView.xaml`。该`View`应该有六个图像元素，以及对应的面部ID的标题和文本框。它还应该有一个用于分组命令的按钮和一个用于输出分组结果的文本框。
- en: In the corresponding `FaceGroupingViewModel.xaml` `View` model, you should add
    the `BitmapImage` properties for all images. You should also add the `string`
    properties for the face IDs and one for the result. There is also a need for an
    `ICommand` property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在相应的`FaceGroupingViewModel.xaml` `View`模型中，你应该为所有图像添加`BitmapImage`属性。你还应该添加面部ID的`string`属性和一个用于结果的属性。还需要一个`ICommand`属性。
- en: 'At the start of the `ViewModel`, we declare some `private` variables, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`的开始处，我们声明了一些`private`变量，如下所示：
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first one is used to access the Face API. The second one contains a list
    of strings that in turn contain the location of our images. The last list contains
    the detected face IDs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于访问面部API。第二个包含一个字符串列表，该列表包含我们图像的位置。最后一个列表包含检测到的面部ID。
- en: The constructor accepts a parameter of the `FaceServiceClient` type. It assigns
    it to the corresponding variable and calls the `Initialize` function. This creates
    our `ICommand` object and calls a function to add our images to the application.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个`FaceServiceClient`类型的参数。它将其分配给相应的变量并调用`Initialize`函数。这创建我们的`ICommand`对象并调用一个函数将我们的图像添加到应用程序中。
- en: 'In the function that adds images, we add hardcoded image paths to our `_imageFiles`
    list. For this example, we add six. Using a `for` loop, we generate each `BitmapImage`
    property. When we have an image, we want to detect faces in it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加图像的函数中，我们将硬编码的图像路径添加到我们的`_imageFiles`列表中。在这个例子中，我们添加了六个。使用`for`循环，我们生成每个`BitmapImage`属性。当我们有一个图像时，我们想要检测其中的面部：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We do not need any more data than the generated face ID, which we know is stored
    for 24 hours after detection:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要比生成的面部ID更多的数据，我们知道该ID在检测后存储24小时：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Assuming that there is only one face per image, we add that face ID to our `_faceIds`
    list. The image, face ID, and current iteration number in the loop are passed
    on to a new function, `CreateImageSources`. This function contains a `switch`
    case based on the iteration number. Based on the number, we assign the image and
    face ID to the corresponding image and image ID property. This is then shown in
    the UI.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每张图像中只有一个面部，我们将该面部ID添加到我们的`_faceIds`列表中。然后将图像、面部ID和循环中的当前迭代次数传递给一个新的函数`CreateImageSources`。这个函数包含一个基于迭代号的`switch`案例。根据数字，我们将图像和面部ID分配给相应的图像和图像ID属性。然后在UI中显示。
- en: 'We have a button to group the images. To group the images, we call the Face
    API''s `GroupAsync` method, passing on an array of face IDs, as shown in the following
    code. The array of face IDs must contain at least two elements, and it cannot
    contain more than 1,000 elements:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个按钮来分组图像。要分组图像，我们调用面部API的`GroupAsync`方法，传递一个包含面部ID的数组，如下所示。面部ID数组必须至少包含两个元素，并且不能包含超过1,000个元素：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The response is a `GroupResult` type, which may contain one or more groups,
    as well as the messy group. We check to see whether there is a response and then
    we parse it, as shown in the following code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是`GroupResult`类型，可能包含一个或多个组，以及混乱的组。我们检查是否有响应，然后解析它，如下所示：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Before looking at the `ParseGroupResult` method, add the corresponding `catch`
    clause and close-up `GroupFaces` function.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`ParseGroupResult`方法之前，添加相应的`catch`子句并关闭`GroupFaces`函数。
- en: 'When parsing the results, we first create a `StringBuilder` class to hold our
    text. Then we get the `groups` from the result. A group is an array of face IDs
    of the images in that group. All groups are stored in a list, and we append the
    number of groups to the `StringBuilder` class, as shown in the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析结果时，我们首先创建一个`StringBuilder`类来保存我们的文本。然后我们从结果中获取`groups`。一个组是该组中图像的面部ID数组。所有组都存储在一个列表中，我们将组的数量追加到`StringBuilder`类中，如下所示：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We loop through the list of groups. Inside this loop, we loop through each
    item in the group. For the sake of readability, we have a helper function to find
    the image name from the ID. It finds the index in our `_faceIds` list. This is
    then used in the image name, so if the index is `2`, the image name would be `Image
    3`. For this to give the intended effect, you must have placed the images in a
    logical order, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历组列表。在这个循环内部，我们遍历组中的每个项目。为了提高可读性，我们有一个辅助函数来从 ID 中找到图像名称。它找到我们 `_faceIds`
    列表中的索引。然后用于图像名称，所以如果索引是 `2`，图像名称将是 `Image 3`。为了达到预期的效果，你必须按照以下逻辑顺序放置图像：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `GroupResult` method may also contain a `MessyGroup` array. This is an
    array of `Guid` variables containing the face IDs in that group. We loop through
    this array and append the image name, the same way we did with the regular groups,
    as shown in the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupResult` 方法也可能包含一个 `MessyGroup` 数组。这是一个包含该组中面部 ID 的 `Guid` 变量的数组。我们遍历这个数组，以与常规组相同的方式追加图像名称，如下所示代码所示：'
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We end the function by returning the `StringBuilder` function''s text, which
    will output it to the screen, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过返回 `StringBuilder` 函数的文本来结束函数，这将输出到屏幕上，如下所示：
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Make sure that the `ViewModel` instances have been created in the `MainViewModel.cs`
    file. Also, make sure that the `View` has been added as a `TabItem` property in
    the `MainView.xaml` file. Compile and test the application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `MainViewModel.cs` 文件中创建了 `ViewModel` 实例。同时，确保 `View` 已添加到 `MainView.xaml`
    文件中的 `TabItem` 属性。编译并测试应用程序。
- en: 'If you are using the sample images provided, you may end up with something
    like the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用提供的示例图像，你可能会得到以下结果：
- en: '![Grouping similar faces](img/B12373_02_06.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![分组相似的面部](img/B12373_02_06.jpg)'
- en: Adding identification to our smart-house application
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的智能家居应用程序添加标识
- en: As a part of our smart-house application, we want the application to recognize
    who we are. Doing so opens up the opportunity to get responses and actions from
    the application, tailored to you.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们智能家居应用程序的一部分，我们希望应用程序能够识别我们是谁。这样做为我们提供了从应用程序获取针对您的响应和操作的机会。
- en: Creating our smart-house application
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的智能家居应用程序
- en: Create a new project for the smart-house application, based on the MVVM template
    we created earlier.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前创建的 MVVM 模板创建智能家居应用程序的新项目。
- en: With the new project created, add the `Microsoft.ProjectOxford.Face` NuGet package.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目后，添加 `Microsoft.ProjectOxford.Face` NuGet 包。
- en: As we will be building this application throughout this book, we will start
    small. In the `MainView.xaml` file, add a `TabControl` property containing two
    items. The two items should be two user controls, one called the `AdministrationView.xaml`
    file and the other called the `HomeView.xaml` file.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在这本书中构建这个应用程序，我们将从小处开始。在 `MainView.xaml` 文件中，添加一个包含两个项目的 `TabControl` 属性。这两个项目应该是两个用户控件，一个称为
    `AdministrationView.xaml` 文件，另一个称为 `HomeView.xaml` 文件。
- en: The administration control will be where we administer different parts of the
    application. The home control will be the starting point and the main control
    to use.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 管理控制将是我们管理应用程序不同部分的地方。主页控制将是起点和主要控制。
- en: Add corresponding `ViewModel` instances to the `Views`. Make sure they are declared
    and created in `MainViewModel.cs`, as we have seen throughout this chapter. Make
    sure that the application compiles and runs before moving on.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 将相应的 `ViewModel` 实例添加到 `Views` 中。确保它们在 `MainViewModel.cs` 中声明和创建，正如我们在这章中看到的。在继续之前，请确保应用程序可以编译并运行。
- en: Adding people to be identified
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加要识别的人员
- en: Before we can go on to identify a person, we need to have something to identify
    them from. To identify a person, we need a `PersonGroup` property. This is a group
    that contains several `Persons` properties.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够继续识别一个人之前，我们需要有一些东西来识别他们。为了识别一个人，我们需要一个 `PersonGroup` 属性。这是一个包含几个 `Persons`
    属性的组。
- en: Creating a view
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建视图
- en: In the administration control, we will execute several operations in this regard.
    The UI should contain two textbox elements, two list box elements, and six buttons.
    The two textbox elements will allow us to input a name for the person group and
    a name for the person. One list box will list all person groups that we have available.
    The other will list all the persons in any given group.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理控制中，我们将执行这方面的几个操作。UI 应包含两个文本框元素、两个列表框元素和六个按钮。两个文本框元素将允许我们输入人员组名称和人员名称。一个列表框将列出我们可用的所有人员组。另一个将列出任何给定组中的所有人员。
- en: 'We have buttons for each of the operations that we want to execute, which are
    as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个要执行的操作都设置了按钮，具体如下：
- en: Add person group
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加人员组
- en: Delete person group
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除人员组
- en: Train person group
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练人员组
- en: Add person
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加人员
- en: Delete person
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除人员
- en: Add person face
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加人员面部
- en: 'The `View` model should have two `ObservableCollection` properties: one of
    a `PersonGroup` type and the other of a `Person` type. We should also add three
    `string` properties. One will be for our person group name, the other for our
    person name. The last will hold some status text. We also want a `PersonGroup`
    property for the selected person group. Finally, we want a `Person` property holding
    the selected person.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`模型应该有两个`ObservableCollection`属性：一个为`PersonGroup`类型，另一个为`Person`类型。我们还应该添加三个`string`属性。一个将用于我们的人员组名称，另一个用于我们的人员名称。最后一个将保存一些状态文本。我们还想添加一个`PersonGroup`属性来选择人员组。最后，我们还想添加一个`Person`属性来保存所选人员。'
- en: 'In our `View` model, we want to add a `private` variable for the `FaceServiceClient`
    method, as shown in the following code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`View`模型中，我们希望为`FaceServiceClient`方法添加一个`private`变量，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This should be assigned in the constructor, which should accept a parameter
    of a `FaceServiceClient` type. It should also call an initialization function,
    which will initialize six `ICommand` properties. These maps to the buttons, created
    earlier. The initialization function should call the `GetPersonGroups` function
    to list all person groups available, as shown in the following code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在构造函数中分配，构造函数应接受一个`FaceServiceClient`类型的参数。它还应调用一个初始化函数，该函数将初始化六个`ICommand`属性。这些属性对应于之前创建的按钮。初始化函数应调用`GetPersonGroups`函数来列出所有可用的人员组，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `ListPersonGroupsAsync` function does not take any parameters, and returns
    a `PersonGroup` array if successfully executed, as shown in the following code:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListPersonGroupsAsync`函数不接受任何参数，如果成功执行，则返回一个`PersonGroup`数组，如下面的代码所示：'
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We then check to see whether the array contains any elements. If it does, we
    clear out the existing `PersonGroups` list. Then we loop through each item of
    the `PersonGroup` array and add them to the `PersonGroups` list.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查数组是否包含任何元素。如果包含，我们将清除现有的`PersonGroups`列表。然后我们遍历`PersonGroup`数组中的每个项目，并将它们添加到`PersonGroups`列表中。
- en: If no person groups exist, we can add a new one by filling in a name. The name
    you fill in here will also be used as a person group ID. This means that it can
    include numbers and English lowercase letters, the "-" character (hyphen), and
    the "_" character (underscore). The maximum length is 64 characters. When it is
    filled in, we can add a person group.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有人员组存在，我们可以通过填写一个名称来添加一个新的组。你在这里填写的名称也将用作人员组ID。这意味着它可以包含数字和英文小写字母，"-"字符（连字符）和"_"字符（下划线）。最大长度为64个字符。当它被填写后，我们可以添加一个人员组。
- en: Adding person groups
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加人员组
- en: 'First, we call the `DoesPersonGroupExistAsync` function, specifying `PersonGroupName`
    as a parameter, as shown in the following code. If this is `true`, then the name
    we have given already exists, and as such, we are not allowed to add it. Note
    how we call the `ToLower` function on the name. This is so we are sure that the
    ID is in lowercase:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`DoesPersonGroupExistAsync`函数，指定`PersonGroupName`作为参数，如下面的代码所示。如果这是`true`，那么我们给出的名字已经存在，因此我们不允许添加它。注意我们如何在名字上调用`ToLower`函数。这样做是为了确保ID是小写的：
- en: '[PRE68]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If the person group does not exist, we call the `CreatePersonGroupAsync` function,
    as shown in the following code. Again, we specify the `PersonGroupName` as lowercase
    in the first parameter. This represents the ID of the group. The second parameter
    indicates the name we want. We end the function by calling the `GetPersonGroups`
    function again, so we get the newly added group in our list:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人员组不存在，我们将调用`CreatePersonGroupAsync`函数，如下面的代码所示。同样，我们在第一个参数中将`PersonGroupName`指定为小写。这代表组的ID。第二个参数表示我们想要的名字。我们通过再次调用`GetPersonGroups`函数来结束函数，这样我们就可以在我们的列表中获得新添加的组：
- en: '[PRE69]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `DoesPersonGroupExistAsync` function makes one API call. It tries to call
    the `GetPersonGroupAsync` function, with the person group ID specified as a parameter.
    If the resultant `PersonGroup` list is anything but `null`, we return `true`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoesPersonGroupExistAsync`函数执行一个API调用。它尝试调用`GetPersonGroupAsync`函数，将人员组ID指定为参数。如果结果`PersonGroup`列表不是`null`，则返回`true`。'
- en: 'To delete a person group, a group must be selected as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除人员组，必须按照以下方式选择一个组：
- en: '[PRE70]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The API call to the `DeletePersonGroupAsync` function requires a person group
    ID as a parameter. We get this from the selected person group. If no exception
    is caught, then the call has completed successfully, and we call the `GetPersonGroups`
    function to update our list.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`DeletePersonGroupAsync`函数的API需要将人员组ID作为参数。我们从所选人员组中获取这个ID。如果没有捕获到异常，那么调用已经成功完成，然后我们调用`GetPersonGroups`函数来更新我们的列表。
- en: 'When a person group is selected from the list, we make sure that we call the
    `GetPersons` function. This will update the list of persons, as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当从列表中选择人员组时，我们确保调用`GetPersons`函数。这将更新人员列表，如下所示：
- en: '[PRE71]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We make sure the selected person group is not `null`. If it is not, we clear
    our `persons` list. The API call to the `GetPersonsAsync` function requires a
    person group ID as a parameter. A successful call will result in a `Person` array.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保所选的人员组不是`null`。如果不是，我们清空我们的`persons`列表。调用`GetPersonsAsync`函数的API需要人员组ID作为参数。成功的调用将导致一个`Person`数组。
- en: 'If the resultant array contains any elements, we loop through it. Each `Person`
    object is added to our `persons` list, as shown in the following code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果数组包含任何元素，我们将遍历它。每个`Person`对象都将添加到我们的`persons`列表中，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Adding new persons
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新人员
- en: 'If no persons exist, we can add new ones. To add a new one, a person group
    must be selected, and a name of the person must be filled in. With this in place,
    we can click on the **Add** button:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有人员存在，我们可以添加新的。要添加一个新的人员，必须选择一个人员组，并填写该人员的姓名。完成这些步骤后，我们可以点击**添加**按钮：
- en: '[PRE73]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The API call to the `CreatePersonAsync` function requires a person group ID
    as the first parameter. The next parameter is the name of the person. Optionally,
    we can add user data as a third parameter. In this case, it should be a string.
    When a new person has been created, we update the `persons` list by calling the
    `GetPersons` function again.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`CreatePersonAsync`函数的API需要人员组ID作为第一个参数。下一个参数是人员的姓名。可选地，我们可以添加用户数据作为第三个参数。在这种情况下，它应该是一个字符串。当创建了一个新人员后，我们通过再次调用`GetPersons`函数来更新`persons`列表。
- en: 'If we have selected a person group and a person, then we will be able to delete
    that person, as shown in the following code:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已选择一个人员组和一个人，那么我们将能够删除那个人，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: To delete a person, we make a call to the `DeletePersonAsync` function. This
    requires the person group ID of the person group the person lives in. It also
    requires the ID of the person we want to delete. If no exceptions are caught,
    then the call succeeded, and we call the `GetPersons` function to update our person
    list.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个人，我们调用`DeletePersonAsync`函数。这需要该人员所在人员组的ID以及我们想要删除的人员的ID。如果没有捕获到异常，那么调用成功，然后我们调用`GetPersons`函数来更新我们的人员列表。
- en: 'Our administration control now looks similar to the following screenshot:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管理控制界面现在看起来类似于以下截图：
- en: '![Adding new persons](img/B12373_02_07.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![添加新人员](img/B12373_02_07.jpg)'
- en: Associating faces with a person
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将面部与人员关联
- en: 'Before we can identify a person, we need to associate faces with that person.
    With a given person group and person selected, we can add faces. To do so, we
    open a file dialog. When we have an image file, we can add the face to the person,
    as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够识别一个人之前，我们需要将面部与那个人关联起来。在给定的人员组和人员被选中后，我们可以添加面部。为此，我们打开一个文件对话框。当我们有一个图像文件时，我们可以按照以下方式将该面部添加到人员中：
- en: '[PRE75]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We open the image file as a `Stream`. This file is passed on as the third parameter
    in our call to the `AddPersonFaceAsync` function. Instead of a stream, we could
    have passed a URL to an image.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图像文件作为`Stream`打开。这个文件作为我们调用`AddPersonFaceAsync`函数的第三个参数传递。我们也可以传递一个指向图像的URL而不是流。
- en: The first parameter in the call is the person group ID of the group in which
    the person lives. The next parameter is the person ID.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 调用的第一个参数是人员所在组的人员组ID。下一个参数是人员ID。
- en: Some optional parameters to include are user data in the form of a string and
    a `FaceRectangle` parameter for the image. The `FaceRectangle` parameter is required
    if there is more than one face in the image.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 可以包含的一些可选参数包括以字符串形式提供用户数据和用于图像的`FaceRectangle`参数。如果图像中有多于一个面部，则`FaceRectangle`参数是必需的。
- en: A successful call will result in an `AddPersistedFaceResult` object. This contains
    the persisted face ID for the person.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用将导致一个`AddPersistedFaceResult`对象。它包含该人员的持久化面部ID。
- en: Each person can have a maximum of 248 faces associated with it. The more faces
    you can add, the more likely it is that you will receive a solid identification
    later. The faces that you add should from slightly different angles.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Training the model
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With enough faces associated with the persons, we need to train the person group.
    This is a task that is required after any change to a person or person group.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'We can train a person group when one has been selected, as shown in the following
    code:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The call to the `TrainPersonGroupAsync` function takes a person group ID as
    a parameter, as shown in the following code. It does not return anything, and
    it may take a while to execute:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We want to ensure that the training completed successfully. To do so, we call
    the `GetPersonGroupTrainingStatusAsync` function inside a `while` loop. This call
    requires a person group ID, and a successful call results in a `TrainingStatus`
    object, as shown in the following code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We check the status and we show the result if it is not running. If the training
    is still running, we wait for one second and run the check again.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: When the training has succeeded, we are ready to identify people.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Additional functionality
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few API calls that we have not looked at, which will be mentioned
    briefly in the following bullet list:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'To update a person group, call the following; this function does not return
    anything:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To get a person''s face, call the following:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: A successful call returns the persisted face ID and user-provided data.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To delete a person''s face, call the following; this call does not return anything:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To update a person, call the following; this call does not return anything:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To update a person''s face, call the following; this call does not return anything:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Identifying a person
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To identify a person, we are first going to upload an image. Open the `HomeView.xaml`
    file and add a `ListBox` element to the UI. This will contain the person groups
    to choose from when identifying a person. We will need to add a button element
    to find an image, upload it, and identify the person. A `TextBox` element is added
    to show the working response. For our own convenience, we also add an image element
    to show the image we are using.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: In the `View` model, add an `ObservableCollection` property of a `PersonGroup`
    type. We need to add a property for the selected `PersonGroup` type. Also, add
    a `BitmapImage` property for our image, and a string property for the response.
    We will also need an `ICommand` property for our button.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `private` variable for the `FaceServiceClient` type, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This will be assigned in our constructor, which should accept a parameter of
    a `FaceServiceClient` type. From the constructor, call on the `Initialize` function
    to initialize everything, as shown in the following code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: First, we call the `GetPersonGroups` function to retrieve all the person groups.
    This function makes a call to the `ListPersonGroupsAsync` API, which we saw earlier.
    The result is added to our `PersonGroup` list's `ObservableCollection` parameter.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create our `ICommand` object. The `CanUploadOwnerImage` function will
    return `true` if we have selected an item from the `PersonGroup` list. If we have
    not, it will return `false`, and we will not be able to identify anyone.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UploadOwnerImage` function, we first browse to an image and then load
    it. With an image loaded and a file path available, we can start to identify the
    person in the image, as shown in the following code:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We open the image as a `Stream` type, as shown in the following code. Using
    this, we detect faces in the image. From the detected faces, we get all the face
    IDs in an array:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The array of face IDs will be sent as the second parameter to the `IdentifyAsync`
    API call. Remember that when we detect a face, it is stored for 24 hours. Proceeding
    to use the corresponding face ID will make sure that the service knows which face
    to use for identification.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter used is the ID of the person group we have selected. The
    last parameter in the call is the number of candidates returned. As we do not
    want to identify more than one person at a time, we specify one. Because of this,
    we should ensure that there is only one face in the image we upload.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful API call will result in an array of the `IdentifyResult` parameter,
    as shown in the following code. Each item in this array will contain candidates:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We loop through the array of results, as shown in the following code. If we
    do not have any candidates, we just break out of the loop. If, however, we do
    have candidates, we get the `PersonId` parameter of the first candidate (we asked
    for only one candidate earlier, so this is okay):'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'With the `personId` parameter, we get a single `Person` object, using the API
    to call the `GetPersonAsync` function. If the call is successful, we print a welcome
    message to the correct person (as shown in the following screenshot) and break
    out of the loop:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying a person](img/B12373_02_08.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: Knowing your mood using the Face API
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Face API allows you to recognize emotions from faces.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Research has shown that there are some key emotions that can be classified as
    cross-cultural. These are happiness, sadness, surprise, anger, fear, contempt,
    disgust, and neutral. All of these are detected by the API, which allows your
    applications to respond in a more personalized way by knowing the user's mood.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to recognize emotions from images so that our smart-house
    application can know our mood.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Getting images from a web camera
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that there are several cameras around your house. The smart-house application
    can see what your mood is at any time. By knowing this, it can utilize the mood
    to better predict your needs.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add web-camera capabilities to our application. If you do not
    have a web camera, you can follow along, but load images using the techniques
    we have already seen.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: First we need to add a NuGet package to our smart-house application. Search
    for `OpenCvSharp3-AnyCPU` and install the package by **shimat**. This is a package
    that allows for the processing of images, and is utilized by the next dependency
    we are going to add.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example code provided, there is a project called `VideoFrameAnalyzer`.
    This is a project written by Microsoft that allows us to grab frame-by-frame images
    from a web camera. Using this, we are able to analyze emotions in our application.
    The use case we will execute is as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting images from a web camera](img/B12373_02_09.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: In our `HomeView.xaml` file, add two new buttons. One will be to start the web
    camera while the other will be to stop it.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'In the corresponding `View` model, add two `ICommand` properties for each of
    the buttons. Also add the following `private` members:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The first one is a `FrameGrabber` object, which is from the `VideoFrameAnalyzer`
    project. The `static` member is an array of parameters for images, and is used
    when fetching web camera images. Additionally, we need to add a `CameraResult`
    class, which should be within the `ViewModel` file.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize the `EmotionScores` to `null`, as shown in the following code.
    This is done so that new emotion scores always will be assigned from the most
    resent analysis result:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Add an initialization of the `_frameGrabber` member in the constructor and
    add the following in the `Initialization` function:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Each time a new frame is provided from the camera, an event is raised.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'When we receive new frames, we want to create a `BitmapImage` from it to show
    it in the UI. To do so requires us to invoke the action from the current dispatcher,
    as the event is triggered from a background thread, as shown in the following
    code:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We get the `BitmapSource` of the `Frame` and create some required variables.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `encoder` we created, we add the `bitmapSource` and save it to the
    `memoryStream`, as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This `memoryStream` is then assigned to the `BitmapImage` we created, as shown
    in the following code. This is in turn assigned to the `ImageSource`, which will
    show the frame in the UI:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As this event will be triggered a lot, we will get a fluent stream in the UI,
    and it will seem like it is a direct video feed.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Initialization` function, we will also need to create our `ICommand`
    for the buttons, as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To be able to start the camera, we need to have selected a person group, and
    we need to have at least one camera available:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To start a camera, we need to specify which camera to use and how often we
    want to trigger an analysis using the following code:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If no camera is specified in `StartProcessingCameraAsync`, the first one available
    is chosen by default.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: We will get back to the analysis part of this process soon.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the camera, we run the following command:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Letting the smart house know your mood
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a video from the web camera available for our use.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: In the `FrameGrabber` class, there is a `Func`, which will be used for analysis
    functions. We need to create the function that will be passed on this that will
    enable emotions to be recognized.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function, `EmotionAnalysisAsync`, that accepts a `VideoFrame` as
    a parameter. The return type should be `Task<CameraResult>` and the function should
    be marked as `async`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'The `frame` we get as a parameter is used to create a `MemoryStream` containing
    the current frame. This will be in the JPG file format. We will find a face in
    this image, and we want to ensure that we specify that we want emotion attributes
    using the following code:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'A successful call will result in an object containing all the emotion scores,
    as shown in the following code. The scores are what we want to return:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Catch any exceptions that may be thrown, returning `null` when they are.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: We need to assign the `Initialize` function to the `Func`. We also need to add
    an event handler each time we have a new result.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new result is obtained, we grab the `EmotionScore` that is received,
    as shown in the following code. If it is `null` or does not contain any elements,
    then we do not want to do anything else:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In the following code, we parse the emotion scores in `AnalyseEmotions`, which
    we will look at in a bit:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Using the result from `AnalyseEmotions`, we print a string to the result to
    indicate the current mood. This will need to be invoked from the current dispatcher,
    as the event has been triggered in another thread.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the current mood in a readable format, we parse the emotion scores in
    `AnalyseEmotions` as follows:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: With the `Scores` we get, we call a `ToRankedList` function. This will return
    a list of `KeyValuePair`, containing each emotion, along with the corresponding
    confidence. The first one will be the most likely, the second will be the second
    most likely, and so on. We only care about the most likely one, so we select it.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'With the top emotion score selected, we use a `switch` statement to find the
    correct emotion. This is returned and printed to the result, as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The last piece of the puzzle is to make sure that the analysis is being executed
    at a specified interval. In the `StartCamera` function, add the following line,
    just before calling `StartProcessingCamera`:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This will trigger an emotion analysis to be called every fifth second.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'When I have a smile on my face, the application now knows that I am happy and
    can provide further interaction accordingly. If we compile and run the example,
    we should get results like those shown in the following screenshots:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '![Letting the smart house know your mood](img/B12373_02_10.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
- en: 'As my mood changes to neutral, the application detects this as well:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '![Letting the smart house know your mood](img/B12373_02_11.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
- en: Automatically moderating user content
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the content moderator API, we can add monitoring to user-generated content.
    The API is created to assist with flags and to assess and filter offensive and
    unwanted content.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Types of content moderation APIs
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will quickly go through the key features of the moderation APIs in this section.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reference to the documentation for all APIs can be found at [https://docs.microsoft.com/nb-no/azure/cognitive-services/content-moderator/api-reference](https://docs.microsoft.com/nb-no/azure/cognitive-services/content-moderator/api-reference).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Image moderation
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The image moderation API allows you to moderate images for adult and inappropriate
    content. It can also extract textual content and detect faces in images.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: When using the API to evaluate inappropriate content, the API will take an image
    as input. Based on the image, it will return a Boolean value, indicating whether
    the image is appropriate or not. It will also contain a corresponding confidence
    score between 0 and 1\. The Boolean value is set based on a set of default thresholds.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: If the image contains any text, the API will use OCR to extract the text. It
    will then look for the same adult or racy content as text moderation, which we
    will get to shortly.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Some content-based applications may not want to display any personally identifiable
    information, in which case it can be wise to detect faces in images. Based on
    the information retrieved in the face-detection evaluation, you can ensure that
    no user content contains images of people.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Text moderation
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the text moderation API, you can screen text against custom and shared
    lists of text. It is able to detect personally identifiable information and profanity
    in text. In this case, personally identifiable information is the presence of
    information such as email addresses, phone numbers, and mailing addresses.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: When you submit a text to be moderated, the API can detect the language used,
    if it is not stated. Screening text will automatically correct any misspelled
    words (to catch deliberately misspelled words). The results will contain the location
    of profanities and personal identifiable information in the text, as well as the
    original text, autocorrected text, and the language. Using these results, you
    can moderate content appropriately.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Moderation tools
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three ways to moderate content, enabled by the content moderator:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '**Human moderation**: Using teams and community to manually moderate all content'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated moderation**: Utilizing machine learning and AI to moderate at
    scale with no human interaction'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid moderation**: A combination of the preceding two, where people typically
    occasionally do reviews'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The common scenario used is the last one. This is where machine learning is
    used to automate the moderation process and teams of people can review the moderation.
    Microsoft have created a review tool to ease this process. This allows you to
    see through all the items for review in a web browser while using the APIs in
    your application. We will look into this tool in the following section.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Using the
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'l, head over to [https://contentmoderator.cognitive.microsoft.com/](https://contentmoderator.cognitive.microsoft.com/).
    From here, you can sign in using your Microsoft account. On your first sign-in,
    you will need to register by adding your name to the account. You will then go
    on to create a *review team*, as shown in the following screenshot:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the](img/B12373_02_12.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
- en: You can do this by selecting the region and entering a team name. You can optionally
    enter the email addresses of other people who should be part of the team. Click
    on **Create Team**.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'Once in, you will be presented with the following dashboard:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the](img/B12373_02_13.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
- en: You will be presented with the total number of images and textual content that
    are for review. You will also be presented with the total number of completed
    and pending reviews. The dashboard also lists the users that have completed reviews,
    as well as any tags used for content.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'By selecting the **Try** option in the menu, you have the option to upload
    images or text to execute moderation online. Do this by either uploading an image
    or entering sample text in the textbox. Once done, you can select the **Review**
    option, where you will be presented with the following screen:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the](img/B12373_02_14.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
- en: If the given content is either adult content or racist, you can click on the
    **a** or **r** buttons, respectively. For text, any profanities will be displayed.
    Once you are done marking reviews, click on **Next**. This will go through a process
    of moderating the given content.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from the APIs and the review tool, there are two other tools you can
    use, as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '**List manager API**: Using custom lists of images and text to moderate pre-identified
    content that you don''t wish to scan for repeatedly'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workflow API**: Using this API, you can define conditional logic and actions
    to specify the policies used by your specific content'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use any of these APIs, or to use the moderator APIs, you can make calls
    to specific REST APIs. To do so, you will need to use an API key and a base URL.
    These settings can be found under **Settings | Credentials** on the review tool
    website, as shown in the following screenshot:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '![Other tools](img/B12373_02_15.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
- en: Building your own image classifiers
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Custom Vision** service allows you to build your own image classifiers.
    There might be cases where you require special images to use the image APIs. Such
    cases may be from a factory, where the equipment you need to recognize is not
    very available. You can start to build a prototype, using as little
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Building a classifier
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a classifier, you will need to create a new project. Doing so will
    allow you to specify what category the images will be in. You will also select
    the classification type and project type.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, you will need to upload images. This can be done through the web
    page or through a REST API. All images must be tagged so that the classifier will
    recognize similar images later.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Once all images (at least 50) are uploaded, you must train your model. Once
    the training is complete, you will be presented with a precision percentage per
    tag. This is a measurement of the accuracy of the model.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Improving the model
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the website, you can test your models. Doing so will allow you to upload
    images, which will be classified by the model. If it turns out that the model
    performs poorly, you can improve the model.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'Improving the model involves uploading more images. Some general guidelines
    to improve the model are as follows:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Have enough images
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the balance between tags is good (so that there is an equal number
    of images per tag)
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a diverse set of images for training
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use images that have been used for prediction
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect the predictions
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the trained model
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you are happy with the model, you can use it for predictions. The model
    can be used in one of the two following ways:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: With a REST API
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export it to a model file
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first choice involves uploading an image. Calling the generated endpoint
    for your model, along with the image data, will result in a prediction. The result
    will contain the predicted tags, ordered by their probability.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: The second choice allows you to run the prediction offline. This means that
    you can utilize different frameworks, such as TensorFlow, CoreML, and ONNX, for
    different platforms. How to use the model with these frameworks is beyond the
    scope of this book. The downside of using an offline model is that the accuracy
    may suffer a bit compared to the online version.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into a big part of the vision APIs. You
    first learned how to get good descriptions of images. Next, you learned how to
    recognize celebrities and text in images, and you learned how to generate thumbnails.
    Following this, we moved on to the Face API, where we got more information about
    detected faces. We found out how to verify whether two faces were the same. After
    this, you learned how to find similar faces and group similar faces. Then we added
    identification to our smart-house application, allowing it to know who we are.
    We also added the ability to recognize emotions in faces. We took a quick look
    into the content moderator to see how you can add automatic moderation to user-generated
    content. Finally, we briefly looked at the Custom Vision service, and how you
    can use it to generate specific prediction models.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will continue with the final vision API. We will focus on videos,
    learning what the video indexer API has to offer.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
