- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Machine Learning Development Process
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习开发过程
- en: In this chapter, we will define how the work for any successful **machine learning**
    (**ML**) software engineering project can be divided up. Basically, we will answer
    the question of how you *actually organize the doing* of a successful ML project.
    We will not only discuss the process and workflow but we will also set up the
    tools you will need for each stage of the process and highlight some important
    best practices with real ML code examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义如何将任何成功的**机器学习**（**ML**）软件工程项目的工作进行划分。基本上，我们将回答您如何*实际上组织一个成功的ML项目*的问题。我们不仅将讨论流程和工作流程，还将为流程的每个阶段设置所需的工具，并通过真实的ML代码示例突出一些重要的最佳实践。
- en: 'In this edition, there will be more details on an important data science and
    ML project management methodology: **Cross-Industry Standard Process for Data
    Mining** (**CRISP-DM**). This will include a discussion of how this methodology
    compares to traditional Agile and Waterfall methodologies and will provide some
    tips and tricks for applying it to your ML projects. There are also far more detailed
    examples to help you get up and running with **continuous integration/continuous
    deployment** (**CI/CD**) using GitHub Actions, including how to run ML-focused
    processes such as automated model validation. The advice on getting up and running
    in an **Interactive Development Environment** (**IDE**) has also been made more
    tool-agnostic, to allow for those using any appropriate IDE. As before, the chapter
    will focus heavily on a “four-step”methodology I propose that encompasses a *discover,
    play, develop, deploy* workflow for your ML projects. This project workflow will
    be compared with the CRISP-DM methodology, which is very popular in data science
    circles. We will also discuss the appropriate development tooling and its configuration
    and integration for a successful project. We will also cover version control strategies
    and their basic implementation, and setting up CI/CD for your ML project. Then,
    we will introduce some potential execution environments as the target destinations
    for your ML solutions. By the end of this chapter, you will be set up for success
    in your Python ML engineering project. This is the foundation on which we will
    build everything in subsequent chapters.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一版中，我们将更详细地介绍一个重要的数据科学和机器学习项目管理方法：**跨行业标准数据挖掘流程**（**CRISP-DM**）。这包括讨论这种方法与传统敏捷和瀑布方法的比较，并提供一些将此方法应用于您的机器学习项目的技巧和窍门。还有更多详细的示例，帮助您使用GitHub
    Actions开始**持续集成/持续部署**（**CI/CD**），包括如何运行专注于机器学习的流程，如自动模型验证。关于在**交互式开发环境**（**IDE**）中启动的建议也已经变得更加工具无关，以便使用任何合适的IDE。与之前一样，本章将重点介绍我提出的“四步”方法，该方法涵盖了您的机器学习项目的*发现、玩耍、开发、部署*工作流程。这个项目工作流程将与在数据科学领域非常流行的CRISP-DM方法进行比较。我们还将讨论适当的发展工具及其配置和集成，以确保项目成功。我们还将涵盖版本控制策略及其基本实施，以及为您的机器学习项目设置CI/CD。然后，我们将介绍一些潜在的执行环境，作为您的机器学习解决方案的目标目的地。到本章结束时，您将为您的Python机器学习工程项目成功做好准备。这是我们将在后续章节中构建一切的基础。
- en: As usual, we will conclude the chapter by summarizing the main points and highlighting
    what this means as we work through the rest of the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将通过总结本章的主要观点并强调在阅读本书其余部分时这些观点的意义来结束本章。
- en: Finally, it is also important to note that although we will frame the discussion
    here in terms of ML challenges, most of what you will learn in this chapter can
    also be applied to other Python software engineering projects. My hope is that
    the investment in building out these foundational concepts in detail will be something
    you can leverage again and again in all of your work.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，尽管我们在这里将讨论框架定为ML挑战，但本章中您将学到的许多内容也可以应用于其他Python软件工程项目。我的希望是，在详细构建这些基础概念的投资将能够让您在所有工作中反复利用。
- en: 'We will explore all of this in the following sections and subsections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节和子章节中探讨所有这些内容：
- en: Setting up our tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的工具
- en: 'Concept to solution in four steps:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从概念到解决方案的四个步骤：
- en: Discover
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现
- en: Play
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩耍
- en: Develop
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发
- en: Deploy
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: There is plenty of exciting stuff to get through and lots to learn – so let’s
    get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多令人兴奋的内容需要消化和很多知识需要学习——让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As in *Chapter 1*, *Introduction to ML Engineering* if you want to run the
    examples provided here, you can create a Conda environment using the environment
    YAML file provided in the `Chapter02` folder of the book’s GitHub repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 *第 1 章*，*机器学习工程简介* 中所述，如果您想运行这里提供的示例，您可以使用本书 GitHub 仓库 `Chapter02` 文件夹中提供的环境
    YAML 文件创建一个 Conda 环境：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On top of this, many of the examples in this chapter will require the use of
    the following software and packages. These will also stand you in good stead for
    following the examples in the rest of the book:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章中的许多示例将需要使用以下软件和包。这些也将为你在本书其他部分的示例提供良好的基础：
- en: Anaconda
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anaconda
- en: PyCharm Community Edition, VS Code, or another Python-compatible IDE
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm Community Edition，VS Code 或其他兼容 Python 的 IDE
- en: Git
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: 'You will also need the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要以下内容：
- en: An Atlassian Jira account. We will discuss this more later in the chapter, but
    you can sign up for one for free at [https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Atlassian Jira 账户。我们将在本章后面进一步讨论这个问题，但您可以在[https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)免费注册一个账户。
- en: An AWS account. This will also be covered in the chapter, but you can sign up
    for an account at [https://aws.amazon.com/](https://aws.amazon.com/). You will
    need to add payment details to sign up for AWS, but everything we do in this book
    will only require the free tier solutions.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 账户。这将在本章中讨论，但您可以在[https://aws.amazon.com/](https://aws.amazon.com/)注册一个账户。注册
    AWS 需要添加付款详情，但本书中我们将只使用免费层解决方案。
- en: The technical steps in this chapter were all tested on both a Linux machine
    running Ubuntu 22.04 LTS with a user profile that had admin rights and on a Macbook
    Pro M2 with the setup described in *Chapter 1*, *Introduction to ML Engineering.*
    If you are running the steps on a different system, then you may have to consult
    the documentation for that specific tool if the steps do not work as planned.
    Even if this is the case, most of the steps will be the same, or very similar,
    for most systems. You can also check out all of the code for this chapter in the
    book’s repository at [https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Python-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Python-Second-Edition/tree/main/Chapter02).
    The repo will also contain further resources for getting the code examples up
    and running.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的技术步骤都在运行 Ubuntu 22.04 LTS 的 Linux 机器上进行了测试，该机器有一个具有管理员权限的用户配置文件，以及一个按照 *第
    1 章*，*机器学习工程简介* 中描述的设置运行的 Macbook Pro M2。如果您在运行不同系统上的步骤时，如果步骤没有按预期工作，您可能需要查阅该特定工具的文档。即使如此，大多数步骤对于大多数系统来说都将相同或非常相似。您还可以在本书的
    GitHub 仓库[https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Python-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Python-Second-Edition/tree/main/Chapter02)中查看本章的所有代码。该仓库还将包含进一步的资源，以帮助您将代码示例运行起来。
- en: Setting up our tools
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的工具
- en: 'To prepare for the work in the rest of this chapter, and indeed the rest of
    the book, it will be helpful to set up some tools. At a high level, we need the
    following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备本章以及本书其余部分的工作，设置一些工具将会很有帮助。从高层次来看，我们需要以下工具：
- en: Somewhere to code
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编码的地方
- en: Something to track our code changes
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于跟踪我们的代码更改的内容
- en: Something to help manage our tasks
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于帮助我们管理任务的内容
- en: Somewhere to provision infrastructure and deploy our solution
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于配置基础设施和部署我们的解决方案的地方
- en: 'Let’s look at how to approach each of these in turn:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看如何处理这些问题：
- en: '**Somewhere to code**: First, although the weapon of choice for coding by data
    scientists is of course Jupyter Notebook, once you begin to make the move toward
    ML engineering, it will be important to have an IDE to hand. An IDE is basically
    an application that comes with a series of built-in tools and capabilities to
    help you to develop the best software that you can. **PyCharm** is an excellent
    example for Python developers and comes with a wide variety of plugins, add-ons,
    and integrations useful to ML engineers. You can download the Community Edition
    from JetBrains at [https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/).
    Another popular development tool is the lightweight but powerful source code editor
    VS Code. Once you have successfully installed PyCharm, you can create a new project
    or open an existing one from the **Welcome to PyCharm** window, as shown in *Figure
    2.1*:![Figure 2.1 – Opening or creating your PyCharm project ](img/B19525_02_01.png)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写代码的地方**：首先，尽管数据科学家选择编码的武器当然是Jupyter Notebook，但一旦您开始向ML工程转型，拥有一个IDE将变得非常重要。IDE基本上是一个包含一系列内置工具和功能的应用程序，可以帮助您开发出最好的软件。**PyCharm**是Python开发者的一个优秀例子，它提供了许多对ML工程师有用的插件、附加组件和集成。您可以从JetBrains下载社区版，网址为[https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/)。另一个流行的开发工具是轻量但强大的源代码编辑器VS
    Code。一旦您成功安装了PyCharm，您可以从**欢迎使用PyCharm**窗口创建一个新项目或打开一个现有项目，如图*图2.1*所示：![图2.1 –
    打开或创建您的PyCharm项目](img/B19525_02_01.png)'
- en: 'Figure 2.1: Opening or creating your PyCharm project.'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.1：打开或创建您的PyCharm项目。
- en: '**Something to track code changes**: Next on the list is a code version control
    system. In this book, we will use **GitHub** but there are a variety of solutions,
    all freely available, that are based on the same underlying open-source **Git**
    technology. Later sections will discuss how to use these as part of your development
    workflow, but first, if you do not have a version control system set up, you can
    navigate to [github.com](http://github.com) and create a free account. Follow
    the instructions on the site to create your first repository, and you will be
    shown a screen that looks something like *Figure 2.2*. To make your life easier
    later, you should select **Add a README file** and **Add .gitignore** (then select
    **Python**). The README file provides an initial Markdown file for you to get
    started with and somewhere to describe your project. The `.gitignore` file tells
    your Git distribution to ignore certain types of files that in general are not
    important for version control. It is up to you whether you want the repository
    to be public or private and what license you wish to use. The repository for this
    book uses the **MIT license**:![Figure 2.2 – Setting up your GitHub repository
    ](img/B19525_02_02.png)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪代码变更的内容**：接下来在列表中是代码版本控制系统。在这本书中，我们将使用**GitHub**，但基于相同底层开源**Git**技术的解决方案有很多，所有这些解决方案都是免费提供的。后面的章节将讨论如何将这些工具作为您开发工作流程的一部分，但首先，如果您还没有设置版本控制系统，您可以导航到[github.com](http://github.com)并创建一个免费账户。按照网站上的说明创建您的第一个仓库，您将看到一个类似于*图2.2*的屏幕。为了使您的生活更轻松，您应该选择**添加README文件**和**添加.gitignore**（然后选择**Python**）。README文件为您提供了一个初始的Markdown文件，以便您开始使用，并描述您的项目。`.gitignore`文件告诉您的Git分布忽略某些类型的文件，这些文件通常对版本控制不重要。您可以选择将仓库设置为公开或私有，以及您希望使用的许可证。这本书的仓库使用**MIT许可证**：![图2.2
    – 设置您的GitHub仓库](img/B19525_02_02.png)'
- en: 'Figure 2.2: Setting up your GitHub repository.'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.2：设置您的GitHub仓库。
- en: 'Once you have set up your IDE and version control system, you need to make
    them talk to each other by using the Git plugins provided with PyCharm. This is
    as simple as navigating to **VCS** | **Enable Version Control Integration** and
    selecting **Git**. You can edit the version control settings by navigating to
    **File** | **Settings** | **Version** **Control**; see *Figure 2.3*:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦您设置了IDE和版本控制系统，您需要通过使用PyCharm提供的Git插件使它们相互通信。这就像导航到**VCS** | **启用版本控制集成**并选择**Git**一样简单。您可以通过导航到**文件**
    | **设置** | **版本** **控制**来编辑版本控制设置；请参阅*图2.3*：
- en: '![Figure 2.3 – Configuring version control with PyCharm ](img/B19525_02_03.png)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图2.3 – 使用PyCharm配置版本控制](img/B19525_02_03.png)'
- en: 'Figure 2.3: Configuring version control with PyCharm.'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.3：使用PyCharm配置版本控制。
- en: '**Something to help manage our tasks**: You are now ready to write Python and
    track your code changes, but are you ready to manage or participate in a complex
    project with other team members? For this, it is often useful to have a solution
    where you can track tasks, issues, bugs, user stories, and other documentation
    and items of work. It also helps if this has good integration points with the
    other tools you will use. In this book, we will use **Jira** as an example of
    this. If you navigate to [https://www.atlassian.com/software/jira](https://www.atlassian.com/software/jira),
    you can create a free cloud Jira account and then follow the interactive tutorial
    within the solution to set up your first board and create some tasks. *Figure
    2.4* shows the task board for this book project, called **Machine Learning Engineering
    in Python** (**MEIP**):![](img/B19525_02_04.png)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些帮助我们管理任务的东西**：您现在可以编写 Python 代码并跟踪您的代码更改，但您准备好与其他团队成员一起管理或参与一个复杂的项目了吗？为此，拥有一个可以跟踪任务、问题、错误、用户故事和其他文档和工作项的解决方案通常很有用。如果这个解决方案与其他您将使用的工具有良好的集成点，那就更好了。在这本书中，我们将使用**Jira**作为这个示例。如果您导航到[https://www.atlassian.com/software/jira](https://www.atlassian.com/software/jira)，您可以创建一个免费的云
    Jira 账户，然后在该解决方案中遵循交互式教程来设置您的第一个看板并创建一些任务。*图 2.4*显示了本书项目（称为**Python 机器学习工程**，**MEIP**）的任务板：![](img/B19525_02_04.png)'
- en: 'Figure 2.4: The task board for this book in Jira.'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.4：本书在 Jira 中的任务板。
- en: '**Somewhere to provision infrastructure and deploy our solution**: Everything
    that you have just installed and set up is tooling that will really help take
    your workflow and software development practices to the next level. The last piece
    of the puzzle is having the tools, technologies, and infrastructure available
    for deploying the end solution. The management of computing infrastructure for
    applications was (and often still is) the provision of dedicated infrastructure
    teams, but with the advent of public clouds, there has been real democratization
    of this capability for people working across the spectrum of software roles. In
    particular, modern ML engineering is very dependent on the successful implementation
    of cloud technologies, usually through the main public cloud providers such as
    **Amazon Web Services** (**AWS**), **Microsoft Azure**, or **Google Cloud Platform**
    (**GCP**). This book will utilize tools found in the AWS ecosystem, but all of
    the tools and techniques you will find here have equivalents in the other clouds.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个用于部署基础设施和部署我们的解决方案的地方**：您刚刚安装和设置的一切都是工具，这些工具将真正帮助您将工作流程和软件开发实践提升到下一个层次。最后一部分是拥有部署最终解决方案所需的工具、技术和基础设施。为应用程序管理计算基础设施（过去和现在通常仍然是）提供专门的团队，但随着公共云的出现，这种能力对于从事软件各个角色的员工来说已经实现了真正的民主化。特别是，现代机器学习工程非常依赖于云计算技术的成功实施，通常是通过主要的公共云提供商，如**亚马逊网络服务**（**AWS**）、**微软Azure**或**谷歌云平台**（**GCP**）。本书将利用
    AWS 生态系统中的工具，但您在这里找到的所有工具和技术在其他云中都有等效项。'
- en: The flip side of the democratization of capabilities that the cloud brings is
    that teams who own the deployment of their solutions have to gain new skills and
    understanding. I am a strong believer in the principle that “*you build it, you
    own it, you run it*” as far as possible, but this means that as an ML engineer,
    you will have to be comfortable with a host of potential new tools and principles,
    as well as *owning* the performance of your deployed solution. *With great power
    comes great responsibility* and all that. In *Chapter 5*, *Deployment Patterns
    and Tools*, we will dive into this topic in detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 云带来的能力民主化的一面是，拥有其解决方案部署权的团队必须掌握新的技能和理解。我坚信“*你建它，你拥有它，你运行它*”的原则，但这意味着作为一个机器学习工程师，您将不得不熟悉大量潜在的新工具和原则，以及*拥有*您部署的解决方案的性能。*权力越大，责任越大*，诸如此类。在*第
    5 章*，*部署模式和工具*中，我们将详细探讨这个话题。
- en: Let’s talk through setting this up.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈如何设置它。
- en: Setting up an AWS account
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 AWS 账户
- en: 'As previously stated, you don’t have to use AWS, but that’s what we’re going
    to use throughout this book. Once it’s set up here, you can use it for everything
    we’ll do:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您不必使用 AWS，但我们将在这本书的整个过程中使用它。一旦在这里设置好，您就可以用它来做我们将会做的所有事情：
- en: To set up an AWS account, navigate to [aws.amazon.com](http://aws.amazon.com)
    and select **Create Account**. You will have to add some payment details but everything
    we mention in this book can be explored through the *free tier* of AWS, where
    you do not incur a cost below a certain threshold of consumption.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使这更加具体。每个阶段的主要焦点和输出可以总结如下，如图2.1表所示：
- en: 'Once you have created your account, you can navigate to the AWS Management
    Console, where you can see all the services that are available to you (see *Figure
    2.5*):'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您创建了账户，您就可以导航到AWS管理控制台，在那里您可以查看所有可用的服务（见*图2.5*）：
- en: '![Figure 2.5 – The AWS Management Console ](img/B19525_02_05.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – AWS管理控制台](img/B19525_02_05.png)'
- en: 'Figure 2.5: The AWS Management Console.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：AWS管理控制台。
- en: With our AWS account ready to go, let’s look at the four steps that cover the
    whole process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的AWS账户准备就绪后，让我们看看涵盖整个过程的四个步骤。
- en: Concept to solution in four steps
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '| **阶段** | **输出** |'
- en: 'All ML projects are unique in some way: the organization, the data, the people,
    and the tools and techniques employed will never be exactly the same for any two
    projects. This is good, as it signifies progress as well as the natural variety
    that makes this such a fun space to work in.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有机器学习项目在某种程度上都是独特的：组织、数据、人员、使用的工具和技术在任何两个项目中都不会完全相同。这是好事，因为它标志着进步，以及使这个领域如此有趣的自然多样性。
- en: That said, no matter the details, broadly speaking, all successful ML projects
    actually have a good deal in common. They require the translation of a business
    problem into a technical problem, a lot of research and understanding, proofs
    of concept, analyses, iterations, the consolidation of work, the construction
    of the final product, and its deployment to an appropriate environment. That is
    ML engineering in a nutshell!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，无论细节如何，从广义上讲，所有成功的机器学习项目实际上有很多共同之处。它们需要将业务问题转化为技术问题，进行大量的研究和理解，概念验证，分析，迭代，工作整合，最终产品的构建，以及将其部署到适当的环境。这就是机器学习工程的精髓！
- en: 'Developing this a bit further, you can start to bucket these activities into
    rough categories or stages, the results of each being necessary inputs for later
    stages. This is shown in *Figure 2.6*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步发展这一点，您可以将这些活动开始归类为粗略的类别或阶段，每个阶段的成果都是后续阶段必要的输入。这如图2.6所示：
- en: '![Figure 2.6 – The stages that any ML project goes through as part of the ML
    development process ](img/B19525_02_06.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 任何机器学习项目在机器学习开发过程中所经历的各个阶段](img/B19525_02_06.png)'
- en: 'Figure 2.6: The stages that any ML project goes through as part of the ML development
    process.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：任何机器学习项目在机器学习开发过程中所经历的各个阶段。
- en: Each category of work has a slightly different flavor, but taken together, they
    provide the backbone of any good ML project. The next few sections will develop
    the details of each of these categories and begin to show you how they can be
    used to build your ML engineering solutions. As we will discuss later, it is also
    not necessary for you to tackle your entire project in four steps like this; you
    can actually work through each of these steps for a specific feature or part of
    your overall project. This will be covered in the *Selecting a software development
    methodology* section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作类别都有其独特的风味，但综合起来，它们构成了任何良好机器学习项目的骨架。接下来的几节将详细阐述每个类别的细节，并开始展示如何使用它们来构建您的机器学习工程解决方案。正如我们稍后将要讨论的，您也不必像这样分四步完成整个项目；您实际上可以为特定功能或整体项目的一部分逐个完成这些步骤。这将在*选择软件开发方法*部分中介绍。
- en: 'Let’s make this a bit more real. The main focus and outputs of every stage
    can be summarized as shown in *Table 2.1*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置AWS账户，请导航到[aws.amazon.com](http://aws.amazon.com)并选择**创建账户**。您需要添加一些付款详情，但本书中提到的所有内容都可以通过AWS的*免费层*进行探索，在那里您不会因消费低于一定阈值而产生费用。
- en: '| **Stage** | **Outputs** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: 四步从概念到解决方案
- en: '| Discover | Clarity on the business question.Clear arguments for ML over another
    approach.Definition of the KPIs and metrics you want to optimize.A sketch of the
    route to value. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 输出 |'
- en: '| Play | Detailed understanding of the data.Working proof of concept.Agreement
    on the model/algorithm/logic that will solve the problem.Evidence that a solution
    is doable within realistic resource scenarios.Evidence that good ROI can be achieved.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 详细理解数据。工作原理的概念验证。对解决问题所采用的模型/算法/逻辑达成一致。在现实资源场景中实现解决方案的证据。实现良好投资回报率的证据。
    |'
- en: '| Develop | A working solution that can be hosted on appropriate and available
    infrastructure.Thorough test results and performance metrics (for algorithms and
    software).An agreed retraining and model deployment strategy.Unit tests, integration
    tests, and regression tests.Solution packaging and pipelines. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 开发 | 开发一个可以在适当和可用的基础设施上托管的工作解决方案。详尽的测试结果和性能指标（针对算法和软件）。达成一致的再培训和模型部署策略。单元测试、集成测试和回归测试。解决方案打包和管道。
    |'
- en: '| Deploy | A working and tested deployment process.Provisioned infrastructure
    with appropriate security and performance characteristics.Mode retraining and
    management processes.An end-to-end working solution! |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 部署 | 一个工作且经过测试的部署流程。配备适当的安全性和性能特性的基础设施。模式再培训和管理工作流程。端到端的工作解决方案！ |'
- en: 'Table 2.1: The outputs of the different stages of the ML development process.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：机器学习开发过程不同阶段的输出。
- en: IMPORTANT NOTE
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may think that an ML engineer only really needs to consider the latter two
    stages, *develop*, and *deploy*, and that earlier stages are owned by the data
    scientist or even a business analyst. We will indeed focus mainly on these stages
    throughout this book and this division of labor can work very well. It is, however,
    crucially important that if you are going to build an ML solution, you understand
    all of the motivations and development steps that have gone before – you wouldn’t
    build a new type of rocket without understanding where you want to go first, would
    you?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为机器学习工程师只需要真正考虑后两个阶段，*开发*和*部署*，而早期阶段由数据科学家或甚至业务分析师负责。我们确实会在整本书中主要关注这些阶段，并且这种劳动分工可以非常有效。然而，如果你打算构建一个机器学习解决方案，理解所有之前的动机和开发步骤至关重要——你不了解你想要去哪里，难道会建造一种新的火箭吗？
- en: Comparing this to CRISP-DM
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与CRISP-DM的比较
- en: 'The high-level categorization of project steps that we will outline in the
    rest of this chapter has many similarities to, and some differences from, an important
    methodology known as CRISP-DM. This methodology was published in 1999 and has
    since gathered a large following as a way to understand how to build any data
    project. In CRISP-DM, there are six different phases of activity, covering similar
    ground to that outlined in the four steps described in the previous section:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的其余部分概述的项目步骤的高级分类与一个重要的方法论CRISP-DM有许多相似之处，也有一些不同。这个方法论于1999年发布，自那时起，它已成为理解如何构建任何数据项目的一种方式。在CRISP-DM中，有六个不同的活动阶段，涵盖了与上一节中描述的四个步骤类似的内容：
- en: '**Business understanding**: This is all about getting to know the business
    problem and domain area. This becomes part of the *Discover* phase in the four-step
    model.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**业务理解**：这全部关于了解业务问题和领域。在四步模型中，这成为*发现*阶段的一部分。'
- en: '**Data understanding**: Extending the knowledge of the business domain to include
    the state of the data, its location, and how it is relevant to the problem. Also
    included in the *Discover* phase.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据理解**：将业务领域的知识扩展到包括数据的状态、其位置以及它与问题的相关性。这也包括在*发现*阶段。'
- en: '**Data preparation**: Starting to take the data and transform it for downstream
    use. This will often have to be iterative. Captured in the *Play* stage.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据准备**：开始获取数据并将其转换为下游使用。这通常需要迭代。在*玩耍*阶段进行捕捉。'
- en: '**Modeling**: Taking the prepared data and then developing analytics on top
    of it; this could now include ML of various levels of sophistication. This is
    an activity that occurs both in the *Play* and *Develop* phases of the four-step
    methodology.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**建模**：对准备好的数据进行处理，并在其上开发分析；这现在可能包括不同复杂程度的机器学习。这是一个在四步方法论中的*玩耍*和*开发*阶段都会发生的活动。'
- en: '**Evaluation**: This stage is concerned with confirming whether the solution
    will meet the business requirements and performing a holistic review of the work
    that has gone before. This helps confirm if anything was overlooked or could be
    improved upon. This is very much part of the *Develop* and *Deploy* phases; in
    the methodology we will describe in this chapter, these tasks are very much more
    baked in across the project.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**评估**：这一阶段关注的是确认解决方案是否满足业务需求，并对之前的工作进行全面的审查。这有助于确认是否有什么被忽略或可以改进的地方。这非常是*开发*和*部署*阶段的一部分；在我们本章将描述的方法论中，这些任务在整个项目中都得到了很好的整合。'
- en: '**Deployment**: In CRISP-DM, this was originally focused on deploying simple
    analytics solutions like dashboards or scheduled ETL pipelines that would run
    the decided-upon analytics models.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署**：在CRISP-DM中，这最初是专注于部署简单的分析解决方案，如仪表板或计划中的ETL管道，这些管道将运行已决定的分析模型。'
- en: In the world of model ML engineering, this stage can represent, well, anything
    talked about in this book! CRISP-DM suggests sub-stages around planning and then
    reviewing the deployment.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在模型机器学习工程的世界里，这一阶段可以代表这本书中提到的任何内容！CRISP-DM建议在规划和审查部署方面有子阶段。
- en: As you can see from the list, many steps in CRISP-DM cover similar topics to
    those outlined in the four steps I propose. CRISP-DM is extremely popular across
    the data science community and so its merits are definitely appreciated by a huge
    number of data professionals across the world. Given this, you might be wondering,
    “Why bother developing something else then?” Let me convince you of why this is
    a good idea.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从列表中看到的，CRISP-DM中的许多步骤涵盖了与我提出的四个步骤中概述的类似主题。CRISP-DM在数据科学社区中非常受欢迎，因此其优点肯定得到了全世界大量数据专业人士的认可。鉴于这一点，您可能会想，“为什么还要开发其他的东西呢？”让我说服您为什么这是一个好主意。
- en: 'The CRISP-DM methodology is just another way to group the important activities
    of any data project in order to give them some structure. As you can perhaps see
    from the brief description of the stages I gave above and if you do further research,
    CRISP-DM has some potential drawbacks for use in a modern ML engineering project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: CRISP-DM方法论只是将任何数据项目的重要活动分组以提供结构的一种方式。您可能从上面我给出的阶段简要描述中看到，如果您进行进一步的研究，CRISP-DM在用于现代机器学习工程项目的使用中可能存在一些潜在的缺点：
- en: The process outlined in CRISP-DM is relatively rigid and quite linear. This
    can be beneficial for providing structure but might inhibit moving fast in a project.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRISP-DM中概述的过程相对僵化且相当线性。这可以为提供结构带来好处，但可能会阻碍项目中的快速进展。
- en: The methodology is very big on documentation. Most steps detail writing some
    kind of report, review, or summary. Writing and maintaining good documentation
    is absolutely critical in a project but there can be a danger of doing too much.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法非常重视文档。大多数步骤都详细说明了编写某种类型的报告、审查或总结。在项目中编写和维护良好的文档至关重要，但过度编写文档也可能存在风险。
- en: CRISP-DM was written in a world before “big data” and large-scale ML. It is
    unclear to me whether its details still apply in such a different world, where
    classic extract-transform-load patterns are only one of so many.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRISP-DM是在“大数据”和大规模机器学习出现之前的世界中编写的。对我来说，不清楚其细节是否仍然适用于这样一个不同的世界，在那里经典的提取-转换-加载模式只是众多模式之一。
- en: CRISP-DM definitely comes from the data world and then tries to move toward
    the idea of a deployable solution in the last stage. This is laudable, but in
    my opinion, this is not enough. ML engineering is a different discipline in the
    sense that it is far closer to classic software engineering than not. This is
    a point that this book will argue time and again. It is therefore important to
    have a methodology where the concepts of deployment and development are aligned
    with software and modern ML techniques all the way through.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRISP-DM无疑源自数据世界，并在最后阶段试图向可部署解决方案的概念迈进。这是值得赞扬的，但在我看来，这还不够。机器学习工程是一个不同的学科，因为它与经典软件工程的距离远比接近。这本书将反复论证这一点。因此，拥有一个将部署和开发的概念与软件和现代机器学习技术完全一致的方法非常重要。
- en: The *four-step* methodology attempts to alleviate some of these challenges and
    does so in a way that constantly makes reference to software engineering and ML
    skills and techniques. This does not mean that you should never use CRISP-DM in
    your projects; it might just be the perfect thing! As with many of the concepts
    introduced in this book, the important thing is to have many tools in your toolkit
    so that you can select the one most appropriate for the job at hand.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**四步法**试图缓解这些挑战，并以不断参考软件工程和机器学习技能和技术的方式进行。这并不意味着你永远不应该在你的项目中使用CRISP-DM；它可能正是完美的选择！就像这本书中介绍的大多数概念一样，重要的是要拥有许多工具在你的工具箱中，以便你可以选择最适合当前工作的那个。'
- en: Given this, let’s now go through the four steps in detail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们详细地过一遍这四个步骤。
- en: Discover
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现
- en: Before you start working to build any solution, it is vitally important that
    you understand the problem you are trying to solve. This activity is often termed
    **discovery** in business analysis and is crucial if your ML project is going
    to be a success.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建任何解决方案之前，了解你试图解决的问题至关重要。这项活动在商业分析中通常被称为**发现**，如果你的机器学习项目要取得成功，这是至关重要的。
- en: 'The key things to do during the discovery phase are the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现阶段需要做的关键事情如下：
- en: '*Speak to the customer! And then speak to them again*: You must understand
    the end user requirements in detail if you are to design and build the right system.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与客户沟通！然后再与他们沟通*：如果你要设计和构建正确的系统，你必须详细了解最终用户的需求。'
- en: '*Document everything*: You will be judged on how well you deliver against the
    requirements, so make sure that all of the key points from your discussion are
    documented and signed off by members of your team and the customer or their appropriate
    representative.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记录一切*：你将根据你满足要求的好坏来评判，所以请确保你的讨论中的所有关键点都得到了团队成员和客户或其适当代表的记录和批准。'
- en: '*Define the metrics that matter*: It is very easy at the beginning of a project
    to get carried away and to feel like you can solve any and every problem with
    the amazing new tool you are going to build. Fight this tendency as aggressively
    as you can, as it can easily cause major headaches later on. Instead, steer your
    conversations toward defining a single or very small number of metrics that define
    what success will look like.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义重要的指标*：在项目开始时，很容易被冲昏头脑，感觉自己可以用即将构建的神奇新工具解决任何问题。尽可能强烈地抵制这种倾向，因为它很容易在以后造成严重的头痛。相反，将你的对话引导到定义一个或非常少的指标，这些指标定义了成功将是什么样子。'
- en: '*Start finding out where the data lives!*: If you can start working out what
    kind of systems you will have to access to get the data you need, this saves you
    time later and can help you find any major issues before they derail your project.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始找出数据在哪里！*：如果你能开始确定你需要访问哪些系统来获取所需的数据，这将节省你以后的时间，并有助于你在项目脱轨之前发现任何重大问题。'
- en: Using user stories
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用用户故事
- en: 'Once you have spoken to the customer (a few times), you can start to define
    some **user stories**. User stories are concise and consistently formatted expressions
    of what the user or customer wants to see and the acceptance criteria for that
    feature or unit of work. For example, we may want to define a user story based
    on the taxi ride example from *Chapter 1*, *Introduction to ML Engineering*: “As
    a user of our internal web service, I want to see anomalous taxi rides and be
    able to investigate them further.”'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你与客户（几次）交谈过，你就可以开始定义一些**用户故事**。用户故事是对用户或客户想要看到的内容以及该功能或工作单元的验收标准的简洁且格式一致的表述。例如，我们可能想根据*第1章*，*机器学习工程简介*中的出租车行程示例定义一个用户故事：“作为我们内部网络服务的用户，我希望看到异常的出租车行程，并能够进一步调查。”
- en: Let’s begin!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: To add this in Jira, select the **Create** button.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Jira中添加此内容，请选择**创建**按钮。
- en: Next, select **Story**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**故事**。
- en: Then, fill in the details as you deem appropriate.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，根据需要填写细节。
- en: 'You have now added a user story to your work management tool! This allows you
    to do things such as create new tasks and link them to this user story or update
    its status as your project progresses:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经将一个用户故事添加到你的工作管理工具中！这让你可以做诸如创建新任务并将它们链接到这个用户故事或更新其状态等事情：
- en: '![Figure 2.8 – An example user story in Jira ](img/B19525_02_07.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – Jira中的一个示例用户故事](img/B19525_02_07.png)'
- en: 'Figure 2.7: An example user story in Jira.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：Jira中的一个示例用户故事。
- en: The data sources you use are particularly crucial to understand. As you know,
    *garbage in, garbage out*, or even worse, *no data, no go*! The particular questions
    you have to answer about the data are mainly centered around **access**, **technology**,
    **quality**, and **relevance**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的数据源尤其重要，需要理解。正如你所知，“垃圾进，垃圾出”，或者更糟，“没有数据，就没有进展”！你必须回答的数据的特定问题主要集中在**访问**、**技术**、**质量**和**相关性**上。
- en: For access and technology, you are trying to pre-empt how much work the data
    engineers have to do to start their pipeline of work and how much this will hold
    up the rest of the project. It is therefore crucial that you get this one right.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于访问和技术，你试图预先了解数据工程师开始他们的工作流程需要做多少工作，以及这会耽误整个项目多少时间。因此，正确地完成这一点至关重要。
- en: A good example would be if you find out quite quickly that the main bulk of
    data you will need lives in a legacy internal financial system with no real modern
    APIs and no access request mechanism for non-finance team members. If its main
    backend is on-premises and you need to migrate locked-down financial data to the
    cloud, but this makes your business nervous, then you know you have a lot of work
    to do before you type a line of code. If the data already lives in an enterprise
    data lake that your team has access to, then you are obviously in a better position.
    Any challenge is surmountable if the value proposition is strong enough, but finding
    all this out early will save you time, energy, and money later on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是，如果你很快发现你需要的绝大部分数据都存在于没有真正现代API和没有非财务团队成员访问请求机制的遗留内部财务系统中。如果其主要后端是本地部署的，你需要将锁定在云端的财务数据迁移过来，但这会让你的业务感到紧张，那么你知道在编写第一行代码之前还有很多工作要做。如果数据已经存在于你的团队可以访问的企业数据湖中，那么你显然处于更好的位置。如果价值主张足够强大，任何挑战都是可以克服的，但尽早找出这些情况将为你节省时间、精力和金钱。
- en: Relevance is a bit harder to find out before you kick off, but you can begin
    to get an idea. For example, if you want to perform the inventory forecast we
    discussed in *Chapter 1*, *Introduction to ML Engineering*, do you need to pull
    in customer account information? If you want to create the classifier of *premium*
    or *non-premium* customers as marketing targets, also mentioned in *Chapter 1*,
    *Introduction to ML Engineering*, do you need to have data on social media feeds?
    The question as to what is relevant will often be less clear-cut than for these
    examples but an important thing to remember is that you can always come back to
    it if you really missed something important. You are trying to capture the most
    important design decisions early, so common sense and lots of stakeholder and
    subject-matter expert engagement will go a long way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动之前，相关性可能更难找到，但你可以开始形成一些想法。例如，如果你想执行我们在*第一章*，*机器学习工程导论*中讨论的库存预测，你是否需要拉取客户账户信息？如果你想创建*高端*或*非高端*客户的分类器，作为营销目标，这也如*第一章*，*机器学习工程导论*中提到的，你是否需要社交媒体数据？关于相关性的问题通常不会像这些例子那样明确，但一个重要的事情要记住的是，如果你真的错过了什么重要的东西，你总是可以回过头来。你试图尽早捕捉到最重要的设计决策，所以常识和大量的利益相关者和领域专家参与将大有裨益。
- en: Data quality is something that you can try to anticipate a little before moving
    forward in your project with some questions to current users or consumers of the
    data or those involved in its entry processes. To get a more quantitative understanding
    though, you will often just need to get your data scientists working with the
    data in a hands-on manner.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目前进之前，你可以尝试通过向当前的数据用户或消费者或参与其输入过程的人员提出一些问题来预测数据质量。但要获得更定量的理解，你通常只需要让你的数据科学家以动手的方式与数据一起工作。
- en: In the next section, we will look at how we develop proof-of-concept ML solutions
    in the most research-intensive phase, *Play*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在最具研究密集性的阶段，即*Play*阶段，开发概念验证机器学习解决方案。
- en: Play
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Play
- en: In the **play** stage of the project, your aim is to work out whether solving
    the task even at the proof-of-concept level is feasible. To do this, you might
    employ the usual data science bread-and-butter techniques of exploratory data
    analysis and explanatory modeling we mentioned in the last chapter before moving
    on to creating an ML model that does what you need.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的**play**阶段，你的目标是确定即使在概念验证级别解决任务是否可行。为此，你可能会在创建满足你需求的机器学习模型之前，采用我们在上一章中提到的常规数据科学技术，如探索性数据分析和解释性建模。
- en: 'In this part of the process, you are not overly concerned with details of implementation,
    but with exploring the realms of possibility and gaining an in-depth understanding
    of the data and the problem, which goes beyond initial discovery work. Since the
    goal here is not to create *production-ready* code or to build reusable tools,
    you should not worry about whether or not the code you are writing is of the highest
    quality, or using sophisticated patterns. For example, it will not be uncommon
    to see code that looks something like the following examples (taken, in fact,
    from the repo for this book):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流程的这一部分，你不必过分关注实现的细节，而是要探索可能性领域，并深入理解数据和问题，这超出了初步发现工作。由于这里的目的是不创建*生产就绪*的代码或构建可重用的工具，因此你不必担心你编写的代码是否质量最高，或者是否使用了复杂的模式。例如，看到以下示例（实际上是从本书的repo中摘取的）的代码并不罕见：
- en: '![Figure 2.9 – Some example prototype code that will be created during the
    play stage ](img/B19525_02_08.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 在游戏阶段将创建的一些示例原型代码](img/B19525_02_08.png)'
- en: 'Figure 2.8: Some example prototype code that will be created during the play
    stage.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：在游戏阶段将创建的一些示例原型代码。
- en: 'Even a quick glance at these screenshots tells you a few things:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 只需快速浏览这些截图，就能告诉你一些事情：
- en: The code is in a Jupyter notebook, which is run by a user interactively in a
    web browser.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码位于Jupyter笔记本中，由用户在网页浏览器中交互式运行。
- en: The code sporadically calls methods to simply check or explore elements of the
    data (for example, `df.head()` and `df.dtypes`).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码偶尔会调用方法来简单地检查或探索数据元素（例如，`df.head()`和`df.dtypes`）。
- en: There is ad hoc code for plotting (and it’s not very intuitive!).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于绘图（而且它并不直观！）有专门的代码。
- en: There is a variable called `tmp`, which is not very descriptive.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个名为`tmp`的变量，描述性不强。
- en: All of this is absolutely fine in this more exploratory phase, but one of the
    aims of this book is to help you understand what is required to take code like
    this and make it into something suitable for your production ML pipelines. The
    next section starts us along this path.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些在这个更探索性的阶段都是绝对可以接受的，但本书的一个目标就是帮助你理解将此类代码转化为适合你生产机器学习管道所需的要素。下一节将开始引导我们走上这条道路。
- en: Develop
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发
- en: As we have mentioned a few times already, one of the aims of this book is to
    get you thinking about the fact that you are building software products that just
    happen to have ML in them. This means a steep learning curve for some of us who
    have come from more mathematical and algorithmic backgrounds. This may seem intimidating
    but do not despair! The good news is that we can reuse a lot of the best practices
    and techniques honed through the software engineering community over several decades.
    There is nothing new under the sun.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前已经提到几次，本书的一个目标就是让你思考这样一个事实：你正在构建的软件产品恰好包含了机器学习。这意味着对于我们这些来自更数学和算法背景的人来说，学习曲线可能会很陡峭。这可能会让人感到害怕，但不要绝望！好消息是，我们可以重用几十年来软件工程社区锤炼的许多最佳实践和技术。太阳之下无新事。
- en: This section explores several of those methodologies, processes, and considerations
    that can be employed in the development phase of our ML engineering projects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了在机器学习工程项目的开发阶段可以采用的一些方法、流程和考虑因素。
- en: Selecting a software development methodology
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择软件开发方法
- en: One of the first things we could and should shamelessly replicate as ML engineers
    is the software development methodologies that are utilized in projects across
    the globe. One category of these, often referred to as **Waterfall**, covers project
    workflows that fit quite naturally with the idea of building something complex
    (think a building or a car). In Waterfall methodologies, there are distinct and
    sequential phases of work, each with a clear set of outputs that are needed before
    moving on to the next phase. For example, a typical Waterfall project may have
    phases that broadly cover requirements-gathering, analysis, design, development,
    testing, and deployment (sound familiar?). The key thing is that in a Waterfall-flavored
    project, when you are in the *requirements-gathering* phase, you should *only*
    be working on gathering requirements, when in the testing phase, you should *only*
    be working on testing, and so on. We will discuss the pros and cons of this for
    ML in the next few paragraphs after introducing another set of methodologies.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为机器学习工程师，可以而且应该毫无顾忌地复制全球项目中使用的软件开发方法。这些方法中的一类，通常被称为**瀑布模型**，涵盖了适合构建复杂事物的项目工作流程（想想建筑或汽车）。在瀑布模型中，有明确且顺序性的工作阶段，每个阶段都有在进入下一阶段之前所需的明确输出。例如，典型的瀑布项目可能包含涵盖需求收集、分析、设计、开发、测试和部署等阶段（听起来熟悉吗？）。关键在于，在瀑布风格的项目中，当你处于**需求收集**阶段时，你应该**只**专注于收集需求，当处于测试阶段时，你应该**只**专注于测试，依此类推。在介绍另一套方法之后，我们将在接下来的几段中讨论这种方法在机器学习中的优缺点。
- en: The other set of methodologies, termed **Agile**, began its life after the introduction
    of the **Agile Manifesto** in 2001 ([https://agilemanifesto.org/](https://agilemanifesto.org/)).
    At the heart of Agile development are the ideas of flexibility, iteration, incremental
    updates, failing fast, and adapting to changing requirements. If you are from
    a research or scientific background, this concept of flexibility and adaptability
    based on results and new findings may sound familiar.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一套方法，称为**敏捷**，是在2001年**敏捷宣言**（[https://agilemanifesto.org/](https://agilemanifesto.org/)）发布之后出现的。敏捷开发的核心理念是灵活性、迭代、增量更新、快速失败和适应变化的需求。如果你来自研究或科学背景，这种基于结果和新发现灵活性和适应性的概念可能听起来很熟悉。
- en: What may not be so familiar to you if you have this type of scientific or academic
    background is that you can still embrace these concepts within a relatively strict
    framework that is centered around delivery outcomes. Agile software development
    methodologies are all about finding the balance between experimentation and delivery.
    This is often done by introducing the concepts of **ceremonies** (such as **Scrums**
    and **Sprint** **Retrospectives**) and **roles** (such as **Scrum Master** and
    **Product Owner**).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具有这种科学或学术背景，可能不太熟悉的是，你仍然可以在一个以交付结果为中心的相对严格的框架内接受这些概念。敏捷软件开发方法的核心是寻找实验和交付之间的平衡。这通常通过引入**仪式**（如**Scrum**和**Sprint**回顾）和**角色**（如**Scrum
    Master**和**产品负责人**）来实现。
- en: 'Further to this, within Agile development, there are two variants that are
    extremely popular: **Scrum** and **Kanban**. Scrum projects are centered around
    short units of work called **Sprints** where the idea is to make additions to
    the product from ideation through to deployment in that small timeframe. In Kanban,
    the main idea is to achieve a steady **flow** of tasks from an organized backlog
    into work in progress through to completed work.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在敏捷开发中，有两种非常流行的变体：**Scrum**和**Kanban**。Scrum项目围绕称为**Sprint**的短期工作单元展开，其理念是在这个短暂的时间内从构思到部署对产品的添加。在Kanban中，主要理念是实现从有序的待办事项到进行中工作，再到完成工作的稳定**流程**。
- en: All of these methodologies (and many more besides) have their merits and their
    detractions. You do not have to be married to any of them; you can chop and change
    between them. For example, in an ML project, it may make sense to do some *post-deployment*
    work that has a focus on maintaining an already existing service (sometimes termed
    a *business-as-usual* activity) such as further model improvements or software
    optimizations in a Kanban framework. It may make sense to do the main delivery
    of your core body of work in Sprints with very clear outcomes. But you can chop
    and change and see what fits best for your use cases, your team, and your organization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'But what makes applying these types of workflows to ML projects different?
    What do we need to think about in this world of ML that we didn’t before? Well,
    some of the key points are the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '*You don’t know what you don’t know*: You cannot know whether you will be able
    to solve the problem until you have seen the data. Traditional software engineering
    is not as critically dependent on the data that will flow through the system as
    ML engineering is. We can know how to solve a problem in principle, but if the
    appropriate data does not exist in sufficient quantity or is of poor quality,
    then we can’t solve the problem in practice.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your system is alive*: If you build a classic website, with its backend database,
    shiny frontend, amazing load-balancing, and other features, then realistically,
    if the resource is there, it can just run forever. Nothing fundamental changes
    about the website and how it runs over time. Clicks still get translated into
    actions and page navigation still happens the same way. Now, consider putting
    some ML-generated advertising content based on typical user profiles in there.
    What is a *typical user profile* and does that change with time? With more traffic
    and more users, do behaviors that we never saw before become *the new normal?*
    Your system is learning all the time and that leads to the problems of *model
    drift* and *distributional shift*, as well as more complex update and rollback
    scenarios.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Nothing is certain*: When building a system that uses rule-based logic, you
    know what you are going to get each and every time. *If X*, *then Y* means just
    that, always. With ML models, it is often much harder to know what the answer
    is when you ask the question, which is in fact why these algorithms are so powerful.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But it does mean that you can have unpredictable behavior, either for the reasons
    discussed previously or simply because the algorithm has learned something that
    is not obvious about the data to a human observer, or, because ML algorithms can
    be based on probabilistic and statistical concepts, results come attached to some
    uncertainty or *fuzziness*. A classic example is when you apply logistic regression
    and receive the probability of the data point belonging to one of the classes.
    It’s a probability so you cannot say with certainty that it is the case; just
    how likely it is! This is particularly important to consider when the outputs
    of your ML system will be leveraged by users or other systems to make decisions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Given these issues, in the next section, we’ll try and understand what development
    methodologies can help us when we build our ML solutions. In *Table 2.2*, we can
    see some advantages and disadvantages of each of these Agile methodologies for
    different stages and types of ML engineering projects:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methodology** | **Pros** | **Cons** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| Agile | Flexibility is expected.Faster dev to deploy cycles. | If not well
    managed, can easily have scope drift.Kanban or Sprints may not work well for some
    projects. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| Waterfall | Clearer path to deployment.Clear staging and ownership of tasks.
    | Lack of flexibility.Higher admin overheads. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: Agile versus Waterfall for ML development.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next section!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Package management (conda and pip)
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If I told you to write a program that did anything in data science or ML without
    using any libraries or packages and just pure Python, you would probably find
    this quite difficult to achieve in any reasonable amount of time, and incredibly
    boring! This is a good thing. One of the really powerful features of developing
    software in Python is that you can leverage an extensive ecosystem of tools and
    capabilities relatively easily. The flip side of this is that it would be very
    easy for managing the dependencies of your code base to become a very complicated
    and hard-to-replicate task. This is where package and environment managers such
    as `pip` and `conda` come in.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`pip` is the standard package manager in Python and the one recommended for
    use by the Python Package Authority.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: It retrieves and installs Python packages from `PyPI`, the `Python Package Index`.
    `pip` is super easy to use and is often the suggested way to install packages
    in tutorials and books.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '`conda` is the *package and environment* manager that comes with the Anaconda
    and Miniconda Python distributions. A key strength of `conda` is that although
    it comes from the Python ecosystem, and it has excellent capabilities there, it
    is actually a more general package manager. As such, if your project requires
    dependencies outside Python (the NumPy and SciPy libraries being good examples),
    then although `pip` can install these, it can’t track all the non-Python dependencies,
    nor manage their versions. With `conda`, this is solved.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `pip` within `conda` environments, so you can get the best
    of both worlds or use whatever you need for your project. The typical workflow
    that I use is to use `conda` to manage the environments I create and then use
    that to install any packages I think may require non-Python dependencies that
    perhaps are not captured well within `pip`, and then I can use `pip` most of the
    time within the created `conda` environment. Given this, throughout the book,
    you may see `pip` or `conda` installation commands used interchangeably. This
    is perfectly fine.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: To get started with Conda, if you haven’t already, you can download the **Individual**
    distribution installer from the Anaconda website ([https://www.anaconda.com/products/individual](https://www.anaconda.com/products/individual)).
    Anaconda comes with some Python packages already installed, but if you want to
    start from a completely empty environment, you can download Miniconda from the
    same website instead (they have the exact same functionality; you just start from
    a different base).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The Anaconda documentation is very helpful for getting you up to speed with
    the appropriate commands, but here is a quick tour of some of the key ones.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if we want to create a `conda` environment called `mleng` with Python
    version 3.8 installed, we simply execute the following in our terminal:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then activate the `conda` environment by running the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means that any new `conda` or `pip` commands will install packages in this
    environment and not system-wide.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'We often want to share the details of our environment with others working on
    the same project, so it can be useful to export all the package configurations
    to a `.yml` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The GitHub repository for this book contains a file called `mleng-environment.yml`
    for you to create your own instance of the `mleng` environment. The following
    command creates an environment with this configuration using this file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This pattern of creating a `con``da` environment from an environment file is
    a nice way to get your environments set up for running the examples in each of
    the chapters in the book. So, the *Technical requirements* section in each chapter
    will point to the name of the correct environment YAML file contained in the book’s
    repository.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: These commands, coupled with your classic `conda` or `pip install` command,
    will set you up for your project quite nicely!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Or
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I think it’s always a good practice to have many options for doing something,
    and in general, this is good engineering practice. So given that, now that we
    have covered the classic Python environment and package managers in `conda` and
    `pip`, we will cover one more package manager. This is a tool that I like for
    its ease of use and versatility. I think it provides a nice extension of the capabilities
    of `conda` and `pip` and can be used to complement them nicely. This tool is called
    Poetry and it is what we turn to now.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Poetry
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Poetry is another package manager that has become very popular in recent years.
    It allows you to manage your project’s dependencies and package information into
    a single configuration file in a similar way to the environment YAML file we discussed
    in the section on Conda. Poetry’s strength lies in its far superior ability to
    help you manage complex dependencies and ensure “deterministic” builds, meaning
    that you don’t have to worry about the dependency of a package updating in the
    background and breaking your solution. It does this via the use of “lock files”
    as a core feature, as well as in-depth dependency checking. This means that reproducibility
    can often be easier in Poetry. It is important to call out that Poetry is focused
    on Python package management specifically, while Conda can also install and manage
    other packages, for example, C++ libraries. One way to think of Poetry is that
    it is like an upgrade of the `pip` Python installation package, but one that also
    has some environment management capability. The next steps will explain how to
    set up and use Poetry for a very basic use case.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build on this with some later examples in the book. First, follow these
    steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as usual, we will install Poetry:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After Poetry is installed, you can create a new project using the `poetry new`
    command, followed by the name of your project:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will create a new directory named `mleng-with-python` with the necessary
    files and directories for a Python project. To manage your project’s dependencies,
    you can add them to the `pyproject.toml` file in the root directory of your project.
    This file contains all of the configuration information for your project, including
    its dependencies and package metadata.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if you are building a ML project and want to use the `scikit-learn`
    library, you would add the following to your `pyproject.toml` file:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then install the dependencies for your project by running the following
    command. This will install the `scikit-learn` library and any other dependencies
    specified in your `pyproject.toml` file:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To use a dependency in your project, you can simply import it in your Python
    code like so:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, getting started with Poetry is very easy. We will return to
    using Poetry throughout the book in order to give you examples that complement
    the knowledge of Conda that we will develop. *Chapter 4*, *Packaging Up*, will
    discuss this in detail and will show you how to get the most out of Poetry.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Code version control
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to write code for real systems, you are almost certainly going
    to do it as part of a team. You are also going to make your life easier if you
    can have a clean audit trail of changes, edits, and updates so that you can see
    how the solution has developed. Finally, you are going to want to cleanly and
    safely separate out the stable versions of the solution that you are building
    and that can be deployed versus more transient developmental versions. All of
    this, thankfully, is taken care of by source code version control systems, the
    most popular of which is **Git**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not go into how Git works under the hood here (there are whole books
    on the topic!) but we will focus on understanding the key practical elements of
    using it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'You already have a GitHub account from earlier in the chapter, so the first
    thing to do is to create a repository with Python as the language and initialize
    `README.md` and `.gitignore` files. The next thing to do is to get a local copy
    of this repository by running the following command in Bash, Git Bash, or another
    terminal:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that you have done this, go into the `README.md` file and make some edits
    (anything will do). Then, run the following commands to tell Git to *monitor*
    this file and to save your changes locally with a message briefly explaining what
    these are:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This now means that your local Git instance has stored what you’ve changed and
    is ready to share that with the remote repo.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can then incorporate these changes into the `main` branch by doing the
    following:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you now go back to the GitHub site, you will see that the changes have taken
    place in your remote repository and that the comments you added have accompanied
    the change.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Other people in your team can then get the updated changes by running the following:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These steps are the absolute basics of Git and there is a ton more you can learn
    online. What we will do now, though, is start setting up our repo and workflow
    in a way that is relevant to ML engineering.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Git strategies
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The presence of a strategy for using version control systems can often be a
    key differentiator between the data science and ML engineering aspects of a project.
    It can sometimes be overkill to define a strict Git strategy for exploratory and
    basic modeling stages (*Discover* and *Play*) but if you want to engineer something
    for deployment (and you are reading this book, so this is likely where your head
    is at), then it is fundamentally important.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Great, but what do we mean by a Git strategy?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Well, let’s imagine that we just try to develop our solution without a shared
    direction on how to organize the versioning and code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'ML engineer *A* wants to start building some of the data science code into
    a Spark ML pipeline (more on this later) so creates a branch from `main` called
    `pipeline1spark`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'They then get to work on the branch and writes some nice code in a new file
    called `pipeline.py`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Great, they’ve made some excellent progress in translating some previous `sklearn`
    code into Spark, which was deemed more appropriate for the use case. They then
    keep working in this branch because it has all of their additions, and they think
    it’s better to do everything in one place. When they want to push the branch to
    the remote repository, they run the following commands:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'ML engineer *B* comes along, and they want to use ML engineer *A*’s pipeline
    code and build some extra steps around it. They know engineer *A*’s code has a
    branch with this work, so they know enough about Git to create another branch
    with *A*’s code in it, which *B* calls `pipeline`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'They then add some code to read the parameters for the model from a variable:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Cool, engineer *B* has made an update that is starting to abstract away some
    of the parameters. They then push their new branch to the remote repository:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, ML engineer *C* joins the team and wants to get started on the code.
    Opening up Git and looking at the branches, they see there are three:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, which one should be taken as the most up to date? If they want to make
    new edits, where should they branch from? It isn’t clear, but more dangerous than
    that is if they are tasked with pushing deployment code to the execution environment,
    they may think that `main` has all the relevant changes. On a far busier project
    that’s been going on for a while, they may even branch off from `main` and duplicate
    some of *B* and *C*’s work! In a small project, you would waste time going on
    this wild goose chase; in a large project with many different lines of work, you
    would have very little chance of maintaining a good workflow:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If these commits both get pushed to the `main` branch at the same time, then
    we will get what is called a **merge conflict**, and in each case, the engineer
    will have to choose which piece of code to keep, the current or new example. This
    would look something like this if engineer *A* pushed their changes to `main`
    first:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The delimiters in the code show that there has been a merge conflict and that
    it is up to the developer to select which of the two versions of the code they
    want to keep.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Although, in this simple case, we could potentially trust the engineers to select
    the *better* code, allowing situations like this to occur very frequently is a
    huge risk to your project. This not only wastes a huge amount of precious development
    time but it could also mean that you actually end up with worse code!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The way to avoid confusion and extra work like this is to have a very clear
    strategy for the use of the version control system in place, such as the one we
    will now explore.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The Gitflow workflow
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The biggest problem with the previous example was that all of our hypothetical
    engineers were actually working on the same piece of code in different places.
    To stop situations like this, you have to create a process that your team can
    all follow – in other words, a version control strategy or workflow.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular of these strategies is the **Gitflow workflow**. This
    builds on the basic idea of having branches that are dedicated to features and
    extends it to incorporate the concept of releases and hotfixes, which are particularly
    relevant to projects with a continuous deployment element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The main idea is we have several types of branches, each with clear and specific
    reasons for existing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**Main** contains your official releases and should only contain the stable
    version of your code.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dev** acts as the main point for branching from and merging to for most work
    in the repository; it contains the ongoing development of the code base and acts
    as a staging area before `main`.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature** branches should not be merged straight into the `main` branch;
    everything should branch off from `dev` and then be merged back into `dev`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release** branches are created from `dev` to kick off a build or release
    process before being merged into `main` and `dev` and then deleted.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hotfix** branches are for removing bugs in deployed or production software.
    You can branch this from `main` before merging into `main` and `dev` when done.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can all be summarized diagrammatically as in *Figure 2.9*, which shows
    how the different branches contribute to the evolution of your code base in the
    Gitflow workflow:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – The Gitflow Workflow ](img/B19525_02_09.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: The Gitflow workflow.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: This diagram is taken from [https://lucamezzalira.com/2014/03/10/git-flow-vs-github-flow/](https://lucamezzalira.com/2014/03/10/git-flow-vs-github-flow/).
    More details can be found at [https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'If your ML project can follow this sort of strategy (and you don’t need to
    be completely strict about this if you want to adapt it), you will likely see
    a drastic improvement in productivity, code quality, and even documentation:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Example code changes upon a pull request in GitHub ](img/B19525_02_10.png)Figure
    2.10: Example code changes upon a pull request in GitHub.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: One important aspect we haven’t discussed yet is the concept of code reviews.
    These are triggered in this process by what is known as a **pull request**, where
    you make known your intention to merge into another branch and allow another team
    member to review your code before this executes. This is the natural way to introduce
    code review to your workflow. You do this whenever you want to merge your changes
    and update them into dev or main branches. The proposed changes can then be made
    visible to the rest of the team, where they can be debated and iterated on with
    further commits before completing the merge.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: This enforces code review to improve quality, as well as creating an audit trail
    and safeguards for updates. *Figure 2.10* shows an example of how changes to code
    are made visible for debate during a pull request in GitHub.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed some of the best practices for applying version control
    to your code, let’s explore how to version control the models you produce during
    your ML project.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Model version control
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In any ML engineering project, it is not only code changes that you have to
    track clearly but also changes in your models. You want to track changes not only
    in the modeling approach but also in performance when new or different data is
    fed into your chosen algorithms. One of the best tools for tracking these kinds
    of changes and providing version control of ML models is **MLflow**, an open-source
    platform from **Databricks** under the stewardship of the Linux Foundation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'To install MLflow, run the following command in your chosen Python environment:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The main aim of MLflow is to provide a platform via which you can log model
    experiments, artifacts, and performance metrics. It does this through some very
    simple APIs provided by the Python `mlflow` library, interfaced to selected storage
    solutions through a series of centrally developed and community plugins. It also
    comes with functionality for querying, analyzing, and importing/exporting data
    via a **Graphical User Interface** (**GUI**), which will look something like *Figure
    2.11*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – The MLflow Tracking Server UI with some forecasting runs ](img/B19525_02_11.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: The MLflow tracking server UI with some forecasting runs.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The library is extremely easy to use. In the following example, we will take
    the sales forecasting example from *Chapter 1*, *Introduction to ML Engineering*,
    and add some basic MLflow functionality for tracking performance metrics and saving
    the trained Prophet model:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make the relevant imports, including MLflow’s `pyfunc` module, which
    acts as a general interface for saving and loading models that can be written
    as Python functions. This facilitates working with libraries and tools not natively
    supported in MLflow (such as the `fbprophet` library):'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To create a more seamless integration with the forecasting models from `fbprophet`,
    we define a small wrapper class that inherits from the `mlflow.pyfunc.PythonModel`
    object:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We now wrap the functionality for training and prediction into a single helper
    function called `train_predict()` to make running multiple times simpler. We will
    not define all of the details inside this function here but let’s run through
    the main pieces of MLflow functionality contained within it.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we need to let MLflow know that we are now starting a training run we
    wish to track:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside this loop, we then define and train the model, using parameters defined
    elsewhere in the code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then perform some cross-validation to calculate some metrics we would like
    to log:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can log these metrics, for example, the **Root Mean Squared Error** (**RMSE**)
    here, to our MLflow server:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then finally, we can use our model wrapper class to log the model and print
    some information about the run:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With only a few extra lines, we have started to perform version control on our
    models and track the statistics of different runs!
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are many different ways to save the ML model you have built to MLflow
    (and in general), which is particularly important when tracking model versions.
    Some of the main options are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '**pickle**: `pickle` is a Python library for object serialization that is often
    used for the export of ML models that are written in `scikit-learn` or pipelines
    in the wider `scipy` ecosystem ([https://docs.python.org/3/library/pickle.xhtml#module-pickle](https://docs.python.org/3/library/pickle.xhtml#module-pickle)).
    Although it is extremely easy to use and often very fast, you must be careful
    when exporting your models to `pickle` files because of the following:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: When you pickle an object, you have to unpickle it in other
    programs using the *same version of pickle* for stability reasons. This adds more
    complexity to managing your project.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: The documentation for `pickle` states clearly that it is *not
    secure* and that it is very easy to construct malicious pickles, which will execute
    dangerous code upon unpickling. This is a very important consideration, especially
    as you move toward production.'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, as long as the lineage of the `pickle` files you use is known and
    the source is trusted, they are OK to use and a very simple and fast way to share
    your models!
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**joblib**: `joblib` is a general-purpose pipelining library in Python that
    is very powerful but lightweight. It has a lot of really useful capabilities centered
    around caching, parallelizing, and compression that make it a very versatile tool
    for saving and reading in your ML pipelines. It is also particularly fast for
    storing large `NumPy` arrays, so is useful for data storage. We will use `joblib`
    more in later chapters. It is important to note that `joblib` suffers from the
    same security issues as `pickle`, so knowing the lineage of your `joblib` files
    is incredibly important.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON**: If `pickle` and `joblib` aren’t appropriate, you can serialize your
    model and its parameters in JSON format. This is good because JSON is a standardized
    text serialization format that is commonly used across a variety of solutions
    and platforms. The caveat to using JSON serialization of your models is that you
    often have to manually define the JSON structure with the relevant parameters
    you want to store. So, it can create a lot of extra work. Several ML libraries
    in Python have their own export to JSON functionality, for example, the deep learning
    package Keras, but they can all result in quite different formats.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MLeap**: MLeap is a serialization format and execution engine based on the
    **Java Virtual Machine** (**JVM**). It has integrations with Scala, PySpark, and
    Scikit-Learn but you will often see it used in examples and tutorials for saving
    Spark pipelines, especially for models built with Spark ML. This focus means it
    is not the most flexible of formats but is very useful if you are working in the
    **Spark ecosystem**.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ONNX**: The **Open Neural Network Exchange** (**ONNX**) format is aimed at
    being completely cross-platform and allowing the exchange of models between the
    main ML frameworks and ecosystems. The main downside of ONNX is that (as you can
    guess from the name) it is mainly aimed at neural network-based models, with the
    exception of its `scikit-learn` API. It is an excellent option if you are building
    a neural network though.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 3*, *From Model to Model Factory*, we will export our models to
    MLflow using some of these formats, but they are all compatible with MLflow and
    so you should feel comfortable using them as part of your ML engineering workflow.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The final section of this chapter will introduce some important concepts for
    planning how you wish to deploy your solution, prefacing more detailed discussions
    later in the book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Deploy
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final stage of the ML development process is the one that really matters:
    how do you get the amazing solution you have built out into the real world and
    solve your original problem? The answer has multiple parts, some of which will
    occupy us more thoroughly later in this book but will be outlined in this section.
    If we are to successfully deploy our solution, first of all, we need to know our
    deployment options: what infrastructure is available and is appropriate for the
    task? We then need to get the solution from our development environment onto this
    production infrastructure so that, subject to appropriate orchestration and controls,
    it can execute the tasks we need it to and surface the results where it has to.
    This is where the concepts of **DevOps** and **MLOps** come into play.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Let’s elaborate on these two core concepts, laying the groundwork for later
    chapters and exploring how to begin deploying our work.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Knowing your deployment options
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Chapter 5*, *Deployment Patterns and Tools*, we will cover in detail what
    you need to get your ML engineering project from the **develop** to **deploy**
    stage, but to pre-empt that and provide a taster of what is to come, let’s explore
    the different types of deployment options we have at our disposal:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**On-premises deployment**: The first option we have is to ignore the public
    cloud altogether and deploy our solutions in-house on owned infrastructure. This
    option is particularly popular and necessary for a lot of large institutions with
    a lot of legacy software and strong regulatory constraints on data location and
    processing. The basic steps for deploying on-premises are the same as deploying
    on the cloud but often require a lot more involvement from other teams with particular
    specialties. For example, if you are in the cloud, you often do not need to spend
    a lot of time configuring networking or implementing load balancers, whereas on-premises
    solutions will require these.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big advantage of on-premises deployment is security and peace of mind that
    none of your data is going to traverse your company firewall. The big downsides
    are that it requires a larger investment upfront for hardware and that you have
    to expend a lot of effort to successfully configure and manage that hardware effectively.
    We will not be discussing on-premises deployment in detail in this book, but all
    of the concepts we will employ around software development, packaging, environment
    management, and training and prediction systems still apply.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Infrastructure-as-a-Service** (**IaaS**): If you are going to use the cloud,
    one of the lowest levels of abstraction you have access to for deployment is IaaS
    solutions. These are typically based on the concept of virtualization, such that
    servers with a variety of specifications can be spun up at the user’s will. These
    solutions often abstract away the need for maintenance and operations as part
    of the service. Most importantly, they allow extreme scalability of your infrastructure
    as you need it. Have to run 100 more servers next week? No problem, just scale
    up your IaaS request and there it is. Although IaaS solutions are a big step up
    from fully managed on-premises infrastructure, there are still several things
    you need to think about and configure. The balance in cloud computing is always
    over how easy you want things to be versus what level of control you want to have.
    IaaS maximizes control but minimizes (relative) ease compared to some other solutions.
    In **AWS**, **Simple Storage Service** (**S3**) and **Elastic Compute Cloud**
    (**EC2**) are good examples of IaaS offerings.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform-as-a-Service** (**PaaS**): PaaS solutions are the next level up
    in terms of abstraction and usually provide you with a lot of capabilities without
    needing to know exactly what is going on under the hood. This means you can focus
    solely on the development tasks that the platform is geared up to support, without
    worrying about underlying infrastructure at all. One good example is **AWS** **Lambda**
    functions, which are serverless functions that can scale almost without limit.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All you are required to do is enter the main piece of code you want to execute
    inside the function. Another good example is **Databricks**, which provides a
    very intuitive UI on top of the **Spark cluster** infrastructure, with the ability
    to provision, configure, and scale up these clusters almost seamlessly.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Being aware of these different options and their capabilities can help you design
    your ML solution and ensure that you focus your team’s engineering effort where
    it is most needed and will be most valuable. If your ML engineer is working on
    configuring routers, for example, you have definitely gone wrong somewhere.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: But once you have selected the components you’ll use and provisioned the infrastructure,
    how do you integrate these together and manage your deployment and update cycles?
    This is what we will explore now.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DevOps and MLOps
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very powerful idea in modern software development is that your team should
    be able to continuously update your code base as needed, while testing, integrating,
    building, packaging, and deploying your solution should be as automated as possible.
    This then means these processes can happen on an almost continual basis without
    big pre-planned **buckets** of time being assigned to update cycles. This is the
    main idea behind **CI/CD**. CI/CD is a core part of **DevOps** and its ML-focused
    cousin **MLOps**, which both aim to bring together software development and post-deployment
    operations. Several of the concepts and solutions we will develop in this book
    will be built up so that they naturally fit within an MLOps framework.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The CI part is mainly focused on the stable incorporation of ongoing changes
    to the code base while ensuring functionality remains stable. The CD part is all
    about taking the resultant stable version of the solution and pushing it to the
    appropriate infrastructure.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.12* shows a high-level view of this process:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – A high-level view of CI/CD processes ](img/B19525_02_12.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: A high-level view of CI/CD processes.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In order to make CI/CD a reality, you need to incorporate tools that help automate
    tasks that you would traditionally perform manually in your development and deployment
    process. For example, if you can automate the running of tests upon merging of
    code, or the pushing of your code artifacts/models to the appropriate environment,
    then you are well on your way to CI/CD.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We can break this out further and think of the different types of tasks that
    fall into the DevOps or MLOps lifecycles for a solution. Development tasks will
    typically cover all of the activities that take you from a blank screen on your
    computer to a working piece of software. This means that development is where
    you spend most of your time in a DevOps or MLOps project. This covers everything
    from writing the code to formatting it correctly and testing it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 2.3* splits out these typical tasks and provides some details on how
    they build on each other, as well as typical tools you could use in your Python
    stack for enabling them.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lifecycle Stage** | **Activity** | **Details** | **Tools** |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| Dev | Testing | Unit tests: tests aimed at testing the functionality smallest
    pieces of code. | pytest or unittest |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| Integration tests: ensure that interfaces within the code and to other solutions
    work. | Selenium |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| Acceptance tests: business focused tests. | Behave |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| UI tests: ensuring any frontends behave as expected. |  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| Linting | Raise minor stylistic errors and bugs. | flake8 or bandit |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| Formatting | Enforce well-formatted code automatically. | black or sort |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| Building | The final stage of bringing the solution together. | Docker, twine,
    or pip |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: 'Table 2.3: Details of the development activities carried out in any DevOps
    or MLOps project.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can think about the ML activities within MLOps, which this book will
    be very concerned with. This covers all of the tasks that a classic Python software
    engineer would not have to worry about, but that are crucially important to get
    right for ML engineers like us. This includes the development of capabilities
    to automatically train the ML models, to run the predictions or inferences the
    model should generate, and to bring that together inside code pipelines. It also
    covers the staging and management of the versions of your models, which heavily
    complements the idea of versioning your application code, as we do using tools
    like Git. Finally, an ML engineer also has to consider that they have to build
    out specific monitoring capabilities for the operational mode of their solution,
    which is not covered in traditional DevOps workflows. For an ML solution, you
    may have to consider monitoring things like precision, recall, the f1-score, population
    stability, entropy, and data drift in order to know if the model component of
    your solution is behaving within a tolerable range. This is very different from
    classic software engineering as it requires a knowledge of how ML models work,
    how they can go wrong, and a real appreciation of the importance of data quality
    to all of this. This is why ML engineering is such an exciting place to be! See
    *Table 2.4* for some more details on these types of activities.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lifecycle Stage** | **Activity** | **Details** | **Tools** |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| ML | Training | Train the model . | Any ML package. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| Predicting | Run the predictions or inference steps. | Any ML package. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| Building | Creating the pipelines and application logic in which the model
    is embedded. | sklearn pipelines, Spark ML pipelines, ZenML. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| Staging | Tag and release the appropriate version of your models and pipelines.
    | MLflow or Comet.ml. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| Monitoring | Track the solution performance and raise alerts when necessary.
    | Seldon, Neptune.ai, Evidently.ai, or Arthur.ai. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: 'Table 2.4: Details on the ML-centered activities carried out during an MLOps
    project.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in either DevOps or MLOps, there is the Ops piece, which refers to
    Operations. This is all about how the solution will actually run, how it will
    alert you if there is an issue, and if it can recover successfully. Naturally
    then, operations will cover activities relating to the final packaging, build,
    and release of your solution. It also has to cover another type of monitoring,
    which is different from the performance monitoring of ML models. This monitoring
    has more of a focus on infrastructure utilization, stability, and scalability,
    on solution latency, and on the general running of the wider solution. This part
    of the DevOps and MLOps lifecycle is quite mature in terms of tooling, so there
    are many options available. Some information to get you started is presented in
    *Table 2.5*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lifecycle Stage** | **Activity** | **Details** | **Tools** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| Ops | Releasing | Taking the software you have built and storing it somewhere
    central for reuse. | Twine, pip, GitHub, or BitBucket. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| Deploying | Pushing the software you have built to the appropriate target
    location and environment. | Docker, GitHub Actions, Jenkins, TravisCI, or CircleCI.
    |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| Monitoring | Tracking the performance and utilization of the underlying infrastructure
    and general software performance, alerting where necessary. | DataDog, Dynatrace,
    or Prometheus. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: 'Table 2.5: Details of the activities carried out in order to make a solution
    operational in a DevOps or MLOps project.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have elucidated the core concepts needed across the MLOps lifecycle,
    in the next section, we will discuss how to implement CI/CD practices so that
    we can start making this a reality in our ML engineering projects. We will also
    extend this to cover automated testing of the performance of your ML models and
    pipelines, and to perform automated retraining of your ML models.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Building our first CI/CD example with GitHub Actions
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use GitHub Actions as our CI/CD tool in this book, but there are several
    other tools available that do the same job. GitHub Actions is available to anyone
    with a GitHub account, has a very useful set of documentation, [https://docs.github.com/en/actions](https://docs.github.com/en/actions),
    and is extremely easy to start using, as we will show now.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'When using GitHub Actions, you have to create a `.yml` file that tells GitHub
    when to perform the required actions and, of course, what actions to perform.
    This `.yml` file should be put in a folder called `.github/workflows` in the root
    directory of your repository. You will have to create this if it doesn’t already
    exist. We will do this in a new branch called `feature/actions`. Create this branch
    by running:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, create a `.yml` file called `github-actions-basic.yml`. In the following
    steps, we will build up this example `.yml` file for a Python project where we
    automatically install dependencies, run a **linter** (a solution to check for
    bugs, syntax errors, and other issues), and then run some unit tests. This example
    comes from the GitHub Starter Workflows repository ([https://github.com/actions/starter-workflows/blob/main/ci/python-package-conda.yml](https://github.com/actions/starter-workflows/blob/main/ci/python-package-conda.yml)).
    Open up `github-actions-basic.yml` and then execute the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you define the name of the GitHub Actions workflow and what Git event
    will trigger it:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You then list the jobs you want to execute as part of the workflow, as well
    as their configuration. For example, here we have one job called `build`, which
    we want to run on the latest Ubuntu distribution, and we want to attempt the build
    using several different versions of Python:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You then define the steps that execute as part of the job. Each step is separated
    by a hyphen and is executed as a separate command. It is important to note that
    the `uses` keyword grabs standard GitHub Actions; for example, in the first step,
    the workflow uses the **v2** version of the `checkout` action, and the second
    step sets up the Python versions we want to run in the workflow:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next step installs the relevant dependencies for the solution using `pip`
    and a `requirements.txt` file (but you can use `conda` of course!):'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then run some linting:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, we run our tests using our favorite Python testing library. For this
    step, we do not want to run through the entire repository, as it is quite complex,
    so for this example, we use the `working-directory` keyword to only run `pytest`
    in that directory.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since it contains a simple test function in `test_basic.py`, this will automatically
    pass:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have now built up the GitHub Actions workflow; the next stage is to show
    it running. This is taken care of automatically by GitHub, all you have to do
    is push to the remote repository. So, add the edited `.yml` file, commit it, and
    then push it:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After you have run these commands in the terminal, you can navigate to the GitHub
    UI and then click on **Actions** in the top menu bar. You will then be presented
    with a view of all action runs for the repository like that in *Figure 2.13.*
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_02_13.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: The GitHub Actions run as viewed from the GitHub UI.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: If you then click on the run, you will be presented with details of all jobs
    that ran within the **Actions** run, as shown in *Figure 2.14*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_02_14.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: GitHub Actions run details from the GitHub UI.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can go into each job and see the steps that were executed, as shown
    in *Figure 2.15*. Clicking on these will also show the outputs from each of the
    steps. This is extremely useful for analyzing any failures in the run.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_02_15.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: The GitHub Actions run steps as shown on the GitHub UI.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: What we have shown so far is an example of CI. For this to be extended to cover
    CD, we need to include steps that push the produced solution to its target host
    destination. Examples are building a Python package and publishing it to `pip`,
    or creating a pipeline and pushing it to another system for it to be picked up
    and run. This latter example will be covered with an **Airflow DAG** in *Chapter
    5*, *Deployment Patterns and Tools*. And that, in a nutshell, is how you start
    building your CI/CD pipelines. As mentioned, later in the book, we will build
    workflows specific to our ML solutions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at how we take CI/CD concepts to the next level for ML engineering
    and build some tests for our model performance, which can then also be triggered
    as part of continuous processes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Continuous model performance testing
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As ML engineers, we not only care about the core functional behavior of the
    code we are writing; we also have to care about the models that we are building,
    This is an easy thing to forget, as traditional software projects do not have
    to consider this component.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The process I will now walk you through shows how you can take some base reference
    data and start to build up some different flavors of tests to give confidence
    that your model will perform as expected when you deploy it.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already introduced how to test automatically with Pytest and GitHub
    Actions, the good news is that we can just extend this concept to include the
    testing of some model performance metrics. To do this, you need a few things in
    place:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Within the action or tests, you need to retrieve the reference data for performing
    the model validation. This can be done by pulling from a remote data store like
    an object store or a database, as long as you provide the appropriate credentials.
    I would suggest storing these as secrets in Github. Here, we will use a dataset
    generated in place using the `sklearn` library as a simple example.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to retrieve the model or models you wish to test from some location
    as well. This could be a full-fledged model registry or some other storage mechanism.
    The same points around access and secrets management as in *point 1* apply. Here
    we will pull a model from the `Hugging Face Hub` (more on Hugging Face in *Chapter
    3*), but this could equally have been an MLflow Tracking instance or some other
    tool.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to define the tests you want to run and that you are confident will
    achieve the desired outcome. You do not want to write tests that are far too sensitive
    and trigger failed builds for spurious reasons, and you also want to try and define
    tests that are useful for capturing the types of failures you would want to flag.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For *point 1*, here we grab some data from the `sklearn` library and make it
    available to the tests through a `pytest fixture`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For *point 2*, I will use the `Hugging Face Hub` package to retrieve the stored
    model. As mentioned in the bullets above, you will need to adapt this to whatever
    model storage mechanism you are accessing. The repository in this case is public
    so there is no need to store any secrets; if you did need to do this, please use
    the GitHub Secrets store.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we just need to write the tests. Let’s start simple with a test that confirms
    that the predictions of the model produce the correct object types:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can then write a test to assert some specific conditions on the performance
    of the model on the test dataset is met:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The previous test can be thought of as something like a data-driven unit test
    and will make sure that if you change something in the model (perhaps you change
    some feature engineering step in the pipeline or you change a hyperparameter),
    you will not breach the desired performance criteria. Once these tests have been
    successfully added to the repo, on the next push, the GitHub action will be triggered
    and you will see that the model performance test runs successfully.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: This means we are performing some continuous model validation as part of our
    CI/CD process!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_02_16.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: Successfully executing model validation tests as part of a CI/CD
    process using GitHub Actions.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: More sophisticated tests can be built upon this simple concept, and you can
    adapt the environment and packages used to suit your needs.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Continuous model training
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important extension of the “continuous” concept in ML engineering is to perform
    continuous training. The previous section showed how to trigger some ML processes
    for testing purposes when pushing code; now, we will discuss how to extend this
    for the case where you want to trigger retraining of the model based on a code
    change. Later in this book, we will learn a lot about training and retraining
    ML models based on a variety of different triggers like data or model drift in
    *Chapter 3*, *From Model to Model Factory*, and about how to deploy ML models
    in general in *Chapter 5*, *Deployment Patterns and Tools*. Given this, we will
    not cover the details of deploying to different targets here but instead show
    you how to build continuous training steps into your CI/CD pipelines.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: This is actually simpler than you probably think. As you have hopefully noticed
    by now, CI/CD is really all about automating a series of steps, which are triggered
    upon particular events occurring during the development process. Each of these
    steps can be very simple or more complex, but fundamentally it is always just
    other programs we are executing in the specified order upon activating the trigger
    event.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since we are concerned with continuous training, we should ask
    ourselves, when would we want to retrain during code development? Remember that
    we are ignoring the most obvious cases of retraining on a schedule or upon a drift
    in model performance or data quality, as these are touched on in later chapters.
    If we only consider that the code is changing for now, the natural answer is to
    train only when there is a substantial change to the code.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a trigger was fired every time we committed our code to version
    control, this would likely result in a lot of costly compute cycles being used
    for not much gain, as the ML model will likely not perform very differently in
    each case. We could instead limit the triggering of retraining to only occur when
    a pull request is merged into the main branch. In a project, this is an event
    that signifies a new software feature or functionality has been added and has
    now been incorporated into the core of the solution.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, when building CI/CD in GitHub Actions, you create or edit `YAML`
    files contained in the `.github` folder of your Git repository. If we want to
    trigger a training process upon a pull request, then we can add something like:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And then we need to define the steps for pushing the appropriate training script
    to the target system and running it. First, this would likely require some fetching
    of access tokens. Let’s assume this is for AWS and that you have loaded your appropriate
    AWS credentials as GitHub Secrets; for more information, see *Chapter 5*, *Deployment
    Patterns and Tools*. We would then be able to retrieve these in the first step
    of a `deploy-trainer` job:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You may then want to copy your repository files to a target **S3** destination;
    perhaps they contain modules that the main training script needs to run. You could
    then do something like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And finally, you would want to run some sort of process that uses these files
    to perform the training. There are so many ways to do this that I have left the
    specifics out for this example. Many ways for deploying ML processes will be covered
    in *Chapter 5*, *Deployment Patterns and Tools*:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And with that, you have all the key pieces you need to run continuous ML model
    training to complement the other section on continuous model performance testing.
    This is how you bring the DevOps concept of CI/CD to the world of MLOps!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about building a solid foundation for future work. We discussed
    the development steps common to all ML engineering projects, which we called “*Discover,
    Play, Develop, Deploy*,” and contrasted this way of thinking against traditional
    methodologies like CRISP-DM. In particular, we outlined the aim of each of these
    steps and their desired outputs.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: This was followed by a high-level discussion of tooling and a walkthrough of
    the main setup steps. We set up the tools for developing our code, keeping track
    of the changes to that code, managing our ML engineering project, and finally,
    deploying our solutions.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the chapter, we went through the details for each of the four
    steps we outlined previously, with a particular focus on the *Develop* and *Deploy*
    stages. Our discussion covered everything from the pros and cons of Waterfall
    and Agile development methodologies to environment management and then software
    development best practices. We explored how to package your ML solution and what
    deployment infrastructure is available for you to use, and outlined the basics
    of setting up your DevOps and MLOps workflows. We finished up the chapter by discussing,
    in some detail, how to apply testing to our ML code, including how to automate
    this testing as part of CI/CD pipelines. This was then extended into the concepts
    of continuous model performance testing and continuous model training.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn our attention to how to build out the software
    for performing the automated training and retraining of your models using a lot
    of the techniques we have discussed here.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/mle](https://packt.link/mle)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code102810325355484.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
