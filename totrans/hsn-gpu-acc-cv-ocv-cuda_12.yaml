- en: Basic Computer Vision Applications Using PyCUDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw important programming concepts related to PyCUDA.
    We also learned how to develop some programs in PyCUDA using these programming
    concepts. This chapter will build on this knowledge and we will use PyCUDA for
    developing basic image processing and computer vision applications. The parallel
    programming concepts of atomic operations and shared memory will also be explained
    in detail. The histogram of an image conveys important information related to
    the contrast of an image and it can also be used as an image feature for computer
    vision tasks. The program to calculate the histogram using PyCUDA will be explained
    in detail in this chapter. Other basic computer vision applications, such as the
    conversion of color spaces, image addition, and image inversion using PyCUDA,
    will also be described.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Histogram calculation using atomic operations and shared memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic computer vision applications using PyCUDA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color space conversion for an image and video from a webcam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image addition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image inversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires a good understanding of the Python programming languages.
    It also requires any computer or laptop with an Nvidia GPU on board. All the code
    used in this chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA).
    Check out the following video to see the code in action: [http://bit.ly/2prC1wI](http://bit.ly/2prC1wI)'
  prefs: []
  type: TYPE_NORMAL
- en: Histogram calculation in PyCUDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The histogram of an image conveys important information related to the contrast
    of an image, and it can also be used as an image feature for computer vision tasks.
    A histogram indicates the frequency of the occurrence of a particular pixel value.
    While calculating the histogram of an 8-bit image that is 256 x 256 in size, the
    65,535-pixel values will work on arrays of intensity values from 0-255\. If one
    thread is launched per pixel, then 65,535 threads will work on 256 memory locations
    of intensity values.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a situation in which a large number of threads try to modify a small
    portion of memory. While calculating the histogram of an image, read-modify-write
    operations have to be performed for all memory locations. This operation is `d_out[i]
    ++`, where first `d_out[i]` is read from memory, then incremented, and then written
    back to the memory. However, when multiple threads are doing this operation on
    the same memory location, it can give an incorrect output.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose one memory location has an initial value of `0` and the `a` and `b`
    threads try to increment this memory location, then the final answer should be
    `2`. However, at the time of execution, it may happen that both the `a` and `b`
    threads read this value simultaneously, then both threads will get the value `0`.
    They increment it to `1` and both will store this `1` on the memory. So instead
    of `2`, the calculated answer is `1`, which is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this can be dangerous, consider the example of an ATM cash
    withdrawal. Suppose you have a balance of $50,000 in your account. You have two
    ATM cards for the same account. You and your friend go to two different ATMs simultaneously
    to withdraw $40,000\. Both of you swipe cards simultaneously; so, when the ATMs
    check the balance, both will get $50,000\. If you both withdraw $40,000, then
    both machines will look at the initial balance, which is $50,000\. The amount
    to withdraw is less than the balance, hence both machines will give $40,000\.
    Even though your balance was $50,000, you got $80,000, which is dangerous. To
    avoid these scenarios, atomic operations are used when parallel programming, which
    is explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using atomic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CUDA provides an API called `atomicAdd` operations to avoid problems with parallel
    access of memory locations. It is a blocking operation, which means that when
    multiple threads try to access the same memory location, only one thread can access
    the memory location at a time. Other threads have to wait for this thread to finish
    and write its answer to memory. The kernel function to calculate a histogram using
    an `atomicAdd` operation is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The kernel function has three arguments. The first argument is the output array
    in which the histogram will be stored after calculation. The size of this array
    will be 256 for an 8-bit image. The second argument is the flattened array of
    image intensities. The third argument is the size of a flattened array. The memory
    location of the histogram array indexed by pixel intensity at the thread index
    will be incremented for every thread. The number of threads is equal to the size
    of a flattened image array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `atomicAdd` function is used to increment memory location. It takes two
    arguments. The first is the memory location we want to increment, and the second
    is the value by which this location has to be incremented. The `atomicadd` function
    will increase the cost in terms of execution time for histogram calculation. The
    Python code for histogram calculation using atomic operations is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The pointer reference to the kernel function is created using the `get_function()`
    method. The image is read using the OpenCV library. If it is not installed for
    Python, you can execute the following command from the Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, `OpenCV` library can be imported from any Python program using the `import
    cv2` command. The image read function is similar to what has been explained earlier
    in this book. The image is read as a grayscale image. The image is stored as a
    `numpy` array in Python. This array is flattened to a vector so that it can be
    operated upon by one-dimensional threads and blocks. It is also possible to work
    on an image with two-dimensional threads without flattening it. The `numpy` library
    provides a `flatten()` method to perform this operation.
  prefs: []
  type: TYPE_NORMAL
- en: The total number of blocks and threads are calculated from the size of an image
    and the number of bins for the histogram. The flattened image array, blank histogram
    array, and size of the flattened array are passed as arguments while calling the
    kernel function along with the number of blocks and threads to be launched. The
    kernel function returns the calculated histogram, which can be displayed or plotted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides a `matplotlib` library that contains a rich set of plotting
    functions. The `stem` function from this library is used to plot a discrete `histogram`
    function. The `xlim` function is used to set limits of the *X* axis. The `title`
    function is used to give a title to the plot. The output of the program is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d855bba-b5c5-4a11-a2d7-eb592c3d3b82.png)'
  prefs: []
  type: TYPE_IMG
- en: If a histogram does not have a uniform distribution of all intensities, then
    it can result in poor contrast images. The contrast can be enhanced by performing
    histogram equalization, which converts this distribution to a uniform one. A histogram
    also conveys information about the brightness of an image. If the histogram is
    concentrated on the left-hand side of the plot, then the image will be too dark
    and if it is concentrated on the right-hand side, then the image will be too bright.
    Again, histogram equalization can be used to correct this issue.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel function for calculating a histogram can also be developed using
    the concept of shared memory in parallel programming. This is illustrated in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shared memory is available on-chip on a GPU device, hence it is much faster
    than global memory. Shared memory latency is roughly 100 times lower than uncached
    global memory latency. All the threads from the same block can access shared memory.
    This is very useful in many applications where threads need to share their results
    with other threads. However, it can also create chaos or false results if this
    is not synchronized. If one thread reads data from memory before the other thread
    has written to it, it can lead to false results. So, this memory access should
    be controlled or managed properly. This is done with the `__syncthreads()` directive,
    which ensures that all write operations to memory are completed before moving
    ahead in the programs. This is also called a **barrier**. The meaning of barrier
    is that all threads will reach this line and wait for other threads to finish.
    After all the threads have reached this barrier, they can move further. This section
    will demonstrate how shared memory can be used from a PyCUDA program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept of shared memory can be utilized for calculating the histogram
    of an image. The kernel function is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of bins is 256 for an 8-bit image, so we are defining shared memory
    of size equal to the number of threads in a block, which is equal to a number
    of bins. We will calculate a histogram for the current block, so shared memory
    is initialized to zero and the histogram is computed for this block in the same
    way as discussed earlier. But this time, the result is stored in shared memory
    and not in global memory. In this case, only 256 threads are trying to access
    256 memory elements in shared memory instead of all 65,535 elements from the previous
    code. This will help in reducing the overhead time in the atomic operation. The
    final atomic add in the last line will add a histogram of one block to overall
    histogram values. As addition is a cumulative operation, we do not have to worry
    about the order in which each block is executed. The Python code to use this kernel
    function to calculate a histogram is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code is almost similar to that in the last section. The only difference
    is in the kernel call. The size of the shared memory should be defined while calling
    the kernel. This can be specified using the shared argument in the kernel call
    function. It is specified as `256*4` because the shared memory has a size of 256
    integer elements, which require 4 bytes of storage each. The same histogram will
    be displayed as shown in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the authenticity of the calculated histogram and compare the performance,
    the histogram is also calculated using the OpenCV inbuilt function, `calcHist`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calcHist` function requires five arguments. The first argument is the
    name of the image variable. The second argument specifies the channels in the
    case of a color image. It is zero for a grayscale image. The third argument specifies
    the mask if you want to calculate the histogram for a particular portion of an
    image. The fourth argument specifies the number of bins, and the fifth argument
    specifies the range of intensity values. OpenCV also provides `getTickCount` and
    `getTickFrequency` functions in Python for calculating the performance of the
    OpenCV code. The performance of the code without shared memory, with shared memory,
    and using the OpenCV function, is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/134bdb0d-ff13-4ef0-947e-80b4afae24b5.png)'
  prefs: []
  type: TYPE_IMG
- en: The time taken by the kernel function without shared memory is 1 ms while, using
    shared memory, it is 0.8 ms, which further proves the point that the use of shared
    memory improves the performance of kernel functions. To summarize, in this section,
    we have seen two different methods of calculating histograms on the GPU. We have
    also seen the concept of atomic operations and shared memory, along with how they
    can be used in PyCUDA.
  prefs: []
  type: TYPE_NORMAL
- en: Basic computer vision operations using PyCUDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will demonstrate the use of PyCUDA in developing simple computer
    vision applications. Images in Python are nothing but two- or three-dimensional
    `numpy` arrays, hence working and manipulating images in PyCUDA is similar to
    working with multidimensional arrays. This section will give you a basic idea
    of developing a simple application that you can utilize in developing complex
    computer vision applications using PyCUDA.
  prefs: []
  type: TYPE_NORMAL
- en: Color space conversion in PyCUDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most computer vision algorithms work on grayscale images, so there is a need
    for converting a color image captured from a camera to a grayscale image. Though
    OpenCV provides an inbuilt function to do this operation, it can be done by developing
    your own function. This section will demonstrate the method to develop a PyCUDA
    function for converting a color image to a grayscale image. If formulas for converting
    an image from one color space into another are known, then the function shown
    in this section can be written for any color space conversion by just replacing
    formulas.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV captures and stores image in BGR format, where blue is the first channel
    followed by green and red. The formula to convert from BGR format to grayscale
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of this function for an image and video is shown in the following
    two subsections.
  prefs: []
  type: TYPE_NORMAL
- en: BGR to gray conversion on an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will try to develop the kernel function for converting
    a BGR image into a grayscale image. The kernel function for converting a color
    image into grayscale is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A small `INDEX` function is defined to calculate a particular index value for
    a two-dimensional image of 256 x 256 in size. The flattened image arrays of three
    channels of a color image are taken as the input of the kernel function and its
    output is the grayscale image of the same size. The `INDEX` function is used to
    convert the thread index into a particular pixel location in an image. The grayscale
    value at that location is calculated using the function shown. The Python code
    for converting a color image to a grayscale image is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The color image is read using the OpenCV `imread` function. The size of an image
    should be 256 x 256, so if it isn't, then it should be converted into that size
    using the `cv2.resize` function. The color image is stored in BGR format so blue,
    green, and red channels are separated from it using array slicing in Python. These
    arrays are flattened so that they can be passed to a kernel function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel function is called with three color channels as input and an array
    to store the output grayscale image. The kernel function will calculate a grayscale
    value at every pixel location and return a flattened array of a grayscale image.
    This resultant array is converted back to the original image size using the `reshape`
    function from the `numpy` library. The OpenCV `imshow` function needs an unsigned
    integer data type for displaying the image so that an array is also converted
    to the `uint8` data type. The grayscale image is displayed on the screen, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7458e8e8-add3-465f-b622-0fe1c14c3049.png)'
  prefs: []
  type: TYPE_IMG
- en: BGR to gray conversion on a webcam video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same kernel function developed in the last section to convert an image
    into grayscale can be utilized to convert a video captured from a webcam into
    grayscale. The Python code for this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV in Python provides a `VideoCapture` class to capture video from a webcam.
    It requires a camera device index as an argument. It is specified as zero for
    a webcam. Then, a continuous `while` loop is started to capture frames from the
    webcam. The frames are read using the `read` method of a capture object. These
    frames are resized to 256 x 256 using the `resize` function of the `cv2` library.
    These frames are color images, so three channels are separated from them and flattened
    so that they can be passed to a kernel function. The kernel function is called
    in the same way as in the last section, and the result from it is reshaped for
    displaying on the screen. The output of the code for one frame of webcam stream
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07916faa-c2e1-41c4-8a9a-37e22fff0b5f.png)'
  prefs: []
  type: TYPE_IMG
- en: The webcam streaming will continue until the *q* key is pressed on the keyboard.
    To summarize, we have developed a kernel function in PyCUDA to convert a color
    image in BGR format into a grayscale image, which can work on an image as well
    as video. These kernel functions can be modified for other color space conversions
    by replacing equations for the same.
  prefs: []
  type: TYPE_NORMAL
- en: Image addition in PyCUDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The addition of two images can be performed when two images are of the same
    size. It performs a pixel-wise addition of two images. Suppose that, in two images,
    the pixel at (0,0) has intensity values of 100 and 150 respectively, then the
    intensity value in the resultant image will be 250, which is the addition of two
    intensity values, as shown in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV addition is a saturated operation, which means that if an answer of
    addition goes above 255, then it will be saturated at 255\. So, the same functionality
    is implemented as a PyCUDA kernel function. The code to perform image addition
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel function is similar to the array addition kernel function seen in
    the last chapter. The saturation condition is added to the kernel function, which
    indicates that if pixel intensity goes beyond 255 after addition, then it will
    be saturated at 255\. Two images of the same size are read, flattened, and converted
    into a single precision floating point data type. These flattened images, along
    with their size, are passed as arguments to the kernel function. The result calculated
    by the kernel function is reshaped to the original image size and converted into
    an unsigned integer type for displaying, using the `imshow` function. The result
    is shown in the following screenshot, along with the original images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d61c8000-e347-4ead-a9fe-31422c27b7f0.png)'
  prefs: []
  type: TYPE_IMG
- en: The same kernel functions can be used for other arithmetic and logical operations
    with minor modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Image inversion in PyCUDA using gpuarray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from arithmetic operations, the `NOT` operation is also widely used for
    inverting an image where black is converted into white and white is converted
    into black. It can be represented by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding equation, 255 indicates the maximum intensity value for an
    8-bit image. The `gpuarray` class provided by PyCUDA is used to develop a program
    for image inversion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The image is read as a grayscale image, flattened and converted into a single
    precision floating point data type for further processing. It is uploaded to the
    GPU using the `to_gpu` method of a `gpuarray` class. The inversion is performed
    on the GPU using the preceding equation and the result is downloaded back to the
    host using the `get()` method. The result is displayed on the screen by reshaping
    it to the original image size, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63d9d72c-1604-4e0f-bedc-b08461c13072.png)'
  prefs: []
  type: TYPE_IMG
- en: To summarize, this section demonstrated the use of PyCUDA in developing basic
    computer vision operations, such as color space conversions, image addition, and
    image inversion. This concept can be used to develop complex computer vision applications
    using PyCUDA.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described the use of PyCUDA in the development of simple computer
    vision applications. It described the use of PyCUDA in calculating the histogram
    of an array. The histogram is a very important statistical global feature of an
    image that can be used to find out important information about it. The concept
    of atomic operations and shared memory was explained in detail, using histogram
    calculation as an example. Images in Python are stored as `numpy` arrays, so manipulating
    images in PyCUDA is similar to modifying multidimensional `numpy` arrays. This
    chapter described the use of PyCUDA in various basic computer vision applications,
    such as image addition, image inversion, and color space conversion. The concepts
    described in this chapter can be utilized for developing complex computer vision
    applications using PyCUDA.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also marks an end to this book, which described the use of CUDA
    programming and GPU hardware in accelerating computer vision applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'State true or false: The use of the `d_out[i]++` line instead of the `atomicadd`
    operation will yield an accurate result in histogram calculation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using shared memory with atomic operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the modification in the kernel call function when shared memory is used
    in the kernel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which information can be obtained by calculating the histogram of an image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'State true or false: The kernel function developed in this chapter for BGR
    into grayscale conversion will also work for RGB into grayscale conversion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the image flattened in all of the examples shown in this chapter? Is
    it a compulsory step?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the image converted into the `uint8` data type from the `numpy` library
    before being displayed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
