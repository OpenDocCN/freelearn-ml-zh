- en: Drawing, Filtering, and Transformation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the previous chapter with nothing but the basics and fundamental
    concepts used in computer vision, and we ended up learning about many algorithms
    and functions used to perform a wide range of operations on matrices and images.
    First, we learned all about the functions that are embedded into the `Mat` class
    for convenience, such as cloning (or getting a full and independent copy) a matrix,
    calculating the cross and the dot product of two matrices, getting the transpose
    or inverse of a matrix, and producing an identity matrix. Then we moved on to
    learn about various element-wise operations in OpenCV. Element-wise operations,
    as we already know, are parallelizable algorithms that perform the same process
    on all individual pixels (or elements) of an image. During the process, we also
    experimented with the effect of such operations on actual image files. We completed
    the previous chapter by learning about operations and functions that treat images
    as a whole, unlike element-wise operations, but they are still considered matrix
    operations in terms of computer vision.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're ready to dig even deeper and learn about numerous powerful algorithms
    that are used in computer vision applications for tasks such as drawing, filtering,
    and the transformation of images. As mentioned in the previous chapters, these
    categories of algorithms as a whole are considered image-processing algorithms.
    In this chapter, we're going to start by learning about drawing shapes and text
    on empty images (similar to canvases) or existing images and video frames. The
    examples in the first section of this chapter will also include a tutorial about
    adding trackbars to OpenCV windows, for easily adjusting required parameters.
    After that, we'll move on to learn about image filtering techniques, such as blurring
    an image, dilation, and erosion. The filtering algorithms and functions that we'll
    learn about in this chapter include many popular and widely used algorithms, especially
    by professional photo-editing applications. This chapter will include a comprehensive
    section about image-transformation algorithms, including algorithms such as the
    simple resizing of photos, or complex algorithms such as remapping pixels. We'll
    end this chapter by learning how to apply colormaps to images to transform their
    colors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Drawing shapes and text on images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying smoothening filters to images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying dilation, erosion, and various other filters to images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remapping pixels and performing geometric transformation algorithms on images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying colormaps to images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IDE to develop C++ or Python applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenCV library
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [Chapter 2](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4),
    *Getting Started with OpenCV*, for more information about how to set up a personal
    computer and make it ready for developing computer vision applications using the
    OpenCV library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following URL to download the source codes and examples for
    this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter04)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on images
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without a doubt, one of the most important tasks when developing computer vision
    applications is drawing on images. Imagine you want to print the timestamp on
    pictures or draw a rectangle or ellipse around some areas in an image, and many
    similar examples that would require you to draw text and digits on images or shapes
    (rectangles and so on). As you can see, the examples that can be pointed out are
    quite obvious and countless, so without further ado, let's start with the functions
    and algorithms in OpenCV that can be used for drawing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Printing text on images
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV contains a very easy-to-use function named `putText` to draw, or print,
    text on images. This function requires an image as the input/output parameter,
    which means the source image itself will be updated. So, be sure to make a copy
    of your original image in memory before calling this function. You also need to
    provide this function with an origin point, which is simply the point where the
    text will be printed. The font of the text must be one of the entries in the `HersheyFonts`
    enum, which can take one (or a combination) of the following values:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_SIMPLEX`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_PLAIN`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_DUPLEX`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_COMPLEX`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_TRIPLEX`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_COMPLEX_SMALL`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_SCRIPT_SIMPLEX`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_SCRIPT_COMPLEX`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_ITALIC`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details of how each entry looks when printed, you can check out OpenCV or
    simply search online for more information about Hershey fonts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the parameters we just mentioned, you also need a few additional
    parameters, such as the scale, color, thickness, and line type of the text. Let's
    break them all down with a simple example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example code that demonstrates the usage of the `putText` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When executed on our example picture from the previous chapters, the following
    result will be created:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Obviously, increasing or decreasing `scale` will result in an increased or
    decreased text size. The `thickness` parameter corresponds to the thickness of
    the printed text and so on. The only parameter that is worth discussing more is `lineType`,
    which was **LINE_AA** in our example, but it can take any value from the `LineTypes`
    enum. Here are the most important line types along with their differences, demonstrated
    with a printed `W` character on a white background:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.gif)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: '**LINE_4** stands for four-connected line types, and **LINE_8** stands for
    eight-connected line types. **LINE_AA** though, which is the anti-aliased line
    type, is slower to draw than the other two, but, as can be seen in the preceding
    diagram, it also provides a much better quality.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The `LineTypes` enum also includes a `FILLED` entry, which is used for filling
    the shapes drawn on an image with the given color. It's important to note that
    almost all drawing functions in OpenCV (not just `putText`) require a line type
    parameter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV provides two more functions that are related to handling texts, but
    not exactly for drawing them. The first one is called `getFontScaleFromHeight`,
    which is used to get the required scale value based on a font type, height (in
    pixels), and thickness. Here''s an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We could have used the preceding code instead of providing a constant value
    for `scale` in our previous example usage of the `putText` function. Obviously,
    we need to replace `50` with any desired pixel height value for our text.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `getFontScaleFromHeight`, OpenCV also includes a function named `getTextSize`
    that can be used to retrieve the width and height that is required for printing
    a specific text on an image. Here''s an example code that shows how we can find
    out the width and height in pixels required for printing the `"Example"` word
    with the `FONT_HERSHEY_PLAIN` font type, a scale of `3.2`, and a thickness of
    `2` on an image using the `getTextSize` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The results should look like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means the text will need `216` by `30` pixels of space to be printed and
    the baseline will be `17` pixels farther from the bottom of the text.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Drawing shapes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use a set of very simple OpenCV functions to draw various types of shapes
    on images. These functions are all included in the `imgproc` module, just like
    the `putText` function, and they can be used to draw markers, lines, arrowed lines,
    rectangles, ellipses and circles, polylines, and so on in given points.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `drawMarker` function, which is used to draw a marker
    with a given type on an image. Here''s how this function is used to print a marker
    at the center of a given image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`position` is the central point of the marker, and the rest of the parameters
    are almost exactly what we saw in the `putText` function previously. This is the
    same pattern of parameters for most (if not all) of the drawing functions in OpenCV.
    The only parameters that are specific to the `drawMarker` function are `markerSize`,
    which is simply the size of the marker, and `markerType`, which can take one of
    the following values from the `MarkerTypes` enum:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '`MARKER_CROSS`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_TILTED_CROSS`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_STAR`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_DIAMOND`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_SQUARE`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_TRIANGLE_UP`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_TRIANGLE_DOWN`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram depicts all possible marker types mentioned in the previous
    list when they are printed on a white background, from left to right:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Drawing lines in OpenCV is possible using the `line` function. This function
    requires two points and it will draw a line connecting the given points. Here''s
    an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `shift` parameter corresponds to the number of fractional bits in the given
    points. You can omit or simply pass zero to make sure it has no effect on your
    results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `line` function, `arrowedLine` can be used to draw an arrowed
    line. Obviously, the order of the given points determines the direction of the
    arrow. The only parameter that this function needs is the `tipLength` parameter,
    which corresponds to the percentage of the line length that will be used to create
    the tip of the arrow. Here is an example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To be able to draw a circle on an image, we can use the `circle` function.
    Here''s how this function is used to draw a circle right at the center of an image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Apart from `center` and `radius`, which are obviously the center point and radius
    of the circle, the rest of the parameters are the same as the functions and examples
    we learned about in this section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing a rectangle or square on an image is possible using the `rectangle`
    function. This function is very similar to the `line` function in that it requires
    only two points. The difference is that the points given to the `rectangle` function
    correspond to the top-left and bottom-right corner points of a rectangle or square.
    Here''s an example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead of two separate `Point` objects, this function can also be provided
    with a single `Rect` object. Here''s how:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, an ellipse can be drawn by using the `ellipse` function. This function
    requires the size of the axes along with the angle of the ellipse to be provided.
    Additionally, you can use start and ending angles to draw all or part of an ellipse,
    or, in others, an arc instead of an ellipse. You can guess that passing `0` and
    `360` as the start and ending angles will result in a full ellipse being drawn.
    Here''s an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another way of calling the `ellipse` function is by using a `RotatedRect` object.
    In this version of the same function, you must first create a `RotatedRect` with
    a given width and height (or, in other words, size) and an `angle`, and then call
    the `ellipse` function as seen here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that with this method, you can't draw an arc, and this is only used for
    drawing full ellipses.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re down to the last type of shapes that can be drawn using OpenCV drawing
    functions, and that is polyline shapes. You can draw polyline shapes by using
    the `polylines` function. You must make sure to create a vector of points that
    corresponds to the vertices required for drawing a polyline. Here''s an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `isClosed` parameter is used to determine whether the polyline must be closed,
    by connecting the last vertex to the first one or not.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the `arrowedLine`, `circle`, `rectangle`,
    and `polylines` functions that we used in the preceding code snippets, when they
    are used to draw on our example image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Before proceeding with the next section and learning about algorithms used for
    image filtering, we're going to learn about adjusting parameters at runtime by
    using trackbars added to OpenCV display windows. This is a very useful method
    in order to try out a wide range of different parameters at runtime when you are
    experimenting with different values to see their effect, and it allows the value
    of a variable to be changed by simply readjusting a trackbar (or slider) position.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first see an example and then further break down the code and learn
    how trackbars are handled using OpenCV functions. The following complete example
    shows how we can use a trackbar to adjust the radius of a circle drawn on an image
    at runtime:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `window` and `trackbar` are `string` objects that are
    used to identify and access a specific trackbar on a specific window. `image`
    is a `Mat` object containing the source image. `center`, `radius`, `color`, `thickness`,
    `lineType`, and `shift` are parameters required for drawing a circle, as we learned
    previously in this chapter. `drawCircle` is the name of the function (the callback
    function, to be precise) that will be called back when the trackbar is used to
    update the `radius` value for the circle we want to draw. This function must have
    the signature that is used in this example, which has an `int` and a `void` pointer
    as its parameters. This function is quite simple; it just clones the original
    image, draws a circle on it, and then displays it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function is where we actually create the window and the trackbar.
    First, the `namedWindow` function must be called to create a window with the window
    name that we want. The `createTrackbar` function can then be called, as seen in
    the example, to create a trackbar on that window. Note that the trackbar itself
    has a name that is used to access it. This name will also be printed next to the
    trackbar to display its purpose to the user when the application is running. `setTrackbarMin`
    and `setTrackbarMax` are called to make sure our trackbar doesn't allow `radius`
    values less than 25 or greater than the width or height of the image (whichever
    is smaller), divided by 2 (since we're talking radius, not diameter).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot that demonstrates the output of our `window`
    along with `trackbar` on it that can be used to adjust the `radius` of the circle:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Try adjusting to see for yourself how the radius of the circle changes according
    to the position of the trackbar. Make sure to use this method when you want to
    experiment with the parameters of a function or algorithms that you learn in this
    book. Note that you can add as many trackbars as you need. However, adding more
    trackbars will use more space on your window, which might lead to a poor user
    interface and experience and, consequently, a hard-to-use program instead of a
    simplified one, so try to make use of trackbars wisely.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Filtering images
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It really doesn't matter whether you are trying to build a computer vision application
    to perform highly complex tasks, such as object detection in real-time, or simply
    modifying an input image in one way or another. Almost inevitably, you'll have
    to apply a certain type of filter to your input or output images. The reason for
    this is quite simple—not all pictures are ready to be processed out of the box,
    and most of the time, applying filters to make images smoother is one of the ways
    to make sure they can be fed into our algorithms.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在尝试构建一个执行高度复杂任务的计算机视觉应用程序，比如实时目标检测，还是简单地以某种方式修改输入图像，这真的并不重要。几乎不可避免的是，你将不得不应用某种类型的滤波器到你的输入或输出图像上。原因很简单——并不是所有的图片都准备好直接进行处理，大多数时候，应用滤波器使图像更平滑是确保它们可以被我们的算法处理的一种方式。
- en: The variety of filters that you can apply to your images in computer vision
    is huge, but in this section, we're going to be learning about some of the most
    important filters and especially the ones with an implementation in the OpenCV
    library that we can use.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉中，你可以应用到图像上的滤波器种类繁多，但在这个章节中，我们将学习一些最重要的滤波器，特别是那些在OpenCV库中有实现，我们可以使用的滤波器。
- en: Blurring/smoothening filters
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊/平滑滤波器
- en: Blurring an image is one of the most important image filtering tasks, and there
    are many algorithms that can perform it, each one with their own pros and cons,
    which we'll be talking about in this section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊图像是图像滤波任务中最重要的一项，有许多算法可以执行这项任务，每个算法都有其自身的优缺点，我们将在本节中讨论这些内容。
- en: 'Let''s start with the simplest filter used for smoothening images, which is
    called the median filter, and it can be done by using the `medianBlur` function,
    as seen in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用于平滑图像的最简单的滤波器开始，这个滤波器被称为中值滤波器，可以通过使用`medianBlur`函数来实现，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This filter simply finds the median value of the neighboring pixels of each
    pixel in an image. `ksize`, or the kernel size parameter, decides how big the
    kernel used for blurring is, or, in other words, how far the neighboring pixels
    will be considered in the blurring algorithm. The following image depicts the
    result of increasing the kernel size from 1 to 7:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此滤波器简单地找到图像中每个像素的邻近像素的中值。`ksize`，或核大小参数，决定了用于模糊的核的大小，换句话说，决定了在模糊算法中考虑邻近像素的距离。以下图像展示了从1到7增加核大小的结果：
- en: '![](img/00040.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.jpeg)'
- en: Note that the kernel size must be an odd value, and a kernel size of 1 will
    produce the exact same image as the input. So, in the previous images, you can
    see the increase in blurring level from the original image (the leftmost) until
    the kernel size of 7.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，核大小必须是奇数，核大小为1将产生与输入图像完全相同的图像。因此，在之前的图像中，你可以看到从原始图像（最左侧）到核大小为7的模糊级别的增加。
- en: 'Note that you can use extremely high kernel sizes if you need, but it is rarely
    necessary and would usually be needed in case you need to de-noise an extremely
    noisy image. Here''s an example image depicting the result of a kernel size of
    21:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你需要，可以使用非常高的核大小，但这通常是不必要的，通常只有在需要去除极其嘈杂的图像的噪声时才需要。以下是一个核大小为21的示例图像，展示了其结果：
- en: '![](img/00041.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00041.jpeg)'
- en: 'Another method of blurring an image is by using the `boxFilter` function. Let''s
    see how it''s done with an example code and then break it down further to better
    understand its behavior:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种模糊图像的方法是使用`boxFilter`函数。让我们通过一个示例代码来看看它是如何实现的，然后进一步分解以更好地理解其行为：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Box filtering is referred to as a blurring method in which a matrix of ones
    with the given `ksize` and `anchor` point is used for blurring an image. The major
    difference here, when compared with the `medianBlur` function, is that you can
    actually define the `anchor` point to be anything other than the center point
    in any neighborhood. You can also define the border type used in this function,
    whereas in the `medianBlur` function, `BORDER_REPLICATE` is used internally and
    cannot be changed. For more information about border types, you might want to
    refer to [Chapter 3](part0048.html#1DOR00-15c05657f8254d318ea883ef10fc67f4), *Array
    and Matrix Operations*. Finally, the `normalize` parameter allows us to normalize
    the result to the displayable result.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The `ddepth` parameter can be used to change the depth of the result. However,
    you can use -1 to make sure the result has the same depth as the source. Similarly,
    `anchor` can be supplied with -1 values to make sure the default anchor point
    is used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the previous example code. The image
    on the right is the box-filtered result of the image on the left-hand side:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'We can perform the exact same task, in other words, the normalized box filter,
    by using the `blur` function, as seen in the following example code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result of this sample code is exactly the same as calling `boxFilter`, as
    we saw previously. The obvious difference here is that this function does not
    allow us to change the depth of the result and applies normalization by default.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the standard box filter, you can also apply a square box filter
    with the `sqrBoxFilter` function. In this method, instead of calculating the sum
    of the neighboring pixels, the sum of their square values is calculated. Here
    is an example, which is incredibly similar to calling the `boxFilter` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The unnormalized versions of the `boxFilter` and `sqrBoxFilter` functions can
    also be used to find statistical information about the neighboring areas of all
    pixels in an image, and their use case is not limited to just blurring an image.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most popular blurring methods in computer vision is the **Gaussian
    blur** algorithm, and it can be performed in OpenCV by using the `GaussianBlur`
    function. This function, similar to the previous blur functions that we learned
    about, requires a kernel size, along with standard deviation values in the *X*
    and *Y* direction, called `sigmaX` and `sigmaY`, respectively. Here''s an example
    of how this function is used:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that a value of zero for `sigmaY` means the value of `sigmaX` will also
    be used in the *Y* direction. For more information about Gaussian blur, you can
    read about the Gaussian function in general and the `GaussianBlur` function in
    the OpenCV documentation pages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The last smoothening filter that we''ll learn about in this section is called
    the **bilateral filter**, and it can be achieved by using the `bilateralFilter`
    function. Bilateral filtering is a powerful method of de-noising and smoothening
    an image, while preserving edges. This function is also much slower and more CPU-intensive
    in comparison with the blur algorithms that we saw previously. Let''s see how
    `bilateralFilter` is used with an example and then break down the required parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将学习的最后一个平滑滤波器称为**双边滤波器**，可以通过使用`bilateralFilter`函数实现。双边滤波是一种强大的去噪和图像平滑方法，同时保留边缘。与之前看到的模糊算法相比，此函数也慢得多，CPU密集度更高。让我们通过一个例子来看看如何使用`bilateralFilter`，然后分解所需的参数：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`d`, or the filter size, is the diameter of the pixel neighborhood that will
    participate in the filter. The `sigmaColor` and `sigmaSpace` values are both used
    to define the effect of the color and coordinate the pixels nearer or farther
    from the pixel whose filtered value is being calculated. Here''s a screenshot
    that demonstrates the effect of the `bilateralFilter` function when executed on
    our example image:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`d`，或过滤器大小，是参与过滤的像素邻域的直径。`sigmaColor`和`sigmaSpace`值都用于定义颜色效果并协调计算过滤值像素的颜色和坐标。以下是演示`bilateralFilter`函数在我们示例图像上执行效果的截图：'
- en: '![](img/00043.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: Morphological filters
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态学滤波器
- en: Similar to smoothening filters, morphology filters are the algorithms that change
    the value of each pixel based on the value of the neighboring pixels, although
    the obvious difference is that they do not have a blurring effect and are mostly
    used to produce some form of erosion or dilation effect on images. This will be
    clarified with a few hands-on examples further in this section, but for now, let's
    see how morphological operations (also called **transformations**) are performed
    using OpenCV functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与平滑滤波器类似，形态学滤波器是改变每个像素值基于相邻像素值的算法，尽管明显的区别是它们没有模糊效果，并且主要用于在图像上产生某种形式的侵蚀或膨胀效果。这将在本节后面的几个动手示例中进一步阐明，但现在，让我们看看如何使用OpenCV函数执行形态学操作（也称为**变换**）。
- en: 'You can use the `morphologyEx` function to perform morphological operations
    on images. This function can be provided with an entry from the `MorphTypes` enum
    to specify the morphological operation. Here are the values that can be used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`morphologyEx`函数对图像执行形态学操作。此函数可以提供一个来自`MorphTypes`枚举的条目来指定形态学操作。以下是可用的值：
- en: '`MORPH_ERODE`: For erosion operation'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_ERODE`：用于侵蚀操作'
- en: '`MORPH_DILATE`: For dilation operation'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_DILATE`：用于膨胀操作'
- en: '`MORPH_OPEN`: For opening operation, or the dilation of eroded images'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_OPEN`：用于开运算，或侵蚀图像的膨胀'
- en: '`MORPH_CLOSE`: For closing operation, or the erosion of dilated images'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_CLOSE`：用于闭运算，或从膨胀图像中侵蚀'
- en: '`MORPH_GRADIENT`: For morphological gradient operation, or subtraction of the
    eroded image from the dilated image'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_GRADIENT`：用于形态学梯度操作，或从膨胀图像中减去侵蚀图像'
- en: '`MORPH_TOPHAT`: For Top-hat operation, or subtraction of the opening operation
    result from the source image'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_TOPHAT`：用于顶帽操作，或从源图像中减去开运算的结果'
- en: '`MORPH_BLACKHAT`: For Black-hat operation, or subtraction of the source image
    from the result of the closing operation'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_BLACKHAT`：用于黑帽操作，或从闭运算的结果中减去源图像'
- en: 'To understand all of the possible morphological operations mentioned in the
    previous list, it''s important to first understand the effect of erosion and dilation
    (the first two entries in the list) since the rest are simply different combinations
    of these two morphological operations. Let''s first try erosion with an example
    and, at the same time, learn how the `morphologyEx` function is used:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解前面列表中提到的所有可能的形态学操作，首先理解侵蚀和膨胀（列表中的前两项）的效果是很重要的，因为其余的只是这两种形态学操作的组合。让我们先通过一个例子来尝试侵蚀，同时学习如何使用`morphologyEx`函数：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`op`, or the operation, is an entry from the `MorphTypes` enum, as mentioned
    before. `kernel`, or the structuring element, is the kernel matrix used for the
    morphological operation, which itself is either created manually or by using the `getStructuringElement`
    function. You must provide the `getStructuringElement` with a `shape` morph, kernel
    size (`ksize`), and `anchor`. `shape` can be a rectangle, cross, or ellipse, and
    is simply an entry from the `MorphShapes` enum. The `iterations` variable refers
    to the number of times the morphological operation is performed on an image. `borderType`
    is interpreted exactly the same way as with all the functions we''ve seen so far
    for the extrapolation of pixels. In case a constant border type value is used,
    the `morphologyEx` function must also be provided with a border value, which can
    be retrieved by using the `morphologyDefaultBorderValue` function, or specified
    manually.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result of our preceding code (for erosion), when executed on our
    sample image:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Dilation, on the other hand, is performed by simply replacing the `op` value
    with `MORPH_DILATE` in the previous example. Here''s the result of the dilation
    operation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: A highly simplified description of what erosion and dilation operations do is
    that they cause the neighboring pixels of darker pixels to become darker (in case
    of erosion) or the neighboring pixels of brighter pixels to become brighter (in
    case of dilations), which, after more iterations, will cause a stronger and easily
    visible effect.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'As was mentioned before, all of the other morphological operations are simply
    a combination of erosion and dilation. Here are the results of opening and closing
    operations when they are executed on our example images:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Make sure you try the rest of the morphological operations by yourself to see
    their effects. Create user interfaces that have trackbars on them and try changing
    the value of `iteration` and other parameters to see how they affect the result
    of morphological operations. If used carefully and wisely, morphological operations
    can have very interesting results and further simplify an operation that you want
    to perform on an image.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding to the next section, it is worth noting that you can also
    use the `erode` and `dilate` functions to perform exactly the same operation.
    Although these functions do not require an operation parameter (since the operation
    is in their name already), the rest of the parameters are exactly the same as
    with the `morphologyEx` function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Derivative-based filters
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to learn about filtering algorithms that are based
    on calculating and using the derivatives of an image. To understand the concept
    of derivatives in an image, you can recall the fact that images are matrices,
    so you can calculate the derivatives (of any order) in *X* or *Y* directions,
    for instance, which, in the simplest case, would be the same as finding the change
    across the pixels in a direction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `Sobel` function, which is used to calculate the derivative
    of an image using a `Sobel` operator. Here''s how this function is used in practice:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`ddepth`, similar to what we saw in previous examples throughout this chapter,
    is used to define the depth of the output, and using `-1` makes sure the result
    has the same depth as the input. `dx` and `dy` are used to set the order of the
    derivative in both the *X* and *Y* directions. `ksize` is the size of the `Sobel`
    operator, which can be 1, 3, 5, or 7\. `scale` is used as the `scale` factor for
    the result, and delta is added to the `result`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The following images depict the result of the `Sobel` function when called
    with the parameter values from the preceding example code, but for a `delta` value
    of zero (on the left) and 255 (on the right):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: Try setting different `delta` and `scale` values and experiment with the results.
    Also try different derivative orders and see the effects for yourself. As you
    can see from the preceding output images, calculating the derivative of an image
    is a method for calculating the edges in an image.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `spatialGradient` function to calculate the first-order
    derivative of an image in both the *X* and *Y* directions using the `Sobel` operator,
    at the same time. In other words, calling `spatialGradient` once is like calling
    the `Sobel` function twice, for the first-order derivative in both directions.
    Here''s an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the `ksize` parameter must be `3` and the input image type must be
    grayscale, otherwise this function will fail to execute, although this might change
    in an upcoming OpenCV version.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the way we used the `Sobel` function, you can use the `Laplacian`
    function to calculate the Laplacian of an image. It''s important to note that
    this function essentially sums up the second derivatives in the *X* and *Y* directions
    calculated using the `Sobel` operator. Here''s an example that demonstrates the
    usage of the `Laplacian` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: All of the parameters used in the `Laplacian` function are already described
    in previous examples, and especially the `Sobel` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary filtering
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV supports the application of arbitrary filters on images by using the
    `filter2D` function. This function is capable of creating the result of many algorithms
    we already learned, but it requires a `kernel` matrix to be provided. This function
    simply convolves the whole image with the given `kernel` matrix. Here''s an example
    of applying an arbitrary filter on an image:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the result of this arbitrary filter. You can see the original image
    on the left, and the result of the filtering operation on the right-hand side:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: There is absolutely no limit to the number of possible filters you can create
    and use using the `filter2D` function. Make sure you try different kernel matrices
    and experiment with the `filter2D` function. You can also search online for popular
    filter kernel matrices and apply them using the `filter2D` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Transforming images
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about computer vision algorithms that are used
    to transform images in one way or another. The algorithms that we'll be learning
    in this section cover algorithms that change the content of an image, or the way
    its contents is interpreted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Thresholding algorithms
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thresholding algorithms are used to apply a threshold value to the pixels of
    an image. These algorithms can be used to effectively create masks from images
    that have possible regions or pixels of interest in them that pass a certain threshold
    value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `threshold` function to apply a threshold value on all pixels
    of an image. The `threshold` function must be provided with the type of threshold
    that is desired, and it can be an entry from the `ThresholdTypes` enum. The following
    is an example that can be used to find the brightest areas in an image using the
    `threshold` function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`thresh` is the minimum threshold value, and `maxval` is the maximum allowed
    value. Simply put, all pixel values between `thresh` and `maxval` are allowed
    to pass and so the `result` is created. The following is the result of the preceding
    `threshold` operation demonstrated with an example image:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Increase the `thresh` parameter (or the threshold value) and you'll notice that
    fewer pixels are allowed to pass. Setting a correct threshold value requires experience
    and knowledge about the scene. In some cases, however, you can develop programs
    that set the threshold automatically for you, or adaptively. Note that the threshold
    type completely affects the result of the `threshold` function. For instance,
    `THRESH_BINARY_INV` will produce the inverted result of `THRESH_BINARY` and so
    on. Make sure to try different threshold types and experiment for yourself with
    this interesting and powerful function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Another, more sophisticated, way of applying thresholds to images is by using
    the `adaptiveThreshold` function, which works with grayscale images. This function
    assigns the given `maxValue` parameter to the pixels that pass the threshold criteria.
    Besides that, you must provide a threshold type, an adaptive `threshold` method,
    a block size defining the diameter in the pixel neighborhood, and a constant value
    that is subtracted from the mean (depending on the adaptive `threshold` method).
    Here is an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that `adaptiveMethod` can take any of the following examples:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`ADAPTIVE_THRESH_MEAN_C`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADAPTIVE_THRESH_GAUSSIAN_C`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The higher the `blockSize` parameter value, the more pixels are used in the
    adaptive `threshold` method. The following is an example image that depicts the
    result of the `adaptiveThreshold` method called with the values in the preceding
    example code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Color space and type conversion
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting various color spaces and types to each other is extremely important,
    especially when it comes to dealing with images from different device types or
    intending to display them on different devices and formats. Let's see what this
    means with a very simple example. You'll need grayscale images for various OpenCV
    functions and computer vision algorithms, while some will require RGB color images.
    In such cases, you can use the `cvtColor` function to convert between various
    color spaces and formats.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example that converts a color image to grayscale:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`code` can take a conversion code, which must be an entry from the `ColorConversionCodes`
    enum. The following are some examples of the most popular color-conversion codes,
    that can be used with the `cvtColor` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`COLOR_BGR2RGB`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLOR_RGB2GRAY`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLOR_BGR2HSV`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on and on. Make sure to check the `ColorConversionCodes` enum
    for all possible color-conversion codes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Geometric transformation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is dedicated to geometric transformation algorithms and OpenCV
    functions. It's important to note that the name, Geometric transformation, is
    based on the fact that the algorithms falling in this category do not change the
    content of an image, they simply deform the existing pixels, while using an extrapolation
    and interpolation method to calculate the pixels that fall outside the area of
    the existing pixels, or over each other, respectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest geometric transformation algorithm, which is
    used for resizing an image. You can use the `resize` function to resize an image.
    Here is how this function is used:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the `dsize` parameter is set to a non-zero size, the `fx` and `fy` parameters
    are used to scale the input image. Otherwise, if `fx` and `fy` are both zero,
    the input image is resized to the given `dsize`. The `interpolation` parameter,
    on the other hand, is used to set the `interpolation` method used for the resize
    algorithm, and it must be one of the entries in the `InterpolationFlags` enum.
    Here are some of the possible values for the `interpolation` parameter:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`INTER_NEAREST`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTER_LINEAR`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTER_CUBIC`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTER_AREA`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTER_LANCZOS4`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to check out the OpenCV documentation pages for `InterpolationFlags`
    to find out about the details of each possible method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the previous example code that was
    used for resizing an image:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: Probably the most important geometric transformation algorithm, which is able
    to perform most of the other geometric transformations, is the remapping algorithm,
    and it can be achieved by calling the `remap` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remap` function must be provided with two mapping matrices, one for *X*
    and another one for the *Y* direction. Besides that, an interpolation and extrapolation
    (border type) method, along with a border value in case of constant border type,
    must be provided to the `remap` function. Let''s first see how this function is
    called and then try a couple of different remaps. Here''s an example that shows
    how the `remap` function is called:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can create an infinite number of different mappings and use them with the `remap`
    function to resize, flip, warp, and do many other transformations on images. For
    instance, the following code can be used to create a remapping that will cause
    a vertical flip of the resulting image:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Replace the code in the preceding `for` loop with the following and the result
    of the `remap` function call will be a horizontally flipped image:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Besides simple flipping, you can use the `remap` function to perform many interesting
    pixel deformations. Here''s an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As can be seen from the inline comments of the preceding example code, it is
    common to convert the OpenCV `i` and `j` values (row and column number) to a standard
    coordinate system and use *X* and *Y* with known mathematical and geometrical
    functions, and then convert them back to the OpenCV image coordinates. The following
    image demonstrates the result of the preceding example code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: The `remap` function is incredibly powerful and efficient as long as the calculation
    of `mapX` and `mapY` are handled efficiently. Make sure to experiment with this
    function to learn about more remapping possibilities.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: There are a huge number of geometric transformation algorithms in computer vision
    and in the OpenCV library, and covering all of them would need a book of its own.
    So, we'll leave the rest of the geometric transformation algorithms for you to
    explore and try on your own. Refer to the *Geometric Image Transformations* section
    in the OpenCV `imgproc` (Image Processing) module documentation for more geometric
    transformation algorithms and functions. In particular, make sure to learn about
    functions including `getPerspectiveTransform` and `getAffineTransform`, which
    are used to find the perspective and affine transformation between two sets of
    points. Such functions return transformation matrices that can be used to apply
    perspective and affine transformation to images by using the `warpPerspective`
    and `warpAffine` functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Applying colormaps
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll end this chapter by learning about applying colormaps to images. This
    is a fairly simple but powerful method that can be used to modify the colors of
    an image or its tone in general. This algorithm simply replaces the colors of
    an input image using a colormap and creates a result. A **colormap** is a 256-element
    array of color values, in which each element represents the color that must be
    used for the corresponding pixel values in the source image. We will break this
    down further with a couple of examples, but before that, let's see how colormaps
    are applied to images.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过学习将色图应用于图像来结束本章。这是一个相当简单但功能强大的方法，可以用来修改图像的颜色或其总体色调。该算法简单地使用色图替换输入图像的颜色并创建一个结果。**色图**是一个包含256个颜色值的数组，其中每个元素代表源图像中相应像素值必须使用的颜色。我们将通过几个示例进一步解释，但在那之前，让我们看看色图是如何应用于图像的。
- en: 'OpenCV contains a function named `applyColorMap` that can be used to either
    apply predefined colormaps or custom ones created by the user. In case predefined
    colormaps are used, `applyColorMap` must be provided with a colormap type, which
    must be an entry from the `ColormapTypes` enum. Here''s an example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV包含一个名为`applyColorMap`的函数，可以用来应用预定义的色图或用户创建的自定义色图。如果使用预定义的色图，`applyColorMap`必须提供一个色图类型，这必须是`ColormapTypes`枚举中的一个条目。以下是一个示例：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following image depicts the result of various predefined colormaps that
    can be applied using the `applyColorMap` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像展示了可以使用`applyColorMap`函数应用的各种预定义色图的结果：
- en: '![](img/00053.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: 'As mentioned earlier, you can also create your own custom colormaps. You just
    need to make sure you follow the instructions for creating a colormap. Your colormap
    must have a size of `256` elements (a `Mat` object with `256` rows and `1` column)
    and it must contain color or grayscale values, depending on the type of image
    you are planning to apply the colormap to. The following is an example that shows
    how to create a custom colormap by simply inverting the green channel color:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你还可以创建自己的自定义色图。你只需确保遵循创建色图的说明。你的色图必须包含256个元素的大小（一个具有256行和1列的`Mat`对象）并且它必须包含颜色或灰度值，具体取决于你打算将色图应用于哪种类型的图像。以下是一个示例，展示了如何通过简单地反转绿色通道颜色来创建自定义色图：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is the result of the preceding example code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面示例代码的结果：
- en: '![](img/00054.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Even though we tried to cover the most important topics of image-processing
    algorithms in computer vision, we still have a long way to go and many more algorithms
    to learn. The reason is quite simple, and that is the variety of applications
    that these algorithms can be used for. We learned a great deal of widely used
    computer vision algorithms in this chapter, but it should also be noted that whatever
    we learned in this chapter is also meant to ease your way when you start exploring
    the rest of the image-processing algorithms by yourself.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们试图涵盖计算机视觉中图像处理算法的最重要主题，但我们还有很长的路要走，还有更多的算法要学习。原因很简单，那就是这些算法可以用于各种应用。在本章中，我们学习了大量的广泛使用的计算机视觉算法，但还应注意的是，本章中我们所学的内容也是为了在你开始自己探索其他图像处理算法时能更容易一些。
- en: 'We started this chapter by learning about drawing functions that can be used
    to draw shapes and text on images. Then we moved on to learn about one of the
    most important computer vision topics: image filtering. We learned how to use
    smoothening algorithms, we experimented with morphological filters, and learned
    about erosion, dilation, opening, and closing. We also got to try some simple
    edge detection algorithms, or, in other words, derivative-based filters. We learned
    about thresholding images and changing their color spaces and types. The final
    sections of this chapter introduced us to geometric transformations and applying
    colormaps on images. We even created a custom colormap of our own. You can easily
    find the trace of the algorithms that we learned in this chapter, in many professional
    photo-editing or social-networking and photo-sharing applications.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习可以用于在图像上绘制形状和文本的绘图函数开始本章。然后我们转向学习最重要的计算机视觉主题之一：图像滤波。我们学习了如何使用平滑算法，实验了形态学滤波器，并了解了腐蚀、膨胀、开运算和闭运算。我们还尝试了一些简单的边缘检测算法，换句话说，基于导数的滤波器。我们学习了图像阈值处理和改变它们的颜色空间和类型。本章的最后部分介绍了几何变换和将颜色图应用于图像。我们甚至创建了自己的自定义颜色图。你可以在许多专业照片编辑或社交网络和照片共享应用中轻松找到我们在这章中学到的算法的痕迹。
- en: In the next chapter, we'll learn all about histograms, how they are calculated,
    and how they are used in computer vision. We'll cover the algorithms that are
    crucial when working on certain object detection and tracking algorithms that
    we'll be exploring in the upcoming chapters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习所有关于直方图的内容，包括它们的计算方式以及它们在计算机视觉中的应用。我们将涵盖在即将到来的章节中探索的某些对象检测和跟踪算法中至关重要的算法。
- en: Questions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Write a program that draws a cross mark over the whole image, with a thickness
    of 3 pixels and in the color red.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，在整张图像上绘制一个红色、3像素粗的十字标记。
- en: Create a window with a trackbar to change the `ksize` of a `medianBlur` function.
    The possible range for the `kszise` value should be between 3 and 99.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有滑块的窗口，用于更改`medianBlur`函数的`ksize`值。`kszise`值的可能范围应在3到99之间。
- en: Perform a gradient morphological operation on an image, considering a kernel
    size of 7 and a rectangular  morphological shape for the structuring element.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对图像执行梯度形态学操作，考虑结构元素的核大小为7，矩形形态学形状。
- en: Using `cvtColor`, convert a color image to grayscale and make sure only the
    darkest 100 shades of gray are filtered out using the `threshold` function. Make
    sure that filtered pixels are set to white in the result image and the rest of
    the pixels are set to black.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cvtColor`将彩色图像转换为灰度图，并确保使用`threshold`函数过滤掉最暗的100种灰色调。确保过滤后的像素在结果图像中设置为白色，其余像素设置为黑色。
- en: Use the `remap` function to resize an image to half of its original width and
    height, thus preserving the aspect ratio of the original image. Use a default
    border type for the extrapolation.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`remap`函数将图像调整为其原始宽度和高度的一半，从而保留原始图像的宽高比。使用默认的边界类型进行外推。
- en: a) Use colormaps to convert an image to grayscale. b) Convert an image to grayscale
    and invert its pixels at the same time.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a) 使用颜色图将图像转换为灰度图。b) 将图像转换为灰度图并同时反转其像素。
- en: Did you read about perspective transformation functions? Which OpenCV function
    covers all similar transformations in one single function?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你读过关于透视变换函数的内容吗？哪个OpenCV函数覆盖了所有类似的变换在一个单一函数中？
