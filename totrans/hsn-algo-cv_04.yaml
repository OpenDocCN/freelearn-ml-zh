- en: Drawing, Filtering, and Transformation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图、过滤和变换
- en: We started the previous chapter with nothing but the basics and fundamental
    concepts used in computer vision, and we ended up learning about many algorithms
    and functions used to perform a wide range of operations on matrices and images.
    First, we learned all about the functions that are embedded into the `Mat` class
    for convenience, such as cloning (or getting a full and independent copy) a matrix,
    calculating the cross and the dot product of two matrices, getting the transpose
    or inverse of a matrix, and producing an identity matrix. Then we moved on to
    learn about various element-wise operations in OpenCV. Element-wise operations,
    as we already know, are parallelizable algorithms that perform the same process
    on all individual pixels (or elements) of an image. During the process, we also
    experimented with the effect of such operations on actual image files. We completed
    the previous chapter by learning about operations and functions that treat images
    as a whole, unlike element-wise operations, but they are still considered matrix
    operations in terms of computer vision.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章中从计算机视觉的基本和基本概念开始，最终学习了用于在矩阵和图像上执行广泛操作的许多算法和函数。首先，我们学习了嵌入到`Mat`类中以方便使用的各种函数，例如克隆（或获取完整且独立的副本）一个矩阵，计算两个矩阵的叉积和点积，获取矩阵的转置或逆，以及生成单位矩阵。然后我们转向学习OpenCV中的各种逐元素操作。正如我们所知，逐元素操作是可并行化的算法，它们对图像的所有单个像素（或元素）执行相同的过程。在这个过程中，我们还实验了这些操作对实际图像文件的影响。我们通过学习将图像视为整体的操作和函数来完成前一章，这些操作与逐元素操作不同，但在计算机视觉中它们仍然被视为矩阵操作。
- en: Now, we're ready to dig even deeper and learn about numerous powerful algorithms
    that are used in computer vision applications for tasks such as drawing, filtering,
    and the transformation of images. As mentioned in the previous chapters, these
    categories of algorithms as a whole are considered image-processing algorithms.
    In this chapter, we're going to start by learning about drawing shapes and text
    on empty images (similar to canvases) or existing images and video frames. The
    examples in the first section of this chapter will also include a tutorial about
    adding trackbars to OpenCV windows, for easily adjusting required parameters.
    After that, we'll move on to learn about image filtering techniques, such as blurring
    an image, dilation, and erosion. The filtering algorithms and functions that we'll
    learn about in this chapter include many popular and widely used algorithms, especially
    by professional photo-editing applications. This chapter will include a comprehensive
    section about image-transformation algorithms, including algorithms such as the
    simple resizing of photos, or complex algorithms such as remapping pixels. We'll
    end this chapter by learning how to apply colormaps to images to transform their
    colors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好深入挖掘，学习在计算机视觉应用中用于绘图、过滤和图像变换等任务的众多强大算法。正如前几章所述，这些算法类别整体上被认为是图像处理算法。在本章中，我们将从学习如何在空图像（类似于画布）或现有图像和视频帧上绘制形状和文本开始。本章第一部分中的示例还将包括一个关于如何向OpenCV窗口添加滑块条的教程，以便轻松调整所需参数。之后，我们将继续学习图像过滤技术，例如模糊图像、膨胀和腐蚀。本章我们将学习到的过滤算法和函数包括许多流行且广泛使用的算法，尤其是被专业照片编辑应用所采用。本章将包括一个关于图像变换算法的全面部分，包括如简单调整照片大小或复杂如像素重新映射的算法。我们将通过学习如何将色图应用于图像以变换其颜色来结束本章。
- en: 'In this chapter, we''ll learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Drawing shapes and text on images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像上绘制形状和文本
- en: Applying smoothening filters to images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将平滑滤波器应用于图像
- en: Applying dilation, erosion, and various other filters to images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将膨胀、腐蚀以及其他各种过滤器应用于图像
- en: Remapping pixels and performing geometric transformation algorithms on images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像上重新映射像素并执行几何变换算法
- en: Applying colormaps to images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将色图应用于图像
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: An IDE to develop C++ or Python applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于开发C++或Python应用程序的IDE
- en: The OpenCV library
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV库
- en: Refer to [Chapter 2](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4),
    *Getting Started with OpenCV*, for more information about how to set up a personal
    computer and make it ready for developing computer vision applications using the
    OpenCV library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何设置个人计算机并使其准备好使用OpenCV库开发计算机视觉应用程序的更多信息，请参阅[第2章](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4)，*开始使用OpenCV*。
- en: 'You can use the following URL to download the source codes and examples for
    this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下网址下载本章的源代码和示例：
- en: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter04)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter04)'
- en: Drawing on images
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用图像
- en: Without a doubt, one of the most important tasks when developing computer vision
    applications is drawing on images. Imagine you want to print the timestamp on
    pictures or draw a rectangle or ellipse around some areas in an image, and many
    similar examples that would require you to draw text and digits on images or shapes
    (rectangles and so on). As you can see, the examples that can be pointed out are
    quite obvious and countless, so without further ado, let's start with the functions
    and algorithms in OpenCV that can be used for drawing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，在开发计算机视觉应用时，最重要的任务之一就是在图像上绘制。想象一下，你想要在图片上打印时间戳，或者在图像的某些区域绘制矩形或椭圆，以及许多需要你在图像或形状（如矩形）上绘制文本和数字的类似例子。正如你所看到的，可以指出的例子非常明显且数量众多，因此，我们不妨直接从
    OpenCV 中用于绘制的函数和算法开始。
- en: Printing text on images
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像上打印文本
- en: 'OpenCV contains a very easy-to-use function named `putText` to draw, or print,
    text on images. This function requires an image as the input/output parameter,
    which means the source image itself will be updated. So, be sure to make a copy
    of your original image in memory before calling this function. You also need to
    provide this function with an origin point, which is simply the point where the
    text will be printed. The font of the text must be one of the entries in the `HersheyFonts`
    enum, which can take one (or a combination) of the following values:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 包含一个名为 `putText` 的非常易于使用的函数，用于在图像上绘制或打印文本。此函数需要一个图像作为输入/输出参数，这意味着源图像本身将被更新。因此，在调用此函数之前，务必在内存中制作原始图像的副本。你还需要为此函数提供一个起点，这仅仅是文本将被打印的点。文本的字体必须是
    `HersheyFonts` 枚举中的一个条目，它可以取以下值之一（或它们的组合）：
- en: '`FONT_HERSHEY_SIMPLEX`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_HERSHEY_SIMPLEX`'
- en: '`FONT_HERSHEY_PLAIN`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_HERSHEY_PLAIN`'
- en: '`FONT_HERSHEY_DUPLEX`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_HERSHEY_DUPLEX`'
- en: '`FONT_HERSHEY_COMPLEX`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_HERSHEY_COMPLEX`'
- en: '`FONT_HERSHEY_TRIPLEX`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_HERSHEY_TRIPLEX`'
- en: '`FONT_HERSHEY_COMPLEX_SMALL`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_HERSHEY_COMPLEX_SMALL`'
- en: '`FONT_HERSHEY_SCRIPT_SIMPLEX`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_HERSHEY_SCRIPT_SIMPLEX`'
- en: '`FONT_HERSHEY_SCRIPT_COMPLEX`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_HERSHEY_SCRIPT_COMPLEX`'
- en: '`FONT_ITALIC`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FONT_ITALIC`'
- en: For details of how each entry looks when printed, you can check out OpenCV or
    simply search online for more information about Hershey fonts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于每个条目打印时的详细情况，你可以查看 OpenCV 或简单地在网上搜索有关 Hershey 字体的更多信息。
- en: Apart from the parameters we just mentioned, you also need a few additional
    parameters, such as the scale, color, thickness, and line type of the text. Let's
    break them all down with a simple example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才提到的参数之外，你还需要一些额外的参数，例如文本的缩放、颜色、粗细和线型。让我们用一个简单的例子来逐一解释它们。
- en: 'Here''s an example code that demonstrates the usage of the `putText` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示 `putText` 函数用法的示例代码：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When executed on our example picture from the previous chapters, the following
    result will be created:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当在上一章的示例图片上执行时，将创建以下结果：
- en: '![](img/00035.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: 'Obviously, increasing or decreasing `scale` will result in an increased or
    decreased text size. The `thickness` parameter corresponds to the thickness of
    the printed text and so on. The only parameter that is worth discussing more is `lineType`,
    which was **LINE_AA** in our example, but it can take any value from the `LineTypes`
    enum. Here are the most important line types along with their differences, demonstrated
    with a printed `W` character on a white background:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，增加或减少 `scale` 将导致文本大小的增加或减少。`thickness` 参数对应于打印文本的粗细，等等。唯一值得讨论的参数是 `lineType`，在我们的示例中它是
    **LINE_AA**，但它可以取 `LineTypes` 枚举中的任何值。以下是重要的线型及其差异，通过在白色背景上打印 `W` 字符来演示：
- en: '![](img/00036.gif)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00036.gif)'
- en: '**LINE_4** stands for four-connected line types, and **LINE_8** stands for
    eight-connected line types. **LINE_AA** though, which is the anti-aliased line
    type, is slower to draw than the other two, but, as can be seen in the preceding
    diagram, it also provides a much better quality.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**LINE_4** 表示四连接线型，**LINE_8** 表示八连接线型。然而，**LINE_AA**，即抗锯齿线型，比其他两种线型绘制速度慢，但如图所示，它也提供了更好的质量。'
- en: The `LineTypes` enum also includes a `FILLED` entry, which is used for filling
    the shapes drawn on an image with the given color. It's important to note that
    almost all drawing functions in OpenCV (not just `putText`) require a line type
    parameter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineTypes` 枚举还包括一个 `FILLED` 条目，它用于用给定的颜色填充图像上绘制的形状。需要注意的是，OpenCV 中几乎所有绘图函数（不仅仅是
    `putText`）都需要一个线型参数。'
- en: 'OpenCV provides two more functions that are related to handling texts, but
    not exactly for drawing them. The first one is called `getFontScaleFromHeight`,
    which is used to get the required scale value based on a font type, height (in
    pixels), and thickness. Here''s an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 提供了两个与处理文本相关的函数，但不是用于绘制文本。第一个函数名为 `getFontScaleFromHeight`，它用于根据字体类型、高度（以像素为单位）和粗细获取所需的缩放值。以下是一个示例：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We could have used the preceding code instead of providing a constant value
    for `scale` in our previous example usage of the `putText` function. Obviously,
    we need to replace `50` with any desired pixel height value for our text.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的代码代替在之前 `putText` 函数的示例使用中为 `scale` 提供一个常量值。显然，我们需要将 `50` 替换为我们文本所需的任何像素高度值。
- en: 'Besides `getFontScaleFromHeight`, OpenCV also includes a function named `getTextSize`
    that can be used to retrieve the width and height that is required for printing
    a specific text on an image. Here''s an example code that shows how we can find
    out the width and height in pixels required for printing the `"Example"` word
    with the `FONT_HERSHEY_PLAIN` font type, a scale of `3.2`, and a thickness of
    `2` on an image using the `getTextSize` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `getFontScaleFromHeight`，OpenCV 还包括一个名为 `getTextSize` 的函数，可以用来检索打印特定文本所需的宽度和高度。以下是一个示例代码，展示了我们如何使用
    `getTextSize` 函数找出打印 `“Example”` 单词所需的像素宽度和高度，使用 `FONT_HERSHEY_PLAIN` 字体类型，缩放为
    `3.2`，粗细为 `2`：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The results should look like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像以下这样：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means the text will need `216` by `30` pixels of space to be printed and
    the baseline will be `17` pixels farther from the bottom of the text.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着文本需要 `216` by `30` 像素的空间来打印，基线将比文本底部远 `17` 像素。
- en: Drawing shapes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制形状
- en: You can use a set of very simple OpenCV functions to draw various types of shapes
    on images. These functions are all included in the `imgproc` module, just like
    the `putText` function, and they can be used to draw markers, lines, arrowed lines,
    rectangles, ellipses and circles, polylines, and so on in given points.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一组非常简单的 OpenCV 函数在图像上绘制各种类型的形状。这些函数都包含在 `imgproc` 模块中，就像 `putText` 函数一样，并且可以用来在给定点绘制标记、线条、箭头线条、矩形、椭圆、圆、多边形等。
- en: 'Let''s start with the `drawMarker` function, which is used to draw a marker
    with a given type on an image. Here''s how this function is used to print a marker
    at the center of a given image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `drawMarker` 函数开始，该函数用于在图像上绘制给定类型的标记。以下是该函数如何用于在给定图像的中心打印标记的示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`position` is the central point of the marker, and the rest of the parameters
    are almost exactly what we saw in the `putText` function previously. This is the
    same pattern of parameters for most (if not all) of the drawing functions in OpenCV.
    The only parameters that are specific to the `drawMarker` function are `markerSize`,
    which is simply the size of the marker, and `markerType`, which can take one of
    the following values from the `MarkerTypes` enum:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`position` 是标记的中心点，其余的参数几乎与我们之前在 `putText` 函数中看到的是一样的。这是 OpenCV 中大多数（如果不是所有）绘图函数的参数模式。唯一特定于
    `drawMarker` 函数的参数是 `markerSize`，它只是标记的大小，以及 `markerType`，它可以取 `MarkerTypes` 枚举中的以下值之一：'
- en: '`MARKER_CROSS`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MARKER_CROSS`'
- en: '`MARKER_TILTED_CROSS`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MARKER_TILTED_CROSS`'
- en: '`MARKER_STAR`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MARKER_STAR`'
- en: '`MARKER_DIAMOND`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MARKER_DIAMOND`'
- en: '`MARKER_SQUARE`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MARKER_SQUARE`'
- en: '`MARKER_TRIANGLE_UP`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MARKER_TRIANGLE_UP`'
- en: '`MARKER_TRIANGLE_DOWN`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MARKER_TRIANGLE_DOWN`'
- en: 'The following diagram depicts all possible marker types mentioned in the previous
    list when they are printed on a white background, from left to right:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了之前列表中提到的所有可能的标记类型，当它们打印在白色背景上时，从左到右排列：
- en: '![](img/00037.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.gif)'
- en: 'Drawing lines in OpenCV is possible using the `line` function. This function
    requires two points and it will draw a line connecting the given points. Here''s
    an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenCV 中使用 `line` 函数可以绘制线条。此函数需要两个点，并将绘制连接给定点的线条。以下是一个示例：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `shift` parameter corresponds to the number of fractional bits in the given
    points. You can omit or simply pass zero to make sure it has no effect on your
    results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`shift`参数对应于给定点的分数位数。您可以省略或简单地传递零以确保它对您的结果没有影响。'
- en: 'Similar to the `line` function, `arrowedLine` can be used to draw an arrowed
    line. Obviously, the order of the given points determines the direction of the
    arrow. The only parameter that this function needs is the `tipLength` parameter,
    which corresponds to the percentage of the line length that will be used to create
    the tip of the arrow. Here is an example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与`line`函数类似，`arrowedLine`也可以用来绘制带箭头的线。显然，给定点的顺序决定了箭头的方向。这个函数唯一需要的参数是`tipLength`参数，它对应于用于创建箭头尖端的线长百分比。以下是一个示例：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To be able to draw a circle on an image, we can use the `circle` function.
    Here''s how this function is used to draw a circle right at the center of an image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在图像上绘制一个圆，我们可以使用`circle`函数。以下是这个函数如何用来在图像中心绘制一个圆的示例：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Apart from `center` and `radius`, which are obviously the center point and radius
    of the circle, the rest of the parameters are the same as the functions and examples
    we learned about in this section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`center`和`radius`，它们显然是圆的中心点和半径之外，其余参数与我们在本节中学到的函数和示例相同。
- en: 'Drawing a rectangle or square on an image is possible using the `rectangle`
    function. This function is very similar to the `line` function in that it requires
    only two points. The difference is that the points given to the `rectangle` function
    correspond to the top-left and bottom-right corner points of a rectangle or square.
    Here''s an example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rectangle`函数可以在图像上绘制矩形或正方形。这个函数与`line`函数非常相似，因为它只需要两个点。不同之处在于，提供给`rectangle`函数的点对应于矩形或正方形的左上角和右下角点。以下是一个示例：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead of two separate `Point` objects, this function can also be provided
    with a single `Rect` object. Here''s how:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个单独的`Point`对象外，这个函数还可以提供一个单一的`Rect`对象。以下是这样做的方法：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, an ellipse can be drawn by using the `ellipse` function. This function
    requires the size of the axes along with the angle of the ellipse to be provided.
    Additionally, you can use start and ending angles to draw all or part of an ellipse,
    or, in others, an arc instead of an ellipse. You can guess that passing `0` and
    `360` as the start and ending angles will result in a full ellipse being drawn.
    Here''s an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以使用`ellipse`函数绘制椭圆。这个函数需要提供轴的大小以及椭圆的角度。此外，您可以使用起始和结束角度来绘制椭圆的全部或部分，或者，在其他情况下，绘制一个圆弧而不是椭圆。您可以猜测，将`0`和`360`作为起始和结束角度将导致绘制一个完整的椭圆。以下是一个示例：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another way of calling the `ellipse` function is by using a `RotatedRect` object.
    In this version of the same function, you must first create a `RotatedRect` with
    a given width and height (or, in other words, size) and an `angle`, and then call
    the `ellipse` function as seen here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调用`ellipse`函数的方法是使用`RotatedRect`对象。在这个函数的版本中，您必须首先创建一个具有给定宽度和高度（或者说大小）以及一个`angle`的`RotatedRect`，然后像下面这样调用`ellipse`函数：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that with this method, you can't draw an arc, and this is only used for
    drawing full ellipses.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用这种方法，您不能绘制圆弧，这仅用于绘制完整的椭圆。
- en: 'We''re down to the last type of shapes that can be drawn using OpenCV drawing
    functions, and that is polyline shapes. You can draw polyline shapes by using
    the `polylines` function. You must make sure to create a vector of points that
    corresponds to the vertices required for drawing a polyline. Here''s an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了可以使用OpenCV绘图函数绘制的最后一种形状类型，那就是多边形形状。您可以通过使用`polylines`函数来绘制多边形形状。您必须确保创建一个点向量，它对应于绘制多边形所需的顶点。以下是一个示例：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `isClosed` parameter is used to determine whether the polyline must be closed,
    by connecting the last vertex to the first one or not.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`isClosed`参数用于确定多边形线是否必须闭合，即是否通过将最后一个顶点连接到第一个顶点。'
- en: 'The following image depicts the result of the `arrowedLine`, `circle`, `rectangle`,
    and `polylines` functions that we used in the preceding code snippets, when they
    are used to draw on our example image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了我们在前面的代码片段中使用的`arrowedLine`、`circle`、`rectangle`和`polylines`函数在绘制示例图像时的结果：
- en: '![](img/00038.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00038.jpeg)'
- en: Before proceeding with the next section and learning about algorithms used for
    image filtering, we're going to learn about adjusting parameters at runtime by
    using trackbars added to OpenCV display windows. This is a very useful method
    in order to try out a wide range of different parameters at runtime when you are
    experimenting with different values to see their effect, and it allows the value
    of a variable to be changed by simply readjusting a trackbar (or slider) position.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一节并学习用于图像过滤的算法之前，我们将学习如何通过在 OpenCV 显示窗口中添加滑块来在运行时调整参数。当你实验不同的值以查看它们的效果时，这是一个非常有用的方法，以便在运行时尝试大量不同的参数，并且它允许通过简单地调整滑块（或滑块）的位置来改变变量的值。
- en: 'Let''s first see an example and then further break down the code and learn
    how trackbars are handled using OpenCV functions. The following complete example
    shows how we can use a trackbar to adjust the radius of a circle drawn on an image
    at runtime:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个例子，然后进一步分解代码，学习如何使用 OpenCV 函数处理滑块。以下完整的例子展示了我们如何使用滑块在运行时调整图像上绘制的圆的半径：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `window` and `trackbar` are `string` objects that are
    used to identify and access a specific trackbar on a specific window. `image`
    is a `Mat` object containing the source image. `center`, `radius`, `color`, `thickness`,
    `lineType`, and `shift` are parameters required for drawing a circle, as we learned
    previously in this chapter. `drawCircle` is the name of the function (the callback
    function, to be precise) that will be called back when the trackbar is used to
    update the `radius` value for the circle we want to draw. This function must have
    the signature that is used in this example, which has an `int` and a `void` pointer
    as its parameters. This function is quite simple; it just clones the original
    image, draws a circle on it, and then displays it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`window` 和 `trackbar` 是 `string` 对象，用于识别和访问特定窗口上的特定滑块。`image` 是包含源图像的
    `Mat` 对象。`center`、`radius`、`color`、`thickness`、`lineType` 和 `shift` 是绘制圆所需的参数，正如我们在本章前面所学。`drawCircle`
    是当使用滑块更新我们想要绘制的圆的 `radius` 值时将被调用的函数（确切地说，是回调函数）。这个函数必须具有示例中使用的签名，它有一个 `int` 和一个
    `void` 指针作为其参数。这个函数相当简单；它只是克隆原始图像，在其上绘制一个圆，然后显示它。
- en: The `main` function is where we actually create the window and the trackbar.
    First, the `namedWindow` function must be called to create a window with the window
    name that we want. The `createTrackbar` function can then be called, as seen in
    the example, to create a trackbar on that window. Note that the trackbar itself
    has a name that is used to access it. This name will also be printed next to the
    trackbar to display its purpose to the user when the application is running. `setTrackbarMin`
    and `setTrackbarMax` are called to make sure our trackbar doesn't allow `radius`
    values less than 25 or greater than the width or height of the image (whichever
    is smaller), divided by 2 (since we're talking radius, not diameter).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数是我们实际创建窗口和滑块的地方。首先，必须调用 `namedWindow` 函数来创建一个具有我们想要的窗口名称的窗口。然后，可以像示例中那样调用
    `createTrackbar` 函数，在该窗口上创建一个滑块。请注意，滑块本身有一个名称，用于访问它。当应用程序运行时，这个名称也将打印在滑块旁边，以向用户显示其目的。调用
    `setTrackbarMin` 和 `setTrackbarMax` 确保我们的滑块不允许 `radius` 值小于 25 或大于图像的宽度或高度（取较小者），然后除以
    2（因为我们谈论的是半径，而不是直径）。'
- en: 'The following is a screenshot that demonstrates the output of our `window`
    along with `trackbar` on it that can be used to adjust the `radius` of the circle:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个截图，展示了我们的 `window` 以及其上的 `trackbar`，可以用来调整圆的 `radius`：
- en: '![](img/00039.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00039.jpeg)'
- en: Try adjusting to see for yourself how the radius of the circle changes according
    to the position of the trackbar. Make sure to use this method when you want to
    experiment with the parameters of a function or algorithms that you learn in this
    book. Note that you can add as many trackbars as you need. However, adding more
    trackbars will use more space on your window, which might lead to a poor user
    interface and experience and, consequently, a hard-to-use program instead of a
    simplified one, so try to make use of trackbars wisely.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整以亲自看到圆的半径是如何根据滑块的位置变化的。确保在你想实验这本书中学到的函数或算法的参数时使用这种方法。请注意，你可以添加你需要的任意数量的滑块。然而，添加更多的滑块会在你的窗口上使用更多的空间，这可能会导致用户界面和体验不佳，从而使得程序难以使用，而不是简化，所以尽量明智地使用滑块。
- en: Filtering images
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像过滤
- en: It really doesn't matter whether you are trying to build a computer vision application
    to perform highly complex tasks, such as object detection in real-time, or simply
    modifying an input image in one way or another. Almost inevitably, you'll have
    to apply a certain type of filter to your input or output images. The reason for
    this is quite simple—not all pictures are ready to be processed out of the box,
    and most of the time, applying filters to make images smoother is one of the ways
    to make sure they can be fed into our algorithms.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在尝试构建一个执行高度复杂任务的计算机视觉应用程序，比如实时目标检测，还是简单地以某种方式修改输入图像，这真的并不重要。几乎不可避免的是，你将不得不应用某种类型的滤波器到你的输入或输出图像上。原因很简单——并不是所有的图片都准备好直接进行处理，大多数时候，应用滤波器使图像更平滑是确保它们可以被我们的算法处理的一种方式。
- en: The variety of filters that you can apply to your images in computer vision
    is huge, but in this section, we're going to be learning about some of the most
    important filters and especially the ones with an implementation in the OpenCV
    library that we can use.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉中，你可以应用到图像上的滤波器种类繁多，但在这个章节中，我们将学习一些最重要的滤波器，特别是那些在OpenCV库中有实现，我们可以使用的滤波器。
- en: Blurring/smoothening filters
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊/平滑滤波器
- en: Blurring an image is one of the most important image filtering tasks, and there
    are many algorithms that can perform it, each one with their own pros and cons,
    which we'll be talking about in this section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊图像是图像滤波任务中最重要的一项，有许多算法可以执行这项任务，每个算法都有其自身的优缺点，我们将在本节中讨论这些内容。
- en: 'Let''s start with the simplest filter used for smoothening images, which is
    called the median filter, and it can be done by using the `medianBlur` function,
    as seen in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用于平滑图像的最简单的滤波器开始，这个滤波器被称为中值滤波器，可以通过使用`medianBlur`函数来实现，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This filter simply finds the median value of the neighboring pixels of each
    pixel in an image. `ksize`, or the kernel size parameter, decides how big the
    kernel used for blurring is, or, in other words, how far the neighboring pixels
    will be considered in the blurring algorithm. The following image depicts the
    result of increasing the kernel size from 1 to 7:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此滤波器简单地找到图像中每个像素的邻近像素的中值。`ksize`，或核大小参数，决定了用于模糊的核的大小，换句话说，决定了在模糊算法中考虑邻近像素的距离。以下图像展示了从1到7增加核大小的结果：
- en: '![](img/00040.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.jpeg)'
- en: Note that the kernel size must be an odd value, and a kernel size of 1 will
    produce the exact same image as the input. So, in the previous images, you can
    see the increase in blurring level from the original image (the leftmost) until
    the kernel size of 7.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，核大小必须是奇数，核大小为1将产生与输入图像完全相同的图像。因此，在之前的图像中，你可以看到从原始图像（最左侧）到核大小为7的模糊级别的增加。
- en: 'Note that you can use extremely high kernel sizes if you need, but it is rarely
    necessary and would usually be needed in case you need to de-noise an extremely
    noisy image. Here''s an example image depicting the result of a kernel size of
    21:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你需要，可以使用非常高的核大小，但这通常是不必要的，通常只有在需要去除极其嘈杂的图像的噪声时才需要。以下是一个核大小为21的示例图像，展示了其结果：
- en: '![](img/00041.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00041.jpeg)'
- en: 'Another method of blurring an image is by using the `boxFilter` function. Let''s
    see how it''s done with an example code and then break it down further to better
    understand its behavior:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种模糊图像的方法是使用`boxFilter`函数。让我们通过一个示例代码来看看它是如何实现的，然后进一步分解以更好地理解其行为：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Box filtering is referred to as a blurring method in which a matrix of ones
    with the given `ksize` and `anchor` point is used for blurring an image. The major
    difference here, when compared with the `medianBlur` function, is that you can
    actually define the `anchor` point to be anything other than the center point
    in any neighborhood. You can also define the border type used in this function,
    whereas in the `medianBlur` function, `BORDER_REPLICATE` is used internally and
    cannot be changed. For more information about border types, you might want to
    refer to [Chapter 3](part0048.html#1DOR00-15c05657f8254d318ea883ef10fc67f4), *Array
    and Matrix Operations*. Finally, the `normalize` parameter allows us to normalize
    the result to the displayable result.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 箱形滤波器被称为一种模糊方法，其中使用给定 `ksize` 和 `anchor` 点的 1 的矩阵进行图像模糊。与 `medianBlur` 函数相比，主要区别在于您实际上可以定义
    `anchor` 点为任何非中心点的任何邻域。您还可以定义在此函数中使用的边界类型，而在 `medianBlur` 函数中，内部使用 `BORDER_REPLICATE`
    并不能更改。有关边界类型的更多信息，您可能需要参考第 3 章，*数组和矩阵操作*。最后，`normalize` 参数允许我们将结果归一化到可显示的结果。
- en: The `ddepth` parameter can be used to change the depth of the result. However,
    you can use -1 to make sure the result has the same depth as the source. Similarly,
    `anchor` can be supplied with -1 values to make sure the default anchor point
    is used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `ddepth` 参数来更改结果的深度。然而，您可以使用 -1 来确保结果具有与源相同的深度。同样，可以提供 -1 值给 `anchor` 以确保使用默认的锚点。
- en: 'The following image depicts the result of the previous example code. The image
    on the right is the box-filtered result of the image on the left-hand side:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像展示了前面示例代码的结果。右侧图像是左侧图像经过箱形滤波后的结果：
- en: '![](img/00042.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: 'We can perform the exact same task, in other words, the normalized box filter,
    by using the `blur` function, as seen in the following example code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `blur` 函数执行完全相同的任务，换句话说，就是归一化箱形滤波器，如下面的示例代码所示：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result of this sample code is exactly the same as calling `boxFilter`, as
    we saw previously. The obvious difference here is that this function does not
    allow us to change the depth of the result and applies normalization by default.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例代码的结果与之前看到的调用 `boxFilter` 的结果完全相同。这里明显的区别是，此函数不允许我们更改结果的深度，并且默认应用归一化。
- en: 'In addition to the standard box filter, you can also apply a square box filter
    with the `sqrBoxFilter` function. In this method, instead of calculating the sum
    of the neighboring pixels, the sum of their square values is calculated. Here
    is an example, which is incredibly similar to calling the `boxFilter` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的箱形滤波器外，您还可以使用 `sqrBoxFilter` 函数应用平方箱形滤波器。在此方法中，不是计算邻近像素的总和，而是计算它们平方的总和。以下是一个示例，与调用
    `boxFilter` 函数非常相似：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The unnormalized versions of the `boxFilter` and `sqrBoxFilter` functions can
    also be used to find statistical information about the neighboring areas of all
    pixels in an image, and their use case is not limited to just blurring an image.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`boxFilter` 和 `sqrBoxFilter` 函数的非归一化版本也可以用来获取图像中所有像素邻近区域的统计信息，它们的使用场景并不仅限于图像模糊。'
- en: 'One of the most popular blurring methods in computer vision is the **Gaussian
    blur** algorithm, and it can be performed in OpenCV by using the `GaussianBlur`
    function. This function, similar to the previous blur functions that we learned
    about, requires a kernel size, along with standard deviation values in the *X*
    and *Y* direction, called `sigmaX` and `sigmaY`, respectively. Here''s an example
    of how this function is used:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉中最受欢迎的模糊方法之一是 **高斯模糊** 算法，在 OpenCV 中可以通过使用 `GaussianBlur` 函数来实现。这个函数与之前我们了解过的模糊函数类似，需要指定核大小，以及
    *X* 和 *Y* 方向上的标准差值，分别称为 `sigmaX` 和 `sigmaY`。以下是如何使用此函数的示例：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that a value of zero for `sigmaY` means the value of `sigmaX` will also
    be used in the *Y* direction. For more information about Gaussian blur, you can
    read about the Gaussian function in general and the `GaussianBlur` function in
    the OpenCV documentation pages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sigmaY` 的值为零意味着 `sigmaX` 的值也将用于 *Y* 方向。有关高斯模糊的更多信息，您可以阅读关于高斯函数的一般信息和 OpenCV
    文档页面中的 `GaussianBlur` 函数。
- en: 'The last smoothening filter that we''ll learn about in this section is called
    the **bilateral filter**, and it can be achieved by using the `bilateralFilter`
    function. Bilateral filtering is a powerful method of de-noising and smoothening
    an image, while preserving edges. This function is also much slower and more CPU-intensive
    in comparison with the blur algorithms that we saw previously. Let''s see how
    `bilateralFilter` is used with an example and then break down the required parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将学习的最后一个平滑滤波器称为**双边滤波器**，可以通过使用`bilateralFilter`函数实现。双边滤波是一种强大的去噪和图像平滑方法，同时保留边缘。与之前看到的模糊算法相比，此函数也慢得多，CPU密集度更高。让我们通过一个例子来看看如何使用`bilateralFilter`，然后分解所需的参数：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`d`, or the filter size, is the diameter of the pixel neighborhood that will
    participate in the filter. The `sigmaColor` and `sigmaSpace` values are both used
    to define the effect of the color and coordinate the pixels nearer or farther
    from the pixel whose filtered value is being calculated. Here''s a screenshot
    that demonstrates the effect of the `bilateralFilter` function when executed on
    our example image:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`d`，或过滤器大小，是参与过滤的像素邻域的直径。`sigmaColor`和`sigmaSpace`值都用于定义颜色效果并协调计算过滤值像素的颜色和坐标。以下是演示`bilateralFilter`函数在我们示例图像上执行效果的截图：'
- en: '![](img/00043.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: Morphological filters
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态学滤波器
- en: Similar to smoothening filters, morphology filters are the algorithms that change
    the value of each pixel based on the value of the neighboring pixels, although
    the obvious difference is that they do not have a blurring effect and are mostly
    used to produce some form of erosion or dilation effect on images. This will be
    clarified with a few hands-on examples further in this section, but for now, let's
    see how morphological operations (also called **transformations**) are performed
    using OpenCV functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与平滑滤波器类似，形态学滤波器是改变每个像素值基于相邻像素值的算法，尽管明显的区别是它们没有模糊效果，并且主要用于在图像上产生某种形式的侵蚀或膨胀效果。这将在本节后面的几个动手示例中进一步阐明，但现在，让我们看看如何使用OpenCV函数执行形态学操作（也称为**变换**）。
- en: 'You can use the `morphologyEx` function to perform morphological operations
    on images. This function can be provided with an entry from the `MorphTypes` enum
    to specify the morphological operation. Here are the values that can be used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`morphologyEx`函数对图像执行形态学操作。此函数可以提供一个来自`MorphTypes`枚举的条目来指定形态学操作。以下是可用的值：
- en: '`MORPH_ERODE`: For erosion operation'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_ERODE`：用于侵蚀操作'
- en: '`MORPH_DILATE`: For dilation operation'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_DILATE`：用于膨胀操作'
- en: '`MORPH_OPEN`: For opening operation, or the dilation of eroded images'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_OPEN`：用于开运算，或侵蚀图像的膨胀'
- en: '`MORPH_CLOSE`: For closing operation, or the erosion of dilated images'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_CLOSE`：用于闭运算，或从膨胀图像中侵蚀'
- en: '`MORPH_GRADIENT`: For morphological gradient operation, or subtraction of the
    eroded image from the dilated image'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_GRADIENT`：用于形态学梯度操作，或从膨胀图像中减去侵蚀图像'
- en: '`MORPH_TOPHAT`: For Top-hat operation, or subtraction of the opening operation
    result from the source image'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_TOPHAT`：用于顶帽操作，或从源图像中减去开运算的结果'
- en: '`MORPH_BLACKHAT`: For Black-hat operation, or subtraction of the source image
    from the result of the closing operation'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MORPH_BLACKHAT`：用于黑帽操作，或从闭运算的结果中减去源图像'
- en: 'To understand all of the possible morphological operations mentioned in the
    previous list, it''s important to first understand the effect of erosion and dilation
    (the first two entries in the list) since the rest are simply different combinations
    of these two morphological operations. Let''s first try erosion with an example
    and, at the same time, learn how the `morphologyEx` function is used:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解前面列表中提到的所有可能的形态学操作，首先理解侵蚀和膨胀（列表中的前两项）的效果是很重要的，因为其余的只是这两种形态学操作的组合。让我们先通过一个例子来尝试侵蚀，同时学习如何使用`morphologyEx`函数：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`op`, or the operation, is an entry from the `MorphTypes` enum, as mentioned
    before. `kernel`, or the structuring element, is the kernel matrix used for the
    morphological operation, which itself is either created manually or by using the `getStructuringElement`
    function. You must provide the `getStructuringElement` with a `shape` morph, kernel
    size (`ksize`), and `anchor`. `shape` can be a rectangle, cross, or ellipse, and
    is simply an entry from the `MorphShapes` enum. The `iterations` variable refers
    to the number of times the morphological operation is performed on an image. `borderType`
    is interpreted exactly the same way as with all the functions we''ve seen so far
    for the extrapolation of pixels. In case a constant border type value is used,
    the `morphologyEx` function must also be provided with a border value, which can
    be retrieved by using the `morphologyDefaultBorderValue` function, or specified
    manually.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`op`，或操作，是前面提到的`MorphTypes`枚举中的一个条目。`kernel`，或结构元素，是用于形态学操作的核矩阵，它可以是手动创建的，也可以通过使用`getStructuringElement`函数创建。你必须为`getStructuringElement`提供`shape`形态、核大小（`ksize`）和`anchor`。`shape`可以是矩形、十字或椭圆，它只是`MorphShapes`枚举中的一个条目。`iterations`变量指的是形态学操作在图像上执行次数。`borderType`的解释方式与迄今为止我们看到的用于像素外推的所有函数完全相同。如果使用常量边界类型值，则`morphologyEx`函数还必须提供边界值，该值可以通过使用`morphologyDefaultBorderValue`函数检索，或手动指定。'
- en: 'Here is the result of our preceding code (for erosion), when executed on our
    sample image:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的先前代码（用于腐蚀）在示例图像上执行的结果：
- en: '![](img/00044.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: 'Dilation, on the other hand, is performed by simply replacing the `op` value
    with `MORPH_DILATE` in the previous example. Here''s the result of the dilation
    operation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，膨胀操作是通过在前面示例中将`op`值替换为`MORPH_DILATE`来执行的。以下是膨胀操作的结果：
- en: '![](img/00045.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: A highly simplified description of what erosion and dilation operations do is
    that they cause the neighboring pixels of darker pixels to become darker (in case
    of erosion) or the neighboring pixels of brighter pixels to become brighter (in
    case of dilations), which, after more iterations, will cause a stronger and easily
    visible effect.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对腐蚀和膨胀操作的高度简化描述是，它们会导致较暗像素的邻近像素变得更暗（在腐蚀的情况下）或较亮像素的邻近像素变得更亮（在膨胀的情况下），经过更多迭代后，这将导致更强烈且易于观察的效果。
- en: 'As was mentioned before, all of the other morphological operations are simply
    a combination of erosion and dilation. Here are the results of opening and closing
    operations when they are executed on our example images:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有其他形态学操作都是腐蚀和膨胀的组合。以下是当我们对示例图像执行开闭操作时的结果：
- en: '![](img/00046.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: Make sure you try the rest of the morphological operations by yourself to see
    their effects. Create user interfaces that have trackbars on them and try changing
    the value of `iteration` and other parameters to see how they affect the result
    of morphological operations. If used carefully and wisely, morphological operations
    can have very interesting results and further simplify an operation that you want
    to perform on an image.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你自己尝试其余的形态学操作，以查看它们的效果。创建具有滑块的图形用户界面，并尝试更改`iteration`和其他参数的值，以查看它们如何影响形态学操作的结果。如果使用得当，形态学操作可以产生非常有趣的结果，并进一步简化你想要在图像上执行的操作。
- en: Before proceeding to the next section, it is worth noting that you can also
    use the `erode` and `dilate` functions to perform exactly the same operation.
    Although these functions do not require an operation parameter (since the operation
    is in their name already), the rest of the parameters are exactly the same as
    with the `morphologyEx` function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，值得注意的是，你也可以使用`erode`和`dilate`函数执行完全相同的操作。尽管这些函数不需要操作参数（因为操作已经在它们的名称中），但其余的参数与`morphologyEx`函数完全相同。
- en: Derivative-based filters
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于导数的过滤器
- en: In this section, we're going to learn about filtering algorithms that are based
    on calculating and using the derivatives of an image. To understand the concept
    of derivatives in an image, you can recall the fact that images are matrices,
    so you can calculate the derivatives (of any order) in *X* or *Y* directions,
    for instance, which, in the simplest case, would be the same as finding the change
    across the pixels in a direction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习基于计算和使用图像导数的滤波算法。为了理解图像中导数的概念，您可以回忆一下事实，即图像是矩阵，因此您可以在`X`或`Y`方向上计算（任何阶数）的导数，例如，在最简单的情况下，这相当于在某个方向上寻找像素的变化。
- en: 'Let''s start with the `Sobel` function, which is used to calculate the derivative
    of an image using a `Sobel` operator. Here''s how this function is used in practice:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Sobel`函数开始，该函数用于通过`Sobel`算子计算图像的导数。以下是这个函数在实际中的应用方法：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`ddepth`, similar to what we saw in previous examples throughout this chapter,
    is used to define the depth of the output, and using `-1` makes sure the result
    has the same depth as the input. `dx` and `dy` are used to set the order of the
    derivative in both the *X* and *Y* directions. `ksize` is the size of the `Sobel`
    operator, which can be 1, 3, 5, or 7\. `scale` is used as the `scale` factor for
    the result, and delta is added to the `result`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ddepth`，类似于在本章中之前示例中看到的，用于定义输出深度，使用`-1`确保结果具有与输入相同的深度。`dx`和`dy`用于设置`X`和`Y`方向上导数的阶数。`ksize`是`Sobel`算子的大小，可以是1、3、5或7。`scale`用作结果的缩放因子，`delta`被加到结果上。'
- en: 'The following images depict the result of the `Sobel` function when called
    with the parameter values from the preceding example code, but for a `delta` value
    of zero (on the left) and 255 (on the right):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用前一个示例代码中的参数值调用`Sobel`函数的结果，但`delta`值为零（左侧）和255（右侧）：
- en: '![](img/00047.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: Try setting different `delta` and `scale` values and experiment with the results.
    Also try different derivative orders and see the effects for yourself. As you
    can see from the preceding output images, calculating the derivative of an image
    is a method for calculating the edges in an image.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试设置不同的`delta`和`scale`值，并实验结果。还可以尝试不同的导数阶数，亲自看看效果。正如您从前面的输出图像中可以看到，计算图像的导数是计算图像边缘的一种方法。
- en: 'You can also use the `spatialGradient` function to calculate the first-order
    derivative of an image in both the *X* and *Y* directions using the `Sobel` operator,
    at the same time. In other words, calling `spatialGradient` once is like calling
    the `Sobel` function twice, for the first-order derivative in both directions.
    Here''s an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`spatialGradient`函数，同时使用`Sobel`算子，在`X`和`Y`方向上计算图像的一阶导数。换句话说，调用一次`spatialGradient`相当于调用两次`Sobel`函数，用于两个方向的一阶导数。以下是一个示例：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the `ksize` parameter must be `3` and the input image type must be
    grayscale, otherwise this function will fail to execute, although this might change
    in an upcoming OpenCV version.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ksize`参数必须是`3`，输入图像类型必须是灰度图，否则此函数将无法执行，尽管这可能在即将到来的OpenCV版本中有所改变。
- en: 'Similar to the way we used the `Sobel` function, you can use the `Laplacian`
    function to calculate the Laplacian of an image. It''s important to note that
    this function essentially sums up the second derivatives in the *X* and *Y* directions
    calculated using the `Sobel` operator. Here''s an example that demonstrates the
    usage of the `Laplacian` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用`Sobel`函数的方式类似，您可以使用`Laplacian`函数来计算图像的拉普拉斯。重要的是要注意，此函数本质上是对使用`Sobel`算子计算的`X`和`Y`方向的二阶导数求和。以下是一个演示`Laplacian`函数用法的示例：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: All of the parameters used in the `Laplacian` function are already described
    in previous examples, and especially the `Sobel` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Laplacian`函数中使用的所有参数已在之前的示例中描述，特别是`Sobel`函数。
- en: Arbitrary filtering
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任意滤波
- en: 'OpenCV supports the application of arbitrary filters on images by using the
    `filter2D` function. This function is capable of creating the result of many algorithms
    we already learned, but it requires a `kernel` matrix to be provided. This function
    simply convolves the whole image with the given `kernel` matrix. Here''s an example
    of applying an arbitrary filter on an image:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV通过使用`filter2D`函数支持在图像上应用任意滤波器。此函数能够创建我们之前学习到的许多算法的结果，但它需要一个`kernel`矩阵来提供。此函数只是将整个图像与给定的`kernel`矩阵进行卷积。以下是在图像上应用任意滤波器的示例：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the result of this arbitrary filter. You can see the original image
    on the left, and the result of the filtering operation on the right-hand side:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这种任意滤波器的结果。你可以看到左侧的原始图像和右侧的滤波操作结果：
- en: '![](img/00048.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00048.jpeg)'
- en: There is absolutely no limit to the number of possible filters you can create
    and use using the `filter2D` function. Make sure you try different kernel matrices
    and experiment with the `filter2D` function. You can also search online for popular
    filter kernel matrices and apply them using the `filter2D` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter2D`函数可以创建和使用的可能过滤器数量绝对没有限制。确保你尝试不同的核矩阵，并使用`filter2D`函数进行实验。你还可以在网上搜索流行的滤波核矩阵，并使用`filter2D`函数应用它们。
- en: Transforming images
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像变换
- en: In this section, we'll learn about computer vision algorithms that are used
    to transform images in one way or another. The algorithms that we'll be learning
    in this section cover algorithms that change the content of an image, or the way
    its contents is interpreted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习用于以某种方式变换图像的计算机视觉算法。本节中我们将学习的算法包括改变图像内容或其内容解释方式的算法。
- en: Thresholding algorithms
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阈值算法
- en: Thresholding algorithms are used to apply a threshold value to the pixels of
    an image. These algorithms can be used to effectively create masks from images
    that have possible regions or pixels of interest in them that pass a certain threshold
    value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值算法用于将阈值值应用于图像的像素。这些算法可以用来有效地从包含可能区域或感兴趣像素且通过一定阈值值的图像中创建掩码。
- en: 'You can use the `threshold` function to apply a threshold value on all pixels
    of an image. The `threshold` function must be provided with the type of threshold
    that is desired, and it can be an entry from the `ThresholdTypes` enum. The following
    is an example that can be used to find the brightest areas in an image using the
    `threshold` function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`threshold`函数将阈值值应用于图像的所有像素。`threshold`函数必须提供所需的阈值类型，并且它可以是`ThresholdTypes`枚举中的一个条目。以下是一个示例，说明如何使用`threshold`函数找到图像中最亮的部分：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`thresh` is the minimum threshold value, and `maxval` is the maximum allowed
    value. Simply put, all pixel values between `thresh` and `maxval` are allowed
    to pass and so the `result` is created. The following is the result of the preceding
    `threshold` operation demonstrated with an example image:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`thresh`是最低阈值值，而`maxval`是允许的最大值。简单来说，介于`thresh`和`maxval`之间的所有像素值都被允许通过，从而创建出`result`。以下是一个使用示例图像演示的先前`threshold`操作的结果：'
- en: '![](img/00049.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00049.jpeg)'
- en: Increase the `thresh` parameter (or the threshold value) and you'll notice that
    fewer pixels are allowed to pass. Setting a correct threshold value requires experience
    and knowledge about the scene. In some cases, however, you can develop programs
    that set the threshold automatically for you, or adaptively. Note that the threshold
    type completely affects the result of the `threshold` function. For instance,
    `THRESH_BINARY_INV` will produce the inverted result of `THRESH_BINARY` and so
    on. Make sure to try different threshold types and experiment for yourself with
    this interesting and powerful function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 增加阈值参数（或阈值值），你会注意到允许通过的像素更少。设置正确的阈值值需要经验和关于场景的知识。然而，在某些情况下，你可以开发出自动设置阈值或自适应阈值的程序。请注意，阈值类型完全影响`threshold`函数的结果。例如，`THRESH_BINARY_INV`将产生`THRESH_BINARY`的逆结果，依此类推。确保尝试不同的阈值类型，并亲自实验这个有趣且强大的函数。
- en: 'Another, more sophisticated, way of applying thresholds to images is by using
    the `adaptiveThreshold` function, which works with grayscale images. This function
    assigns the given `maxValue` parameter to the pixels that pass the threshold criteria.
    Besides that, you must provide a threshold type, an adaptive `threshold` method,
    a block size defining the diameter in the pixel neighborhood, and a constant value
    that is subtracted from the mean (depending on the adaptive `threshold` method).
    Here is an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更复杂地将阈值应用于图像的方法是使用`adaptiveThreshold`函数，该函数与灰度图像一起工作。此函数将给定的`maxValue`参数分配给通过阈值标准的像素。除此之外，你必须提供一个阈值类型、自适应的阈值方法、定义像素邻域直径的块大小，以及从平均值中减去的常数值（取决于自适应阈值方法）。以下是一个示例：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that `adaptiveMethod` can take any of the following examples:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`adaptiveMethod`可以采用以下任何示例：
- en: '`ADAPTIVE_THRESH_MEAN_C`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADAPTIVE_THRESH_MEAN_C`'
- en: '`ADAPTIVE_THRESH_GAUSSIAN_C`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADAPTIVE_THRESH_GAUSSIAN_C`'
- en: 'The higher the `blockSize` parameter value, the more pixels are used in the
    adaptive `threshold` method. The following is an example image that depicts the
    result of the `adaptiveThreshold` method called with the values in the preceding
    example code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockSize`参数值越高，自适应`threshold`方法中使用的像素就越多。以下是一个示例图像，展示了使用前面示例代码中的值调用`adaptiveThreshold`方法的结果：'
- en: '![](img/00050.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: Color space and type conversion
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色空间和类型转换
- en: Converting various color spaces and types to each other is extremely important,
    especially when it comes to dealing with images from different device types or
    intending to display them on different devices and formats. Let's see what this
    means with a very simple example. You'll need grayscale images for various OpenCV
    functions and computer vision algorithms, while some will require RGB color images.
    In such cases, you can use the `cvtColor` function to convert between various
    color spaces and formats.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将各种颜色空间和类型相互转换非常重要，尤其是在处理来自不同设备类型或打算在不同设备和格式上显示的图像时。让我们用一个非常简单的例子来看看这意味着什么。您将需要用于各种OpenCV函数和计算机视觉算法的灰度图像，而有些则需要RGB颜色图像。在这种情况下，您可以使用`cvtColor`函数在各个颜色空间和格式之间进行转换。
- en: 'The following is an example that converts a color image to grayscale:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将彩色图像转换为灰度的示例：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`code` can take a conversion code, which must be an entry from the `ColorConversionCodes`
    enum. The following are some examples of the most popular color-conversion codes,
    that can be used with the `cvtColor` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`code`可以接受一个转换代码，该代码必须是`ColorConversionCodes`枚举中的一个条目。以下是一些最流行的颜色转换代码的示例，这些代码可以与`cvtColor`函数一起使用：'
- en: '`COLOR_BGR2RGB`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COLOR_BGR2RGB`'
- en: '`COLOR_RGB2GRAY`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COLOR_RGB2GRAY`'
- en: '`COLOR_BGR2HSV`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COLOR_BGR2HSV`'
- en: The list goes on and on. Make sure to check the `ColorConversionCodes` enum
    for all possible color-conversion codes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以一直继续。请确保查看`ColorConversionCodes`枚举以获取所有可能的颜色转换代码。
- en: Geometric transformation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何变换
- en: This section is dedicated to geometric transformation algorithms and OpenCV
    functions. It's important to note that the name, Geometric transformation, is
    based on the fact that the algorithms falling in this category do not change the
    content of an image, they simply deform the existing pixels, while using an extrapolation
    and interpolation method to calculate the pixels that fall outside the area of
    the existing pixels, or over each other, respectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本节专门介绍几何变换算法和OpenCV函数。需要注意的是，几何变换这一名称是基于以下事实：属于这一类别的算法不会改变图像的内容，它们只是变形现有的像素，同时使用外推和内插方法来计算位于现有像素区域之外或重叠的像素。
- en: 'Let''s start with the simplest geometric transformation algorithm, which is
    used for resizing an image. You can use the `resize` function to resize an image.
    Here is how this function is used:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的几何变换算法开始，该算法用于调整图像大小。您可以使用`resize`函数调整图像大小。以下是此函数的使用方法：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the `dsize` parameter is set to a non-zero size, the `fx` and `fy` parameters
    are used to scale the input image. Otherwise, if `fx` and `fy` are both zero,
    the input image is resized to the given `dsize`. The `interpolation` parameter,
    on the other hand, is used to set the `interpolation` method used for the resize
    algorithm, and it must be one of the entries in the `InterpolationFlags` enum.
    Here are some of the possible values for the `interpolation` parameter:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dsize`参数设置为非零大小，则`fx`和`fy`参数用于缩放输入图像。否则，如果`fx`和`fy`都为零，则输入图像的大小调整为给定的`dsize`。另一方面，`interpolation`参数用于设置用于缩放算法的`interpolation`方法，并且它必须是`InterpolationFlags`枚举中的条目之一。以下是`interpolation`参数的一些可能值：
- en: '`INTER_NEAREST`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTER_NEAREST`'
- en: '`INTER_LINEAR`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTER_LINEAR`'
- en: '`INTER_CUBIC`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTER_CUBIC`'
- en: '`INTER_AREA`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTER_AREA`'
- en: '`INTER_LANCZOS4`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTER_LANCZOS4`'
- en: Make sure to check out the OpenCV documentation pages for `InterpolationFlags`
    to find out about the details of each possible method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保查看OpenCV文档中的`InterpolationFlags`页面，以了解每种可能方法的详细信息。
- en: 'The following image depicts the result of the previous example code that was
    used for resizing an image:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了用于调整图像大小的先前示例代码的结果：
- en: '![](img/00051.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: Probably the most important geometric transformation algorithm, which is able
    to perform most of the other geometric transformations, is the remapping algorithm,
    and it can be achieved by calling the `remap` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是最重要的几何变换算法，它能够执行大多数其他几何变换，这就是重映射算法，可以通过调用`remap`函数来实现。
- en: 'The `remap` function must be provided with two mapping matrices, one for *X*
    and another one for the *Y* direction. Besides that, an interpolation and extrapolation
    (border type) method, along with a border value in case of constant border type,
    must be provided to the `remap` function. Let''s first see how this function is
    called and then try a couple of different remaps. Here''s an example that shows
    how the `remap` function is called:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`remap`函数必须提供两个映射矩阵，一个用于*X*方向，另一个用于*Y*方向。除此之外，还必须向`remap`函数提供一种插值和外推（边界类型）方法，以及在恒定边界类型的情况下，提供一个边界值。让我们首先看看这个函数是如何调用的，然后尝试几种不同的映射。以下是一个示例，展示了如何调用`remap`函数：'
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can create an infinite number of different mappings and use them with the `remap`
    function to resize, flip, warp, and do many other transformations on images. For
    instance, the following code can be used to create a remapping that will cause
    a vertical flip of the resulting image:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建无限数量的不同映射，并使用`remap`函数来调整图像大小、翻转、扭曲以及进行许多其他变换。例如，以下代码可以用来创建一个映射，这将导致输出图像进行垂直翻转：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Replace the code in the preceding `for` loop with the following and the result
    of the `remap` function call will be a horizontally flipped image:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将前一个`for`循环中的代码替换为以下代码，`remap`函数调用的结果将是一个水平翻转的图像：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Besides simple flipping, you can use the `remap` function to perform many interesting
    pixel deformations. Here''s an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的翻转之外，你还可以使用`remap`函数执行许多有趣的像素变形。以下是一个示例：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As can be seen from the inline comments of the preceding example code, it is
    common to convert the OpenCV `i` and `j` values (row and column number) to a standard
    coordinate system and use *X* and *Y* with known mathematical and geometrical
    functions, and then convert them back to the OpenCV image coordinates. The following
    image demonstrates the result of the preceding example code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例代码的行内注释所示，将OpenCV的`i`和`j`值（行和列号）转换为标准坐标系，并使用*X*和*Y*与已知的数学和几何函数一起使用，然后再将它们转换回OpenCV图像坐标，这是常见的做法。以下图像展示了前一个示例代码的结果：
- en: '![](img/00052.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: The `remap` function is incredibly powerful and efficient as long as the calculation
    of `mapX` and `mapY` are handled efficiently. Make sure to experiment with this
    function to learn about more remapping possibilities.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`mapX`和`mapY`的计算效率高，`remap`函数就非常强大且高效。请确保尝试这个函数，以了解更多的映射可能性。
- en: There are a huge number of geometric transformation algorithms in computer vision
    and in the OpenCV library, and covering all of them would need a book of its own.
    So, we'll leave the rest of the geometric transformation algorithms for you to
    explore and try on your own. Refer to the *Geometric Image Transformations* section
    in the OpenCV `imgproc` (Image Processing) module documentation for more geometric
    transformation algorithms and functions. In particular, make sure to learn about
    functions including `getPerspectiveTransform` and `getAffineTransform`, which
    are used to find the perspective and affine transformation between two sets of
    points. Such functions return transformation matrices that can be used to apply
    perspective and affine transformation to images by using the `warpPerspective`
    and `warpAffine` functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉和OpenCV库中有大量的几何变换算法，要涵盖所有这些算法需要一本自己的书。因此，我们将剩下的几何变换算法留给你去探索和尝试。请参考OpenCV
    `imgproc`（图像处理）模块文档中的*几何图像变换*部分，以获取更多几何变换算法和函数。特别是，请确保了解包括`getPerspectiveTransform`和`getAffineTransform`在内的函数，这些函数用于找到两组点之间的透视和仿射变换。这些函数返回的变换矩阵可以用于通过使用`warpPerspective`和`warpAffine`函数来应用透视和仿射变换到图像上。
- en: Applying colormaps
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用颜色图
- en: We'll end this chapter by learning about applying colormaps to images. This
    is a fairly simple but powerful method that can be used to modify the colors of
    an image or its tone in general. This algorithm simply replaces the colors of
    an input image using a colormap and creates a result. A **colormap** is a 256-element
    array of color values, in which each element represents the color that must be
    used for the corresponding pixel values in the source image. We will break this
    down further with a couple of examples, but before that, let's see how colormaps
    are applied to images.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过学习将色图应用于图像来结束本章。这是一个相当简单但功能强大的方法，可以用来修改图像的颜色或其总体色调。该算法简单地使用色图替换输入图像的颜色并创建一个结果。**色图**是一个包含256个颜色值的数组，其中每个元素代表源图像中相应像素值必须使用的颜色。我们将通过几个示例进一步解释，但在那之前，让我们看看色图是如何应用于图像的。
- en: 'OpenCV contains a function named `applyColorMap` that can be used to either
    apply predefined colormaps or custom ones created by the user. In case predefined
    colormaps are used, `applyColorMap` must be provided with a colormap type, which
    must be an entry from the `ColormapTypes` enum. Here''s an example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV包含一个名为`applyColorMap`的函数，可以用来应用预定义的色图或用户创建的自定义色图。如果使用预定义的色图，`applyColorMap`必须提供一个色图类型，这必须是`ColormapTypes`枚举中的一个条目。以下是一个示例：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following image depicts the result of various predefined colormaps that
    can be applied using the `applyColorMap` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像展示了可以使用`applyColorMap`函数应用的各种预定义色图的结果：
- en: '![](img/00053.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: 'As mentioned earlier, you can also create your own custom colormaps. You just
    need to make sure you follow the instructions for creating a colormap. Your colormap
    must have a size of `256` elements (a `Mat` object with `256` rows and `1` column)
    and it must contain color or grayscale values, depending on the type of image
    you are planning to apply the colormap to. The following is an example that shows
    how to create a custom colormap by simply inverting the green channel color:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你还可以创建自己的自定义色图。你只需确保遵循创建色图的说明。你的色图必须包含256个元素的大小（一个具有256行和1列的`Mat`对象）并且它必须包含颜色或灰度值，具体取决于你打算将色图应用于哪种类型的图像。以下是一个示例，展示了如何通过简单地反转绿色通道颜色来创建自定义色图：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is the result of the preceding example code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面示例代码的结果：
- en: '![](img/00054.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Even though we tried to cover the most important topics of image-processing
    algorithms in computer vision, we still have a long way to go and many more algorithms
    to learn. The reason is quite simple, and that is the variety of applications
    that these algorithms can be used for. We learned a great deal of widely used
    computer vision algorithms in this chapter, but it should also be noted that whatever
    we learned in this chapter is also meant to ease your way when you start exploring
    the rest of the image-processing algorithms by yourself.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们试图涵盖计算机视觉中图像处理算法的最重要主题，但我们还有很长的路要走，还有更多的算法要学习。原因很简单，那就是这些算法可以用于各种应用。在本章中，我们学习了大量的广泛使用的计算机视觉算法，但还应注意的是，本章中我们所学的内容也是为了在你开始自己探索其他图像处理算法时能更容易一些。
- en: 'We started this chapter by learning about drawing functions that can be used
    to draw shapes and text on images. Then we moved on to learn about one of the
    most important computer vision topics: image filtering. We learned how to use
    smoothening algorithms, we experimented with morphological filters, and learned
    about erosion, dilation, opening, and closing. We also got to try some simple
    edge detection algorithms, or, in other words, derivative-based filters. We learned
    about thresholding images and changing their color spaces and types. The final
    sections of this chapter introduced us to geometric transformations and applying
    colormaps on images. We even created a custom colormap of our own. You can easily
    find the trace of the algorithms that we learned in this chapter, in many professional
    photo-editing or social-networking and photo-sharing applications.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习可以用于在图像上绘制形状和文本的绘图函数开始本章。然后我们转向学习最重要的计算机视觉主题之一：图像滤波。我们学习了如何使用平滑算法，实验了形态学滤波器，并了解了腐蚀、膨胀、开运算和闭运算。我们还尝试了一些简单的边缘检测算法，换句话说，基于导数的滤波器。我们学习了图像阈值处理和改变它们的颜色空间和类型。本章的最后部分介绍了几何变换和将颜色图应用于图像。我们甚至创建了自己的自定义颜色图。你可以在许多专业照片编辑或社交网络和照片共享应用中轻松找到我们在这章中学到的算法的痕迹。
- en: In the next chapter, we'll learn all about histograms, how they are calculated,
    and how they are used in computer vision. We'll cover the algorithms that are
    crucial when working on certain object detection and tracking algorithms that
    we'll be exploring in the upcoming chapters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习所有关于直方图的内容，包括它们的计算方式以及它们在计算机视觉中的应用。我们将涵盖在即将到来的章节中探索的某些对象检测和跟踪算法中至关重要的算法。
- en: Questions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Write a program that draws a cross mark over the whole image, with a thickness
    of 3 pixels and in the color red.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，在整张图像上绘制一个红色、3像素粗的十字标记。
- en: Create a window with a trackbar to change the `ksize` of a `medianBlur` function.
    The possible range for the `kszise` value should be between 3 and 99.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有滑块的窗口，用于更改`medianBlur`函数的`ksize`值。`kszise`值的可能范围应在3到99之间。
- en: Perform a gradient morphological operation on an image, considering a kernel
    size of 7 and a rectangular  morphological shape for the structuring element.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对图像执行梯度形态学操作，考虑结构元素的核大小为7，矩形形态学形状。
- en: Using `cvtColor`, convert a color image to grayscale and make sure only the
    darkest 100 shades of gray are filtered out using the `threshold` function. Make
    sure that filtered pixels are set to white in the result image and the rest of
    the pixels are set to black.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cvtColor`将彩色图像转换为灰度图，并确保使用`threshold`函数过滤掉最暗的100种灰色调。确保过滤后的像素在结果图像中设置为白色，其余像素设置为黑色。
- en: Use the `remap` function to resize an image to half of its original width and
    height, thus preserving the aspect ratio of the original image. Use a default
    border type for the extrapolation.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`remap`函数将图像调整为其原始宽度和高度的一半，从而保留原始图像的宽高比。使用默认的边界类型进行外推。
- en: a) Use colormaps to convert an image to grayscale. b) Convert an image to grayscale
    and invert its pixels at the same time.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a) 使用颜色图将图像转换为灰度图。b) 将图像转换为灰度图并同时反转其像素。
- en: Did you read about perspective transformation functions? Which OpenCV function
    covers all similar transformations in one single function?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你读过关于透视变换函数的内容吗？哪个OpenCV函数覆盖了所有类似的变换在一个单一函数中？
