- en: Drawing, Filtering, and Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the previous chapter with nothing but the basics and fundamental
    concepts used in computer vision, and we ended up learning about many algorithms
    and functions used to perform a wide range of operations on matrices and images.
    First, we learned all about the functions that are embedded into the `Mat` class
    for convenience, such as cloning (or getting a full and independent copy) a matrix,
    calculating the cross and the dot product of two matrices, getting the transpose
    or inverse of a matrix, and producing an identity matrix. Then we moved on to
    learn about various element-wise operations in OpenCV. Element-wise operations,
    as we already know, are parallelizable algorithms that perform the same process
    on all individual pixels (or elements) of an image. During the process, we also
    experimented with the effect of such operations on actual image files. We completed
    the previous chapter by learning about operations and functions that treat images
    as a whole, unlike element-wise operations, but they are still considered matrix
    operations in terms of computer vision.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're ready to dig even deeper and learn about numerous powerful algorithms
    that are used in computer vision applications for tasks such as drawing, filtering,
    and the transformation of images. As mentioned in the previous chapters, these
    categories of algorithms as a whole are considered image-processing algorithms.
    In this chapter, we're going to start by learning about drawing shapes and text
    on empty images (similar to canvases) or existing images and video frames. The
    examples in the first section of this chapter will also include a tutorial about
    adding trackbars to OpenCV windows, for easily adjusting required parameters.
    After that, we'll move on to learn about image filtering techniques, such as blurring
    an image, dilation, and erosion. The filtering algorithms and functions that we'll
    learn about in this chapter include many popular and widely used algorithms, especially
    by professional photo-editing applications. This chapter will include a comprehensive
    section about image-transformation algorithms, including algorithms such as the
    simple resizing of photos, or complex algorithms such as remapping pixels. We'll
    end this chapter by learning how to apply colormaps to images to transform their
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing shapes and text on images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying smoothening filters to images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying dilation, erosion, and various other filters to images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remapping pixels and performing geometric transformation algorithms on images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying colormaps to images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IDE to develop C++ or Python applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenCV library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [Chapter 2](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4),
    *Getting Started with OpenCV*, for more information about how to set up a personal
    computer and make it ready for developing computer vision applications using the
    OpenCV library.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following URL to download the source codes and examples for
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without a doubt, one of the most important tasks when developing computer vision
    applications is drawing on images. Imagine you want to print the timestamp on
    pictures or draw a rectangle or ellipse around some areas in an image, and many
    similar examples that would require you to draw text and digits on images or shapes
    (rectangles and so on). As you can see, the examples that can be pointed out are
    quite obvious and countless, so without further ado, let's start with the functions
    and algorithms in OpenCV that can be used for drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Printing text on images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV contains a very easy-to-use function named `putText` to draw, or print,
    text on images. This function requires an image as the input/output parameter,
    which means the source image itself will be updated. So, be sure to make a copy
    of your original image in memory before calling this function. You also need to
    provide this function with an origin point, which is simply the point where the
    text will be printed. The font of the text must be one of the entries in the `HersheyFonts`
    enum, which can take one (or a combination) of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_SIMPLEX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_PLAIN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_DUPLEX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_COMPLEX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_TRIPLEX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_COMPLEX_SMALL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_SCRIPT_SIMPLEX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_HERSHEY_SCRIPT_COMPLEX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FONT_ITALIC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details of how each entry looks when printed, you can check out OpenCV or
    simply search online for more information about Hershey fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the parameters we just mentioned, you also need a few additional
    parameters, such as the scale, color, thickness, and line type of the text. Let's
    break them all down with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example code that demonstrates the usage of the `putText` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed on our example picture from the previous chapters, the following
    result will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Obviously, increasing or decreasing `scale` will result in an increased or
    decreased text size. The `thickness` parameter corresponds to the thickness of
    the printed text and so on. The only parameter that is worth discussing more is `lineType`,
    which was **LINE_AA** in our example, but it can take any value from the `LineTypes`
    enum. Here are the most important line types along with their differences, demonstrated
    with a printed `W` character on a white background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.gif)'
  prefs: []
  type: TYPE_IMG
- en: '**LINE_4** stands for four-connected line types, and **LINE_8** stands for
    eight-connected line types. **LINE_AA** though, which is the anti-aliased line
    type, is slower to draw than the other two, but, as can be seen in the preceding
    diagram, it also provides a much better quality.'
  prefs: []
  type: TYPE_NORMAL
- en: The `LineTypes` enum also includes a `FILLED` entry, which is used for filling
    the shapes drawn on an image with the given color. It's important to note that
    almost all drawing functions in OpenCV (not just `putText`) require a line type
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV provides two more functions that are related to handling texts, but
    not exactly for drawing them. The first one is called `getFontScaleFromHeight`,
    which is used to get the required scale value based on a font type, height (in
    pixels), and thickness. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We could have used the preceding code instead of providing a constant value
    for `scale` in our previous example usage of the `putText` function. Obviously,
    we need to replace `50` with any desired pixel height value for our text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `getFontScaleFromHeight`, OpenCV also includes a function named `getTextSize`
    that can be used to retrieve the width and height that is required for printing
    a specific text on an image. Here''s an example code that shows how we can find
    out the width and height in pixels required for printing the `"Example"` word
    with the `FONT_HERSHEY_PLAIN` font type, a scale of `3.2`, and a thickness of
    `2` on an image using the `getTextSize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The results should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means the text will need `216` by `30` pixels of space to be printed and
    the baseline will be `17` pixels farther from the bottom of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use a set of very simple OpenCV functions to draw various types of shapes
    on images. These functions are all included in the `imgproc` module, just like
    the `putText` function, and they can be used to draw markers, lines, arrowed lines,
    rectangles, ellipses and circles, polylines, and so on in given points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `drawMarker` function, which is used to draw a marker
    with a given type on an image. Here''s how this function is used to print a marker
    at the center of a given image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`position` is the central point of the marker, and the rest of the parameters
    are almost exactly what we saw in the `putText` function previously. This is the
    same pattern of parameters for most (if not all) of the drawing functions in OpenCV.
    The only parameters that are specific to the `drawMarker` function are `markerSize`,
    which is simply the size of the marker, and `markerType`, which can take one of
    the following values from the `MarkerTypes` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MARKER_CROSS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_TILTED_CROSS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_STAR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_DIAMOND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_SQUARE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_TRIANGLE_UP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MARKER_TRIANGLE_DOWN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram depicts all possible marker types mentioned in the previous
    list when they are printed on a white background, from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Drawing lines in OpenCV is possible using the `line` function. This function
    requires two points and it will draw a line connecting the given points. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `shift` parameter corresponds to the number of fractional bits in the given
    points. You can omit or simply pass zero to make sure it has no effect on your
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `line` function, `arrowedLine` can be used to draw an arrowed
    line. Obviously, the order of the given points determines the direction of the
    arrow. The only parameter that this function needs is the `tipLength` parameter,
    which corresponds to the percentage of the line length that will be used to create
    the tip of the arrow. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to draw a circle on an image, we can use the `circle` function.
    Here''s how this function is used to draw a circle right at the center of an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Apart from `center` and `radius`, which are obviously the center point and radius
    of the circle, the rest of the parameters are the same as the functions and examples
    we learned about in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing a rectangle or square on an image is possible using the `rectangle`
    function. This function is very similar to the `line` function in that it requires
    only two points. The difference is that the points given to the `rectangle` function
    correspond to the top-left and bottom-right corner points of a rectangle or square.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of two separate `Point` objects, this function can also be provided
    with a single `Rect` object. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, an ellipse can be drawn by using the `ellipse` function. This function
    requires the size of the axes along with the angle of the ellipse to be provided.
    Additionally, you can use start and ending angles to draw all or part of an ellipse,
    or, in others, an arc instead of an ellipse. You can guess that passing `0` and
    `360` as the start and ending angles will result in a full ellipse being drawn.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of calling the `ellipse` function is by using a `RotatedRect` object.
    In this version of the same function, you must first create a `RotatedRect` with
    a given width and height (or, in other words, size) and an `angle`, and then call
    the `ellipse` function as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that with this method, you can't draw an arc, and this is only used for
    drawing full ellipses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re down to the last type of shapes that can be drawn using OpenCV drawing
    functions, and that is polyline shapes. You can draw polyline shapes by using
    the `polylines` function. You must make sure to create a vector of points that
    corresponds to the vertices required for drawing a polyline. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `isClosed` parameter is used to determine whether the polyline must be closed,
    by connecting the last vertex to the first one or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the `arrowedLine`, `circle`, `rectangle`,
    and `polylines` functions that we used in the preceding code snippets, when they
    are used to draw on our example image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Before proceeding with the next section and learning about algorithms used for
    image filtering, we're going to learn about adjusting parameters at runtime by
    using trackbars added to OpenCV display windows. This is a very useful method
    in order to try out a wide range of different parameters at runtime when you are
    experimenting with different values to see their effect, and it allows the value
    of a variable to be changed by simply readjusting a trackbar (or slider) position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first see an example and then further break down the code and learn
    how trackbars are handled using OpenCV functions. The following complete example
    shows how we can use a trackbar to adjust the radius of a circle drawn on an image
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `window` and `trackbar` are `string` objects that are
    used to identify and access a specific trackbar on a specific window. `image`
    is a `Mat` object containing the source image. `center`, `radius`, `color`, `thickness`,
    `lineType`, and `shift` are parameters required for drawing a circle, as we learned
    previously in this chapter. `drawCircle` is the name of the function (the callback
    function, to be precise) that will be called back when the trackbar is used to
    update the `radius` value for the circle we want to draw. This function must have
    the signature that is used in this example, which has an `int` and a `void` pointer
    as its parameters. This function is quite simple; it just clones the original
    image, draws a circle on it, and then displays it.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function is where we actually create the window and the trackbar.
    First, the `namedWindow` function must be called to create a window with the window
    name that we want. The `createTrackbar` function can then be called, as seen in
    the example, to create a trackbar on that window. Note that the trackbar itself
    has a name that is used to access it. This name will also be printed next to the
    trackbar to display its purpose to the user when the application is running. `setTrackbarMin`
    and `setTrackbarMax` are called to make sure our trackbar doesn't allow `radius`
    values less than 25 or greater than the width or height of the image (whichever
    is smaller), divided by 2 (since we're talking radius, not diameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot that demonstrates the output of our `window`
    along with `trackbar` on it that can be used to adjust the `radius` of the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Try adjusting to see for yourself how the radius of the circle changes according
    to the position of the trackbar. Make sure to use this method when you want to
    experiment with the parameters of a function or algorithms that you learn in this
    book. Note that you can add as many trackbars as you need. However, adding more
    trackbars will use more space on your window, which might lead to a poor user
    interface and experience and, consequently, a hard-to-use program instead of a
    simplified one, so try to make use of trackbars wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It really doesn't matter whether you are trying to build a computer vision application
    to perform highly complex tasks, such as object detection in real-time, or simply
    modifying an input image in one way or another. Almost inevitably, you'll have
    to apply a certain type of filter to your input or output images. The reason for
    this is quite simple—not all pictures are ready to be processed out of the box,
    and most of the time, applying filters to make images smoother is one of the ways
    to make sure they can be fed into our algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The variety of filters that you can apply to your images in computer vision
    is huge, but in this section, we're going to be learning about some of the most
    important filters and especially the ones with an implementation in the OpenCV
    library that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Blurring/smoothening filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blurring an image is one of the most important image filtering tasks, and there
    are many algorithms that can perform it, each one with their own pros and cons,
    which we'll be talking about in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest filter used for smoothening images, which is
    called the median filter, and it can be done by using the `medianBlur` function,
    as seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This filter simply finds the median value of the neighboring pixels of each
    pixel in an image. `ksize`, or the kernel size parameter, decides how big the
    kernel used for blurring is, or, in other words, how far the neighboring pixels
    will be considered in the blurring algorithm. The following image depicts the
    result of increasing the kernel size from 1 to 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the kernel size must be an odd value, and a kernel size of 1 will
    produce the exact same image as the input. So, in the previous images, you can
    see the increase in blurring level from the original image (the leftmost) until
    the kernel size of 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can use extremely high kernel sizes if you need, but it is rarely
    necessary and would usually be needed in case you need to de-noise an extremely
    noisy image. Here''s an example image depicting the result of a kernel size of
    21:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another method of blurring an image is by using the `boxFilter` function. Let''s
    see how it''s done with an example code and then break it down further to better
    understand its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Box filtering is referred to as a blurring method in which a matrix of ones
    with the given `ksize` and `anchor` point is used for blurring an image. The major
    difference here, when compared with the `medianBlur` function, is that you can
    actually define the `anchor` point to be anything other than the center point
    in any neighborhood. You can also define the border type used in this function,
    whereas in the `medianBlur` function, `BORDER_REPLICATE` is used internally and
    cannot be changed. For more information about border types, you might want to
    refer to [Chapter 3](part0048.html#1DOR00-15c05657f8254d318ea883ef10fc67f4), *Array
    and Matrix Operations*. Finally, the `normalize` parameter allows us to normalize
    the result to the displayable result.
  prefs: []
  type: TYPE_NORMAL
- en: The `ddepth` parameter can be used to change the depth of the result. However,
    you can use -1 to make sure the result has the same depth as the source. Similarly,
    `anchor` can be supplied with -1 values to make sure the default anchor point
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the previous example code. The image
    on the right is the box-filtered result of the image on the left-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can perform the exact same task, in other words, the normalized box filter,
    by using the `blur` function, as seen in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The result of this sample code is exactly the same as calling `boxFilter`, as
    we saw previously. The obvious difference here is that this function does not
    allow us to change the depth of the result and applies normalization by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the standard box filter, you can also apply a square box filter
    with the `sqrBoxFilter` function. In this method, instead of calculating the sum
    of the neighboring pixels, the sum of their square values is calculated. Here
    is an example, which is incredibly similar to calling the `boxFilter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The unnormalized versions of the `boxFilter` and `sqrBoxFilter` functions can
    also be used to find statistical information about the neighboring areas of all
    pixels in an image, and their use case is not limited to just blurring an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most popular blurring methods in computer vision is the **Gaussian
    blur** algorithm, and it can be performed in OpenCV by using the `GaussianBlur`
    function. This function, similar to the previous blur functions that we learned
    about, requires a kernel size, along with standard deviation values in the *X*
    and *Y* direction, called `sigmaX` and `sigmaY`, respectively. Here''s an example
    of how this function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that a value of zero for `sigmaY` means the value of `sigmaX` will also
    be used in the *Y* direction. For more information about Gaussian blur, you can
    read about the Gaussian function in general and the `GaussianBlur` function in
    the OpenCV documentation pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last smoothening filter that we''ll learn about in this section is called
    the **bilateral filter**, and it can be achieved by using the `bilateralFilter`
    function. Bilateral filtering is a powerful method of de-noising and smoothening
    an image, while preserving edges. This function is also much slower and more CPU-intensive
    in comparison with the blur algorithms that we saw previously. Let''s see how
    `bilateralFilter` is used with an example and then break down the required parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`d`, or the filter size, is the diameter of the pixel neighborhood that will
    participate in the filter. The `sigmaColor` and `sigmaSpace` values are both used
    to define the effect of the color and coordinate the pixels nearer or farther
    from the pixel whose filtered value is being calculated. Here''s a screenshot
    that demonstrates the effect of the `bilateralFilter` function when executed on
    our example image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Morphological filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to smoothening filters, morphology filters are the algorithms that change
    the value of each pixel based on the value of the neighboring pixels, although
    the obvious difference is that they do not have a blurring effect and are mostly
    used to produce some form of erosion or dilation effect on images. This will be
    clarified with a few hands-on examples further in this section, but for now, let's
    see how morphological operations (also called **transformations**) are performed
    using OpenCV functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `morphologyEx` function to perform morphological operations
    on images. This function can be provided with an entry from the `MorphTypes` enum
    to specify the morphological operation. Here are the values that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MORPH_ERODE`: For erosion operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MORPH_DILATE`: For dilation operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MORPH_OPEN`: For opening operation, or the dilation of eroded images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MORPH_CLOSE`: For closing operation, or the erosion of dilated images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MORPH_GRADIENT`: For morphological gradient operation, or subtraction of the
    eroded image from the dilated image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MORPH_TOPHAT`: For Top-hat operation, or subtraction of the opening operation
    result from the source image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MORPH_BLACKHAT`: For Black-hat operation, or subtraction of the source image
    from the result of the closing operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand all of the possible morphological operations mentioned in the
    previous list, it''s important to first understand the effect of erosion and dilation
    (the first two entries in the list) since the rest are simply different combinations
    of these two morphological operations. Let''s first try erosion with an example
    and, at the same time, learn how the `morphologyEx` function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`op`, or the operation, is an entry from the `MorphTypes` enum, as mentioned
    before. `kernel`, or the structuring element, is the kernel matrix used for the
    morphological operation, which itself is either created manually or by using the `getStructuringElement`
    function. You must provide the `getStructuringElement` with a `shape` morph, kernel
    size (`ksize`), and `anchor`. `shape` can be a rectangle, cross, or ellipse, and
    is simply an entry from the `MorphShapes` enum. The `iterations` variable refers
    to the number of times the morphological operation is performed on an image. `borderType`
    is interpreted exactly the same way as with all the functions we''ve seen so far
    for the extrapolation of pixels. In case a constant border type value is used,
    the `morphologyEx` function must also be provided with a border value, which can
    be retrieved by using the `morphologyDefaultBorderValue` function, or specified
    manually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result of our preceding code (for erosion), when executed on our
    sample image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Dilation, on the other hand, is performed by simply replacing the `op` value
    with `MORPH_DILATE` in the previous example. Here''s the result of the dilation
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A highly simplified description of what erosion and dilation operations do is
    that they cause the neighboring pixels of darker pixels to become darker (in case
    of erosion) or the neighboring pixels of brighter pixels to become brighter (in
    case of dilations), which, after more iterations, will cause a stronger and easily
    visible effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'As was mentioned before, all of the other morphological operations are simply
    a combination of erosion and dilation. Here are the results of opening and closing
    operations when they are executed on our example images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure you try the rest of the morphological operations by yourself to see
    their effects. Create user interfaces that have trackbars on them and try changing
    the value of `iteration` and other parameters to see how they affect the result
    of morphological operations. If used carefully and wisely, morphological operations
    can have very interesting results and further simplify an operation that you want
    to perform on an image.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding to the next section, it is worth noting that you can also
    use the `erode` and `dilate` functions to perform exactly the same operation.
    Although these functions do not require an operation parameter (since the operation
    is in their name already), the rest of the parameters are exactly the same as
    with the `morphologyEx` function.
  prefs: []
  type: TYPE_NORMAL
- en: Derivative-based filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to learn about filtering algorithms that are based
    on calculating and using the derivatives of an image. To understand the concept
    of derivatives in an image, you can recall the fact that images are matrices,
    so you can calculate the derivatives (of any order) in *X* or *Y* directions,
    for instance, which, in the simplest case, would be the same as finding the change
    across the pixels in a direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `Sobel` function, which is used to calculate the derivative
    of an image using a `Sobel` operator. Here''s how this function is used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`ddepth`, similar to what we saw in previous examples throughout this chapter,
    is used to define the depth of the output, and using `-1` makes sure the result
    has the same depth as the input. `dx` and `dy` are used to set the order of the
    derivative in both the *X* and *Y* directions. `ksize` is the size of the `Sobel`
    operator, which can be 1, 3, 5, or 7\. `scale` is used as the `scale` factor for
    the result, and delta is added to the `result`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following images depict the result of the `Sobel` function when called
    with the parameter values from the preceding example code, but for a `delta` value
    of zero (on the left) and 255 (on the right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Try setting different `delta` and `scale` values and experiment with the results.
    Also try different derivative orders and see the effects for yourself. As you
    can see from the preceding output images, calculating the derivative of an image
    is a method for calculating the edges in an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `spatialGradient` function to calculate the first-order
    derivative of an image in both the *X* and *Y* directions using the `Sobel` operator,
    at the same time. In other words, calling `spatialGradient` once is like calling
    the `Sobel` function twice, for the first-order derivative in both directions.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `ksize` parameter must be `3` and the input image type must be
    grayscale, otherwise this function will fail to execute, although this might change
    in an upcoming OpenCV version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the way we used the `Sobel` function, you can use the `Laplacian`
    function to calculate the Laplacian of an image. It''s important to note that
    this function essentially sums up the second derivatives in the *X* and *Y* directions
    calculated using the `Sobel` operator. Here''s an example that demonstrates the
    usage of the `Laplacian` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: All of the parameters used in the `Laplacian` function are already described
    in previous examples, and especially the `Sobel` function.
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV supports the application of arbitrary filters on images by using the
    `filter2D` function. This function is capable of creating the result of many algorithms
    we already learned, but it requires a `kernel` matrix to be provided. This function
    simply convolves the whole image with the given `kernel` matrix. Here''s an example
    of applying an arbitrary filter on an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of this arbitrary filter. You can see the original image
    on the left, and the result of the filtering operation on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is absolutely no limit to the number of possible filters you can create
    and use using the `filter2D` function. Make sure you try different kernel matrices
    and experiment with the `filter2D` function. You can also search online for popular
    filter kernel matrices and apply them using the `filter2D` function.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about computer vision algorithms that are used
    to transform images in one way or another. The algorithms that we'll be learning
    in this section cover algorithms that change the content of an image, or the way
    its contents is interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: Thresholding algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thresholding algorithms are used to apply a threshold value to the pixels of
    an image. These algorithms can be used to effectively create masks from images
    that have possible regions or pixels of interest in them that pass a certain threshold
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `threshold` function to apply a threshold value on all pixels
    of an image. The `threshold` function must be provided with the type of threshold
    that is desired, and it can be an entry from the `ThresholdTypes` enum. The following
    is an example that can be used to find the brightest areas in an image using the
    `threshold` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`thresh` is the minimum threshold value, and `maxval` is the maximum allowed
    value. Simply put, all pixel values between `thresh` and `maxval` are allowed
    to pass and so the `result` is created. The following is the result of the preceding
    `threshold` operation demonstrated with an example image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Increase the `thresh` parameter (or the threshold value) and you'll notice that
    fewer pixels are allowed to pass. Setting a correct threshold value requires experience
    and knowledge about the scene. In some cases, however, you can develop programs
    that set the threshold automatically for you, or adaptively. Note that the threshold
    type completely affects the result of the `threshold` function. For instance,
    `THRESH_BINARY_INV` will produce the inverted result of `THRESH_BINARY` and so
    on. Make sure to try different threshold types and experiment for yourself with
    this interesting and powerful function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another, more sophisticated, way of applying thresholds to images is by using
    the `adaptiveThreshold` function, which works with grayscale images. This function
    assigns the given `maxValue` parameter to the pixels that pass the threshold criteria.
    Besides that, you must provide a threshold type, an adaptive `threshold` method,
    a block size defining the diameter in the pixel neighborhood, and a constant value
    that is subtracted from the mean (depending on the adaptive `threshold` method).
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `adaptiveMethod` can take any of the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADAPTIVE_THRESH_MEAN_C`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADAPTIVE_THRESH_GAUSSIAN_C`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The higher the `blockSize` parameter value, the more pixels are used in the
    adaptive `threshold` method. The following is an example image that depicts the
    result of the `adaptiveThreshold` method called with the values in the preceding
    example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Color space and type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting various color spaces and types to each other is extremely important,
    especially when it comes to dealing with images from different device types or
    intending to display them on different devices and formats. Let's see what this
    means with a very simple example. You'll need grayscale images for various OpenCV
    functions and computer vision algorithms, while some will require RGB color images.
    In such cases, you can use the `cvtColor` function to convert between various
    color spaces and formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example that converts a color image to grayscale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`code` can take a conversion code, which must be an entry from the `ColorConversionCodes`
    enum. The following are some examples of the most popular color-conversion codes,
    that can be used with the `cvtColor` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COLOR_BGR2RGB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLOR_RGB2GRAY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLOR_BGR2HSV`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on and on. Make sure to check the `ColorConversionCodes` enum
    for all possible color-conversion codes.
  prefs: []
  type: TYPE_NORMAL
- en: Geometric transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is dedicated to geometric transformation algorithms and OpenCV
    functions. It's important to note that the name, Geometric transformation, is
    based on the fact that the algorithms falling in this category do not change the
    content of an image, they simply deform the existing pixels, while using an extrapolation
    and interpolation method to calculate the pixels that fall outside the area of
    the existing pixels, or over each other, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest geometric transformation algorithm, which is
    used for resizing an image. You can use the `resize` function to resize an image.
    Here is how this function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `dsize` parameter is set to a non-zero size, the `fx` and `fy` parameters
    are used to scale the input image. Otherwise, if `fx` and `fy` are both zero,
    the input image is resized to the given `dsize`. The `interpolation` parameter,
    on the other hand, is used to set the `interpolation` method used for the resize
    algorithm, and it must be one of the entries in the `InterpolationFlags` enum.
    Here are some of the possible values for the `interpolation` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INTER_NEAREST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTER_LINEAR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTER_CUBIC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTER_AREA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTER_LANCZOS4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to check out the OpenCV documentation pages for `InterpolationFlags`
    to find out about the details of each possible method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the previous example code that was
    used for resizing an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Probably the most important geometric transformation algorithm, which is able
    to perform most of the other geometric transformations, is the remapping algorithm,
    and it can be achieved by calling the `remap` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remap` function must be provided with two mapping matrices, one for *X*
    and another one for the *Y* direction. Besides that, an interpolation and extrapolation
    (border type) method, along with a border value in case of constant border type,
    must be provided to the `remap` function. Let''s first see how this function is
    called and then try a couple of different remaps. Here''s an example that shows
    how the `remap` function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create an infinite number of different mappings and use them with the `remap`
    function to resize, flip, warp, and do many other transformations on images. For
    instance, the following code can be used to create a remapping that will cause
    a vertical flip of the resulting image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code in the preceding `for` loop with the following and the result
    of the `remap` function call will be a horizontally flipped image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides simple flipping, you can use the `remap` function to perform many interesting
    pixel deformations. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen from the inline comments of the preceding example code, it is
    common to convert the OpenCV `i` and `j` values (row and column number) to a standard
    coordinate system and use *X* and *Y* with known mathematical and geometrical
    functions, and then convert them back to the OpenCV image coordinates. The following
    image demonstrates the result of the preceding example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `remap` function is incredibly powerful and efficient as long as the calculation
    of `mapX` and `mapY` are handled efficiently. Make sure to experiment with this
    function to learn about more remapping possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: There are a huge number of geometric transformation algorithms in computer vision
    and in the OpenCV library, and covering all of them would need a book of its own.
    So, we'll leave the rest of the geometric transformation algorithms for you to
    explore and try on your own. Refer to the *Geometric Image Transformations* section
    in the OpenCV `imgproc` (Image Processing) module documentation for more geometric
    transformation algorithms and functions. In particular, make sure to learn about
    functions including `getPerspectiveTransform` and `getAffineTransform`, which
    are used to find the perspective and affine transformation between two sets of
    points. Such functions return transformation matrices that can be used to apply
    perspective and affine transformation to images by using the `warpPerspective`
    and `warpAffine` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Applying colormaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll end this chapter by learning about applying colormaps to images. This
    is a fairly simple but powerful method that can be used to modify the colors of
    an image or its tone in general. This algorithm simply replaces the colors of
    an input image using a colormap and creates a result. A **colormap** is a 256-element
    array of color values, in which each element represents the color that must be
    used for the corresponding pixel values in the source image. We will break this
    down further with a couple of examples, but before that, let's see how colormaps
    are applied to images.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV contains a function named `applyColorMap` that can be used to either
    apply predefined colormaps or custom ones created by the user. In case predefined
    colormaps are used, `applyColorMap` must be provided with a colormap type, which
    must be an entry from the `ColormapTypes` enum. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image depicts the result of various predefined colormaps that
    can be applied using the `applyColorMap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned earlier, you can also create your own custom colormaps. You just
    need to make sure you follow the instructions for creating a colormap. Your colormap
    must have a size of `256` elements (a `Mat` object with `256` rows and `1` column)
    and it must contain color or grayscale values, depending on the type of image
    you are planning to apply the colormap to. The following is an example that shows
    how to create a custom colormap by simply inverting the green channel color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of the preceding example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we tried to cover the most important topics of image-processing
    algorithms in computer vision, we still have a long way to go and many more algorithms
    to learn. The reason is quite simple, and that is the variety of applications
    that these algorithms can be used for. We learned a great deal of widely used
    computer vision algorithms in this chapter, but it should also be noted that whatever
    we learned in this chapter is also meant to ease your way when you start exploring
    the rest of the image-processing algorithms by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this chapter by learning about drawing functions that can be used
    to draw shapes and text on images. Then we moved on to learn about one of the
    most important computer vision topics: image filtering. We learned how to use
    smoothening algorithms, we experimented with morphological filters, and learned
    about erosion, dilation, opening, and closing. We also got to try some simple
    edge detection algorithms, or, in other words, derivative-based filters. We learned
    about thresholding images and changing their color spaces and types. The final
    sections of this chapter introduced us to geometric transformations and applying
    colormaps on images. We even created a custom colormap of our own. You can easily
    find the trace of the algorithms that we learned in this chapter, in many professional
    photo-editing or social-networking and photo-sharing applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn all about histograms, how they are calculated,
    and how they are used in computer vision. We'll cover the algorithms that are
    crucial when working on certain object detection and tracking algorithms that
    we'll be exploring in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that draws a cross mark over the whole image, with a thickness
    of 3 pixels and in the color red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a window with a trackbar to change the `ksize` of a `medianBlur` function.
    The possible range for the `kszise` value should be between 3 and 99.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a gradient morphological operation on an image, considering a kernel
    size of 7 and a rectangular  morphological shape for the structuring element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `cvtColor`, convert a color image to grayscale and make sure only the
    darkest 100 shades of gray are filtered out using the `threshold` function. Make
    sure that filtered pixels are set to white in the result image and the rest of
    the pixels are set to black.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `remap` function to resize an image to half of its original width and
    height, thus preserving the aspect ratio of the original image. Use a default
    border type for the extrapolation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Use colormaps to convert an image to grayscale. b) Convert an image to grayscale
    and invert its pixels at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Did you read about perspective transformation functions? Which OpenCV function
    covers all similar transformations in one single function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
