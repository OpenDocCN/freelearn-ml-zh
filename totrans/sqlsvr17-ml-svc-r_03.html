<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing Machine Learning Services for SQL Server 2017 and R</h1>
                
            
            <article>
                
<p class="calibre2">This chapter will tackle managing R Services and the steps necessary to get R Services running from a SQL Server database. In detail, this chapter will cover the following topics:</p>
<ul class="calibre7">
<li class="calibre8">Installing SQL Server with R services</li>
<li class="calibre8">Configuring the environment and installing <strong class="calibre1">R Tools for Visual Studio</strong> (<strong class="calibre1">RTVS</strong>)</li>
<li class="calibre8">Resource Governor</li>
<li class="calibre8">Security</li>
<li class="calibre8">Sessions and logs</li>
<li class="calibre8">Installing new R packages</li>
<li class="calibre8">Managing SQL Server R services with PowerShell</li>
<li class="calibre8">Getting to know the <kbd class="calibre11">sp_execute_external_script</kbd> <span>external procedure</span></li>
</ul>
<p class="calibre2">With SQL Server 2017 installation, configuration, and setting up the working environment aren't that much different, compared with how SQL Server 2016 operated when R was originally introduced. If there are differences between the versions, they will be pointed out.</p>
<p class="calibre2">Installing SQL Server with machine learning R Services using SQL Server 2016 and 2017 has minimal hardware requirements that depend on the edition of SQL Server you will be installing. SQL Server comes in several editions. More information is available on the Microsoft webpage: </p>
<p class="calibre2"><a href="https://www.microsoft.com/en-us/sql-server/sql-server-2017-editions" class="calibre10">https://www.microsoft.com/en-us/sql-server/sql-server-2017-editions</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Minimum requirements</h1>
                
            
            <article>
                
<p class="calibre2">Basic R integration is available in almost all SQL Server editions, except the Express edition (unless it is Express with Advanced Services). This means that a standard SQL Server will support R services to the extent of using vanilla and native R code, but no advanced R integration or pushing computations to other computational contexts. The same logic will apply to SQL Server 2017 (at the time of writing), and editions and features are already made public at the following URL:</p>
<p class="calibre2"><a href="https://docs.microsoft.com/en-us/sql/sql-server/editions-and-components-of-sql-server-2017" class="calibre10">https://docs.microsoft.com/en-us/sql/sql-server/editions-and-components-of-sql-server-2017</a></p>
<p class="calibre2">In terms of the operating system, many Microsoft OS versions (such as Windows Server 2012 and higher, Windows 8 and higher) are supported and, starting with SQL Server 2016 and higher, Linux is also supported. To have R Services running, a minimum of 1 GB is required, but 4 GB would be recommended, and 2.0 GHz or a faster processor (x64 processor type) speed would do the job. In addition, 6 GB hard drive space would do for the principal installation, but more disk space will be required based on any additional features or SQL Server services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Choosing the edition</h1>
                
            
            <article>
                
<p class="calibre2">SQL Server is no longer just a database, but has grown into a database platform - an ecosystem -  which consists of many additional services (such as SSRS, SSAS, and SSIS) that supports and also extends the capabilities of modern <span>database </span>usage. When installing Machine Learning R Services (in a database), one should think about the ecosystem environment and which additional services would be used along with R Services. If the business need requires advanced R (or Python) integration and analytics, the Enterprise edition is the right one. If only basic R integration is needed, the standard version will cover the needs. Also, think along the lines of other analytical tools if you need analysis services or reporting services, and which developments tools would also be needed for that (for example, MDX on top of OLAP cubes and running R code against the same data mart).</p>
<p class="calibre2">When you have decided on the version, download the ISO or CAB installation file of SQL Server 2017(or 2016) and start the installation. I will install the Developer edition of SQL Server 2017 (which is, from the installation perspective, almost the same as the 2016 version):</p>
<div class="packt_figure"><img class="aligncenter7" src="../images/00015.jpeg"/></div>
<div class="cdpaligncenter">Figure 1: Installation type of SQL Server</div>
<p class="calibre2">Installing a new installation of SQL Server will guarantee that the Machine Learning Services with R (or in-database service) are correctly installed.</p>
<p class="calibre2">In the next step, the installation features must be installed. To have R Services installed, a tick must be placed on <span>R</span> for <span>SQL Server Services (in-database),</span> while for SQL Server 2017, a tick must be placed on <span>R</span> in the <span>Machine Learning Services (in-database)</span> section:</p>
<div class="packt_figure"><img class="aligncenter8" src="../images/00016.jpeg"/></div>
<div class="cdpaligncenter">Figure 2: Feature selection for SQL Server</div>
<p class="calibre2">In the following server configuration step, you must check the users and accounts that will have access to services. For R Services (in-database), the SQL Server Launchpad service will be installed and automatically started. This service can be started or stopped after the installation through Windows Application-Services:</p>
<div class="packt_figure"><img class="aligncenter9" src="../images/00017.jpeg"/></div>
<div class="cdpaligncenter">Figure 3: Server configuration for SQL Server</div>
<p class="calibre2">After the database engine is configured, you will be prompted to accept the agreement to install Microsoft R Open, making sure that you are aware of the fact that R is under GNU License. By requesting this consent, Microsoft just wants to make sure that the administrator agrees and that all new updates and patches to R Open version will be in accordance with the SQL Server update preferences:</p>
<div class="packt_figure"><img class="aligncenter10" src="../images/00018.jpeg"/></div>
<div class="cdpaligncenter">Figure 4: Prompting the content for installing Microsoft R Open</div>
<p class="calibre2">In addition to agreeing to R's agreement, please note that the life cycle of Microsoft R Server is two years. If MRS 8.0 was released in January 2016, the official support ended in January 2018; to be more precise, security and critical updates will come in for a period of one year (until January 2017) and, after that, only the security updates will continue until January 2018. During the year, upgrades will also be received. Please note that it is relevant for the standalone product-Microsoft Machine Learning Server, but it is worth mentioning how long the support timeline will be held.</p>
<p class="calibre2">If you are also installing Python, the same consent will be requested:</p>
<div class="packt_figure"><img class="aligncenter11" src="../images/00019.jpeg"/></div>
<div class="cdpaligncenter">Figure 5: Prompting the content to install Python</div>
<p class="calibre2">Once you have selected all of the features, configurations, and consents, you will be presented with an overview of the services and features to be installed:</p>
<div class="packt_figure"><img class="aligncenter12" src="../images/00020.jpeg"/></div>
<div class="cdpaligncenter">Figure 6: Selected features ready to be installed</div>
<p class="calibre2">Once the installation is completed, you will have the R Engine for Machine Learning Services and Microsoft Machine Learning Server with R (if selected) installed. Please note that R Engine for R Services (in-database) will have a different R installation, as the standalone Microsoft R Server, and also all the installed packages will be different, under different paths, rights, and security settings.</p>
<div class="packt_figure"><img class="aligncenter13" src="../images/00021.jpeg"/></div>
<div class="cdpaligncenter">Figure 7: Completing the installation process</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the database</h1>
                
            
            <article>
                
<p class="calibre2">During the postinstallation process, database configuration will be the next task. Think about database collation, because the R language is case-sensitive, and it matters what kind of data you will be feeding to SQL Server engine and pushing onward to Launchpad.Some languages differentiate the small from capital caps (for example, the Turkish language; the letter L in particular) and this might be an additional challenge when pairing SQL Server and R data types. In addition, based on your ecosystem, authentication should also play an important role in setting up the environment.</p>
<p class="calibre2">With real-time data scoring available with SQL Server 2016 and improved in SQL Server 2017, it is worth giving it a try. Also, for any extended use of Machine Learning Services, file database might be a very useful and powerful way to store graphs and results for later analysis, or results that can be exposed to Power BI, SSRS, or external applications. If you have a filestream included for tackling unstructured data in your business, this is also another service where the database configuration needs additional attention.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the environment and installing R Tools for Visual Studio (RTVS)</h1>
                
            
            <article>
                
<p class="calibre2">Once the installation is completed, there are some post installation processes that need to be executed.</p>
<p class="calibre2">The external script server must be enabled so that stored procedures can call external script. In order to do so, run the following command against your SQL Server instance, where you have installed R Services (in-database):</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_configure 'show advanced options',1;</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">RECONFIGURE;</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">EXEC sp_configure 'external scripts enabled';</strong>
<strong class="calibre1">GO</strong>  </pre>
<p class="calibre2">If you are running this for the first time, it is disabled by default so enabling it is a must; otherwise, running the <kbd class="calibre11">sp_execute_external_script</kbd> procedure will not be possible:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_configure 'external scripts enabled', 1;</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">RECONFIGURE WITH OVERRIDE;</strong>
<strong class="calibre1">GO</strong>  </pre>
<p class="calibre2">You can always check whether the <kbd class="calibre11">run_value</kbd> of <span>external scripts enabled </span>is set to <span>1</span>, as follows:</p>
<div class="packt_figure"><img class="aligncenter14" src="../images/00022.gif"/></div>
<div class="cdpaligncenter">Figure 8: Setting up sp_configure</div>
<p class="calibre2">If the server configuration does not take effect, you need to restart the SQL Server service.Under services, find your <kbd class="calibre11">MSSQLSERVER</kbd> Service name and restart it (<span>Stop </span>and <span>Start</span>):</p>
<div class="packt_figure"><img src="../images/00023.jpeg" class="calibre26"/></div>
<div class="cdpaligncenter">Figure 9: Checking MSSQLSERVER service</div>
<p class="calibre2">Restarting the <kbd class="calibre11">MSSQLSERVER</kbd> service will automatically restart all the dependent services, along with the <kbd class="calibre11">MSSQLLaunchpad</kbd> service. After the restart of the server, the external script will be enabled.</p>
<p class="calibre2">After the post installation process has finished, security can be set. It is optional, as the default database readers are already set, but, based on your company's environment you are advised to look into this and set it up properly.</p>
<p class="calibre2">In addition, you will need to install <strong class="calibre1">R Tools for Visual Studio</strong> (<strong class="calibre1">RTVS</strong>). To do this, Visual Studio 2015 or higher is needed and, once VS2015+ is installed, you need to download the RTVS itself from the Visual Studio website (<a href="https://www.visualstudio.com/vs/rtvs/" class="calibre10">https://www.visualstudio.com/vs/rtvs/</a>). The installation process from that point is straightforward and does not need any further instructions now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Security</h1>
                
            
            <article>
                
<p class="calibre2">After configuring the database and any other additional settings used in your ecosystem, you will want to think about security, in terms of who will have access to run <kbd class="calibre11">sp_execute_external_script</kbd>.</p>
<p class="calibre2">You can directly create security settings on the external procedure. In this case, you will need to add database permissions to execute external script to the user.</p>
<p class="calibre2">A simple SQL login will look like this:</p>
<pre class="calibre19"><strong class="calibre1">USE [master]</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">CREATE LOGIN [RR1] WITH PASSWORD=N'Read!2$17', DEFAULT_DATABASE=[SQLR], CHECK_EXPIRATION=ON, CHECK_POLICY=ON</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">ALTER SERVER ROLE [sysadmin] ADD MEMBER [RR1]</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">CREATE DATABASE SQLR;</strong>
<strong class="calibre1">GO</strong>
    
<strong class="calibre1">USE [SQLR]</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">CREATE USER [RR1] FOR LOGIN [RR1]</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">USE [SQLR]</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">ALTER USER [RR1] WITH DEFAULT_SCHEMA=[dbo]</strong>
<strong class="calibre1">GO</strong></pre>
<p class="calibre2">And now, let's start the external procedure:</p>
<pre class="calibre19">    
<strong class="calibre1">EXECUTE AS USER = 'RR1';</strong>
<strong class="calibre1">GO</strong>
    
<strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'OutputDataSet&lt;- InputDataSet'</strong>
 <strong class="calibre1">     ,@input_data_1 = N'SELECT 1 AS Numb UNION ALL SELECT 2;'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">((</strong>
<strong class="calibre1">    Res INT</strong>
<strong class="calibre1">))</strong>
    
    
<strong class="calibre1">REVERT;</strong>
<strong class="calibre1">GO</strong></pre>
<p class="calibre2">And the error message will be, that the user <kbd class="calibre11">RR1</kbd> does not have permissions:</p>
<pre class="calibre19"><strong class="calibre1">Msg 297, Level 16, State 101, Procedure sp_execute_external_script, Line 1 [Batch Start Line 34]</strong>
<strong class="calibre1">The user does not have permission to perform this action.</strong></pre>
<p class="calibre2">You also have to grant the database a datareader role in order to execute the <kbd class="calibre11">sp_execute_external_script</kbd> command:</p>
<pre class="calibre19"><strong class="calibre1">USE [SQLR]
GO
ALTER ROLE [db_datareader] ADD MEMBER [RR1]
GO
</strong></pre>
<p class="calibre2">You should also check that executing external scripts is enabled:</p>
<pre class="calibre19"><strong class="calibre1">GRANT EXECUTE ANY EXTERNAL SCRIPT TO [RR1];</strong>
<strong class="calibre1">GO</strong>  </pre>
<p class="calibre2">After setting the database role and granting execute permissions, rerun the <kbd class="calibre11">sp_execute_external_script</kbd> procedure and the result of executing the external script should be as follows:</p>
<div class="packt_figure"><img class="aligncenter15" src="../images/00024.gif"/></div>
<div class="cdpaligncenter">Figure 10: The results of the external procedure</div>
<p class="calibre2">How to manage user authentication (Windows or SQL) and primary security principles; it should be aligned using local DBA, SysAdmin, and architect to help you delegate who will have access to the system.</p>
<p class="calibre2">A rule of thumb is to prepare stored procedures for dealing with different levels of data manipulation and granting access on the level of the stored procedure. Clean the data using this commands:</p>
<pre class="calibre19"><strong class="calibre1">DROP USER RR1; </strong><br class="title-page-name"/><strong class="calibre1">GO </strong><br class="title-page-name"/><strong class="calibre1">USE [master]; </strong><br class="title-page-name"/><strong class="calibre1">GO </strong><br class="title-page-name"/><strong class="calibre1">DROP LOGIN RR1; </strong><br class="title-page-name"/><strong class="calibre1">GO </strong><br class="title-page-name"/><strong class="calibre1">--DROP TABLE IF EXISTS SQLR; </strong><br class="title-page-name"/><strong class="calibre1">GO</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Resource Governor</h1>
                
            
            <article>
                
<p class="calibre2">Resource Governor is a very welcome feature of R Services (in-database), as it enables the Govern workload against the server with a simple dataset that is available with the accompanying code-database <kbd class="calibre11">RevoTestDB</kbd>, it needs to be restored first<strong class="calibre1">:</strong></p>
<pre class="calibre19"><strong class="calibre1">USE [master]</strong>
<strong class="calibre1">RESTORE DATABASE [RevoTestDB] FROM  DISK = N'C:\SQLServer2017MLServicesR\CH03\RevoTestDB.bak';</strong>
<strong class="calibre1">GO</strong>  </pre>
<p class="calibre2">After the restore, we will see the loads against the database and how to govern resources:</p>
<pre class="calibre19"><strong class="calibre1">USE RevoTestDB;
GO

-- TEST query
EXECUTE  sp_execute_external_script
                 @language = N'R'
                 ,@script = N'
            library(RevoScaleR)
f &lt;- formula(as.numeric(ArrDelay) ~ as.numeric(DayOfWeek) + CRSDepTime)
s &lt;- system.time(mod &lt;- rxLinMod(formula = f, data = AirLine))
            OutputDataSet &lt;-  data.frame(system_time = s[3]);'
                ,@input_data_1 = N'SELECT * FROM AirlineDemoSmall'
                ,@input_data_1_name = N'AirLine'
WITH RESULT SETS ((Elapsed_time FLOAT));</strong></pre>
<p class="calibre2">With this test query on my computer, the whole running time was 21 seconds and with elapsed time returned from R Engine, of 1.43 seconds.</p>
<p class="calibre2">Setting up the Resource Governer to tackle picks and spikes. To have execution operations running faster when needed or when running a higher amount of data, we need to configure the external resource pool and the resource pool to grant the resources:</p>
<pre class="calibre19"><strong class="calibre1">-- Default value
ALTER EXTERNAL RESOURCE POOL [default] 
WITH (AFFINITY CPU = AUTO)
GO

CREATE EXTERNAL RESOURCE POOL RService_Resource_Pool
WITH (  
      MAX_CPU_PERCENT = 10  
      ,MAX_MEMORY_PERCENT = 5
);  

ALTER RESOURCE POOL [default] WITH (max_memory_percent = 60, max_cpu_percent=90);  
ALTER EXTERNAL RESOURCE POOL [default] WITH (max_memory_percent = 40, max_cpu_percent=10);  
ALTER RESOURCE GOVERNOR reconfigure;

ALTER RESOURCE GOVERNOR RECONFIGURE;  
GO
</strong></pre>
<p class="calibre2">In the last step, a classification function must be created and reconfigured:</p>
<pre class="calibre19"><strong class="calibre1">CREATE FUNCTION RG_Class_function()
RETURNS sysname
WITH schemabinding
AS  
BEGIN  
    IF program_name() in ('Microsoft R Host', 'RStudio') RETURN 'R_workgroup';  
    RETURN 'default'
    END;  
GO  

ALTER RESOURCE GOVERNOR WITH  (classifier_function = dbo.RG_Class_function);  
ALTER RESOURCE GOVERNOR reconfigure;  
GO
</strong></pre>
<p class="calibre2">After that, I can run the same query again:</p>
<pre class="calibre19"><strong class="calibre1">-- TEST 2 - performance normal; with governor enabled</strong>
<strong class="calibre1">EXECUTE  sp_execute_external_script</strong>
<strong class="calibre1">                 @language = N'R'</strong>
<strong class="calibre1">,@script = N'</strong>
<strong class="calibre1">library(RevoScaleR)</strong>
<strong class="calibre1">f &lt;- formula(as.numeric(ArrDelay) ~ as.numeric(DayOfWeek) + CRSDepTime)</strong>
<strong class="calibre1">s &lt;- system.time(mod &lt;- rxLinMod(formula = f, data = AirLine))</strong>
<strong class="calibre1">OutputDataSet&lt;-  data.frame(system_time = s[3]);'</strong>
<strong class="calibre1">,@input_data_1 = N'SELECT * FROM AirlineDemoSmall'</strong>
<strong class="calibre1">,@input_data_1_name = N'AirLine'</strong>
<strong class="calibre1">WITH RESULT SETS ((Elapsed_time FLOAT));</strong>  </pre>
<p class="calibre2">In the end, the comparison in performance is obvious. In the case of my test environment, because I dedicated more CPU and RAM resources to executing R code, I get a running time of three seconds with an R elapsed time of 0.63 seconds. Results on your client might be different, but the change from the default resource governor settings to new settings should be very obvious.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing new R packages</h1>
                
            
            <article>
                
<p class="calibre2">An R package is a container of functions that serve a particular purpose with the relevant binary source code (usually C, C++, or Fortran), documentation, and sample data. A package is a collection of these files that reside in a library folder. If you navigate to your R library folder, you will see all the packages installed for your R Engine. A package might also be called a binary package or a tarball, depending on the operating system.</p>
<p class="calibre2">A package is not equivalent to a library, nor should it be mistaken for one. In the R language, when installing a package the command <kbd class="calibre11">install.packages</kbd> is used. A <kbd class="calibre11">library()</kbd> is a function that loads functions in particular packages into your R environment. Deriving from the Windows OS, shared objects are called <strong class="calibre1">Dynamic-link </strong>library's (<strong class="calibre1">DLLs</strong>). Hence, the word library is used and refers to common and shared objects. So, to load a package into your R environment, the function <kbd class="calibre11">library()</kbd> is used, with the name of the package specified in brackets.</p>
<p class="calibre2">Referring to an R library in an R script is super easy; simply add the library or use the <kbd class="calibre11">require()</kbd> method. But in the system, the library must be, in the first place, installed.</p>
<p class="calibre2">Libraries are installed by installing packages available in common repositories, such as CRAN, Biocondutor, GitHub, and MRAN in the case of the Microsoft repository. In the R language, a library is installed by invoking the following command:</p>
<pre class="calibre19"><strong class="calibre1">install.packages("Package_Name")</strong>  </pre>
<p class="calibre2">In SQL Server 2016, the installation of such packages was not possible by running an R script with an external stored procedure and the code returned an error, as follows:</p>
<pre class="calibre19"><strong class="calibre1">--Install Package using sp_execute_external_script</strong>
<strong class="calibre1">EXECUTE sp_execute_external_script</strong>
<strong class="calibre1">       @language = N'R'</strong>
<strong class="calibre1">,@script = N'install.packages("AUC")'</strong>  </pre>
<p class="calibre2">This T-SQL code returns an error, saying that this package is not available for my R version. However, we will later see how to install the same package:</p>
<div class="packt_figure"><img class="aligncenter16" src="../images/00025.jpeg"/></div>
<div class="cdpaligncenter">Figure 11: Warning message while installing AUC package</div>
<p class="calibre2">So, we can extend the original stored procedure, as follows:</p>
<pre class="calibre19"><strong class="calibre1">EXECUTE sp_execute_external_script
        @language = N'R'
,@script = N'   library(Hmisc)
               u &lt;- unlist(rcorr(Customers_by_invoices$InvoiceV, Customers_by_invoices$CustCat, type="spearman"))
statistical_significance&lt;-as.character(u[10])
OutputDataSet &lt;- data.frame(statistical_significance)'

,@input_data_1 = N'SELECT
SUM(il.Quantity) AS InvoiceQ
,SUM(il.ExtendedPrice) AS InvoiceV
,c.CustomerID AS Customer
,c.CustomerCategoryID AS CustCat

                                         FROM sales.InvoiceLines AS il
                                         INNER JOIN sales.Invoices AS i
                                         ON il.InvoiceID = i.InvoiceID
                                         INNER JOIN sales.Customers AS c
                                         ON c.CustomerID = i.CustomerID
                                         GROUP BY
c.CustomerID
,c.CustomerCategoryID'

,@input_data_1_name = N'Customers_by_invoices'

WITH RESULT SETS (( statistical_significance FLOAT(20) ));
GO
</strong></pre>
<p class="calibre2">If we do this, we will be able to calculate the statistical significance for the correlation between two variables. The point here is that we are referring to the R function <kbd class="calibre11">library(Hmisc)</kbd> with the appropriate package name. The following is the detailed part of the script:</p>
<pre class="calibre19"><strong class="calibre1">-- part of R script with reference to call method library</strong>
<strong class="calibre1">,@script = N'   library(Hmisc)</strong>
<strong class="calibre1">                 u &lt;- unlist(rcorr(Customers_by_invoices$InvoiceV, Customers_by_invoices$CustCat, type="spearman"))</strong>
<strong class="calibre1">statistical_significance &lt;-as.character(u[10])</strong>
<strong class="calibre1">OutputDataSet &lt;- data.frame(statistical_significance)'</strong>  </pre>
<p class="calibre2">When referring to a library, we need to have the package already preinstalled; otherwise, you will receive an error stating that the package does not exist. The same error will be received if you misspell the package name and, since the R language is case-sensitive, in the case of the <kbd class="calibre11">Hmisc</kbd> <span>package</span>, an error will occur when mistyping it as <kbd class="calibre11">hmisc</kbd> (without the capital letter <kbd class="calibre11">H</kbd>):</p>
<div class="packt_figure"><img class="aligncenter17" src="../images/00026.jpeg"/></div>
<div class="cdpaligncenter">Figure 12</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Package information</h1>
                
            
            <article>
                
<p class="calibre2">Packages are always saved in the <span><kbd class="calibre11">library</kbd> </span>folder but, depending on your version of R (Open, Client, or Server), SQL Server instance names and paths can be different.</p>
<p class="calibre2">In general, the Client or Server versions will store your libraries on your main drive. For the Client version, the default path is <kbd class="calibre11">C:\Program Files\Microsoft\R Client\R_SERVER\library</kbd>. You can see the folder contents in the following screenshot:</p>
<div class="packt_figure"><img class="aligncenter18" src="../images/00027.jpeg"/></div>
<div class="cdpaligncenter">Figure 13</div>
<p class="calibre2">In the R Server version, you will find libraries on the path of your default SQL Server instance: <kbd class="calibre11">C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\R_SERVICES\library</kbd>. The following are the contents of a Server installation:</p>
<div class="packt_figure"><img class="aligncenter19" src="../images/00028.jpeg"/></div>
<div class="cdpaligncenter">Figure 14</div>
<p class="calibre2">Sub-folders represent the name of installed and available packages. To find the default path to your packages, you can execute the following code:</p>
<pre class="calibre19"><strong class="calibre1">-- Path to libraries on your computer/server</strong>
<strong class="calibre1">EXECUTE sp_execute_external_script</strong>
<strong class="calibre1">       @language = N'R'</strong>
<strong class="calibre1">,@script = N'OutputDataSet &lt;- data.frame(.libPaths());'</strong>
<strong class="calibre1">WITH RESULT SETS (([DefaultLibraryName] VARCHAR(MAX) NOT NULL));</strong>
<strong class="calibre1">GO</strong>  </pre>
<p class="calibre2">In my case, the following is the default path for R packages in the R Server edition:</p>
<div class="packt_figure"><img class="aligncenter20" src="../images/00029.jpeg"/></div>
<div class="cdpaligncenter">Figure 15</div>
<p class="calibre2">Much more information can be retrieved using the R function <kbd class="calibre11">installed.packages()</kbd>. In this example, we extract much more information on packages and insert the information into a SQL Server table:</p>
<pre class="calibre19"><strong class="calibre1">-- You can create a table for libraries and populate all the necessary information
CREATE TABLE dbo.Libraries
       (
               ID INT IDENTITY NOT NULL CONSTRAINT PK_RLibraries PRIMARY KEY CLUSTERED
,Package NVARCHAR(50)
,LibPath NVARCHAR(200)
,[Version] NVARCHAR(20)
,Depends NVARCHAR(200)
,Imports NVARCHAR(200)
,Suggests NVARCHAR(200)
,Built NVARCHAR(20)
       )

INSERT INTO dbo.Libraries
EXECUTE sp_execute_external_script
              @language = N'R'
,@script=N'x &lt;- data.frame(installed.packages())
OutputDataSet &lt;- x[,c(1:3,5,6,8,16)]'


SELECT * FROM dbo.Libraries
DROP TABLE dbo.Libraries
</strong></pre>
<p class="calibre2">By querying this table, you get information on library dependencies, versions, imports, and builds in one execution of <kbd class="calibre11">sp_execute_external_script</kbd>:</p>
<div class="packt_figure"><img class="aligncenter21" src="../images/00030.jpeg"/></div>
<div class="cdpaligncenter">Figure 16</div>
<p class="calibre2">In the following, we will explore how to install missing R packages. With SQL Server 2016 there were several ways (official or unofficial) which will be addressed and with SQL Server 2017, we have an elegant way of using <kbd class="calibre11">rxInstall</kbd> package or creating an external library. Both new ways introduced in SQL Server 2017 are far better, safer, and faster ways to install missing packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using R Tools for Visual Studio (RTVS) 2015 or higher</h1>
                
            
            <article>
                
<p class="calibre2">With SQL Server 2016, Microsoft recommended installing missing packages through RTVS. The user should have installed RTVS (<span><a href="https://www.visualstudio.com/vs/rtvs/" class="calibre10">https://www.visualstudio.com/vs/rtvs/</a></span>) on a client in order to install packages. Check the default paths:</p>
<pre class="calibre19"><strong class="calibre1">sessionInfo()</strong>
<strong class="calibre1">.libPaths()</strong>  </pre>
<p class="calibre2">This also returns the paths to the library folders on my machine-for R Server (by default <kbd class="calibre11">C:/Program Files/Microsoft SQL Server/MSSQL14.MSSQLSERVER/R_SERVICES/library</kbd>) and for the user (<kbd class="calibre11">C:/Users/Tomaz/Documents/R/win-library/3.2</kbd>) who is currently using RTVS:</p>
<div class="packt_figure"><img src="../images/00031.jpeg" class="calibre27"/></div>
<div class="cdpaligncenter">Figure 17</div>
<p class="calibre2">Checking the <span>Options...</span> section:</p>
<div class="packt_figure"><img src="../images/00032.jpeg" class="calibre28"/></div>
<div class="cdpaligncenter">Figure 18</div>
<p class="calibre2">Then select <span>R Tools </span>| <span>Advanced</span> (as shown next):</p>
<div class="packt_figure"><img class="aligncenter22" src="../images/00033.jpeg"/></div>
<div class="cdpaligncenter">Figure 19</div>
<p class="calibre2">You will see that the <span>R Engine</span> has a path defined. This path is the root path for installing R packages. R packages are installed under the subfolder-library (<kbd class="calibre11">C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\R_SERVICES\Library</kbd>).</p>
<p class="calibre2">So, by running <kbd class="calibre11">install.packages("AUC")</kbd>, I can see that the server path was ignored and the library was installed into the user specified folder:</p>
<div class="packt_figure"><img class="aligncenter23" src="../images/00034.jpeg"/></div>
<div class="cdpaligncenter">Figure 20</div>
<p class="calibre2">To install the package in the R Server folder, you need to have administrator-level access or have an administrator do it for you. Microsoft has discussed this issue on MSDN (<span><a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/r/installing-and-managing-r-packages" class="calibre10">https://docs.microsoft.com/en-us/sql/advanced-analytics/r/installing-and-managing-r-packages</a></span>). Running Visual Studio and RTVS as an administrator does not change the result. To avoid this problem, you need to declare the path to the library folder of the R Server where you want package to be installed:</p>
<pre class="calibre19"><strong class="calibre1">install.packages("AUC", dependencies = TRUE, lib = "C:/Program Files/Microsoft SQL Server/MSSQL14.MSSQLSERVER/R_SERVICES/library")</strong>  </pre>
<p class="calibre2">The package will automatically be installed in the R Server repository folder:</p>
<div class="packt_figure"><img src="../images/00035.jpeg" class="calibre27"/></div>
<div class="cdpaligncenter">Figure 21</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using R.exe in CMD</h1>
                
            
            <article>
                
<p class="calibre2">When executing <kbd class="calibre11">R.exe</kbd> as an administrator in the binary folder of R Server (<kbd class="calibre11">C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\R_SERVICES\bin</kbd>), you will be prompted with a command window:</p>
<div class="packt_figure"><img class="aligncenter24" src="../images/00036.jpeg"/></div>
<div class="cdpaligncenter">Figure 22</div>
<p class="calibre2">From there, the user can always install the missing package.</p>
<pre class="calibre19"><strong class="calibre1">install.packages("AUC")</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using XP_CMDSHELL</h1>
                
            
            <article>
                
<p class="calibre2">This method is by far the fastest and is very useful when sharing T-SQL code, but it compromises using the command shell and many users and DBAs are not keen on this. By enabling <kbd class="calibre11">xp_cmdshell</kbd> in configurations and using this stored procedure, you can install any missing package. Using code with the <kbd class="calibre11">-e</kbd> switch, you can easily install the library:</p>
<pre class="calibre19"><strong class="calibre1">R cmd -e install.packages("Hmisc")</strong>  </pre>
<p class="calibre2">The following code will install the missing package on the R Server:</p>
<pre class="calibre19"><strong class="calibre1">-- enable xp_cmdshell</strong>
<strong class="calibre1">EXECUTE SP_CONFIGURE 'xp_cmdshell','1';</strong>
<strong class="calibre1">GO</strong>
    
<strong class="calibre1">RECONF</strong><strong class="calibre1">IGURE;</strong>
<strong class="calibre1">GO </strong>
<strong class="calibre1">EXEC xp_cmdshell '"C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\R_SERVICES\bin\R.EXE"cmd -e</strong></pre>
<pre class="calibre19"><strong class="calibre1">install.packages(''Hmisc'')';   </strong>
<strong class="calibre1">GO</strong>  </pre>
<p class="calibre2">Running Vanilla R and adding the <kbd class="calibre11">install.packages()</kbd> function can be done if the user has been granted the permission. The results are as follows:</p>
<div class="packt_figure"><img src="../images/00037.jpeg" class="calibre29"/></div>
<div class="cdpaligncenter">Figure 23</div>
<p class="calibre2">Using CMD and the <kbd class="calibre11">-e</kbd> switch, the deployment and computation of R code can be executed and simplified, but since this is not an official way I would not suggest using this, since it exposes security issues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Copying files</h1>
                
            
            <article>
                
<p class="calibre2">Copying files may sound a bit strange at first glance but, for the majority of packages, copying the complete library folder to the destination folder will also do the job. Imagine being a system administrator responsible for configuring a new R environment or sandbox. In this scenario, you don't want to run hundreds of lines of code to install all the needed packages; so, you would just copy/paste the folders from an image or backup. This would be a hundred times faster and much more convenient. Also, the packages would be already tested with R Engine.</p>
<p class="calibre2">Using a simple copy/paste, drag, and drop opretion, I copied and installed the, <kbd class="calibre11">acepack</kbd> package in my R Client environment (copied from R Server):</p>
<div class="packt_figure"><img class="aligncenter25" src="../images/00038.jpeg"/></div>
<div class="cdpaligncenter">Figure 24</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the rxInstallPackages function</h1>
                
            
            <article>
                
<p class="calibre2">With the new version of SQL Server R Services for SQL Server 2017, a very much needed R function-in the <kbd class="calibre11">RevoScaleR</kbd> package-has been made publicly available. With the <kbd class="calibre11">rxInstallPackages</kbd> function, a user will be capable of installing any additional R package for a desired computational context.</p>
<p class="calibre2">With the following code, one can really speed up the installation of packages, without worrying about workarounds, opening additional tools, or anything else.</p>
<p class="calibre2">Running code from RTVS looks as follows:</p>
<pre class="calibre19"><strong class="calibre1">RSQLServicesCC &lt;- RxInSqlServer(connectionString = "Driver=SQL Server;Server=myServer;Database=TestDB;Trusted_Connection=True;")</strong>
    
<strong class="calibre1">rxInstallPackages("AUC", verbose = TRUE, scope = "private", computeContext = RSQLServicesCC)</strong>  </pre>
<p class="calibre2">Running the same code from SQL Server is as follows:</p>
<pre class="calibre19"><strong class="calibre1">EXECUTE sp_execute_external_script </strong><br class="title-page-name"/><strong class="calibre1">      @language = N'R' </strong><br class="title-page-name"/><strong class="calibre1">           ,@script = N'</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">            packagesToInstall &lt;- c("caret","tree","party") library(MicrosoftML) </strong><br class="title-page-name"/><strong class="calibre1">            RSqlServerCC &lt;- RxInSqlServer(connectionString = "Driver=SQL Server; +Server=SICN-KASTRUN\\SQLSERVER2017C2;Database=SQLR; +Trusted_Connection=True;") </strong><br class="title-page-name"/><strong class="calibre1">            rxInstallPackages(pkgs = packagesToInstall, owner = '', +scope = "shared", computeContext = "SqlServerCC");'; </strong><br class="title-page-name"/><strong class="calibre1">GO</strong></pre>
<p class="calibre2">This is way too easy to be true, but it is. Make sure to do couple of things prior to running this code:</p>
<ul class="calibre7">
<li class="calibre8">Set the compute environment to where your packages are installed</li>
<li class="calibre8">Set up the correct permissions and access</li>
<li class="calibre8">Check up on the TCP/IP protocols</li>
</ul>
<p class="calibre2">In the <kbd class="calibre11">rxInstallPackages</kbd> function, use the <kbd class="calibre11">computeContext</kbd> parameter to set either <kbd class="calibre11">Local</kbd> or your <kbd class="calibre11">SqlServer</kbd> environment; you can also use scope as shared or private (the difference is that, if you install a package as shared, it can be used by different users across different databases). You can also specify the owner if you are running this command out of the <kbd class="calibre11">db_owner</kbd> role.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing SQL Server R Services with PowerShell</h1>
                
            
            <article>
                
<p class="calibre2">PowerShell is very useful for managing remote machines, virtual machines, or even Azure VM machines. Besides this common administrative work, it has many other positive and useful benefits.</p>
<p class="calibre2">One can list, schedule, or work with any task-scheduled jobs or SQL Server jobs, based on what jobs you need to be running, and how, let's say daily for fetching data or recalculating and initializing predictive models, to even running models.</p>
<p class="calibre2">Another very useful aspect of PowerShell can be API communication within different environments and systems.</p>
<p class="calibre2">For system administrators, PowerShell will be very useful for distributing and maintaining any additional R packages among client machines or even among R Server servers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting to know the sp_execute_external_script external procedure</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">SP_EXECUTE_EXTERNAL_SCRIPT</kbd> is a stored procedure that executes a provided script as an argument on an external script to a provided language (in this case, the R language). With SQL Server 2017, Python is also supported and it is said that, in the future, other languages, such as Java, C#, and C++, will be supported (through Launchpad).</p>
<p class="calibre2"><kbd class="calibre11">sp_execute_external_script</kbd> is a system procedure that evokes and sends the passed code to an external engine and returns the result to SQL Server in the form of a table. Script has a set of arguments that will navigate to T-SQL code and data to R Engine, with R code included.</p>
<p class="calibre2">The following arguments are available:</p>
<pre class="calibre19"><strong class="calibre1">sp_execute_external_script</strong>
<strong class="calibre1">     @language = N''</strong>
<strong class="calibre1">,@script = N'',  </strong>
<strong class="calibre1">,@input_data_1 =  'input_data_1'</strong>
<strong class="calibre1">,@input_data_1_name =  N'input_data_1_name'</strong>
<strong class="calibre1">,@output_data_1_name = 'output_data_1_name'</strong>
<strong class="calibre1">,@parallel = 0 | 1   </strong>
<strong class="calibre1">,@params =  N''</strong>
<strong class="calibre1">,@parameter1 = ''</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Arguments</h1>
                
            
            <article>
                
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">@language</kbd>: This specifies which language will be used in the external procedure. For SQL Server 2016, the R language is available and with SQL Server 2017 Python is available. The argument is of the <kbd class="calibre11">sysname</kbd> build-in data type and has a limit of 128 Unicode characters. This is why we use N in front of the value, to denote the <kbd class="calibre11">nvarchar</kbd> type.</li>
<li class="calibre8"><kbd class="calibre11">@script</kbd>: Native R or Python code is passed with this argument to the Launchpad service. This external code (external to SQL Server) must be validated and properly formatted (only in the case of Python), since SSMS or RTVS will not validate this argument. Therefore, the easiest way to do this is to use Visual Studio and validate your R code in RTVS or your Python code with <strong class="calibre1">Python Tools for Visual Studio </strong>(<strong class="calibre1">PTVS</strong>). This field is of the <kbd class="calibre11">nvarchar</kbd> type.</li>
<li class="calibre8"><kbd class="calibre11">@input_data_1</kbd>: This takes your T-SQL code as the source of data for an external procedure. This code will be validated and checked by SSMS or VS. This field is also the <kbd class="calibre11">nvarchar</kbd> type and can execute literally any T-SQL code. There are a few limitations as to what data types can be inputted, because of external engine (the R language) limitations. The R language itself supports fewer data types as compared with SQL Server 2016. Data types supported are logical, numeric, integer, complex, character, and raw. So immediately, one can see that the following data types (unless converted to the R data type) will deliver some problems. Let's just state a few SQL Server data types:
<ul class="calibre17">
<li class="calibre8"><kbd class="calibre11">Cursor</kbd></li>
</ul>
<ul class="calibre17">
<li class="calibre8"><kbd class="calibre11">Timestamp</kbd> (hash format not date time format)</li>
<li class="calibre8"><kbd class="calibre11">Datetime2</kbd>, <kbd class="calibre11">datetimeoffset</kbd>, <kbd class="calibre11">time</kbd></li>
<li class="calibre8">All Unicode text data types: <kbd class="calibre11">nvarchar</kbd>, <kbd class="calibre11">nchar</kbd>, <kbd class="calibre11">ntext</kbd></li>
<li class="calibre8"><kbd class="calibre11">Sql_variant</kbd></li>
<li class="calibre8"><kbd class="calibre11">Text</kbd>, <kbd class="calibre11">image</kbd></li>
<li class="calibre8"><kbd class="calibre11">XML</kbd> (includingJSON, as it is an XML datatype format in SQL Server 2017)</li>
<li class="calibre8"><kbd class="calibre11">Hierarchy</kbd>, <kbd class="calibre11">geometry</kbd>, <kbd class="calibre11">geography</kbd></li>
<li class="calibre8">Any CLR or assembly bound data type built using the .NET framework or any Launchpad service-supported language</li>
</ul>
</li>
</ul>
<p class="calibre2">In addition to some of the data types' limitations, there are also T-SQL clauses and statements that cannot be used as part of the input data argument. These are as follows:</p>
<ul class="calibre7">
<li class="calibre8">Stored procedure (UDF, Table value functions))</li>
<li class="calibre8">Logical <kbd class="calibre11">IF</kbd> and <kbd class="calibre11">WHILE</kbd>, <kbd class="calibre11">FOR</kbd> loops</li>
<li class="calibre8">Temporary variables or tables</li>
<li class="calibre8">No updates, inserts, or deletes (only select)</li>
<li class="calibre8"><kbd class="calibre11">GO</kbd> statements or semicolons</li>
<li class="calibre8"><kbd class="calibre11">OUTPUT</kbd> clauses from and DML statements</li>
<li class="calibre8">Referencing any CURSORS</li>
</ul>
<p class="calibre2">The following statements (besides the <kbd class="calibre11">SELECT</kbd> statement) can be used:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">SELECT</kbd> with multiple <kbd class="calibre11">JOINS</kbd></li>
<li class="calibre8"><kbd class="calibre11">WITH</kbd>commontable expressions</li>
<li class="calibre8"><kbd class="calibre11">UNION</kbd>, <kbd class="calibre11">UNIONALL</kbd>, <kbd class="calibre11">EXCEPT</kbd>, <kbd class="calibre11">INTERSECT</kbd></li>
<li class="calibre8">Any <kbd class="calibre11">SET</kbd>, <kbd class="calibre11">STRING</kbd>, <kbd class="calibre11">LOGICAL</kbd>, <kbd class="calibre11">COMPARISON</kbd>, <kbd class="calibre11">BITWISE</kbd>, <kbd class="calibre11">ARITHMETIC</kbd>, <kbd class="calibre11">COMPOUND</kbd> operators</li>
<li class="calibre8">
<p class="calibre9"><kbd class="calibre11">COLLATE</kbd></p>
</li>
</ul>
<p class="calibre2">As already mentioned DML statements, <kbd class="calibre11">@input_data_1</kbd> argument also does not support any DDL statement or clause.</p>
<p class="calibre2">To avoid the data type collisions between the T-SQL language and external scripts, the best practice is to do as much data preparation, wrangling, and optimization as possible prior to throwing the desired dataset into the argument. Also, many restrictions can be compromised with conversion to the R closed data type.</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">@input_data_1_name</kbd>:This holds the name of the dataset that will be used in the R script as an input dataset. By default, the external procedure <kbd class="calibre11">sp_execute_external_script</kbd> will be using the following:-<kbd class="calibre11">InputDataSet</kbd> for inputting data and-<kbd class="calibre11">OutputDataSet</kbd> for returning result data (both are default values). Please note that the R language is case-sensitive, so the name of your dataset provided in this argument must be written in the same manner also in R code.</li>
<li class="calibre8"><kbd class="calibre11">@output_data_1_name</kbd>:This argument holds the definition of the returned result from an external script as a variable returned to any stored procedure. The returned dataset must be in the <kbd class="calibre11">data.frame</kbd> format in the R language. Data.frame is a set of vectors and is a representation of a table, which T-SQL Server can import and use further with any other T-SQL clause or statement: or it can store the results directly into SQL Server table. This argument is a <kbd class="calibre11">sysname</kbd> data type.</li>
<li class="calibre8"><kbd class="calibre11">@parallel</kbd>:This is an argument that will explicitly tell the R Engine to parallelize computations in R. This parameter has been introduced with later versions of SQL Server 2016 (SP/CU) and is very welcome for any type of R code, functions, or packages that do not use parallelism for <kbd class="calibre11">RevoScaleR</kbd> computational functions. Of course, this is true in relation to trivial R scripts and in the case of large input datasets. R functions from a particular R package will deliver much better performance results if the package itself is written in C++ (and not the original Fortran) and, if the R script does not include relatively complex data wrangling/munching instructions, in particular and of <kbd class="calibre11">plyr</kbd>/<kbd class="calibre11">dplyr</kbd> or <kbd class="calibre11">data.table</kbd> function. Just remember the simpler, the better.</li>
</ul>
<p class="calibre2">To check whether the workload can be distributed in parallel, simply observe the execution plans and look for degrees of parallelism in the plan when running T-SQL code. Also note that any local setting of MAXDOP will also have an effect on the desired parallelism. In other words, if MAXDOP is turned off, and you set your argument <kbd class="calibre11">@parallel = 1</kbd>, do not expect much of a distributed workload, since parallelism is by default turned off.</p>
<p class="calibre2">When running and using any of the computational functions available in the <kbd class="calibre11">RevoScaleR</kbd> package, Launchpad will automatically take care of parallelism, using distribute R functions, available in R Server or SQL Server R Services.</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">@params</kbd>: This is an argument where any additional variable can be declared and specified as a variable(s) that can be used in the R script. The parameters can be specified as input or output and are very handy when feeding the predictive model to your R code or when exporting additional information from R code (besides the specified results set). Using this parameter as an output can return a single value/column and not a table.</li>
<li class="calibre8"><kbd class="calibre11">@parameter1</kbd>: This is an argument where the values of the parameters are specified and used within the R script in the form of an input or output variable.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter has covered the installation of Machine Learning Services (in-database), the configuration of the services and how to administrate the services. It has also explored the installation of missing packages and covered security and the resource governor. In the last section, the chapter also gives an explanation of how to use external procedures and the <kbd class="calibre11">sp_execute_external_script</kbd> with all arguments. Several examples have been covered through digging into security issues and the installation of missing packages. The installation of missing packages was heavily dependent on the article in SQLServerCentral.</p>
<p class="calibre2">An introduction to machine learning services and using an external procedure will be the foundation for all of the following chapters, which will all heavily rely on a good understanding of configuring and using this procedure.</p>


            </article>

            
        </section>
    </body></html>