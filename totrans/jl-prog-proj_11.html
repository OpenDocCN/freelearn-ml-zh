<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Julia Packages</h1>
                </header>
            
            <article>
                
<p class="calibre2">We've come a long way since the beginning of our journey toward learning Julia. I hope you enjoyed this process of discovery as much as I did! We've covered a lot of ground, learning about many key topics while developing quite a suite of fully functional applications. Yet, there's one thing left in order to fully earn our Julia developer badge. The signature of every proficient Julia programmer—(drumroll, please!)—creating, publishing, and registering our own <em class="calibre16">official</em> Julia package!</p>
<p class="calibre2">In this chapter, we'll build a REPL app and we'll wrap it into a package. Our product will help Julia developers to easily report bugs they encounter in other Julia packages. Once the users install and configure our package, they will be able to open GitHub issues into the corresponding repo, without having to leave their REPL or IDE. In the process, we'll learn about many other very important aspects of programming with Julia, such as the following:</p>
<ul class="calibre10">
<li class="calibre11">Using Pkg to scaffold packages</li>
<li class="calibre11">Package versioning and dependencies</li>
<li class="calibre11">Test-driven development in Julia and how to unit test our code</li>
<li class="calibre11">Benchmarking and performance optimization</li>
<li class="calibre11">Interacting with the GitHub API</li>
<li class="calibre11">Documenting the code base and generating documentation</li>
<li class="calibre11">Publishing packages (with a little help from Julia's bots!)</li>
</ul>
<p class="calibre2">Ready? I sure hope so. Let's go!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="calibre2">The Julia package ecosystem is under continuous development and new package versions are released on a daily basis. Most of the times this is great news, as new releases bring new features and bug fixes. However, since many of the packages are still in beta (version 0.x), any new release can introduce breaking changes. As a result, the code presented in the book can stop working. In order to ensure that your code will produce the same results as described in the book, it is recommended to use the same package versions. Here are the external packages used in this chapter and their specific versions:</p>
<pre class="calibre17">BenchmarkTools@v0.4.1<br class="title-page-name"/>DocStringExtensions@v0.6.0<br class="title-page-name"/>Documenter@v0.21.0<br class="title-page-name"/>GitHub@v5.0.2<br class="title-page-name"/>IJulia@v1.14.1<br class="title-page-name"/>Traceur@v0.2.0<br class="title-page-name"/>URIParser@v0.4.0</pre>
<p class="calibre2">In order to install a specific version of a package you need to run:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add PackageName@vX.Y.Z</strong> </pre>
<p class="calibre2">For example:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add IJulia@v1.14.1</strong></pre>
<p class="calibre2">Alternatively you can install all the used packages by downloading the <kbd class="calibre12">Project.toml</kbd> file provided with the chapter and using <kbd class="calibre12">pkg&gt;</kbd> instantiate as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; download("https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter11/Project.toml", "Project.toml")</strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; activate . </strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; instantiate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new Julia package</h1>
                </header>
            
            <article>
                
<p class="calibre2">In order to create a new package, we must first satisfy a few prerequisites. To start with, we need <kbd class="calibre12">git</kbd> installed and configured on the development machine. The obvious reason for this is that, by default, Julia uses <kbd class="calibre12">git</kbd> and <span class="calibre5">GitHub (<a href="https://github.com/" class="calibre9">https://github.com/</a>)</span> to host packages (although third-party, including private package, registries can also be used). If your current choice of operating system does not come with <kbd class="calibre12">git</kbd> preinstalled, please visit <a href="https://git-scm.com/downloads" class="calibre9"><span>https://git-scm.com/downloads</span></a> for the official download page. Pick the right version for your OS and follow the installation instructions.</p>
<p class="calibre2">Second, if you don't already have a GitHub account, you'll need one. Please visit <a href="https://github.com" class="calibre9"><span>https://github.com</span></a> and set up a free account.</p>
<p class="calibre2">Now that we have <kbd class="calibre12"><span>git</span></kbd> installed and a GitHub account, let's set up some global configuration options, as they'll come in handy. Open a new Terminal window and execute the following—please make sure to replace the placeholder text within <span class="calibre5"><kbd class="calibre12">&lt;...&gt;</kbd></span> with your actual information:</p>
<pre class="calibre17"><strong class="calibre1">$ git config --global user.name "&lt;FULL_NAME&gt;" 
$ git config --global user.email "&lt;EMAIL&gt;" 
$ git config --global github.user "&lt;GITHUB_USERNAME&gt;"</strong> </pre>
<p class="calibre2">So for example, in my case, the first command will be as follows:</p>
<pre class="calibre17"><strong class="calibre1">$ git config --global user.name "Adrian Salceanu"</strong> </pre>
<p class="calibre2">Please check that all went well by running <kbd class="calibre12"><span>git config -l</span></kbd><span class="calibre5">. </span>You should get an output similar to mine:</p>
<pre class="calibre17"><strong class="calibre1">$ git config -l 
user.name=Adrian Salceanu 
user.email=**@**  
github.user=essenciary</strong> </pre>
<p class="calibre2">Excellent! We're now ready to get down to the business of setting up our package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating packages </h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia's package manager, <kbd class="calibre12">Pkg</kbd>, expects a certain file structure in order to manage dependencies, run tests, build binaries, generate documentation, and so on. Thankfully, we don't have to create all these manually: we will use <kbd class="calibre12">Pkg</kbd> itself, namely the <kbd class="calibre12">generate</kbd> command. All we need to do is pass it the name of our package. Let's call it <kbd class="calibre12">IssueReporter</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ] # enter Pkg mode pkg&gt; generate IssueReporter Generating project IssueReporter: IssueReporter/Project.toml IssueReporter/src/IssueReporter.jl</strong> </pre>
<p class="calibre2">A new folder was created for us, named <kbd class="calibre12">IssueReporter/</kbd>. Within it, we can find a <kbd class="calibre12">Project.toml</kbd> file and a subfolder, <kbd class="calibre12">src/</kbd>, which includes an <kbd class="calibre12">IssueReporter.jl</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Project.toml file</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">Project.toml</kbd> file is very special for <kbd class="calibre12">Pkg</kbd>, as it's used for managing packages and their dependencies. It is meant to include meta-information, such as the name of the package, its unique identifier (called the <strong class="calibre4">UUID</strong>), the version number, the author's name, and the list of dependencies. <kbd class="calibre12">Pkg</kbd> has already prepopulated it, to get us started:</p>
<pre class="calibre17">authors = ["Adrian Salceanu &lt;*@*.com&gt;"] # actual email truncated 
name = "IssueReporter" 
uuid = "7b29c13e-f3eb-11e8-2be5-fb20b77ad364" 
version = "0.1.0" 
 
[deps] </pre>
<p class="calibre2"><span class="calibre5">As you can see, </span><kbd class="calibre12">Pkg</kbd> <span class="calibre5">has picked up the correct author information based on my Git settings; it has filled up the package</span><span class="calibre5">'s name and generated a new UUID, and assigned the version number <kbd class="calibre12">0.1.0</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The src folder and the main module</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">src/</kbd> folder also plays a special role. A path of the form <kbd class="calibre12">&lt;Package Name&gt;/src/&lt;Package Name&gt;.jl</kbd> is used by Julia to identify the entry point into a package—that is, its main module. This path will be searched when we invoke <kbd class="calibre12">using IssueReporter</kbd>. To get us to a good start, the <kbd class="calibre12">IssueReporter.jl</kbd> file has already been filled up with a few lines of code, just enough to bootstrap the corresponding module:</p>
<pre class="calibre17">module IssueReporter 
 
greet() = print("Hello World!") 
 
end # module </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using our new package</h1>
                </header>
            
            <article>
                
<p class="calibre2">We can now activate the project and load our package:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ; # enter shell mode 
shell&gt; cd IssueReporter 
julia&gt; ] # enter pkg mode 
pkg&gt; activate . 
(IssueReporter) pkg&gt; </strong> </pre>
<p class="calibre2">At this point, our package's environment has been activated and the included modules are available:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using IssueReporter 
[ Info: Precompiling IssueReporter [7b29c13e-f3eb-11e8-2be5-fb20b77ad364] 
 
julia&gt; IssueReporter.greet() 
Hello World!</strong> </pre>
<p class="calibre2">Excellent—everything is set up and ready for us to add logic, tests, and documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the requirements for our package</h1>
                </header>
            
            <article>
                
<p class="calibre2">The goal of our project is to create a Julia package that will make it very easy to report bugs in other Julia packages. We want to allow the users of our library to access a simple API for programmatic reporting of issues, without the need to go to <span class="calibre5">GitHub (<a href="https://github.com/" class="calibre9">https://github.com/</a>)</span> to manually create a new issue.</p>
<p class="calibre2">In order to do this, we need to implement the following two features—a way to find out the GitHub URL of a registered package; and the means to access the GitHub API to register a new issue on the found repo. Given that <kbd class="calibre12">Pkg</kbd> is capable of cloning a package from GitHub using only the name of the package, we can safely assume that the information is available with our Julia install, and that somehow we'll be able to access that information ourselves. Then, the aptly named <kbd class="calibre12"><span>GitHub</span></kbd> package will help us to interface with GitHub's API. We can start by adding it. Please make sure that the currently active project is <kbd class="calibre12">IssueReporter</kbd>. This should be indicated by the <kbd class="calibre12">(IssuerReporter)</kbd> prefix, placed in front of the <kbd class="calibre12">pkg&gt;</kbd> cursor. If that is not the case, as previously explained, you need to <kbd class="calibre12">cd</kbd> into our package's directory and then run <kbd class="calibre12">pkg&gt; activate .</kbd> as follows:</p>
<pre class="calibre201"><strong class="calibre1">(IssueReporter) pkg&gt; add GitHub </strong> </pre>
<p class="calibre2">While we're at it, let's also add the <kbd class="calibre12"><span>URIParser</span></kbd> package—we'll work a lot with repo URLs and this functionality will come in handy:</p>
<pre class="calibre17"><strong class="calibre1">    <span>(IssueReporter) pkg&gt; add URIParser </span> </strong> </pre>
<p class="calibre2">And, one more thing—we'll use <strong class="calibre4">test-driven development</strong> (<strong class="calibre4">TDD</strong>) in order to build our project, so we'll also need Julia's <kbd class="calibre12">Test</kbd> module:</p>
<pre class="calibre17"><strong class="calibre1">    <span>(IssueReporter) pkg&gt; add Test</span></strong></pre>
<p class="calibre2">At this point, all the packages have been added to the list of dependencies. You can confirm this by checking the <kbd class="calibre12">Project.toml</kbd> file, which is under the <kbd class="calibre12">[deps]</kbd> section and should now show the following:</p>
<pre class="calibre17">[deps] 
GitHub = "bc5e4493-9b4d-5f90-b8aa-2b2bcaad7a26" 
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40" 
URIParser = "30578b45-9adc-5946-b283-645ec420af67" </pre>
<p class="calibre2">Now we have all the prerequisites for adding our logic, the TDD way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Beginning with test-driven Julia development</h1>
                </header>
            
            <article>
                
<p class="calibre2">Test-driven development is a software development practice based on a simple workflow that puts automated testing center stage. The basic idea is that the requirements are turned into very specific, well-defined, and targeted test cases. Each test should address only one piece of functionality. Once the test is ready, we run the whole test suite. Obviously, as we first write the test, it will initially fail. Next, we add the minimal implementation to make the test pass. That's it—all we need to do is repeat the same process until all the requirements are implemented. This approach ensures that our code base is thoroughly tested and that we focus on delivering just the requirements, avoiding feature creep.</p>
<p class="calibre2">Julia provides built-in unit testing capabilities under the <kbd class="calibre12"><span>Test</span></kbd> module. It is very straightforward and easy to use, providing enough methods to cover all the basic testing scenarios: value and exception checking, approximate values, types, and so on.</p>
<p class="calibre2">The most important ones are the <kbd class="calibre12"><span>@test</span></kbd>, <kbd class="calibre12"><span>@test_throws</span></kbd>, and <kbd class="calibre12"><span>@testset</span></kbd> macros. The <kbd class="calibre12"><span>@test</span></kbd> macro checks that the <kbd class="calibre12">expression</kbd> passed as argument evaluates to <span class="calibre5">true</span>, returning a <kbd class="calibre12"><span>PassResult</span></kbd>. If the test does not pass, it will return either a <kbd class="calibre12"><span>FailResult</span></kbd> when the expression evaluates to <kbd class="calibre12"><span>false</span></kbd>—or an <kbd class="calibre12"><span>ErrorResult</span></kbd> if the expression can't be evaluated at all. The <kbd class="calibre12"><span>@test_throws</span></kbd> macro checks that the evaluated expression throws an exception. Finally, <kbd class="calibre12"><span>@testset</span></kbd> is used to group tests into sets. All the tests in a test set will run, and at the end of the test set, a summary of the results will be displayed. If any of the tests failed, or could not be evaluated due to an error, the test set will throw a <kbd class="calibre12"><span>TestSetException</span></kbd>.</p>
<p class="calibre2">For example, consider the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Test 
 
julia&gt; @test 1 == 1 
Test Passed 
 
julia&gt; @test 'A' == 'a' 
Test Failed 
  Expression: 'A' == 'a' 
   Evaluated: 'A' == 'a' 
ERROR: There was an error during testing 
# output omitted #</strong> </pre>
<p class="calibre2">The previous snippet shows the output from both a passing and a failing test. The following one illustrates the use of test sets, with one passing and one failing test:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @testset "Example" begin 
           @test :a == :a 
           @test 'x' == 'y' 
       end 
Example: Test Failed 
  Expression: 'x' == 'y' 
   Evaluated: 'x' == 'y' 
 
Test Summary: | Pass  Fail  Total 
Example       |    1     1      2 
ERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 0 broken. 
# output omitted #</strong> </pre>
<p class="calibre2">Finally, this is how exceptions are handled:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @testset "Example" begin 
           error("Oh no!") 
       end 
Example: Error During Test 
  Got an exception of type ErrorException outside of a @test 
  Oh no! 
 
Test Summary: | Error  Total 
Example       |     1      1 
ERROR: Some tests did not pass: 0 passed, 0 failed, 1 errored, 0 broken. 
# output omitted #</strong> </pre>
<p class="calibre2">Now that we have the testing theory covered, let's continue by writing our first test. We will need a method that will take a package name and return the corresponding GitHub repo URL. This URL will be used in order to later interact with the GitHub API and open the issue into the corresponding repo. For now, we'll just check that the return value is a valid URL. We'll use the <kbd class="calibre12"><span>URIParser</span></kbd> package to check the validity.</p>
<p class="calibre2">Julia makes it easy to add and run tests for our package, again, through the functionality provided by <kbd class="calibre12">Pkg</kbd> under the <kbd class="calibre12">test</kbd> command. When we run <kbd class="calibre12">(IssueReporter) pkg&gt; test</kbd>, the <kbd class="calibre12">Pkg</kbd> library will look for a file called <kbd class="calibre12">runtests.jl</kbd> in the <kbd class="calibre12">test/</kbd> folder.</p>
<p class="calibre2">Time to add them—from within the Julia REPL:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; mkdir("test") 
"test" 
 
julia&gt; touch("test/runtests.jl") 
"test/runtests.jl"</strong> </pre>
<p class="calibre2">Now, open the newly created <kbd class="calibre12">runtests.jl</kbd> file in the editor, for example, by running the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; edit("test/runtests.jl")</strong> </pre>
<p class="calibre2">Please make sure your <kbd class="calibre12"><span>runtests.jl</span></kbd> file looks like this:</p>
<pre class="calibre17"><strong class="calibre1">using IssueReporter 
using Test, URIParser, GitHub 
 
@testset "Basic features" begin 
  @testset "Looking up an existing package returns a proper repo URI" begin 
    @test IssueReporter.packageuri("DataFrames") |&gt; URIParser.isvalid 
  end 
end</strong> </pre>
<p class="calibre2">In this snippet, we define a test set called <kbd class="calibre12">"Basic features"</kbd>. Within it, we have yet another test set, which contains the actual test. Finally, the test invokes a function called <kbd class="calibre12">packageuri</kbd> from the <kbd class="calibre12">IssueReporter</kbd> module, passing it the  <kbd class="calibre12">DataFrames</kbd> string as its argument. What we're trying to do here is get the GitHub URI for a package that we know exists and is registered, namely <kbd class="calibre12">DataFrames</kbd>. Then, we make sure that the URI is valid by passing it into the <kbd class="calibre12">URIParser.isvalid</kbd> method.</p>
<p class="calibre2">A test set block, defined by the <kbd class="calibre12">@testset</kbd> macro, groups multiple tests and/or other tests sets. The reason for using test sets is that when a test fails, an exception is thrown, causing the execution of the script to stop. However, when we have a large batch of tests, we usually prefer to allow all the tests to run and get a full report of what failed and what worked. With a test set, all the tests within the set will be run and a summary will be displayed at the end of the set. If any of the tests fail, or cannot be evaluated due to an error, the test set will then throw a <kbd class="calibre12">TestSetException</kbd>.</p>
<p class="calibre2">Test sets should have self-explanatory names relevant to the batch of tests they represent, as these labels are outputted when the tests are run.</p>
<p class="calibre2">We can run the test as follows:</p>
<pre class="calibre17"><strong class="calibre1"> (IssueReporter) pkg&gt; test</strong></pre>
<p class="calibre2">It will fail with an informative message:</p>
<pre class="calibre17"><strong class="calibre1">(IssueReporter) pkg&gt; test 
   Testing IssueReporter 
 Resolving package versions... 
Looking up an existing package returns a proper repo URI: Error During Test at IssueReporter/test/runtests.jl:7 
  Test threw exception 
  Expression: IssueReporter.packageuri("DataFrames") |&gt; URIParser.isvalid 
  UndefVarError: packageuri not defined 
Test Summary:                                              | Error  Total 
Basic features                                             |     1      1 
  Looking up an existing package returns a proper repo URI |     1      1 
ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 1 errored, 0 broken. 
ERROR: Package IssueReporter errored during testing 
# output omitted #</strong> </pre>
<p class="calibre2">The important bit is <kbd class="calibre12">UndefVarError: packageuri not defined</kbd>. This is unsurprising, as we have not yet defined the <kbd class="calibre12">IssueReporter.packageuri</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Peeking into Julia's registry</h1>
                </header>
            
            <article>
                
<p class="calibre2">As we were saying, we need a way to retrieve the GitHub URI of a package, based on the package's name. Now, given that we're able to successfully execute operations such as <kbd class="calibre12">add</kbd> and <kbd class="calibre12">develop</kbd> with <kbd class="calibre12">Pkg</kbd>, without having to provide the GitHub URI, we can assume that there is a way to convert a package name to a package URL.</p>
<p class="calibre2">Indeed, Julia manages a repository of all the packages that are known to <kbd class="calibre12">Pkg</kbd>. These packages are grouped into multiple registries that are copied to your computer. By default, Julia comes with the so-called <kbd class="calibre12">General</kbd> registry, which can be found in the <kbd class="calibre12">.julia/</kbd> folder in your home directory. The <kbd class="calibre12">General</kbd> registry itself is nothing but a folder that contains subfolders named after each letter in the English alphabet (thus, from <kbd class="calibre12">A</kbd> to <kbd class="calibre12">Z</kbd>). Within each of these folders, we can find all the packages whose names start with that letter:</p>
<p class="CDPAlignCenter"><img src="assets/6abab19b-7d55-4b66-b195-3497520fd947.png" class="calibre202"/></p>
<p class="calibre2">This screenshot shows a part of the <kbd class="calibre12">General</kbd> registry, with some of its folders (from <kbd class="calibre12">A</kbd> to <kbd class="calibre12">D</kbd>) and some of the packages starting with the letter <kbd class="calibre12">D</kbd>.</p>
<p class="calibre2">In order to make package retrieval more efficient, a special index file, called <kbd class="calibre12">Registry.toml</kbd>, is also placed inside the <kbd class="calibre12">General</kbd> folder. This file defines a hash-based index that maps package UUIDs to a dictionary of <kbd class="calibre12">name</kbd> and <kbd class="calibre12">path</kbd> values—the path being relative and pointing to a folder within the <kbd class="calibre12">General</kbd> registry. For example, this is the entry corresponding to the <kbd class="calibre12">D3Trees</kbd> package, the first one under the letter <kbd class="calibre12">D</kbd>:</p>
<pre class="calibre17">e3df1716-f71e-5df9-9e2d-98e193103c45 = { name = "D3Trees", path = "D/D3Trees" } </pre>
<p class="calibre2">Moving on, if we peek into the <kbd class="calibre12">D3Trees/</kbd> folder itself, we'll see that it contains four files, each of them containing important metadata:</p>
<p class="CDPAlignCenter"><img src="assets/60224858-81ad-498f-9ca5-402cd18423fb.png" class="calibre203"/></p>
<p class="calibre2">The screenshot shows the four <kbd class="calibre12">Pkg</kbd> metadata files belonging to the <kbd class="calibre12">D3Trees</kbd> package.</p>
<p class="calibre2">The <kbd class="calibre12">Deps.toml</kbd> file includes the list of dependencies (those packages required by <kbd class="calibre12">D3Trees</kbd> itself). The <kbd class="calibre12">Compat.toml</kbd> file stores compatibility requirements for the dependencies and for the Julia versions. <kbd class="calibre12">Package.toml</kbd> defines information such as name, UUID, and repo URL, and finally, <kbd class="calibre12">Versions.toml</kbd> shows all the known versions of <kbd class="calibre12">D3Trees</kbd> together with their corresponding Git references. It looks like we need the information within the <kbd class="calibre12">Package.toml</kbd> file.</p>
<p class="calibre2">The workflow, then, is the following:</p>
<ol class="calibre13">
<li class="calibre11">Get the path to Julia's <kbd class="calibre12">General</kbd> registry</li>
<li class="calibre11">Read the <kbd class="calibre12">Registry.toml</kbd> <span>file</span></li>
<li class="calibre11">Look for a package with the name that we're searching for</li>
<li class="calibre11">If the package exists, get its path in the <kbd class="calibre12">General</kbd> <span>registry</span></li>
<li class="calibre11">Read the corresponding <kbd class="calibre12">Package.toml</kbd> <span>file</span></li>
<li class="calibre11">Extract the package's GitHub URL</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with TOML files</h1>
                </header>
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Tom's Obvious, Minimal Language</strong> (<strong class="calibre4">TOML</strong>) is a minimal configuration file format created by Tom Preston-Werner. TOML files serve the same purpose as other configuration formats, for example, the famous INI—although TOML's goal is to be easier to read and easier to parse. YAML and JSON are other very popular configuration formats that you may have encountered. <kbd class="calibre12">Pkg</kbd> makes extensive usage of TOML for storing package metadata.</p>
<div class="packttip">You can read more about TOML, including the full specification, at <a href="https://github.com/toml-lang/toml" class="calibre19"><span>https://github.com/toml-lang/toml</span></a><span>.</span></div>
<p class="calibre2">A TOML parser for Julia is available at <a href="https://github.com/wildart/TOML.jl" class="calibre9"><span>https://github.com/wildart/TOML.jl</span></a>, but we don't need to explicitly add it as <kbd class="calibre12">Pkg</kbd> comes bundled with a TOML parser that we will use instead. But, this means that we do have to declare <kbd class="calibre12">Pkg</kbd> as a dependency of <kbd class="calibre12">IssueReporter</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">(IssueReporter) pkg&gt; add Pkg</strong> </pre>
<p class="calibre2">Now, to implement the preceding workflow. First, the path to the <kbd class="calibre12">General</kbd> registry.</p>
<p class="calibre2">Julia keeps track of a list of locations where important information is stored. This info includes configuration files, environments, installed packages, and registries. In Julia's lingo, these are called <strong class="calibre4">depots</strong> and are stored in the <kbd class="calibre12">DEPOT_PATH</kbd> global variable:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; DEPOT_PATH 3-element Array{String,1}: "/Users/adrian/.julia" "/Applications/Julia-1.0.app/Contents/Resources/julia/local/share/julia" "/Applications/Julia-1.0.app/Contents/Resources/julia/share/julia"</strong> </pre>
<p class="calibre2">The contents of the <kbd class="calibre12">DEPOT_PATH</kbd> array on my computer are shown here. Your output will be different, but similar. </p>
<p class="calibre2">The first entry is the user depot where registries are cloned, new package versions are installed, package repos are cloned, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are read-only and are used for operations performed by system administrators.</p>
<p class="calibre2">Let's add a new (failing) test for getting the <kbd class="calibre12">General</kbd> registry path:</p>
<pre class="calibre17">@testset "Interacting with the registry" begin 
  @testset "The General registry is accessible" begin 
    IssueReporter.generalregistrypath() |&gt; Base.Filesystem.isdir 
  end 
end </pre>
<p class="calibre2">As for the implementation, we will want to loop over each entry in the <kbd class="calibre12">DEPOT_PATH</kbd> and check if it contains a <kbd class="calibre12">registries/General</kbd> path of directories. These should be in the user depot, but a more extensive lookup will make our code more robust:</p>
<pre class="calibre17">function generalregistrypath() 
  for i in DEPOT_PATH 
    if isdir(joinpath(i, "registries", "General")) 
      return joinpath(i, "registries", "General") 
    end 
  end 
end </pre>
<p class="calibre2">Once we have the path to the <kbd class="calibre12">General</kbd> registry, we'll want to parse the <kbd class="calibre12">Registry.toml</kbd> file and extract the information corresponding to the package we'll be searching for. Once parsed, the <kbd class="calibre12">Registry.toml</kbd> file produces in a dictionary with five entries:</p>
<pre class="calibre17">Dict{String,Any} with 5 entries: 
  "name"        =&gt; "General" 
  "repo"        =&gt; "https://github.com/JuliaRegistries/General.git" 
  "packages"    =&gt; Dict{String,Any}("c786d6c3-4fbc-59fc-968c-e848efb65d2d"=&gt;Dict{String,Any}("name"=&gt;"ScHoLP","path"=&gt;"S/ScHoLP"),"88634af6-177f-5301-88b8-7819386cfa38"=&gt;Dict{String,Any}("name"=&gt;"SaferIntegers","path"=&gt;"S/SaferIntegers")... 
  "uuid"        =&gt; "23338594-aafe-5451-b93e-139f81909106" 
  "description" =&gt; "Official general Julia package registry where people  
# output omitted #  </pre>
<p class="calibre2">We're only interested in the <em class="calibre16">packages</em> data, which looks like this:</p>
<pre class="calibre17">Dict{String,Any} with 2358 entries: 
  "c786d6c3-4fbc-59fc-968c-e848efb65d2d" =&gt; Dict{String,Any}("name"=&gt;"ScHoLP","path"=&gt;"S/ScHoLP") 
  "88634af6-177f-5301-88b8-7819386cfa38" =&gt; Dict{String,Any}("name"=&gt;"SaferIntegers","path"=&gt;"S/SaferIntegers") 
  "aa65fe97-06da-5843-b5b1-d5d13cad87d2" =&gt; Dict{String,Any}("name"=&gt;"SnoopCompile","path"=&gt;"S/SnoopCompile") 
# output truncated # </pre>
<p class="calibre2">And actually, we don't want all that, since we don't care about the UUID; only the name and the path. Let's add a new function to the <kbd class="calibre12">IssueReporter</kbd> module, to reflect this spec:</p>
<pre class="calibre17">function generalregistry() 
    TOML.parsefile(joinpath(generalregistrypath(), "Registry.toml"))["packages"] |&gt; values |&gt; collect 
end </pre>
<p class="calibre2">The output of the function is similar to this, an array of <kbd class="calibre12">Dict</kbd> elements:</p>
<pre class="calibre17">2358-element Array{Any,1}: 
 Dict{String,Any}("name"=&gt;"ScHoLP","path"=&gt;"S/ScHoLP") 
 Dict{String,Any}("name"=&gt;"SaferIntegers","path"=&gt;"S/SaferIntegers") 
 Dict{String,Any}("name"=&gt;"SnoopCompile","path"=&gt;"S/SnoopCompile") 
# output truncated # </pre>
<p class="calibre2">Once we have this, it is very easy to perform a package lookup by name. We simply iterate over each item and compare the <kbd class="calibre12">"name"</kbd> value against the search string:</p>
<pre class="calibre17">function searchregistry(pkgname::String) 
  for item in generalregistry() 
    item["name"] == pkgname &amp;&amp; return item 
  end 
end </pre>
<p class="calibre2">After we identify a package by name, we can use the path value to build the path to the folder that contains the package's metadata information. Remember that we're after the <kbd class="calibre12">Package.toml</kbd> file, as this contains the repo URI.</p>
<p class="calibre2">Putting it all together, we can finally write our <kbd class="calibre12">IssueReporter.packageuri</kbd> function:</p>
<pre class="calibre17">function packageuri(pkgname::String) 
  TOML.parsefile(joinpath(generalregistrypath(), searchregistry(pkgname)["path"], "Package.toml"))["repo"] 
end </pre>
<p class="calibre2">Your <kbd class="calibre12">IssueReporter.jl</kbd> file should look like this:</p>
<pre class="calibre17">module IssueReporter 
 
using Pkg, Pkg.TOML 
 
function generalregistrypath() 
  for i in DEPOT_PATH 
    if isdir(joinpath(i, "registries", "General")) 
      return joinpath(i, "registries", "General") 
    end 
  end 
end 
 
function generalregistry() 
    TOML.parsefile(joinpath(generalregistrypath(), "Registry.toml"))["packages"] |&gt; values |&gt; collect 
end 
 
function searchregistry(pkgname::String) 
  for item in generalregistry() 
    item["name"] == pkgname &amp;&amp; return item 
  end 
end 
 
function packageuri(pkgname::String) 
  TOML.parsefile(joinpath(generalregistrypath(), searchregistry(pkgname)["path"], "Package.toml"))["repo"] 
end 
 
end # module </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The IssueReporter.jl package</h1>
                </header>
            
            <article>
                
<p class="calibre2">Running the tests again will be successful:</p>
<pre class="calibre17"><strong class="calibre1">(IssueReporter) pkg&gt; test</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<div class="CDPAlignCenter1"><img src="assets/1e7c324e-9905-43ac-b1ca-b8e9282253f9.png" class="calibre204"/></div>
<p class="calibre2">If you're curious, the GitHub repo URI for <kbd class="calibre12">DataFrames</kbd>, according to <kbd class="calibre12">IssueReporter</kbd>, is as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; IssueReporter.packageuri("DataFrames")</strong> 
<strong class="calibre1">https://github.com/JuliaData/DataFrames.jl.git</strong></pre>
<p class="calibre2">If you want, you can check for yourself in the web browser to confirm that it is indeed, the correct URI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performance testing</h1>
                </header>
            
            <article>
                
<p class="calibre2">Our code works correctly so far, but what about it's performance? Besides its readable syntax, liberal license, rich package ecosystem, and welcoming community, performance is one of the top reasons why data scientists and software developers choose Julia. The compiler does a great job of providing excellent performance out of the box, but there are certain best practices that we as developers must keep in mind to ensure that we basically don't hinder the compiler. We'll go over the most important ones by looking at a few examples while running some benchmarks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benchmarking tools</h1>
                </header>
            
            <article>
                
<p class="calibre2">Given its focus on performance, it should come as no surprise that both core Julia and the ecosystem provide a variety of tools for inspecting our code, looking for bottlenecks and measuring runtime and memory usage. One of the simplest is the <kbd class="calibre12">@time</kbd> macro. It takes an expression and then prints its execution time, number of allocations, and the total number of bytes the execution caused to be allocated, before returning the result of the expression. For example, note the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @time [x for x in 1:1_000_000]; 
  0.031727 seconds (55.85 k allocations: 10.387 MiB)</strong> </pre>
<p class="calibre2">Generating an array of one million integers by iterating from one to one million takes 0.03 seconds. Not bad, but what if I told you that we can do better—much better? We just committed one of the cardinal sins of Julia—code should not be run (nor benchmarked) in the global scope. So, rule one—always wrap your code into functions.</p>
<p class="calibre2">The previous snippet can easily be refactored as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; function onetomil()  </strong><br class="title-page-name"/><strong class="calibre1">            [x for x in 1:1_000_000]</strong><br class="title-page-name"/><strong class="calibre1">       end 
onetomil (generic function with 1 method)</strong> </pre>
<p class="calibre2">Now, the benchmark is as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @time onetomil();
  0.027002 seconds (65.04 k allocations: 10.914 MiB)</strong> </pre>
<p class="calibre2">All right, that's clearly faster—but not much faster. However, what if we run the benchmark one more time?</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @time onetomil();
  0.002413 seconds (6 allocations: 7.630 MiB)</strong> </pre>
<p class="calibre2">Wow, that's an order of magnitude faster! So, what gives?</p>
<p class="calibre2">If you remember from our coverage of functions and methods, Julia uses a <strong class="calibre4">just-in-time</strong> (<strong class="calibre4">JIT</strong>) compiler; that is, a function is compiled in real time when it is invoked for the first time. So, our initial benchmark also included the compilation time. This brings us to the second rule—don't benchmark the first run.</p>
<p class="calibre2">The best way to accurately measure the performance of a piece of code, thus, would be to execute it multiple times and then compute the mean. There is a great tool, specially designed for this use case, called <kbd class="calibre12">BenchmarkTools</kbd>. Let's add it and give it a try:</p>
<pre class="calibre17"><strong class="calibre1">(IssueReporter) pkg&gt; add BenchmarkTools 
julia&gt; using BenchmarkTools 
julia&gt; @benchmark onetomil() 
BenchmarkTools.Trial: 
  memory estimate:  7.63 MiB 
  allocs estimate:  2 
  -------------- 
  minimum time:     1.373 ms (0.00% GC) 
  median time:      1.972 ms (0.00% GC) 
  mean time:        2.788 ms (34.06% GC) 
  maximum time:     55.129 ms (96.23% GC) 
  -------------- 
  samples:          1788 
  evals/sample:     1</strong> </pre>
<p class="calibre2"><kbd class="calibre12">BenchmarkTools</kbd> took <kbd class="calibre12">1788</kbd> samples, with an evals to sample ratio of <kbd class="calibre12">1</kbd>. Here, a sample represents a measurement, while an evaluation is an execution of the benchmark expression. We got a maximum time of 55 milliseconds, driven by the garbage collection, with a minimum of 1.3 milliseconds, and a mean of 2.7 milliseconds. That is in line with what the second <kbd class="calibre12">@time</kbd> execution revealed, at 2.4 milliseconds—but this benchmark is far more accurate. We can also use the more compact <kbd class="calibre12">@btime</kbd> macro, which has an output similar to <kbd class="calibre12">@time</kbd>, but executes an equally comprehensive benchmark:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @btime onetomil(); 
  1.363 ms (2 allocations: 7.63 MiB)</strong> </pre>
<div class="packttip"><kbd class="calibre24">BenchmarkTools</kbd> exposes a very rich API and it's worth getting to know it well. You can read more about it at <a href="https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md" class="calibre19"><span>https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md</span></a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type stability is key</h1>
                </header>
            
            <article>
                
<p class="calibre2">If there is one thing that has a direct and massive impact on the performance of Julia code, it's the type system. And the most important thing about it is to write code that is type-stable. Type stability means that the type of a variable (including the return value of a function) must not vary with time or under different inputs. Understanding how to leverage type stability is key to writing fast software. Now that we know how to measure our code's execution time, we can see the effect of type instability with a few examples.</p>
<p class="calibre2">Let's take this innocent-looking function, for example:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; function f1() 
           x = 0 
 
           for i in 1:10 
               x += sin(i) 
           end 
            
           x 
       end 
f1 (generic function with 1 method)</strong> </pre>
<p class="calibre2">There's nothing fancy about it. We have a variable, <kbd class="calibre12">x</kbd>, which is initialized to <kbd class="calibre12">0</kbd>—and then a loop from <kbd class="calibre12">1</kbd> to <kbd class="calibre12">10</kbd>, where we add the <kbd class="calibre12">sin</kbd> of a number to <kbd class="calibre12">x</kbd>. And then we return <kbd class="calibre12">x</kbd>. Nothing to see, right? Well, actually, quite the contrary—a few bad things, performance-wise, are happening here. And they all have to do with type instability.</p>
<p class="calibre2">Julia provides a great tool for inspecting and diagnosing code for type-related issues—the <kbd class="calibre12">@code_warntype</kbd> macro. Here's what we get when we use it with our <kbd class="calibre12">f1</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @code_warntype f1()</strong> </pre>
<p class="CDPAlignLeft1">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/acb8a124-d316-4c01-8f17-d5985117cd02.png" class="calibre205"/></p>
<p class="calibre2">This time, I'm using a screenshot for the output, in order to illustrate the color coding. As you might expect, green is good and red is bad. I am also marking the red flags with a rectangle. The problems are with <kbd class="calibre12">Body::Union{Float64, Int64}</kbd> on the first line, <kbd class="calibre12">(#4 =&gt; 0, #14 =&gt; %29)::Union{Float64, Int64}</kbd> on line <kbd class="calibre12">12</kbd>, and <kbd class="calibre12">(#13 =&gt; %29, #4 =&gt; 0)::Union{Float64, Int64}</kbd> on the penultimate line.</p>
<p class="calibre2">On the first line, the <kbd class="calibre12">Body::Union{Float64, Int64}</kbd>, as well as on the penultimate line, <kbd class="calibre12">::Union{Float64, Int64}</kbd>, tell us the same thing—the function returns a <kbd class="calibre12">Union{Float64, Int64}</kbd>, meaning that the function can return either a <kbd class="calibre12">Float</kbd> or an <kbd class="calibre12">Integer</kbd>. This is textbook type instability and bad news for performance. Next, on line <kbd class="calibre12">12</kbd>, <em class="calibre16">something</em> has a type of <kbd class="calibre12">Union{Float64, Int64}</kbd> and this value is then returned as the result of the function. In case you're wondering, that <em class="calibre16">something</em> is <kbd class="calibre12">x</kbd>.</p>
<p class="calibre2">The problem is that we unsuspectingly initialized <kbd class="calibre12">x</kbd> to <kbd class="calibre12">0</kbd>, an <kbd class="calibre12">Integer</kbd>. However, the <kbd class="calibre12">sin</kbd> function will return a <kbd class="calibre12">Float</kbd>. Adding a <kbd class="calibre12">Float</kbd> to an <kbd class="calibre12">Integer</kbd> will result in a <kbd class="calibre12">Float</kbd>, causing the type of <kbd class="calibre12">x</kbd> to change accordingly. Thus, <kbd class="calibre12">x</kbd> has two types during the execution of the function, and since we return <kbd class="calibre12">x</kbd>, our function is also type-unstable.</p>
<p class="calibre2">Granted, understanding the output of <kbd class="calibre12">@code_warntype</kbd> is not easy, although it does get easier with time. However, we can make our job easier by using the super-useful <kbd class="calibre12">Traceur</kbd> package. It provides a <kbd class="calibre12">@trace</kbd> macro, which generates human-friendly information. Let's add it and try it out; you'll appreciate it, I'm sure:</p>
<pre class="calibre17"><strong class="calibre1">(IssueReporter) pkg&gt; add Traceur 
julia&gt; using Traceur 
julia&gt; @trace f1() 
┌ Warning: x is assigned as Int64 
└ @ REPL[94]:2 
┌ Warning: x is assigned as Float64 
└ @ REPL[94]:4 
┌ Warning: f1 returns Union{Float64, Int64} 
└ @ REPL[94]:2 
1.4111883712180104</strong> </pre>
<p class="calibre2">How cool is that? Crystal clear! </p>
<p class="calibre2">With this feedback in mind, we can refactor our code into a new <kbd class="calibre12">f2</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; function f2() 
           x = 0.0 
 
           for i in 1:10 
                  x += sin(i) 
           end 
 
           x 
       end 
f2 (generic function with 1 method) 
 
julia&gt; @trace f2() 
1.4111883712180104</strong></pre>
<p class="calibre2">Awesome, nothing to report! No news is good news!</p>
<p class="calibre2">Now, we can benchmark <kbd class="calibre12">f1</kbd> and <kbd class="calibre12">f2</kbd> to see the result of our refactoring:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @btime f1() 
  129.413 ns (0 allocations: 0 bytes) 
1.4111883712180104 
 
julia&gt; @btime f2() 
  79.241 ns (0 allocations: 0 bytes) 
1.4111883712180104</strong> </pre>
<p class="calibre2">That's nice—79 versus 129 nanoseconds! If you're thinking that <em class="calibre16">It's just 50 nanoseconds, what's all the fuss about?</em>, you need to look at it this way—<kbd class="calibre12">f2</kbd>, the type-stable variant, is almost twice as fast as <kbd class="calibre12">f1</kbd>! And that's a really big deal!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benchmarking our code</h1>
                </header>
            
            <article>
                
<p class="calibre2">It's time to apply what we've learned to our own code base. Heads up, I have intentionally sneaked in a few problems, to spice things up a bit. Let's fix them together:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @code_warntype IssueReporter.packageuri("DataFrames")</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/10c7d5ce-3ae9-42aa-8b1f-cf29fb6ea23f.png" class="calibre206"/></p>
<p class="calibre2">This is all very interesting—let's see what we can learn from it.</p>
<p class="calibre2">Starting with line <kbd class="calibre12">1</kbd>, the <kbd class="calibre12">IssueReporter.generalregistrypath</kbd> function returns a <kbd class="calibre12">Union{Nothing, String}</kbd>. The reason is that our function does not handle the case when the <kbd class="calibre12">for</kbd> loop is not entered, or when the <kbd class="calibre12">if</kbd> statement is not executed. We should make sure that our function always returns a value and that the type of this return value does not change. To be extra sure, we can also add a type assertion to the function definition itself. If we accidentally return the wrong type, Julia will try to convert it to the declared type—if that doesn't work, an error is thrown.</p>
<p class="calibre2">We need to redefine the function as follows:</p>
<pre class="calibre17">function generalregistrypath() :: String 
  for i in DEPOT_PATH 
    if isdir(joinpath(i, "registries", "General")) 
      return joinpath(i, "registries", "General") 
    end 
  end 
   
  "" 
end </pre>
<p class="calibre2">Now, on to the line starting with <kbd class="calibre12">%2</kbd> (the third line)—the <kbd class="calibre12">searchregistry</kbd> function returns a value of type <kbd class="calibre12">Any</kbd>. The issue here is that we return an item coming from the invocation of <kbd class="calibre12">generalregistry</kbd>, so we need to look at that first. We'll add a check for the return value of <kbd class="calibre12">generalregistrypath</kbd>, and we add a default return value, an empty <kbd class="calibre12">Vector{Dict{String,Any}}</kbd>. Then, for <kbd class="calibre12">searchregistry</kbd>, we'll also add a default return value—since it returns an item from this <kbd class="calibre12">Vector</kbd>, it will be of type <kbd class="calibre12">Dict{String,Any}</kbd>.</p>
<p class="calibre2">Next, in regards to the <kbd class="calibre12">packageuri</kbd> function, in the line starting with <kbd class="calibre12">%9</kbd> (on line <kbd class="calibre12">11</kbd>), we can see something about a <kbd class="calibre12">KeyError</kbd> and <kbd class="calibre12">repo</kbd>. Julia is warning us that it's possible that we won't have a key named <kbd class="calibre12">repo</kbd>, thus leading to a <kbd class="calibre12">KeyError</kbd>. Also, the function returns an object of type <kbd class="calibre12">Any</kbd>.</p>
<p class="calibre2">Here are the three functions, refactored:</p>
<pre class="calibre17">function generalregistry() :: Vector{Dict{String,Any}} 
  if ! isempty(generalregistrypath()) 
    TOML.parsefile(joinpath(generalregistrypath(), "Registry.toml"))["packages"] |&gt; values |&gt; collect 
  else 
     Dict{String,Any}[] 
   end 
end 
 
function searchregistry(pkgname::String) :: Dict{String,Any} 
  for item in generalregistry() 
    item["name"] == pkgname &amp;&amp; return item 
  end 
 
  Dict{String,Any}() 
end 
 
function packageuri(pkgname::String) :: String 
  pkg = searchregistry(pkgname) 
  isempty(pkg) &amp;&amp; return "" 
  get!(TOML.parsefile(joinpath(generalregistrypath(), pkg["path"], "Package.toml")), "repo", "") 
end </pre>
<p class="calibre2">We can now recheck our code:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @code_warntype IssueReporter.packageuri("DataFrames") </strong></pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/aec1e4c4-9374-4937-8a4e-952d886aaccd.png" class="calibre207"/></p>
<p class="calibre2">Excellent, almost everything is green! There's just one red <kbd class="calibre12">Any</kbd>, coming from the <kbd class="calibre12">TOML.parsefile</kbd> function itself, but it's just not worth optimizing that away; the extra work would cancel the benefit.</p>
<div class="packttip">It's definitely worth spending some time going over the official performance recommendations, available online at <a href="https://docs.julialang.org/en/v1/manual/performance-tips/" class="calibre19"><span>https://docs.julialang.org/en/v1/manual/performance-tips/</span></a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with the GitHub API</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that we can retrieve the GitHub URI for any package in the <kbd class="calibre12">General</kbd> registry, we can use it to interact with the GitHub API. Julia developers have access to a powerful GitHub library provided by the <span class="calibre5">GitHub</span> package. It's what we'll use in order to create new issues on the packages' GitHub repos.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authenticating with the GitHub API</h1>
                </header>
            
            <article>
                
<p class="calibre2">In order to be allowed to interact with the GitHub API, we have to authenticate. This will permit our package to execute actions on GitHub under the user's account as if done directly through the website. Please access <a href="https://github.com/settings/tokens" class="calibre9"><span>https://github.com/settings/tokens/new</span></a> to set up a new GitHub access token. If you're not familiar with the concept and would like to learn more about this, please read on and follow the official instructions at <a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/" class="calibre9"><span>https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/</span></a>. Give the token a good description and, very importantly, make sure that you check the <span class="calibre5">repo</span> scope, just as you can see in this screenshot:</p>
<p class="CDPAlignCenter"><img src="assets/4109ce90-615c-403b-ac74-a4fe1de71118.png" class="calibre208"/></p>
<p class="calibre2">Once generated, write down the token—once you leave that page, you won't see it again.</p>
<div class="packttip"><span>The access tokens must be manipulated with care—and must not be committed to git or other source control systems where they can be accessed by other users. Anybody that get</span>s <span>your access token can use it to impersonate you on GitHub. To be on the safe side, please make sure that for this project, you only check the <span>repo</span> scope.</span></div>
<p class="calibre2">Let's add a bit of logic to make the access token available to our package without compromising security. It should work as follows—first, we check if the access token is provided as a command line parameter to the Julia process—meaning that it will be available in the <kbd class="calibre12"><span>ENV</span></kbd> collection. If it's not, we'll look for a file called <kbd class="calibre12"><span>secrets.jl</span></kbd> in the root folder of the package and include it. The file will contain the access token so we'll add it to <kbd class="calibre12"><span>.gitignore</span></kbd>, to make sure it's not accidentally committed to git.</p>
<p class="calibre2">So, let's write the tests. Append the following at the end of <kbd class="calibre12"><span>runtests.jl</span></kbd>:</p>
<pre class="calibre17">@testset "GitHub integration" begin 
  delete!(ENV, "GITHUB_ACCESS_TOKEN") 
 
  @testset "An undefined token should return false" begin 
    @test ! IssueReporter.tokenisdefined() 
  end <br class="title-page-name"/>  @testset "Attempting to access a token that is not set will error" begin 
    @test_throws ErrorException IssueReporter.token() 
  end <br class="title-page-name"/>  # setup a mock token 
  ENV["GITHUB_ACCESS_TOKEN"] = "1234" <br class="title-page-name"/>  @testset "Token is defined" begin 
    @test IssueReporter.tokenisdefined() 
  end <br class="title-page-name"/> @testset "A valid token is a non empty string and has the set value" begin 
    token = IssueReporter.token() 
    @test isa(token, String) &amp;&amp; ! isempty(token) 
    @test token == "1234" 
  end 
end 
 </pre>
<p class="calibre2">The tests will fail, of course, so let's make them pass.</p>
<p class="calibre2">Add these function definitions to <kbd class="calibre12"><span>IssueReporter.jl</span></kbd>:</p>
<pre class="calibre17">function tokenisdefined() :: Bool 
    if ! haskey(ENV, "GITHUB_ACCESS_TOKEN") 
        secrets_path = joinpath(@__DIR__, "secrets.jl") 
        isfile(secrets_path) &amp;&amp; include(secrets_path) 
        haskey(ENV, "GITHUB_ACCESS_TOKEN") || return false 
    end <br class="title-page-name"/>    <br class="title-page-name"/>    true 
end <br class="title-page-name"/><br class="title-page-name"/>function token() :: String 
    tokenisdefined() &amp;&amp; return ENV["GITHUB_ACCESS_TOKEN"] 
    error("""ENV["GITHUB_ACCESS_TOKEN"] is not set -- please make sure it's passed as a command line argument or defined in the `secrets.jl` file.""") 
end </pre>
<p class="calibre2">In the <kbd class="calibre12"><span>tokenisdefined</span></kbd> function, we check if the <kbd class="calibre12"><span>GITHUB_ACCESS_TOKEN</span></kbd> environment variable is already defined—if not, we check for the <kbd class="calibre12"><span>secrets.jl</span></kbd> file and, if it exists, we include it. Once included, the <kbd class="calibre12"><span>secrets.jl</span></kbd> file should define the variable, so finally, we check again for the existence of <kbd class="calibre12"><span>GITHUB_ACCESS_TOKEN</span></kbd>. If the token is still not defined, the function returns <kbd class="calibre12"><span>false</span></kbd>—otherwise<span class="calibre5">,</span> <kbd class="calibre12"><span>true</span></kbd>. We've also added a <span class="calibre5">token</span> function that invokes <kbd class="calibre12"><span>tokenisdefined</span></kbd>, giving the module the chance to set up <kbd class="calibre12"><span>GITHUB_ACCESS_TOKEN</span></kbd>. If the token is available, it returns it—if not, this time an error is thrown. Our tests should now pass:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; test</strong> </pre>
<p class="calibre2">This is it, as shown here:</p>
<p class="CDPAlignCenter"><img src="assets/6f998ece-b5fe-420e-8b2b-7854bd0c9201.png" class="calibre209"/></p>
<p class="calibre2">Success!</p>
<p class="calibre2">Before moving on, we need to add the <kbd class="calibre12"><span>secrets.jl</span></kbd> file to <kbd class="calibre12"><span>.gitignore</span></kbd>—committing this to a public GitHub repo would be a huge security error. From the Julia REPL, note the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; write(".gitignore", "secrets.jl")</strong> </pre>
<p class="calibre2">Now, you need to create the <kbd class="calibre12"><span>secrets.jl</span></kbd> file itself and make sure that it contains something similar to the next snippet, but adding your own GitHub access token:</p>
<pre class="calibre17"><strong class="calibre1">ENV["GITHUB_ACCESS_TOKEN"] = "0cdf8672e66***" # token truncated</strong> </pre>
<p class="calibre2">Excellent, we're ready to report issues!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reporting GitHub issues</h1>
                </header>
            
            <article>
                
<p class="calibre2">We're now down to the last step—using the GitHub API to report problems. In order to register an issue, we need two pieces of information—the title and the body. As such, we'll have to define a new function, called <kbd class="calibre12"><span>report</span></kbd>, which will accept <span class="calibre5"><em class="calibre16">three</em></span> string arguments—the name of the package, plus two more for the title and the body of the issue. Internally, the function will make an authenticated call to the corresponding GitHub API via the <span class="calibre5">GitHub</span> package.</p>
<p class="calibre2">According to the documentation, a call to the <kbd class="calibre12"><span>GitHub.create_issue</span></kbd> method looks like this:</p>
<pre class="calibre17">GitHub.create_issue("&lt;username&gt;/&lt;repo&gt;", auth = &lt;GitHub.OAuth2&gt;, params...) </pre>
<p class="calibre2">This means that we need to do the following:</p>
<ol class="calibre13">
<li class="calibre11">Use the GitHub token to authenticate and generate the required <kbd class="calibre12"><span>GitHub.OAuth2</span></kbd> authentication object</li>
<li class="calibre11">Starting from the Julia package name, compute the GitHub <span>username</span> and <span>repo</span> info—for this, we'll use the already implemented <kbd class="calibre12"><span>IssueReporter.packageurl</span></kbd>,<span> </span>plus some extra processing to remove the unwanted parts from the URL</li>
<li class="calibre11">Make the call to <kbd class="calibre12"><span>GitHub.create_issue</span></kbd>, passing in all the required arguments</li>
</ol>
<p class="calibre2">Since we're doing TDD, let's begin by converting these specifications into tests. Add the following at the very bottom of the <kbd class="calibre12"><span>runtests.jl</span></kbd> file:</p>
<pre class="calibre17">@testset "Adding GitHub issues" begin 
  delete!(ENV, "GITHUB_ACCESS_TOKEN") 
 
  @testset "Successful authentication should return a GitHub.OAuth2 instance" begin 
    @test isa(IssueReporter.githubauth(), GitHub.OAuth2) 
  end 
  @testset "Converting package name to GitHub id" begin 
    @test IssueReporter.repoid("IssueReporter") == "essenciary/IssueReporter.jl" 
  end 
  @testset "Submitting an issue should result in a GitHub.Issue object" begin 
    @test isa(IssueReporter.report("IssueReporter", "I found a bug", "Here is how you can reproduce the problem: ..."), GitHub.Issue) 
  end 
end </pre>
<p class="calibre2">The tests mirror, in the exact same order, the requirements we previously expressed in plain English. The first one invokes a function that we'll have to write, called <kbd class="calibre12"><span>IssueReporter.githubauth</span></kbd>, which will perform the GitHub authentication and will return a <kbd class="calibre12"><span>GitHub.OAuth2</span></kbd> object if successful. Next, we'll need a new <kbd class="calibre12"><span>repoid</span></kbd> function, which will take the name of a package and will return the GitHub username and repo name. Notice that we're using my repo of the <kbd class="calibre12"><span>IssueReporter</span></kbd> package as the guinea pig for our testing. Finally, we test the issue creation, which will be done by the <kbd class="calibre12"><span>IssueReporter.report</span></kbd> method—on success, we expect a <kbd class="calibre12"><span>GitHub.Issue</span></kbd> object.</p>
<div class="packttip"><span>Don't use Julia for anything evil! The code we're writing will actually register new issues on live GitHub repos.</span> Please be respectful of the hard work <span>of the open source contributors and don't overload them with fake issues.</span></div>
<p class="calibre2">Time to make the tests pass by writing the implementations. Make sure that the <kbd class="calibre12"><span>using</span></kbd> directive of the <kbd class="calibre12"><span>IssueReporter</span></kbd> module reads as follows:</p>
<pre class="calibre17">using Pkg, Pkg.TOML, <strong class="calibre1">GitHub, URIParser</strong>  # we've added URIParser and GitHub </pre>
<p class="calibre2">And then, add the following functions to the bottom of the <kbd class="calibre12"><span>IssueReporter</span></kbd> module:</p>
<pre class="calibre17">function githubauth() 
  token() |&gt; GitHub.authenticate 
end <br class="title-page-name"/><br class="title-page-name"/>function repoid(package_name::String) 
  pkg_url = packageuri(package_name) |&gt; URIParser.parse_url 
  repo_info = endswith(pkg_url.path, ".git") ? <br class="title-page-name"/>                replace(pkg_url.path, r".git$"=&gt;"") : <br class="title-page-name"/>                pkg_url.path <br class="title-page-name"/>  repo_info[2:end] 
end <br class="title-page-name"/><br class="title-page-name"/>function report(package_name::String, title::String, body::String) 
  GitHub.create_issue(repoid(package_name), auth = githubauth(), <br class="title-page-name"/>                        params = Dict(:title =&gt; title, :body =&gt; body)) 
end </pre>
<p class="calibre2">Pretty straightforward. The <kbd class="calibre12"><span>githubauth</span></kbd> function invokes the <kbd class="calibre12"><span>GitHub.authenticate</span></kbd> method, passing it the auth token provided by a call to the <span class="calibre5">token</span> function.</p>
<p class="calibre2">The <kbd class="calibre12"><span>repoid</span></kbd> method accepts a string parameter for the name of the repo, then invokes the <kbd class="calibre12"><span>packageuri</span></kbd> and the <kbd class="calibre12"><span>URIParse.parse_url</span></kbd> to generate a <span class="calibre5">URI</span> object corresponding to the GitHub repo. We then extract the <span class="calibre5">path</span> component of the <span class="calibre5">URI</span> and process it to keep only the GitHub username and the repo name. In other words, starting with the package named <kbd class="calibre12">IssueReporter</kbd>, we retrieve the GitHub repo URL, which is <span class="calibre5"><kbd class="calibre12">git://github.com/essenciary/IssueReporter.jl.git</kbd></span>. The <span class="calibre5">path</span> component is <span class="calibre5"><kbd class="calibre12">/essenciary/IssueReporter.jl.git</kbd></span>. We use <span class="calibre5">replace</span> with the <kbd class="calibre12"><span>r".git$"</span></kbd> regex to remove the <span class="calibre5"><kbd class="calibre12">.git</kbd></span> ending before returning the substring starting from the second letter. At the end, we have what we need—<span class="calibre5"><kbd class="calibre12">essenciary/IssueReporter.jl</kbd></span>.</p>
<p class="calibre2">Lastly, the <span class="calibre5">report</span> function puts it all together by invoking the <kbd class="calibre12"><span>GitHub.create_issue</span></kbd> method and passing it the <kbd class="calibre12"><span>repoid</span></kbd>, the authentication object, and the title and body of the issue within a <kbd class="calibre12"><span>Dict</span></kbd>. All the tests should pass now and the issues are successfully created on <span class="calibre5">Github.com (<a href="https://github.com/" class="calibre9">https://github.com/</a>)</span>:</p>
<p class="CDPAlignCenter"><img src="assets/668b4028-4bd8-4a21-8f2f-5f67691461b2.png" class="calibre210"/></p>
<div class="packttip"><span>Please note that the sample code provided with the chapter has the <kbd class="calibre24">create issue</kbd> functionality commented out—and instead it has hard-coded a dummy repository. Again, out of respect for the contributors and followers of the real repos, the actual issues will be created on a dummy repository that I created especially for this purpose.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Documenting our package</h1>
                </header>
            
            <article>
                
<p class="calibre2">Our package is now complete! Let's make it easy for our users to take advantage of the amazing convenience provided by <kbd class="calibre12"><span>IssueReporter</span></kbd>—we'll supply them an informative documentation. We already know how to document our code by using <kbd class="calibre12">DocStrings</kbd> - which can be used by ourselves and other developers to understand our source code. It's also used by the REPL's help system (remember from <a href="90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml" class="calibre9">Chapter 1</a>, <em class="calibre16">Getting Started with Julia Programming</em> that you can type <kbd class="calibre12"><span>?</span></kbd> at the beginning of the line to switch the REPL to help mode). You'll be happy to hear that we can also generate package documentation using the same <kbd class="calibre12">DocStrings</kbd>, with the help of a package called <kbd class="calibre12"><span>Documenter</span></kbd>. Please add it with <span class="calibre5"><kbd class="calibre12">(IssueReporter) pkg&gt; add Documenter</kbd>.</span></p>
<p class="calibre2">So, the first thing to do is add some <kbd class="calibre12">DocStrings</kbd> to our functions. Keep in mind that the <em class="calibre16">official</em> recommendation is to include the function's signature together with a small description and a few examples. For instance, the documentation for the <kbd class="calibre12"><span>IssueReporter.packageuri</span></kbd> function could look like this:</p>
<pre class="calibre17">""" packageuri(pkgname::String) :: String <br class="title-page-name"/>Takes the name of a registered Julia package and returns the associated repo git URL. <br class="title-page-name"/>Examples ``` jldoctest julia&gt; IssueReporter.packageuri("IssueReporter") "git://github.com/essenciary/IssueReporter.jl.git" ``` """ function packageuri(pkgname::String) :: String # output truncated # end </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced documentation tips</h1>
                </header>
            
            <article>
                
<p class="calibre2">You may have noticed in the previous snippet that we have to repeat the signature of the <kbd class="calibre12"><span>packageuri</span></kbd> function in the <kbd class="calibre12">DocString</kbd>. The problem here is that the documentation can get out of sync if we change the function declaration, but omit to update the documentation. Julia's package ecosystem provides a library that extends the default documentation functionality, named <kbd class="calibre12"><span>DocStringExtensions</span></kbd>. It's a registered package, so it can be added with <kbd class="calibre12"><span>(IssueReporter) pkg&gt; add DocStringExtensions</span></kbd>. It provides a series of methods that can be used to automatically generate some of the repetitive parts of the documentation process. For example, once we add <kbd class="calibre12"><span>using DocStringExtensions</span></kbd> to the <kbd class="calibre12"><span>IssueReporter</span></kbd> module, we can replace the function declaration from the docstring with the <kbd class="calibre12"><span>$(SIGNATURES)</span></kbd><span class="calibre5"> </span><span class="calibre5"><em class="calibre16">abbreviation</em></span>. We'll see how to do that right away.</p>
<p class="calibre2">Another valuable feature of <kbd class="calibre12">DocStrings</kbd> is that the examples can also serve as tests. This kind of testing is called a <strong class="calibre4">doctest</strong>. Basically, when we provide a REPL example together with the corresponding output, if we tag this as a <em class="calibre16"><span class="calibre5">jldoctest</span></em>, the <kbd class="calibre12"><span>Documenter</span></kbd> package used to generate the documentation will also run the examples and compare the result against the provided output, thus testing the examples and, implicitly, our code. Check the next snippet to see what the previous example looks like after we apply these optimizations.</p>
<p class="calibre2">I have added comments to all the functions that represent the <em class="calibre16">public</em> API of <kbd class="calibre12"><span>IssueReporter</span></kbd>. Here are the updated function definitions (you can get the full file from this chapter's repo at <a href="https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl" class="calibre9">https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter11/IssueReporter/src/IssueReporter.jl</a>):</p>
<pre class="calibre17">module IssueReporter 
 
using Pkg, Pkg.TOML, GitHub, URIParser, Documenter, DocStringExtensions 
 
# ... some functions omitted ... #
 
""" 
$(SIGNATURES) 
 
Takes the name of a registered Julia package and returns the associated repo git URL. 
 
#Examples 
```julia-repl 
julia&gt; IssueReporter.packageuri("IssueReporter") 
"git://github.com/essenciary/IssueReporter.jl.git" 
``` 
""" 
function packageuri(pkgname::String) :: String 
    # ... function body omitted ... # 
end 
 
""" 
$(SIGNATURES) 
 
Checks if the required GitHub authentication token is defined. 
""" 
function tokenisdefined() :: Bool 
  # ... function body omitted ... # 
end 
 
# ... some functions omitted ... #
 
""" 
$(SIGNATURES) 
 
Converts a registered Julia package name to the corresponding GitHub "username/repo_name" string. 
 
#Examples 
```jldoctest 
julia&gt; IssueReporter.repo_id("IssueReporter") 
"essenciary/IssueReporter.jl" 
``` 
""" 
function repoid(package_name::String) 
    # ... function body omitted ... # 
end 
 
# ... some functions omitted ... #
 
end # module  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating the documentation</h1>
                </header>
            
            <article>
                
<p class="calibre2">In order to create our documentation, we'll need to first create a <span class="calibre5"><kbd class="calibre12">docs/</kbd></span> folder inside our <kbd class="calibre12"><span>IssueReporter</span></kbd> root directory.</p>
<p class="calibre2">Within the <kbd class="calibre12"><span>docs/</span></kbd> folder, we need two more things—first, a <kbd class="calibre12"><span>src/</span></kbd> folder, which will contain the markdown template that will be used to build the documentation, the <kbd class="calibre12">index.md</kbd> file; second, a <kbd class="calibre12"><span>make.jl</span></kbd> file that will control the documentation building process. Here is the full file structure of our package, for reference:</p>
<p class="CDPAlignCenter"><img src="assets/125def3c-c57d-4429-af88-e08d85d9bce4.png" class="calibre211"/></p>
<p class="calibre2">Now, open the <kbd class="calibre12"><span>docs/make.jl</span></kbd> file in the editor and add the following:</p>
<pre class="calibre17">using Pkg 
pkg"activate .." 
push!(LOAD_PATH,"../src/") 
using Documenter, IssueReporter 
 
makedocs(sitename = "IssueReporter Documentation") </pre>
<p class="calibre2">Next, open the <kbd class="calibre12">index.md</kbd> file in the editor and add the following:</p>
<pre class="calibre17"># IssueReporter.jl Documentation <br class="title-page-name"/>```@meta 
CurrentModule = IssueReporter 
``` <br class="title-page-name"/>```@contents 
``` <br class="title-page-name"/>## Functions <br class="title-page-name"/>```@docs 
packageuri(pkgname::String) 
tokenisdefined() 
token() 
githubauth() 
repoid(package_name::String) 
report(package_name::String, title::String, body::String) 
``` <br class="title-page-name"/>## Index <br class="title-page-name"/>```@index 
``` </pre>
<p class="calibre2">This is the markdown template of our documentation. At the top, we have the title of the page. Then, the <kbd class="calibre12"><span>@meta</span></kbd> block contains information for <kbd class="calibre12"><span>Documenter</span></kbd>, passing in the name of the module. The <kbd class="calibre12"><span>@contents</span></kbd> block will be replaced with the table of contents. The <kbd class="calibre12"><span>@docs</span></kbd> block will contain the documentation for each of the functions included. At the bottom, the <kbd class="calibre12"><span>@index</span></kbd> block will be replaced by a list of links to each of the documented functions.</p>
<p class="calibre2">That's all. In order to generate the documentation, we need to run <kbd class="calibre12"><span>$ julia --color make.jl</span></kbd> from an OS Terminal, from within the <kbd class="calibre12"><span>docs/</span></kbd> folder.</p>
<p class="calibre2">The output of the command will show the progress of building the docs:</p>
<pre class="calibre17">Documenter: setting up build directory. 
Documenter: expanding markdown templates. 
Documenter: building cross-references. 
Documenter: running document checks. 
 &gt; checking for missing docstrings. 
 &gt; running doctests. 
 &gt; checking footnote links. 
Documenter: populating indices. 
Documenter: rendering document. </pre>
<p class="calibre2">The generated documentation can be found at <kbd class="calibre12"><span>docs/build/index.html</span></kbd>, and looks like this:</p>
<p class="CDPAlignCenter"><img src="assets/31055def-d852-4a81-afb9-24d2dcf03d2f.png" class="calibre212"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering our package</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now, for the last step—making our package available to the world! For starters, we need to create the remote GitHub repository and push our code to it. The easiest way to do this is with the <kbd class="calibre12">hub</kbd> binary, provided by GitHub. Please follow the installation instructions for your platform, as described at <a href="https://github.com/github/hub" class="calibre9"><span>https://github.com/github/hub</span></a>. Once ready, we'll need to run <kbd class="calibre12">hub create</kbd> in the root of the <kbd class="calibre12">IssueReporter</kbd> folder. We can do it in Julia's REPL:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; cd(Pkg.dir("IssueReporter")) 
julia&gt; run(`hub create IssueReporter.jl`)</strong> </pre>
<p class="calibre2">You'll be prompted for your GitHub username and password—and if all goes well, you'll see the output confirming that the repo was created.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finishing touches</h1>
                </header>
            
            <article>
                
<p class="calibre2">Next, we need to commit and push our changes—but before doing that, let's make a final change to <kbd class="calibre12"><span>.gitignore</span></kbd> to also add <kbd class="calibre12"><span>docs/build</span></kbd> to the list of ignored files. It is a bad practice to include the built docs into the GitHub commits—for more information about hosting documentation on GitHub, please read the official <kbd class="calibre12"><span>Documenter</span></kbd> info at <a href="https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1" class="calibre9"><span>https://juliadocs.github.io/Documenter.jl/latest/man/guide/#Usage-1</span></a> and <a href="https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1" class="calibre9"><span>https://juliadocs.github.io/Documenter.jl/latest/man/hosting/#Hosting-Documentation-1</span></a>.</p>
<p class="calibre2">While we're at it, let's also add a <kbd class="calibre12"><span>README.md</span></kbd> file to the root folder of <kbd class="calibre12">IssueReporter</kbd>, to include a bit of info:</p>
<pre class="calibre17"># IssueReporter.jl  <br class="title-page-name"/>`IssueReporter.jl` is a Julia package which makes it easy to report a new issue with a registered package. 
In order to use it, it needs to be configured with a valid GitHub authentication token. Follow the instructions at 
https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/ to generate a new token -- make sure 
that it has the `repo` access. <br class="title-page-name"/>Once you have the token, add it to the secrets.jl file. <br class="title-page-name"/>You can now open issues by invoking: 
`IssueReporter.report("Julia package name", "issue title", "issue body")` </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the repository</h1>
                </header>
            
            <article>
                
<p class="calibre2">Using your favorite git client, <kbd class="calibre12">add</kbd>, <kbd class="calibre12">commit</kbd>, and <kbd class="calibre12">push</kbd> the code base. I'm going to use the Terminal:</p>
<pre class="calibre17"><strong class="calibre1">$ git add . $ git commit -m "initial commit" $ git push origin master</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unleashing Julia's army of bots</h1>
                </header>
            
            <article>
                
<p class="calibre2">Our package is looking great—it's now time to tag a release and register it.</p>
<p class="calibre2">Julia contributors have developed a series of very useful GitHub integrations, namely, <span class="calibre5"><em class="calibre16">bots</em></span>. These bots help us, humans, to automate a series of boring tasks so that we can focus on the really important things (mmm, pizza!).</p>
<p class="calibre2">One of them is Attobot, a package release bot for Julia. It creates pull requests to Julia's <kbd class="calibre12">General</kbd> registry when releases are tagged in GitHub. Try the following:</p>
<ol class="calibre13">
<li class="calibre11">To set up Attobot, open your <kbd class="calibre12">IssueReporter</kbd> GitHub repo and go to <a href="https://github.com/integration/attobot" class="calibre9"><span>https://github.com/integration/attobot</span></a>. Please make sure that you're logged into your GitHub account.</li>
<li class="calibre11">Then, click <span>Configure</span> to select the repositories you wish to add.</li>
<li class="calibre11">Choose <span>Only select repositories</span>, and then select <kbd class="calibre12">IssueReporter</kbd> and click <span>Save</span>. Now, Attobot is configured to monitor packages with the standard <kbd class="calibre12">.jl</kbd> extension—and publish them on the <kbd class="calibre12">Global</kbd> registry when new releases are tagged.</li>
</ol>
<div class="packttip">For more details about Attobot, please visit <span><a href="https://github.com/attobot/attobot" class="calibre19">https://github.com/attobot/attobot</a>.</span></div>
<ol start="4" class="calibre13">
<li class="calibre11">Now, we need to go to our repo's GitHub page and click on the <span>releases</span> link:</li>
</ol>
<div class="CDPAlignCenter1"><img src="assets/887ff6ff-9ca3-4050-976f-2baca06e9d2f.png" class="calibre213"/></div>
<ol start="5" class="calibre13">
<li class="calibre11">Next, we are given the option to <span>Create a new release</span>:</li>
</ol>
<div class="CDPAlignCenter1"><img src="assets/2332f178-74bb-4118-b178-c0024c3a803a.png" class="calibre214"/></div>
<ol start="6" class="calibre13">
<li class="calibre11">On the next screen, we'll be able to tag our release. Julia uses semantic versioning (which looks like <span>vX.Y.Z</span>) and recommends starting with <kbd class="calibre12"><span>v0.0.1</span></kbd>. Let's do just that:</li>
</ol>
<div class="CDPAlignCenter1"><img src="assets/bb2f8d04-78ad-4343-9f98-0a5f327362a6.png" class="calibre215"/></div>
<ol start="7" class="calibre13">
<li class="calibre11">Then, click <span>Publish release</span>.</li>
</ol>
<p class="calibre2">If there are any problems, Attobot will open issues in the repo—make sure you address them. Once done, the package will be registered! Victory!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre2">It is exciting to see our package finally ready!</p>
<p class="calibre2">While developing it, we've also learned about Julia's powerful toolbox, and about some of the most important best practices of software development in general—TDD, unit testing, benchmarking, and documenting our code base and publishing the resulting documentation.</p>
<p class="calibre2">This also concludes our journey into learning the Julia language. We've come a long way since opening the REPL for the first time—and you have achieved some impressive feats! Data analysis, plotting, web scraping, recommenders, supervised and unsupervised machine learning, and time series analysis and forecasting! You are now able to do all these things using Julia. Wow! That's quite an amazing track record indeed! And, if doing all this seemed easy, it's all due to Julia's incredible features. The productive REPL, the simple package installation, the handy plotting packages, or the readable syntax; they all make programming easy and fun.</p>
<p class="calibre2">Julia really is a new breed of programming language. As it is new, it is able to learn from the most successful programming languages by borrowing from their strengths, and avoid their mistakes. Julia was specifically designed to efficiently address the needs of our generation—machine learning, artificial intelligence, high performance, parallel, GPU, and distributed cloud computing<span class="calibre5">—</span>these are all areas where the language excels.</p>
<p class="calibre2">But, not only does Julia provide efficient language constructs for writing highly performant code—it also makes for a productive development experience. The powerful REPL (one of the best REPLs in all existing programming languages, period!) and the JIT compilation make it easy to quickly prototype solutions, slice and dice large amounts of data, or experiment with data models on the fly. The integrated help mode and the powerful shell mode empower developers, boosting productivity.</p>
<p class="calibre2">Then there's the seamless integration with Jupyter Notebooks via IJulia—and the incredible cross-language integration with established programming languages such as Python and R. If you've used with these technologies, switching to Julia should be straightforward.</p>
<p class="calibre2">But the fact that Julia is new, just reaching version 1, does not mean that Julia is not a mature language. It's been crafted with care and attention for over six years—with contributions from thousands of developers. So, I encourage you to start using Julia for solving real problems. You'd be joining tens of thousands of other developers using the language professionally, for scientific computing, data science, AI, fintech, web development, teaching, and much more. Household names such as Apple, Amazon, Facebook, and Oracle—to name just a few—were all looking to hire Julia programmers in 2017.</p>
<p class="calibre2">I hope you enjoyed reading this book as much as I enjoyed writing it. You are now prepared<span class="calibre5">—</span>and I hope eager—to use Julia in your projects. So, instead of <em class="calibre16">Goodbye</em>, I'd like to say—<em class="calibre16">Welcome to the wonderful world of Julia programming!</em></p>


            </article>

            
        </section>
    </body></html>