- en: Chapter 9. AdventureWorks Production – Neural Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One day you are sitting in your office, basking in the glow of your new-found
    rock star status at AdventureWorks when your boss knocks on the door. She says,
    "Since you did such a good job with the consumer-facing portion of our existing
    website, we want to know if you would be interested in working on an internally-facing
    greenfield project." You cut her off with a resounding, "Yes!" She smiles and
    continues, "Okay. The problem is in our production area. Management is very interested
    in how we can reduce our scrap amount. Every month we get a report from Excel
    that looks like this:"
  prefs: []
  type: TYPE_NORMAL
- en: '![AdventureWorks Production – Neural Networks](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '"The problem is that we don''t know what to do with this data. Production is
    a complex workflow with many variables that can impact whether an item gets scrapped.
    We are looking for two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A way of identifying the items that most impact whether items get scrapped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tool that allows our planners to alter the key variables to play *what if…*
    and make changes to the production process"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You tell your boss okay. Since this is a greenfield application and you have
    been hearing the hype around ASP.NET Core 1.0, this seems like a great place to
    try it. Also, you have heard about one of the hot models in data science, neural
    networks, and want to see whether the reality matches the hype.
  prefs: []
  type: TYPE_NORMAL
- en: Neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A relative latecomer to data science, neural networks attempt to have the computer
    imitate how the brain operates. The gray matter between our ears is very good,
    up to a point, at making connections and drawing inferences. The promise of neural
    networks is that if we can build models that are patterned after how our brain
    works, we can combine the speed of computers and the pattern-matching ability
    of our wetware to make a learning model that can provide insights that computers
    or humans alone might miss.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Neural networks takes their vocabulary from the actual brain; a neural network
    is a collection of neurons. If you remember from Biology 101 (or Crysis 2), the
    brain has billions of neurons that look more or less like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Background](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The axon terminal of one neuron connects to another neuron's dendrite. Since
    an individual neuron can have multiple dendrites and axon terminals, neurons can
    connect, and be connected to, numerous other neurons. The actual connection area
    between two neurons is called the synapse. Our brains use electrical signals to
    pass messages among neurons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Background](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since we are modeling the human brain for neural networks, it stands to reason
    that we will use the same vocabulary. In a neural network, we have a series of
    inputs and an output. Between the inputs and outputs, there is a hidden layer
    comprising neurons. Any connection from the inputs into the hidden layer, among
    the neurons inside the hidden layer, and from the hidden layer to the output is
    called a synapse.
  prefs: []
  type: TYPE_NORMAL
- en: '![Background](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that every synapse connects only to the neurons (or output) to its immediate
    right. Data always flows in one direction in a neural network and synapses never
    connect to themselves or any other preceding neuron in the network. One more thing
    to note is that when the hidden layer has many neurons, it is called a deep belief
    network (or deep learning). We will not be covering deep belief networks in this
    book, though it is certainly something you might want to toss around the next
    time you are out bowling with friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a neural network, the synapse has only one job. They form a connection from
    one neuron to the next, applying a weight to that connection. For example, Neuron
    1 activates the synapse with a weight of two, so that Neuron 2 receives an input
    of two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Background](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Neurons have a more complicated job. They take in the values from all of their
    input synapses, take input from something called a bias (I''ll get to that in
    a second), apply an activation function to the inputs, and then either output
    a signal or do nothing. The activation function can treat each input separately,
    combine them, or do a mixture of both. There are many kinds of activation functions,
    ranging from simple to mind-boggling. In this example, the inputs are added together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Background](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some neural networks are smart enough to add and drop neurons as needed. For
    this book, we will not be doing anything like that—we will fix the number of neurons
    in each layer. Going back to some vocabulary that I dropped on you in the preceding
    paragraph, there are two kinds of inputs for any given activation function inside
    a neuron: the weights as transmitted by the synapses and the bias. The weights
    are a number that is assigned to the synapse, depending on the nature of the synapse,
    and does not change during the lifetime of the neural network. The bias is a global
    value that is assigned to all neurons (and output) which, unlike the weights,
    changes frequently. The machine learning component of the neural network is the
    many iterations that the computer does to create the best combination of weights
    and bias to give the optimal predictive score.'
  prefs: []
  type: TYPE_NORMAL
- en: Neural network demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this mental model in place, let''s take a look at a neural network in
    action. Let''s look at a series of students who studied and drank beer before
    an exam and compare whether they passed that exam or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neural network demo](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have two input (*x*) variables (**Hours Studying** and **Beers Drank**),
    our neural network will have two inputs. We have one dependent variable (**Passed?**)
    so our neural network will have one output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neural network demo](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'One thing to note is that the number of inputs depends on the range of values.
    So if we had a categorical input (such as male/female), we would have a number
    of inputs that correspond to the range of values in the category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neural network demo](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go into Visual Studio and create a new C# ASP.NET web application:![Neural network
    demo](img/00132.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next dialog box, select **ASP.NET 5 Templates** and change the authentication
    type to **No Authentication**. Note that the templates will probably change from
    ASP.NET 5 to ASP.NET Core 1 after the writing of this book. You can consider these
    two terms synonymously.![Neural network demo](img/00133.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything code-gens as it should, you will get the following project:![Neural
    network demo](img/00134.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's add an F# Windows Library project:![Neural network demo](img/00135.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the F# project has been created, open up the NuGet Package Manager Console
    and install numl. Make sure that you are targeting the F# project for the NuGet
    installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Neural network demo](img/00136.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Rename `Scipt1.fsx` to `StudentNeuralNetwork.fsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the script and replace everything in it with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you send this to the FSI, you will get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you worked through the example in [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    this code will look familiar. The `Student` type has three properties: `Study`,
    `Beer`, and `Passed`. Note that `Passed` is marked as mutable because numl expects
    any prediction data type to be of the same type that was used when the model was
    created. Numl then mutates the response variable to whatever the model comes up
    with, so we have to use the mutable keyword. Alternative implementations would
    be to pass into the prediction function a type without that response variable
    or return a new instance so the value can be immutable. Feel free to contribute
    to the open source project if you feel strongly about this (I''ll see you there
    J).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In any event, the data is an array of instances of our students. We then create
    a descriptor of the `Student` type and a generator of a neural network. Notice
    that we know the generator''s `descriptor` property is mutable because we assign
    it using the `<-` symbol in this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we pass the generator to the learner and create the model. Under the
    hood, numl is scaling our data and running multiple instances of a neural network
    to determine the optimal solution. Once the generator has finished its work, it
    reports that it has an accuracy of 100%. We can then test our neural network with
    some new data. Go to the script and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send this to the FSI, you will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, our student who studies 7 hours and has 1 beer will pass the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neural network – try #1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the theory out of the way, let''s see if neural networks can help us with
    AdventureWorks. As in [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    let''s see if we can use a business area expert to help us formulate some viable
    hypotheses. When we visit the manager of manufacturing, he says, "I think there
    are a couple of areas that you should look at. See if the production location
    has an impact. We have seven major locations":'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neural network – try #1](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '"I am curious if our **Paint** location generates more than expected defects
    because we have high turnover in that area."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Also, see if there is a relationship between vendors and products with defects.
    In some cases, we purchase parts for a single vendor; in other cases, we have
    two or three vendors supplying us parts. We don''t track which part came from
    which vendor when we build a bike, but perhaps you can find that certain vendors
    are associated with purchase orders that have defects."'
  prefs: []
  type: TYPE_NORMAL
- en: 'These seem like two good places to start, so let''s head over to the **Solution
    Explorer** and create a new script file called `AWNeuralNetwork.fsx` in the F#
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neural network – try #1](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, open up the NuGet Package Manager and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the script file and enter this (note that the version number might
    be different for you):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL will give you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s tackle the location hypothesis. Go to the script and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see we have a record type with each location as a field and an indicator
    if there was anything scrapped. The level of automacy for this data structure
    is work order. Each order might visit one or all of the locations and might have
    some scrap quantity. The `getWorkOrderFunction` takes the `WorkOrderLocation`
    table, where each location is a row in the table, and flattens into this `WorkOrderLocation`
    record type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go back to the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending this to the REPL gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code is very much what you saw in [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*. We go to
    the database and pull in all the work orders and then map the locations into our
    `WorkOrderLocation` record. Notice that we are using the `PSeq` so that we can
    get a performance boost by making simultaneous calls to the database to get the
    locations for each work order.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the data local, let''s try out a neural network. Go into the script file
    and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending that to the REPL, after a long wait, will give you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, ugh, it does not look like the location can predict where defects might
    occur. As we saw in [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    sometimes you do not need a working model to make the experiment worthwhile. In
    this case, we can go back to the director and tell him that scraps are occurring
    all over his production location, not just in the painting (so much for blaming
    the new guy).
  prefs: []
  type: TYPE_NORMAL
- en: 'Neural network – try #2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see if we can find anything using the director''s second hypothesis
    that certain vendors might have higher defect rates than others. Go back to the
    script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send it to the FSI, you will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `VendorProduct` record type should be familiar to you. The next code block
    creates an array of 1,000 random work order IDs. As we learned from the first
    experiment, neural networks take a long time to complete. We will look at some
    big-data solutions in the next chapter, but until then we'll do what data scientists
    have done for as long as they have done data science—take a sample of the larger
    dataset. Notice that we are using the `Array.Mapi` high-order function so that
    we can use the index value to locate the correct value in the work orders array.
    Unfortunately, we can't pass the index into the type provider and have it evaluate
    on the server, so the entire work order table is brought local so that we can
    use the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter this into the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send it to the FSI, after a bit of a wait, you will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first line is the `in` (`|=|`) operator that we ran across in [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*. The next
    code block hydrates the `vendorData` array with the data from the 1,000 randomly
    selected work orders. Notice that there is some repetition because each work order
    will use several parts and each part might be supplied by a variety of vendors
    (in this case, called business entities).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the data local, go into the script and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send it to the FSI, you will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is interesting. We have a very high accuracy rate. One wonders: is
    this because in the case of a single vendor for a product, all of the scrapped
    amount will be associated with them because they are the only ones. However, since
    a single vendor might supply multiple input products and those products might
    have different scrap rates, you can use the model to predict if a given vendor
    and a given product will have a scrap rate. Also, notice that instead of adding
    an input for each vendor and product (which would have made a very sparse data
    frame), there is one input for vendor and one for product. Although these can
    be considered categorical values, we can sacrifice some precision for this exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: The key thing about the neural network that you will want to remember is that
    the neural network can't tell you how it got its answer (very much like the human
    brain, no?). So the neural network won't report back which combination of vendors
    and products will lead to defects. To do that, you would need to use a different
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this neural network giving us enough of what we need, let's go ahead and
    build out our ASP.NET 5.0 application with the model. At the time of writing,
    ASP.NET 5.0 only supports C# so we will have to translate our F# into C# and port
    the code into the application. Once the other languages are supported by ASP.NET,
    we will update the sample code on the website.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with C#, it is the most popular language on the .NET
    stack and is very similar to Java. C# is a general-purpose language that initially
    combined imperative and object-oriented language features. Lately, functional
    constructs have been bolted onto the language specifications. However, as the
    old carpenter axiom goes, "If it's a screw, use a screwdriver. If it's a nail,
    use a hammer." Since that's the case, you are much better served to do .NET functional
    programming with F#. I'll do my best in the next section to explain any differences
    in the C# implementation when we port the code over.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already have the boilerplate MVC site created. Open up NuGet Package Manager
    Console and install numl into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Setting up the models](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create a folder called `Models` in the **Solution Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the models](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In that folder, add a new class file named `VendorProduct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the models](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside that file, replace all of the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can guess, this is the equivalent of the record type we create in F#.
    The only real difference is that the properties are mutable by default (so be
    careful). Go to the **Solution Explorer** and find the `Project.json` file. Open
    it and remove this entry in the `frameworks` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This section should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the models](img/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go ahead and run the website to make sure it is good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the models](img/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What we are doing is removing the site's dependency on .NET Core. Although numl
    does support .NET Core, we don't need it right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the site is up and running, let''s add the rest of our helper classes. Go
    back into the **Solution Explorer** and add a new class file named `Product.cs`.
    Go into that class and replace the existing code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is another record-equivalent class which will be used when the user selects
    the `Product` they want to model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the **Solution Explorer** and add a new class file named `Vendor.cs`.
    Go into that class and replace the existing code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Like the `Product` class, this will be used to populate the select list for
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back into the **Solution Explorer** and add a new class file named `Repository.cs`.
    Go into that class and replace the existing code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can probably guess, this is the class that calls out to the database.
    Since C# does not have type providers, we need to handwrite the ADO.NET code.
    We will need to add a reference to `System.Data` to make this code work. Go into
    the **References** in **Solution Explorer** and add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the models](img/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can run the site again to make sure we are on the right track. In the **Solution
    Explorer**, add a class file called `NeuralNetwork.cs`. Replace all of its code
    with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This class does the heavy lifting of the neural network calculations for us.
    Notice that the class is data–agnostic, so it can be ported over to .NET Core
    easily. All we need is a collection of `VendorProducts` to be passed into the
    constructor for the neural network to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of these classes created, your solution explorer should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the models](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You should be able to compile and run the website. Let's now implement a user
    interface for the neural network.
  prefs: []
  type: TYPE_NORMAL
- en: Building the UX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will guide you to build the UX:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the **Solution Explorer** and select **AdventureWorks.ProcessAnalysisTool**.
    Navigate to **Add** | **New Item**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next dialog, select **Class** and name it `Global.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the `Global` class and replace all of the contents with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This class creates a new neural network for us. We can access the neural network's
    functions via the read-only property called `Neural Network`. Because it is marked
    static, the class will stay in memory as long as the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, locate the `Startup.cs` file in the main site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the file and replace the constructor (called `Startup`) with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When the website starts up, it will create a global neural network that all
    requests can use.
  prefs: []
  type: TYPE_NORMAL
- en: Next, locate the `HomeController` in the `Controllers` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open that file and add this method to populate some drop lists of vendors and
    products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add this method to run `Calculate` on the global neural network when
    the vendor and product are posted back to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you collapse to definitions, the `HomeController` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, go into **Solution Explorer** and navigate to **AdventureWorks.ProcessAnalysisTool**
    | **Views** | **Home**. Right-click on the folder and navigate to **Add** | **New
    Item**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next dialog box, select **MVC View Page** and name it `PredictScrap.cshtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open this page and replace all of the contents with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the input form that will allow users to select vendors and products
    and see what the neural network will predict—whether this combination will have
    scrap. When you run the site and navigate to `localhost:port/home/PredictScrap`
    for the first time, you will see the droplists ready for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select a vendor and a product and click on **Predict!**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UX](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a fully functioning ASP .NET Core 1.0 website that uses a neural
    network to predict AdventureWorks scrap percentages. With this skeleton, we can
    hand the site off to a UX expert to make the site have a better look and feel—with
    the core functionality in place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter broke some new ground. We dove into ASP.NET 5.0 for our website
    design. We used numl to create two neural networks: one that showed that there
    is no relationship between the area of the company and the scrap rate, and another
    that can be used to predict if there will be scrap based on the vendor and product.
    We then implemented the second model in our website.'
  prefs: []
  type: TYPE_NORMAL
