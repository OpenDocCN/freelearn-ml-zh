- en: Chapter 1. Applying Geometric Transformations to Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 将几何变换应用于图像
- en: In this chapter, we are going to learn how to apply cool geometric effects to
    images. Before we get started, we need to install OpenCV-Python. We will discuss
    how to install the necessary tools and packages as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将酷炫的几何效果应用于图像。在我们开始之前，我们需要安装OpenCV-Python。我们将讨论如何安装必要的工具和包。
- en: 'By the end of this chapter, you will know:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将知道：
- en: How to install OpenCV-Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装OpenCV-Python
- en: How to read, display, and save images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取、显示和保存图像
- en: How to convert between multiple color spaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在多个颜色空间之间进行转换
- en: How to apply geometric transformations like translation, rotation, and scaling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何应用几何变换，如平移、旋转和缩放
- en: How to use affine and projective transformations to apply funny geometric effects
    on photos
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用仿射和投影变换在照片上应用有趣的几何效果
- en: Installing OpenCV-Python
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装OpenCV-Python
- en: Let's see how to install OpenCV with Python support on multiple platforms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在多个平台上使用Python支持安装OpenCV。
- en: Windows
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: 'In order to get OpenCV-Python up and running, we need to perform the following
    steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让OpenCV-Python正常运行，我们需要执行以下步骤：
- en: 'Install Python: Make sure you have Python 2.7.x installed on your machine.
    If you don''t have it, you can install it from [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Python：确保您的计算机上已安装Python 2.7.x。如果您没有安装，可以从[https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)安装。
- en: 'Install NumPy: NumPy is a great package to do numerical computing in Python.
    It is very powerful and has a wide variety of functions. OpenCV-Python plays nicely
    with NumPy, and we will be using this package a lot, during the course of this
    book. You can install the latest version from [http://sourceforge.net/projects/numpy/files/NumPy/](http://sourceforge.net/projects/numpy/files/NumPy/)'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装NumPy：NumPy是一个在Python中进行数值计算的优秀包。它非常强大，具有多种功能。OpenCV-Python与NumPy配合良好，我们将在本书的整个过程中大量使用这个包。您可以从[http://sourceforge.net/projects/numpy/files/NumPy/](http://sourceforge.net/projects/numpy/files/NumPy/)安装最新版本。
- en: 'We need to install all these packages in their default locations. Once we install
    Python and NumPy, we need to ensure that they''re working fine. Open up the Python
    shell and type the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这些包安装在其默认位置。一旦我们安装了Python和NumPy，我们需要确保它们运行良好。打开Python shell并输入以下内容：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the installation has gone well, this shouldn't throw any error. Once you
    confirm it, you can go ahead and download the latest OpenCV version from [http://opencv.org/downloads.html](http://opencv.org/downloads.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装顺利，这不应该抛出任何错误。一旦您确认，您就可以继续下载最新的OpenCV版本，从[http://opencv.org/downloads.html](http://opencv.org/downloads.html)。
- en: 'Once you finish downloading it, double-click to install it. We need to make
    a couple of changes, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，双击安装。我们需要进行一些更改，如下所示：
- en: Navigate to `opencv/build/python/2.7/`
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`opencv/build/python/2.7/`
- en: You will see a file named `cv2.pyd`. Copy this file to `C:/Python27/lib/site-packages`
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个名为`cv2.pyd`的文件。将此文件复制到`C:/Python27/lib/site-packages`。
- en: 'You''re all set! Let''s make sure that OpenCV is working. Open up the Python
    shell and type the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经设置好了！让我们确保OpenCV正在运行。打开Python shell并输入以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you don't see any errors, then you are good to go! You are now ready to use
    OpenCV-Python.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到任何错误，那么您就可以开始了！您现在可以使用OpenCV-Python了。
- en: Mac OS X
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mac OS X
- en: 'To install OpenCV-Python, we will be using **Homebrew**. Homebrew is a great
    package manager for Mac OS X and it will come in handy when you are installing
    various libraries and utilities on OS X. If you don''t have Homebrew, you can
    install it by running the following command on your terminal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装OpenCV-Python，我们将使用**Homebrew**。Homebrew是Mac OS X的一个优秀的包管理器，当您在OS X上安装各种库和实用程序时，它将非常有用。如果您没有Homebrew，您可以通过在终端运行以下命令来安装它：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Even though OS X comes with inbuilt Python, we need to install Python using
    Homebrew to make our lives easier. This version is called brewed Python. Once
    you install Homebrew, the next step is to install brewed Python. Open up the terminal
    and type the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OS X自带Python，但我们需要使用Homebrew安装Python以简化我们的操作。这个版本被称为brewed Python。一旦您安装了Homebrew，下一步就是安装brewed
    Python。打开终端并输入以下内容：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will automatically install `pip` as well. Pip is a package management
    tool to install packages in Python and we will be using it to install other packages.
    Let''s make sure the brewed Python is working correctly. Go to your terminal and
    type the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动安装 `pip`。Pip 是一个用于在 Python 中安装包的包管理工具，我们将使用它来安装其他包。让我们确保已正确安装了 brewed Python。转到你的终端并输入以下内容：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see `/usr/local/bin/python` printed on the terminal. This means
    that we are using the brewed Python and not the inbuilt system Python. Now that
    we have installed brewed Python, we can go ahead and add the repository, `homebrew/science`,
    which is where OpenCV is located. Open the terminal and run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端看到 `/usr/local/bin/python` 被打印出来。这意味着我们正在使用 brewed Python 而不是内置的系统 Python。现在我们已经安装了
    brewed Python，我们可以继续添加仓库 `homebrew/science`，这是 OpenCV 所在的位置。打开终端并运行以下命令：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Make sure the package NumPy is installed. If not, run the following in your
    terminal:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已安装 NumPy 包。如果没有，请在终端运行以下命令：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we are ready to install OpenCV. Go ahead and run the following command
    from your terminal:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好安装 OpenCV。从你的终端运行以下命令：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'OpenCV is now installed on your machine and you can find it at `/usr/local/Cellar/opencv/2.4.9/`.
    You can''t use it just yet. We need to tell Python where to find our OpenCV packages.
    Let''s go ahead and do that by symlinking the OpenCV files. Run the following
    commands from your terminal:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 现已安装在你的机器上，你可以在 `/usr/local/Cellar/opencv/2.4.9/` 找到它。你现在还不能使用它。我们需要告诉
    Python 哪里可以找到我们的 OpenCV 包。让我们继续通过符号链接 OpenCV 文件来完成这个操作。从你的终端运行以下命令：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You''re all set! Let''s see if it''s installed properly. Open up the Python
    shell and type the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好了！让我们看看它是否已正确安装。打开 Python 命令行界面并输入以下内容：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the installation went well, you will not see any error message. You are now
    ready to use OpenCV in Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装顺利，你将不会看到任何错误消息。你现在可以使用 Python 中的 OpenCV 了。
- en: Linux (for Ubuntu)
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux (针对 Ubuntu)
- en: 'Before we start, we need to install some dependencies. Let''s install them
    using the package manager as shown below:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要安装一些依赖项。让我们使用以下包管理器安装它们：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that you have installed the necessary packages, let''s go ahead and build
    OpenCV with Python support:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了必要的包，让我们继续使用 Python 支持构建 OpenCV：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s make sure that it''s installed correctly. Open up the Python shell and
    type the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保它已正确安装。打开 Python 命令行界面，并输入以下内容：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you don't see any errors, you are good to go.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到任何错误，那么你就可以继续了。
- en: If you have any other Linux distribution, please refer to the OpenCV downloads
    page ([http://opencv.org/downloads.html](http://opencv.org/downloads.html)) for
    installation details.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是其他 Linux 发行版，请参考 OpenCV 下载页面 ([http://opencv.org/downloads.html](http://opencv.org/downloads.html))
    以获取安装详情。
- en: Reading, displaying, and saving images
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取、显示和保存图像
- en: Let's see how we can load an image in OpenCV-Python. Create a file named `first_program.py`
    and open it in your favorite code editor. Create a folder named `images` in the
    current folder and make sure that you have an image named `input.jpg` in that
    folder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 OpenCV-Python 中加载一个图像。创建一个名为 `first_program.py` 的文件，并在你喜欢的代码编辑器中打开它。在当前文件夹中创建一个名为
    `images` 的文件夹，并确保在该文件夹中有一个名为 `input.jpg` 的图像。
- en: 'Once you do that, add the following lines to that Python file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，将以下行添加到那个 Python 文件中：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you run the preceding program, you will see an image being displayed in a
    new window.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的程序，你将看到一个图像在新窗口中显示。
- en: What just happened?
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Let's understand the previous piece of code, line by line. In the first line,
    we are importing the OpenCV library. We need this for all the functions we will
    be using in the code. In the second line, we are reading the image and storing
    it in a variable. OpenCV uses NumPy data structures to store the images. You can
    learn more about NumPy at [http://www.numpy.org](http://www.numpy.org)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行理解前面的代码。在第一行，我们正在导入 OpenCV 库。我们需要这个库来使用代码中的所有函数。在第二行，我们正在读取图像并将其存储在一个变量中。OpenCV
    使用 NumPy 数据结构来存储图像。你可以在 [http://www.numpy.org](http://www.numpy.org) 上了解更多关于 NumPy
    的信息。
- en: 'So if you open up the Python shell and type the following, you will see the
    datatype printed on the terminal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你打开 Python 命令行界面并输入以下内容，你将在终端看到打印出的数据类型：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next line, we display the image in a new window. The first argument in
    `cv2.imshow` is the name of the window. The second argument is the image you want
    to display.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们在新窗口中显示图像。`cv2.imshow` 中的第一个参数是窗口的名称，第二个参数是你想要显示的图像。
- en: You must be wondering why we have the last line here. The function, `cv2.waitKey()`,
    is used in OpenCV for keyboard binding. It takes a number as an argument, and
    that number indicates the time in milliseconds. Basically, we use this function
    to wait for a specified duration, until we encounter a keyboard event. The program
    stops at this point, and waits for you to press any key to continue. If we don't
    pass any argument or if we pass `0` as the argument, this function will wait for
    a keyboard event indefinitely.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么这里有一行。函数`cv2.waitKey()`在OpenCV中用于键盘绑定。它接受一个数字作为参数，该数字表示毫秒数。基本上，我们使用这个函数来等待指定的时间，直到我们遇到键盘事件。程序在此处停止，等待您按任意键继续。如果我们不传递任何参数或传递`0`作为参数，此函数将无限期地等待键盘事件。
- en: Loading and saving an image
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和保存图像
- en: 'OpenCV provides multiple ways of loading an image. Let''s say we want to load
    a color image in grayscale mode. We can do that using the following piece of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了多种加载图像的方法。假设我们想要以灰度模式加载彩色图像。我们可以使用以下代码片段来完成：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we are using the flag `cv2.IMREAD_GRAYSCALE` to load the image in grayscale
    mode. You can see that from the image being displayed in the new window. Next,
    is the input image:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用标志`cv2.IMREAD_GRAYSCALE`以灰度模式加载图像。您可以从新窗口中显示的图像中看到这一点。接下来，是输入图像：
- en: '![Loading and saving an image](img/B04554_01_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![加载和保存图像](img/B04554_01_01.jpg)'
- en: 'Following is the corresponding grayscale image:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的灰度图像：
- en: '![Loading and saving an image](img/B04554_01_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![加载和保存图像](img/B04554_01_02.jpg)'
- en: 'We can save this image into a file as well:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将此图像保存到文件中：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will save the grayscale image into an output file named `output.jpg`. Make
    sure you get comfortable with reading, displaying, and saving images in OpenCV,
    because we will be doing this quite a bit during the course of this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把灰度图像保存到名为`output.jpg`的输出文件中。确保您熟悉在OpenCV中读取、显示和保存图像，因为在本书的整个过程中我们将做很多这样的操作。
- en: Image color spaces
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像颜色空间
- en: 'In computer vision and image processing, color space refers to a specific way
    of organizing colors. A color space is actually a combination of two things: a
    color model and a mapping function. The reason we want color models is because
    it helps us in representing pixel values using tuples. The mapping function maps
    the color model to the set of all possible colors that can be represented.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉和图像处理中，颜色空间指的是组织颜色的特定方式。颜色空间实际上是两件事的组合：一个颜色模型和一个映射函数。我们想要颜色模型的原因是它帮助我们使用元组表示像素值。映射函数将颜色模型映射到可以表示的所有可能颜色的集合。
- en: 'There are many different color spaces that are useful. Some of the more popular
    color spaces are RGB, YUV, HSV, Lab, and so on. Different color spaces provide
    different advantages. We just need to pick the color space that''s right for the
    given problem. Let''s take a couple of color spaces and see what information they
    provide:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的颜色空间非常有用。其中一些更流行的颜色空间是RGB、YUV、HSV、Lab等等。不同的颜色空间提供不同的优势。我们只需要选择适合给定问题的颜色空间。让我们来看几个颜色空间，看看它们提供了哪些信息：
- en: '**RGB**: It''s probably the most popular color space. It stands for Red, Green,
    and Blue. In this color space, each color is represented as a weighted combination
    of red, green, and blue. So every pixel value is represented as a tuple of three
    numbers corresponding to red, green, and blue. Each value ranges between 0 and
    255.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RGB**：这可能是最流行的颜色空间。它代表红色、绿色和蓝色。在这个颜色空间中，每种颜色都表示为红色、绿色和蓝色的加权组合。因此，每个像素值都表示为对应于红色、绿色和蓝色的三个数字的元组。每个值介于0到255之间。'
- en: '**YUV**: Even though RGB is good for many purposes, it tends to be very limited
    for many real life applications. People started thinking about different methods
    to separate the intensity information from the color information. Hence, they
    came up with the YUV color space. Y refers to the luminance or intensity, and
    U/V channels represent color information. This works well in many applications
    because the human visual system perceives intensity information very differently
    from color information.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YUV**：尽管RGB在许多用途中都很好，但它对于许多实际应用来说往往非常有限。人们开始考虑不同的方法来分离强度信息与颜色信息。因此，他们提出了YUV颜色空间。Y代表亮度或强度，U/V通道代表颜色信息。这在许多应用中都很好，因为人眼对强度信息和颜色信息的感知方式非常不同。'
- en: '**HSV**: As it turned out, even YUV was still not good enough for some of the
    applications. So people started thinking about how humans perceive color and they
    came up with the HSV color space. HSV stands for Hue, Saturation, and Value. This
    is a cylindrical system where we separate three of the most primary properties
    of colors and represent them using different channels. This is closely related
    to how the human visual system understands color. This gives us a lot of flexibility
    as to how we can handle images.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HSV**：结果证明，即使是 YUV 对于某些应用来说还不够好。因此，人们开始思考人类如何感知颜色，并提出了 HSV 颜色空间。HSV 代表色调、饱和度和亮度。这是一个圆柱系统，我们通过不同的通道来分离颜色的三个最基本属性。这与人类视觉系统理解颜色的方式密切相关。这为我们提供了很多灵活性，关于我们如何处理图像。'
- en: Converting between color spaces
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色空间之间的转换
- en: 'Considering all the color spaces, there are around 190 conversion options available
    in OpenCV. If you want to see a list of all available flags, go to the Python
    shell and type the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有颜色空间，OpenCV 中大约有 190 种转换选项可用。如果你想查看所有可用标志的列表，请转到 Python 壳中并输入以下内容：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You will see a list of options available in OpenCV for converting from one
    color space to another. We can pretty much convert any color space into any other
    color space. Let''s see how we can convert a color image into a grayscale image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到 OpenCV 中可用于从一种颜色空间转换到另一种颜色空间的选项列表。我们可以将任何颜色空间转换为任何其他颜色空间。让我们看看如何将彩色图像转换为灰度图像：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What just happened?
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'We use the function `cvtColor` to convert between color spaces. The first argument
    is the input image and the second argument specifies the color space conversion.
    You can convert to YUV by using the following flag:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `cvtColor` 函数在颜色空间之间进行转换。第一个参数是输入图像，第二个参数指定颜色空间转换。你可以使用以下标志将图像转换为 YUV：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The image will look something like the following one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图像看起来可能像以下这样：
- en: '![What just happened?](img/B04554_01_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_03.jpg)'
- en: 'This may look like a deteriorated version of the original image, but it''s
    not. Let''s separate out the three channels:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是原始图像的退化版本，但事实并非如此。让我们分离出三个通道：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since `yuv_img` is a numPy array, we can separate out the three channels by
    slicing it. If you look at `yuv_img.shape`, you will see that it is a 3D array
    whose dimensions are `NUM_ROWS x NUM_COLUMNS x NUM_CHANNELS`. So once you run
    the preceding piece of code, you will see three different images. Following is
    the `Y` channel:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `yuv_img` 是一个 NumPy 数组，我们可以通过切片来分离出三个通道。如果你查看 `yuv_img.shape`，你会看到它是一个三维数组，其维度是
    `NUM_ROWS x NUM_COLUMNS x NUM_CHANNELS`。所以一旦运行前面的代码片段，你会看到三幅不同的图像。以下是 `Y` 通道：
- en: '![What just happened?](img/B04554_01_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_04.jpg)'
- en: 'The `Y` channel is basically the grayscale image. Next is the `U` channel:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Y` 通道基本上是灰度图像。接下来是 `U` 通道：'
- en: '![What just happened?](img/B04554_01_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_05.jpg)'
- en: 'And lastly, the `V` channel:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是 `V` 通道：
- en: '![What just happened?](img/B04554_01_06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_06.jpg)'
- en: As we can see here, the `Y` channel is the same as the grayscale image. It represents
    the intensity values. The `U` and `V` channels represent the color information.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Y` 通道与灰度图像相同。它表示强度值。`U` 和 `V` 通道表示颜色信息。
- en: 'Let''s convert to HSV and see what happens:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换到 HSV 看看会发生什么：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![What just happened?](img/B04554_01_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_07.jpg)'
- en: 'Again, let''s separate the channels:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们分离通道：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you run the preceding piece of code, you will see three different images.
    Take a look at the `H` channel:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行前面的代码片段，你会看到三幅不同的图像。看看 `H` 通道：
- en: '![What just happened?](img/B04554_01_08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_08.jpg)'
- en: 'Next is the `S` channel:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `S` 通道：
- en: '![What just happened?](img/B04554_01_09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_09.jpg)'
- en: 'Following is the `V` channel:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `V` 通道：
- en: '![What just happened?](img/B04554_01_10.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_10.jpg)'
- en: This should give you a basic idea of how to convert between color spaces. You
    can play around with more color spaces to see what the images look like. We will
    discuss the relevant color spaces as and when we encounter them during subsequent
    chapters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给你一个关于如何在颜色空间之间转换的基本概念。你可以尝试更多的颜色空间，看看图像看起来像什么。我们将在后续章节中遇到相关颜色空间时进行讨论。
- en: Image translation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像转换
- en: 'In this section, we will discuss about shifting an image. Let''s say we want
    to move the image within our frame of reference. In computer vision terminology,
    this is referred to as `translation`. Let''s go ahead and see how we can do that:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何移动图像。假设我们想要在参考框架内移动图像。在计算机视觉术语中，这被称为`平移`。让我们看看我们如何实现这一点：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you run the preceding code, you will see something like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上一段代码，你会看到如下所示的内容：
- en: '![Image translation](img/B04554_01_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图像平移](img/B04554_01_11.jpg)'
- en: What just happened?
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'To understand the preceding code, we need to understand how warping works.
    Translation basically means that we are shifting the image by adding/subtracting
    the X and Y coordinates. In order to do this, we need to create a transformation
    matrix, as shown as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解前面的代码，我们需要了解扭曲是如何工作的。平移基本上意味着我们通过添加/减去X和Y坐标来移动图像。为了做到这一点，我们需要创建一个变换矩阵，如下所示：
- en: '![What just happened?](img/B04554_01_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_12.jpg)'
- en: 'Here, the **tx** and **ty** values are the X and Y translation values, that
    is, the image will be moved by `X` units towards the right, and by `Y` units downwards.
    So once we create a matrix like this, we can use the function, `warpAffine`, to
    apply to our image. The third argument in `warpAffine` refers to the number of
    rows and columns in the resulting image. Since the number of rows and columns
    is the same as the original image, the resultant image is going to get cropped.
    The reason for this is because we didn''t have enough space in the output when
    we applied the translation matrix. To avoid cropping, we can do something like
    this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**tx**和**ty**值是X和Y平移值，即图像将向右移动`X`个单位，向下移动`Y`个单位。因此，一旦我们创建了一个这样的矩阵，我们就可以使用`warpAffine`函数将其应用于我们的图像。`warpAffine`函数中的第三个参数指的是结果图像的行数和列数。由于行数和列数与原始图像相同，结果图像将被裁剪。这是因为我们在应用平移矩阵时输出空间不足。为了避免裁剪，我们可以这样做：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you replace the corresponding line in our program with the preceding line,
    you will see the following image:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将程序中相应的行替换为上一行，你会看到以下图像：
- en: '![What just happened?](img/B04554_01_13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_13.jpg)'
- en: 'Let''s say you want to move the image in the middle of a bigger image frame;
    we can do something like this by carrying out the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要将图像移动到更大图像框架的中间；我们可以通过执行以下操作来实现类似的效果：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you run the preceding code, you will see an image like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上一段代码，你会看到如下所示的图像：
- en: '![What just happened?](img/B04554_01_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_14.jpg)'
- en: Image rotation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像旋转
- en: 'In this section, we will see how to rotate a given image by a certain angle.
    We can do it using the following piece of code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何通过一定的角度旋转给定的图像。我们可以使用以下代码片段来完成：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run the preceding code, you will see an image like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上一段代码，你会看到如下所示的图像：
- en: '![Image rotation](img/B04554_01_15.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图像旋转](img/B04554_01_15.jpg)'
- en: What just happened?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'In order to understand this, let''s see how we handle rotation mathematically.
    Rotation is also a form of transformation, and we can achieve it by using the
    following transformation matrix:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，让我们看看我们如何从数学上处理旋转。旋转也是一种变换形式，我们可以通过以下变换矩阵来实现：
- en: '![What just happened?](img/B04554_01_16.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_16.jpg)'
- en: Here, `θ` is the angle of rotation in the counterclockwise direction. OpenCV
    provides closer control over the creation of this matrix through the function,
    `getRotationMatrix2D`. We can specify the point around which the image would be
    rotated, the angle of rotation in degrees, and a scaling factor for the image.
    Once we have the transformation matrix, we can use the `warpAffine` function to
    apply this matrix to any image.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`θ`是逆时针方向的旋转角度。OpenCV通过`getRotationMatrix2D`函数提供了对创建此矩阵的更精细的控制。我们可以指定图像将围绕哪个点旋转，旋转的角度（以度为单位），以及图像的缩放因子。一旦我们有了变换矩阵，我们可以使用`warpAffine`函数将此矩阵应用于任何图像。
- en: 'As we can see from the previous figure, the image content goes out of boundary
    and gets cropped. In order to prevent this, we need to provide enough space in
    the output image. Let''s go ahead and do that using the translation functionality
    we discussed earlier:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，图像内容超出了边界并被裁剪。为了防止这种情况，我们需要在输出图像中提供足够的空间。让我们使用之前讨论过的平移功能来这样做：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we run the preceding code, we will see something like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上一段代码，我们会看到类似以下的内容：
- en: '![What just happened?](img/B04554_01_17.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/B04554_01_17.jpg)'
- en: Image scaling
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像缩放
- en: 'In this section, we will discuss about resizing an image. This is one of the
    most common operations in computer vision. We can resize an image using a `scaling`
    factor, or we can resize it to a particular size. Let''s see how to do that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论图像的缩放。这是计算机视觉中最常见的操作之一。我们可以使用缩放因子来调整图像大小，或者将其调整到特定的大小。让我们看看如何做到这一点：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What just happened?
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Whenever we resize an image, there are multiple ways to fill in the pixel values.
    When we are enlarging an image, we need to fill up the pixel values in between
    pixel locations. When we are shrinking an image, we need to take the best representative
    value. When we are scaling by a non-integer value, we need to interpolate values
    appropriately, so that the quality of the image is maintained. There are multiple
    ways to do interpolation. If we are enlarging an image, it's preferable to use
    linear or cubic interpolation. If we are shrinking an image, it's preferable to
    use the area-based interpolation. Cubic interpolation is computationally more
    complex, and hence slower than linear interpolation. But the quality of the resulting
    image will be higher.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们调整图像大小时，有多种方式来填充像素值。当我们放大图像时，我们需要填充像素位置之间的像素值。当我们缩小图像时，我们需要取最佳代表性值。当我们以非整数值缩放时，我们需要适当地插值值，以保持图像的质量。有多种插值方法。如果我们放大图像，最好使用线性或立方插值。如果我们缩小图像，最好使用基于区域的插值。立方插值在计算上更复杂，因此比线性插值慢。但生成的图像质量会更高。
- en: 'OpenCV provides a function called `resize` to achieve image scaling. If you
    don''t specify a size (by using `None`), then it expects the X and Y scaling factors.
    In our example, the image will be enlarged by a factor of `1.2`. If we do the
    same enlargement using cubic interpolation, we can see that the quality improves,
    as seen in the following figure. The following screenshot shows what linear interpolation
    looks like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个名为`resize`的函数来实现图像缩放。如果你没有指定大小（通过使用`None`），那么它期望X和Y缩放因子。在我们的例子中，图像将按`1.2`的因子放大。如果我们使用立方插值进行相同的放大，我们可以看到质量有所提高，如下面的图所示。下面的截图显示了线性插值的外观：
- en: '![What just happened?](img/B04554_01_18.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/B04554_01_18.jpg)'
- en: 'Here is the corresponding cubic interpolation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的立方插值：
- en: '![What just happened?](img/B04554_01_19.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/B04554_01_19.jpg)'
- en: 'If we want to resize it to a particular size, we can use the format shown in
    the last resize instance. We can basically skew the image and resize it to whatever
    size we want. The output will look something like the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将其调整到特定的大小，我们可以使用最后一次缩放实例中显示的格式。我们基本上可以扭曲图像并将其调整到我们想要的任何大小。输出将类似于以下内容：
- en: '![What just happened?](img/B04554_01_20.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/B04554_01_20.jpg)'
- en: Affine transformations
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斜变换
- en: In this section, we will discuss about the various generalized geometrical transformations
    of 2D images. We have been using the function `warpAffine` quite a bit over the
    last couple of sections, it's about time we understood what's happening underneath.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论2D图像的各种广义几何变换。在前几节中，我们相当多地使用了`warpAffine`函数，现在是时候了解其背后的发生了什么。
- en: Before talking about affine transformations, let's see what Euclidean transformations
    are. Euclidean transformations are a type of geometric transformations that preserve
    length and angle measure. As in, if we take a geometric shape and apply Euclidean
    transformation to it, the shape will remain unchanged. It might look rotated,
    shifted, and so on, but the basic structure will not change. So technically, lines
    will remain lines, planes will remain planes, squares will remain squares, and
    circles will remain circles.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论斜变换之前，让我们看看什么是欧几里得变换。欧几里得变换是一种保持长度和角度测量的几何变换。也就是说，如果我们对一个几何形状应用欧几里得变换，形状将保持不变。它可能看起来是旋转的、平移的等等，但基本结构不会改变。所以从技术上讲，线仍然是线，平面仍然是平面，正方形仍然是正方形，圆仍然是圆。
- en: Coming back to affine transformations, we can say that they are generalizations
    of Euclidean transformations. Under the realm of affine transformations, lines
    will remain lines but squares might become rectangles or parallelograms. Basically,
    affine transformations don't preserve lengths and angles.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回到仿射变换，我们可以这样说，它们是欧几里得变换的推广。在仿射变换的范畴内，直线将保持直线，但正方形可能会变成矩形或平行四边形。基本上，仿射变换不保持长度和角度。
- en: 'In order to build a general affine transformation matrix, we need to define
    the control points. Once we have these control points, we need to decide where
    we want them to be mapped. In this particular situation, all we need are three
    points in the source image, and three points in the output image. Let''s see how
    we can convert an image into a parallelogram-like image:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个一般的仿射变换矩阵，我们需要定义控制点。一旦我们有了这些控制点，我们需要决定我们希望它们映射到何处。在这种情况下，我们只需要源图像中的三个点和输出图像中的三个点。让我们看看我们如何将图像转换为类似平行四边形的图像：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What just happened?
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'As we discussed earlier, we are defining control points. We just need three
    points to get the affine transformation matrix. We want the three points in `src_points`
    to be mapped to the corresponding points in `dst_points`. We are mapping the points
    as shown in the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们正在定义控制点。我们只需要三个点来获取仿射变换矩阵。我们希望`src_points`中的三个点映射到`dst_points`中的对应点。我们按照以下方式映射点：
- en: '![What just happened?](img/B04554_01_21.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_21.jpg)'
- en: To get the transformation matrix, we have a function called `getAffineTransform`
    in OpenCV. Once we have the affine transformation matrix, we use the `warpAffine`
    function to apply this matrix to the input image.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取变换矩阵，我们在OpenCV中有一个名为`getAffineTransform`的函数。一旦我们有了仿射变换矩阵，我们使用`warpAffine`函数将这个矩阵应用到输入图像上。
- en: 'Following is the input image:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们输入的图像：
- en: '![What just happened?](img/B04554_01_22.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_22.jpg)'
- en: 'If you run the preceding code, the output will look something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，输出将看起来像这样：
- en: '![What just happened?](img/B04554_01_23.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_23.jpg)'
- en: 'We can also get the mirror image of the input image. We just need to change
    the control points in the following way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以得到输入图像的镜像。我们只需要按照以下方式更改控制点：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, the mapping looks something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，映射看起来大致是这样的：
- en: '![What just happened?](img/B04554_01_24.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_24.jpg)'
- en: 'If you replace the corresponding lines in our affine transformation code with
    these two lines, you will get the following result:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将我们的仿射变换代码中的对应行替换为这两行，你将得到以下结果：
- en: '![What just happened?](img/B04554_01_25.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_25.jpg)'
- en: Projective transformations
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影变换
- en: Affine transformations are nice, but they impose certain restrictions. A projective
    transformation, on the other hand, gives us more freedom. It is also referred
    to as **homography**. In order to understand projective transformations, we need
    to understand how projective geometry works. We basically describe what happens
    to an image when the point of view is changed. For example, if you are standing
    right in front of a sheet of paper with a square drawn on it, it will look like
    a square. Now, if you start tilting that sheet of paper, the square will start
    looking more and more like a trapezoid. Projective transformations allow us to
    capture this dynamic in a nice mathematical way. These transformations preserve
    neither sizes nor angles, but they do preserve incidence and cross-ratio.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换很好，但它们施加了某些限制。另一方面，投影变换给了我们更多的自由。它也被称为**单应性**。为了理解投影变换，我们需要了解投影几何是如何工作的。我们基本上描述了当视角改变时图像会发生什么。例如，如果你正站在画有正方形的纸张的正前方，它看起来就像一个正方形。现在，如果你开始倾斜那张纸，正方形将开始看起来更像梯形。投影变换允许我们以优雅的数学方式捕捉这种动态。这些变换既不保持大小也不保持角度，但它们确实保持交点和交叉比。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about incidence and cross-ratio at [http://en.wikipedia.org/wiki/Incidence_(geometry)](http://en.wikipedia.org/wiki/Incidence_(geometry))
    and [http://en.wikipedia.org/wiki/Cross-ratio](http://en.wikipedia.org/wiki/Cross-ratio).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://en.wikipedia.org/wiki/Incidence_(geometry)](http://en.wikipedia.org/wiki/Incidence_(geometry))和[http://en.wikipedia.org/wiki/Cross-ratio](http://en.wikipedia.org/wiki/Cross-ratio)上了解更多关于交点和交叉比的信息。
- en: Now that we know what projective transformations are, let's see if we can extract
    more information here. We can say that any two images on a given plane are related
    by a homography. As long as they are in the same plane, we can transform anything
    into anything else. This has many practical applications such as augmented reality,
    image rectification, image registration, or the computation of camera motion between
    two images. Once the camera rotation and translation have been extracted from
    an estimated homography matrix, this information may be used for navigation, or
    to insert models of 3D objects into an image or video. This way, they are rendered
    with the correct perspective and it will look like they were part of the original
    scene.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了什么是投影变换，让我们看看我们是否可以在这里提取更多信息。我们可以这样说，给定平面上任意两个图像通过单应性相关联。只要它们在同一个平面上，我们可以将任何东西变换成任何其他东西。这有许多实际应用，例如增强现实、图像校正、图像配准或计算两张图像之间的相机运动。一旦从估计的单应性矩阵中提取出相机旋转和平移，这些信息可以用于导航，或者将3D物体的模型插入到图像或视频中。这样，它们将以正确的透视渲染，看起来就像它们是原始场景的一部分。
- en: 'Let''s go ahead and see how to do this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看如何做到这一点：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you run the preceding code, you will see a funny looking output like the
    following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会看到一个像以下截图一样的有趣输出：
- en: '![Projective transformations](img/B04554_01_26.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![投影变换](img/B04554_01_26.jpg)'
- en: What just happened?
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We can choose four control points in the source image and map them to the destination
    image. Parallel lines will not remain parallel lines after the transformation.
    We use a function called `getPerspectiveTransform` to get the transformation matrix.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在源图像中选择四个控制点并将它们映射到目标图像。变换后，平行线将不再是平行线。我们使用一个名为`getPerspectiveTransform`的函数来获取变换矩阵。
- en: Let's apply a couple of fun effects using projective transformation and see
    what they look like. All we need to do is change the control points to get different
    effects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用投影变换来应用一些有趣的效果，看看它们看起来像什么。我们只需要改变控制点来获得不同的效果。
- en: 'Here''s an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![What just happened?](img/B04554_01_27.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04554_01_27.jpg)'
- en: 'The control points are as shown next:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 控制点如下所示：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As an exercise, you should map the above points on a plane and see how the points
    are mapped (just like we did earlier, while discussing Affine Transformations).
    You will get a good understanding about the mapping system, and you can create
    your own control points.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你应该在平面上映射上述点，看看点是如何映射的（就像我们之前在讨论仿射变换时做的那样）。这将帮助你更好地理解映射系统，并可以创建自己的控制点。
- en: Image warping
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像扭曲
- en: 'Let''s have some more fun with the images and see what else we can achieve.
    Projective transformations are pretty flexible, but they still impose some restrictions
    on how we can transform the points. What if we want to do something completely
    random? We need more control, right? As it so happens, we can do that as well.
    We just need to create our own mapping, and it''s not that difficult. Following
    are a few effects you can achieve with image warping:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再玩一些图像，看看我们还能实现什么。投影变换非常灵活，但它们仍然对我们如何变换点施加一些限制。如果我们想做一些完全随机的事情呢？我们需要更多的控制，对吧？碰巧，我们也可以做到。我们只需要创建自己的映射，这并不难。以下是一些你可以通过图像扭曲实现的效果：
- en: '![Image warping](img/B04554_01_28.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图像扭曲](img/B04554_01_28.jpg)'
- en: 'Here is the code to create these effects:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建这些效果的代码：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to install OpenCV-Python on various platforms.
    We discussed how to read, display, and save images. We talked about the importance
    of various color spaces and how we can convert between multiple color spaces.
    We learned how to apply geometric transformations to images and understood how
    to use those transformations to achieve cool geometric effects. We discussed the
    underlying formulation of transformation matrices and how we can formulate different
    kinds of transformations based on our needs. We learned how to select control
    points based on the required geometric transformation. We discussed about projective
    transformations and learned how to use image warping to achieve any given geometric
    effect. In the next chapter, we are going to discuss edge detection and image
    filtering. We can apply a lot of visual effects using image filters, and the underlying
    formation gives us a lot of freedom to manipulate images in creative ways.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在各种平台上安装 OpenCV-Python。我们讨论了如何读取、显示和保存图像。我们探讨了各种颜色空间的重要性以及我们如何可以在多个颜色空间之间进行转换。我们学习了如何将几何变换应用于图像，并理解了如何使用这些变换来实现酷炫的几何效果。我们讨论了变换矩阵的底层公式以及我们如何可以根据我们的需求制定不同类型的变换。我们学习了如何根据所需的几何变换选择控制点。我们讨论了投影变换，并学习了如何使用图像扭曲来实现任何给定的几何效果。在下一章中，我们将讨论边缘检测和图像滤波。我们可以使用图像滤波器应用许多视觉效果，其底层结构为我们提供了很多自由度，以创造性地操纵图像。
