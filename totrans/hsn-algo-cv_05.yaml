- en: Back-Projection and Histograms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向投影和直方图
- en: In the previous chapter, we learned about many computer vision algorithms and
    OpenCV functions that can be used to prepare images for further processing or
    modify them in one way or another. We learned how to draw text and shapes on images,
    filter them using smoothening algorithms, perform morphological transformations
    on them, and calculate their derivatives. We also learned about geometric and
    miscellaneous transformations of images and applied colormaps to alter the tone
    of our images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了众多计算机视觉算法和OpenCV函数，这些函数可用于准备图像以供进一步处理或以某种方式修改它们。我们学习了如何在图像上绘制文本和形状，使用平滑算法对其进行过滤，对其进行形态学变换，并计算其导数。我们还学习了图像的几何和杂项变换，并应用色图来改变图像的色调。
- en: In this chapter, we'll be learning about a few more algorithms and functions
    that are used mostly to prepare images for further processing, inference, and
    modification. This will be further clarified later on in this chapter, after we
    learn about histograms in computer vision. We'll be introduced to the concept
    of histograms, and then we'll learn how they are calculated and utilized with
    hands-on example codes. The other extremely important concept we'll be learning
    about in this chapter is called **back-projection**. We'll learn how back-projection
    of a histogram can be used to create an altered version of the original image.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些更多用于准备图像以供进一步处理、推理和修改的算法和函数。这一点将在本章后面进一步阐明，在我们学习了计算机视觉中的直方图之后。我们将介绍直方图的概念，然后通过实际示例代码学习它们是如何计算和利用的。本章我们将学习的另一个极其重要的概念被称为**反向投影**。我们将学习如何使用直方图的反向投影来创建原始图像的修改版本。
- en: Besides their standard usage, the concepts and algorithms that we'll learn in
    this chapter are also essential when it comes to dealing with some of the most
    widely used algorithms for object detection and tracking, which we'll be learning
    in the upcoming chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们的常规用途外，本章我们将学习的概念和算法在处理一些最广泛使用的目标检测和跟踪算法时也是必不可少的，这些算法将在接下来的章节中学习。
- en: 'In this chapter, we''ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Understanding histograms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解直方图
- en: Back projection of histograms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图反向投影
- en: Histogram comparison
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图比较
- en: Equalizing histograms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: An IDE to develop C++ or Python applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于开发C++或Python应用程序的IDE
- en: OpenCV library
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV库
- en: Refer to [Chapter 2](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4),
    *Getting Started with OpenCV,* for more information about how to set up a personal
    computer and make it ready to develop computer vision applications using the OpenCV
    library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第2章](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4)，*使用OpenCV入门*，获取有关如何设置个人计算机并使其准备好使用OpenCV库开发计算机视觉应用程序的更多信息。
- en: 'You can use the following URL to download the source codes and examples for
    this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下URL下载本章的源代码和示例：
- en: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter05)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter05)'
- en: Understanding histograms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解直方图
- en: 'In computer vision, histograms are simply graphs that represent the distribution
    of pixel values over the possible range of the accepted values for those pixels,
    or, in other words, the probability distribution of pixels. Well, this might not
    be as crystal clear as you would expect, so let''s take single-channel grayscale
    images as a simple example to describe what histograms are, and then expand it
    to multi-channel colored images, and so on. We already know that the pixels in
    a standard grayscale image can contain values between 0 and 255\. Considering
    this fact, a graph similar to the following, which depicts the ratio of the number
    of pixels containing each and every possible grayscale pixel value of an arbitrary
    image, is simply the histogram of that given image:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉中，直方图简单地说是表示像素值在像素可能接受值范围内的分布的图表，或者说，是像素的概率分布。嗯，这可能不像你期望的那样清晰，所以让我们以单通道灰度图像作为一个简单的例子来描述直方图是什么，然后扩展到多通道彩色图像等。我们已经知道，标准灰度图像中的像素可以包含0到255之间的值。考虑到这一点，一个类似于以下图表的图形，它描述了任意图像中每个可能的灰度像素值的像素数量比，就是该给定图像的直方图：
- en: '![](img/00055.gif)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00055.gif)'
- en: Keeping in mind what we just learned, it can be easily guessed that the histogram
    of a three-channel image, for example, would be three graphs representing the
    distribution of values for each channel, similar to what we just saw with the
    histogram of a single-channel grayscale image.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们刚刚学到的内容，可以很容易地猜测，例如，三通道图像的直方图将是由三个图表表示的，每个通道的值分布，类似于我们刚才看到的单通道灰度图像的直方图。
- en: You can use the `calcHist` function in the OpenCV library to calculate the histogram
    of one or multiple images that can be single-channel or multi-channel themselves.
    This function requires a number of parameters that must be provided carefully
    for it to produce the desired results. Let's see how this function is used with
    a few examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 OpenCV 库中的 `calcHist` 函数计算一个或多个图像的直方图，这些图像可以是单通道或多通道。此函数需要提供一些参数，必须仔细提供才能产生所需的结果。让我们通过几个示例来看看这个函数是如何使用的。
- en: 'The following example code (followed by description of all the parameters)
    demonstrates how you can calculate the histogram of a single grayscale image:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码（随后是对所有参数的描述）演示了如何计算单个灰度图像的直方图：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We infer the following from the preceding code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以推断出以下内容：
- en: '`grayImg` is the input grayscale image that wants to calculate its histogram,
    and `histogram` will contain the result.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grayImg` 是想要计算其直方图的输入灰度图像，而 `histogram` 将包含结果。'
- en: '`nimages` must contain the number of images for which we want histograms calculated,
    which, in this case, is just one image.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nimages` 必须包含我们想要计算直方图的图像数量，在这个例子中，只有一个图像。'
- en: '`channels` is an array that is supposed to contain the zero-based index number
    of the channels in each image for which we want their histogram calculated. For
    instance, if we want to calculate the histogram of the first, second, and fourth
    channels in a multi-channel image, the `channels` array must contain the values
    of 0, 1, and 3\. In our example, `channels` only contained `0`, since we''re calculating
    the histogram of the only channel in a grayscale image.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channels` 是一个数组，它应该包含我们想要计算其直方图的每个图像中通道的零基于索引号。例如，如果我们想要计算多通道图像中第一个、第二个和第四个通道的直方图，`channels`
    数组必须包含 0、1 和 3 的值。在我们的例子中，`channels` 只包含 `0`，因为我们正在计算灰度图像中唯一通道的直方图。'
- en: '`mask`, which is common to many other OpenCV functions, is a parameter that
    is used to mask (or ignore) certain pixels, or, in other words, prevent them from
    participating in the calculated result. In our case, and as long as we are not
    working on a certain portion of an image, `mask` must contain an empty matrix.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mask`，这是许多其他 OpenCV 函数的共同参数，是一个用于屏蔽（或忽略）某些像素，或者换句话说，防止它们参与计算结果的参数。在我们的情况下，只要我们不在图像的某个部分上工作，`mask`
    必须包含一个空矩阵。'
- en: '`dims`, or the dimensionality parameters, corresponds to the dimensionality
    of the result histogram that we are calculating. It must not be greater than `CV_MAX_DIM`,
    which is 32 in current OpenCV versions. We''ll be using `1` in most cases, since
    we expect our histogram to be a simple array-shaped matrix. Consequently, the
    index number of each element in the resulting histogram will correspond to the
    bin number.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dims`，或维度参数，对应于我们正在计算的直方图的结果维度。它必须不大于 `CV_MAX_DIM`，在当前 OpenCV 版本中为 32。我们大多数情况下将使用
    `1`，因为我们期望我们的直方图是一个简单的数组形状矩阵。因此，结果直方图中每个元素的索引号将对应于箱子号。'
- en: '`histSize` is an array that must contain the size of the histogram in each
    dimension. In our example, since the dimensionality was `1`, `histSize` must contain
    a single value. The size of the histogram, in this case, is the same as the number
    of bins in a histogram. In the preceding example code, `bins` is used to define
    the number of bins in the histogram, and it is also used as the single `histSize`
    value. Think of `bins` as the number of groups of pixels in a histogram. This
    will be further clarified with examples later on, but for now, it is important
    to note that a value of `256` for `bins` will result in a histogram containing
    the count of all individual possible pixel values.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`histSize` 是一个数组，它必须包含每个维度中直方图的大小。在我们的例子中，由于维度是 `1`，`histSize` 必须包含一个单一值。在这种情况下，直方图的大小与直方图中的箱子数量相同。在前面的示例代码中，`bins`
    用于定义直方图中的箱子数量，并且它也被用作单一的 `histSize` 值。将 `bins` 想象为直方图中的像素组数量。这将在稍后的示例中进一步阐明，但就目前而言，重要的是要注意，`bins`
    的值为 `256` 将导致包含所有可能的单个像素值计数的直方图。'
- en: '`ranges` must contain pairs of values corresponding to the lower and higher
    bounds of each range of possible values when calculating the histogram of an image.
    In our example, this means a value in the single range of (`0`, `256`), which
    is what we have provided to this parameter.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计算图像的直方图时，`ranges`必须包含对应于每个可能值范围的上下限值对。在我们的示例中，这意味着单个范围（`0`, `256`）中的一个值，这是我们提供给此参数的值。
- en: The `uniform` parameter is used to define the uniformity of the histogram. Note
    that if the histogram is non-uniform, as opposed to what is demonstrated in our
    example, the `ranges` parameter must contain the lower and higher bounds of all
    dimensions, respectively.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniform`参数用于定义直方图的均匀性。请注意，如果直方图是非均匀的，与我们的示例中展示的不同，则`ranges`参数必须包含所有维度的下限和上限。'
- en: The `accumulate` parameter is used to decide whether the histogram should be
    cleared before it is calculated, or the calculated values should be added to an
    existing histogram. This can be quite useful when you need to calculate a single
    histogram using multiple images.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accumulate`参数用于决定在计算直方图之前是否应该清除它，或者将计算出的值添加到现有的直方图中。当你需要使用多张图像计算单个直方图时，这非常有用。'
- en: We'll cover the parameters mentioned here as much as possible in the examples
    provided in this chapter. However, you can also refer to the online documentation
    of the `calcHist` function for more information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章提供的示例中尽可能多地介绍这里提到的参数。然而，你也可以参考`calcHist`函数的在线文档以获取更多信息。
- en: Displaying histograms
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示直方图
- en: Quite obviously, trying to display the resulting histogram using a function,
    such as `imshow`, is futile since the raw format of the stored histogram is similar
    to a single column matrix that has `bins` number of rows in it. Each row, or,
    in other words, each element, of the histogram corresponds to the number of pixels
    that fall into that specific bin. Considering this, we can draw the calculated
    histogram by using drawing functions from [Chapter 4](part0085.html#2H1VQ0-15c05657f8254d318ea883ef10fc67f4),
    *Drawing, Filtering, and Transformation*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，尝试使用如`imshow`之类的函数显示结果直方图是徒劳的，因为存储的直方图的原始格式类似于一个具有`bins`行数的单列矩阵。直方图的每一行，或者说每个元素，对应于落入该特定bin的像素数。考虑到这一点，我们可以使用[第4章](part0085.html#2H1VQ0-15c05657f8254d318ea883ef10fc67f4)，*绘图、滤波和变换*中的绘图函数绘制计算出的直方图。
- en: 'Here''s an example that shows how we can display the histogram that we calculated
    in the previous code sample as a graph with custom size and properties:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了我们如何将前面代码样本中计算出的直方图显示为具有自定义大小和属性的图形：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, `gRow` and `gCol` refer to the height and width of the
    resulting graph, respectively. The rest of the parameters are either self-explanatory
    (`backgroundColor` and so on), or you have already learned about them in the previous
    chapters. Notice how each value in `histogram` is used to calculate the position
    of the line that needs to be drawn. In the preceding code, `maxVal` is simply
    used to scale the results to the visible range. Here''s how `maxVal` itself is
    calculated:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`gRow`和`gCol`分别代表结果的图形的高度和宽度。其余参数要么是自解释的（如`backgroundColor`等），或者你在前面的章节中已经了解过它们。注意`histogram`中的每个值是如何用来计算需要绘制的线的位置的。在前面的代码中，`maxVal`简单地用于将结果缩放到可见范围。以下是`maxVal`本身是如何计算的：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Refer to [Chapter 3](part0048.html#1DOR00-15c05657f8254d318ea883ef10fc67f4),
    *Array and Matrix Operations,* if you need to refresh your memory about how the `minMaxLoc`
    function is used. In our example, we only need the value of the biggest element
    in the histogram, so we ignore the rest of the parameters by passing zero to them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要刷新关于`minMaxLoc`函数如何使用的记忆，请参阅[第3章](part0048.html#1DOR00-15c05657f8254d318ea883ef10fc67f4)，*数组和矩阵操作*。在我们的示例中，我们只需要直方图中最大元素的值，所以我们通过将它们传递零来忽略其余参数。
- en: 'Here is the result of the preceding example codes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面示例代码的结果：
- en: '![](img/00056.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.jpeg)'
- en: You can easily change the background or the graph color using the provided `backGroundColor`
    or `graphColor` parameters, or make the graph thinner or thicker by changing the
    `thickness` parameter, and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供的`backGroundColor`或`graphColor`参数轻松更改背景或图形颜色，或者通过更改`thickness`参数使图形更细或更粗，等等。
- en: Interpretation of a histogram is extremely important, especially in photography
    and photo-editing applications, so being able to visualize them is essential for
    easier interpretation of the results. For instance, in the preceding example,
    it can be easily noticed from the resulting histogram that the source image contains
    more tones of darker colors than brighter ones. We'll see more examples of darker
    and brighter images later on, but before that, let's see how changing the number
    of bins would affect the result.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图的解释非常重要，尤其是在摄影和照片编辑应用中，因此能够可视化它们对于更容易解释结果至关重要。例如，在前例中，可以从结果直方图中轻松看出，源图像包含比亮色更多的暗色调。我们将在稍后看到更多关于暗色和亮色图像的示例，但在那之前，让我们看看改变桶数会如何影响结果。
- en: 'The following are the resulting histograms of the same image as the previous
    example, with 150, 80, and 25 bins, from left to right, drawn using a bar chart
    visualization method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的直方图是之前示例中相同图像的结果，从左到右分别使用150、80和25个桶进行柱状图可视化：
- en: '![](img/00057.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: 'You can easily notice that the lower the bins value is, the more grouped together
    the pixels are. Even though this might seem more like a lower resolution of the
    same data (from left to right), it is actually better to use a lower number of
    bins to group similar pixels together. Note that the bar-chart visualization in
    the preceding example is produced by replacing the `for` loop from the previous
    example code with the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地注意到，桶值越低，像素越聚集在一起。尽管这看起来更像是相同数据（从左到右）的较低分辨率，但实际上使用更少的桶值将相似像素聚集在一起是更好的选择。请注意，前例中的柱状图可视化是通过将前例代码中的`for`循环替换为以下代码产生的：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Both of these visualizations (graph or bar-chart) have their own pros and cons,
    which will be more obvious as you try calculating histograms of different types
    of images. Let''s try calculating the histogram of a color image. We''ll need
    to calculate the histogram of individual channels, as was mentioned previously.
    Here''s an example code that demonstrates how it''s done:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种可视化（图形或柱状图）各有其优缺点，当你尝试计算不同类型图像的直方图时，这些优缺点将更加明显。让我们尝试计算一张彩色图像的直方图。我们需要计算各个通道的直方图，正如之前提到的。以下是一个示例代码，展示了如何进行操作：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/00058.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00058.jpeg)'
- en: 'As you can see in the preceding example code, the `split` function is used
    to create three individual images, each containing a single channel, out of our
    source color image (BGR by default). The part of the code that is mentioned with
    the commented line in the preceding code is simply a `for` loop that iterates
    over the elements of `imgChannels` and draws each graph using the exact same code
    as you saw before, but with each graph having its own unique color that is calculated
    using the following code in the loop:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例代码所示，`split`函数被用来从我们的源彩色图像（默认为BGR）中创建三个单独的图像，每个图像包含一个单独的通道。前例代码中提到的带有注释行的代码部分，实际上是一个`for`循环，它遍历`imgChannels`的元素，并使用与之前看到的完全相同的代码绘制每个图表，但每个图表都有其独特的颜色，该颜色是通过循环中的以下代码计算的：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Depending on the value of `i`, `graphColor` is set to blue, green, or red, hence
    the resulting histography depicted in the previous picture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`i`的值，`graphColor`被设置为蓝色、绿色或红色，因此产生了之前图片中显示的直方图。
- en: Besides interpreting the content of an image, or to seeing how pixel values
    are distributed in an image, histograms have many use cases. In the following
    sections, we'll be learning about back-projection and other algorithms that are
    used for utilizing histograms in our applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解释图像内容或查看像素值在图像中的分布情况外，直方图还有许多用途。在接下来的章节中，我们将学习关于反投影和其他算法，这些算法用于在我们的应用中利用直方图。
- en: Back-projection of histograms
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图的反投影
- en: Considering the definition of histograms from the start of the previous section,
    it can be said that back-projection of a histogram on an image means replacing
    each of its pixels with their probability distribution value. This is, in a way
    (not exactly), the reverse operation of calculating the histogram of an image.
    When we back-project a histogram on an image, we actually use a histogram to modify
    an image. Let's first see how back-projection is performed using OpenCV and, afterwards,
    dive into how it is actually used.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节开头的直方图定义开始考虑，可以说图像上直方图的反向投影意味着用其每个像素的概率分布值替换它们。这在某种程度上（并不完全）是计算图像直方图的逆操作。当我们对图像上的直方图进行反向投影时，我们实际上是用直方图来修改图像。让我们首先看看如何使用
    OpenCV 执行反向投影，然后深入了解其实际应用。
- en: 'You can use the `calcBackProject` function to calculate the back-projection
    of a histogram on an image. This function needs a similar set of parameters to
    the `caclHist` function. Let''s see how it is called and then further break down
    its parameters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `calcBackProject` 函数来计算图像上直方图的反向投影。此函数需要与 `calcHist` 函数类似的参数集。让我们看看它是如何调用的，然后进一步分解其参数：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `nimages`, `channels`, `ranges`, and `uniform` parameters in the `calcBackProject`
    function are used exactly the way they were with the `calcHist` function. `image`
    must contain the input image and `histogram` needs to be calculated with a prior
    call to the `calcHist` function or with any other method (or even manually). The
    result will be scaled by using the `scale` parameter and finally, it will be saved
    in `backProj`. It''s important to note that the values in `histogram` can be over
    the correctly displayable range, so after performing the back-projection, the
    resulting `backProj` object will not be displayable correctly. To fix this issue,
    we need to first make sure `histogram` is normalized to the displayable range
    by OpenCV. The following code must be executed before the preceding call to `calcBackProject`
    in order for the resulting `backProj` to be displayable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`calcBackProject` 函数中的 `nimages`、`channels`、`ranges` 和 `uniform` 参数的使用方式与 `calcHist`
    函数中的使用方式完全相同。`image` 必须包含输入图像，而 `histogram` 需要通过先前的 `calcHist` 函数调用或任何其他方法（甚至手动）来计算。结果将通过使用
    `scale` 参数进行缩放，最后将保存在 `backProj` 中。重要的是要注意，`histogram` 中的值可能超过正确的可显示范围，因此在进行反向投影后，结果
    `backProj` 对象将无法正确显示。为了解决这个问题，我们需要首先确保 `histogram` 被归一化到 OpenCV 的可显示范围。以下代码必须在执行前面的
    `calcBackProject` 调用之前执行，以便结果 `backProj` 可显示：'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following image depicts the result of the back-projection of the image
    with its original histogram (unaltered histogram). The image on the right-hand
    side is the result of the back-projection algorithm:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了使用其原始直方图（未修改的直方图）进行反向投影的结果。右侧的图像是反向投影算法的结果：
- en: '![](img/00059.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00059.jpeg)'
- en: According to the definition of histograms and back-projection, it can be said
    that the darker areas in the preceding back-projection result image contain pixels
    that are less common to the original image, and vice versa. This algorithm can
    be used (or even abused) to alter an image using a modified, or manually-made
    histogram. This technique is commonly used, for example, to create masks that
    extract only portions of an image that contains a given color or intensity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据直方图和反向投影的定义，可以说前一个反向投影结果图像中的较暗区域包含比原始图像中更不常见的像素，反之亦然。此算法可用于（甚至滥用）使用修改后的或手动制作的直方图来改变图像。这种技术通常用于创建仅提取包含给定颜色或强度的图像部分的掩码。
- en: 'Here is an example that demonstrates how you can use the concept of histograms
    and back-projection to detect the pixels in an image that are in the range of
    the brightest 10% of possible pixel values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示了如何使用直方图和反向投影的概念来检测图像中位于可能像素值最亮 10% 范围内的像素：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the histogram is formed manually, with `10` bins, instead of being
    calculated from the original image. Then, the last bin, or, in other words, the
    last element in the histogram, is set to `255`, which means absolute white. Obviously,
    if this wasn't done, we'd need to perform a normalization to make sure the result
    of back-projection is in the displayable range of colors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直方图是手动形成的，有 `10` 个桶，而不是从原始图像中计算得出。然后，最后一个桶，或者说直方图的最后一个元素，被设置为 `255`，这意味着绝对白色。显然，如果没有这样做，我们就需要执行归一化以确保反向投影的结果在可显示的颜色范围内。
- en: 'The following image depicts the result of the preceding code snippet when it
    is executed on the same sample image from the previous examples:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了在执行上述代码片段时，在之前示例中的相同样本图像上的结果：
- en: '![](img/00060.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: The extracted mask image can be used to further modify an image, or, in the
    case of a uniquely-colored object, it can be used to detect and track the object.
    The detection and tracking algorithms will be covered thoroughly in the upcoming
    chapters, but how exactly we can use the color of an object is what we're going
    to learn next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的掩码图像可以用于进一步修改图像，或者在具有独特颜色的对象的情况下，可以用于检测和跟踪该对象。检测和跟踪算法将在接下来的章节中详细讲解，但我们将学习如何具体使用对象的颜色。
- en: Learning more about back-projections
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习更多关于反向投影
- en: First off, let's recall that the HSV color space is far better suited to dealing
    with the actual color value of pixels in an image than the standard RGB (or BGR
    and so on) color space. You might want to revisit [Chapter 1](part0021.html#K0RQ0-15c05657f8254d318ea883ef10fc67f4),
    *Introduction to Computer Vision,* for more information about this phenomenon.
    We're going to use this simple fact to find regions in an image that have a special
    color, regardless of their color intensity, brightness, and so on. For this reason,
    we need to first convert an image to the HSV color s
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下HSV颜色空间在处理图像中像素的实际颜色值方面比标准的RGB（或BGR等）颜色空间更适合。你可能需要回顾[第1章](part0021.html#K0RQ0-15c05657f8254d318ea883ef10fc67f4)，*计算机视觉简介*，以了解更多关于这一现象的信息。我们将利用这一简单事实来找到图像中具有特殊颜色的区域，无论其颜色强度、亮度等。因此，我们需要首先将图像转换为HSV颜色空间
- en: 'Let''s simplify this with an example case. Imagine we want to replace a specific
    color in an image, preserving the highlights, brightness, and so on. To be able
    to perform such a task, we need to be able to accurately detect a given color
    and then make sure we only change the color in the detected pixels and not their
    brightness and similar properties. The following example code demonstrates how
    we can use a manually-formed histogram of the hue channel and its back-projection
    to extract pixels that have a specific color, which, in this example, is assumed
    to be blue:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个示例案例来简化这一点。假设我们想要替换图像中的特定颜色，同时保留高光、亮度等。为了能够执行此类任务，我们需要能够准确检测给定的颜色，并确保我们只更改检测到的像素中的颜色，而不是它们的亮度和其他类似属性。以下示例代码演示了我们可以如何使用手动形成的色调通道直方图及其反向投影来提取具有特定颜色的像素，在这个例子中，假设颜色是蓝色：
- en: 'To perform such an operation, we need to start by reading an image, converting
    it to the HSV color space, and extracting the hue channel, or, in other words,
    the first channel, as seen here:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行此类操作，我们需要首先读取一个图像，将其转换为HSV颜色空间，并提取色调通道，换句话说，就是第一个通道，如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have the hue channel inside the `hue` object, we need to form a
    proper histogram of the hue channel, which contains only the pixels with the color
    blue. The hue value can be a value between `0` and `360` (in degrees) and the
    hue value of blue is `240`. So, we can create a histogram using the following
    code, which can be used to extract the blue-colored pixels, with an offset (or
    threshold) of `50` pixels:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将色调通道存储在`hue`对象中，我们需要形成色调通道的适当直方图，其中只包含具有蓝色颜色的像素。色调值可以在`0`到`360`（度）之间，蓝色的色调值为`240`。因此，我们可以使用以下代码创建一个直方图，用于提取具有蓝色颜色的像素，偏移量（或阈值）为`50`像素：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code acts like a simple threshold, in which all elements in the
    histogram that have an index of `240` (plus/minus `50`) are set to `255` and the
    rest are set to zero.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码像一个简单的阈值，其中直方图中索引为`240`（加减`50`）的所有元素都被设置为`255`，其余的设置为零。
- en: 'Visualizing the manually-created hue channel histogram will allow us to have
    a better idea of the exact colors that are going to be extracted using it. The
    following code can be used to easily visualize a hue histogram:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过可视化手动创建的色调通道直方图，我们可以更好地了解将要使用它提取的确切颜色。以下代码可以轻松地可视化色调直方图：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before proceeding with the next steps, let's break down the preceding example
    code. It is almost exactly the same as visualizing a grayscale histogram or a
    single red-, green-, or blue-channel histogram. However, the interesting fact
    to note about the preceding code is where we form the `colors` object. The `colors`
    object is going to be a simple vector that contains all possible colors across
    the hue spectrum, but according to the number of bins we have. Notice how we have
    used the `saturate_cast` function in OpenCV to make sure the hue values are saturated
    into the acceptable range. The S and V channels are simply set to their highest
    possible value, which is 255\. After the `colors` object is correctly created,
    we have used the same visualization function as before. However, since OpenCV
    does not display images in the HSV color space by default (and you can expect
    the same behavior in most image display functions and libraries), we need to convert
    the HSV color space to BGR in order to display the colors correctly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步之前，让我们分析前面的示例代码。它几乎与可视化灰度直方图或单个红、绿或蓝通道直方图完全相同。然而，关于前面代码的有趣事实是我们在哪里形成`colors`对象。`colors`对象将是一个简单的向量，包含色调光谱中所有可能的颜色，但根据我们的bin数量。注意我们是如何在OpenCV中使用`saturate_cast`函数来确保色调值饱和到可接受的范围。S和V通道简单地设置为它们可能的最大值，即255。在`colors`对象正确创建后，我们使用了之前相同的可视化函数。然而，由于OpenCV默认不显示HSV颜色空间中的图像（你可以在大多数图像显示函数和库中预期这种行为），我们需要将HSV颜色空间转换为BGR才能正确显示颜色。
- en: Even though hue can take a value in the range of (0, 360), it is not possible
    to store it in single-byte C++ types (such as `uchar`), which are capable of storing
    values in the range of (0, 255). That is why hue values are considered to be in
    the range of (0, 180) in OpenCV, or, in other words, they are simply divided by
    two.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管色调可以取（0，360）范围内的值，但无法将其存储在单字节C++类型（如`uchar`）中，这些类型能够存储（0，255）范围内的值。这就是为什么在OpenCV中，色调值被认为是在（0，180）范围内，换句话说，它们只是简单地除以二。
- en: 'The following image depicts the result of the preceding example code, if we
    try to display `theGraph` using the `imshow` function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像描述了如果我们尝试使用`imshow`函数显示`theGraph`时前面示例代码的结果：
- en: '![](img/00061.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/00061.jpeg)'
- en: 'These are the colors we''re going to extract in a mask, if we use its corresponding
    histogram to calculate the back-project of an image. This range of colors is created
    using the simple threshold (in a loop) that we did when we formed the histogram
    manually. Obviously, if you set all the values of the histogram to `255.0` instead
    of just the blue range, you''d have the whole spectrum of colors. Here''s a simple
    example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用其相应的直方图来计算图像的反向投影，我们将从中提取这些颜色。这个颜色范围是通过我们在形成直方图时所做的简单阈值（在循环中）创建的。显然，如果你将直方图的全部值设置为`255.0`而不是仅蓝色范围，你将得到整个颜色光谱。以下是一个简单的示例：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The visualization output would be the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化输出将是以下内容：
- en: '![](img/00062.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/00062.jpeg)'
- en: Now let's go back to our original histogram of only the blue colors and continue
    with the remaining steps.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们原始的仅蓝色直方图，并继续进行剩余的步骤。
- en: 'We are ready to calculate the back-projection of our histogram on the hue channel
    that we had extracted in the initial step of our example. Here''s how it''s done:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好计算我们示例的第一步中提取的色调通道上的直方图的反向投影。以下是操作方法：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It's quite similar to how we created the back-projection of grayscale channels,
    but the range, in this case, is adjusted to correctly represent the possible values
    for the hue channel, which is `0` to `180`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们创建灰度通道的反向投影非常相似，但在这个例子中，范围被调整为正确表示色调通道的可能值，即`0`到`180`。
- en: 'The following image displays the result of such a back-projection, in which
    pixels with blue colors are extracted:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了此类反向投影的结果，其中提取了蓝色像素：
- en: '![](img/00063.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/00063.jpeg)'
- en: Note that pixels with grayscale colors (including white and black) might also
    have a value similar to the hue value that we want to extract, but since changing
    their hue value would not have any effect on their color, we can simply ignore
    them in our example case.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，具有灰度颜色（包括白色和黑色）的像素也可能具有与我们想要提取的色调值相似的价值，但由于改变它们的色调值不会对它们的颜色产生任何影响，因此我们可以在我们的示例案例中简单地忽略它们。
- en: 'Shift and change the hue in the pixels we extracted using the `calcBackProject`
    function. We simply need to loop through the pixels and shift their first channel
    with any desired value. The result obviously must be converted to BGR before it
    is suitable for being displayed. Here''s how:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`calcBackProject`函数提取像素后，我们需要调整这些像素的色调。我们只需遍历像素并将它们的第一个通道以任何期望的值进行偏移。显然，结果必须在显示之前转换为BGR格式。以下是具体步骤：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We used a `shift` value of `-50` in the preceding example, which will cause
    the blue pixels to turn to green, preserving their brightness, and so on. Using
    various `shift` values would result in different colors replacing the blue pixels.
    Here are two examples:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`-50`的`shift`值，这将导致蓝色像素变成绿色，同时保持其亮度，依此类推。使用不同的`shift`值会导致不同的颜色替换蓝色像素。以下是两个示例：
- en: '![](img/00064.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00064.jpeg)'
- en: What we learned in the preceding example is the basis of many color-based detection
    and tracking algorithms, as we'll learn in the upcoming chapters. Being able to
    correctly extract pixels of a certain color, regardless of their brightness shift,
    is extremely handy. Brightness shift in a color is what happens when the lighting
    over an object of a certain color is changed, or during day and night, which is
    taken into account when hue is used instead of red, green, or blue channels in
    an RGB image.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学到的内容是许多基于颜色的检测和跟踪算法的基础，正如我们将在接下来的章节中学习的那样。能够正确提取特定颜色的像素，无论其亮度如何变化，都非常有用。当使用色调而不是红、绿或蓝通道时，颜色的亮度变化就是当某个颜色的物体上的光照改变，或者在白天和夜晚时发生的情况。
- en: Before proceeding to the final section of this chapter, it's worth noting that
    the exact same visualization method that we used for displaying the manually-made
    histogram of an imaginary hue channel can also be used to visualize the color
    histograms calculated from an image. Let's see how it's done with an example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入本章的最后一部分之前，值得注意的是，我们用于显示假设色调通道手动制作的直方图的完全相同的可视化方法也可以用于可视化从图像计算出的颜色直方图。让我们通过一个示例来看看如何实现。
- en: 'In the preceding example, right after the initial step, instead of forming
    the histogram manually, simply calculate it using the `calcHist` algorithm, as
    seen here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在初始步骤之后，我们不是手动形成直方图，而是简单地使用`calcHist`算法进行计算，如下所示：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Changing the bin size effect is similar to what we saw in grayscale and single
    channel histograms, in the sense that it groups nearby values together. However,
    and in case of visualizing the hue channel, the nearby hue values will be grouped
    together, which results in a hue histogram that better represents similar colors
    in an image. The following example images depict the result of the preceding visualization,
    but with different `bins` values. From top to bottom, the `bins` value used to
    calculate each histogram is 360, 100, 36, and 7\. Notice how the resolution of
    the histogram decreases as the bins value is decreased:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 改变bin大小的影响与我们在灰度图和单通道直方图中看到的影响相似，即它将附近的值分组在一起。然而，在可视化色调通道时，附近的色调值将被分组在一起，这导致色调直方图更好地表示图像中的相似颜色。以下示例图像展示了前面可视化结果，但使用了不同的`bins`值。从上到下，计算每个直方图所使用的`bins`值分别是360、100、36和7。注意，随着bins值的减小，直方图的分辨率降低：
- en: '![](img/00065.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00065.jpeg)'
- en: Choosing the right bins value completely depends on what type of objects you
    are dealing with and your definition of similar colors. What can be seen from
    the preceding image is that obviously choosing a very high bin value (such as
    360) is not useful when we need at least some level of grouping of similar colors.
    On the other hand, choosing a very low bin size can result in an extreme grouping
    of colors in which calculating a back-projection would not produce an accurate
    result. Make sure to choose the bins value wisely, varying them for different
    subjects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的bins值完全取决于你处理的对象类型以及你对相似颜色的定义。从前面的图像中可以看出，显然当我们需要至少一些相似颜色的分组时，选择一个非常高的bin值（例如360）是没有用的。另一方面，选择一个非常小的bin大小可能会导致颜色极端分组，计算反向投影时不会产生准确的结果。请确保明智地选择bins值，并根据不同的主题进行变化。
- en: Comparing histograms
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较直方图
- en: 'Histograms can be compared with each other in other to get some insight into
    the content of an image. OpenCV allows histogram comparison using a method called
    `compareHist`, which requires the comparison method to be set first. The following
    example code depicts how this function can be used to calculate the result of
    comparison between two histograms calculated using previous calls to the `calcHist`
    function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过比较直方图来获取对图像内容的某些洞察。OpenCV允许使用名为`compareHist`的方法比较直方图，这需要首先设置比较方法。以下示例代码展示了如何使用此函数计算使用之前对`calcHist`函数的调用计算的两个直方图之间的比较结果：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`histogram1` and `histogram2`, in the preceding example, are simply histograms
    of two different images, or different channels of an image. `method`, on the other
    hand, which must contain a valid entry from the `HistCompMethods` enum, defines
    the comparison algorithm used by the `compareHist` function and it can be any
    one of the following methods:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`histogram1`和`histogram2`仅仅是两个不同图像的直方图，或者是一个图像的不同通道。另一方面，`method`必须包含来自`HistCompMethods`枚举的有效条目，它定义了`compareHist`函数使用的比较算法，并且可以是以下方法中的任何一个：
- en: '`HISTCMP_CORREL`, for the Correlation method'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HISTCMP_CORREL`，用于相关方法'
- en: '`HISTCMP_CHISQR`, for the Chi-square method'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HISTCMP_CHISQR`，用于卡方方法'
- en: '`HISTCMP_INTERSECT`, for the Intersection method'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HISTCMP_INTERSECT`，用于交集方法'
- en: '`HISTCMP_BHATTACHARYYA`, for the Bhattacharyya distance method'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HISTCMP_BHATTACHARYYA`，用于Bhattacharyya距离方法'
- en: '`HISTCMP_HELLINGER`, same as `HISTCMP_BHATTACHARYYA`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HISTCMP_HELLINGER`，与`HISTCMP_BHATTACHARYYA`相同'
- en: '`HISTCMP_CHISQR_ALT`, for the Alternative Chi-square method'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HISTCMP_CHISQR_ALT`，用于替代卡方方法'
- en: '`HISTCMP_KL_DIV`, for the Kullback-Leibler divergence method'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HISTCMP_KL_DIV`，用于Kullback-Leibler散度方法'
- en: 'You can refer to the latest OpenCV documentation to get more information about
    the mathematical details of each method, and how and what properties of histograms
    are used by them. The same can be said about the interpretation of the results
    of any method. Let''s see what this means with an example. Using the following
    sample code, we can output the result of all histogram-comparison methods:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考最新的OpenCV文档以获取有关每种方法的数学细节以及它们如何以及使用哪些直方图属性的信息。同样，这也适用于任何方法的解释结果。让我们通过一个示例来看看这意味着什么。使用以下示例代码，我们可以输出所有直方图比较方法的结果：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We use the same example image we used throughout this chapter to calculate
    both `histogram1` and `histogram2`, or, in other words, if we compare one histogram
    with an equal histogram, here''s what we would get:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用本章中一直使用的示例图像来计算`histogram1`和`histogram2`，换句话说，如果我们比较一个直方图与一个等直方图，这里是我们会得到的结果：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice how distance- and divergence-based methods return a value of zero, while
    correlation returns a value of one, for exact correlation. All of the results
    in the preceding output mean equal histograms. Let''s shed more light on this
    by calculating the histograms from the following two images:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意基于距离和发散的方法返回零值，而相关方法返回一值，对于完全相关。前面输出中的所有结果都表示等直方图。让我们通过计算以下两个图像的直方图来进一步说明：
- en: '![](img/00066.gif)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.gif)'
- en: 'The following results would be created if the image on the left is used to
    create `histogram1` and the image on the right is used to create `histogram2`,
    or, in other words, an arbitrary bright image is compared with an arbitrary dark
    image:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左边的图像用于创建`histogram1`，右边的图像用于创建`histogram2`，或者换句话说，一个任意亮图像与一个任意暗图像进行比较，以下结果将会产生：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s important to note that the order of the histograms being passed to the
    `compareHist` function matters in some cases, such as when `HISTCMP_CHISQR` is
    used as the method. Here are the results with `histogram1` and `histogram2` passed
    in reverse order to the `compareHist` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在某些情况下，传递给`compareHist`函数的直方图的顺序很重要，例如当使用`HISTCMP_CHISQR`作为方法时。以下是`histogram1`和`histogram2`以相反顺序传递给`compareHist`函数的结果：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Comparing histograms is extremely useful, especially when we need to get a better
    and more meaningful impression of changes across various images. For instance,
    comparing histograms of consecutive frames from a camera can give us an idea of
    the intensity of change between those consecutive frames.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 比较直方图非常有用，尤其是在我们需要更好地了解各种图像之间的变化时。例如，比较来自摄像机的连续帧的直方图可以给我们一个关于这些连续帧之间强度变化的想法。
- en: Equalizing histograms
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: 'Using the functions and algorithms that we''ve learned so far, we can enhance
    the intensity distribution of images, or, in other words, adjust the brightness
    of too dark or overly bright images, among many other operations. In computer
    vision, the histogram-equalization algorithm is used for the exact same reason.
    This algorithm performs the following tasks:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们迄今为止学到的函数和算法，我们可以增强图像的强度分布，换句话说，调整过暗或过亮图像的亮度，以及其他许多操作。在计算机视觉中，直方图均衡化算法出于完全相同的原因被使用。此算法执行以下任务：
- en: Calculates the histogram of an image
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算图像的直方图
- en: Normalizes the histogram
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归一化直方图
- en: Calculates the integral of the histogram
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算直方图的积分
- en: Uses the updated histogram to modify the source image
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更新的直方图修改源图像
- en: Except the integral part, which is simply calculating the sum of the values
    in all bins, the rest is what we already performed in this chapter, in one way
    or another. OpenCV includes a function called `equalizeHist` that performs all
    of the mentioned operations and produces an image with an equalized histogram.
    Let's first see how this function is used and then try an example to see the effect
    for ourselves.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了积分部分，它只是简单地计算所有箱中值的总和之外，其余的都是在本章中以某种方式已经执行过的。OpenCV 包含一个名为 `equalizeHist`
    的函数，该函数执行所有提到的操作，并生成一个具有均衡直方图的图像。让我们首先看看这个函数是如何使用的，然后尝试一个示例来看看我们自己的效果。
- en: 'The following example codes depict how the `equalizeHist` function is used,
    which is extremely easy to use and requires no special parameters whatsoever:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了如何使用 `equalizeHist` 函数，这个函数极其容易使用，并且不需要任何特殊参数：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s consider for instance that we have the following image, which is extremely
    overexposed (or bright), and its histogram, which is depicted on the right-hand
    side:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图像，它极度过度曝光（或明亮），以及其直方图，如右侧所示：
- en: '![](img/00067.gif)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.gif)'
- en: 'Using the `equalizeHist` function, we can get an image with better contrast
    and brightness. Here are the resulting image and histogram of the preceding example
    image when its histogram is equalized:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `equalizeHist` 函数，我们可以得到对比度和亮度更好的图像。以下是前面示例图像在直方图均衡化后的结果图像和直方图：
- en: '![](img/00068.gif)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.gif)'
- en: Histogram equalization is quite helpful when we have to deal with images that
    have the potential to be overexposed (too bright) or underexposed (too dark).
    For instance, x-ray scan images, where the details are only visible when the contrast
    and brightness is increased using a powerful backlight, or when we are working
    with video frames from an environment that can have intensive light changes, are
    examples of conditions in which histogram equalization can be used to make sure
    the rest of the algorithms always deal with the same, or just slightly different,
    brightness and contrast levels.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不得不处理可能过度曝光（太亮）或欠曝光（太暗）的图像时，直方图均衡化非常有帮助。例如，X射线扫描图像，其中细节只有在使用强背光增加对比度和亮度时才可见，或者当我们与可能具有强烈光线变化的视频帧一起工作时，这些都是可以使用直方图均衡化来确保其余算法始终处理相同的，或者只是略微不同的亮度对比度级别的情况。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by learning about histograms, what they are, and how
    they are calculated using the OpenCV library. We learned about the bin size of
    a histogram and how it can affect the accuracy or grouping of the values in a
    histogram. We continued to learn about visualizing histograms using the functions
    and algorithms we learned in [Chapter 4](part0085.html#2H1VQ0-15c05657f8254d318ea883ef10fc67f4), *Drawing,
    Filtering and Transformation*. After going through various visualization types,
    we learned about back-projection and how we can update an image using a histogram.
    We learned about detecting pixels with a certain color and how to shift the hue
    value, and consequently the color of only those specific pixels. In the final
    sections of this chapter, we learned about comparing histograms and histogram-equalization
    algorithms. We performed hands-on examples for possible histogram comparison scenarios
    and enhanced the contrast and brightness of an overexposed image.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习直方图开始本章，了解它们是什么，以及如何使用 OpenCV 库计算它们。我们学习了直方图的箱大小及其如何影响直方图中值的准确性或分组。我们继续学习使用我们在第
    4 章[绘图、过滤和转换](part0085.html#2H1VQ0-15c05657f8254d318ea883ef10fc67f4)中学到的函数和算法来可视化直方图。在经过各种可视化类型后，我们学习了反向投影以及如何使用直方图更新图像。我们学习了检测具有特定颜色的像素以及如何移动色调值，从而仅改变这些特定像素的颜色。在本章的最后部分，我们学习了比较直方图和直方图均衡化算法。我们进行了可能的直方图比较场景的动手示例，并增强了曝光过度的图像的对比度和亮度。
- en: Histograms and how they are used to enhance and modify images using back-projection
    is one of the computer vision subjects that cannot be easily skipped over or missed,
    since it is the foundation of many image enhancement algorithms and techniques
    in photo-editing applications, or, as we'll see later on in the upcoming chapters,
    the basis of some of the most important real-time detection and tracking algorithms.
    What we learned in this chapter were a few of the most practical use cases of
    histograms and back-projection, but there is certainly much more to these algorithms
    if you start building real-life projects that make use of histograms.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图及其如何通过反向投影增强和修改图像是计算机视觉主题之一，不能轻易跳过或错过，因为它构成了许多图像增强算法和照片编辑应用中的技术基础，或者，正如我们将在接下来的章节中看到的，它是某些最重要的实时检测和跟踪算法的基础。在本章中，我们学习了直方图和反向投影的一些最实用的用例，但如果你开始构建使用直方图的现实生活项目，这些算法肯定还有更多内容。
- en: In the next chapter, we'll use all of the concepts we learned in this and the
    previous chapters to work videos and video frames to detect objects with a certain
    color, track them in real-time, or detect motion in a video.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用在本章和前几章中学到的所有概念来处理视频和视频帧，以检测具有特定颜色的对象，实时跟踪它们，或在视频中检测运动。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Calculate the histogram of the second channel in a three-channel image. Use
    an optional bin size and a range of 0 to 100 for possible values of the second
    channel.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算三通道图像中第二个通道的直方图。使用可选的箱大小和 0 到 100 的范围作为第二个通道的可能值。
- en: Create a histogram that can be used with the `calcBackProject` function to extract
    the darkest pixels from a grayscale image. Consider the darkest 25% possible pixel
    values as the grayscale intensities we are looking to extract.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个直方图，可用于与 `calcBackProject` 函数一起使用，以从灰度图像中提取最暗的像素。考虑最暗的 25% 可能的像素值作为我们想要提取的灰度强度。
- en: In the previous question, what if we needed the darkest and brightest 25% to
    be excluded, instead of extracted, in a mask?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个问题中，如果我们需要排除而不是提取最暗和最亮的 25% 的像素，在蒙版中会怎样？
- en: What is the hue value of the color red? How much should it be shifted to get
    the color blue?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 红色的色调值是多少？应该移动多少才能得到蓝色？
- en: Create a hue histogram that can be used to extract red-colored pixels from an
    image. Consider an offset of 50 for pixels that are considered reddish. Finally,
    visualize the hue histogram calculated.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个色调直方图，可用于从图像中提取红色像素。考虑将 50 作为被认为是红色的像素的偏移量。最后，可视化计算出的色调直方图。
- en: Calculate the integral of a histogram.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算直方图的积分。
- en: Perform histogram equalization on a color image. Note that the `equalizeHist`
    function only supports histogram equalization of single-channel 8-bit grayscale
    images.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对彩色图像执行直方图均衡化。注意，`equalizeHist` 函数仅支持单通道 8 位灰度图像的直方图均衡化。
- en: Further reading
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*OpenCV 3.x with Python By Example – Second Edition* ([https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition](https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition))'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过示例学习 OpenCV 3.x 与 Python 第二版* ([https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition](https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition))'
- en: '*Computer Vision with OpenCV 3 and Qt5* ([https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5](https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5))'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 OpenCV 3 和 Qt5 进行计算机视觉* ([https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5](https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5))'
