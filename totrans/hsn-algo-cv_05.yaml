- en: Back-Projection and Histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about many computer vision algorithms and
    OpenCV functions that can be used to prepare images for further processing or
    modify them in one way or another. We learned how to draw text and shapes on images,
    filter them using smoothening algorithms, perform morphological transformations
    on them, and calculate their derivatives. We also learned about geometric and
    miscellaneous transformations of images and applied colormaps to alter the tone
    of our images.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be learning about a few more algorithms and functions
    that are used mostly to prepare images for further processing, inference, and
    modification. This will be further clarified later on in this chapter, after we
    learn about histograms in computer vision. We'll be introduced to the concept
    of histograms, and then we'll learn how they are calculated and utilized with
    hands-on example codes. The other extremely important concept we'll be learning
    about in this chapter is called **back-projection**. We'll learn how back-projection
    of a histogram can be used to create an altered version of the original image.
  prefs: []
  type: TYPE_NORMAL
- en: Besides their standard usage, the concepts and algorithms that we'll learn in
    this chapter are also essential when it comes to dealing with some of the most
    widely used algorithms for object detection and tracking, which we'll be learning
    in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding histograms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back projection of histograms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Histogram comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equalizing histograms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IDE to develop C++ or Python applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenCV library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [Chapter 2](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4),
    *Getting Started with OpenCV,* for more information about how to set up a personal
    computer and make it ready to develop computer vision applications using the OpenCV
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following URL to download the source codes and examples for
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In computer vision, histograms are simply graphs that represent the distribution
    of pixel values over the possible range of the accepted values for those pixels,
    or, in other words, the probability distribution of pixels. Well, this might not
    be as crystal clear as you would expect, so let''s take single-channel grayscale
    images as a simple example to describe what histograms are, and then expand it
    to multi-channel colored images, and so on. We already know that the pixels in
    a standard grayscale image can contain values between 0 and 255\. Considering
    this fact, a graph similar to the following, which depicts the ratio of the number
    of pixels containing each and every possible grayscale pixel value of an arbitrary
    image, is simply the histogram of that given image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.gif)'
  prefs: []
  type: TYPE_IMG
- en: Keeping in mind what we just learned, it can be easily guessed that the histogram
    of a three-channel image, for example, would be three graphs representing the
    distribution of values for each channel, similar to what we just saw with the
    histogram of a single-channel grayscale image.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `calcHist` function in the OpenCV library to calculate the histogram
    of one or multiple images that can be single-channel or multi-channel themselves.
    This function requires a number of parameters that must be provided carefully
    for it to produce the desired results. Let's see how this function is used with
    a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code (followed by description of all the parameters)
    demonstrates how you can calculate the histogram of a single grayscale image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We infer the following from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`grayImg` is the input grayscale image that wants to calculate its histogram,
    and `histogram` will contain the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nimages` must contain the number of images for which we want histograms calculated,
    which, in this case, is just one image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channels` is an array that is supposed to contain the zero-based index number
    of the channels in each image for which we want their histogram calculated. For
    instance, if we want to calculate the histogram of the first, second, and fourth
    channels in a multi-channel image, the `channels` array must contain the values
    of 0, 1, and 3\. In our example, `channels` only contained `0`, since we''re calculating
    the histogram of the only channel in a grayscale image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mask`, which is common to many other OpenCV functions, is a parameter that
    is used to mask (or ignore) certain pixels, or, in other words, prevent them from
    participating in the calculated result. In our case, and as long as we are not
    working on a certain portion of an image, `mask` must contain an empty matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dims`, or the dimensionality parameters, corresponds to the dimensionality
    of the result histogram that we are calculating. It must not be greater than `CV_MAX_DIM`,
    which is 32 in current OpenCV versions. We''ll be using `1` in most cases, since
    we expect our histogram to be a simple array-shaped matrix. Consequently, the
    index number of each element in the resulting histogram will correspond to the
    bin number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`histSize` is an array that must contain the size of the histogram in each
    dimension. In our example, since the dimensionality was `1`, `histSize` must contain
    a single value. The size of the histogram, in this case, is the same as the number
    of bins in a histogram. In the preceding example code, `bins` is used to define
    the number of bins in the histogram, and it is also used as the single `histSize`
    value. Think of `bins` as the number of groups of pixels in a histogram. This
    will be further clarified with examples later on, but for now, it is important
    to note that a value of `256` for `bins` will result in a histogram containing
    the count of all individual possible pixel values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ranges` must contain pairs of values corresponding to the lower and higher
    bounds of each range of possible values when calculating the histogram of an image.
    In our example, this means a value in the single range of (`0`, `256`), which
    is what we have provided to this parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `uniform` parameter is used to define the uniformity of the histogram. Note
    that if the histogram is non-uniform, as opposed to what is demonstrated in our
    example, the `ranges` parameter must contain the lower and higher bounds of all
    dimensions, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `accumulate` parameter is used to decide whether the histogram should be
    cleared before it is calculated, or the calculated values should be added to an
    existing histogram. This can be quite useful when you need to calculate a single
    histogram using multiple images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll cover the parameters mentioned here as much as possible in the examples
    provided in this chapter. However, you can also refer to the online documentation
    of the `calcHist` function for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite obviously, trying to display the resulting histogram using a function,
    such as `imshow`, is futile since the raw format of the stored histogram is similar
    to a single column matrix that has `bins` number of rows in it. Each row, or,
    in other words, each element, of the histogram corresponds to the number of pixels
    that fall into that specific bin. Considering this, we can draw the calculated
    histogram by using drawing functions from [Chapter 4](part0085.html#2H1VQ0-15c05657f8254d318ea883ef10fc67f4),
    *Drawing, Filtering, and Transformation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that shows how we can display the histogram that we calculated
    in the previous code sample as a graph with custom size and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `gRow` and `gCol` refer to the height and width of the
    resulting graph, respectively. The rest of the parameters are either self-explanatory
    (`backgroundColor` and so on), or you have already learned about them in the previous
    chapters. Notice how each value in `histogram` is used to calculate the position
    of the line that needs to be drawn. In the preceding code, `maxVal` is simply
    used to scale the results to the visible range. Here''s how `maxVal` itself is
    calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Refer to [Chapter 3](part0048.html#1DOR00-15c05657f8254d318ea883ef10fc67f4),
    *Array and Matrix Operations,* if you need to refresh your memory about how the `minMaxLoc`
    function is used. In our example, we only need the value of the biggest element
    in the histogram, so we ignore the rest of the parameters by passing zero to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result of the preceding example codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can easily change the background or the graph color using the provided `backGroundColor`
    or `graphColor` parameters, or make the graph thinner or thicker by changing the
    `thickness` parameter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation of a histogram is extremely important, especially in photography
    and photo-editing applications, so being able to visualize them is essential for
    easier interpretation of the results. For instance, in the preceding example,
    it can be easily noticed from the resulting histogram that the source image contains
    more tones of darker colors than brighter ones. We'll see more examples of darker
    and brighter images later on, but before that, let's see how changing the number
    of bins would affect the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the resulting histograms of the same image as the previous
    example, with 150, 80, and 25 bins, from left to right, drawn using a bar chart
    visualization method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can easily notice that the lower the bins value is, the more grouped together
    the pixels are. Even though this might seem more like a lower resolution of the
    same data (from left to right), it is actually better to use a lower number of
    bins to group similar pixels together. Note that the bar-chart visualization in
    the preceding example is produced by replacing the `for` loop from the previous
    example code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these visualizations (graph or bar-chart) have their own pros and cons,
    which will be more obvious as you try calculating histograms of different types
    of images. Let''s try calculating the histogram of a color image. We''ll need
    to calculate the histogram of individual channels, as was mentioned previously.
    Here''s an example code that demonstrates how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding example code, the `split` function is used
    to create three individual images, each containing a single channel, out of our
    source color image (BGR by default). The part of the code that is mentioned with
    the commented line in the preceding code is simply a `for` loop that iterates
    over the elements of `imgChannels` and draws each graph using the exact same code
    as you saw before, but with each graph having its own unique color that is calculated
    using the following code in the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the value of `i`, `graphColor` is set to blue, green, or red, hence
    the resulting histography depicted in the previous picture.
  prefs: []
  type: TYPE_NORMAL
- en: Besides interpreting the content of an image, or to seeing how pixel values
    are distributed in an image, histograms have many use cases. In the following
    sections, we'll be learning about back-projection and other algorithms that are
    used for utilizing histograms in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Back-projection of histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering the definition of histograms from the start of the previous section,
    it can be said that back-projection of a histogram on an image means replacing
    each of its pixels with their probability distribution value. This is, in a way
    (not exactly), the reverse operation of calculating the histogram of an image.
    When we back-project a histogram on an image, we actually use a histogram to modify
    an image. Let's first see how back-projection is performed using OpenCV and, afterwards,
    dive into how it is actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `calcBackProject` function to calculate the back-projection
    of a histogram on an image. This function needs a similar set of parameters to
    the `caclHist` function. Let''s see how it is called and then further break down
    its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nimages`, `channels`, `ranges`, and `uniform` parameters in the `calcBackProject`
    function are used exactly the way they were with the `calcHist` function. `image`
    must contain the input image and `histogram` needs to be calculated with a prior
    call to the `calcHist` function or with any other method (or even manually). The
    result will be scaled by using the `scale` parameter and finally, it will be saved
    in `backProj`. It''s important to note that the values in `histogram` can be over
    the correctly displayable range, so after performing the back-projection, the
    resulting `backProj` object will not be displayable correctly. To fix this issue,
    we need to first make sure `histogram` is normalized to the displayable range
    by OpenCV. The following code must be executed before the preceding call to `calcBackProject`
    in order for the resulting `backProj` to be displayable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image depicts the result of the back-projection of the image
    with its original histogram (unaltered histogram). The image on the right-hand
    side is the result of the back-projection algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: According to the definition of histograms and back-projection, it can be said
    that the darker areas in the preceding back-projection result image contain pixels
    that are less common to the original image, and vice versa. This algorithm can
    be used (or even abused) to alter an image using a modified, or manually-made
    histogram. This technique is commonly used, for example, to create masks that
    extract only portions of an image that contains a given color or intensity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates how you can use the concept of histograms
    and back-projection to detect the pixels in an image that are in the range of
    the brightest 10% of possible pixel values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the histogram is formed manually, with `10` bins, instead of being
    calculated from the original image. Then, the last bin, or, in other words, the
    last element in the histogram, is set to `255`, which means absolute white. Obviously,
    if this wasn't done, we'd need to perform a normalization to make sure the result
    of back-projection is in the displayable range of colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the preceding code snippet when it
    is executed on the same sample image from the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The extracted mask image can be used to further modify an image, or, in the
    case of a uniquely-colored object, it can be used to detect and track the object.
    The detection and tracking algorithms will be covered thoroughly in the upcoming
    chapters, but how exactly we can use the color of an object is what we're going
    to learn next.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about back-projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First off, let's recall that the HSV color space is far better suited to dealing
    with the actual color value of pixels in an image than the standard RGB (or BGR
    and so on) color space. You might want to revisit [Chapter 1](part0021.html#K0RQ0-15c05657f8254d318ea883ef10fc67f4),
    *Introduction to Computer Vision,* for more information about this phenomenon.
    We're going to use this simple fact to find regions in an image that have a special
    color, regardless of their color intensity, brightness, and so on. For this reason,
    we need to first convert an image to the HSV color s
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s simplify this with an example case. Imagine we want to replace a specific
    color in an image, preserving the highlights, brightness, and so on. To be able
    to perform such a task, we need to be able to accurately detect a given color
    and then make sure we only change the color in the detected pixels and not their
    brightness and similar properties. The following example code demonstrates how
    we can use a manually-formed histogram of the hue channel and its back-projection
    to extract pixels that have a specific color, which, in this example, is assumed
    to be blue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform such an operation, we need to start by reading an image, converting
    it to the HSV color space, and extracting the hue channel, or, in other words,
    the first channel, as seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the hue channel inside the `hue` object, we need to form a
    proper histogram of the hue channel, which contains only the pixels with the color
    blue. The hue value can be a value between `0` and `360` (in degrees) and the
    hue value of blue is `240`. So, we can create a histogram using the following
    code, which can be used to extract the blue-colored pixels, with an offset (or
    threshold) of `50` pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code acts like a simple threshold, in which all elements in the
    histogram that have an index of `240` (plus/minus `50`) are set to `255` and the
    rest are set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualizing the manually-created hue channel histogram will allow us to have
    a better idea of the exact colors that are going to be extracted using it. The
    following code can be used to easily visualize a hue histogram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Before proceeding with the next steps, let's break down the preceding example
    code. It is almost exactly the same as visualizing a grayscale histogram or a
    single red-, green-, or blue-channel histogram. However, the interesting fact
    to note about the preceding code is where we form the `colors` object. The `colors`
    object is going to be a simple vector that contains all possible colors across
    the hue spectrum, but according to the number of bins we have. Notice how we have
    used the `saturate_cast` function in OpenCV to make sure the hue values are saturated
    into the acceptable range. The S and V channels are simply set to their highest
    possible value, which is 255\. After the `colors` object is correctly created,
    we have used the same visualization function as before. However, since OpenCV
    does not display images in the HSV color space by default (and you can expect
    the same behavior in most image display functions and libraries), we need to convert
    the HSV color space to BGR in order to display the colors correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Even though hue can take a value in the range of (0, 360), it is not possible
    to store it in single-byte C++ types (such as `uchar`), which are capable of storing
    values in the range of (0, 255). That is why hue values are considered to be in
    the range of (0, 180) in OpenCV, or, in other words, they are simply divided by
    two.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the preceding example code, if we
    try to display `theGraph` using the `imshow` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the colors we''re going to extract in a mask, if we use its corresponding
    histogram to calculate the back-project of an image. This range of colors is created
    using the simple threshold (in a loop) that we did when we formed the histogram
    manually. Obviously, if you set all the values of the histogram to `255.0` instead
    of just the blue range, you''d have the whole spectrum of colors. Here''s a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The visualization output would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's go back to our original histogram of only the blue colors and continue
    with the remaining steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to calculate the back-projection of our histogram on the hue channel
    that we had extracted in the initial step of our example. Here''s how it''s done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It's quite similar to how we created the back-projection of grayscale channels,
    but the range, in this case, is adjusted to correctly represent the possible values
    for the hue channel, which is `0` to `180`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image displays the result of such a back-projection, in which
    pixels with blue colors are extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that pixels with grayscale colors (including white and black) might also
    have a value similar to the hue value that we want to extract, but since changing
    their hue value would not have any effect on their color, we can simply ignore
    them in our example case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shift and change the hue in the pixels we extracted using the `calcBackProject`
    function. We simply need to loop through the pixels and shift their first channel
    with any desired value. The result obviously must be converted to BGR before it
    is suitable for being displayed. Here''s how:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a `shift` value of `-50` in the preceding example, which will cause
    the blue pixels to turn to green, preserving their brightness, and so on. Using
    various `shift` values would result in different colors replacing the blue pixels.
    Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What we learned in the preceding example is the basis of many color-based detection
    and tracking algorithms, as we'll learn in the upcoming chapters. Being able to
    correctly extract pixels of a certain color, regardless of their brightness shift,
    is extremely handy. Brightness shift in a color is what happens when the lighting
    over an object of a certain color is changed, or during day and night, which is
    taken into account when hue is used instead of red, green, or blue channels in
    an RGB image.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding to the final section of this chapter, it's worth noting that
    the exact same visualization method that we used for displaying the manually-made
    histogram of an imaginary hue channel can also be used to visualize the color
    histograms calculated from an image. Let's see how it's done with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, right after the initial step, instead of forming
    the histogram manually, simply calculate it using the `calcHist` algorithm, as
    seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the bin size effect is similar to what we saw in grayscale and single
    channel histograms, in the sense that it groups nearby values together. However,
    and in case of visualizing the hue channel, the nearby hue values will be grouped
    together, which results in a hue histogram that better represents similar colors
    in an image. The following example images depict the result of the preceding visualization,
    but with different `bins` values. From top to bottom, the `bins` value used to
    calculate each histogram is 360, 100, 36, and 7\. Notice how the resolution of
    the histogram decreases as the bins value is decreased:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Choosing the right bins value completely depends on what type of objects you
    are dealing with and your definition of similar colors. What can be seen from
    the preceding image is that obviously choosing a very high bin value (such as
    360) is not useful when we need at least some level of grouping of similar colors.
    On the other hand, choosing a very low bin size can result in an extreme grouping
    of colors in which calculating a back-projection would not produce an accurate
    result. Make sure to choose the bins value wisely, varying them for different
    subjects.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Histograms can be compared with each other in other to get some insight into
    the content of an image. OpenCV allows histogram comparison using a method called
    `compareHist`, which requires the comparison method to be set first. The following
    example code depicts how this function can be used to calculate the result of
    comparison between two histograms calculated using previous calls to the `calcHist`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`histogram1` and `histogram2`, in the preceding example, are simply histograms
    of two different images, or different channels of an image. `method`, on the other
    hand, which must contain a valid entry from the `HistCompMethods` enum, defines
    the comparison algorithm used by the `compareHist` function and it can be any
    one of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HISTCMP_CORREL`, for the Correlation method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTCMP_CHISQR`, for the Chi-square method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTCMP_INTERSECT`, for the Intersection method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTCMP_BHATTACHARYYA`, for the Bhattacharyya distance method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTCMP_HELLINGER`, same as `HISTCMP_BHATTACHARYYA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTCMP_CHISQR_ALT`, for the Alternative Chi-square method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTCMP_KL_DIV`, for the Kullback-Leibler divergence method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can refer to the latest OpenCV documentation to get more information about
    the mathematical details of each method, and how and what properties of histograms
    are used by them. The same can be said about the interpretation of the results
    of any method. Let''s see what this means with an example. Using the following
    sample code, we can output the result of all histogram-comparison methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the same example image we used throughout this chapter to calculate
    both `histogram1` and `histogram2`, or, in other words, if we compare one histogram
    with an equal histogram, here''s what we would get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how distance- and divergence-based methods return a value of zero, while
    correlation returns a value of one, for exact correlation. All of the results
    in the preceding output mean equal histograms. Let''s shed more light on this
    by calculating the histograms from the following two images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The following results would be created if the image on the left is used to
    create `histogram1` and the image on the right is used to create `histogram2`,
    or, in other words, an arbitrary bright image is compared with an arbitrary dark
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that the order of the histograms being passed to the
    `compareHist` function matters in some cases, such as when `HISTCMP_CHISQR` is
    used as the method. Here are the results with `histogram1` and `histogram2` passed
    in reverse order to the `compareHist` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Comparing histograms is extremely useful, especially when we need to get a better
    and more meaningful impression of changes across various images. For instance,
    comparing histograms of consecutive frames from a camera can give us an idea of
    the intensity of change between those consecutive frames.
  prefs: []
  type: TYPE_NORMAL
- en: Equalizing histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the functions and algorithms that we''ve learned so far, we can enhance
    the intensity distribution of images, or, in other words, adjust the brightness
    of too dark or overly bright images, among many other operations. In computer
    vision, the histogram-equalization algorithm is used for the exact same reason.
    This algorithm performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates the histogram of an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalizes the histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculates the integral of the histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the updated histogram to modify the source image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except the integral part, which is simply calculating the sum of the values
    in all bins, the rest is what we already performed in this chapter, in one way
    or another. OpenCV includes a function called `equalizeHist` that performs all
    of the mentioned operations and produces an image with an equalized histogram.
    Let's first see how this function is used and then try an example to see the effect
    for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example codes depict how the `equalizeHist` function is used,
    which is extremely easy to use and requires no special parameters whatsoever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider for instance that we have the following image, which is extremely
    overexposed (or bright), and its histogram, which is depicted on the right-hand
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `equalizeHist` function, we can get an image with better contrast
    and brightness. Here are the resulting image and histogram of the preceding example
    image when its histogram is equalized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.gif)'
  prefs: []
  type: TYPE_IMG
- en: Histogram equalization is quite helpful when we have to deal with images that
    have the potential to be overexposed (too bright) or underexposed (too dark).
    For instance, x-ray scan images, where the details are only visible when the contrast
    and brightness is increased using a powerful backlight, or when we are working
    with video frames from an environment that can have intensive light changes, are
    examples of conditions in which histogram equalization can be used to make sure
    the rest of the algorithms always deal with the same, or just slightly different,
    brightness and contrast levels.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by learning about histograms, what they are, and how
    they are calculated using the OpenCV library. We learned about the bin size of
    a histogram and how it can affect the accuracy or grouping of the values in a
    histogram. We continued to learn about visualizing histograms using the functions
    and algorithms we learned in [Chapter 4](part0085.html#2H1VQ0-15c05657f8254d318ea883ef10fc67f4), *Drawing,
    Filtering and Transformation*. After going through various visualization types,
    we learned about back-projection and how we can update an image using a histogram.
    We learned about detecting pixels with a certain color and how to shift the hue
    value, and consequently the color of only those specific pixels. In the final
    sections of this chapter, we learned about comparing histograms and histogram-equalization
    algorithms. We performed hands-on examples for possible histogram comparison scenarios
    and enhanced the contrast and brightness of an overexposed image.
  prefs: []
  type: TYPE_NORMAL
- en: Histograms and how they are used to enhance and modify images using back-projection
    is one of the computer vision subjects that cannot be easily skipped over or missed,
    since it is the foundation of many image enhancement algorithms and techniques
    in photo-editing applications, or, as we'll see later on in the upcoming chapters,
    the basis of some of the most important real-time detection and tracking algorithms.
    What we learned in this chapter were a few of the most practical use cases of
    histograms and back-projection, but there is certainly much more to these algorithms
    if you start building real-life projects that make use of histograms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll use all of the concepts we learned in this and the
    previous chapters to work videos and video frames to detect objects with a certain
    color, track them in real-time, or detect motion in a video.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculate the histogram of the second channel in a three-channel image. Use
    an optional bin size and a range of 0 to 100 for possible values of the second
    channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a histogram that can be used with the `calcBackProject` function to extract
    the darkest pixels from a grayscale image. Consider the darkest 25% possible pixel
    values as the grayscale intensities we are looking to extract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the previous question, what if we needed the darkest and brightest 25% to
    be excluded, instead of extracted, in a mask?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the hue value of the color red? How much should it be shifted to get
    the color blue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a hue histogram that can be used to extract red-colored pixels from an
    image. Consider an offset of 50 for pixels that are considered reddish. Finally,
    visualize the hue histogram calculated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the integral of a histogram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform histogram equalization on a color image. Note that the `equalizeHist`
    function only supports histogram equalization of single-channel 8-bit grayscale
    images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*OpenCV 3.x with Python By Example – Second Edition* ([https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition](https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Computer Vision with OpenCV 3 and Qt5* ([https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5](https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
