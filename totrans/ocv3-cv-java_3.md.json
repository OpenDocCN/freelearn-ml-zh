["```py\npublic static void blur(Mat src, Mat dst, Size ksize)\n```", "```py\npublic static void blur(Mat src, Mat dst, Size ksize, Point anchor, int borderType)\n```", "```py\nBORDER_REPLICATE:     aaaaaa|abcdefgh|hhhhhhh\nBORDER_REFLECT:       fedcba|abcdefgh|hgfedcb\nBORDER_REFLECT_101:   gfedcb|abcdefgh|gfedcba\nBORDER_WRAP:          cdefgh|abcdefgh|abcdefg\nBORDER_CONSTANT:      000000|abcdefgh|0000000\n```", "```py\npublic static void GaussianBlur(Mat src,\n                                Mat dst,\n                                Size ksize,\n                                double sigmaX [, double sigmaY])\n```", "```py\nImgproc.GaussianBlur(image, output,  new Size(3.0, 3.0), 0);\n```", "```py\nsigma = 0.3*((ksize-1)*0.5 - 1) + 0.8\n```", "```py\npublic static void medianBlur(Mat src,\n                              Mat dst,\n                              int ksize)\n```", "```py\npublic static void bilateralFilter(Mat src, Mat dst, int d,\n                                   double sigmaColor,\n                                   double sigmaSpace,\n                                   [int borderType])\n```", "```py\npublic Mat erode(Mat input, int elementSize, int elementShape){\n  Mat outputImage = new Mat();\n  Mat element = getKernelFromShape(elementSize, elementShape);\n  Imgproc.erode(input,outputImage, element);\n  return outputImage;\n}\n\npublic Mat dilate(Mat input, int elementSize, int elementShape) {\n  Mat outputImage = new Mat();\n  Mat element = getKernelFromShape(elementSize, elementShape);\n  Imgproc.dilate(input,outputImage, element);\n  return outputImage;\n}\n\npublic Mat open(Mat input, int elementSize, int elementShape) {\n  Mat outputImage = new Mat();\n  Mat element = getKernelFromShape(elementSize, elementShape);\n  Imgproc.morphologyEx(input,outputImage, Imgproc.MORPH_OPEN, element);\n  return outputImage;\n}\n\npublic Mat close(Mat input, int elementSize, int elementShape) {\n  Mat outputImage = new Mat();\n  Mat element = getKernelFromShape(elementSize, elementShape);\n  Imgproc.morphologyEx(input,outputImage, Imgproc.MORPH_CLOSE, element);\n  return outputImage;\n}\n\nprivate Mat getKernelFromShape(int elementSize, int elementShape) {\n  return Imgproc.getStructuringElement(elementShape, new Size(elementSize*2+1, elementSize*2+1), new Point(elementSize, elementSize) );\n}\n```", "```py\npublic static int floodFill(Mat image,\n                            Mat mask,\n                            Point seedPoint,\n                            Scalar newVal,\n                            Rect rect,\n                            Scalar loDiff,\n                            Scalar upDiff,\n                            int flags)\n```", "```py\npublic class FloodFillFacade {\n\n  public static final int NULL_RANGE = 0;\n  public static final int FIXED_RANGE = 1;\n  public static final int FLOATING_RANGE = 2;\n  private boolean colored = true;\n  private boolean masked = true;\n  private int range = FIXED_RANGE;\n  private Random random = new Random();\n  private int connectivity = 4;\n  private int newMaskVal = 255;\n  private int lowerDiff = 20;\n  private int upperDiff = 20;\n\n  public int fill(Mat image, Mat mask, int x, int y) {\n    Point seedPoint = new Point(x,y);\n\n    int b = random.nextInt(256);\n    int g = random.nextInt(256);\n    int r = random.nextInt(256);\n    Rect rect = new Rect();\n\n    Scalar newVal = isColored() ? new Scalar(b, g, r) : new Scalar(r*0.299 + g*0.587 + b*0.114);\n\n    Scalar lowerDifference = new Scalar(lowerDiff,lowerDiff,lowerDiff);\n    Scalar upperDifference = new Scalar(upperDiff,upperDiff,upperDiff);\n    if(range == NULL_RANGE){\n      lowerDifference = new Scalar (0,0,0);\n      upperDifference = new Scalar (0,0,0);\n    }\n    int flags = connectivity + (newMaskVal << 8) + \n      (range == FIXED_RANGE ? Imgproc.FLOODFILL_FIXED_RANGE : 0);\n    int area = 0;\n    if(masked){\n      area = Imgproc.floodFill(image, mask, seedPoint, newVal, rect, lowerDifference, upperDifference, flags);\n    }\n    else{\n      area = Imgproc.floodFill(image, new Mat(), seedPoint, newVal, rect, lowerDifference, upperDifference, flags);\n    }\n    return area;\n  }\n...\n}\n```", "```py\npublic static void pyrDown(Mat src, Mat dst ,[Size dstsize, int borderType])\n```", "```py\n|dstsize.width  * 2 – src.cols| < 2\n|dstsize.height * 2 – src.rows| < 2\n```", "```py\npublic static void pyrUp(Mat src, Mat dst)\n```", "```py\nMat gp1 = new Mat();\nImgproc.pyrDown(image, gp1);\nImgproc.pyrUp(gp1, gp1);\nCore.subtract(image, gp1, gp1);\n```", "```py\npublic static double threshold(Mat src,\n                               Mat dst,\n                               double thresh,\n                               double maxval,\n                               int type)\n```", "```py\npublic static void adaptiveThreshold(Mat src,\n                                     Mat dst,\n                                     double maxValue,\n                                     int adaptiveMethod,\n                                     int thresholdType,\n                                     int blockSize,\n                                     double C)\n```"]