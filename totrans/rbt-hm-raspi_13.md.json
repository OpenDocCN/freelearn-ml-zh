["```py\nwidth = 1500\nheight = 1500\ncutout_width = 500\ncutout_height = 500\nboundary_lines = [\n    [(0,0), (0, height)],\n    [(0, height), (width, height)],\n    [(width, height), (width, cutout_height)],\n    [(width, cutout_height), (width - cutout_width, cutout_height)],\n    [(width - cutout_width, cutout_height), (width - cutout_width, 0)],\n    [(width - cutout_width, 0), (0, 0)],\n]\n```", "```py\nfrom matplotlib import pyplot as plt\nimport arena\nfor line in arena.boundary_lines:\n    plt.plot([line[0][0], line[1][0]], [line[0][1], line[1][1]], color=\"black\")\nplt.show()\n```", "```py\nimport asyncio\nimport json\nimport arena\nimport robot\ndef send_json(data):\n    robot.uart.write((json.dumps(data)+\"\\n\").encode())\ndef read_json():\n    data = robot.uart.readline()\n    decoded = data.decode()\n    return json.loads(decoded)\n```", "```py\nasync def command_handler():\n    print(\"Starting handler\")\n    while True:\n        if robot.uart.in_waiting:\n            request = read_json()\n            print(\"Received: \", request)\n            if request[\"command\"] == \"arena\":\n                send_json({\n                    \"arena\": arena.boundary_lines,\n                })\n        await asyncio.sleep(0.1)\nasyncio.run(command_handler())\n```", "```py\nimport asyncio\nimport bleak\nasync def run():\n    ble_uuid = \"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\"\n    ble_name = \"Adafruit Bluefruit LE\"\n    devices = await bleak.BleakScanner.discover(service_uuids=[ble_uuid])\n    print(f\"Found {len(devices)} devices\")\n    print([device.name for device in devices])\n    matching_devices = [device for device in devices if device.name==ble_name]\n    if len(matching_devices) == 0:\n        raise RuntimeError(\"Could not find robot\")\n    ble_device_info = matching_devices[0]\n    print(f\"Found robot {ble_device_info.name}...\")\nasyncio.run(run())\n```", "```py\nFound 1 devices\n['Adafruit Bluefruit LE']\nFound robot Adafruit Bluefruit LE...\n```", "```py\nimport asyncio\nimport bleak\n```", "```py\nclass BleConnection:\n    ble_uuid = \"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\"\n    rx_gatt = \"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\"\n    tx_gatt = \"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\"\n    ble_name = \"Adafruit Bluefruit LE\"\n```", "```py\n    def __init__(self, receive_handler):\n        self.ble_client = None\n        self.receive_handler = receive_handler\n```", "```py\n    def _uart_handler(self, _, data: bytes):\n        self.receive_handler(data)\n```", "```py\n    async def connect(self):\n        print(\"Scanning for devices...\")\n        devices = await bleak.BleakScanner.discover(\n            service_uuids=[self.ble_uuid]\n        )\n        matching_devices = [device for device in devices if device.name==self.ble_name]\n        if len(matching_devices) == 0:\n            raise RuntimeError(\"Could not find robot\")\n        ble_device_info = matching_devices[0]\n        print(f\"Found robot {ble_device_info.name}...\")\n```", "```py\n        self.ble_client = bleak.BleakClient(ble_device_info.address)\n        await self.ble_client.connect()\n        print(\"Connected to {}\".format(ble_device_info.name))\n        self.notify_task = asyncio.create_task(\n            self.ble_client.start_notify(self.rx_gatt, self._uart_handler)\n        )\n```", "```py\n    async def close(self):\n        await self.ble_client.disconnect()\n```", "```py\n    async def send_uart_data(self, data):\n        await self.ble_client.write_gatt_char(self. tx_gatt, data)\n```", "```py\nimport asyncio\nimport json\nimport matplotlib.pyplot as plt\nfrom robot_ble_connection import BleConnection\n```", "```py\nclass RobotDisplay:\n    def __init__(self):\n        self.ble_connection = BleConnection(self.handle_data)\n        self.buffer = \"\"\n        self.arena = {}\n        self.closed = False\n        self.fig, self.axes = plt.subplots()\n```", "```py\n    def handle_close(self, _):\n        self.closed = True\n```", "```py\n    def handle_data(self, data):\n        self.buffer += data.decode()\n        while \"\\n\" in self.buffer:\n            line, self.buffer = self.buffer.split(\"\\n\", 1)\n            print(f\"Received data: {line}\")\n            try:\n                message = json.loads(line)\n            except ValueError:\n                print(\"Error parsing JSON\")\n                return\n            if \"arena\" in message:\n                self.arena = message\n```", "```py\n    def draw(self):\n        self.axes.clear()\n        if self.arena:\n            for line in self.arena[\"arena\"]:\n                self.axes.plot(\n                    [line[0][0], line[1][0]], [line[0][1], line[1][1]], color=\"black\"\n                )\n```", "```py\n    async def main(self):\n        plt.ion()\n        await self.ble_connection.connect()\n        try:\n            request = json.dumps({\"command\": \"arena\"}).encode()\n            print(f\"Sending request for arena: {request}\")\n            await self.ble_connection.send_uart_data(request)\n            self.fig.canvas.mpl_connect(\"close_event\", self.handle_close)\n```", "```py\n            while not self.closed:\n                self.draw()\n                plt.draw()\n                plt.pause(0.05)\n                await asyncio.sleep(0.01)\n        finally:\n            await self.ble_connection.close()\n```", "```py\nrobot_display = RobotDisplay()\nasyncio.run(robot_display.main())\n```", "```py\npython3 display_from_robot.py\n```", "```py\nSending request for arena: b'{\"command\": \"arena\"}'\nReceived data: {\"arena\": [[[0, 0], [0, 1500]], [[0, 1500], [1500, 1500]], [[1500, 1500], [1500, 500]], [[1500, 500], [1000, 500]], [[1000, 500], [1000, 0]], [[1000, 0], [0, 0]]]}\n```", "```py\nimport asyncio\nimport json\nimport random\nfrom ulab import numpy as np\n```", "```py\nclass Simulation:\n    def __init__(self):\n        self.population_size = 20\n        self.poses = np.array(\n            [(\n                int(random.uniform(0, arena.width)),\n                int(random.uniform(0, arena.height)),\n                int(random.uniform(0, 360))) for _ in range(self.population_size)],\n            dtype=np.float,\n        )\n```", "```py\ndef send_poses(samples):\n    send_json({\n        \"poses\": np.array(samples[:,:2], dtype=np.int16).tolist(),\n    })\n```", "```py\nasync def command_handler(simulation):\n    print(\"Starting handler\")\n    while True:\n        if robot.uart.in_waiting:\n            request = read_json()\n            print(\"Received: \", request)\n            if request[\"command\"] == \"arena\":\n                send_json({\n                    \"arena\": arena.boundary_lines,\n                })\n                send_poses(simulation.poses)\n        await asyncio.sleep(0.1)\nsimulation = Simulation()\nasyncio.run(command_handler(simulation))\n```", "```py\nimport asyncio\nimport json\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\n        self.fig, self.axes = plt.subplots()\n        self.poses = None\n```", "```py\n            if \"arena\" in message:\n                self.arena = message\n            if \"poses\" in message:\n                self.poses = np.array(message[\"poses\"], dtype=np.int16)\n```", "```py\n        if self.arena:\n            for line in self.arena[\"arena\"]:\n                self.axes.plot(\n                    [line[0][0], line[1][0]], [line[0][1], line[1][1]], color=\"black\"\n                )\n        if self.poses is not None:\n            self.axes.scatter(self.poses[:,0], self.poses[:,1], color=\"blue\")\n```", "```py\nclass DistanceSensorTracker:\n    def __init__(self):\n        robot.left_distance.distance_mode = 2\n        robot.right_distance.distance_mode = 2\n        self.left = 300\n        self.right = 300\n```", "```py\n    async def main(self):\n        robot.left_distance.start_ranging()\n        robot.right_distance.start_ranging()\n        while True:\n            if robot.left_distance.data_ready and robot.left_distance.distance:\n                self.left = robot.left_distance.distance * 10\n                robot.left_distance.clear_interrupt()\n            if robot.right_distance.data_ready and robot.right_distance.distance:\n                self.right = robot.right_distance.distance * 10\n                robot.right_distance.clear_interrupt()\n            await asyncio.sleep(0.01)     \n```", "```py\nclass CollisionAvoid:\n    def __init__(self, distance_sensors):\n        self.speed = 0.6\n        self.distance_sensors = distance_sensors\n```", "```py\n    async def main(self):\n        while True:\n            robot.set_right(self.speed)\n            while self.distance_sensors.left < 300 or \\\n                    self.distance_sensors.right < 300:\n                robot.set_left(-self.speed)\n                await asyncio.sleep(0.3)\n            robot.set_left(self.speed)\n            await asyncio.sleep(0)\n```", "```py\n        self.distance_sensors = DistanceSensorTracker()\n        self.collision_avoider = CollisionAvoid(self.distance_sensors)\n```", "```py\n    async def main(self):\n        asyncio.create_task(self.distance_sensors.main())\n        collision_avoider = asyncio.create_task(self.collision_avoider.main())\n        try:\n            while True:\n                await asyncio.sleep(0.1)\n                send_poses(self.poses)\n        finally:\n            collision_avoider.cancel()\n            robot.stop()\n```", "```py\nasync def command_handler(simulation):\n    print(\"Starting handler\")\n    simulation_task = None\n    while True:\n```", "```py\n            if request[\"command\"] == \"arena\":\n                send_json({\n                    \"arena\": arena.boundary_lines,\n                })\n            elif request[\"command\"] == \"start\":\n                if not simulation_task:\n                    simulation_task = asyncio.create_task(simulation.main())\n```", "```py\nfrom matplotlib.widgets import Button\n```", "```py\n    async def send_command(self, command):\n        request = (json.dumps({\"command\": command})  ).encode()\n        print(f\"Sending request: {request}\")\n        await self.ble_connection.send_uart_data(request)\n```", "```py\n    def start(self, _):\n        self.button_task = asyncio.create_task(self.send_command(\"start\"))\n```", "```py\n        await self.ble_connection.connect()\n        try:\n            await self.send_command(\"arena\")\n```", "```py\n            self.fig.canvas.mpl_connect(\"close_event\", self.handle_close)\n            start_button = Button(plt.axes([0.7, 0.05, 0.1, 0.075]), \"Start\")\n            start_button.on_clicked(self.start)\n            while not self.closed:\n```", "```py\nticks_per_revolution = encoder_poles * gear_ratio\nticks_to_mm = wheel_circumference_mm / ticks_per_revolution\nticks_to_m = ticks_to_mm / 1000\nm_to_ticks = 1 / ticks_to_m\nwheelbase_mm = 170\n```", "```py\n    def convert_odometry_to_motion(self, left_encoder_delta, right_encoder_delta):\n        left_mm = left_encoder_delta * robot.ticks_to_mm\n        right_mm = right_encoder_delta * robot.ticks_to_mm\n        if left_mm == right_mm:\n            return 0, left_mm, 0\n```", "```py\n        radius = (robot.wheelbase_mm / 2) * (left_mm + right_mm) / (right_mm - left_mm)\n        d_theta = (right_mm - left_mm) / robot.wheelbase_mm\n        arc_length = d_theta * radius\n```", "```py\n        rot1 = np.degrees(d_theta/2)\n        rot2 = rot1\n        return rot1, arc_length, rot2\n```", "```py\n        def move_poses(self, rot1, trans, rot2):\n    ```", "```py\n            self.poses[:,2] += rot1\n    ```", "```py\n            rot1_radians = np.radians(self.poses[:,2])\n    ```", "```py\n            self.poses[:,0] += trans * np.cos(rot1_radians)\n    ```", "```py\n            self.poses[:,1] += trans * np.sin(rot1_radians)\n    ```", "```py\n            self.poses[:,2] += rot2\n    ```", "```py\n            self.poses[:,2] = np.array([float(theta % 360) for theta in self.poses[:,2]])\n    ```", "```py\n            self.collision_avoider = CollisionAvoid(self.distance_sensors)\n    ```", "```py\n            self.last_encoder_left = robot.left_encoder.read()\n    ```", "```py\n            self.last_encoder_right = robot.right_encoder.read()\n    ```", "```py\n        def motion_model(self):\n    ```", "```py\n            new_encoder_left = robot.left_encoder.read()\n    ```", "```py\n            new_encoder_right = robot.right_encoder.read()\n    ```", "```py\n            rot1, trans, rot2 = self.convert_odometry_to_motion(\n    ```", "```py\n                new_encoder_left - self.last_encoder_left, \n    ```", "```py\n                new_encoder_right - self.last_encoder_right)\n    ```", "```py\n            self.last_encoder_left = new_encoder_left\n    ```", "```py\n            self.last_encoder_right = new_encoder_right\n    ```", "```py\n            self.move_poses(rot1, trans, rot2)\n    ```", "```py\n            while True:\n                await asyncio.sleep(0.05)\n                self.motion_model()\n                send_poses(self.poses)\n```", "```py\ndef get_random_sample(mean, scale):\n    return mean + (random.uniform(-scale, scale) + random.uniform(-scale, scale)) / 2\n```", "```py\n        self.last_encoder_right = robot.right_encoder.read()\n        self.alpha_rot = 0.09\n        self.alpha_rot_trans = 0.05\n        self.alpha_trans = 0.12\n        self.alpha_trans_rot = 0.05        \n```", "```py\n        def randomise_motion(self, rot1, trans, rot2):\n    ```", "```py\n            rot1_scale = self.alpha_rot * abs(rot1) + self.alpha_rot_trans * abs(trans)\n    ```", "```py\n            trans_scale = self.alpha_trans * abs(trans) + self.alpha_trans_rot * (abs(rot1) + abs(rot2))\n    ```", "```py\n            rot2_scale = self.alpha_rot * abs(rot2) + self.alpha_rot_trans * abs(trans)\n    ```", "```py\n            rot1_model = np.array([get_random_sample(rot1, rot1_scale) for _ in range(self.poses.shape[0])])\n    ```", "```py\n            trans_model = np.array([get_random_sample(trans, trans_scale) for _ in range(self.poses.shape[0])])\n    ```", "```py\n            rot2_model = np.array([get_random_sample(rot2, rot2_scale) for _ in range(self.poses.shape[0])])\n    ```", "```py\n            return rot1_model, trans_model, rot2_model\n    ```", "```py\n    def motion_model(self):\n        \"\"\"Apply the motion model\"\"\"\n        new_encoder_left = robot.left_encoder.read()\n        new_encoder_right = robot.right_encoder.read()\n        rot1, trans, rot2 = self.convert_odometry_to_motion(\n            new_encoder_left - self.last_encoder_left, \n            new_encoder_right - self.last_encoder_right)\n        self.last_encoder_left = new_encoder_left\n        self.last_encoder_right = new_encoder_right\n        rot1_model, trans_model, rot2_model = self.randomise_motion(rot1, trans, rot2)\n        self.move_poses(rot1_model, trans_model, rot2_model)\n```", "```py\n    low_probability = 10 ** -10\n    ```", "```py\n    def contains(x, y):\n    ```", "```py\n      if x < 0 or x > width \\\n    ```", "```py\n        or y < 0 or y > height:\n    ```", "```py\n        return False\n    ```", "```py\n      if x > (width - cutout_width) and y < cutout_height:\n    ```", "```py\n        return False\n    ```", "```py\n      return True\n    ```", "```py\n        def observation_model(self):\n    ```", "```py\n            weights = np.ones(self.poses.shape[0], dtype=np.float)\n    ```", "```py\n            for index, pose in enumerate(self.poses):\n    ```", "```py\n                if not arena.contains(pose[0], pose[1]):\n    ```", "```py\n                    weights[index] = arena.low_probability\n    ```", "```py\n            return weights\n    ```", "```py\n        def resample(self, weights, sample_count):\n    ```", "```py\n            samples = np.zeros((sample_count, 3))\n    ```", "```py\n            interval = np.sum(weights) / sample_count\n    ```", "```py\n            shift = random.uniform(0, interval)\n    ```", "```py\n            cumulative_weights = weights[0]\n    ```", "```py\n            source_index = 0\n    ```", "```py\n            for current_index in range(sample_count):\n    ```", "```py\n                weight_index = shift + current_index * interval\n    ```", "```py\n                while weight_index > cumulative_weights:\n    ```", "```py\n                    source_index += 1\n    ```", "```py\n                    source_index = min(len(weights) - 1, source_index)\n    ```", "```py\n                    cumulative_weights += weights[source_index]\n    ```", "```py\n                samples[current_index] = self.poses[source_index]\n    ```", "```py\n            return samples\n    ```", "```py\n    def __init__(self):\n        self.population_size = 200\n```", "```py\n            while True:\n                weights = self.observation_model()\n                send_poses(self.resample(weights, 20))\n                self.poses = self.resample(weights, self.population_size)\n                await asyncio.sleep(0.05)\n                self.motion_model()\n```", "```py\nfrom ulab import numpy as np\n```", "```py\ngrid_cell_size = 50\noverscan = 2\n```", "```py\ndef get_distance_to_segment(x, y, segment):\n    x1, y1 = segment[0]\n    x2, y2 = segment[1]\n    if y1 == y2 and x >= min(x1, x2) and x <= max(x1, x2):\n        return abs(y - y1)\n    if x1 == x2 and y >= min(y1, y2) and y <= max(y1, y2):\n        return abs(x - x1)\n    return np.sqrt(\n        min(\n            (x - x1) ** 2 + (y - y1) ** 2, \n            (x - x2) ** 2 + (y - y2) ** 2\n        )\n    )\n```", "```py\ndef get_distance_likelihood(x, y):\n    min_distance = None\n    for segment in boundary_lines:\n        distance = get_distance_to_segment(x, y, segment)\n        if min_distance is None or distance < min_distance:\n            min_distance = distance\n    return 1.0 / (1 + min_distance/100) ** 2\n```", "```py\ndef make_distance_grid():\n    grid = np.zeros((\n            width // grid_cell_size + 2 * overscan, \n            height // grid_cell_size + 2 * overscan\n        ), dtype=np.float)\n```", "```py\n    for x in range(grid.shape[0]):\n        column_x = x * grid_cell_size - (overscan * grid_cell_size)\n        for y in range(grid.shape[1]):\n            row_y = y * grid_cell_size - (overscan * grid_cell_size)\n            grid[x, y] = get_distance_likelihood(\n                column_x, row_y\n            )\n    return grid distance_grid = make_distance_grid()\n```", "```py\ndist_side_mm = 37\ndist_forward_mm = 66\n```", "```py\n    def get_distance_likelihood_at(x, y):\n    ```", "```py\n      \"\"\"Return the distance grid value at the given point.\"\"\"\n    ```", "```py\n      grid_x = int(x // grid_cell_size + overscan)\n    ```", "```py\n      grid_y = int(y // grid_cell_size + overscan)\n    ```", "```py\n      if grid_x < 0 or grid_x >= distance_grid.shape[0] or grid_y < 0 or grid_y >= distance_grid.shape[1]:\n    ```", "```py\n        return low_probability\n    ```", "```py\n      return distance_grid[grid_x, grid_y]\n    ```", "```py\n        def get_sensor_endpoints(self, sensor_reading, right=False):\n    ```", "```py\n            adjacent = sensor_reading + robot.dist_forward_mm\n    ```", "```py\n            angle = np.atan(robot.dist_side_mm / adjacent)\n    ```", "```py\n            if right:\n    ```", "```py\n                angle = - angle\n    ```", "```py\n            hypotenuse = np.sqrt(robot.dist_side_mm**2 + adjacent**2)\n    ```", "```py\n            pose_angles = np.radians(self.poses[:,2]) + angle\n    ```", "```py\n            sensor_endpoints = np.zeros((self.poses.shape[0], 2), dtype=np.float)\n    ```", "```py\n            sensor_endpoints[:,0] = self.poses[:,0] + hypotenuse * np.cos(pose_angles)\n    ```", "```py\n            sensor_endpoints[:,1] = self.poses[:,1] + hypotenuse * np.sin(pose_angles)\n    ```", "```py\n            return sensor_endpoints\n    ```", "```py\n        def observe_distance_sensors(self, weights):\n    ```", "```py\n            left_sensor = self.get_sensor_endpoints(self.distance_sensors.left)\n    ```", "```py\n            right_sensor = self.get_sensor_endpoints(self.distance_sensors.right, True)\n    ```", "```py\n        for index in range(self.poses.shape[0]):\n            sensor_weight = arena. get_distance_likelihood_at(left_sensor[index,0], left_sensor[index,1])\n            sensor_weight += arena. get_distance_likelihood_at(right_sensor[index,0], right_sensor[index,1])\n```", "```py\n                weights[index] *= sensor_weight\n    ```", "```py\n            return weights\n    ```", "```py\n    def observation_model(self):\n        weights = np.ones(self.poses.shape[0], dtype=np.float)\n        for index, pose in enumerate(self.poses):\n            if not arena.contains(pose[0], pose[1]):\n                weights[index] = arena.low_probability\n        weights = self.observe_distance_sensors(weights)\n        weights = weights / np.sum(weights)\n        return weights\n```"]