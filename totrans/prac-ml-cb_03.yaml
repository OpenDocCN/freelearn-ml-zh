- en: Chapter 3. Clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical clustering - World Bank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hierarchical clustering - Amazon rainforest burned between 1999-2010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hierarchical clustering - gene clustering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary clustering - math test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K-means clustering - European countries protein consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K-means clustering - foodstuff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hierarchical clustering**: One of the most important methods in unsupervised
    learning is Hierarchical clustering. In Hierarchical clustering for a given set
    of data points, the output is produced in the form of a binary tree (dendrogram).
    In the binary tree, the leaves represent the data points while internal nodes
    represent nested clusters of various sizes. Each object is assigned a separate
    cluster. Evaluation of all the clusters takes place based on a pairwise distance
    matrix. The distance matrix will be constructed using distance values. The pair
    of clusters with the shortest distance must be considered. The identified pair
    should then be removed from the matrix and merged together. The merged clusters''
    distance must be evaluated with the other clusters and the distance matrix should
    be updated. The process is to be repeated until the distance matrix is reduced
    to a single element.'
  prefs: []
  type: TYPE_NORMAL
- en: An ordering of the objects is produced by hierarchical clustering. This helps
    with informative data display. The smaller clusters produced help in the discovery
    of information. The main disadvantage of hierarchical clustering is that, if the
    objects have been incorrectly grouped at an early stage then, there is no provision
    for a relocation of objects. Use of different distance metrics for measuring distances
    between clusters may result in the generation of different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**K-means clustering**: The K-means clustering algorithm is a method for estimating
    the mean (vectors) of a set of K-groups. The K-Means clustering method is unsupervised,
    non-deterministic, and iterative in nature. The method produces a specific number
    of disjointed, flat (non-hierarchical) clusters. K denotes the number of clusters.
    These clusters are based on the data at hand. Each of the clusters has at least
    one data point. The clusters are non-overlapping and non-hierarchical in nature.
    The dataset is partitioned into K number of clusters. The data points are randomly
    assigned to each of the clusters. This results in an almost equal distribution
    of data points among the clusters at the early stage. If a data point is closest
    to its own cluster, it is not changed. If a data point is not close to its own
    cluster, it is moved to the cluster to which it is closest. The steps are repeated
    for all the data points till no data points are moving from one cluster to another.
    At this point the clusters are stabilized and the clustering process ends. The
    choice of initial an partition can greatly affect the final clusters that result,
    in terms of inter-cluster and intra-cluster distances and cohesion.'
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of K-means clustering is that it is relatively computationally,
    less expensive in terms of time compared to hierarchical clustering. The main
    challenge is that there is a difficulty in determining the number of clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical clustering - World Bank sample dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main goals for establishing the World Bank was to fight and eliminate
    poverty. Continuous evolution and fine-tuning its policies in the ever-evolving
    world has been helping the institution to achieve the goal of poverty elimination.
    The barometer of success in the elimination of poverty is measured in terms of
    improvement of each of the parameters in health, education, sanitation, infrastructure,
    and other services needed to improve the lives of the poor. The development gains
    that will ensure the goals must be pursued in an environmentally, socially, and
    economically sustainable manner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform Hierarchical clustering, we shall be using a dataset collected
    from the World Bank dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset titled `WBClust2013` shall be used. This is available in the CSV
    format titled `WBClust2013.csv`. The dataset is in standard format. There are
    80 rows of data and 14 variables. The numeric variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new.forest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rural`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log.CO2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log.GNI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log.Energy.2011`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LifeExp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fertility`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InfMort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log.Exports`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log.Imports`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CellPhone`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuralWater`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variable is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Country`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.3 (2015-12-10)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships between variables.
    We''ll begin by importing the CSV file named `WBClust2013.csv`. We will be saving
    the data to the `wbclust` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we shall print the `wbclust` data frame. The `head()` function returns
    the `wbclust` data frame. The `wbclust` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - transforming data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Centering variables and creating z-scores are two common data analysis activities
    to standardize data. The numeric variables mentioned above need to create z-scores.
    The `scale()` function is a generic function whose default method centers and/or
    scales the columns of a numeric matrix. The data frame, `wbclust` is passed to
    the scale function. Only numeric fields are considered. The result is then stored
    in another data frame, `wbnorm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - transforming data](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All data frames have a `rownames` attribute. In order to retrieve or set the
    row or column names of a matrix-like object, the `rownames()` function is used.
    The data frame `wbclust` with the first column is passed to the `rownames()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the function `rownames(wbnorm)` results in displaying of the values
    from the first column. The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - transforming data](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - training and evaluating the model performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is about training the model. The first step is to calculate the
    distance matrix. The `dist()` function is used. Using the specified distance measure,
    distances between the rows of a data matrix are computed. The distance measure
    used can be Euclidean, maximum, Manhattan, Canberra, binary, or Minkowski. The
    distance measure used is Euclidean. The Euclidean distance calculates the distance
    between two vectors as *sqrt(sum((x_i - y_i)^2))*. The result is then stored in
    a new data frame, `dist1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to perform clustering using Ward's method. The `hclust()` function
    is used. In order to perform cluster analysis on a set of dissimilarities of *n*
    objects, the `hclust()` function is used. At the first stage, each of the objects
    is assigned to its own cluster. After this, at each stage the algorithm iterates
    and joins two of the most similar clusters. This process continues till there
    is just a single cluster left. The `hclust()` function requires that we provide
    the data in the form of a distance matrix. The `dist1` data frame is passed. By
    default, the complete linkage method is used. There are multiple agglomeration
    methods which can be used, some of them could be `ward.D`, `ward.D2`, `single`,
    `complete`, and `average`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the function `clust1` results in displaying the agglomeration methods
    used, the manner in which the distance is calculated, and the number of objects.
    The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training and evaluating the model performance](img/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - plotting the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `plot()` function is a generic function for plotting R objects. Here, the
    `plot()` function is used to draw the dendrogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `rect.hclust()` function highlights the clusters and draws the rectangles
    around the branches of the dendrogram. The dendrogram is first cut at a certain
    level followed by drawing a rectangle around the selected branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object `clust1` is passed as an object to the function along with the number
    of clusters to be formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `cuts()` function shall cut the tree into multiple groups on the basis
    of the desired number of groups or the cut height. Here, `clust1` is passed as
    an object to the function along with the number of the desired group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Getting the list of countries in each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hierarchical clustering - Amazon rainforest burned between 1999-2010
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Between 1999-2010, 33,000 square miles (85,500 square kilometers), or 2.8 percent
    of the Amazon rainforest burned down. This was found by NASA-led research. The
    main purpose of the research was to measure the extent of fire smolders under
    the forest canopy. The research found that burning forests destroys a much larger
    area compared to when forest lands are cleared for agriculture and cattle pasture.
    Yet, no correlation could be established between the fires and deforestation.
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the query of no correlation between fires and deforestation lay
    in humidity data from the **Atmospheric Infrared Sounder** (**AIRS**) instrument
    aboard NASA's Aqua satellite. The fire frequency coincides with low night-time
    humidity, which allowed the low-intensity surface fires to continue burning.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform hierarchical clustering, we shall be using a dataset collected
    on the Amazon rainforest, which burned from 1999-2010.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The  `NASAUnderstory` dataset shall be used. This is available in CSV format
    as `NASAUnderstory.csv`. The dataset is in standard format. There are 64 rows
    of data and 32 variables. The numeric variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlotID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASMA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOSS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LEGR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHCA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GRAS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEDG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SMTR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PTAQ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COCA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VAAN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GAHI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARNU`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LYOB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PIMA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUBU`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VAOX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACSP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COCO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACRU`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRBO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MACA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STRO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FUNG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DILO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERIO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GATR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Overstory Species`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Labels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.3 (2015-12-10)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships among the variables.
    We''ll begin by importing the file named `NASAUnderstory.csv`. We will be saving
    the data to the `NASA` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we shall obtain the long version of each of the species column labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we shall print the `NASA.lab` data frame. This contains the complete name
    of each of the species as obtained.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we shall pass the entire data content to the `NASA` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Printing the `NASA` data frame shall results in displaying the entire data content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - transforming data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, data standardization shall be carried out. The `scale()` function shall
    center and scale the columns of all the numeric variables as mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This shall scale all the numeric values between columns `3` to `31` of the `NASA`
    data frame.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the `NASAscale` data frame results in displaying all the scaled and
    centered values of the `NASAscale.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - transforming data](img/image_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to encode a vector as a factor, the function factor is used. If the
    argument ordered is `TRUE`, the factor levels are assumed to be ordered. Here,
    we are passing the `OverstorySpecies` column as a value to the factor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `as.factor()` returns a data frame with the row names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Printing the data frame `rownames(NASAscale)` results in displaying all the
    values of the `OverstorySpecies` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - transforming data](img/image_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - training and evaluating model performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is about training the model. The first step is to calculate the
    distance matrix. The `dist()` function is used. The function computes and returns
    the distance matrix, using the specified distance measure to compute the distances
    between the rows of a data matrix. The distance measure used can be Euclidean,
    maximum, Manhattan, Canberra, binary, or Minkowski. The distance measure used
    is Euclidean. The Euclidean distance calculates the distance between two vectors
    as *sqrt(sum((x_i - y_i)^2))*. The result is then stored in a new data frame `dist1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to perform clustering using Ward's method. The `hclust()` function
    is used. In order to perform cluster analysis on a set of dissimilarities of *n*
    objects, the `hclust()` function is used. At the first stage, each of the objects
    is assigned to its own cluster. The algorithm then proceeds iteratively at each
    stage joining the two most similar clusters. This process continues till there
    is just a single cluster left. The `hclust()` function requires us to provide
    the data in the form of a distance matrix. The `dist1` data frame is passed. By
    default, the complete linkage method is used. There can be multiple agglomeration
    methods which can be used, some of them could be `ward.D`, `ward.D2`, `single`,
    `complete`, and `average`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the function, `clust1` results in display of the agglomeration
    method used, the manner in which the distance is calculated, and the number of
    objects. The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training and evaluating model performance](img/image_03_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - plotting the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `plot()` function is a generic function for the plotting R objects. Here,
    the `plot()` function is used to draw the dendrogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `rect.hclust()` function highlights clusters and draws rectangles around
    the branches of the dendrogram. The dendrogram is first cut at a certain level
    followed by drawing a rectangle around selected branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object, `clust1` is passed as an object to the function along with the
    number of clusters to be formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `cuts()` function shall cut the tree into multiple groups on the basis
    of the desired number of groups or the cut height. Here, `clust1` is passed as
    an object to the function along with the number of desired groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 6 - improving model performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following package needs to be loaded as a first step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `vegan` library is primarily used by community and vegetation ecologists.
    It contains ordination methods, diversity analysis, and other functions. Some
    of the popular tools are **diversity analysis, species abundance models, analysis
    of species richness, dissimilarity analyses, and so on.**
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is about improving the model by training using the distance method,
    `jaccard`. The first step is to calculate the distance matrix. The `vegdist()`
    function is used. The function calculates pairwise distance. The result is then
    stored in a new data frame, `dist1`. The `jaccard` coefficient measures similarity
    between finite sample sets. This is calculated by dividing the size of the intersection
    by the size of the union of the sample sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to perform clustering using Ward''s method. The `hclust()`
    function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the function, `clust1` results in display of the agglomeration
    methods used, the manner in which the distance is calculated, and the number of
    objects. The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/image_03_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plot()` function is a generic function for the plotting R objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `clust1` data frame is passed as an object to the function. `cex` gives
    the numerical value of the amount by which plotting text and symbols can be magnified
    relative to the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/image_03_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The object `clust1` is passed as an object to the function along with the number
    of clusters to be formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/B04714_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `cuts()` function shall cut the tree into multiple groups on the basis
    of the desired number of groups or the cut height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/image_03_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using principal components lets us plot of two cluster solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The `clusplot()` function shall draw a two-dimensional clustering plot. Here,
    the `NASA` data frame is passed as an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/image_03_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using discriminant functions lets us plot two cluster solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The `plotcluster()` function plots using projection methods in order to distinguish
    the given classes. Various projection methods include classical discriminant coordinates,
    methods to project differences in mean and covariance structure, asymmetric methods
    (separation of a homogeneous class from a heterogeneous one), local neighborhood-based
    methods and methods based on robust covariance matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clusplot()` function shall draw a two-dimensional clustering plot. Here,
    the `NASA` data frame is passed as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/B04714_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, transposing the `NASAscale` data frame takes place using the `t()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The next step is about improving the model by training using the Minkowski distance
    method. The first step is to calculate the distance matrix. The `dist()` function
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: The Minkowski distance is often used when variables are measured on ratio scales
    with an absolute zero value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to perform clustering using Ward's method. The `hclust()` function
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the `clust1` function results in display of the agglomeration method
    used, the manner in which the distance is calculated, and the number of objects.
    The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/image_03_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plot()` function is a generic function for the plotting R objects. Here,
    the `plot()` function is used to draw the dendrogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/image_03_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `rect.hclust()` function shall draw rectangles around the branches of the
    dendrogram highlighting the corresponding clusters. First, the dendrogram is cut
    at a certain level, and then a rectangle is drawn around selected branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clust1` object is passed as an object to the function along with the number
    of clusters to be formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/image_03_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `cuts()` function shall cut the tree into multiple groups on the basis
    of the desired number of groups or the cut height. Here, `clust1` is passed as
    an object to the function along with the number of the desired group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - improving model performance](img/image_03_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hierarchical clustering - gene clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to gather genome-wide expression data is a computationally complex
    task. The human brain with its limitations cannot solve the problem. However,
    data can be fine-grained to an easily comprehensible level by subdividing the
    genes into a smaller number of categories and then analyzing them.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of clustering is to subdivide a set of genes in such a way that similar
    items fall into the same cluster, whereas dissimilar items fall into different
    clusters. The important questions to be considered are decisions on similarity
    and usage for the items that have been clustered. Here we shall explore clustering
    genes and samples using the photoreceptor time series for the two genotypes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform Hierarchical clustering, we shall be using a dataset collected
    on mice.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The datasets titled `GSE4051_data` and `GSE4051_design` shall be used. These
    are available in the CSV format titled `GSE4051_data.csv` and `GSE4051_design.csv`.
    The dataset is in standard format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GSE4051_data` there are 29,949 rows of data and 39 variables. The numeric
    variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sample_21`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_22`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_23`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_16`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_17`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_6`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_26`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_27`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_14`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_29`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_30`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_31`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_7`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_32`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_33`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_34`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_35`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_13`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_15`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_18`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_19`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_36`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_37`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_38`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_39`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_11`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_12`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sample_9`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `GSE4051_design` dataset there are 39 rows of data and 4 variables.
    The numeric variable is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sidNum`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sidChar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devStage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.3 (2015-12-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The `RColorBrewer` package is an R package from [http://colorbrewer2.org](http://colorbrewer2.org)
     and provides color schemes for maps and other graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pvclust` package is used for assessing uncertainty in hierarchical cluster
    analysis. In hierarchical clustering, each of the clusters calculates p-values
    via multi-scale bootstrap resampling. The p-value of a cluster is measured between
    0 and 1\. There are two types of p-value available: **approximately** **unbiased**
    (**AU**) and **bootstrap probability** (**BP**) value. The AU p-value is calculated
    using the multi-scale bootstrap resampling method, while the ordinary bootstrap
    resampling method is used to calculate the BP p-value. The AU p-value has superiority
    bias compared to the BP p-value.'
  prefs: []
  type: TYPE_NORMAL
- en: LaTeX-formatted tables are produced by the `xtable` package. Using `xtable`,
    package-specific R objects can be turned into `xtables`. These `xtables` can then
    be output in either LaTeX or HTML formats.
  prefs: []
  type: TYPE_NORMAL
- en: The `plyr` package is used as a tool for carrying out **split-apply-combine**
    (**SAC**) procedures. It breaks a big problem down into manageable pieces, operates
    on each piece, and then puts all the pieces back together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following packages must be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore the data and understand the relationships among the variables.
    We''ll begin by importing the CSV file named `GSE4051_data.csv`. We will be saving
    the data to the `GSE4051_data` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we shall print information about the `GSE4051_data` data frame. The `str()`
    function returns the provided information about the structure of the `GSE4051_data`
    data frame. It compactly displays the internal structure of the `GSE4051_data`
    data frame. `max.level` indicates the maximal level of nesting applied to display
    nested structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_03_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we shall import the CSV file named `GSE4051_design.csv`. We will be saving
    the data to the `GSE4051_design` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line prints the internal structure of the `GSE4051_design` data
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_03_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - transforming data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to ease visualization at a later stage, the rows are rescaled. Since
    the absolute differences in the expression between genes at the currently required,
    rescaling of the rows is carried out.
  prefs: []
  type: TYPE_NORMAL
- en: Centering variables and creating z-scores are two common data analysis activities.
    The `scale` function centers and/or scales the columns of a numeric matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transposing the matrix. The `GSE4051_data` data frame is passed for transposition
    of the data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Next, we shall print information about the `GSE4051_data` data frame. With `give.attr
    = FALSE`, attributes as sub structures are not displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - transforming data](img/image_03_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `head()` function returns the first part of a vector, matrix, table, data
    frame, or function. The `GSE4051_data` and `trans_GSE4051_data` data frames are
    passed as objects. The `rowMeans()` function calculates the means of rows. The
    `data.frame()` function creates data frames that are tightly coupled collections
    of variables and share many of the properties of matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - transforming data](img/image_03_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - training the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is training the model. The first step is to calculate the distance
    matrix. The `dist()` function is used. The function computes and returns the distance
    matrix, using the specified distance measure to compute the distances between
    the rows of a data matrix. The distance measure used can be Euclidean, maximum,
    Manhattan, Canberra, binary, or Minkowski. The distance measure used is Euclidean.
    The Euclidean distance calculates the distance between two vectors as *sqrt(sum((x_i
    - y_i)^2))*. The transposed `trans_GSE4051_data` data frame is used to calculate
    the distance. The result is then stored in the `pair_dist_GSE4051_data` data frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `interaction()` function is used, which computes and returns an unordered
    factor with the interaction of the `gType`, `devStage` variables. The result of
    unordered factors is passed to the `with()` function along with the data frame,
    `GSE4051_design`. This creates a new factor representing the interaction of `gType`,
    `devStage` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `summary()` function is used to produce result summaries of the data frame,
    `GSE4051_design$group`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, the computing of hierarchical clustering using various linkage types is
    carried out.
  prefs: []
  type: TYPE_NORMAL
- en: The `hclust()` function is used. In order to perform cluster analysis on a set
    of dissimilarities of *n* objects, the `hclust()` function is used. At the first
    stage, each of the objects is assigned to its own cluster. The algorithm then
    proceeds iteratively at each stage joining the two most similar clusters. This
    process continues till there is just a single cluster left. The `hclust()` function
    requires we provide the data in the form of a distance matrix. The `pair_dist_GSE4051_data`
    data frame is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The agglomeration method, `single`, is used as the first case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `pr.hc.single` results in display of the agglomeration method used,
    the manner in which the distance is calculated and the number of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The agglomeration method, `complete` is used as the second case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `pr.hc.complete` results in display of the agglomeration method
    used, the manner in which the distance is calculated and the number of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The agglomeration method `average` is used as the third case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `pr.hc.average` results in display of the agglomeration method
    used, the manner in which the distance is calculated, and the number of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The agglomeration method ward is used as the fourth case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `pr.hc.ward` results in display of the agglomeration method used,
    the manner in which the distance is calculated, and the number of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `plot()` function is a generic function for plotting R objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first call to the `plot()` function passes the `pr.hc.single` data frame
    as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second call to the `plot()` function passes the `pr.hc.complete` data frame
    as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The third call to the `plot()` function passes the `pr.hc.average` data frame
    as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The fourth call to the `plot()` function passes the `pr.hc.ward` data frame
    as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - training the model](img/image_03_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 - plotting the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `plot()` function is a generic function for the plotting R objects. Here,
    the `plot()` function is used to draw the dendrogram.
  prefs: []
  type: TYPE_NORMAL
- en: The `rect.hclust()` function shall draw rectangles around the branches of the
    dendrogram highlighting the corresponding clusters. First the dendrogram is cut
    at a certain level, and then a rectangle is drawn around selected branches.
  prefs: []
  type: TYPE_NORMAL
- en: '`RColorBrewer` uses the work from [http://colorbrewer2.org/](http://colorbrewer2.org/)
    to choose sensible color schemes for figures in R.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The colors are split into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequential: Low data--light colors; high data--dark colors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Diverging: Mid-range data--light colors; low and high range data--contrasting
    dark colors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qualitative: Colors have been designed to highlight the maximum visual difference
    between classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the important functions of `RColorBrewer` is `brewer.pal()`. This function
    allows one to choose from the `display.brewer.all()` function by passing the number
    of colors and the name of the palette.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first case, `pr.hc.single` is passed as an object to the `plot()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we create the heat maps using the `single` agglomeration method. By default,
    the `heatmap()` function uses the agglomeration method `euclidean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a second case, `pr.hc.complete` is passed as an object to the `plot()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next we create heat maps using the `complete` agglomeration method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a third case, `pr.hc.average` is passed as an object to the `plot()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we create heat maps using the `average` agglomeration method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a fourth case, `pr.hc.ward` is passed as an object to the `plot()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we create heat maps using the `ward` agglomeration method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the model](img/image_03_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Binary clustering - math test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the education system tests and examinations are major features. The advantage
    of examination system is that it can be one of the ways to differentiate between
    good and poor performers. The examination system puts the onus on students to
    upgrade for next standard for which they should appear and pass exams. It creates
    responsibility on students to study on regular basis. The exam systems prepare
    the students to meet the challenges of future. It helps them to analyze reason
    and communicate their ideas effectively in a fixed time period. On the other hand
    few draw backs are noticed such as slow learners cannot perform well in test and
    this creates inferior complexity among students.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform binary clustering, we shall be using a dataset collected
    on math tests.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dataset titled `math test` shall be used. This is available in the TXT format
    titled `math test.txt`. The dataset is in standard format. There are 60 rows of
    data. There are 60 columns. The columns are scores on items for 55 male students.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.3 (2015-12-10)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand relationships among the variables. We''ll
    begin by importing the TXT file named `ACT math test.txt`. We will be saving the
    data to the `Mathtest` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 - training and evaluating model performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we shall perform clustering of the items. Groups of items based on the
    students' scores shall be clustered together.
  prefs: []
  type: TYPE_NORMAL
- en: First, we shall count the total mismatches based on the squared Euclidean distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dist()` function is called. The `Mathtest` data frame is passed as input
    to the `dist()` function. Counting the total mismatches based on the squared Euclidean
    distance, the result shall be stored in the, `dist.items` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Next, we shall print the `dist.items` data frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - training and evaluating model performance](img/image_03_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, the distance measure ignores `0-0` matches altogether. The binary method
    shall be used in the `dist()` function. In the binary method, the non-zero elements
    are on and zero-elements are off since the vectors are considered binary bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Next, we shall print the data frame, `dist.items.2`, to observe the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - training and evaluating model performance](img/image_03_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, the distance measure ignores `1-1` matches altogether. The binary method
    shall be used in the `dist()` function. In the binary method, the non-zero elements
    are on and zero-elements are off since the vectors are considered binary bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Next, we shall print the data frame, `dist.items.3`, to observe the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - training and evaluating model performance](img/image_03_050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to perform clustering using the `complete` method. The `hclust()`
    function is used. In order to perform cluster analysis on a set of dissimilarities
    for *n* objects, the `hclust()` function is used. At the first stage, each of
    the objects is assigned to its own cluster. The algorithm then proceeds iteratively
    at each stage joining the two most similar clusters. This process continues till
    there is just a single cluster left. The `hclust()` function requires us to provide
    the data in the form of a distance matrix. The `dist1` data frame is passed. By
    default, the complete linkage method is used. There can be multiple agglomeration
    methods which can be used, some of them could be `ward.D`, `ward.D2`, `single`,
    `complete`, or `average`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method used is complete. When the complete method is used, the cluster
    that is formed has the maximum distance between any object in the cluster and
    the other object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the `items.complete.link` function results in display of the agglomeration
    method used, the manner in which the distance is calculated, and the number of
    objects. The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - training and evaluating model performance](img/image_03_051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - plotting the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `plot()` function is a generic function for the plotting R objects. Here,
    the `plot()` function is used to plot the complete linkage dendrogram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete linkage is used for hierarchical clustering, and ensures the distance
    between two clusters is the maximum distance. At each step of the algorithm when
    using complete linkage, two of the nearest clusters are merged together. The process
    is iterated until the entire dataset is merged into a single cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - plotting the model](img/image_03_052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we shall be performing single linkage on the dendrogram. In single linkage
    hierarchical clustering, each step is merged into two clusters based on the smallest
    distance to other objects, or the smallest minimum pairwise distance between the
    clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the `items.sing.link` function results in display of the agglomeration
    method used, the manner in which the distance is calculated, and the number of
    objects. The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - plotting the model](img/image_03_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the `plot()` function is used to plot the complete linkage dendrogram.
    `items.sing.link` is passed as a data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - plotting the model](img/image_03_054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - K-medoids clustering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Loading the `cluster()` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In order to calculate the average silhouette width, we write a function.
  prefs: []
  type: TYPE_NORMAL
- en: Silhouette refers to a method for interpreting and validating consistency within clusters
    of data. In order to provide the position of the object in the cluster, the technique
    uses graphical representation. The silhouette range of is between -1 and 1, with
    1 indicating the highest match and -1 indicating the poorest match of the object
    to its own cluster. In a cluster, if most of the objects have a high value, for
    instance closer to 1, the clustering configuration is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`rep()` is a generic function that is used to replicate the values of `my.k.choices`.
    The result is stored in the data frame `avg.sil.width`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '**PAM** stands for **Partitioning Around Medoids**. PAM requires that one be aware
    of the number of clusters desired (like k-means clustering), but it does more
    computation than k-means in order to ensure that the medoids it finds are truly
    representative of the observations within a given cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Printing the value of choices with silhouette values calculated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - K-medoids clustering](img/image_03_055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Performing clustering on the basis of 2 clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - K-medoids clustering](img/image_03_056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `lapply()` function returns a list of the same length as X, each element
    of which is the result of applying `FUN` to the corresponding element of X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - K-medoids clustering](img/image_03_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Performing clustering on the basis of 3 clusters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - K-medoids clustering](img/image_03_058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - K-medoids clustering](img/image_03_059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: K-means clustering - European countries protein consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A food consumption pattern is of great interest in the field of medicine and
    nutrition. Food consumption is correlated to the overall health of an individual,
    the nutritional value of the food, the economics involved in purchasing a food
    item, and the environment in which it is consumed. This analysis is concerned
    with the relationship between meat and other food items in 25 European countries.
    It is interesting to observe the correlation between meat and other food items.
    The data includes measures of red meat, white meat, eggs, milk, fish, cereals,
    starchy foods, nuts (including pulses and oil-seeds), fruits, and vegetables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform K-means clustering, we shall be using a dataset collected
    on protein consumption for 25 European countries.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dataset titled `protein` which is in the CSV format shall be used. The dataset
    is in standard format. There are 25 rows of data and are 10 variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The numeric variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RedMeat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WhiteMeat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Eggs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Milk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cereals`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Starch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nuts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fr&Veg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variable is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Country`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.3 (2015-12-10)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand relationships among the variables. We''ll
    begin by importing the CSV file named `protein.csv`. We will be saving the data
    to the `protein` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `head()` returns the first or last parts of a vector, matrix, table, data
    frame, or function. The `protein` data frame is passed to the `head()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_03_060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - clustering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start clustering on the basis of three clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to find a random number of clusters at the initial stage, call the
    `set.seed()` function. The `set.seed()` function results in the generation of
    random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kmeans()` function shall carry out the K-means clustering on the data
    matrix. The `protein` data matrix is passed as an object that can be coerced to
    a numeric matrix of data. `centers=3` signifies the number of initial (distinct)
    cluster centers. Since, the number of clusters is denoted by a number, `nstart=10`
    defines the number of random sets to be chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - clustering](img/image_03_061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, the listing of cluster assignments takes place. The `order()` function returns
    a permutation that rearranges its first argument, produced in ascending or descending
    order. The data frame `groupMeat` is passed as a data frame object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the `data.frame()` function results in displaying the countries
    and the clusters in which they are placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - clustering](img/image_03_062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plot()` function is a generic function for the plotting R objects. The
    argument type signifies the type of plot to be drawn. The `xlim` argument means
    arguments should be given the extremes of the range, not a range. `xlab` and `ylab`
    provide the title for the *x-*axis and *y-*axis respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - clustering](img/image_03_063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - improving the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, clustering on all the nine protein groups takes place and seven clusters
    are created. There is a close significance between the colored scatter-plot for white
    meat against red meat. Countries in close geographic proximity tend to be clustered
    into the same group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set.seed()` function results in the generation of random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '`centers=7` signifies the number of initial (distinct) cluster centers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Seven different clusters are formed. Each of the 25 countries is placed in one
    of the clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_03_064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clustplot()` function creates a bivariate plot that can be visualized
    as a partition (clustering) of the data. All observations are represented by points
    in the plot, using principal components. Around each cluster, an ellipse is drawn.
    The data frame, protein is passed as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_03_065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another approach is to view it in hierarchical form. The `agnes()` function
    is used. By putting `diss=FALSE`, the dissimilarity matrix is used for calculating
    from raw data. `metric="euclidean`" indicates the use of the Euclidean distance
    measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_03_066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_03_067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `cutree()` function cuts a tree into several groups by specifying either
    the desired number(s) of groups or the cut height(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 4 - improving the model](img/image_03_068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - improving the model](img/image_03_069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: K-means clustering - foodstuff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nutrients in the food we consume can be classified by the role they play in
    building body mass. These nutrients can be divided into either macronutrients
    or essential micronutrients. Some examples of macronutrients are carbohydrates,
    protein, and fat while some examples of essential micronutrients are vitamins,
    minerals, and water.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started with the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to perform K-means clustering we shall be using a dataset collected
    on various food items and their respective `Energy`, `Protein`, `Fat`, `Calcium`,
    and `Iron` content. The numeric variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Energy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protein`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Calcium`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iron`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variable is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Food`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.3 (2015-12-10).'
  prefs: []
  type: TYPE_NORMAL
- en: Loading the `cluster()` library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore the data and understand relationships among the variables. We''ll
    begin by importing the text file named `foodstuffs.txt`. We will be saving the
    data to the `food.energycontent` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The `head()` returns the first or last parts of a vector, matrix, table, data
    frame, or function. The `food.energycontent` data frame is passed to the `head()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_03_070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `str()` function returns the provided information on the structure of the
    `food.energycontent` data frame. It compactly displays the internal structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_03_071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - transforming data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `apply()` function carries out entry-by-entry changes to data frames and
    matrices. It returns a vector, array, or list of values obtained by applying a
    function to margins of an array or matrix. 2 indicates column subscripts the function
    will be applied over. `sd` is for standard deviation function, which is to be
    applied on the data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - transforming data](img/image_03_072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sweep()` function returns an array obtained from an input array by sweeping
    out a summary statistic. `food.energycontent[,-1]` is passed as an array. 2 indicates
    column subscripts which the function will be applied over. `standard.deviation`
    is the summary statistic which is to be swept out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - transforming data](img/image_03_073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - clustering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `kmeans()` function shall carry out K-means clustering on the data matrix.
    The data matrix `foodergycnt.stddev` is passed as an object that can be coerced
    to the numeric matrix of data. `centers=5` signifies the number of initial (distinct)
    cluster centers. `iter.max=100` means the maximum number of iterations allowed.
    Since the number of clusters is denoted by a number, `nstart=25` defines the number
    of random sets to be chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - clustering](img/image_03_074.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - clustering](img/image_03_075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the clustering vector for the 4-cluster solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - clustering](img/image_03_076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we shall be printing the clusters for the 4-cluster solution in terms
    of food labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lapply()` function returns a list of the same length as X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - clustering](img/image_03_077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - visualizing the clusters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `pairs()` function, a matrix of scatterplots is produced. `food.energycontent[,-1]`
    provides the coordinates of points given as numeric columns of a matrix or data
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing the clusters](img/image_03_078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `princomp()`function performs a principal components analysis on the given
    numeric data matrix. The function produces an unrotated principal component analysis.
    `cor=T` signifies a logical value indicating that the calculation should use the
    correlation matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The `par()` function combines multiple plots into one overall graph. `s` generates
    a square plotting region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - visualizing the clusters](img/image_03_079.jpg)'
  prefs: []
  type: TYPE_IMG
