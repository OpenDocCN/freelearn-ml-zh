["```py\nfile_names = list(honey_bee_df['file'])\nprint(\"Matching image names: {}\".format(len(set(file_names).intersection(image_files)))) \n```", "```py\ndef read_image_sizes(file_name):\n    \"\"\"\n    Read images size using skimage.io\n    Args:\n        file_name: the name of the image file\n    Returns:\n        A list with images shape\n    \"\"\"\n    image = skimage.io.imread(config['image_path'] + file_name)\n    return list(image.shape) \n```", "```py\ndef read_image_sizes_cv(file_name):\n    \"\"\"\n    Read images size using OpenCV\n    Args:\n        file_name: the name of the image file\n    Returns:\n        A list with images shape\n    \"\"\"\n    image = cv2.imread(config['image_path'] + file_name)\n    return list(image.shape) \nskimage.io:\n```", "```py\n%timeit m = np.stack(subset.apply(read_image_sizes)) \n```", "```py\n%timeit m = np.stack(subset.apply(read_image_sizes_cv)) \n```", "```py\nt_start = time.time()\nm = np.stack(honey_bee_df['file'].apply(read_image_sizes_cv))\ndf = pd.DataFrame(m,columns=['w','h','c'])\nhoney_bee_df = pd.concat([honey_bee_df,df],axis=1, sort=False)\nt_end = time.time()\nprint(f\"Total processing time (using OpenCV): {round(t_end-t_start, 2)} sec.\") \n```", "```py\nTotal processing time (using OpenCV): 34.38 sec. \nboxplot. In the first, we show the image width distribution, and in the second, the image height distribution. The boxplot shows the minimum, first quartile, median, third quartile, and maximum values in the distribution of the value we plot. We also show the outliersâ€™ values as points on each of the traces:\n```", "```py\ntraceW = go.Box(\n    x = honey_bee_df['w'],\n    name=\"Width\",\n     marker=dict(\n                color='rgba(238,23,11,0.5)',\n                line=dict(\n                    color='red',\n                    width=1.2),\n            ),\n    orientation='h')\ntraceH = go.Box(\n    x = honey_bee_df['h'],\n    name=\"Height\",\n    marker=dict(\n                color='rgba(11,23,245,0.5)',\n                line=dict(\n                    color='blue',\n                    width=1.2),\n            ),\n    orientation='h')\ndata = [traceW, traceH]\nlayout = dict(title = 'Width & Heights of images',\n          xaxis = dict(title = 'Size', showticklabels=True), \n          yaxis = dict(title = 'Image dimmension'),\n          hovermode = 'closest',\n         )\nfig = dict(data=data, layout=layout)\niplot(fig, filename='width-height') \n```", "```py\nhoney_bee_df = honey_bee_df.replace({'location':'Athens, Georgia, USA'}, 'Athens, GA, USA') \n```", "```py\ntmp = honey_bee_df.groupby(['zip code'])['location'].value_counts()\ndf = pd.DataFrame(data={'Images': tmp.values}, index=tmp.index).reset_index()\ndf['code'] = df['location'].map(lambda x: x.split(',', 2)[1])\nplotly_barplot(df, 'location', 'Images', 'Tomato', 'Locations', 'Number of images', 'Number of bees images per location') \n```", "```py\ndef plotly_barplot(df, x_feature, y_feature, col, x_label, y_label, title):\n    \"\"\"\n    Plot a barplot with number of y for category x\n    Args:\n        df: dataframe\n        x_feature: x feature\n        y_feature: y feature\n        col: color for markers\n        x_label: x label\n        y_label: y label\n        title: title\n\n    Returns:\n        None\n    \"\"\"\n    trace = go.Bar(\n            x = df[x_feature],\n            y = df[y_feature],\n            marker=dict(color=col),\n            #text=df['location']\n        )\n    data = [trace]\n    layout = dict(title = title,\n              xaxis = dict(title = x_label, showticklabels=True, tickangle=15), \n              yaxis = dict(title = y_label),\n              hovermode = 'closest'\n             )\n    fig = dict(data = data, layout = layout)\n    iplot(fig, filename=f'images-{x_feature}-{y_feature}') \n```", "```py\n#list of locations\nlocations = (honey_bee_df.groupby(['location'])['location'].nunique()).index\ndef draw_category_images(var,cols=5):\n    categories = (honey_bee_df.groupby([var])[var].nunique()).index\n    f, ax = plt.subplots(nrows=len(categories),ncols=cols, figsize=(2*cols,2*len(categories)))\n    # draw a number of images for each location\nfor i, cat in enumerate(categories):\n        sample = honey_bee_df[honey_bee_df[var]==cat].sample(cols)\n        for j in range(0,cols):\n            file=config['image_path'] + sample.iloc[j]['file']\n            im=imageio.imread(file)\n            ax[i, j].imshow(im, resample=True)\n            ax[i, j].set_title(cat, fontsize=9)  \n    plt.tight_layout()\n    plt.show() \n```", "```py\nhoney_bee_df['date_time'] = pd.to_datetime(honey_bee_df['date'] + ' ' + honey_bee_df['time'])\nhoney_bee_df[\"year\"] = honey_bee_df['date_time'].dt.year\nhoney_bee_df[\"month\"] = honey_bee_df['date_time'].dt.month\nhoney_bee_df[\"day\"] = honey_bee_df['date_time'].dt.day\nhoney_bee_df[\"hour\"] = honey_bee_df['date_time'].dt.hour\nhoney_bee_df[\"minute\"] = honey_bee_df['date_time'].dt.minute \n```", "```py\ntmp = honey_bee_df.groupby(['date_time', 'hour'])['location'].value_counts()\ndf = pd.DataFrame(data={'Images': tmp.values}, index=tmp.index).reset_index() \n```", "```py\nhover_text = []\nfor index, row in df.iterrows():\n    hover_text.append(('Date/time: {}<br>'+\n                      'Hour: {}<br>'+\n                      'Location: {}<br>'+\n                      'Images: {}').format(row['date_time'],\n                                            row['hour'],\n                                            row['location'],\n                                            row['Images']))\ndf['hover_text'] = hover_text \n```", "```py\nlocations = (honey_bee_df.groupby(['location'])['location'].nunique()).index\ndata = []\nfor location in locations:\n    dfL = df[df['location']==location]\n    trace = go.Scatter(\n        x = dfL['date_time'],y = dfL['hour'],\n        name=location,\n        marker=dict(\n            symbol='circle',\n            sizemode='area',\n            sizeref=0.2,\n            size=dfL['Images'],\n            line=dict(\n                width=2\n            ),),\n        mode = \"markers\",\n        text=dfL['hover_text'],\n    )\n    data.append(trace)\n\nlayout = dict(title = 'Number of bees images per date, approx. hour and location',\n          xaxis = dict(title = 'Date', showticklabels=True), \n          yaxis = dict(title = 'Hour'),\n          hovermode = 'closest'\n         )\nfig = dict(data = data, layout = layout)\niplot(fig, filename='images-date_time') \n```", "```py\ndef draw_trace_scatter(dataset, subspecies):\n    dfS = dataset[dataset['subspecies']==subspecies];\n    trace = go.Scatter(\n        x = dfS['w'],y = dfS['h'],\n        name=subspecies,\n        mode = \"markers\",\n        marker = dict(opacity=0.8),\n        text=dfS['subspecies'], \n    )\n    return trace \n```", "```py\nsubspecies = (honey_bee_df.groupby(['subspecies'])['subspecies'].nunique()).index\ndef draw_group(dataset, title,height=600):\n    data = list()\n    for subs in subspecies:\n        data.append(draw_trace_scatter(dataset, subs))\n\n    layout = dict(title = title,\n              xaxis = dict(title = 'Width',showticklabels=True),\n              yaxis = dict(title = 'Height', showticklabels=True, tickfont=dict(\n                family='Old Standard TT, serif',\n                size=8,\n                color='black'),), \n              hovermode = 'closest',\n              showlegend=True,\n                  width=800,\n                  height=height,\n             )\n    fig = dict(data=data, layout=layout)\n    iplot(fig, filename='subspecies-image')\ndraw_group(honey_bee_df,  \"Width and height of images per subspecies\") \n```", "```py\ntmp = honey_bee_df.groupby(['location', 'zip code', 'date', 'time', 'health'])['subspecies'].value_counts()\ndf = pd.DataFrame(data={'Images': tmp.values}, index=tmp.index).reset_index()\nfig = plotly_sankey(df,cat_cols=['date', 'time', 'location', 'zip code', 'subspecies', 'health'],value_cols='Images',\n                    title='Honeybee Images: date | time | location | zip code | subspecies | health', \n                 color_palette=[ \"darkgreen\", \"lightgreen\", \"green\", \"gold\", \"black\", \"yellow\"],\n           height=800)\niplot(fig, filename='Honeybee Images') \n```", "```py\ntrain_df, test_df = train_test_split(honey_bee_df, test_size=config['test_size'], random_state=config['random_state'], \n             stratify=honey_bee_df['subspecies'])\ntrain_df, val_df = train_test_split(train_df, test_size=config['val_size'], random_state=config['random_state'], \n             stratify=train_df['subspecies']) \n```", "```py\ndef read_image(file_name):\n    \"\"\"\n    Read and resize the image to image_width x image_height\n    Args:\n        file_name: file name for current image\n    Returns:\n        resized image\n    \"\"\"\n    image = skimage.io.imread(config['image_path'] + file_name)\n    image = skimage.transform.resize(image, (config['image_width'], config['image_height']), mode='reflect')\n    return image[:,:,:config['image_channels']] \n```", "```py\ndef read_image_cv(file_name):\n    \"\"\"\n    Read and resize the image to image_width x image_height\n    Args:\n        file_name: file name for current image\n    Returns:\n        resized image\n    \"\"\"\n    image = cv2.imread(config['image_path'] + file_name)\n    image = cv2.resize(image, (config['image_width'], config['image_height']))\n    return image[:,:,:config['image_channels']] \n```", "```py\ndef categories_encoder(dataset, var='subspecies'):\n    X = np.stack(dataset['file'].apply(read_image))\n    y = pd.get_dummies(dataset[var], drop_first=False)\n    return X, y\ns_time = time.time()\nX_train, y_train = categories_encoder(train_df)\nX_val, y_val = categories_encoder(val_df)\nX_test, y_test = categories_encoder(test_df)\ne_time = time.time()\nprint(f\"Total time: {round(e_time-s_time, 2)} sec.\") \n```", "```py\nimage_generator = ImageDataGenerator(\n        featurewise_center=False,\n        samplewise_center=False,\n        featurewise_std_normalization=False,\n        samplewise_std_normalization=False,\n        zca_whitening=False,\n        rotation_range=180,\n        zoom_range = 0.1, \n        width_shift_range=0.1,\n        height_shift_range=0.1, \n        horizontal_flip=True,\n        vertical_flip=True)\nimage_generator.fit(X_train) \n```", "```py\nmodel1=Sequential()\nmodel1.add(Conv2D(config['conv_2d_dim_1'], \n                  kernel_size=config['kernel_size'], \n                  input_shape=(config['image_width'], config['image_height'],config['image_channels']), \n                  activation='relu', padding='same'))\nmodel1.add(MaxPool2D(config['max_pool_dim']))\nmodel1.add(Conv2D(config['conv_2d_dim_2'],  kernel_size=config['kernel_size'],\n                  activation='relu', padding='same'))\nmodel1.add(Flatten())\nmodel1.add(Dense(y_train.columns.size, activation='softmax'))\nmodel1.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy']) \n```", "```py\ntrain_model1  = model1.fit_generator(image_generator.flow(X_train, y_train, batch_size=config['batch_size']),\n                        epochs=config['no_epochs_1'],\n                        validation_data=[X_val, y_val],\n                        steps_per_epoch=len(X_train)/config['batch_size']) \n```", "```py\nscore = model1.evaluate(X_test, y_test, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1]) \n```", "```py\ndef test_accuracy_report(model):\n    predicted = model.predict(X_test)\n    test_predicted = np.argmax(predicted, axis=1)\n    test_truth = np.argmax(y_test.values, axis=1)\n    print(metrics.classification_report(test_truth, test_predicted, target_names=y_test.columns)) \n    test_res = model.evaluate(X_test, y_test.values, verbose=0)\n    print('Loss function: %s, accuracy:' % test_res[0], test_res[1]) \n```", "```py\nannealer3 = LearningRateScheduler(lambda x: 1e-3 * 0.995 ** (x+config['no_epochs_3']))\nearlystopper3 = EarlyStopping(monitor='loss', patience=config['patience'], verbose=config['verbose'])\ncheckpointer3 = ModelCheckpoint('best_model_3.h5',\n                                monitor='val_accuracy',\n                                verbose=config['verbose'],\n                                save_best_only=True,\n                                save_weights_only=True) \n```", "```py\ntrain_model3  = model3.fit_generator(image_generator.flow(X_train, y_train, batch_size=config['batch_size']),\n                        epochs=config['no_epochs_3'],\n                        validation_data=[X_val, y_val],\n                        steps_per_epoch=len(X_train)/config['batch_size'],\n                        callbacks=[earlystopper3, checkpointer3, annealer3]) \n```"]