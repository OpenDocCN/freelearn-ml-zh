<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Traditional Object-Oriented Patterns</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>By now, we have already learned about the many design patterns that we need to know in order to be an effective Julia programmer. The cases presented in the previous chapters included various problems that we can solve by writing <em>idiomatic</em> Julia code. Some might ask, after all these years, I have learned and adapted to the <strong>object-oriented programming</strong> (<strong>OOP</strong>) paradigm; how do I apply the same concepts in Julia? The general answer is, you won't solve the problem the same way. The solution written in Julia will look different, reflecting a different programming paradigm. Nevertheless, it is still an interesting exercise to think about how to adopt some of the OOP techniques in Julia.</span></p>
<p class="mce-root"><span>In this chapter, we will cover all 23 design patterns from the classic <strong>Gang of Four</strong> (<strong>GoF</strong>) <em>Design Patterns</em> book. We will keep the tradition and organize the topics in the following sections:</span></p>
<ul>
<li>Creational patterns</li>
<li>Behavioral patterns</li>
<li>Structural patterns</li>
</ul>
<p>By the end of this chapter, you will have an idea of how each of these patterns may be applied in Julia, as compared to an OOP approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter11">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter11</a>.</p>
<p>The code is tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creational patterns</h1>
                </header>
            
            <article>
                
<p><strong>Creational</strong> patterns refer to the various ways of constructing and instantiating objects. Since OOP groups data and behavior together, and since a class may inherit the structure and behavior from an ancestor class, there are additional levels of complexity involved when building a large-scale system. By design, Julia has already gotten rid of many issues by not allowing fields to be declared in abstract types and not allowing creating new subtypes from concrete types. Nevertheless, some of these patterns could be helpful in certain situations.</p>
<p>The creational patterns include the factory method, abstract factory, singleton, builder, and prototype patterns. We shall discuss them in detail in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The factory method pattern</h1>
                </header>
            
            <article>
                
<p>The idea of the <strong>factory method</strong> pattern is to p<span>rovide a single interface to create different types of objects that conform to an interface while hiding the actual implementation from the client. This abstraction decouples the client from the underlying implementation of the feature provider.</span></p>
<p><span>For example, a program might need to format some numbers in the output. In Julia, we might want to use the <kbd>Printf</kbd> package to format numbers, as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/164d6264-cef6-4276-9c1a-54d6e23f4a19.png" style="width:20.25em;height:8.67em;"/></p>
<p>Perhaps we do not want to couple with the <kbd>Printf</kbd> package because we want to switch and use a different formatting package in the future. In order to make the application more flexible, we can design an interface where numbers can be formatted according to their types. The following interface is described in the doc string:</p>
<pre>"""<br/> format(::Formatter, x::T) where {T &lt;: Number}<br/><br/>Format a number `x` using the specified formatter.<br/>Returns a string.<br/>"""<br/>function format end</pre>
<p>The <kbd>format</kbd> function takes a <kbd>formatter</kbd> and a numeric value, <kbd>x</kbd>, and returns a formatted string. The <kbd>Formatter</kbd> type is defined as follows:</p>
<pre>abstract type Formatter end<br/>struct IntegerFormatter &lt;: Formatter end<br/>struct FloatFormatter &lt;: Formatter end</pre>
<p>Then, the factory methods basically create singleton types for dispatch purposes:</p>
<pre>formatter(::Type{T}) where {T &lt;: Integer} = IntegerFormatter()<br/>formatter(::Type{T}) where {T &lt;: AbstractFloat} = FloatFormatter()<br/>formatter(::Type{T}) where T = error("No formatter defined for type $T")</pre>
<p>The default implementation may look like the following, utilizing the <kbd>Printf</kbd> package:</p>
<pre>using Printf<br/>format(nf::IntegerFormatter, x) = @sprintf("%d", x)<br/>format(nf::FloatFormatter, x) = @sprintf("%.2f", x)</pre>
<p>Putting everything in a <kbd>FactoryExample</kbd> module, we can run the following testing code:</p>
<pre>function test()<br/>    nf = formatter(Int)<br/>    println(format(nf, 1234))<br/>    nf = formatter(Float64)<br/>    println(format(nf, 1234))<br/>end</pre>
<p>The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8eadb69d-fa16-4659-81a7-1372fd4fe911.png" style="width:16.50em;height:3.92em;"/></p>
<p>Should we ever want to change the formatter in the future, we just need to provide a new implementation with format functions defined for the numeric types that we want to support. This is handy when we have a lot of number-formatting code lying around. The switch to a different formatter involves literally two lines of code changes (in this example).</p>
<p>Let's look at the abstract factory pattern next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The abstract factory pattern</h1>
                </header>
            
            <article>
                
<p><span>The <strong>abstract factory</strong> pattern is used for creating objects via a set of factory methods, which are abstracted away from the concrete implementation. The abstract factory pattern can be viewed as a factory of factories.</span></p>
<p>We can explore the example of building a multiplatform GUI library that supports Microsoft Windows and macOS. As we want to develop code that is cross-platform, we can leverage this design pattern. This design is described in the following UML diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b9e33f83-3b44-4b67-9eca-0e1b6290dd37.png" style="width:68.92em;height:38.92em;"/></p>
<p>In a nutshell, we have presented two types of GUI objects here: <kbd>Button</kbd> and <kbd>Label</kbd>. The concept is the same for both Microsoft Windows and macOS platforms. The client does not care how these objects are instantiated; instead, it asks an abstract factory <kbd>GUIFactory</kbd> to return factories (either <kbd>MacOSFactory</kbd> or <kbd>WindowsFactory</kbd>) that support multiple factory methods for creating platform-dependent GUI objects.</p>
<p>The Julia implementation can simply be modeled with the appropriate abstract and concrete types. Let's start at the OS level:</p>
<pre>abstract type OS end<br/>struct MacOS &lt;: OS end<br/>struct Windows &lt;: OS end</pre>
<p>We intended to use <kbd>MacOS</kbd> and <kbd>Windows</kbd> as singleton types for dispatch purposes later. For now, let's continue and define the abstract types <kbd>Button</kbd> and <kbd>Label</kbd> as follows. Additionally, we have defined <kbd>show</kbd> methods for each type respectively:</p>
<pre>abstract type Button end<br/>Base.show(io::IO, x::Button) = <br/>    print(io, "'$(x.text)' button")<br/><br/>abstract type Label end<br/>Base.show(io::IO, x::Label) = <br/>    print(io, "'$(x.text)' label")</pre>
<p>We do need to provide concrete implementation for these GUI objects. Let's define them now:</p>
<pre># Buttons<br/>struct MacOSButton &lt;: Button<br/>    text::String<br/>end<br/><br/>struct WindowsButton &lt;: Button<br/>    text::String<br/>end<br/><br/># Labels<br/>struct MacOSLabel &lt;: Label<br/>    text::String<br/>end<br/><br/>struct WindowsLabel &lt;: Label<br/>    text::String<br/>end</pre>
<p><span>For the sake of simplicity, we just hold on to a text string, whether it's a button or a label. As factory methods are platform-dependent, we can leverage the OS trait and multiple dispatch to call the right <kbd>make_button</kbd> or <kbd>make_label</kbd> functions:</span></p>
<pre># Generic implementation using traits<br/>current_os() = MacOS() # should get from system<br/>make_button(text::String) = make_button(current_os(), text)<br/>make_label(text::String) = make_label(current_os(), text)</pre>
<p>For testing, we have hardcoded the <kbd>current_os</kbd> function to return <kbd>MacOS()</kbd>. In reality, this function should return either <kbd>MacOS()</kbd> or <kbd>Windows()</kbd> by examining whatever system variable is appropriate to identify the platform. Finally, we need to implement the specific functions for each platform as follows:</p>
<pre># MacOS implementation<br/>make_button(::MacOS, text::String) = MacOSButton(text)<br/>make_label(::MacOS, text::String) = MacOSLabel(text)<br/><br/># Windows implementation<br/>make_button(::Windows, text::String) = WindowsButton(text)<br/>make_label(::Windows, text::String) = WindowsLabel(text)</pre>
<p>Our simple test just involves calling the <kbd>make_button</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c6f09e64-b683-4b9e-a297-21f9303a31f0.png" style="width:23.17em;height:2.67em;"/></p>
<p>Using multiple dispatch, we can easily extend to new platforms or new GUI objects by simply defining new functions for the specific OS.</p>
<p>Next, we will look into the singleton pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The singleton pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>singleton</strong> pattern is used to create a single instance of an object and reuse it from anywhere. A singleton object is typically constructed when the application starts, or it can be created lazily on the first use of the object. An interesting requirement for the singleton pattern arises for multithreaded applications because the instantiation of the singleton object must happen only once. It can be a challenge if the object creation function is called lazily from many threads.</p>
<p><span>Suppose that we want to create a singleton called <kbd>AppKey</kbd> that is used for encryption in the application:</span></p>
<pre># AppKey contains an app id and encryption key<br/>struct AppKey<br/>    appid::String<br/>    value::UInt128<br/>end</pre>
<p><span>Initially, we may be tempted to use a global variable. Given that we have learned about the performance impact of global variables, we can apply the global constant pattern that we learned in <a href="c8cedc0d-716d-46c4-8768-ae0084a10bf9.xhtml">Chapter 6</a>, <em>Performance Patterns</em>. Essentially, a <kbd>Ref</kbd> object is created as a placeholder, as follows:</span></p>
<pre># placeholder for AppKey object. <br/>const appkey = Ref{AppKey}()</pre>
<p>The <kbd>appkey</kbd> global constant is first created without being assigned with any value, but then it can be updated when the singleton is instantiated. The construction of singleton can be done as follows:</p>
<pre>function construct()<br/>    global appkey<br/>    if !isassigned(appkey)<br/>        ak = AppKey("myapp", rand(UInt128))<br/>        println("constructing $ak")<br/>        appkey[] = ak<br/>    end<br/>    return nothing<br/>end</pre>
<p>This code works fine as long as there is a single thread. If we test it with multiple threads, then the <kbd>isassigned</kbd> check is problematic. For example, two threads might check whether the key is assigned at the same time, and both threads might think that the singleton object needs to be instantiated. In this case, we end up constructing the singleton twice.</p>
<p>The testing code is shown as follows:</p>
<pre>function test_multithreading()<br/>    println("Number of threads: ", Threads.nthreads())<br/>    global appkey<br/>    Threads.@threads for i in 1:8<br/>        construct()<br/>    end<br/>end</pre>
<p>We can demonstrate the problem below. Let's start the Julia REPL with four threads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/491e40c8-86df-42c0-88c7-40e95b266b74.png" style="width:27.67em;height:9.67em;"/></p>
<p>Then, we can run the testing code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe8831ec-3da2-423c-8be6-ebc6d3e51e95.png" style="width:30.50em;height:6.17em;"/></p>
<p>As you can see, the singleton being constructed twice here.</p>
<p>So how do we solve this problem? We can use a lock to synchronize the singleton construction logic. Let's first create another global <span>constant </span>to hold the lock:</p>
<pre>const appkey_lock = Ref(ReentrantLock())</pre>
<p>To use the lock, we can modify the <kbd>construct</kbd> function as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9d29c23e-2456-47fb-82f8-8f8c5a9f5cee.png" style="width:27.58em;height:20.33em;"/></p>
<p><span>We</span> must first <span>acquire the lock before</span> checking whether <kbd>appkey[]</kbd> is already assigned. When we are done constructing the singleton (or skipping it, if it has already been created), we release the lock. Note that we have wrapped the critical section of the code in a <kbd>try</kbd> block, and we placed the <kbd>unlock</kbd> function in the <kbd>finally</kbd> block. This is done to ensure that the lock is released regardless of whether the construction of the singleton is successful or not.</p>
<p>Our new test shows that the singleton is constructed only once:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b1ac22bd-96d0-46b2-afa1-2aa38cef4392.png" style="width:28.25em;height:8.92em;"/></p>
<p>The singleton pattern is useful when we need to hold on to a single object. Practical use cases include database connections or other references to external resources. Next, we will take a look at the builder pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The builder pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>builder</strong> pattern is used to build a complex object by incrementally building simpler parts of it. We can imagine that a factory assembly line would work in a similar fashion. In that case, a product is assembled step-by-step with more and more parts, and at the end of the assembly line, the product is finished and ready to go.</p>
<p>One benefit of this pattern is that the builder code looks like a linear data flow and is easier for some people to read. In Julia, we may want to write something like this:</p>
<pre>car = Car() |&gt;<br/>    add(Engine("4-cylinder 1600cc Engine")) |&gt;<br/>    add(Wheels("4x 20-inch wide wheels")) |&gt;<br/>    add(Chassis("Roadster Chassis"))</pre>
<p>Essentially, this is the exact <span>functional pipe pattern </span><span>described in</span> <a href="6682bca1-9221-46fa-84f2-f5379fd4d01b.xhtml">Chapter 9</a><span>,</span> <em>Miscellaneous Patterns</em><span>. For this example, we can develop higher-order functions for building each part (such as the wheels, engine, and chassis). The following code illustrates how to create a curry (higher-order) function for creating wheels:</span></p>
<pre>function add(wheels::Wheels)<br/>    return function (c::Car)<br/>        c.wheels = wheels<br/>        return c<br/>    end<br/>end</pre>
<p>The <kbd>add</kbd> function just returns an anonymous function that takes a <kbd>Car</kbd> object as input and returns an enhanced <kbd>Car</kbd> object. Likewise, we can develop similar functions for the <kbd>Engine</kbd> and <kbd>Chassis</kbd> types. Once these functions are ready, we can build a car by simply chaining these function calls together.</p>
<p>Next, we will discuss the prototype pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The prototype pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>prototype</strong> pattern is used to create new objects <span>by cloning fields from an existing object, or the prototype object. The idea is that some objects are difficult or time-consuming to construct, so it would be useful to make a copy of the object and call it a new one by making small modifications.</span></p>
<p>As Julia keeps data and logic separate, making copies of objects is really the same as duplicating the content. That sounds easy, but we should not overlook the difference between a shallow copy and a deep copy.</p>
<p>A <strong>shallow copy</strong> of an object is merely an object with all the fields copied from another object. A <strong>deep copy</strong> of an object is created by recursively going into the fields of the object and copying their underlying fields as well. As such, a shallow copy may not be desirable because some data can be shared with the original object.</p>
<p>To illustrate this, let's consider the following struct definitions for a bank account example:</p>
<pre>mutable struct Account<br/>    id::Int<br/>    balance::Float64<br/>end<br/><br/>struct Customer<br/>    name::String<br/>    savingsAccount::Account<br/>    checkingAccount::Account<br/>end</pre>
<p>Now, suppose that we have an array of <kbd>Customer</kbd> objects that are returned from this function:</p>
<pre>function sample_customers()<br/>    a1 = Account(1, 100.0)<br/>    a2 = Account(2, 200.0)<br/>    c1 = Customer("John Doe", a1, a2)<br/>    <br/>    a3 = Account(3, 300.0)<br/>    a4 = Account(4, 400.0)<br/>    c2 = Customer("Brandon King", a3, a4)<br/><br/>    return [c1, c2]<br/>end</pre>
<p>The <kbd>sample_customer</kbd> function returns an array of two customers. For testing purposes, let's build a test harness to update the balance for the first customer as follows:</p>
<pre>function test(copy_function::Function)<br/>    println("--- testing ", string(copy_function), " ---")<br/>    customers = sample_customers()<br/>    c = copy_function(customers)<br/>    c[1].checkingAccount.balance += 500<br/>    println("orig: ", customers[1].checkingAccount.balance)<br/>    println("new: ", c[1].checkingAccount.balance)<br/>end</pre>
<p>If we exercise the test harness with built-in <kbd>copy</kbd> and <kbd>deepcopy</kbd> functions, we get the following results:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/736a8fe8-a14f-4f8a-a7a6-32972342531a.png" style="width:19.58em;height:9.33em;"/></p>
<p>Unexpectedly, we got the wrong result in the <kbd>orig</kbd> output since we should be adding $500 to the new customer. Why do we have the same balance for both the original customer record and the new customer record instead? This is because a shallow copy was made from the customer array when the <kbd>copy</kbd> function was used. When this happens, the customer records are essentially shared between the original array and the new array. This means that mutating the new record also affected the original record.</p>
<p>In the second part of the result, only the new copy of the customer record was changed. This is because the <kbd>deepcopy</kbd> function was used. By definition, the prototype pattern requires making changes to the copy. It is probably safer to make a deep copy should this pattern be applied.</p>
<p>We have covered all five creational patterns. These patterns allow us to build new objects in an effective manner.</p>
<p>Next, we're going to cover a set of behavioral design patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Behavioral patterns</h1>
                </header>
            
            <article>
                
<p><span><strong>Behavioral</strong> patterns </span>refer to how objects are designed to collaborate and communicate with each other. There are 11 GoF patterns from the OOP paradigm. We will cover all of them here with some interesting hands-on examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The chain-of-responsibility pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>chain-of-responsibility</strong> (<strong>CoR</strong>) pattern is used to process the request using a chain of request handlers, whereas each handler has its own distinct and independent responsibility.</p>
<p>This pattern is quite common in many applications. For example, web servers usually handle HTTP requests using so-called middleware. Each piece of middleware is responsible for performing a specific task—for example, authenticating requests, maintaining cookies, validating requests, and performing business logic. A specific requirement about the CoR pattern is that any part of the chain can be broken at any time, resulting in an early exit of the process. In the preceding web server example, the authentication middleware may have decided that the user has not been authenticated, and that therefore, the user should be redirected to a separate website for login. This means that the rest of the middleware is skipped unless the user gets past the authentication step.</p>
<p>How do we design something like this in Julia? Let's look at a simple example:</p>
<pre>mutable struct DepositRequest<br/>    id::Int<br/>    amount::Float64<br/>end</pre>
<p>A <kbd>DepositRequest</kbd> object contains an amount that a customer wants to deposit in their account. Our marketing department wants us to provide a thank-you note to the customer if the deposit amount is greater than $100,000. To process such a request, we have designed three functions, as follows:</p>
<pre>@enum Status CONTINUE HANDLED<br/><br/>function update_account_handler(req::DepositRequest) <br/>    println("Deposited $(req.amount) to account $(req.id)")<br/>    return CONTINUE<br/>end<br/><br/>function send_gift_handler(req::DepositRequest)<br/>    req.amount &gt; 100_000 &amp;&amp; <br/>        println("=&gt; Thank you for your business")<br/>    return CONTINUE<br/>end<br/><br/>function notify_customer(req::DepositRequest)<br/>    println("deposit is finished")<br/>    return HANDLED<br/>end</pre>
<p>What is the responsibility of these functions?</p>
<ul>
<li>The <kbd>update_account_handler</kbd> function is responsible for updating the account with the new deposit.</li>
<li>The <kbd>send_gift_handler</kbd> <span>function </span>is responsible for sending a thank-you note to the customer for a large deposit amount.</li>
<li>The <kbd>notify_customer</kbd> function is responsible for informing the customer after the deposit is made.</li>
</ul>
<p><span>These functions also return an enum value, either </span><kbd>CONTINUE</kbd><span> or </span><kbd>HANDLED</kbd><span>, to indicate whether the request should be passed on to the next handler when the current one is finished.</span></p>
<p>It should be quite clear that these functions run in a specific order. In particular, the <kbd>notify_customer</kbd> function should run at the end of the transaction. For that reason, we can establish an array of functions:</p>
<pre>handlers = [<br/>    update_account_handler, <br/>    send_gift_handler,<br/>    notify_customer<br/>]</pre>
<p>We can also have a function to execute these handlers in order:</p>
<pre>function apply(req::DepositRequest, handlers::AbstractVector{Function})<br/>    for f in handlers<br/>        status = f(req)<br/>        status == HANDLED &amp;&amp; return nothing<br/>    end<br/>end</pre>
<p>As part of this design, the loop will end immediately if any handler returns a value of <kbd>HANDLED</kbd>. Our test code for testing the function of sending the thank-you note to a premier customer is shown as follows:</p>
<pre>function test()<br/>    println("Test: customer depositing a lot of money")<br/>    amount = 300_000<br/>    apply(DepositRequest(1, amount), handlers)<br/><br/>    println("\nTest: regular customer")<br/>    amount = 1000<br/>    apply(DepositRequest(2, amount), handlers)<br/>end</pre>
<p>Running the test gives us this result:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5d1b30b8-f33a-43ad-a73c-f416ea37ba4e.png" style="width:21.08em;height:8.92em;"/></p>
<p>I will leave it as an exercise for you to build another function in this chain to perform an early exit. But for now, let's move on to the next pattern—the mediator pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The mediator pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>mediator</strong> pattern is used to facilitate communication between different components in an application. This is done in such a way that individual components are decoupled from each other. In most applications, changes in one component can affect another. Sometimes, there are also cascading effects. A mediator can take the responsibility of getting notified when one component is changed, and it can notify other components about the event so that further downstream updates can be made.</p>
<p>As an example, we can consider the use case of a <strong>graphical user interface</strong> (<strong>GUI</strong>). Suppose that we have a screen that contains three fields for our favorite banking application:</p>
<ul>
<li><strong>Amount</strong>: Current balance in the account.</li>
<li><strong>Interest Rate</strong>: Current interest rate expressed as a percentage.</li>
<li><strong>Interest Amount</strong>: Interest amount. This is a read-only field.</li>
</ul>
<p>How do they interact with each other? If the amount is changed, then the interest amount needs to be updated. Likewise, if the interest rate is changed, then the interest amount needs to be updated as well.</p>
<p>To model the GUI, we can define the following types for the individual GUI objects onscreen:</p>
<pre>abstract type Widget end<br/><br/>mutable struct TextField &lt;: Widget<br/>    id::Symbol<br/>    value::String<br/>end</pre>
<p>The <kbd>Widget</kbd> is an abstract type and it can be used as the supertype for all GUI objects. This application only needs text fields, so we just define a <kbd>TextField</kbd> widget. A text field is identified by an <kbd>id</kbd>, and it contains a <kbd>value</kbd>. In order to extract and update the value in the text field widget, we can define functions as follows:</p>
<pre># extract numeric value from a text field<br/>get_number(t::TextField) = parse(Float64, t.value)<br/><br/># set text field from a numeric value<br/>function set_number(t::TextField, x::Real)<br/>    println("* ", t.id, " is being updated to ", x)<br/>    t.value = string(x)<br/>    return nothing<br/>end</pre>
<p>From the preceding code, we can see that the <kbd>get_number</kbd> function gets the value from the text field widget and returns it as a floating-point number. The <kbd>set_number</kbd> function populates the text field widget with the provided numeric value. Now, we also need to create the application, so we conveniently define a struct as follows:</p>
<pre>Base.@kwdef struct App<br/>    amount_field::TextField<br/>    interest_rate_field::TextField<br/>    interest_amount_field::TextField<br/>end</pre>
<p>For this example, we will implement a <kbd>notify</kbd> function to simulate an event that is sent to the text field widget after the user enters a value. In reality, the GUI platform typically performs that function. Let's call it <kbd>on_change_event</kbd>, as follows:</p>
<pre>function on_change_event(widget::Widget)<br/>    notify(app, widget)<br/>end</pre>
<p><span>The <kbd>on_change_event</kbd> function does nothing else but communicate to the mediator (the app) that something has just happened to this widget. As for the app itself, here's how it handles the notification:</span></p>
<pre># Mediator logic - handling changes to the widget in this app<br/>function notify(app::App, widget::Widget)<br/>    if widget in (app.amount_field, app.interest_rate_field)<br/>        new_interest = get_number(app.amount_field) * get_number(app.interest_rate_field)/100<br/>        set_number(app.interest_amount_field, new_interest)<br/>    end<br/>end</pre>
<p>As you can see, it simply checks whether the widget that is being updated is either the Amount or Interest Rate field. If so, it calculates a new interest amount and populates the Interest Amount field with the new value. Let's do a quick test:</p>
<pre>function test()<br/>    # Show current state before testing<br/>    print_current_state()<br/><br/>    # double principal amount from 100 to 200<br/>    set_number(app.amount_field, 200)<br/>    on_change_event(app.amount_field)<br/>    print_current_state()<br/>end</pre>
<p>The <kbd>test</kbd> function displays the initial state of the application, updates the amount field, and displays the new state. For the sake of brevity, the source code for the <kbd>print_current_state</kbd> function is not shown here, but is available on the book's GitHub site. The output of the test program is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a1a05a91-0844-43d8-980b-b0e034b98f79.png" style="width:26.75em;height:14.75em;"/></p>
<p>The benefit of using the 2 mediator pattern is that every object can focus on its own responsibility and not worry about the downstream impact. A central mediator takes on the responsibility of organizing activities and handling events and communications.</p>
<p>Next, we shall look at the memento pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The memento pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>memento</strong> pattern is a state management technique that you can use to restore your work to a previous state when needed. A common example is the Undo function of a word processor application. After making 10 changes, we can always undo the prior operations and return to the original state before those 10 changes were made. Similarly, an application may remember the most recently opened files and provide a menu of choices so that the user can quickly reopen a previously opened file.</p>
<p>Implementing the memento pattern in Julia is quite simple. We can just store previous states in an array and when making a change, we can push the new state to the array. When we want to undo our actions, we restore the previous state by popping from the array. To illustrate this idea, let's consider the case of a blog post-editing application. We can define the data types as follows:</p>
<pre>struct Post<br/>    title::String<br/>    content::String<br/>end<br/><br/>struct Blog<br/>    author::String<br/>    posts::Vector{Post}<br/>    date_created::DateTime<br/>end</pre>
<p>As you can see, a <kbd>Blog</kbd> object contains an array of <kbd>Post</kbd> objects. By convention, the last element in the array is the current version of the blog post. If there were five posts in the array, then it means that four changes have been made so far. Creating a new blog is as easy, as shown in the following code:</p>
<pre>function Blog(author::String, post::Post)<br/>    return Blog(author, [post], now())<br/>end</pre>
<p>By default, a new blog object contains just one version. As the user makes changes, the array will grow. For convenience, we can provide a <kbd>version_count</kbd> function that returns the number of revisions that the user has made so far.</p>
<pre>version_count(blog::Blog) = length(blog.posts)</pre>
<p>To obtain the current post, we can simply take the last element of the array:</p>
<pre>current_post(blog::Blog) = blog.posts[end]</pre>
<p>Now, when we have to update the blog, we must push the new version to the array. Here is the function that we use to update the blog with a new title or content:</p>
<pre>function update!(blog::Blog; <br/>                 title = nothing, <br/>                 content = nothing)<br/>    post = current_post(blog)<br/>    new_post = Post(<br/>        something(title, post.title),<br/>        something(content, post.content)<br/>    )<br/>    push!(blog.posts, new_post)<br/>    return new_post<br/>end</pre>
<p>The <kbd>update!</kbd> function takes a <kbd>Blog</kbd> object, and optionally it can take either an updated <kbd>title</kbd>, <kbd>content</kbd>, or both. Basically, it creates a new <kbd>Post</kbd> object and pushes it into the <kbd>posts</kbd> array. Undoing is done as follows:</p>
<pre>function undo!(blog::Blog)<br/>    if version_count(blog) &gt; 1<br/>        pop!(blog.posts)<br/>        return current_post(blog)<br/>    else<br/>        error("Cannot undo... no more previous history.")<br/>    end<br/>end</pre>
<p>We can test it with the following <kbd>test</kbd> function:</p>
<pre>function test()<br/>    blog = Blog("Tom", Post("Why is Julia so great?", "Blah blah."))<br/>    update!(blog, content = "The reasons are...")<br/><br/>    println("Number of versions: ", version_count(blog))<br/>    println("Current post")<br/>    println(current_post(blog))<br/>    <br/>    println("Undo #1")<br/>    undo!(blog)<br/>    println(current_post(blog))<br/><br/>    println("Undo #2") # expect failure<br/>    undo!(blog)<br/>    println(current_post(blog))<br/>end</pre>
<p>The output is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e64c8f77-35a7-4be7-bef1-698e54eef529.png" style="width:29.83em;height:9.50em;"/></p>
<p>As you can see, it is quite easy to implement the memento pattern. We will cover the observer pattern next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The observer pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>observer</strong> pattern is useful for registering observers to an object so that all state changes in that object trigger the sending of notifications to the observers. In a language that supports first-class functions—for example, Julia—such functionality can be implemented easily by maintaining a list of functions that can be called before or after the state changes of an object. Sometimes, these functions are called <strong>hooks</strong>.</p>
<p class="mce-root"/>
<p>The implementation of the observer pattern in Julia may consist of two parts:</p>
<ol>
<li>Extend the <kbd>setproperty!</kbd> function of an object to monitor state changes and notify observers.</li>
<li>Maintain a dictionary that can be used to look up the functions to call.</li>
</ol>
<p>For this demonstration, we will bring up the bank account example again:</p>
<pre>mutable struct Account<br/>    id::Int<br/>    customer::String<br/>    balance::Float64<br/>end</pre>
<p>Here is the data structure for maintaining observers:</p>
<pre>const OBSERVERS = IdDict{Account,Vector{Function}}();</pre>
<p>Here, we have chosen to use <kbd>IdDict</kbd> instead of the regular <kbd>Dict</kbd> object. <kbd>IdDict</kbd> is a special type that uses Julia's internal object ID as the key of the dictionary. To register observers, we provide the following function:</p>
<pre>function register(a::Account, f::Function)<br/>    fs = get!(OBSERVERS, a, Function[])<br/>    println("Account $(a.id): registered observer function $(Symbol(f))")<br/>    push!(fs, f)<br/>end</pre>
<p>Now, let's extend the <kbd>setproperty!</kbd> function:</p>
<pre>function Base.setproperty!(a::Account, field::Symbol, value)<br/>    previous_value = getfield(a, field)<br/>    setfield!(a, field, value)<br/>    fs = get!(OBSERVERS, a, Function[])<br/>    foreach(f -&gt; f(a, field, previous_value, value), fs)<br/>end</pre>
<p>This new <kbd>setproperty!</kbd> function not only updates the field for the object, but also calls the observer functions with both the previous state and the current state after the field has been updated. For testing purposes, we will create an observer function as follows:</p>
<pre>function test_observer_func(a::Account, field::Symbol, previous_value, current_value)<br/>    println("Account $(a.id): $field was changed from $previous_value to $current_value")<br/>end</pre>
<p>Our <kbd>test</kbd> function is written as follows:</p>
<pre>function test()<br/>    a1 = Account(1, "John Doe", 100.00)<br/>    register(a1, test_observer_func)<br/>    a1.balance += 10.00<br/>    a1.customer = "John Doe Jr."<br/>    return nothing<br/>end</pre>
<p>When running the test program, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/479fc6b7-8505-4e00-a245-3fa245d02132.png" style="width:36.25em;height:5.25em;"/></p>
<p>From the output, we can see that the <kbd>test_observer_func</kbd> function was called every time a property is updated. The observer pattern is an easy thing to develop. Next, we will look at the state pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The state pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>state</strong> pattern is used in situations where an object behaves differently depending on its internal state. A networking service is a great example. A typical implementation for a network-based service is to listen to a specific port number. When a remote process connects to the service, it establishes a connection, and they use it to communicate with each other until the end of the session. When a network service is currently in a listening state, it should allow a new connection to be opened; however, no data transmission should be allowed until after the connection is opened. Then, after the connection is opened, we should be able to send data. By contrast, we should not allow any data to be sent through the network connection if the connection is already closed.</p>
<p>In Julia, we can possibly implement the state pattern using multiple dispatch. Let's first define the following types that are meaningful for network connections:</p>
<pre>abstract type AbstractState end<br/><br/>struct ListeningState &lt;: AbstractState end<br/>struct EstablishedState &lt;: AbstractState end<br/>struct ClosedState &lt;: AbstractState end<br/><br/>const LISTENING = ListeningState()<br/>const ESTABLISHED = EstablishedState()<br/>const CLOSED = ClosedState()</pre>
<p>Here, we have leveraged the singleton type pattern. As for the network connection itself, we can define the type as follows:</p>
<pre>struct Connection{T &lt;: AbstractState,S}<br/>    state::T<br/>    conn::S<br/>end</pre>
<p>Now, let's develop a <kbd>send</kbd> function, which is used to send a message via a connection. In our implementation, the <kbd>send</kbd> function does not do anything else except gather the current state of the connection and forward the call to a state-specific <kbd>send</kbd> function:</p>
<pre># Use multiple dispatch <br/>send(c::Connection, msg) = send(c.state, c.conn, msg)<br/><br/># Implement `send` method for each state<br/>send(::ListeningState, conn, msg) = error("No connection yet")<br/>send(::EstablishedState, conn, msg) = write(conn, msg * "\n")<br/>send(::ClosedState, conn, msg) = error("Connection already closed")</pre>
<p>You may recognize this as the Holy Trait pattern. For unit testing, we can develop a <kbd>test</kbd> function for creating a new <kbd>Connection</kbd> with the specified message and sending a message to the <kbd>Connection</kbd> object:</p>
<pre>function test(state, msg)<br/>    c = Connection(state, stdout)<br/>    try <br/>        send(c, msg)<br/>    catch ex<br/>        println("$(ex) for message '$msg'")<br/>    end<br/>    return nothing<br/>end</pre>
<p>Then, the testing code simply runs the <kbd>test</kbd> function three times, once for each possible state:</p>
<pre>function test()<br/>    test(LISTENING, "hello world 1")<br/>    test(CLOSED, "hello world 2")<br/>    test(ESTABLISHED, "hello world 3")<br/>end</pre>
<p>When running the <kbd>test</kbd> function, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ee36e51a-a962-4c80-8f2a-5d9702d14489.png" style="width:40.08em;height:4.50em;"/></p>
<p>Only the third message was sent successfully, because the connection was in the <kbd>ESTABLISHED</kbd> state. Now, let's take a look at the strategy pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The strategy pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>strategy</strong> pattern enables clients to select the best algorithm to use at runtime. Instead of coupling the client with predefined algorithms, the client can be configured with a specific algorithm (strategy) when necessary. In addition, sometimes the choice of algorithm cannot be determined ahead of time because the decision may depend on the input data, the environment, or something else.</p>
<p>In Julia, we can solve the problem using multiple dispatch. Let's consider the case of a Fibonacci sequence generator. As we learned from <a href="c8cedc0d-716d-46c4-8768-ae0084a10bf9.xhtml">Chapter 6</a>, <em>Performance Patterns</em>, the calculation of the <em>n</em><sup>th</sup> Fibonacci number can be tricky when we implement it recursively, so our first algorithm (strategy) may be memoization. In addition, we can also solve the same problem using an iterative algorithm without using any recursion. </p>
<p>In order to support both memoization and iterative algorithms, let's create some new types as follows:</p>
<pre>abstract type Algo end<br/>struct Memoized &lt;: Algo end<br/>struct Iterative &lt;: Algo end</pre>
<p>The <kbd>Algo</kbd> abstract type is the supertype for all Fibonacci algorithms. At the moment, we only have two algorithms to choose from: <kbd>Memoized</kbd> or <kbd>Iterative</kbd>. Now, we can define the memoized version of the <kbd>fib</kbd> function as follows:</p>
<pre>using Memoize<br/>@memoize function _fib(n)<br/>    n &lt;= 2 ? 1 : _fib(n-1) + _fib(n-2)<br/>end<br/><br/>function fib(::Memoized, n)<br/>    println("Using memoization algorithm")<br/>    _fib(n)<br/>end</pre>
<p>A memoized function <kbd>_fib</kbd> is first defined. Then a wrapper function <kbd>fib</kbd> is defined, taking a <kbd>Memoized</kbd> object as the first argument. The corresponding iterative algorithm can be implemented as follows:</p>
<pre>function fib(algo::Iterative, n) <br/>    n &lt;= 2 &amp;&amp; return 1<br/>    prev1, prev2 = 1, 1<br/>    local curr<br/>    for i in 3:n<br/>        curr = prev1 + prev2<br/>        prev1, prev2 = curr, prev1<br/>    end<br/>    return curr<br/>end</pre>
<p>How the algorithm actually works is unimportant in this discussion. As the first argument is an <kbd>Iterative</kbd> object, we know that this function will be dispatched accordingly. </p>
<p>From the client's perspective, it can choose either the memoized version or the iterative function, depending on what it needs. As the memoized version runs at O(1) speed, it should be faster when <kbd>n</kbd> is large; however, for a small value of <kbd>n</kbd>, the iterative version would work better. We can call the <kbd>fib</kbd> function in one of the following ways:</p>
<pre>fib(Memoized(), 10)<br/>fib(Iterative(), 10)</pre>
<p>Should the client choose to implement an algorithm-selection process, it can be done <span>easily, </span>as follows:</p>
<pre>function fib(n)<br/>    algo = n &gt; 50 ? Memoized() : Iterative()<br/>    return fib(algo, n)<br/>end</pre>
<p>The successful test result is shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7bc2d48-581e-4c49-9e04-cc6ca69166be.png" style="width:17.92em;height:8.50em;"/></p>
<p>As you can see, implementing the strategy pattern is quite easy. <em>The unreasonable effectiveness of multiple dispatch has come to rescue again!</em> Next, we will go over another behavioral pattern called the template method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The template method pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>template method</strong> pattern is used to create a well-defined process that can use different kinds of algorithms or operations. As a template, it can be customized with whatever algorithm or functions the client requires.</p>
<p>Here, we will explore how the template method pattern can be utilized in a <strong>machine learning</strong> (<strong>ML</strong>) pipeline use case. For those who are unfamiliar with ML pipelines, here is a simplified version of what a data scientist might do:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8d9dc286-6d1e-49f8-84a2-da3a420205a0.png" style="width:48.92em;height:13.83em;"/></p>
<p>A dataset is first split into two separate datasets for training and testing purposes. The training dataset is fed into a process that fits the data into a statistical model. Then, the <kbd>validate</kbd> function uses the model to predict the response (also called the target) variable in the test set. Finally, it compares the predicted values against the actual values and determines how accurate the model is.</p>
<p>Let's say we have the pipeline already set up as follows:</p>
<pre>function run(data::DataFrame, response::Symbol, predictors::Vector{Symbol})<br/>    train, test = split_data(data, 0.7)<br/>    model = fit(train, response, predictors)<br/>    validate(test, model, response)<br/>end</pre>
<p>For the sake of brevity, the specific functions, <kbd>split_data</kbd>, <kbd>fit</kbd>, and <kbd>validate</kbd>, are not shown here; you can look them up on this book's GitHub site if you wish. However, the pipeline concept is demonstrated in the preceding logic. Let's take a quick spin at predicting Boston house prices:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec34e4dc-c307-4190-9ba5-50be22ef7411.png" style="width:42.08em;height:11.75em;"/></p>
<p>In this example, the response variable is <kbd>:MedV</kbd>, and we will build a statistic model based on <kbd>:Rm</kbd>, <kbd>:Tax</kbd>, and <kbd>:Crim</kbd>. </p>
<div class="packt_infobox">The Boston housing dataset contains data <span><span>collected by the U.S. Census Service concerning housing in the area of Boston, Massachusetts. It is used extensively by much statistical analysis educational literature. The variables that we used in this example are:<br/>
<br/></span></span> <kbd>MedV</kbd>: Median value of owner-occupied homes in $1,000's<br/>
<kbd>Rm</kbd>: Average number of rooms per dwelling<br/>
<kbd>Tax</kbd>: Full-value property tax rate per $10,000<br/>
<kbd>Crim</kbd>: Per capita crime rate by town</div>
<p>The accuracy of the model is captured in the <kbd>rmse</kbd> variable (meaning the root mean squared error). The default implementation uses linear regression as the fitting function.</p>
<p>To implement the template method pattern, we should allow the client to plug in any part of the process. For that reason, we can modify the function with keyword arguments:</p>
<pre>function run2(data::DataFrame, response::Symbol, predictors::Vector{Symbol};<br/>            fit = fit, split_data = split_data, validate = validate)<br/>    train, test = split_data(data, 0.7)<br/>    model = fit(train, response, predictors)<br/>    validate(test, model, response)<br/>end</pre>
<p>Here, we have added three keyword arguments: <kbd>fit</kbd>, <kbd>split_data</kbd>, and <kbd>validate</kbd>. The function is named as <kbd>run2</kbd> to avoid confusion here, so the client should be able to customize any one of them by passing in a custom function. To illustrate how it works, let's create a new <kbd>fit</kbd> function that uses the <strong>generalized linear model</strong> (<strong>GLM</strong>):</p>
<pre>using GLM<br/><br/>function fit_glm(df::DataFrame, response::Symbol, predictors::Vector{Symbol})<br/>    formula = Term(response) ~ +(Term.(predictors)...)<br/>    return glm(formula, df, Normal(), IdentityLink())<br/>end</pre>
<p>Now that we have customized the fitting function, we can rerun the program by passing it via the <kbd>fit</kbd> keyword argument: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/01ae2558-eab6-4997-834c-0a5055df949c.png" style="width:27.25em;height:7.42em;"/></p>
<p>As you can see, the client can customize the pipeline easily by just passing in functions. This is possible because Julia supports first-class functions.</p>
<p>In the next section, we will review a few other traditional behavioral patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command, interpreter, iterator, and visitor patterns</h1>
                </header>
            
            <article>
                
<p>The <strong>command</strong>, <strong>interpreter</strong>, and <strong>visitor</strong> patterns are grouped in this section only because we have already covered their use cases earlier in this book.</p>
<p>The <strong>command</strong> pattern is used to parameterize actions that are to be performed. In <a href="6682bca1-9221-46fa-84f2-f5379fd4d01b.xhtml">Chapter 9</a>, <em>Miscellaneous Patterns</em>, in the <em>Singleton type dispatch pattern</em> section, we explored a use case where the GUI invokes different commands and reacts to specific actions that the user has requested. By defining singleton types, we can leverage Julia's multiple dispatch mechanism to execute the proper function. We can extend this to new commands by <span>simply</span><span> </span><span>adding new functions that take new singleton types.</span></p>
<p>The <strong>interpreter</strong> pattern is used to model an abstract syntax tree for a particular domain model. As it turns out, we have already done this in <a href="08f064fb-f7c5-4078-a9c9-5e70d42f336a.xhtml">Chapter 7</a>, <em>Maintainability Patterns</em>, in the <em>Domain-specific language</em> section. Every Julia expression can be modeled as an abstract syntax tree without any additional work, and so we can develop a DSL using regular metaprogramming facilities, such as macros and generated functions.</p>
<p>The <strong>iterator</strong> pattern is used to iterate over a collection of objects using a standard protocol. In Julia, there is already an officially established iteration interface that can be implemented by any collection framework. As long as an <kbd>iterate</kbd> function is defined for a custom object, the elements in the object can be iterated as part of any looping construct. More information can be found from the official Julia reference manual.</p>
<p>Finally, the <strong>visitor</strong> pattern is used to extend functionalities of an existing class in the OOP paradigm. In Julia, adding new functions to an existing system can be done easily via an extension of generic functions. For example, there are many array-like data structure packages in the Julia ecosystem, such as <kbd>OffsetArrays</kbd>, <kbd>StridedArrays</kbd>, and <kbd>NamedArrays</kbd>. All of these are extensions to the existing <kbd>AbstractArray</kbd> framework. </p>
<p>We are now finished with behavioral patterns. Let's move on and take a look at the last group—structural patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structural patterns</h1>
                </header>
            
            <article>
                
<p><strong>Structural design</strong> patterns are used to compose objects together to make bigger things. As you continue developing a system and adding functionalities, its size and complexity grows. Not only do we want to integrate components with each other, but at the same time, we also want to reuse components as much as possible. By learning the structural patterns described in this section, we have a template to follow when we encounter similar situations in our projects.</p>
<p>In this section, we will review the traditional object-oriented patterns, including the adapter, bridge, composite, decorator, facade, flyweight, and proxy patterns. Let's start with the adapter pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The adapter pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>adapter</strong> pattern is used to make one object work with another. Say that we need to integrate two subsystems, but they cannot talk to each other because the interface requirements are not met. In real life, you may have encountered a situation where traveling to a different country is troublesome because the power plugs are not the same. To solve this problem, you would probably bring a universal power adapter, which acts as an intermediary to make your device work with foreign electrical outlets. Similarly, different software can be made to fit with each other by the use of adapters.</p>
<p>As long as the interface for working with a subsystem is clear, then creating an adapter can be a straightforward task. In Julia, we can use the Delegation pattern to wrap an object and provide additional functionalities that conform to the required interface.</p>
<p>Let's imagine that we are using a library that performs a computation and returns a linked list. A linked list is a convenient data structure that supports very fast inserts at O(1) speed. Now, say that we want to pass the data to another subsystem that requires us to conform to an <kbd>AbstractArray</kbd> interface. In this case, we cannot just pass the linked list as it does not fit!</p>
<p>How do we solve this problem? First, let me introduce the <kbd>LinkedList</kbd> implementation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae49982c-b878-4825-a109-91336b9e71b5.png" style="width:21.75em;height:13.00em;"/></p>
<p>This is a fairly standard design for a doubly-linked list. Each node contains a data value, but also maintains a reference to the node before and after. The typical usage of such a linked list is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/252a3142-77ea-4c16-8a2f-4433fba8ebe2.png" style="width:15.33em;height:12.75em;"/></p>
<p>In general, we can traverse the linked list by using the <kbd>prev</kbd> and <kbd>next</kbd> functions. The reason why we need to call <kbd>next(LL)</kbd> when inserting the value of <kbd>3</kbd> is because we want to insert it after the second node.</p>
<p>Because using a linked list does not implement the <kbd>AbstractArray</kbd> interface, we cannot really reference any element by index, nor can we figure out the number of elements:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5634213c-ffb6-468d-835a-c1d6929df4a7.png" style="width:40.92em;height:15.75em;"/></p>
<p>In this case, we can build a wrapper (or so-called adapter) that conforms to the <kbd>AbstractArray</kbd> interface. First, let's create a new type and make it a subtype of <kbd>AbstractArray</kbd>:</p>
<pre>struct MyArray{T} &lt;: AbstractArray{T,1}<br/>    data::Node{T}<br/>end</pre>
<p>As we only need to support a single-dimension array, we have defined the supertype to be <kbd>AbstractArray{T,1}</kbd>. The underlying data is just a reference to the linked list <kbd>Node</kbd> object. In order to conform to the <kbd>AbstractArray</kbd> interface, we should implement the <kbd>Base.size</kbd> and <kbd>Base.getindex</kbd> functions. Here's what the <kbd>size</kbd> function looks like:</p>
<pre>function Base.size(ar::MyArray) <br/>    n = ar.data<br/>    count = 0<br/>    while next(n) !== nothing<br/>        n = next(n)<br/>        count += 1<br/>    end<br/>    return (1 + count, 1)<br/>end</pre>
<p>The function simply determines the length of the array by traversing the linked list using the <kbd>next</kbd> function. To support indexing elements, we can define the <kbd>getindex</kbd> function as follows:</p>
<pre>function Base.getindex(ar::MyArray, idx::Int)<br/>    n = ar.data<br/>    for i in 1:(idx-1)<br/>        next_node = next(n)<br/>        next_node === nothing &amp;&amp; throw(BoundsError(n.data, idx))<br/>        n = next_node<br/>    end<br/>    return value(n)<br/>end</pre>
<p>That is all we need to do for the wrapper. Let's give it a spin now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/51fccc19-1d3f-476a-8383-e64f36bda2d8.png" style="width:12.83em;height:14.83em;"/></p>
<p>Now that we have an indexable array on top of the linked list, we can pass it to any library that expects arrays as input.</p>
<div class="packt_tip">In the situation where mutation is required for the array, we can just implement the <kbd>Base.setindex!</kbd> function as well. Alternatively, we can physically <span>convert the linked list into an array. An array has the performance characteristic of fast indexing at O(1), while being relatively slow for inserts.</span></div>
<p>Using an adapter allows us to make components talk to each other more easily. Next, we will discuss the composite pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The composite pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>composite</strong> pattern is used to model objects that can be grouped together and yet be treated the same as individual objects. This is not an uncommon case—for example, in a drawing application, we might be able to draw different kinds of shapes, such as circles, rectangles, and triangles. Every shape has a position and size so we can determine where they are located on screen as well as how large they are. When we group several shapes together, we can still determine the position and size of the large, grouped object. Additionally, resize, rotate, and other transformation functions can be applied to individual shape objects as well as grouped objects.</p>
<p>A similar situation happens with portfolio management. I have a retirement investment account that is composed of multiple mutual funds. Each mutual fund may either invest in stocks, bonds, or both. Then, some funds may also invest in other mutual funds. From an accounting perspective, we can always determine the market value of a stock, a bond, a fund of stocks, a fund of bonds, and a fund of funds. In Julia, we can tackle this problem by just implementing a <kbd>market_value</kbd> function for different types of instruments, whether it is a stock, a bond, or a fund. Let's take a look at some code now.</p>
<p>Let's say we have the following type defined for stock/bond holdings:</p>
<pre>struct Holding<br/>    symbol::String<br/>    qty::Int<br/>    price::Float64<br/>end</pre>
<p>The <kbd>Holding</kbd> type contains a trading symbol, quantity, and current price. We can define a portfolio as follows:</p>
<pre>struct Portfolio<br/>    symbol::String<br/>    name::String<br/>    stocks::Vector{Holding}<br/>    subportfolios::Vector{Portfolio}<br/>end</pre>
<p>A portfolio is identified by a symbol, a name, an array of holdings, and an array of <kbd>subportfolios</kbd>. For testing, we can create a sample portfolio:</p>
<pre>function sample_portfolio()<br/>    large_cap = Portfolio("TOMKA", "Large Cap Portfolio", [<br/>        Holding("AAPL", 100, 275.15), <br/>        Holding("IBM", 200, 134.21), <br/>        Holding("GOOG", 300, 1348.83)])<br/><br/>    small_cap = Portfolio("TOMKB", "Small Cap Portfolio", [<br/>        Holding("ATO", 100, 107.05), <br/>        Holding("BURL", 200, 225.09), <br/>        Holding("ZBRA", 300, 257.80)])<br/>    <br/>    p1 = Portfolio("TOMKF", "Fund of Funds Sleeve", [large_cap, small_cap])<br/>    p2 = Portfolio("TOMKG", "Special Fund Sleeve", [Holding("C", 200, 76.39)])<br/>    return Portfolio("TOMZ", "Master Fund", [p1, p2])<br/>end</pre>
<p>The structure is visualized more clearly from an indented output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/318f5457-0580-432d-96e1-bec526076030.png" style="width:17.58em;height:14.92em;"/></p>
<p>As we want to support the ability to calculate the market value at any level, we just need to define the <kbd>market_value</kbd> function for each type. The simplest one is for holdings:</p>
<pre>market_value(s::Holding) = s.qty * s.price</pre>
<p>The market value is nothing but quantity multiplied by price. The calculation of market value for a portfolio is just a little more involved:</p>
<pre>market_value(p::Portfolio) = <br/>    mapreduce(market_value, +, p.stocks, init = 0.0) +<br/>    mapreduce(market_value, +, p.subportfolios, init = 0.0)</pre>
<p>Here, we use the <kbd>mapreduce</kbd> function to calculate the market values of individual stocks (or <kbd>subportfolios</kbd>) and sum them up. As a portfolio may include multiple holdings and multiple <kbd>subportfolios</kbd>, we need to perform the calculation for both and add them together. As each subportfolio is also a <kbd>portfolio</kbd> object, this code naturally recurses deeper into sub-<kbd>subportfolios</kbd>, and so forth.</p>
<p>There is nothing fancy about composites. Because Julia supports generic functions, we can just provide an implementation for individual objects as well as grouped objects.</p>
<p>We will discuss the flyweight pattern next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The flyweight pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>flyweight</strong> pattern is used to handle a large number of fine-grained objects efficiently by sharing memory for similar/same objects. </p>
<p>A good example of this involves handling strings. In the field of data science, we frequently need to read and analyze a large amount of data that is represented in a tabular format. In many cases, certain columns may contain a large number of strings that are just repeated values. For example, a population survey might have a column stating gender, and so it will contain either <kbd>Male</kbd> or <kbd>Female</kbd>.</p>
<p>Unlike some other programming languages, strings are not interned in Julia. This means that 10 copies of the word <kbd>Male</kbd> are going to be stored repeatedly, occupying 10 times the memory space that is used by a single string of <kbd>Male</kbd>. We can see this effect easily from the REPL, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/380fa56c-5edf-47fb-89af-8bb638e64e52.png" style="width:21.25em;height:9.67em;"/></p>
<p>So, storing 100,000 copies of a <kbd>Male</kbd> string occupies roughly 800 KB of memory. That is quite a waste of memory. A common way to solve this problem is to maintain a pooled array. Rather than storing 100,000 strings, we can just encode the data and store 100,000 bytes instead so that <kbd>0x01</kbd> corresponds to male and <kbd>0x00</kbd> corresponds to female. We can reduce the memory footprint eightfold by using <kbd>s</kbd> as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6b8c5d49-5f72-4ff0-b14b-be32938fbc6a.png" style="width:21.00em;height:4.92em;"/></p>
<p>You may wonder why there are 40 extra bytes being reported. Those 40 bytes are actually used by the array container. Now, given that the gender column is binary in this case, we can actually squeeze it further by storing bits instead of bytes, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b4e3d6b-c79f-461d-a2df-aa7add823836.png" style="width:30.42em;height:5.08em;"/></p>
<p>Again, we reduce the memory usage approximately eightfold (by going from 1 byte to 1 bit) by using <kbd>BitArray</kbd> to store the gender values. This is an aggressive optimization of memory usage. But we still need to store the <kbd>Male</kbd> and <kbd>Female</kbd> <span>strings</span><span> </span><span>somewhere, right? This is an easy task because we know they can be tracked in any data structure, such as a dictionary:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4b91455c-34a6-49fb-b3f3-c759ba626a25.png" style="width:35.92em;height:7.92em;"/></p>
<p>To summarize, we are now capable of storing 100,000 gender values in 12,568 + 370 = 12,938 bytes of memory. Compared to the original dumb way of storing strings directly, we have saved more than 98% of memory consumption! How did we achieve such a huge saving? Because all records share the same two strings. The only data that we have to maintain is an array of references to those strings.</p>
<p>So, that is the concept of the flyweight pattern. The same trick is used over and over again in many places. For example, the <kbd>CSV.jl</kbd> package uses a package called <kbd>CategoricalArrays</kbd>, which provides essentially the same kind of memory optimization.</p>
<p>Next, we will go over the last few traditional patterns—bridge, decorator, and facade.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bridge, decorator, and facade patterns</h1>
                </header>
            
            <article>
                
<p>Let me explain how the bridge, decorator, and facade patterns work. At this point, we will not provide any more code samples for these patterns, only because they are relatively easy to implement, as you are already equipped with many ideas from prior design pattern sections. Perhaps not too surprisingly, the same tricks that you have learned so far—delegation, singleton type, multiple dispatch, first-class functions, abstract types, and interfaces—are the same ones that you can use to tackle any type of problem.</p>
<p>The <strong>bridge</strong> pattern is used to decouple an abstraction from its implementation so that it can evolve independently. In Julia, we can build a hierarchy of abstract types for which implementers can develop software that conforms to those interfaces.</p>
<p>Julia's numeric types are good examples of how such a system can be designed. There are many abstract types available, such as <kbd>Integer</kbd>, <kbd>AbstractFloat</kbd>, and <kbd>Real</kbd>. Then, there are concrete implementations, such as <kbd>Int</kbd> and <kbd>Float64</kbd>, provided by the <kbd>Base</kbd> package. The abstraction is designed in such a way that people can provide an alternative implementation of numbers. For example, the <kbd>SaferInteger</kbd> packages provide a safer implementation for integers that avoids numerical overflow.</p>
<p>The <strong>decorator</strong> pattern is also simple to implement. It can be used to enhance an existing object with new functionalities, hence the term <em>decorator</em>. Suppose that we have bought a third-party library, but we are not totally satisfied with the functionalities. Using the decorator pattern, we can add value by wrapping the existing library with new functions.</p>
<p><span>This can be done naturally using the Delegation pattern. By wrapping an existing type with a new type, we can reuse existing functionalities by delegating to the underlying object. Then, we can add new functions to the new type to gain new capabilities. </span>We see this pattern used over and over again.</p>
<p>The <strong>facade</strong> pattern is used to encapsulate complex subsystems and provide a simplified interface for clients. How do we do that in Julia? By now, we should have seen this pattern over and over again; all we need to do is create a new type and provide a simple API that operates on the new type. We can use the Delegation pattern to forward requests to other enclosed types.</p>
<p>We have now looked at all traditional object-oriented patterns. You might have noticed that many of the use cases can be solved with the standard Julia features and patterns described in this book. This is not a coincidence—it is just that easy to deal with complex problems in Julia.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have gone over the traditional object-oriented design patterns extensively. We started with the humble belief that the same patterns in object-oriented programming often need to be applied in Julia programming.</p>
<p>We started reviewing creational design patterns, which include the factory method, abstract factory, singleton, builder, and prototype patterns. These patterns involve various techniques for creating objects. When it comes to Julia, we can mostly solve these problems using abstract types, interfaces, and multiple dispatch.</p>
<p>We also spent a considerable amount of effort looking at behavioral design patterns. These patterns are made to handle collaboration and communication between components in an application. We looked at 11 patterns: chain of responsibility, mediator, memento, observer, state, strategy, template method, command, interpreter, iterator, and visitor. These patterns can be implemented in Julia using traits, interfaces, multiple dispatch, and first-class functions.</p>
<p>Finally, we reviewed several structural design patterns. These patterns are used to construct bigger components by reusing existing ones. This includes the adapter, composite, flyweight, bridge, decorator, and facade patterns. In Julia, they can be handled with abstract types, interfaces, and the delegation design pattern.</p>
<p><span>I hope you are convinced that building software does not need to be difficult. Just because OOP made us believe that we need all of this complexity to design software, it does not mean that we have to do the same in Julia. The solutions to the problems that are presented in this chapter mostly require the basic software design skills and patterns that you found in this book.</span></p>
<p>In the next chapter, we will get into a more advanced topic regarding data types and dispatch. <em>Get ready to rock!</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What technique can we use to implement the abstract factory pattern?</li>
<li>How do we prevent a singleton from being initialized multiple times in a multithreaded application?</li>
<li>What Julia feature is essential to implementing the observer pattern?</li>
<li>How can we customize an operation using the template method pattern?</li>
<li>How do we make an adapter to implement a target interface?</li>
<li>What is the benefit of the flyweight pattern and what strategy can we use to achieve it?</li>
<li>What Julia feature can we use to implement the strategy pattern?</li>
</ol>


            </article>

            
        </section>
    </body></html>