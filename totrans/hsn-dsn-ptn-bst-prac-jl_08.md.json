["```py\nmutable struct Account\n    account_number::String\n    balance::Float64\n    date_opened::Date\nend\n```", "```py\n# Accessors\n\naccount_number(a::Account) = a.account_number\nbalance(a::Account) = a.balance\ndate_opened(a::Account) = a.date_opened\n\n# Functions\n\nfunction deposit!(a::Account, amount::Real)\n    a.balance += amount\n    return a.balance\nend\n\nfunction withdraw!(a::Account, amount::Real)\n    a.balance -= amount\n    return a.balance\nend\n\nfunction transfer!(from::Account, to::Account, amount::Real)\n    withdraw!(from, amount)\n    deposit!(to, amount)\n    return amount\nend\n```", "```py\nstruct SavingsAccount\n    acct::Account\n    interest_rate::Float64\n\n    SavingsAccount(account_number, balance, date_opened, interest_rate) = new(\n        Account(account_number, balance, date_opened),\n        interest_rate\n    )\nend\n```", "```py\n# Forward assessors\naccount_number(sa::SavingsAccount) = account_number(sa.acct)\nbalance(sa::SavingsAccount) = balance(sa.acct)\ndate_opened(sa::SavingsAccount) = date_opened(sa.acct)\n\n# Forward methods\ndeposit!(sa::SavingsAccount, amount::Real) = deposit!(sa.acct, amount)\n\nwithdraw!(sa::SavingsAccount, amount::Real) = withdraw!(sa.acct, amount)\n\ntransfer!(sa1::SavingsAccount, sa2::SavingsAccount, amount::Real) = transfer!(\n    sa1.acct, sa2.acct, amount)\n```", "```py\n# new accessor\ninterest_rate(sa::SavingsAccount) = sa.interest_rate\n\n# new behavior\nfunction accrue_daily_interest!(sa::SavingsAccount) \n    interest = balance(sa.acct) * interest_rate(sa) / 365\n    deposit!(sa.acct, interest)\nend\n```", "```py\nusing Lazy: @forward\n\n# Forward assessors and functions\n@forward SavingsAccount.acct account_number, balance, date_opened\n@forward SavingsAccount.acct deposit!, withdraw!\n\ntransfer!(from::SavingsAccount, to::SavingsAccount, amount::Real) = transfer!(\n    from.acct, to.acct, amount)\n```", "```py\nstruct OffsetArray{T,N,AA<:AbstractArray} <: AbstractArray{T,N}\n    parent::AA\n    offsets::NTuple{N,Int}\nend\n\nBase.parent(A::OffsetArray) = A.parent\n\nBase.size(A::OffsetArray) = size(parent(A))\nBase.size(A::OffsetArray, d) = size(parent(A), d)\n\nBase.eachindex(::IndexCartesian, A::OffsetArray) = CartesianIndices(axes(A))\nBase.eachindex(::IndexLinear, A::OffsetVector) = axes(A, 1)\n```", "```py\n\"\"\" `FitBit(model)` will behave just like `model`, but also supports\n`isfit(fb)`, which returns true IFF `fit!(model, ...)` has been called \"\"\"\nmutable struct FitBit\n    model\n    isfit::Bool\n    FitBit(model) = new(model, false)\nend\n\nfunction fit!(fb::FitBit, args...; kwargs...)\n    fit!(fb.model, args...; kwargs...)\n    fb.isfit = true\n    fb\nend\n\nisfit(fb::FitBit) = fb.isfit\n```", "```py\n\n@forward FitBit.model transform, predict, predict_proba, predict_dist, get_classes\n```", "```py\nfunction show_tradable_assets(assets::Vector{Asset})\n    for asset in assets\n        if asset isa Investment || asset isa Cash\n            println(\"Yes, I can trade \", asset)\n        else\n            println(\"Sorry, \", asset, \" is not tradable\")\n        end\n    end\nend\n```", "```py\nconst LiquidInvestments = Union{Investment, Cash}\n\nfunction show_tradable_assets(assets::Vector{Asset})\n    for asset in assets\n        if asset isa LiquidInvestments\n            println(\"Yes, I can trade \", asset)\n        else\n            println(\"Sorry, \", asset, \" is not tradable\")\n        end\n    end\nend\n```", "```py\nabstract type Asset end\n\nabstract type Property <: Asset end\nabstract type Investment <: Asset end\nabstract type Cash <: Asset end\n\nabstract type House <: Property end\nabstract type Apartment <: Property end\n\nabstract type FixedIncome <: Investment end\nabstract type Equity <: Investment end\n```", "```py\nstruct Residence <: House\n    location\nend\n\nstruct Stock <: Equity\n    symbol\n    name\nend\n\nstruct TreasuryBill <: FixedIncome\n    cusip\nend\n\nstruct Money <: Cash\n    currency\n    amount\nend\n```", "```py\nabstract type LiquidityStyle end\nstruct IsLiquid <: LiquidityStyle end\nstruct IsIlliquid <: LiquidityStyle end\n```", "```py\n# Default behavior is illiquid\nLiquidityStyle(::Type) = IsIlliquid()\n\n# Cash is always liquid\nLiquidityStyle(::Type{<:Cash}) = IsLiquid()\n\n# Any subtype of Investment is liquid\nLiquidityStyle(::Type{<:Investment}) = IsLiquid()\n```", "```py\n# The thing is tradable if it is liquid\ntradable(x::T) where {T} = tradable(LiquidityStyle(T), x)\ntradable(::IsLiquid, x) = true\ntradable(::IsIlliquid, x) = false\n```", "```py\n# The thing has a market price if it is liquid\nmarketprice(x::T) where {T} = marketprice(LiquidityStyle(T), x)\nmarketprice(::IsLiquid, x) = error(\"Please implement pricing function for \", typeof(x))\nmarketprice(::IsIlliquid, x) = error(\"Price for illiquid asset $x is not available.\")\n```", "```py\n# Sample pricing functions for Money and Stock\nmarketprice(x::Money) = x.amount\nmarketprice(x::Stock) = rand(200:250)\n```", "```py\nfunction trait_test_cash()\n    cash = Money(\"USD\", 100.00)\n    @show tradable(cash)\n    @show marketprice(cash)\nend\n\nfunction trait_test_stock()\n    aapl = Stock(\"AAPL\", \"Apple, Inc.\")\n    @show tradable(aapl)\n    @show marketprice(aapl)\nend\n\nfunction trait_test_residence()\n    try \n        home = Residence(\"Los Angeles\")\n        @show tradable(home) # returns false\n        @show marketprice(home) # exception is raised\n    catch ex\n        println(ex)\n    end\n    return true\nend\n\nfunction trait_test_bond()\n    try\n        bill = TreasuryBill(\"123456789\")\n        @show tradable(bill)\n        @show marketprice(bill) # exception is raised\n    catch ex\n        println(ex)\n    end\n    return true\nend\n\n```", "```py\nabstract type Literature end\n\nstruct Book <: Literature\n    name\nend\n```", "```py\n# assign trait\nLiquidityStyle(::Type{Book}) = IsLiquid()\n\n# sample pricing function\nmarketprice(b::Book) = 10.0\n```", "```py\nabstract type IteratorSize end\nstruct SizeUnknown <: IteratorSize end\nstruct HasLength <: IteratorSize end\nstruct HasShape{N} <: IteratorSize end\nstruct IsInfinite <: IteratorSize end\n```", "```py\n\"\"\"\n    IteratorSize(itertype::Type) -> IteratorSize\n\"\"\"\nIteratorSize(x) = IteratorSize(typeof(x))\nIteratorSize(::Type) = HasLength() # HasLength is the default\n\nIteratorSize(::Type{<:AbstractArray{<:Any,N}}) where {N} = HasShape{N}()\nIteratorSize(::Type{Generator{I,F}}) where {I,F} = IteratorSize(I)\n\nIteratorSize(::Type{Any}) = SizeUnknown()\n```", "```py\nIteratorSize(::Type{<:Repeated}) = IsInfinite()\n```", "```py\nBitArray(itr) = gen_bitarray(IteratorSize(itr), itr)\n\ngen_bitarray(::IsInfinite, itr) = throw(ArgumentError(\"infinite-size iterable used in BitArray constructor\"))\n```", "```py\nabstract type ConversionTrait end\n\nstruct NoConversion <: ConversionTrait end\nstruct PointBased <: ConversionTrait end\nstruct SurfaceLike <: ConversionTrait end\n\n# By default, there is no conversion trait for any object\nconversion_trait(::Type) = NoConversion()\nconversion_trait(::Type{<: XYBased}) = PointBased()\nconversion_trait(::Type{<: Union{Surface, Heatmap, Image}}) = SurfaceLike()\n```", "```py\n# Do not convert anything if there is no conversion trait\nconvert_arguments(::NoConversion, args...) = args\n```", "```py\n*\"\"\"*\n *convert_arguments(P, x, y)::(Vector)*\n\n*Takes vectors `x` and `y` and turns it into a vector of 2D points of the values*\n*from `x` and `y`.*\n\n*`P` is the plot Type (it is optional).*\n*\"\"\"*\nconvert_arguments(::PointBased, x::RealVector, y::RealVector) = (Point2f0.(x, y),)\n```", "```py\n@traitdef IsLiquid{T}\n```", "```py\n@traitimpl IsLiquid{Cash}\n@traitimpl IsLiquid{Investment}\n```", "```py\n@traitfn marketprice(x::::IsLiquid) = error(\"Please implement pricing function for \", typeof(x))\n@traitfn marketprice(x::::(!IsLiquid)) = error(\"Price for illiquid asset $x is not available.\")\n```", "```py\n# Abstract type hierarchy for personal assets\nabstract type Asset end\nabstract type Investment <: Asset end\nabstract type Equity <: Investment end\n\n# Equity Instruments Types \nstruct Stock <: Equity\n    symbol::String\n    name::String\nend\n\n# Trading Types\nabstract type Trade end\n\n# Types (direction) of the trade\n@enum LongShort Long Short\n\nstruct StockTrade <: Trade\n    type::LongShort\n    stock::Stock\n    quantity::Int\n    price::Float64\nend\n```", "```py\n# Types of stock options\n@enum CallPut Call Put\n\nstruct StockOption <: Equity\n    symbol::String\n    type::CallPut\n    strike::Float64\n    expiration::Date\nend\n\nstruct StockOptionTrade <: Trade\n    type::LongShort\n    option::StockOption\n    quantity::Int\n    price::Float64\nend\n```", "```py\n# Regardless of the instrument being traded, the direction of \n# trade (long/buy or short/sell) determines the sign of the \n# payment amount.\nsign(t::StockTrade) = t.type == Long ? 1 : -1\nsign(t::StockOptionTrade) = t.type == Long ? 1 : -1\n\n# market value of a trade is simply quantity times price\npayment(t::StockTrade) = sign(t) * t.quantity * t.price\npayment(t::StockOptionTrade) = sign(t) * t.quantity * t.price\n```", "```py\nstruct SingleTrade{T <: Investment} <: Trade\n    type::LongShort\n    instrument::T\n    quantity::Int\n    price::Float64\nend\n```", "```py\n# Return + or - sign for the direction of trade\nfunction sign(t::SingleTrade{T}) where {T} \n    return t.type == Long ? 1 : -1\nend\n\n# Calculate payment amount for the trade\nfunction payment(t::SingleTrade{T}) where {T} \n    return sign(t) * t.quantity * t.price\nend\n```", "```py\n# Calculate payment amount for option trades (100 shares per contract)\nfunction payment(t::SingleTrade{StockOption})\n    return sign(t) * t.quantity * 100 * t.price\nend\n```", "```py\nstruct PairTrade{T <: Investment, S <: Investment} <: Trade\n    leg1::SingleTrade{T}\n    leg2::SingleTrade{S}\nend\n```", "```py\npayment(t::PairTrade) = payment(t.leg1) + payment(t.leg2)\n```", "```py\n*\"\"\"\n`Colorant{T,N}` is the abstract super-type of all types in ColorTypes,\nand refers to both (opaque) colors and colors-with-transparency (alpha\nchannel) information. `T` is the element type (extractable with\n`eltype`) and `N` is the number of *meaningful* entries (extractable\nwith `length`), that is, the number of arguments you would supply to the\nconstructor.\n\"\"\"*\nabstract type Colorant{T,N} end\n\n*# Colors (without transparency)\n\"\"\"\n`Color{T,N}` is the abstract supertype for a color (or\ngrayscale) with no transparency.\n\"\"\"*\nabstract type Color{T, N} <: Colorant{T,N} end\n\n*\"\"\"\n`AbstractRGB{T}` is an abstract supertype for red/green/blue color types that\ncan be constructed as `C(r, g, b)` and for which the elements can be\nextracted as `red(c)`, `green(c)`, `blue(c)`. You should *not* make\nassumptions about internal storage order, the number of fields, or the\nrepresentation. One `AbstractRGB` color-type, `RGB24`, is not\nparametric and does not have fields named `r`, `g`, `b`.\n\"\"\"*\nabstract type AbstractRGB{T}      <: Color{T,3} end\n```", "```py\nconst Fractional = Union{AbstractFloat, FixedPoint}\n\n*\"\"\"\n`RGB` is the standard Red-Green-Blue (sRGB) colorspace. Values of the\nindividual color channels range from 0 (black) to 1 (saturated). If\nyou want \"Integer\" storage types (for example, 255 for full color), use `N0f8(1)`\ninstead (see FixedPointNumbers).\n\"\"\"*\nstruct RGB{T<:Fractional} <: AbstractRGB{T}\n    r::T # Red [0,1]\n    g::T # Green [0,1]\n    b::T # Blue [0,1]\n    RGB{T}(r::T, g::T, b::T) where {T} = new{T}(r, g, b)\nend\n\n```", "```py\n\"\"\"\nThe `NamedDimsArray` constructor takes a list of names as `Symbol`s,\none per dimension, and an array to wrap.\n\"\"\"\nstruct NamedDimsArray{L, T, N, A<:AbstractArray{T, N}} <: AbstractArray{T, N}\n    # `L` is for labels, it should be an `NTuple{N, Symbol}`\n    data::A\nend\n```", "```py\nfunction NamedDimsArray{L}(orig::AbstractArray{T, N}) where {L, T, N}\n    if !(L isa NTuple{N, Symbol})\n        throw(ArgumentError(\n            \"A $N dimensional array, needs a $N-tuple of dimension names. Got: $L\"\n        ))\n    end\n    return NamedDimsArray{L, T, N, typeof(orig)}(orig)\nend\n```", "```py\ndimnames(::Type{<:NamedDimsArray{L}}) where L = L\n```"]