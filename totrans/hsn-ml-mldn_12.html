<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using ML.NET with ASP.NET Core</h1>
                </header>
            
            <article>
                
<p>Now that we have an idea of how to create a production-grade .NET Core console application, in this chapter, we will deep dive into creating a fully functional ASP.NET Core Blazor web application. This application will utilize an ML.NET binary classification model to make file classifications on Windows executables (<strong>Portable Executable</strong> (<strong>PE</strong>) files), in order to determine whether the files themselves are either clean or malicious. Furthermore, we will explore breaking our application code into a component-based architecture using a .NET Core library to share between our web application and the console application that will train our model. By the end of the chapter, you should have a firm grasp of designing and coding a production-grade ASP.NET Core Blazor web application with ML.NET.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Breaking down ASP.NET Core </li>
<li>Creating the file classification web application</li>
<li>Exploring additional production-application enhancements</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking down ASP.NET Core</h1>
                </header>
            
            <article>
                
<p>Building on the same .NET Core technology discussed in <a href="a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml">Chapter 8</a>, <em>Using ML.NET with .NET Core and Forecasting</em>, ASP.NET Core adds a powerful web framework. This web framework includes a powerful rendering engine, Razor, in addition to supporting scalable <strong>representational state transfer</strong> (<strong>REST</strong>) services. The example in this chapter will use this technology to create our file classification frontend. In the next two sections, we will dive into the ASP.NET Core architecture and discuss Blazor, the new web framework from Microsoft.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the ASP.NET Core architecture</h1>
                </header>
            
            <article>
                
<p>At a high level, ASP.NET Core builds on top of .NET Core, providing a fully-featured web framework. As with .NET Core, ASP.NET Core runs on Windows, Linux, and macOS, in addition to allowing deployments to x86, x64, and <strong>Advanced RISC Machine</strong> (<strong>ARM</strong>) CPU architectures.</p>
<p>A typical ASP.NET Core application includes the following:</p>
<ul>
<li>Models</li>
<li>Views</li>
<li>Controllers</li>
</ul>
<p>These components form a common web architecture principle of <strong>Model-View-Controller</strong>, otherwise known as <strong>MVC</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controllers</h1>
                </header>
            
            <article>
                
<p>Controllers provide the server-side code for handling business logic for both web applications and REST services. Controllers can include both web and REST calls in the same controller, although I would recommend keeping them separate to ensure your code is organized cleanly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models</h1>
                </header>
            
            <article>
                
<p>Models provide the container of data from the Controller to the View, and vice versa. For example, take a listing page pulling data from a database. The controller would return a model populated with that data, and if that same data was then used for filtering, it would also be serialized into <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) and sent back to the Controller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Views</h1>
                </header>
            
            <article>
                
<p>Views provide the templates for the frontend view with support for model binding. Model binding allows properties bound to various <strong>Domain Object Model</strong> (<strong>DOM</strong>) objects—such as textboxes, checkboxes, and dropdowns—to be cleanly mapped to and from. <span>This approach of model binding has the added benefit of supporting strongly typed references, which comes in extremely handy when you have a complex View with dozens of properties bound to a Model.  </span></p>
<p>Form handling with the model binding provides a similar model to the <span><strong>Model-View ViewModel</strong> </span>(<strong><span>MVVM</span></strong>) approach we are going to dive into in <a href="9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml">Chapter 10</a>, <em>Using ML.NET with UWP</em>, with a <strong>Universal Windows Platform</strong> (<strong>UWP</strong>) application.</p>
<div class="packt_tip">If you want to deep dive further into ASP.NET, Channel 9 from Microsoft has a series called ASP.NET Core 101 that covers all of the main aspects of ASP.NET, at <a href="https://channel9.msdn.com/Series/ASPNET-Core-101">https://channel9.msdn.com/Series/ASPNET-Core-101</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blazor</h1>
                </header>
            
            <article>
                
<p>Building on the ASP.NET Core infrastructure, Blazor focuses on removing one of the biggest hurdles with complex web applications—<strong>JavaScript</strong>. Blazor allows you to write C# code instead of JavaScript code to handle client-side tasks such as form handling, HTTP calls, and asynchronously loading data. Under the hood, Blazor uses <strong>WebAssembly</strong> (<strong>Wasm</strong>), a popular high-performant JavaScript framework supported by all current browsers (Edge, Safari, Chrome, and Firefox). </p>
<p>Similar to other frameworks, Blazor also supports and recommends the use of modular components to promote reuse. These are called <strong>Blazor</strong> <strong>components</strong>.</p>
<p>In addition, there are three project types when creating a Blazor application:</p>
<ul>
<li>The Blazor-only client side is used, which is ideal for more static pages.</li>
<li>A Blazor (ASP.NET Core-hosted) client-side application that is hosted inside ASP.NET Core (this is the project type we are going to review in the next section).</li>
<li>A Blazor server-side application that updates the DOM. This is ideal for use with SignalR, Microsoft's real-time web framework supporting chats, real-time tickers, and maps, to name but a few.</li>
</ul>
<div class="packt_infobox">If you want to deep dive further into Blazor, Microsoft has written an abundant amount of documentation on <strong>Microsoft Developer Network</strong> (<strong>MSDN</strong>) at: <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1">https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the file classification web application</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the application we will be creating is a file classification web application. Using the knowledge garnered in <span><span>the </span></span><em>Creating a binary classification application</em> section in <a href="da0d1d99-ad37-498b-8670-f8cee6ad49bc.xhtml">Chapter 4</a>, <em>Classification Model</em>, we will be taking it a step further and looking at adding more attributes to a file prior to making a classification. In addition, we will be integrating machine learning with ML.NET into the web application, where an end user can upload files for classification, returning either clean or malicious files, along with a confidence of that prediction.</p>
<p>As with previous chapters, the completed project code, sample dataset, and project files can be downloaded at: <a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter09">https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter09</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the project architecture</h1>
                </header>
            
            <article>
                
<p>Given the previous applications have all been command-line applications, the project architecture for this example is quite different.</p>
<p>As with some of the previous chapters, an additional ML.NET NuGet package—<kbd>Microsoft.ML.FastTree</kbd>—is required in order to utilize the <kbd>FastTree</kbd> algorithm in ML.NET. Version 1.3.1 is used in both the included example on GitHub and throughout this chapter's deep dive.</p>
<p>In the following screenshot, you will find the Visual Studio Solution Explorer view of the example's solution. Given that this example comprises three separate projects (more akin to a production scenario), the amount of both new and significantly modified files is quite large. We will review each of the new files shown in the following solution screenshot in detail in further sections:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-611 image-border" src="assets/75e605e4-a04e-4723-8895-f9c81ffad49a.png" style="width:19.00em;height:57.58em;"/></p>
<p>The<span> </span><kbd>sampledata.csv</kbd> file contains 14 rows of extracted features from Windows Executables (we will go into these features in more detail in the next section). Feel free to adjust the data to fit your own observations or to adjust the trained model with different sample files. The following snippet is one of the rows found in the <kbd>sampledata.data</kbd> file:</p>
<div>
<pre>18944<span> </span>0<span> </span>7<span> </span>0<span> </span>0<span> </span>4<span> </span>True<span> </span>"!This program cannot be run in DOS mode.Fm;Ld<span> </span>&amp;~_New_ptrt(M4_Alloc_max"uJIif94H3"j?TjV*?invalid argum_~9%sC:\Program Files (x86\Microsoft Visu Studio\20cl4e\xomory"/Owneby CWGnkno excepti &amp; 0xFF;b?eCErr[E7XE#D%d3kRegO(q/}nKeyExWa!0<span> </span>S=+,H}Vo\DebugPE.pdbC,j?_info ByteToWidendled=aekQ3V?$buic_g(@1@A8?5/wQAEAAV0;AH@Z?flush@Co12@XcCd{(kIN&lt;7BED!?rdbufPA[Tght_tDB.0J608(:6&lt;?xml version='1.0' encoding='UTF8' standalone='yes'?&gt;&lt;assembly xmlns='urn:schemasmicrosoftcom:asm.v1' manifestVersion='1.0'&gt; &lt;trustInfo &gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level='asInvoker' uiAccess='false' /&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt; &lt;/trustInfo&gt;&lt;/assembly&gt;KERNEL32.DLLMSVCP140D.dllucrtbased.dllVCRUNTIME140D.dllExitProcessGetProcAddressLoadLibraryAVirtualProtect??1_Lockit@std@@QAE@XZ"</pre></div>
<p>In addition to this, we added the<span> </span><kbd>testdata.data</kbd><span> </span>file that contains additional data points to test the newly trained model<span> </span>against and evaluate it. Here is a sample row of the data inside of<span> </span><kbd>testdata.data</kbd>:</p>
<pre>1670144<span> </span>1<span> </span>738<span> </span>0<span> </span>0<span> </span>24<span> </span>False<span> </span>"!This program cannot be run in DOS mode.WATAUAVAWH A_AA]A\_t$ UWAVHx UATAUAVAWHA_AA]A\]UVWATAUAVAWH|$@H!t$0HA_AA]A\_]VWATAVAWHSUVWATAUAVAWH(A_AA]A\_][@USVWATAVAWHA_AA\_[]UVWATAUAVAWHA_AA]A\_]@USVWAVH` UAUAVHWATAUAVAWH A_AA]A\_x ATAVAWHUSVWATAUAVAWHA_AA]A\_[]UVWATAUAVAWHA_AA]A\_]\$ UVWATAUAVAWHA_AA]A\_]x UATAUAVAWHA_AA]A\]@USVWAVHUVWATAUAVAWHA_AA]A\_]UVWATAUAVAWHA_AA]A\_]@USVWATAVAWHA_AA\_[]t$ UWAVH@USVWAVHUVWAVAWHh VWATAVAWHUVWAVAWHUVWATAUAVAWHpA_AA]A\_]WATAUAVAWH0A_AA]A\_L$ UVWATAUAVAWH@A_AA]A\_]UVWATAUAVAWH`A_AA]A\_]UVWATAUAVAWHpA_AA]A\_]@USVWATAVAWHD$0fD9 tA_AA\_[]"</pre>
<p>Due to the size of the example project, we will be diving into the code for each of the different components before running the applications at the end of this section, in the following order:</p>
<ul>
<li><span>The .NET Core library for common code between the two applications</span></li>
<li>The ASP.NET Blazor web application for running the prediction</li>
<li>The .NET Core console application for feature extraction and training</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the library</h1>
                </header>
            
            <article>
                
<p>The classes and enumerations that were changed or added are as follows:</p>
<ul>
<li><kbd>FileClassificationResponseItem</kbd></li>
<li><kbd>Converters</kbd></li>
<li><kbd>ExtensionMethods</kbd></li>
<li><kbd>HashingExtension</kbd></li>
<li><kbd>FileData</kbd></li>
<li><kbd>FileDataPrediction</kbd></li>
<li><kbd>FileClassificationFeatureExtractor</kbd></li>
<li><kbd>FileClassificationPredictor</kbd></li>
<li><kbd>FileClassificationTrainer</kbd></li>
</ul>
<p>The <kbd>Constants</kbd> and <kbd>BaseML</kbd> classes remain unmodified from <a href="a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml">Chapter 8</a>, <em>Using ML.NET with .NET Core and Forecasting</em>.</p>
<div class="packt_tip">Due to the nature of this application and that of production applications, where there are multiple platforms and/or ways to execute shared code, a library is used in this chapter's example application. The benefit of using a library is that all common code can reside in a portable and dependency-free manner. Expanding the functionality in this sample application to include desktop or mobile applications would be a much easier lift than having the code either duplicated or kept in the actual applications.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FileClassificationResponseItem class</h1>
                </header>
            
            <article>
                
<p>The <kbd>FileClassificationResponseItem</kbd> class is the common class that contains the properties that are used to feed our model, and is also used to return back to the end user in the web application.</p>
<ol>
<li>First,<span> we define the <kbd>TRUE</kbd> and <kbd>FALSE</kbd> mapping to <kbd>1.0f</kbd> and <kbd>0.0f</kbd> respectively, like this:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">private const float TRUE = 1.0f;<br/>private const float FALSE = 0.0f;</pre></div>
<ol start="2">
<li>Next, we add all of the properties to be used to feed our model and display it back to the end user in the web application. The <kbd>FileSize</kbd>, <kbd>Is64Bit</kbd>, <span><kbd>NumImports</kbd>, </span> <kbd>NumImportFunctions</kbd>, <kbd>NumExportFunctions</kbd>, <kbd>IsSigned</kbd>, and <kbd>Strings</kbd> properties are used specifically as features in our model. The <kbd>SHA1Sum</kbd>, <kbd>Confidence</kbd>, <kbd>IsMalicious</kbd>, and <kbd>ErrorMessage</kbd> properties are used to return our classification back to the end user, as illustrated in the following code block:</li>
</ol>
<div>
<pre style="padding-left: 60px">public string SHA1Sum { get; set; }<br/><br/>public double Confidence { get; set; }<br/><br/>public bool IsMalicious { get; set; }<br/><br/>public float FileSize { get; set; }<br/><br/>public float Is64Bit { get; set; }<br/><br/>public float NumImports { get; set; }<br/><br/>public float NumImportFunctions { get; set; }<br/><br/>public float NumExportFunctions { get; set; }<br/><br/>public float IsSigned { get; set; }<br/><br/>public string Strings { get; set; }<br/><br/>public string ErrorMessage { get; set; }</pre></div>
<ol start="3">
<li><span>Next, we have the constructor method.  The constructor, as you can see, has a byte array as a parameter. This was done to facilitate both the training and prediction paths in both of the applications, the idea being that the raw file bytes will come into the constructor from a <kbd>File.ReadAllBytes</kbd> call or other mechanisms, to provide flexibility. From there, we use the <kbd>PeNet</kbd> NuGet package. This package provides an easy-to-use interface for extracting features from a Windows Executable (also known as a PE file). For the scope of this application, a couple of features were chosen to be extracted and stored into the respective properties, as shown in the following code block:</span></li>
</ol>
<pre style="padding-left: 60px">public FileClassificationResponseItem(byte[] fileBytes)<br/>{<br/>    SHA1Sum = fileBytes.ToSHA1();<br/>    Confidence = 0.0;<br/>    IsMalicious = false;<br/>    FileSize = fileBytes.Length;<br/><br/>    try<br/>    {<br/>        var peFile = new PeNet.PeFile(fileBytes);<br/><br/>        Is64Bit = peFile.Is64Bit ? TRUE : FALSE;<br/><br/>        try<br/>        {<br/>            NumImports = peFile.ImageImportDescriptors.Length;<br/>        }<br/>        catch<br/>        {<br/>            NumImports = 0.0f;<br/>        }<br/><br/>        NumImportFunctions = peFile.ImportedFunctions.Length;<br/><br/>        if (peFile.ExportedFunctions != null)<br/>        {<br/>            NumExportFunctions = peFile.ExportedFunctions.Length;<br/>        }<br/><br/>        IsSigned = peFile.IsSigned ? TRUE : FALSE;<br/><br/>        Strings = fileBytes.ToStringsExtraction();<br/>    }<br/>    catch (Exception)<br/>    {<br/>        ErrorMessage = $"Invalid file ({SHA1Sum}) - only PE files are supported";<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FileData class</h1>
                </header>
            
            <article>
                
<p>The <kbd>FileData</kbd> class, as with previous containers of prediction data, provides our model with the fields necessary to provide a file classification. In addition, we overrode the<span> </span><kbd>ToString</kbd> method to ease the exporting of this data to a <strong>comma-separated values</strong> (<strong>CSV</strong>) file during our feature extraction step, as follows:</p>
<pre>public class FileData<br/>{<br/>    [LoadColumn(0)]<br/>    public float FileSize { get; set; }<br/><br/>    [LoadColumn(1)]<br/>    public float Is64Bit { get; set; }<br/><br/>    [LoadColumn(2)]<br/>    public float NumberImportFunctions { get; set; }<br/><br/>    [LoadColumn(3)]<br/>    public float NumberExportFunctions { get; set; }<br/><br/>    [LoadColumn(4)]<br/>    public float IsSigned { get; set; }<br/><br/>    [LoadColumn(5)]<br/>    public float NumberImports { get; set; }<br/><br/>    [LoadColumn(6)]<br/>    public bool Label { get; set; }<br/><br/>    [LoadColumn(7)]<br/>    public string Strings { get; set; }<br/><br/>    public override string ToString() =&gt; $"{FileSize}\t{Is64Bit}\t{NumberImportFunctions}\t" +<br/>                                         $"{NumberExportFunctions}\t{IsSigned}\t{NumberImports}\t" +<br/>                                         $"{Label}\t\"{Strings}\"";<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FileDataPrediction class</h1>
                </header>
            
            <article>
                
<p>The <kbd>FileDataPrediction</kbd> class contains the prediction's classification and probability properties to return to the end user in our web application, as shown in the following code block:</p>
<div>
<pre>public class FileDataPrediction<br/>{<br/>    public bool Label { get; set; }<br/><br/>    public bool PredictedLabel { get; set; }<br/><br/>    public float Score { get; set; }<br/><br/>    public float Probability { get; set; }<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Converters class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Converters</kbd> class provides an extension method to convert the <kbd>FileClassificationResponseItem</kbd> class—reviewed earlier in this section—to the <kbd>FileData</kbd> class. By making an extension method, as shown in the following code block, we can quickly and cleanly convert between the application container and our model-only container:</p>
<div>
<pre>public static class Converters<br/>{<br/>    public static FileData ToFileData(this FileClassificationResponseItem fileClassification)<br/>    {<br/>        return new FileData<br/>        {<br/>            Is64Bit = fileClassification.Is64Bit,<br/>            IsSigned = fileClassification.IsSigned,<br/>            NumberImports = fileClassification.NumImports,<br/>            NumberImportFunctions = fileClassification.NumImportFunctions,<br/>            NumberExportFunctions = fileClassification.NumExportFunctions,<br/>            FileSize = fileClassification.FileSize,<br/>            Strings = fileClassification.Strings<br/>        };<br/>    }<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ExtensionMethods class</h1>
                </header>
            
            <article>
                
<p>The <kbd>ExtensionMethods</kbd> class, as shown in previous chapters, contains helper extension methods. In this example, we will be adding in the <kbd>ToStrings</kbd> extension method. Strings are a highly popular first pass and an easy-to-capture feature when making a classification of a file. Let's dive into the method, as follows:</p>
<ol>
<li>First, we define two new constants for handling the buffer size and the encoding. As mentioned earlier, <kbd>1252</kbd> is the encoding in which Windows Executables are encoded, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">private const int BUFFER_SIZE = 2048;<br/>private const int FILE_ENCODING = 1252;</pre>
<ol start="2">
<li>The next change is the addition of the <kbd>ToStringsExtraction</kbd> method itself and defining our regular expression, as follows:</li>
</ol>
<pre style="padding-left: 60px">public static string ToStringsExtraction(this byte[] data)<br/>{<br/>     var stringRex = new Regex(@"[ -~\t]{8,}", RegexOptions.Compiled);</pre>
<p style="padding-left: 60px">This regular expression is what we will use to traverse the file's bytes.</p>
<ol start="3">
<li>Next, we initialize the <kbd>StringBuilder</kbd> class and check if the passed-in byte array is null or empty (if it is, we can't process it), like this:</li>
</ol>
<pre style="padding-left: 60px">var stringLines = new StringBuilder();<br/><br/>if (data == null || data.Length == 0)<br/>{<br/>     return stringLines.ToString();<br/>}</pre>
<ol start="4">
<li>Now that we have confirmed there are bytes in the passed-in array, we only want to take up to <kbd>65536</kbd> bytes. The reason for this is that if the file is 100 MB, this operation could take significant time to perform. Feel free to adjust this number and see the efficacy results. The code is shown here:</li>
</ol>
<pre style="padding-left: 60px">var dataToProcess = data.Length &gt; 65536 ? data.Take(65536).ToArray() : data;</pre>
<ol start="5">
<li>Now that we have the bytes we are going to analyze, we will loop through and extract lines of text found in the bytes, as follows:</li>
</ol>
<pre style="padding-left: 60px">using (var ms = new MemoryStream(dataToProcess, false))<br/>{<br/>    using (var streamReader = new StreamReader(ms, Encoding.GetEncoding(FILE_ENCODING), false, BUFFER_SIZE, false))<br/>    {<br/>        while (!streamReader.EndOfStream)<br/>        {<br/>            var line = streamReader.ReadLine();<br/><br/>            if (string.IsNullOrEmpty(line))<br/>            {<br/>                continue;<br/>            }<br/><br/>            line = line.Replace("^", "").Replace(")", "").Replace("-", "");<br/><br/>            stringLines.Append(string.Join(string.Empty,<br/>                stringRex.Matches(line).Where(a =&gt; !string.IsNullOrEmpty(a.Value) &amp;&amp; !string.IsNullOrWhiteSpace(a.Value)).ToList()));<br/>        }<br/>    }<br/>}</pre>
<ol start="6">
<li>Finally, we simply return the lines joined into a single string, like this:</li>
</ol>
<pre style="padding-left: 60px">return string.Join(string.Empty, stringLines);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HashingExtensions class</h1>
                </header>
            
            <article>
                
<p>The new <kbd>HashingExtensions</kbd> class <span><span>converts </span></span>our byte array to a SHA1 string. The reason for not putting this with our other extension methods is to provide a common class to potentially hold SHA256, ssdeep, or other hashes (especially given the recent SHA1 collisions, proving SHA1 to be insecure).</p>
<p>For this method, we're using the built-in .NET Core <kbd>SHA1</kbd> class, and then converting it to a Base64 string with a call to <kbd>ToBase64String</kbd>, as follows:</p>
<pre>public static class HashingExtension<br/>{<br/>    public static string ToSHA1(this byte[] data)<br/>    {<br/>        var sha1 = System.Security.Cryptography.SHA1.Create();<br/><br/>        var hash = sha1.ComputeHash(data);<br/><br/>        return Convert.ToBase64String(hash);<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FileClassificationFeatureExtractor class</h1>
                </header>
            
            <article>
                
<p>The <kbd>FileClassificationFeatureExtractor</kbd> class contains our <kbd>Extract</kbd> and <kbd>ExtractFolder</kbd> methods:</p>
<ol>
<li>First, our <kbd>ExtractFolder</kbd> method takes in the folder path and the output file that will contain our feature extraction, as shown in the following code block:</li>
</ol>
<div>
<pre style="padding-left: 60px">private void ExtractFolder(string folderPath, string outputFile)<br/>{<br/>    if (!Directory.Exists(folderPath))<br/>    {<br/>        Console.WriteLine($"{folderPath} does not exist");<br/><br/>        return;<br/>    }<br/><br/>    var files = Directory.GetFiles(folderPath);<br/><br/>    using (var streamWriter =<br/>        new StreamWriter(Path.Combine(AppContext.BaseDirectory, $"../../../../{outputFile}")))<br/>    {<br/>        foreach (var file in files)<br/>        {<br/>            var extractedData = new FileClassificationResponseItem(File.ReadAllBytes(file)).ToFileData();<br/><br/>            extractedData.Label = !file.Contains("clean");<br/><br/>            streamWriter.WriteLine(extractedData.ToString());<br/>        }<br/>    }<br/><br/>    Console.WriteLine($"Extracted {files.Length} to {outputFile}");<br/>}     </pre></div>
<ol start="2">
<li>Next, we use the <kbd>Extract</kbd> method to call both the training and test extraction, as follows:</li>
</ol>
<div>
<pre style="padding-left: 60px">public void Extract(string trainingPath, string testPath)<br/>{<br/>    ExtractFolder(trainingPath, Constants.SAMPLE_DATA);<br/>    ExtractFolder(testPath, Constants.TEST_DATA);<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FileClassificationPredictor class</h1>
                </header>
            
            <article>
                
<p>The <kbd>FileClassificationPredictor</kbd> class provides the interface for both our command-line and web applications, using an overloaded <kbd>Predict</kbd> method:</p>
<ol>
<li>The first <kbd>Predict</kbd> method is for our command-line application that simply takes in the filename and is called into the overload in <em>Step 2</em> after loading in the bytes, as follows:</li>
</ol>
<pre style="padding-left: 60px">public FileClassificationResponseItem Predict(string fileName)<br/>{<br/>    var bytes = File.ReadAllBytes(fileName);<br/><br/>    return Predict(new FileClassificationResponseItem(bytes));<br/>}</pre>
<ol start="2">
<li>The second implementation is for our web application that takes the <kbd>FileClassificationResponseItem</kbd> object, creates our prediction engine, and returns the prediction data, as follows:</li>
</ol>
<pre style="padding-left: 60px">public FileClassificationResponseItem Predict(FileClassificationResponseItem file)<br/>{<br/>    if (!File.Exists(Common.Constants.MODEL_PATH))<br/>    {<br/>        file.ErrorMessage = $"Model not found ({Common.Constants.MODEL_PATH}) - please train the model first";<br/><br/>        return file;<br/>    }<br/><br/>    ITransformer mlModel;<br/><br/>    using (var stream = new FileStream(Common.Constants.MODEL_PATH, FileMode.Open, FileAccess.Read, FileShare.Read))<br/>    {<br/>        mlModel = MlContext.Model.Load(stream, out _);<br/>    }<br/><br/>    var predictionEngine = MlContext.Model.CreatePredictionEngine&lt;FileData, FileDataPrediction&gt;(mlModel);<br/><br/>    var prediction = predictionEngine.Predict(file.ToFileData());<br/><br/>    file.Confidence = prediction.Probability;<br/>    file.IsMalicious = prediction.PredictedLabel;<br/><br/>    return file;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FileClassificationTrainer class</h1>
                </header>
            
            <article>
                
<p>The last class added in the library is the <kbd>FileClassificationTrainer</kbd> class. This class supports the use of the <kbd>FastTree</kbd> ML.NET trainer, as well as utilizing our features we have extracted from the files:</p>
<ol>
<li>The first change is the use of the <kbd>FileData</kbd> class to read the CSV file into the <kbd>dataView</kbd> property, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">var dataView = MlContext.Data.LoadFromTextFile&lt;FileData&gt;(trainingFileName, hasHeader: false);</pre>
<p>             2. Next, we map our <kbd>FileData</kbd> features to create our pipeline, as follows:</p>
<pre style="padding-left: 60px">var dataProcessPipeline = MlContext.Transforms.NormalizeMeanVariance(nameof(FileData.FileSize))<br/>    .Append(MlContext.Transforms.NormalizeMeanVariance(nameof(FileData.Is64Bit)))<br/>    .Append(MlContext.Transforms.NormalizeMeanVariance(nameof(FileData.IsSigned)))<br/>    .Append(MlContext.Transforms.NormalizeMeanVariance(nameof(FileData.NumberImportFunctions)))<br/>    .Append(MlContext.Transforms.NormalizeMeanVariance(nameof(FileData.NumberExportFunctions)))<br/>    .Append(MlContext.Transforms.NormalizeMeanVariance(nameof(FileData.NumberImports)))<br/>    .Append(MlContext.Transforms.Text.FeaturizeText("FeaturizeText", nameof(FileData.Strings)))<br/>    .Append(MlContext.Transforms.Concatenate(FEATURES, nameof(FileData.FileSize), nameof(FileData.Is64Bit),<br/>        nameof(FileData.IsSigned), nameof(FileData.NumberImportFunctions), nameof(FileData.NumberExportFunctions),<br/>        nameof(FileData.NumberImports), "FeaturizeText"));</pre>
<p>             3. Lastly, we initialize our <kbd>FastTree</kbd> algorithm, as follows:</p>
<pre style="padding-left: 60px">var trainer = MlContext.BinaryClassification.Trainers.FastTree(labelColumnName: nameof(FileData.Label),<br/>    featureColumnName: FEATURES,<br/>    numberOfLeaves: 2,<br/>    numberOfTrees: 1000,<br/>    minimumExampleCountPerLeaf: 1,<br/>    learningRate: 0.2);</pre>
<p>The rest of the method is similar to our previous binary classification <kbd>Train</kbd> method in <a href="4c32e261-cec6-4113-9734-1e29c7c18f9a.xhtml">Chapter 5</a>, <em>Clustering Models</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the web application</h1>
                </header>
            
            <article>
                
<p>With the library code having been reviewed, the next component is the web application. As discussed in the opening section, our web application is an ASP.NET Core Blazor application. For the scope of this example, we are using standard approaches for handling the backend and frontend. The architecture of this app combines both Blazor and ASP.NET Core—specifically, using ASP.NET Core to handle the REST service component of the app.</p>
<p>The files we will be diving into in this section are the following ones:</p>
<ul>
<li><kbd>UploadController</kbd></li>
<li><kbd>Startup</kbd></li>
<li><kbd>Index.razor</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The UploadController class</h1>
                </header>
            
            <article>
                
<p>The purpose of the <kbd>UploadController</kbd> class is to handle the server-side processing of the file once submitted. For those having used ASP.NET MVC or Web API in the past, this controller should look very familiar:</p>
<ol>
<li>The first thing to note is the attribute tags decorating the class. The <kbd>ApiController</kbd> attribute configures the controller to handle HTTP APIs, while the <kbd>Route</kbd> tag indicates the controller will be listening on the <kbd>/Upload</kbd> path, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">[ApiController]<br/>[Route("[controller]")]<br/>public class UploadController : ControllerBase</pre>
<ol start="2">
<li>The next thing to note is the use of <strong>Dependency Injection</strong> (<strong>DI</strong>) in the constructor of <kbd>UploadController</kbd> passing in the predictor object. DI is a powerful approach to providing access to singleton objects such as <kbd>FileClassificationPredictor</kbd> or databases, and is illustrated in the following code block:</li>
</ol>
<pre style="padding-left: 60px">private readonly FileClassificationPredictor _predictor;<br/><br/>public UploadController(FileClassificationPredictor predictor)<br/>{<br/>    _predictor = predictor;<br/>}</pre>
<ol start="3">
<li>Next, we create a helper method to handle taking the <kbd>IFormFile</kbd> from the HTTP post and returning all of the bytes, as follows:</li>
</ol>
<pre style="padding-left: 60px">private static byte[] GetBytesFromPost(IFormFile file)<br/>{<br/>    using (var ms = new BinaryReader(file.OpenReadStream()))<br/>    {<br/>        return ms.ReadBytes((int)file.Length);<br/>    }<br/>}</pre>
<ol start="4">
<li>Lastly, we create the <kbd>Post</kbd> method. The <kbd>HttpPost</kbd> attribute tells the routing engine to listen for only a <kbd>HttpPost</kbd> call. The method handles taking the output of the <kbd>GetBytesFromPost</kbd> method call, creates the <kbd>FileClassificationResponseItem</kbd> object, and then returns the prediction, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">[HttpPost]<br/>public FileClassificationResponseItem Post(IFormFile file)<br/>{<br/>    if (file == null)<br/>    {<br/>        return null;<br/>    }<br/><br/>    var fileBytes = GetBytesFromPost(file);<br/><br/>    var responseItem = new FileClassificationResponseItem(fileBytes);<br/><br/>    return _predictor.Predict(responseItem);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Startup class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Startup</kbd> class in both an ASP.NET Core and Blazor app controls the initialization of the various services used in the web application. Two major changes have been made to the <kbd>Startup</kbd> template that comes with Visual Studio, as follows:</p>
<ol>
<li>The first change is in the <kbd>ConfigureServices</kbd> method. Because this was a combined application of both ASP.NET Core and Blazor, we need to call the <kbd>AddControllers</kbd> method. In addition, we are going to utilize DI and initialize the predictor object once, prior to adding it as a singleton, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddRazorPages();<br/>    services.AddControllers();<br/>    services.AddServerSideBlazor();<br/><br/>    services.AddSingleton&lt;FileClassificationPredictor&gt;();<br/>    services.AddSingleton&lt;HttpClient&gt;();<br/>}</pre>
<ol start="2">
<li>The second change comes in the <kbd>Configure</kbd> method. The first thing is to register the <kbd>CodePages</kbd> instance. Without this call, the feature extraction call to reference the Windows-1252 encoding will cause an exception (we will add this call to the trainer application as well, in the next section). The second <span>thing </span>is to configure the use of <kbd>MapControllerRoute</kbd>, as illustrated in the following code block:</li>
</ol>
<pre style="padding-left: 60px">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br/>{<br/>    Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);<br/><br/>    if (env.IsDevelopment())<br/>    {<br/>        app.UseDeveloperExceptionPage();<br/>    }<br/>    else<br/>    {<br/>        app.UseExceptionHandler("/Error");<br/>    }<br/><br/>    app.UseStaticFiles();<br/><br/>    app.UseRouting();<br/><br/>    app.UseEndpoints(endpoints =&gt;<br/>    {<br/>        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");<br/>        endpoints.MapBlazorHub();<br/>        endpoints.MapFallbackToPage("/_Host");<br/>    });<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Index.razor file</h1>
                </header>
            
            <article>
                
<p>The <kbd>Index.razor</kbd> file contains the frontend to our file classification web application. In addition, it contains the REST call to our <kbd>UploadController</kbd> class described earlier in this section. For this deep dive, we will specifically look at the Blazor code block, as follows:</p>
<ol>
<li>The first thing to note is the declaration of our <kbd>FileClassificationResponseItem</kbd> class. We define the variable in this block, as it will allow access throughout the page. The second element is the declaration of our <kbd>HandleSelection</kbd> method, as illustrated in the following code block:</li>
</ol>
<pre style="padding-left: 60px">FileClassificationResponseItem _classificationResponseItem;<br/><br/>async Task HandleSelection(IEnumerable&lt;IFileListEntry&gt; files) {</pre>
<ol start="2">
<li class="mce-root">Next, we take the first file, convert it to an array of bytes, and create the <kbd>MultipartFormdataContent</kbd> object to POST to the previously described <kbd>Post</kbd> method, as follows:</li>
</ol>
<pre style="padding-left: 60px">var file = files.FirstOrDefault();<br/><br/>if (file != null)<br/>{<br/>    var ms = new MemoryStream();<br/>    await file.Data.CopyToAsync(ms);<br/><br/>    var content = new MultipartFormDataContent {<br/>        {<br/>            new ByteArrayContent(ms.GetBuffer()), "file", file.Name<br/>        }<br/>    };</pre>
<ol start="3">
<li>Lastly, we POST the file to our <kbd>UploadController</kbd> endpoint and asynchronously await the response from our ML.NET prediction, before assigning the response to our response variable, <kbd>_classificationResponseItem</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">var response = await client.PostAsync("http://localhost:5000/upload/", content);<br/><br/>var jsonResponse = await response.Content.ReadAsStringAsync();<br/><br/>_classificationResponseItem = JsonSerializer.Deserialize&lt;FileClassificationResponseItem&gt;(jsonResponse, new JsonSerializerOptions<br/>{<br/>    PropertyNameCaseInsensitive = true<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the trainer application</h1>
                </header>
            
            <article>
                
<p>Now that we have reviewed the shared library and the web application,  let's dive into the trainer application.</p>
<p>We will review the following files:</p>
<ul>
<li><kbd>ProgramArguments</kbd></li>
<li><kbd>ProgramActions</kbd></li>
<li><kbd>Program</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ProgramArguments class</h1>
                </header>
            
            <article>
                
<p>Building off the work in the <kbd>ProgramArguments</kbd> class detailed in <a href="a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml">Chapter 8</a>, <em>Using ML.NET with .NET Core and Forecasting</em>, we are only making one addition to the class. This change adds properties to store the <kbd>Testing</kbd> and <kbd>Training</kbd> folder paths, and is illustrated in the following code block:</p>
<div>
<pre>public string TestingFolderPath { get; set; }<br/><br/>public string TrainingFolderPath { get; set; }</pre></div>
<p>Unlike the previous chapter, feature extraction is based on a number of Windows executable files, as opposed to just an included CSV file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ProgramActions enumeration</h1>
                </header>
            
            <article>
                
<p>The first change is in the <kbd>ProgramActions</kbd> enumeration. In <a href="a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml">Chapter 8</a>, <em>Using ML.NET with .NET Core and Forecasting</em>, we had only training and prediction. However, as mentioned earlier in this chapter, we now also have <kbd>FeatureExtraction</kbd> to perform. To add support, we simply add <kbd>FEATURE_EXTRACTOR</kbd> to the enumeration, like so:</p>
<pre>public enum ProgramActions<br/>{<br/>    FEATURE_EXTRACTOR,<br/>    TRAINING,<br/>    PREDICT<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Program class</h1>
                </header>
            
            <article>
                
<p>Inside the <kbd>Program</kbd> class, there are only two changes from the previous chapter's overhaul of the command-line argument parsing, as follows:</p>
<ol>
<li>First, we need to register the <kbd>CodePages</kbd> encoder instance to properly read the Windows-1252 encoding from the files as we did in the web application, as follows:</li>
</ol>
<div>
<pre style="padding-left: 60px">Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);</pre></div>
<ol start="2">
<li class="mce-root">We then can use a simplified and strongly typed switch case to handle our three actions, as follows:</li>
</ol>
<div>
<pre style="padding-left: 60px">switch (arguments.Action)<br/>{<br/>    case ProgramActions.FEATURE_EXTRACTOR:<br/>        new FileClassificationFeatureExtractor().Extract(arguments.TrainingFolderPath,<br/>            arguments.TestingFolderPath);<br/>        break;<br/>    case ProgramActions.PREDICT:<br/>        var prediction = new FileClassificationPredictor().Predict(arguments.PredictionFileName);<br/><br/>        Console.WriteLine($"File is {(prediction.IsMalicious ? "malicious" : "clean")} with a {prediction.Confidence:P2}% confidence");<br/>        break;<br/>    case ProgramActions.TRAINING:<br/>        new FileClassificationTrainer().Train(arguments.TrainingFileName, arguments.TestingFileName);<br/>        break;<br/>    default:<br/>        Console.WriteLine($"Unhandled action {arguments.Action}");<br/>        break;<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the trainer application</h1>
                </header>
            
            <article>
                
<p><span>To begin, we will need to first run the <kbd>chapter09.trainer</kbd> application to perform feature extraction and training of our model. To run the trainer application, the process is nearly identical to the sample application shown in <a href="8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml">Chapter 3</a>, <em>Regression Model</em>, with the addition of passing in the test dataset folder path when training, and we will follow these steps:</span></p>
<ol>
<li>We will run the trainer application, passing in the paths to the training and test folders to perform feature extraction, as follows:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS chapter09\chapter09.trainer\bin\Debug\netcoreapp3.1&gt; .\chapter09.trainer.exe trainingfolderpath ..\..\..\..\TrainingData\ testingfolderpath ..\..\..\..\TestData\</strong><br/>Extracted 14 to sampledata.data<br/>Extracted 14 to testdata.data</pre></div>
<div class="packt_infobox"><span>Included in the code repository are two pre-feature extracted files (</span><kbd>sampledata.csv</kbd><span> and t</span><kbd>estdata.csv</kbd><span>) to allow you to train a model without performing your own feature extraction.  If you would like to perform your own feature extraction, create a </span><kbd>TestData</kbd><span> and </span><kbd>TrainingData</kbd><span> folder.  Populate these folders with a sampling of </span><strong><span>PowerShell </span></strong><span>(</span><span><strong>PS1</strong></span><span>), </span><span><strong>Windows Executables</strong> </span><span>(</span><strong><span>EXE </span></strong><span>) and </span><span><strong>Microsoft Word documents</strong> </span><span>(</span><strong><span>DOCX</span></strong><span>).</span></div>
<ol start="2">
<li>Now, we will again run the application to train the model based on <em>Step 1</em> sample and test data exports. The resulting model (<kbd><span>fileclassification.mdl</span></kbd>) will be in the same folder as the executable, as follows:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS chapter09\chapter09.trainer\bin\Debug\netcoreapp3.1&gt; .\chapter09.trainer.exe action training trainingfilename ..\..\..\..\sampledata.data testingfilename ..\..\..\..\testdata.data</strong><br/>Entropy: 0.5916727785823275<br/>Log Loss: 12.436063032030377<br/>Log Loss Reduction: -20.018480961432264</pre></div>
<p style="padding-left: 60px">Feel free to modify the values and see how the prediction changes based on the dataset on which the model was trained. A few areas of experimentation from this point might be to do the following:</p>
<ul>
<li style="padding-left: 60px">Tweak the hyperparameters reviewed in the <kbd>Trainer</kbd> class—such as the <kbd>numberOfLeaves</kbd>, <kbd>numberOfTrees</kbd>, and <kbd>learningRate</kbd>—to see how accuracy is affected.</li>
<li style="padding-left: 60px">Add new features to the <kbd>FileData</kbd> class, such as specific imports, instead of using just the count.</li>
<li style="padding-left: 60px">Add more variation to the training and sample set to get a better sampling of data.</li>
</ul>
<p>For convenience, the GitHub repository includes both the <kbd>testdata.csv</kbd> and <kbd>sampledata.csv</kbd> files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the web application</h1>
                </header>
            
            <article>
                
<p>Now that our model has been trained, we can run our web application and test the submission of a file. You must first build the web application if you haven't already. This will create the <kbd>bin\debug\netcoreapp3.1</kbd> folder. After building the web application, copy the model we trained in the previous section. At this point, start the web application. Upon starting, you should see the following in your default browser:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-612 image-border" src="assets/853d9d5f-3a41-4867-aeec-bc598f0bebea.png" style="width:45.75em;height:11.42em;"/></p>
<p>Proceed to click on the <span class="packt_screen">Choose File</span> button, select an <kbd>.exe</kbd> or <kbd>.dll</kbd> file, and you should see the following results from our model:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-613 image-border" src="assets/097bd073-ce7c-4952-a75d-855b741af60b.png" style="width:47.58em;height:19.33em;"/></p>
<p>Feel free to try various files on your machine to see the confidence score, and if you receive a false positive, perhaps add additional features to the model to correct the classification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring additional ideas for improvements</h1>
                </header>
            
            <article>
                
<p>Now that we have completed our deep dive, there are a couple of additional elements to possibly further enhance the application. A few ideas are discussed next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging</h1>
                </header>
            
            <article>
                
<p>As with our previous chapter's deep dive into logging, adding logging could be crucial to remotely understand when an error occurs on a web application. Logging utilizing<span> </span>NLog<span> </span>(<a href="https://nlog-project.org/">https://nlog-project.org/</a>) or a similar open source project is highly recommended as your application complexity increases. This will allow you to log to a file, console, or third-party logging solution—such as Loggly—at varying levels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing a caching layer</h1>
                </header>
            
            <article>
                
<p>Imagine deploying this application on a public-facing web server and having hundreds of concurrent users. Chances are that users might upload the same file—caching the results in memory would avoid unnecessary CPU processing to run the prediction every time. Some caching options include utilizing the ASP.NET in-memory caching, or external caching databases such as Redis. These are both available via NuGet packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing a database</h1>
                </header>
            
            <article>
                
<p>On a similar note to the caching suggestion, recording the results in a database could avoid unnecessary CPU processing. A logical choice would be to utilize a NoSQL database such as MongoDB. Using the SHA1 hash as the key and the value as the full JSON response could significantly improve performance in a high-traffic scenario. MongoDB has a .NET interface available on NuGet called <kbd>MongoDB.Driver</kbd>. Version 2.10.0 is the latest at the time of writing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Over the course of this chapter, we have discussed what goes into a production-ready ASP.NET Core Blazor web application architecture, using the work performed in previous chapters as a foundation. We also created a brand new file classification web application utilizing the FastTree binary classifier from ML.NET. Lastly, we also discussed some ways to further enhance an ASP.NET Core application (and production applications in general).</p>
<p>In the next chapter, we will deep dive into creating a production web browser using the content of a web page to determine if the content is malicious or not, using ML.NET's sentiment analysis and the UWP framework.</p>


            </article>

            
        </section>
    </body></html>