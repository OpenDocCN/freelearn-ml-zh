- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prompt Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we gave some historical context to how AI has developed
    over the years, how we’ve gone from **natural language processing** (**NLP**)
    to **large language models** (**LLMs**), and how the latter serves as the underlying
    machine learning model in AI assistants. To use these AI assistants, you use natural
    language prompts as input. However, to ensure you “prompt” in an efficient way,
    so that you get what you want, it’s important to have a strategy, and that’s what
    this chapter aims to give you.
  prefs: []
  type: TYPE_NORMAL
- en: 'How to “prompt” efficiently is commonly known in the industry as a “prompt
    strategy” or “prompt engineering.” It’s not an engineering practice in the common
    sense of the word but rather an art form where practitioners of AI assistants
    have discovered patterns and practices that seem to work well. We, the authors
    of this book, are building upon those discovered practices and aim to describe
    our findings for two domains: full-stack web development and data science. This
    book turns to you as either a web developer or data scientist and aims to empower
    you by describing how you can best approach problem solving in your domain using
    an AI assistant.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter constitutes a central piece of the book. It’s central in the sense
    that the approach being taught will be exemplified by other chapters in the book.
    As such, see this chapter as a guide you can refer to, providing the theory and
    thinking that is used in future chapters that solve specific problems within data
    science and full-stack web development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a strategy for solving problems with prompts and validating the solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illustrate the strategy with examples from data science and full-stack web development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify some basic principles for writing prompts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where you are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a reader and a practitioner of data science and/or full-stack web development,
    you know your craft. Knowing your craft means you know the tools and techniques
    to solve problems. At this point, you’re looking at an AI assistant and realize
    it’s controlled by natural language, so-called prompts. What you may not realize
    is that there’s more to it than just writing a prompt and getting an answer. An
    AI assistant is trained on a large corpus of text, so it’s quite flexible on what
    it can generate text on and how to respond to prompts. Because of this flexibility,
    it’s important to understand how to write prompts that are effective and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for how to prompt efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prompts are input to AI tools. Depending on what you’re trying to achieve, you
    need to adjust your prompts for the scenario you’re solving for. Therefore, how
    you “prompt” matters. For example, if your prompt is too vague, you won’t get
    what you need. Or, let’s say you’re trying to use a prompt to generate company
    slogans; you don’t want to use the same prompt for generating code for an app.
    Conversely, in a discipline like data science, it’s important you perform tasks
    in a certain order and your prompt should reflect what you want done and, if needed,
    the steps to do so.
  prefs: []
  type: TYPE_NORMAL
- en: What you need to succeed is an approach, a strategy, that you can use in general
    to be efficient with AI assistants. Additionally, such a strategy should be specific
    enough to present “best practices” for chosen problem domains. As mentioned earlier
    in this chapter, we’ve developed a prompt strategy specifically for the domain’s
    full-stack web development and data science.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, we suggest the guidelines for general problem-solving using
    AI assistants; it’s our belief it holds true regardless of what problem domain
    you’re applying prompts to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Break down the problem** so that it’s fully understood. Within this guideline,
    there might be several steps like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Understand the problem**: For any problem, it’s important to understand what
    the problem is and what it’s not. For example, are we building a machine learning
    model to predict sales or a web page to track inventory? These are two different
    problems and require different approaches.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify the parts**: A problem is usually complex and consists of many parts
    that need to be solved. For example, if we’re building a machine learning model
    to predict sales, we need to identify the data, the model, the training, and the
    evaluation. Each of these parts can be broken down into smaller parts and so on.
    Once you find the right detail level for your problem, you can start solving it
    by writing prompts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Break down the problem into smaller pieces**: If needed, break down your
    problem into smaller more manageable pieces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify and understand the data**: Especially with machine learning, it’s
    crucial to identify a dataset to work with, what it contains, and how it’s structured.
    Within web development, data also plays a central role, but the goal is usually
    to ensure you can read, write, and present data in a way that’s useful for the
    user.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generate prompts** at a suitable level. Once you’ve understood the problem
    fully, you should have a list of tasks, and for each task, you should be able
    to author and run a prompt that solves said task.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Validate the solution**. Just like without AI assistants, validation plays
    a crucial part in building systems or apps. Traditionally, that means writing
    tests, testing various components together, and letting users try out various
    parts. Using prompts is no different. A side effect of LLMs is that they can generate
    text that’s not relevant to the problem or solve the problem in a less-than-optimal
    way. Because you’re relying on prompts that end up generating code for you, it
    becomes extra important to validate the solution to ensure it is correct and relevant.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the upcoming sections, we will describe a detailed strategy for each chosen
    problem domain’s full-stack web development and data science.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some techniques that are extra useful when instructing the AI assistant
    to ensure you get the most out of it. The general advice is to provide enough
    context to the AI assistant but what that means exactly can be made more concrete
    via the below suggested patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Task-Action-Guideline Prompt Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persona-Instruction-Content Prompt Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploratory prompt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task-Action-Guideline prompt pattern (TAG)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To explain how this pattern works, let’s break down the parts and the show
    an example prompt with an example response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intent**: To instruct an AI assistant on what task to solve, what actions
    to take, and what guidelines to adhere to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task**: Clearly define the task you want the AI to accomplish'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action**: Specify the steps or actions the AI should take to complete the
    task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guideline**: Provide any rules, constraints, or guidelines the AI should
    follow while performing the task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Task: Generate a summary of the latest news article about climate change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Action:'
  prefs: []
  type: TYPE_NORMAL
- en: Search for the most recent news articles on climate change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the article with the highest relevance and credibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summarize the key points of the article in 3-4 sentences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Guideline:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the summary is concise and accurate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid using technical jargon; keep the language simple and accessible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cite the source of the article at the end of the summary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary: A recent article from BBC News highlights the alarming increase in
    global temperatures over the past decade. Scientists warn that if current trends
    continue, we could see unprecedented climate events. The article emphasizes the
    urgent need for international cooperation to combat climate change. [Source: BBC
    News]'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern helps ensure that the AI assistant understands the task, knows
    the steps to take, and adheres to any specific guidelines, leading to more accurate
    and useful outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what a prompt example could look like for web development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task**: Develop a RESTful API for a simple blog application using Node.js
    and Express.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Action**:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a new Node.js project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Express server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define routes for CRUD operations on blog posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement middleware for JSON parsing and error handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to a MongoDB database using Mongoose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests for the API endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Guideline**:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the project setup is clear and straightforward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide concise and accurate code examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid using overly complex terminology; keep the language simple and accessible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include comments in the code to explain each step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**[End prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Persona-Instruction-Context prompt pattern (PIC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s describe this pattern in the same way as the preceding one, let’s define
    it, followed by an example prompt and an example response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intent**: To instruct an AI assistant on the persona it should assume, what
    instructions to carry out, and provide enough context to generate a correct response.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persona**: Define the persona or character traits the AI should embody while
    responding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instruction**: Specify the tasks or actions the AI should perform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context**: Provide relevant background information or context to help the
    AI understand the situation and generate an appropriate response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Persona: Assume the persona of a friendly and knowledgeable travel guide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: Recommend three must-visit attractions in Paris.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a brief description of each attraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suggest the best time to visit each attraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Context: The user is planning a trip to Paris for the first time and is interested
    in both historical sites and local culture.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As your friendly and knowledgeable travel guide, I’d love to recommend three
    must-visit attractions in Paris:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. **Eiffel Tower**: This iconic landmark offers breathtaking views of the
    city. It’s best to visit in the early morning or late evening to avoid the crowds
    and enjoy the stunning sunrise or sunset.'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. **Louvre Museum**: Home to thousands of works of art, including the Mona
    Lisa, the Louvre is a treasure trove of history and culture. Plan your visit on
    a weekday morning to experience the museum with fewer visitors.'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. **Montmartre**: This charming neighborhood is known for its artistic history
    and vibrant street life. Visit in the late afternoon to explore the quaint streets
    and enjoy a leisurely dinner at a local café.'
  prefs: []
  type: TYPE_NORMAL
- en: Enjoy your trip to Paris!
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern ensures that the AI assistant adopts the right persona, follows
    specific instructions, and uses the provided context to deliver a relevant and
    helpful response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what such a prompt could like for web development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persona**: Assume the persona of a friendly and knowledgeable software development
    mentor.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction**:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a new Node.js project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Express server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define routes for CRUD operations on blog posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement middleware for JSON parsing and error handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to a MongoDB database using Mongoose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests for the API endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Context**: The user is a beginner in web development and is looking to build
    their first RESTful API for a blog application. They need clear, step-by-step
    guidance and code examples.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory prompt pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might find yourself in situations where you’re not building a project from
    start to finish, or you only want to build a smaller part of and then evaluate
    the response. In those cases, your prompts will be more exploratory in nature
    and can for example look like the below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Clean the data.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: An assumption here is that we have a Notebook open with existing code that has
    already fetched the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, something more for web development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Add CSS for this product list.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Prompts for this pattern are usually a lot shorter in length, has context (derived
    from existing code or in some other way) and the developer line of sight is seldom
    beyond the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Learn-Improvise-Feedback-Evaluate prompt pattern (LIFE)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pattern, like TAG and PIC helps frame the problem and provides a good start
    to a solution that you can further refine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Learn**: Highlight the need to understand data through various analytical
    techniques, from basic statistics to complex correlations and temporal analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improvise**: Adapt the analysis based on initial findings. For instance,
    if certain categories of products show unusual trends, deepen the analysis in
    these areas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share code and model outputs for feedback to ensure effective learning and understanding.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate suggestions and critiques to refine the model and the approach.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide errors to troubleshoot and resolve the issues
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluate:** Execute the code provided by ChatGPT to ensure accuracy and validity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example prompt from this pattern might look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Title: Building a Web-Based Search Results Page. You must suggest steps
    and code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective: Create a dynamic and interactive search results page that efficiently
    displays and filters search results based on user queries. Steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learn**: Understand the importance of displaying search results effectively.
    Analyze user interaction data to identify key metrics such as click-through rates,
    average time spent on results pages, and user satisfaction scores. Use various
    analytical techniques, from basic statistics to complex correlations and temporal
    analysis, to gain insights into user behavior and preferences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improvise**: Based on initial findings, adapt the search results page to
    highlight the most relevant results. For instance, if users frequently click on
    certain types of results, prioritize these in the display. Implement features
    such as filters, sorting options, and pagination to enhance user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**: Share your code and the search results page with peers or mentors
    for feedback. This will help ensure effective learning and understanding. Incorporate
    their suggestions and critiques to refine the search results page and improve
    its functionality. Provide errors: Document any errors encountered during the
    development process, such as issues with data retrieval or display. Troubleshoot
    and resolve these issues, learning from the process to enhance your skills.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluate:** Execute the code provided by ChatGPT to ensure its accuracy and
    validity. Validate the search results page by comparing its performance with real-world
    data and user feedback. Make necessary adjustments to improve accuracy and user
    satisfaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might end up with a prompt response similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Great! Let’s break down the steps and provide some code snippets to help you
    build a dynamic and interactive search results page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project Title:** Building a Web-Based Search Results Page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objective:** Create a dynamic and interactive search results page that efficiently
    displays and filters search results based on user queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learn**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand the importance of displaying search results effectively:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze user interaction data to identify key metrics such as click-through
    rates, average time spent on results pages, and user satisfaction scores.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use various analytical techniques, from basic statistics to complex correlations
    and temporal analysis, to gain insights into user behavior and preferences.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improvise**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapt the search results page based on initial findings:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlight the most relevant results based on user interaction data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement features such as filters, sorting options, and pagination to enhance
    user experience.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Share your code and the search results page with peers or mentors for feedback:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate their suggestions and critiques to refine the search results page
    and improve its functionality.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide errors**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document any errors encountered during the development process:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshoot and resolve these issues, learning from the process to enhance
    your skills.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluate**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Execute the code provided by ChatGPT to ensure its accuracy and validity:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the search results page by comparing its performance with real-world
    data and user feedback. Make necessary adjustments to improve accuracy and user
    satisfaction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code Snippets**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML Structure**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**CSS Styling**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**JavaScript Functionality**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Additional Features**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filters and Sorting:** Add dropdowns or checkboxes to filter and sort results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pagination:** Implement pagination to handle large sets of results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error Handling:** Add error handling to manage issues with data retrieval
    or display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should give you a solid foundation to start building your web-based search
    results page. Let me know if you need further assistance or more detailed code
    examples!
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Which pattern to choose?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The general answer it depends on the situation which pattern to choose. The
    reason for choosing between the TAG and PIC is that you have a clearly defined
    problem that you want to solve from start to finish and you’re looking for the
    AI assistant to do the “heavy lifting”. The reason to go for the exploratory pattern
    is when you’re working on an existing codebase, or you want to try out various
    approaches and steps. Our general recommendation is to try out all three patterns
    to see what suits your approach and problem the best.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt strategy for web development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s apply the different guidelines presented in the former section, and through
    using these guidelines, we will step by step work ourselves toward a prompt strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Break down the problem: “web system for inventory management”'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use a real example, “inventory management” within web development, to
    see if we can understand the general problem. To “manage” an inventory, you need
    to read and write data to it. Most likely, you will have different roles in this
    system/app, everything from administrators to normal users. You might also need
    to consider how this system fits in with other systems, should you, for example,
    integrate it with other systems, what parts it consists of in that case and how.
  prefs: []
  type: TYPE_NORMAL
- en: The domain seems pretty straightforward so let’s move on to understand what
    parts it consists of.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, we understand what the system should do. But to solve the
    problem, we need to divide it into smaller parts, which in web development usually
    entails the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frontend**: The frontend is the part of the system that the user interacts
    with. The frontend is responsible for presenting data to the user and receiving
    input from the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backend**: This part of the system communicates with the frontend. The backend
    is responsible for reading and writing data to a database. There could additionally
    be different frontends and different apps altogether that communicate with the
    backend in a more complex system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: The database is the part of the system that stores data. It’s
    a data store, for example, a relational database such as MySQL or PostgreSQL.
    The database is responsible for storing data in a way that’s efficient and easy
    to read and write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reporting**: There’s often a reporting part that presents insights. It takes
    its data from the data store and may need to transform the data to make it presentable
    from a reporting perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further breakdown of the frontend into features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having an overview like this is useful but usually not enough of a breakdown
    for us to start writing prompts. We need to break it down further, usually by
    features. At this point, a further breakdown of the frontend into features may
    look like the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Login**: The user needs to be able to log in to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logout**: The user needs to be able to log out of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View inventory**: The user needs to be able to view the inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add inventory**: The user needs to be able to add the inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remove inventory**: The user needs to be able to remove the inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update inventory**: The user needs to be able to update the inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate prompts for each feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, it’s granular enough for us to start writing prompts. Let’s take
    the first feature, login, and see how we can start thinking about how to craft
    a prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may start with a prompt, using a tool like ChatGPT or GitHub Copilot (more
    on that in an upcoming next chapter) like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a login page for the user to log in to the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: While this may work, you’re leaving out a lot of context, such as what exactly
    is needed here and what’s not, what technologies are you using, what the user
    experience is, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to improve the prompt by adding more context:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a login page with fields for the username and password. It should have
    a link for creating a user and a login button, be vertically and horizontally
    centered, and work well on a mobile phone and tablet. It should be written in
    React and use the Material UI library.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Identify some basic principles for web development, a “prompt strategy”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have seen so far, we broke down the problem into smaller, more “manageable”
    pieces and we suggested some prompts for how to solve a specific feature. So what
    exactly are we suggesting in terms of “prompt strategy” now that we understand
    more about our example “inventory management”? For one, we realize that our strategy
    will be context-dependent. Because we’re in web development, we need to use keywords
    within that domain, together with libraries and architecture suitable for a specific
    area. Here are some guides we suggest you use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provide context – fields**: A login screen can be as simple as username and
    password fields. Most screens however have more fields, such as a password confirmation
    field, a link to reset a password, a field to create a new user, and so on. Depending
    on your needs, you may need to be very detailed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specify how – design, and tech choices**: A login screen can be designed
    in many ways. It’s quite common today to optimize for different devices like tablets,
    mobile, large screens, and so on. For tech choices, web development has a lot
    of choices, from frameworks like React, Vue, and Angular to plain HTML and CSS.
    Specify according to the needs of the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterate**: Different tools react differently to the same prompt. Throughout
    this book, we will show you how to use different tools like GitHub Copilot and
    ChatGPT. Each tool has its own strengths and weaknesses and may offer different
    results. Try to iterate on the prompt by adding separators like commas and colons,
    and try rephrasing the prompt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be context-aware**: When you use tools like ChatGPT and GitHub Copilot, you
    do so with preexisting context. For ChatGPT, that means you’re having an ongoing
    conversation of prompts and responses, and for GitHub Copilot, it means it sees
    not only what you’ve written in your open file but also your entire workspace
    if you let it. The response to your prompts looks at this context and decides
    what to generate. It’s important to be aware of this context and if you’re not
    getting the response you want, try to change the context, in ChatGPT, start a
    new conversation, and in GitHub Copilot, close the open files, start writing in
    a blank file, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt strategy for data science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s do a similar thought experiment for data science as we did for web development.
    We’ll use the presented guidelines “problem breakdown” and “generate prompts,”
    and just like in the web development section, we’ll draw some general conclusions
    on the domain and present those as a prompt strategy for data science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem breakdown: predict sales'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we’re building a machine-learning model to predict sales. At a high
    level, we understand what the system should do. To solve the problem though, we
    need to divide it into smaller parts, which in data science usually entails the
    following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**: The data is the part of the system that stores information. The data
    can come from many places like databases, web endpoints, static files, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: The model is responsible for learning from the data and producing
    a prediction that’s as accurate as possible. To predict, you need an input that
    produces one or more outputs as a prediction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Training**: The training is the part of the system that trains the model.
    Here, you typically have part of your data as training and a part being sample
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluation**: To ensure your model works as intended, you need to evaluate
    it. Evaluation means taking the data and model and producing a score that indicates
    how well the model performs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visualization**: Visualization is the part where you can gain insights valuable
    for the business via graphs. This part is very important, as it’s the part that’s
    most visible to the business.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further breakdown into features/steps for data science
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you’re at too high a level to start writing prompts. We can
    break it down further by looking at each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**: The data part has many steps, including collecting the data, cleaning
    it, and transforming it. Here’s how you can break it down:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collect data**: The data needs to be collected from somewhere. It could be
    a database, a web endpoint, a static file, and so on.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clean data**: The data needs to be cleaned. Cleaning means removing data
    that’s not relevant, removing duplicates, and so on.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transform data**: The data needs to be transformed. Transformation means
    changing the data to a format that’s useful for the model.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Training**: Just like the data part, the training part has many steps to
    it. Here’s how you can break it down:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Split data**: The data needs to be split into training and sample data. The
    training data is used to train the model and the sample data is used to evaluate
    the model.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Train model**: The model needs to be trained. Training means taking the training
    data and learning from it.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evaluation**: The evaluation part is usually a single step but can be broken
    down further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate prompts for each step
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note how our breakdown for data science looks a bit different from web development.
    Instead of identifying features like **Add inventory**, we instead have a feature
    like Collect data.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we’re on the correct level to author a prompt, so let’s use the **Collect
    data** feature as our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Collect data from `data.xls` and read it into a DataFrame using Pandas library.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding prompt is both general and specific at the same time. It’s general
    in the sense that it tells you to “collect data” but specific in that it specifies
    a specific library to use and even what data structure (DataFrame). It’s entirely
    possible that a simpler prompt would have worked for the preceding step like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Collect data from data.xls.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where it may vary depending on whether you use a tool like ChatGPT or
    GitHub Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: Identify some basic principles for data science, “a prompt strategy for data
    science”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we’ve identified some similar principles as in the web development example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provide context – filename**: A CSV file can have any name. It’s important
    to specify the name of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specify how – libraries**: There are many ways to load a CSV file, and even
    though Pandas library is a common choice, it’s important to specify it. There
    are other libraries to work with and you might need a solution for Java, C#, and
    Rust, for example, where libraries are named differently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterate**: It’s worth iterating on the prompt, rephrasing it, and adding
    separators like a comma, a colon, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be context-aware**: Also here, context matters a lot; if you’re working in
    Notebook, previous cells will be available to GitHub Copilot, previous conversations
    will be available to ChatGPT, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see from the preceding guidance, the strategy is very similar for
    web development. Here we’re also listing “Provide,” “Specify how,” “Iterate,”
    and “Be context-aware.” The big difference lies in the details. However, there’s
    an alternate strategy that works in data science and that’s lengthy prompts. Even
    though we’ve broken down the data science problem into features, we don’t need
    to write a prompt per feature. Another way of solving it could be to express everything
    you want to be carried out in one large prompt. Such a prompt could therefore
    look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to predict sales on the file `data.xsl`. Use Python and Pandas library.
    Here are the steps that you should carry out:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Train model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: You will see examples in future chapters on data science and machine learning
    where both smaller prompts as well as lengthier prompts are being used. You decide
    which approach you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Validate the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important part of this strategy is verifying correctness and that
    the text and code created by the AI assistant are correct. There are two general
    approaches we can take to verify our outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verification via prompts**: The first approach is to use prompts to verify
    the outcome. This means writing prompts that question the outcome of specific
    results. This can be a good strategy to employ at the beginning of your verification
    process. What you’re looking for are situations where the AI assistant isn’t consistent
    in its responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classical verifications**: The second approach is to use classical verification
    techniques. What those techniques are varies depending on the problem domain.
    At a high level, though, it boils down to testing code, comparing output, and
    relying on your own knowledge, and the knowledge of your peers, to verify the
    outcome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AI tool doesn’t really know what it’s doing. The responses provided are
    responses that likely depend on its training corpus. At all times, you should
    be aware of this and rely on your expertise to verify the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsections, let’s explore various approaches for manual and classical
    verification.
  prefs: []
  type: TYPE_NORMAL
- en: Verification via prompts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use prompts to both produce results that take you closer to resolving
    the problem but also to verify the results. Let’s take an example where we’re
    building the previously mentioned login screen. We’ve written a prompt that looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a login page with fields for username and password; it should have a
    link for creating a user and a login button. It should be vertically and horizontally
    centered and work well on a mobile phone and tablet. It should be written in React
    and use the Material UI library.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify this outcome, we can write a prompt like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Given the below code, what does it do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: An app could look at the code provided and realize you don’t need a prompt to
    deduce what it does, and that it’s in fact missing CSS code to make it responsive.
    The point here though is that by writing prompts, you can have the AI assistant
    tell you what it thinks the code does via questions.
  prefs: []
  type: TYPE_NORMAL
- en: Using prompts this way, to pose queries on the output, is a good first step
    to verifying the outcome. However, it’s not enough and you need to rely on classical
    verification techniques, so let’s cover that next.
  prefs: []
  type: TYPE_NORMAL
- en: Classical verification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How you verify the outcome depends on the problem domain. In web development,
    you can use a variety of different tools and techniques, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing**: With end-to-end testing or frontend testing, you can verify that
    the code works as intended. Usually, this type of test involves using a programmatic
    approach to simulate user interaction with the web page, using something like
    Selenium, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual testing**: You can manually test the web page by opening it in a browser
    and interacting with it. This is a good approach to use at the beginning of your
    verification process. Apart from interaction, you can also visually inspect the
    web page to see if it looks correct according to your requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code review**: You can review the code and see if it looks correct. This
    is a good approach to use at the beginning of your verification process. It allows
    not only you but also your peers to verify the outcome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tools**: Tools can test a variety of different scenarios like accessibility,
    performance, and so on. These tools are most likely a part of your development
    process already.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conducting data science, you may rely on all of the preceding approaches, but
    you may also use other approaches. Some common approaches are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: You can use unit testing to verify that the code works as
    intended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: You can use integration testing to verify that the
    code works as intended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation of results**: This type of validation means you compare the results
    of your analysis or model to known results or benchmarks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross validation**: This type of validation means you split your data into
    training and sample data, train your model on the training data, and evaluate
    it on the sample data. This is a good approach to use at the beginning of your
    verification process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve provided a strategy for solving problems with
    prompts and validating the solution.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how both web development and data science can be broken down into
    smaller parts that can be solved with prompts. We also identified some basic principles
    for writing prompts.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at how to validate the solution using prompts and classical
    verification techniques.
  prefs: []
  type: TYPE_NORMAL
- en: It’s our hope that you will revisit this chapter when you’re looking at solving
    a problem within web development or data science and you’re looking for an approach.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more to prompting than writing a prompt and getting a response. You
    will see throughout this book how we use these principles in various domains to
    solve problems. Try typing these prompts as you read, adapt to your own needs,
    and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn more about the two AI assistants
    of our choice, GitHub Copilot and ChatGPT.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/aicode](https://packt.link/aicode)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code510410532445718281.png)'
  prefs: []
  type: TYPE_IMG
