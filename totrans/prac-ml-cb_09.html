<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Structured Prediction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Structured Prediction</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hidden Markov models - EUR and USD</li><li class="listitem" style="list-style-type: disc">Hidden Markov models for regime detection</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Introduction</h1></div></div></div><p>The <span class="strong"><strong>hidden Markov model</strong></span> (<span class="strong"><strong>HMM</strong></span>) is a very powerful statistical method of characterizing the observed data samples of a discrete-time series. Not only can it provide an efficient way to build parsimonious parametric models, it can also incorporate the dynamic programming principle in its core for a unified pattern segmentation and pattern classification of time-varying data sequences. The data samples in the time series can be discretely or continuously distributed; they can be scalars or vectors. The underlying assumption of the HMM is the the data samples can be well characterized as a parametric random process, and the parameters of the stochastic process can be estimated in a precise and well-defined framework.</p></div></div>
<div class="section" title="Hidden Markov models - EUR and USD"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Hidden Markov models - EUR and USD</h1></div></div></div><p>The EUR/USD is the most commonly traded pair in the Forex market. Their popularity can be attributed to the fact that each currency represents the world's two largest economic and trading blocks and many multinational corporations that conduct business across the Atlantic.</p><p>Price movements for this currency pair are generally related to factors that influence the value of either the EUR or the USD. As the world's most liquid currency pair, the EUR/USD offers tight spreads and constant liquidity for traders who are looking to instantly buy or sell. The combination of stability and volatility makes the EUR/USD an excellent pair for beginner and advanced traders. The EUR/USD pair offers traders high liquidity and has very tight and competitive spreads. The relative strength of the US economy and the European economy, which can be tracked through the daily news, generally influence this pair.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec58"/>Getting ready</h2></div></div></div><p>In order to apply the hidden Markov model to find different market regimes, and to therefore optimize a trading strategy, we will be using a dataset collected on the Euro Dollar dataset.</p><div class="section" title="Step 1 - collecting and describing data"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec148"/>Step 1 - collecting and describing data</h3></div></div></div><p>The dataset titled <code class="literal">EURUSD1d.csv</code> shall be used. This dataset is available in CSV format and called <code class="literal">EURUSD1d.csv</code>. The dataset is in a standard format. There are 1,008 rows of data and five variables. The numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Open</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">High</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Low</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Close</code></li></ul></div><p>The non-numeric variable is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Open Timestamp</code></li></ul></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec59"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring data"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec149"/>Step 2 - exploring data</h3></div></div></div><p>The following packages need to be loaded as the first step:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("depmixS4")</strong></span>
<span class="strong"><strong>    &gt; install.packages("quantmod")</strong></span>
<span class="strong"><strong>    &gt; install.packages("ggplot2")</strong></span>
<span class="strong"><strong>    &gt; library(depmixS4)</strong></span>
<span class="strong"><strong>    &gt; library(quantmod)</strong></span>
<span class="strong"><strong>    &gt; library(ggplot2)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Version info: Code for this page was tested in R version 3.2.2 (2015-08-14)</p></div></div><p>Let's explore the data and understand the relationships among the variables:</p><p>We'll begin by importing the CSV data file named <code class="literal">EURUSD1d.csv</code>. We will be saving the data to the <code class="literal">EuroUSD</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; EuroUSD &lt;- read.csv("d:/EURUSD1d.csv", header = TRUE)</strong></span>
</pre><p>Printing the <code class="literal">EuroUSD</code> frame: The <code class="literal">head()</code> function returns the first part of the <code class="literal">EuroUSD</code> frame. The <code class="literal">EuroUSD</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(EuroUSD)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_001.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Printing the summary of the <code class="literal">EuroUSD</code> data frame: The <code class="literal">summary()</code> function is a multipurpose function. The <code class="literal">summary()</code> is a generic function that provides a summary of the data related to the individual object or data frame. The <code class="literal">EuroUSD</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(EuroUSD)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_002.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">EuroUSD</code> data frame: The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">EuroUSD</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; str(EuroUSD)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_003.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div class="section" title="Step 3 - turning data into a time series"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec150"/>Step 3 - turning data into a time series</h3></div></div></div><p>Creating objects of the type character: The <code class="literal">as.character()</code> function represents real and complex numbers to 15 significant digits. The entire <code class="literal">EuroUSD</code> data frame is passed apart from the 1<sup>st</sup> column:</p><pre class="programlisting">
<span class="strong"><strong>&gt; Date &lt;- as.character(EuroUSD[,1])</strong></span>
</pre><p>Manipulating the <code class="literal">Date</code> data frame to represent calendar dates. The result is then stored in the data frame <code class="literal">DateTimeSeries</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; DateTimeSeries &lt;- as.POSIXlt(Date, format = "%Y.%m.%d %H:%M:%S")</strong></span>
</pre><p>Creating tightly coupled data frames. <code class="literal">data.frame()</code> creates the data frame for <code class="literal">EuroUSD[,2:5]</code>. <code class="literal">row.names = DateTimeSeries</code> gives the row names for the data frame created:</p><pre class="programlisting">
<span class="strong"><strong>&gt; TimeSeriesData &lt;- data.frame(EuroUSD[,2:5], row.names = DateTimeSeries)</strong></span>
</pre><p>Printing the <code class="literal">TimeSeriesData</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">TimeSeriesData</code> frame. The <code class="literal">TimeSeriesData</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(TimeSeriesData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_004.jpg" alt="Step 3 - turning data into a time series"/></div><p>
</p><p>The <code class="literal">as.xts()</code> function converts the <code class="literal">TimeSeriesData</code> data object to the <code class="literal">xts</code> class without losing any attributes of the <code class="literal">TimeSeriesData</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; TimeSeriesData &lt;- as.xts(TimeSeriesData)</strong></span>
</pre><p>Measuring the volatility of a high-low-close series. The <code class="literal">ATR()</code> function measures the average volatility of the high-low-close series of <code class="literal">TimeSeriesData</code>. <code class="literal">TimeSeriesData[,2:4]</code> indicates the high-low-close of the <code class="literal">TimeSeriesData</code>. The result is then stored in the <code class="literal">ATRindicator</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ATRindicator &lt;- ATR(TimeSeriesData[,2:4],n=14)</strong></span>
</pre><p>Printing the <code class="literal">ATRindicator</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">ATRindicator</code> frame. The <code class="literal">ATRindicator</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(ATRindicator)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_005.jpg" alt="Step 3 - turning data into a time series"/></div><p>
</p><p>Measuring the volatility of a high series. <code class="literal">ATRindicator [,2]</code> indicates the high of the <code class="literal">TimeSeriesData</code>. The result is then stored in the <code class="literal">TrueRange</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; TrueRange &lt;- ATRindicator[,2]</strong></span>
</pre><p>Printing the <code class="literal">TrueRange</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(TrueRange)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_006.jpg" alt="Step 3 - turning data into a time series"/></div><p>
</p><p>Calculating the difference between the <code class="literal">LogReturns</code> of close and open values. The result is then stored in the <code class="literal">LogReturns</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; LogReturns &lt;- log(EuroUSD$Close) - log(EuroUSD$Open)</strong></span>
</pre><p>Printing the summary of the <code class="literal">LogReturns</code> data frame. The <code class="literal">summary()</code> function is used to provide a summary of the data related to the individual object or data frame. The <code class="literal">LogReturns</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(LogReturns)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_007.jpg" alt="Step 3 - turning data into a time series"/></div><p>
</p></div><div class="section" title="Step 4 - building the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec151"/>Step 4 - building the model</h3></div></div></div><p>Creating a data frame for the HMM model. The <code class="literal">data.frame()</code> function creates tightly coupled data frames of variables that share many of the properties of matrices:</p><pre class="programlisting">
<span class="strong"><strong>&gt; HMMModel &lt;- data.frame(LogReturns, TrueRange)</strong></span>
</pre><p>Removing the data where the indicators are being calculated for the <code class="literal">HMMModel</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; HMMModel &lt;- HMMModel[-c(1:14),]</strong></span>
</pre><p>Printing the <code class="literal">HMMModel</code> frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(HMMModel)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_008.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Naming the columns. The <code class="literal">c()</code> function combines arguments to form a vector. All the arguments passed to the function are combined to form a common type that is the type of the returned value:</p><pre class="programlisting">
<span class="strong"><strong>&gt; colnames(HMMModel) &lt;- c("LogReturns","TrueRange")</strong></span>
</pre><p>Printing the column's names:</p><pre class="programlisting">
<span class="strong"><strong>&gt; colnames(HMMModel)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_009.jpg" alt="Step 4 - building the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; set.seed(1)</strong></span>
</pre><p>Building a three-state regime and set response distribution to the Gaussian state. The <code class="literal">depmix()</code> function creates the hidden Markov model. The <code class="literal">LogReturns~1</code>, <code class="literal">TrueRange~1</code> represents the response to be modeled. <code class="literal">data = HMMModel</code> represents the data frame to interpret the variables in response, while <code class="literal">nstates=3</code> is the number of states:</p><pre class="programlisting">
<span class="strong"><strong>&gt; HMM &lt;- depmix(list(LogReturns~1, TrueRange~1), data = HMMModel, nstates=3, family=list(gaussian(), gaussian()))</strong></span>
</pre><p>Fitting the HMM model to the defined dataset. The <code class="literal">fit()</code> function optimizes the parameters of the HMM model, subject to linear inequality. HMM is an object of class HMM, while <code class="literal">verbose = FALSE</code> depicts that the information should not be displayed on screen. The optimized parameters are stored in object <code class="literal">HMMfit</code> of class <code class="literal">depmix</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; HMMfit &lt;- fit(HMM, verbose = FALSE)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_09_010.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Comparing the log likelihood and AIC and BIC values. The <code class="literal">print()</code> function prints the arguments for <code class="literal">HMMfit</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; print(HMMfit)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_011.jpg" alt="Step 4 - building the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(HMMfit)</strong></span>
</pre><p>Printing the summary of the <code class="literal">LogReturns</code> data frame. The <code class="literal">summary()</code> function is used to provide a summary of the data related to the individual object or data frame. The <code class="literal">LogReturns</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_012.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Finding the posterior for each of the state of datasets. The result is stored in <code class="literal">HMMstate</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; HMMstate &lt;- posterior(HMMfit)</strong></span>
</pre><p>Printing the <code class="literal">HMMstate</code> data frame. The probability for each state for every day and the class of highest probability is displayed:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(HMMstate)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_013.jpg" alt="Step 4 - building the model"/></div><p>
</p></div><div class="section" title="Step 5 - displaying the results"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec152"/>Step 5 - displaying the results</h3></div></div></div><p>The calculated <code class="literal">HMMstate</code> data frame will be displayed by following these steps:</p><p>Creating the data frame for the HMM model. The <code class="literal">data.frame()</code> function creates tightly coupled data frames of variables that share many of the properties of matrices. <code class="literal">DateTimeSeries</code>, <code class="literal">LogReturns</code>, and <code class="literal">TrueRange</code> data frames are passed to be tightly coupled. The result is then stored in <code class="literal">DFIndicators</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; DFIndicators &lt;- data.frame(DateTimeSeries, LogReturns, TrueRange)</strong></span>
<span class="strong"><strong>    &gt; DFIndicatorsClean &lt;- DFIndicators[-c(1:14), ]</strong></span>
</pre><p>Creating a data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; Plot1Data &lt;- data.frame(DFIndicatorsClean, HMMstate$state)</strong></span>
</pre><p>Plotting the results using <code class="literal">ggplot()</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; LogReturnsPlot &lt;- ggplot(Plot1Data,aes(x=Plot1Data[,1],y=Plot1Data[,2]))+geom_line(color="darkred")+labs(,y="Log Return Values",x="Date")</strong></span>
<span class="strong"><strong>    &gt; LogReturnsPlot</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_014.jpg" alt="Step 5 - displaying the results"/></div><p>
</p></div></div></div>
<div class="section" title="Hidden Markov models - regime detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Hidden Markov models - regime detection</h1></div></div></div><p>Standard &amp; Poor's 500 Index (S&amp;P 500) is an American Stock market index of 500 stocks. It is a leading indicator of US equities and reflects the performance of large-cap companies selected by economists. Experts, when determining the 500 stocks, consider factors that are included in the index, including market size, liquidity, and industry grouping. It is a market value-weighted index and one of the common benchmarks for the US stock market. Investment products based on the S&amp;P 500 include index funds and exchange-traded funds are available to investors. Investors have a challenge replicating the S&amp;P 500 since the portfolio would need stocks of 500 companies in ratio to the entire portfolio to replicate the index's market cap methodology. For investors it would be easier to purchase one of the S&amp;P 500 investment products such as the Vanguard S&amp;P 500 ETF, the SPDR S&amp;P 500 ETF, or the Shares S&amp;P 500 Index ETF.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec60"/>Getting ready</h2></div></div></div><p>In order to perform hidden Markov models we shall be using a dataset collected on the <code class="literal">S&amp;P500</code> returns set.</p><div class="section" title="Step 1 - collecting and describing data"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec153"/>Step 1 - collecting and describing data</h3></div></div></div><p>The dataset to be used is the <code class="literal">S&amp;P500</code> returns daily value from 1<sup>st</sup> January, 2004 to date. This dataset is freely available on <a class="ulink" href="https://yahoo.com/">https://yahoo.com/</a> from where we shall be downloading the data.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec61"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring data"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec154"/>Step 2 - exploring data</h3></div></div></div><p>Load the following packages:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("depmixS4")</strong></span>
<span class="strong"><strong>    &gt; install.packages("quantmod")</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03)</p></div></div><p>Each of the preceding libraries needs to be installed.</p><pre class="programlisting">
<span class="strong"><strong>    &gt; library("depmixS4 ")</strong></span>
<span class="strong"><strong>    &gt; library("quantmod")</strong></span>
<span class="strong"><strong>    &gt; set.seed(1)</strong></span>
</pre><p>Let's download the data. We will begin by marking the start date and the end date for the time period in which the data is desired.
</p><p>
Loading the data using the <code class="literal">getSymbols()</code> function as follows. The function loads data from multiple sources, either local or remote sources. GSPC is the character vector that specifies the name of the symbol to be loaded:</p><pre class="programlisting">
<span class="strong"><strong>&gt; getSymbols( "^GSPC", from="2004-01-01" )</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_09_015.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Calculating the log difference between each of the closing prices. The result is then saved in the <code class="literal">GSPCDiff</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; GSPCDiff = diff( log( Cl( GSPC ) ) )</strong></span>
</pre><p>Exploring the internal structure of the <code class="literal">GSPCDiff</code> frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">GSPCDiff</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; str(GSPCDiff)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_016.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Printing the <code class="literal">GSPCDiff</code> data frame as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(GSPCDiff)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_017.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Creating the numeric value of the <code class="literal">GSPCDiff</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; returns = as.numeric(GSPCDiff)</strong></span>
</pre><p>Plotting the <code class="literal">GSPCDiff</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(GSPCDiff)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_09_018.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div class="section" title="Step 3 - preparing the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec155"/>Step 3 - preparing the model</h3></div></div></div><p>Fitting a hidden Markov model with two states to the S&amp;P returns. Creating a hidden Markov model for two states.</p><p>The <code class="literal">depmix()</code> function creates the hidden Markov Model. The <code class="literal">returns ~ 1</code> represents the response to be modeled. <code class="literal">data=data.frame(returns=returns)</code> represents the data frame to interpret the variables in response, while <code class="literal">nstates = 2</code> is the number of states:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; hmm2states &lt;- depmix(returns ~ 1, family = gaussian(), nstates = 2, data=data.frame(returns=returns))</strong></span>
<span class="strong"><strong>    &gt; hmm2states</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_019.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Fitting the HMM model to the defined dataset. The <code class="literal">fit()</code> function optimizes the parameters of the HMM model, subject to linear inequality. <code class="literal">hmm2states</code> is an object of class HMM, while <code class="literal">verbose = FALSE</code> instructs that the information should not be displayed on screen. The optimized parameters are stored in object <code class="literal">hmmfit2states</code> of the <code class="literal">depmix</code> class:</p><pre class="programlisting">
<span class="strong"><strong>&gt; hmmfit2states &lt;- fit(hmm2states, verbose = FALSE)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_09_020.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Comparing the log likelihood and AIC and BIC values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; hmmfit2states</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_021.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Finding the posterior for each of the state of datasets. The result is stored in <code class="literal">PosteriorProbs</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; PosteriorProbs &lt;- posterior(hmmfit2states)</strong></span>
</pre><p>Printing the <code class="literal">PosteriorProbs</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">PosteriorProbs</code> frame. The <code class="literal">PosteriorProbs</code> frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head (PosteriorProbs)</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_022.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Plotting the two states results. <code class="literal">type='l'</code> signifies for line plot:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(returns, type='l', main='Regime Detection', xlab='No of Observations', ylab='Returns')</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_023.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Plotting the columns of the <code class="literal">PosteriorProbs</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; matplot(PosteriorProbs[,-1], type='l', main='Regime Posterior Probabilities', xlab='No of Observations', ylab='Probability')</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_024.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Creating a hidden Markov model for three states:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; hmm3states &lt;- depmix(returns ~ 1, family = gaussian(), nstates = 3, data=data.frame(returns=returns))</strong></span>
<span class="strong"><strong>    &gt; hmm3states</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_025.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Fitting the HMM model to the defined dataset:</p><pre class="programlisting">
<span class="strong"><strong>&gt; hmmfit3states &lt;- fit(hmm3states, verbose = FALSE)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_09_026.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Finding the posterior for each of the dataset states:</p><pre class="programlisting">
<span class="strong"><strong>&gt; PosteriorProbs &lt;- posterior(hmmfit3states)</strong></span>
</pre><p>Printing the <code class="literal">PosteriorProbs</code> frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(PosteriorProbs)</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_027.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(returns, type='l', main='Regime Detection', xlab='No of Observations', ylab='Returns')</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_028.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; matplot(PosteriorProbs[,-1], type='l', main='Regime Posterior Probabilities', xlab='No of Observations', ylab='Probability')</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_029.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Creating a hidden Markov model for four states:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; hmm4states &lt;- depmix(returns ~ 1, family = gaussian(), nstates = 4, data=data.frame(returns=returns))</strong></span>
<span class="strong"><strong>    &gt; hmm4states</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_030.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Fitting the HMM model to the defined dataset:</p><pre class="programlisting">
<span class="strong"><strong>&gt; hmmfit4states &lt;- fit(hmm4states, verbose = FALSE)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_09_031.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>Finding the posterior for each of the datasets states:</p><pre class="programlisting">    <span class="strong"><strong>&gt; PosteriorProbs &lt;- posterior(hmmfit4states)</strong></span>    <span class="strong"><strong>&gt; plot(returns, type='l', main='Regime Detection', xlab='No of Observations', ylab='Returns')</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_032.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; matplot(PosteriorProbs[,-1], type='l', main='Regime Posterior Probabilities', xlab='No of Observations', ylab='Probability')</strong></span>
</pre><p>The results are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_033.jpg" alt="Step 3 - preparing the model"/></div><p>
</p></div></div></div></body></html>