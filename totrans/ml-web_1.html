<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Introduction to Practical Machine Learning Using Python">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch01"/>&#13;
 Chapter 1. Introduction to Practical Machine Learning Using Python</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>In the technology industry, the skill of analyzing and mining commercial data is becoming more and more important. All the companies that are related to the online world generate data that can be exploited to improve their business, or can be sold to other companies. This huge amount of information, which can be commercially useful, needs to be restructured and analyzed using the expertise of data science (or data mining) professionals. Data science employs techniques known as machine learning algorithms to transform the data in models, which are able to predict the behavior of certain entities that are highly considered by the business environment. This book is about these algorithms and techniques that are so crucial in today's technology business world, and how to efficiently deploy them in a real commercial environment. You will learn the most relevant machine-learning techniques and will have the chance to employ them in a series of exercises and applications designed to enhance commercial awareness and, with the skills learned in this book, these can be used in your professional experience. You are expected to already be familiar with the Python programming language, linear algebra, and statistics methodologies to fully acquire the topics discussed in this book.</p>&#13;
<div class="itemizedlist">&#13;
<ul class="itemizedlist">&#13;
<li class="listitem">There are many tutorials and classes available online on these subjects, but<a id="id0" class="indexterm"/>&#13;
 we recommend you read the official Python documentation (<a class="ulink" href="https://docs.python.org/">https://docs.python.org/</a>&#13;
 ), the books <span class="emphasis">&#13;
<em>Elementary Statistics</em>&#13;
</span>&#13;
 by A. Bluman and <span class="emphasis">&#13;
<em>Statistical Inference</em>&#13;
</span>&#13;
 by G. Casella and R. L. Berger to understand the statistical main concepts and methods and <span class="emphasis">&#13;
<em>Linear Algebra and Its Applications</em>&#13;
</span>&#13;
 by G. Strang to learn about linear algebra.</li>&#13;
</ul>&#13;
</div>&#13;
<p>The purpose of this introductory chapter is to familiarize you with the more advanced libraries and tools used by <a id="id1" class="indexterm"/>&#13;
 machine-learning professionals in Python, such <a id="id2" class="indexterm"/>&#13;
 as <span class="strong">&#13;
<strong>NumPy</strong>&#13;
</span>&#13;
 , <span class="strong">&#13;
<strong>pandas,</strong>&#13;
</span>&#13;
 and <span class="strong">&#13;
<strong>matplotlib,</strong>&#13;
</span>&#13;
 which will help you to grasp the necessary<a id="id3" class="indexterm"/>&#13;
 technical knowledge to implement the techniques presented in the following chapters. Before continuing with the tutorials and description of the libraries used in this book, we would like to clarify the main concepts of the machine-learning field, and give a practical example of how a machine-learning algorithm can predict useful information in a real context.</p>&#13;
<div class="section" title="General machine-learning concepts">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch01lvl1sec08"/>&#13;
 General machine-learning concepts</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>In this book, the most relevant machine-learning algorithms are going to be discussed and used in exercises to make you familiar with them. In order to explain these algorithms and to understand<a id="id4" class="indexterm"/>&#13;
 the content of this book, there are a few general concepts we need to visit that are going to be described hereafter.</p>&#13;
<p>First of all, a good definition of machine learning is the subfield of computer science that has been developed from the fields of pattern recognition, artificial intelligence, and computational learning theory. Machine learning can also be seen as a data-mining tool, which focuses more on the data analysis aspects to understand the data provided. The purpose of this discipline is the development of programs, which are able to <span class="emphasis">&#13;
<em>learn</em>&#13;
</span>&#13;
 from previously seen data, through tunable parameters (usually arrays of double precision values), that are designed to be adjusted automatically to improve the resulting predictions. In this way, computers can predict a behavior, <span class="emphasis">&#13;
<em>generalizing</em>&#13;
</span>&#13;
 the underlying structure of the data, instead of just storing (or retrieving) the values like usual database systems. For this reason, machine learning is associated with computational statics, which also attempt to predict a behavior based on previous data. Common industrial applications of machine-learning algorithms are spam filtering, search engines, optical character recognition, and computer vision. Now that we have defined the discipline, we can describe the terminology used in each machine-learning problem, in more detail.</p>&#13;
<p>Any learning problem starts with a data set of <span class="emphasis">&#13;
<em>n</em>&#13;
</span>&#13;
 samples, which are used to predict the properties of the future unknown data. Each sample is typically composed of more than a single value so it is a vector. The components of this<a id="id5" class="indexterm"/>&#13;
 vector are called <span class="emphasis">&#13;
<em>features</em>&#13;
</span>&#13;
 . For example, imagine predicting the price of a second-hand car based on its characteristics: year of fabrication, color, engine size, and so on. Each car <span class="emphasis">&#13;
<em>i</em>&#13;
</span>&#13;
 in the dataset will be a vector of features <span class="emphasis">&#13;
<em>x(i)</em>&#13;
</span>&#13;
 that corresponds to its color, engine size, and many others. In this case, there is also a <span class="emphasis">&#13;
<em>target</em>&#13;
</span>&#13;
 (or label) variable associated with each car <span class="emphasis">&#13;
<em>i</em>&#13;
</span>&#13;
 , <span class="emphasis">&#13;
<em>y(i)</em>&#13;
</span>&#13;
 which is the second-hand car price. A <span class="emphasis">&#13;
<em>training example</em>&#13;
</span>&#13;
 is formed by a pair <span class="emphasis">&#13;
<em>(x(i), y(i))</em>&#13;
</span>&#13;
 and therefore the complete set of <span class="emphasis">&#13;
<em>N</em>&#13;
</span>&#13;
 data points<a id="id6" class="indexterm"/>&#13;
 used to learn is called a <span class="emphasis">&#13;
<em>training dataset {(x(i), y(i));i=1,…,N}</em>&#13;
</span>&#13;
 . The symbol <span class="emphasis">&#13;
<em>x</em>&#13;
</span>&#13;
 will denote the space of feature (input) values, and <span class="emphasis">&#13;
<em>y</em>&#13;
</span>&#13;
 the space of target (output) values. The machine-learning algorithm chosen to solve the problem will be described by a mathematical model, with some parameters to tune in the training set. After the training phase is completed, the performance of the prediction is evaluated using another two sets: validation and testing sets. The validation set is used to choose, among multiple models, the one that returns the best results, while the testing set is usually used to determine the actual precision of the chosen model. Typically the dataset is divided into 50% training set, 25% validation set, and 25% testing set.</p>&#13;
<p>The learning problems <a id="id7" class="indexterm"/>&#13;
 can be divided in two main categories (both of which are extensively covered in this book):</p>&#13;
<div class="itemizedlist">&#13;
<ul class="itemizedlist">&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>Unsupervised learning</strong>&#13;
</span>&#13;
 : The training dataset is given by input feature vectors <span class="emphasis">&#13;
<em>x</em>&#13;
</span>&#13;
 without any<a id="id8" class="indexterm"/>&#13;
 corresponding label values. The usual objective is to find similar examples within the data using clustering algorithms, or to project the data from a high-dimensional space down to a few dimensions (blind signal separations algorithms such as principal component analysis). Since there is usually no target value for each training example, it is not possible to evaluate errors of the model directly from the data; you need to use a technique that evaluates how the elements within each cluster are similar to each other and different from the other cluster's members. This is one of the major differences between unsupervised learning and supervised learning.</li>&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>Supervised learning</strong>&#13;
</span>&#13;
 : Each data sample is given in a pair consisting of an input feature <a id="id9" class="indexterm"/>&#13;
 vector and a label value. The task is to infer the parameters to predict the target values of the test data. These types of problems can be further divided into:<div class="itemizedlist">&#13;
<ul class="itemizedlist">&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>Classification</strong>&#13;
</span>&#13;
 : The<a id="id10" class="indexterm"/>&#13;
 data targets belong to two or more classes, and the goal is to learn how to<a id="id11" class="indexterm"/>&#13;
 predict the class of unlabeled data from the training set. Classification is a discrete (as opposed to continuous) form of supervised learning, where the label has a limited number of categories. A practical example of the classification problem is the handwritten digit recognition example, in which the objective is to match each feature vector to one of a finite number of discrete categories.</li>&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>Regression</strong>&#13;
</span>&#13;
 : The<a id="id12" class="indexterm"/>&#13;
 label is a continuous <a id="id13" class="indexterm"/>&#13;
 variable. For example, the prediction of the height of a child based on his age and weight is a regression problem.</li>&#13;
</ul>&#13;
</div>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
<p>We are going to focus on unsupervised learning methods in <a class="link" title="Chapter 2. Unsupervised Machine Learning" href="text00020.html#ch02">Chapter 2</a>&#13;
 , <span class="emphasis">&#13;
<em>Machine Learning Techniques: Unsupervised Learning,</em>&#13;
</span>&#13;
 while the most relevant supervised learning algorithms are discussed in <a class="link" title="Chapter 3. Supervised Machine Learning" href="text00024.html#page">Chapter 3</a>&#13;
 , <span class="emphasis">&#13;
<em>Supervised Machine Learning</em>&#13;
</span>&#13;
 . <a class="link" title="Chapter 4. Web Mining Techniques" href="text00032.html#ch04">Chapter 4</a>&#13;
 , <span class="emphasis">&#13;
<em>Web Mining Techniques</em>&#13;
</span>&#13;
 will approach the field of web-mining techniques that can also be considered as both supervised and unsupervised methods. The recommendation systems, which are again part of the supervised learning category, are described in <a class="link" title="Chapter 5. Recommendation Systems" href="text00037.html#page">Chapter 5</a>&#13;
 , <span class="emphasis">&#13;
<em>Recommendation Systems</em>&#13;
</span>&#13;
 . The <a id="id14" class="indexterm"/>&#13;
 <span class="strong">&#13;
<strong>Django</strong>&#13;
</span>&#13;
 web framework is then introduced in <a class="link" title="Chapter 6. Getting Started with Django" href="text00046.html#ch06">Chapter 6</a>&#13;
 , <span class="emphasis">&#13;
<em>Getting Started with Django,</em>&#13;
</span>&#13;
 and then an example of the recommendation system (using both the Django framework and the algorithms explained in <a class="link" title="Chapter 5. Recommendation Systems" href="text00037.html#page">Chapter 5</a>&#13;
 , <span class="emphasis">&#13;
<em>Recommendation Systems</em>&#13;
</span>&#13;
 ) is detailed in <a class="link" title="Chapter 7. Movie Recommendation System Web Application" href="text00050.html#page">Chapter 7</a>&#13;
 , <span class="emphasis">&#13;
<em>Movie Recommendation System Web Application</em>&#13;
</span>&#13;
 . We finish the book with an example of a Django web-mining application, using some of the techniques learned in <a class="link" title="Chapter 4. Web Mining Techniques" href="text00032.html#ch04">Chapter 4</a>&#13;
 , <span class="emphasis">&#13;
<em>Web Mining Techniques</em>&#13;
</span>&#13;
 . By the end of the book you should be able to understand the different machine-learning methods and be able to deploy them in a real working web application using Django.</p>&#13;
<p>We continue the <a id="id15" class="indexterm"/>&#13;
 chapter by giving an example of how machine learning can be used in real business problems and in tutorials for Python libraries (NumPy, pandas, and matplotlib), which are essential for putting the algorithms learned in each of the following chapters into practice.</p>&#13;
<div class="section" title="Machine-learning example">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h2 class="title"><a id="ch01lvl2sec07"/>&#13;
 Machine-learning example</h2>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>To explain further <a id="id16" class="indexterm"/>&#13;
 what machine learning can do with real data, we consider the following example (the following code is available in the author's GitHub book folder <a class="ulink" href="https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_1/">https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_1/</a>&#13;
 ). We have taken the <span class="emphasis">&#13;
<em>Internet Advertisements Data Set</em>&#13;
</span>&#13;
 from the <span class="emphasis">&#13;
<em>UC Irvine Machine Learning Repository</em>&#13;
</span>&#13;
 (<a class="ulink" href="http://archive.ics.uci.edu">http://archive.ics.uci.edu</a>&#13;
 ). Web advertisements have been collected from various web pages, and each of them has been transformed into a numeric feature's vector. From the <code class="literal">ad.names</code>&#13;
 file we can see that the first three features represent the image size in the page, and the other features are related to the presence of specific words or phrases on the URL of the image or in the text (1558 features in total). The labels values are either <code class="literal">ad</code>&#13;
 or <code class="literal">nonad</code>&#13;
 , depending on whether the page has an advert or not. As an example, a web page in <code class="literal">ad.data</code>&#13;
 is given by:</p>&#13;
<p>&#13;
<code class="literal">125, 125, ...., 1. 0, 1, 0, ad.</code>&#13;
</p>&#13;
<p>Based on this data, a classical machine-learning task is to find a model to predict which pages are adverts and which are not (classification). To start with, we consider the data file <code class="literal">ad.data</code>&#13;
 which contains the full feature's vectors and labels, but it has also missing values indicated with a <code class="literal">?</code>&#13;
 . We can use the pandas Python library to transform the<code class="literal">?</code>&#13;
 to <code class="literal">-1</code>&#13;
 (see next paragraph for a full tutorial on the pandas library):</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>import pandas as pd</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df = pd.read_csv('ad-dataset/ad.data',header=None)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df=df.replace({'?': np.nan})</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df=df.replace({'  ?': np.nan})</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df=df.replace({'   ?': np.nan})</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df=df.replace({'    ?': np.nan})</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df=df.replace({'     ?': np.nan})</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df=df.fillna(-1)</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>A <span class="strong">&#13;
<strong>DataFrame</strong>&#13;
</span>&#13;
 <a id="id17" class="indexterm"/>&#13;
 is created with the data from the <code class="literal">ad.data</code>&#13;
 file, and each <code class="literal">?</code>&#13;
 is first replaced with the an value (<code class="literal">replace</code>&#13;
 function), then with <code class="literal">-1</code>&#13;
 (the <code class="literal">fillna</code>&#13;
 function). Now each label has to be transformed into a numerical value (and so do all the other values in the data):</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>adindices = df[df.columns[-1]]== 'ad.'</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df.loc[adindices,df.columns[-1]]=1</strong>&#13;

</span>&#13;


<span class="strong">
<strong>nonadindices = df[df.columns[-1]]=='nonad.'</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df.loc[nonadindices,df.columns[-1]]=0</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df[df.columns[-1]]=df[df.columns[-1]].astype(float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>df.apply(lambda x: pd.to_numeric(x))</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Each <code class="literal">ad.</code>&#13;
 label<a id="id18" class="indexterm"/>&#13;
 has been transformed into <code class="literal">1</code>&#13;
 while the <code class="literal">nonad.</code>&#13;
 values have been replaced by <code class="literal">0</code>&#13;
 . All the columns (features) need to be numeric and float types (using the <code class="literal">astype</code>&#13;
 function and the <code class="literal">to_numeric</code>&#13;
 function through a <code class="literal">lambda</code>&#13;
 function).</p>&#13;
<p>We want to use<a id="id19" class="indexterm"/>&#13;
 the <span class="strong">&#13;
<strong>Support Vector Machine</strong>&#13;
</span>&#13;
 (<span class="strong">&#13;
<strong>SVM</strong>&#13;
</span>&#13;
 ) algorithm provided by the <code class="literal">scikit-learn</code>&#13;
 library (see <a class="link" title="Chapter 3. Supervised Machine Learning" href="text00024.html#page">Chapter 3</a>&#13;
 , <span class="emphasis">&#13;
<em>Supervised Machine Learning</em>&#13;
</span>&#13;
 ) to predict 20% of the labels in the data. First, we split the data into two sets: a training set (80%) and a test set (20%):</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>import numpy as np</strong>&#13;

</span>&#13;


<span class="strong">
<strong>dataset = df.values[:,:]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>np.random.shuffle(dataset)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>data = dataset[:,:-1]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>labels = dataset[:,-1].astype(float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>ntrainrows = int(len(data)*.8)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>train = data[:ntrainrows,:]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>trainlabels = labels[:ntrainrows]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>test = data[ntrainrows:,:]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>testlabels = labels[ntrainrows:]</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Using the libraries provided by Numpy (a tutorial is provided in the next paragraph), the data are shuffled (function <code class="literal">random.shuffle</code>&#13;
 ) before being split to assure the rows in the two sets are randomly selected. The <code class="literal">-1</code>&#13;
 notation indicates the last column of the array is not considered.</p>&#13;
<p>Now we train our SVM model using the training data:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>from sklearn.svm import SVC</strong>&#13;

</span>&#13;


<span class="strong">
<strong>clf = SVC(gamma=0.001, C=100.)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>clf.fit(train, trainlabels)</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>We have defined our <code class="literal">clf</code>&#13;
 variable that declares the SVM model with the values of the parameters. Then the function <code class="literal">fit</code>&#13;
 is called to fit the model with the training data (see <a class="link" title="Chapter 3. Supervised Machine Learning" href="text00024.html#page">Chapter 3</a>&#13;
 , <span class="emphasis">&#13;
<em>Supervised Machine Learning</em>&#13;
</span>&#13;
 for further details). The mean accuracy in predicting the 20% test cases is performed as follows, using the score function:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>score=clf.score(test,testlabels)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>print 'score:',score</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Running the <a id="id20" class="indexterm"/>&#13;
 preceding code (the full code is available in the <code class="literal">chapter_1</code>&#13;
 folder of the author's GitHub account) gives a result of 92% accuracy, which means 92% of the test cases of the predicted label agree with the true label. This is the power of machine learning: from previous data, we are able to infer if a page will contain an advert or not. To achieve that, we have essentially prepared and manipulated the data using the NumPy and pandas libraries, and then applied the SVM algorithm on the cleaned data using the <code class="literal">scikit-learn</code>&#13;
 library. Since this book will largely employ the <code class="literal">numpy</code>&#13;
 and <code class="literal">pandas</code>&#13;
 (and some <code class="literal">matplotlib</code>&#13;
 ) libraries, the following paragraphs will discuss how to install the libraries and how the data can be manipulated (or even created) using these libraries.</p>&#13;
<div class="section" title="Installing and importing a module (library)">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h3 class="title"><a id="ch01lvl3sec01"/>&#13;
 Installing and importing a module (library)</h3>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Before continuing<a id="id21" class="indexterm"/>&#13;
 with the discussion on<a id="id22" class="indexterm"/>&#13;
 the libraries, we need to clarify how<a id="id23" class="indexterm"/>&#13;
 to install each module we want to use in Python. The usual <a id="id24" class="indexterm"/>&#13;
 way to install a module is through the <code class="literal">pip</code>&#13;
 command using the terminal:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; sudo pip install modulename</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The module is then usually imported into the code using the statement:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>import numpy as np</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Here, <code class="literal">numpy</code>&#13;
 is the library name and <code class="literal">np</code>&#13;
 is the reference name from which any function <span class="emphasis">&#13;
<em>X</em>&#13;
</span>&#13;
 in the library can be accessed using <code class="literal">np.X</code>&#13;
 instead of <code class="literal">numpy.X</code>&#13;
 . We are going to assume that all the libraries (<code class="literal">scipy</code>&#13;
 , <code class="literal">scikit-learn</code>&#13;
 , <code class="literal">pandas</code>&#13;
 , <code class="literal">scrapy</code>&#13;
 , <code class="literal">nltk</code>&#13;
 , and all others) have been be installed and imported in this way.</p>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;

<div class="section" title="Preparing, manipulating and visualizing data &#x2013; NumPy, pandas and matplotlib tutorials">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch01lvl1sec09"/>&#13;
 Preparing, manipulating and visualizing data – NumPy, pandas and matplotlib tutorials</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Most of the <a id="id25" class="indexterm"/>&#13;
 data comes in a very unpractical form for applying machine-learning <a id="id26" class="indexterm"/>&#13;
 algorithms. As we have seen in the example (in the preceding paragraph), the<a id="id27" class="indexterm"/>&#13;
 data can have missing values or non-numeric columns, which are not ready to be fed into any machine-learning technique. Therefore, a machine-learning professional usually spends a large amount of time cleaning and preparing the data to transform it into a form suitable for further analysis or visualization. This section will teach how to use <code class="literal">numpy</code>&#13;
 and <code class="literal">pandas</code>&#13;
 to create, prepare, and manipulate data in Python while the <code class="literal">matplotlib</code>&#13;
 paragraph will provide the basis of plotting a graph in Python. The Python shell has been used to discuss the NumPy tutorial, although all versions of the <a id="id28" class="indexterm"/>&#13;
 code in the IPython notebook, and plain Python script, are<a id="id29" class="indexterm"/>&#13;
 available in the <code class="literal">chapter_1</code>&#13;
 folder of the <a id="id30" class="indexterm"/>&#13;
 author's GitHub. pandas and matplotlib are discussed using the IPython notebook.</p>&#13;
<div class="section" title="Using NumPy">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h2 class="title"><a id="ch01lvl2sec08"/>&#13;
 Using NumPy</h2>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Numerical Python<a id="id31" class="indexterm"/>&#13;
 or NumPy, is an open source extension library for Python, and is a fundamental module required for data analysis and high performance scientific computing. The library features support Python for large, multi-dimensional arrays and matrices, and it provides precompiled functions for numerical routines. Furthermore, it provides a large library of mathematical functions to manipulate these arrays.</p>&#13;
<p>The library provides the following functionalities:</p>&#13;
<div class="itemizedlist">&#13;
<ul class="itemizedlist">&#13;
<li class="listitem">Fast multi-dimensional array for vector arithmetic operations</li>&#13;
<li class="listitem">Standard mathematical functions for fast operations on entire arrays of data</li>&#13;
<li class="listitem">Linear algebra</li>&#13;
<li class="listitem">Sorting, unique, and set operations</li>&#13;
<li class="listitem">Statistics and aggregating data</li>&#13;
</ul>&#13;
</div>&#13;
<p>The main advantage of NumPy is the speed of the usual array operations compared to standard Python operations. For instance, a traditional summation of 10000000 elements:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; def sum_trad():</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   start = time.time()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   X = range(10000000)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   Y = range(10000000)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   Z = []</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   for i in range(len(X)):</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;       Z.append(X[i] + Y[i])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   return time.time() - start</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Compare this to the Numpy function:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; def sum_numpy():</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   </strong>&#13;

</span>&#13;


<span class="strong">
<strong>start = time.time()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   X = np.arange(10000000) </strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   Y = np.arange(10000000) </strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   Z=X+Y</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;   return time.time() - start</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; print 'time sum:',sum_trad(),'  time sum numpy:',sum_numpy()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>time sum: 2.1142539978   time sum numpy: 0.0807049274445</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The time <a id="id32" class="indexterm"/>&#13;
 used is <code class="literal">2.1142539978</code>&#13;
 and <code class="literal">0.0807049274445</code>&#13;
 respectively.</p>&#13;
<div class="section" title="Arrays creation">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h3 class="title"><a id="ch01lvl3sec02"/>&#13;
 Arrays creation</h3>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>The<a id="id33" class="indexterm"/>&#13;
 array object is the main feature provided by the NumPy library. Arrays are the equivalent of Python lists, but each element of an array has the same numerical type (typically float or int). It is possible to define an array casting from a list using the function array by using the following code. Two arguments are passed to it: the list to be converted and the type of the new generated array:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([2, 6, 5, 9], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 2., 6., 5., 9.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; type(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&lt;type 'numpy.ndarray'&gt;</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>And vice versa, an array can be transformed into a list by the following code:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([1, 2, 3], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr.tolist()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>[1.0, 2.0, 3.0]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; list(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>[1.0, 2.0, 3.0]</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<div class="note" title="Note">&#13;
<h3 class="title"><a id="note02"/>&#13;
 Note</h3>&#13;
<p>Assigning an array to a new one will not create a new copy in memory, it will just link the new name to the same original object.</p>&#13;
</div>&#13;
<p>To create a new object from an existing one, the <code class="literal">copy</code>&#13;
 function needs to be used:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([1, 2, 3], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 = arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = arr.copy()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[0] = 0</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([0., 2., 3.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([0., 2., 3.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([1., 2., 3.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Alternatively an array can be filled with a single value in the following way:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([10, 20, 33], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 10., 20., 33.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr.fill(1)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 1., 1., 1.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Arrays can <a id="id34" class="indexterm"/>&#13;
 also be created randomly using the <code class="literal">random</code>&#13;
 submodule. For example, giving the length of an array as an input of the function, <code class="literal">permutation</code>&#13;
 will find a random sequence of integers:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.random.permutation(3)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([0, 1, 2])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Another method, <code class="literal">normal</code>&#13;
 , will draw a sequence of numbers from a normal distribution:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.random.normal(0,1,5)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([-0.66494912,  0.7198794 , -0.29025382,  0.24577752,  0.23736908])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>&#13;
<code class="literal">0</code>&#13;
 is the mean of the distribution while <code class="literal">1</code>&#13;
 is the standard deviation and <code class="literal">5</code>&#13;
 is the number of array's elements to draw. To use a uniform distribution, the random function will return numbers between <code class="literal">0</code>&#13;
 and <code class="literal">1</code>&#13;
 (not included):</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.random.random(5)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 0.48241564,  0.24382627,  0.25457204,  0.9775729 ,  0.61793725])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>NumPy also provides a number of functions for creating two-dimensional arrays (matrices). For instance, to create an identity matrix of a given dimension, the following code can be used:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.identity(5, dtype=float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 1.,  0.,  0.,  0.,  0.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.,  1.,  0.,  0.,  0.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.,  0.,  1.,  0.,  0.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.,  0.,  0.,  1.,  0.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.,  0.,  0.,  0.,  1.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The <code class="literal">eye</code>&#13;
 function returns matrices with ones along the kth diagonal:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.eye(3, k=1, dtype=float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0.,  1.,  0.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.,  0.,  1.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.,  0.,  0.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The most commonly used functions to create new arrays (1 or 2 dimensional) are <code class="literal">zeros</code>&#13;
 and <code class="literal">ones</code>&#13;
 which create new arrays of specified dimensions filled with these values. These are:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.ones((2,3), dtype=float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 1., 1., 1.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 1., 1., 1.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.zeros(6, dtype=int)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([0, 0, 0, 0, 0, 0])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The <code class="literal">zeros_like</code>&#13;
 and <code class="literal">ones_like</code>&#13;
 functions instead create a new array with the same type as an existing one, with the same dimensions:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([[13, 32, 31], [64, 25, 76]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.zeros_like(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0.,  0.,  0.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.,  0.,  0.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.ones_like(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 1.,  1.,  1.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 1.,  1.,  1.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Another way<a id="id35" class="indexterm"/>&#13;
 to create two-dimensional arrays is to merge one-dimensional arrays using <code class="literal">vstack</code>&#13;
 (vertical merge):</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([1,3,2])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([3,4,6])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.vstack([arr1,arr2])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[1, 3, 2],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [3, 4, 6]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The creation using distributions are also possible for two-dimensional arrays, using the <code class="literal">random</code>&#13;
 submodule. For example, a random matrix 2x3 from a uniform distribution between <code class="literal">0</code>&#13;
 and <code class="literal">1</code>&#13;
 is created by the following command:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.random.rand(2,3)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0.36152029,  0.10663414,  0.64622729],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>    [ 0.49498724,  0.59443518,  0.31257493]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Another often used distribution is the multivariate normal distribution:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.random.multivariate_normal([10, 0], [[3, 1], [1, 4]], size=[5,])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 11.8696466 ,  -0.99505689],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 10.50905208,   1.47187705],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [  9.55350138,   0.48654548],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 10.35759256,  -3.72591054],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 11.31376171,   2.15576512]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The list <code class="literal">[10,0]</code>&#13;
 is the mean vector, <code class="literal">[[3, 1], [1, 4]]</code>&#13;
 is the covariance matrix and <code class="literal">5</code>&#13;
 is the number of samples to draw.</p>&#13;
<div class="informaltable">&#13;
<table border="1">&#13;
<colgroup><col/>&#13;
<col/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th valign="bottom">&#13;
<p>Method</p>&#13;
</th>&#13;
<th valign="bottom">&#13;
<p>Description</p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">tolist</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Function <a id="id36" class="indexterm"/>&#13;
 to transform NumPy array to list</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">copy</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Function <a id="id37" class="indexterm"/>&#13;
 to copy NumPy array values</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">ones</code>&#13;
 , <code class="literal">zeros</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Functions to <a id="id38" class="indexterm"/>&#13;
 create an <a id="id39" class="indexterm"/>&#13;
 array of zeros or ones</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">zeros_like</code>&#13;
 , <code class="literal">ones_like</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Functions to <a id="id40" class="indexterm"/>&#13;
 create two-dimensional arrays with same shape of the input list</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">fill</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Function to <a id="id41" class="indexterm"/>&#13;
 replace an array entries with a certain value</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">identity</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Function to <a id="id42" class="indexterm"/>&#13;
 create identity matrix</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">eye</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Function to<a id="id43" class="indexterm"/>&#13;
 create a matrix with one entry along a kth diagonal</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">vstack</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Function <a id="id44" class="indexterm"/>&#13;
 to merge arrays<a id="id45" class="indexterm"/>&#13;
 into two-dimensional<a id="id46" class="indexterm"/>&#13;
 arrays</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>random submodule: <code class="literal">random</code>&#13;
 , <code class="literal">permutation</code>&#13;
 , <code class="literal">normal</code>&#13;
 , <code class="literal">rand</code>&#13;
 , <code class="literal">multivariate_normal</code>&#13;
 , and others</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Random<a id="id47" class="indexterm"/>&#13;
 submodule create arrays drawing samples from distributions</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
<div class="section" title="Array manipulations">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h3 class="title"><a id="ch01lvl3sec03"/>&#13;
 Array manipulations</h3>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>All the<a id="id48" class="indexterm"/>&#13;
 usual operations to access, slice, and manipulate a Python list can be applied in the same way, or in a similar way to an array:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([2., 6., 5., 5.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[:3]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 2., 6., 5.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[3]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>5.0</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[0] = 5.</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 5., 6., 5., 5.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The unique value can be also selected using <code class="literal">unique</code>&#13;
 :</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.unique(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 5., 6., 5.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The values of the array can also be sorted using <code class="literal">sort</code>&#13;
 and its indices with <code class="literal">argsort</code>&#13;
 :</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.sort(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 2.,  5.,  5.,  6.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.argsort(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([0, 2, 3, 1])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>It is also possible to randomly rearrange the order of the array's elements using the <code class="literal">shuffle</code>&#13;
 function:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.random.shuffle(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 2.,  5.,  6.,  5.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>NumPy also has a built-in function to compare arrays <code class="literal">array_equal</code>&#13;
 :</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; np.array_equal(arr,np.array([1,3,2]))</strong>&#13;

</span>&#13;


<span class="strong">
<strong>False</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Multi-dimensional<a id="id49" class="indexterm"/>&#13;
 arrays, however, differ from the list. In fact, a list of dimensions is specified using the comma (instead of a bracket for list). For example, the elements of a two-dimensional array (that is a matrix) are accessed in the following way:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; matrix = np.array([[ 4., 5., 6.], [2, 3, 6]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; matrix</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 4., 5., 6.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 2., 3., 6.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; matrix[0,0]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>4.0</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; matrix[0,2]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>6.0</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Slicing is applied on each dimension using the colon <code class="literal">:</code>&#13;
 symbol between the initial value and the end value of the slice:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([[ 4., 5., 6.], [ 2., 3., 6.]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[1:2,2:3]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 6.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>While a single <code class="literal">:</code>&#13;
 means all the elements along that axis are considered:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr[1,:]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([2, 3, 6])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[:,2]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 6., 6.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[-1:,-2:]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 3., 6.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>One-dimensional arrays can be obtained from multi-dimensional arrays using the <code class="literal">flatten</code>&#13;
 function:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([[10, 29, 23], [24, 25, 46]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 10.,  29.,  23.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 24.,  25.,  46.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr.flatten()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 10.,  29.,  23.,  24.,  25.,  46.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>It is also possible to inspect an array object to obtain information about its content. The size of an array is found using the attribute shape:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr.shape</strong>&#13;

</span>&#13;


<span class="strong">
<strong>(2, 3)</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>In this case, <code class="literal">arr</code>&#13;
 is a matrix of two rows and three columns. The <code class="literal">dtype</code>&#13;
 property returns the type<a id="id50" class="indexterm"/>&#13;
 of values are stored within the array:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr.dtype</strong>&#13;

</span>&#13;


<span class="strong">
<strong>dtype('float64')</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>&#13;
<code class="literal">float64</code>&#13;
 is a numeric type to store double-precision (8-byte) real numbers (similar to <code class="literal">float</code>&#13;
 type in regular Python). There are also other data types such as <code class="literal">int64</code>&#13;
 , <code class="literal">int32</code>&#13;
 , <code class="literal">string,</code>&#13;
 and an array can be converted from one type to another. For example:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt;int_arr = matrix.astype(np.int32)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;int_arr.dtype</strong>&#13;

</span>&#13;


<span class="strong">
<strong>dtype('int32')</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The <code class="literal">len</code>&#13;
 function returns the length of the first dimension when used on an array:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt;arr = np.array([[ 4., 5., 6.], [ 2., 3., 6.]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; len(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>2</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Like in Python for loop, the <code class="literal">in</code>&#13;
 word can be used to check if a value is contained in an array:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([[ 4., 5., 6.], [ 2., 3., 6.]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; 2 in arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>True</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; 0 in arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>False</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>An array can be manipulated in such a way that its elements are rearranged in different dimensions using the function <code class="literal">reshape</code>&#13;
 . For example, a matrix with eight rows and one column can be reshaped to a matrix with four rows and two columns:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array(range(8), float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 0., 1., 2., 3., 4., 5., 6., 7.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr = arr.reshape((4,2))</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0.,  1.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 2.,  3.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       </strong>&#13;

</span>&#13;


<span class="strong">
<strong>[ 4.,  5.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 6.,  7.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr.shape</strong>&#13;

</span>&#13;


<span class="strong">
<strong>(4, 2)</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>In addition, transposed matrices can be created; that is to say, a new array with the final two dimensions switched can be obtained using the transpose function:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array(range(6), float).reshape((2, 3))</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0., 1., 2.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>      [ 3., 4., 5.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr.transpose()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0., 3.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 1., 4.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 2., 5.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Arrays <a id="id51" class="indexterm"/>&#13;
 can also be transposed using the <code class="literal">T</code>&#13;
 attribute:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; matrix = np.arange(15).reshape((3, 5))</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; matrix</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0, 1, 2, 3, 4], </strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 5, 6, 7, 8, 9], </strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [10, 11, 12, 13, 14]]) </strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;matrix .T</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0, 5, 10],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 1, 6, 11],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 2, 6, 12],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       </strong>&#13;

</span>&#13;


<span class="strong">
<strong>[ 3, 8, 13],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 4, 9, 14]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Another way to reshuffle the elements of an array is to use the <code class="literal">newaxis</code>&#13;
 function to increase the dimensionality:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([14, 32, 13], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 14.,  32.,  13.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt; arr[:,np.newaxis]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 14.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 32.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 13.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[:,np.newaxis].shape</strong>&#13;

</span>&#13;


<span class="strong">
<strong>(3,1)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[np.newaxis,:]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 14.,  32.,  13.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[np.newaxis,:].shape</strong>&#13;

</span>&#13;


<span class="strong">
<strong>(1,3)</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>In this example, in each case the new array has two dimensions, the one generated by <code class="literal">newaxis</code>&#13;
 has a length of one.</p>&#13;
<p>Joining arrays is an operation performed by the <code class="literal">concatenate</code>&#13;
 function in NumPy, and the syntax depends on the dimensionality of the array. Multiple one-dimensional arrays can be <a id="id52" class="indexterm"/>&#13;
 chained, specifying the arrays to be joined as a tuple:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([10,22], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([31,43,54,61], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr3 = np.array([71,82,29], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.concatenate((arr1, arr2, arr3))</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 10.,  22.,  31.,  43.,  54.,  61.,  71.,  82.,  29.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Using a multi-dimensional array, the axis along which multiple arrays are concatenated needs to be specified. Otherwise, NumPy concatenates along the first dimension by default:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([[11, 12], [32, 42]], float)</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([[54, 26], [27,28]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.concatenate((arr1,arr2))</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 11.,  12.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 32.,  42.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 54.,  26.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 27.,  28.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.concatenate((arr1,arr2), axis=0)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 11.,  12.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 32.,  42.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 54.,  26.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 27.,  28.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.concatenate((arr1,arr2), axis=1)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 11.,  12.,  54.,  26.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 32.,  42.,  27.,  28.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>It is common to save a large amount of data as a binary file instead of using the direct format. NumPy provides a function, <code class="literal">tostring</code>&#13;
 , to convert an array to a binary string. Of course there's also the inverse operation, where a conversion of a binary string to an array is supported using the <code class="literal">fromstring</code>&#13;
 routine. For example:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([10, 20, 30], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; str = arr.tostring()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; str</strong>&#13;

</span>&#13;


<span class="strong">
<strong>'\x00\x00\x00\x00\x00\x00$@\x00\x00\x00\x00\x00\x004@\x00\x00\x00\x00\x00\x00&gt;@'</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.fromstring(str)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 10., 20., 30.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<div class="informaltable">&#13;
<table border="1">&#13;
<colgroup><col/>&#13;
<col/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th valign="bottom">&#13;
<p>Method</p>&#13;
</th>&#13;
<th valign="bottom">&#13;
<p>Description</p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">unique</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Function to <a id="id53" class="indexterm"/>&#13;
 select only unique values from an array</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">random</code>&#13;
 , <code class="literal">shuffle</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Function to<a id="id54" class="indexterm"/>&#13;
 randomly<a id="id55" class="indexterm"/>&#13;
 rearrange<a id="id56" class="indexterm"/>&#13;
 the elements of an array</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">sort</code>&#13;
 , <code class="literal">argsort</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">sort</code>&#13;
 sorts<a id="id57" class="indexterm"/>&#13;
 the order of an array's values in increasing<a id="id58" class="indexterm"/>&#13;
 order, while <code class="literal">argsort</code>&#13;
 orders the array's indices such that the array gets arranged in an increasing order</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">array_equal</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Compare<a id="id59" class="indexterm"/>&#13;
 two arrays and return a True id (they are equal False otherwise)</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">flatten</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Transform <a id="id60" class="indexterm"/>&#13;
 a two-dimensional array into a one-dimensional array</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">transpose</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Calculate<a id="id61" class="indexterm"/>&#13;
 the transpose of a two-dimensional array</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">reshape</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Rearrange<a id="id62" class="indexterm"/>&#13;
 entries of a two-dimensional array into a different shape</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">concatenate</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Concatenate<a id="id63" class="indexterm"/>&#13;
 two -dimensional arrays into one matrix</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">fromstring</code>&#13;
 , <code class="literal">tostring</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Convert <a id="id64" class="indexterm"/>&#13;
 an <a id="id65" class="indexterm"/>&#13;
 array to a binary string</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
<div class="section" title="Array operations">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h3 class="title"><a id="ch01lvl3sec04"/>&#13;
 Array operations</h3>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Common <a id="id66" class="indexterm"/>&#13;
 mathematical operations are obviously supported in NumPy. For example:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([1,2,3], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([1,2,3], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 + arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([2.,4., 6.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1–arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([0., 0., 0.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 * arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([51, 4., 9.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 / arr1</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([1., 1., 1.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 % arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([0., 0., 0.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2**arr1</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([1., 4., 9.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Since any <a id="id67" class="indexterm"/>&#13;
 operation is applied element wise, the arrays are required to have the same size. If this condition is not satisfied, an error is returned:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([1,2,3], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([1,2], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 + arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>Traceback (most recent call last):</strong>&#13;

</span>&#13;


<span class="strong">
<strong>File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>&#13;

</span>&#13;


<span class="strong">
<strong>ValueError: shape mismatch: objects cannot be broadcast to a single shape</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The error states that the objects cannot be <code class="literal">broadcasted</code>&#13;
 because the only way to perform an operation with arrays of different size is called broadcasting. This means the arrays have a different number of dimensions, and the array with less dimensions will be repeated until it matches the dimensions of the other array. Consider the following:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([[1, 2], [3, 4], [5, 6]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([1, 2], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 1., 2.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 3., 4.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 5., 6.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([1., 1.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 + arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 2., 4.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 4., 6.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 6., 8.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The array <code class="literal">arr2</code>&#13;
 was <span class="emphasis">&#13;
<em>broadcasted</em>&#13;
</span>&#13;
 to a two-dimensional array that matched the size of <code class="literal">arr1</code>&#13;
 . Therefore, <code class="literal">arr2</code>&#13;
 was repeated for each dimension of <code class="literal">arr1</code>&#13;
 , equivalent to the array:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>array([[1., 2.],[1., 2.],[1., 2.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>If we want to make the way an array is broadcasted explicit, the <code class="literal">newaxis</code>&#13;
 constant allows us to specify how we want to broadcast:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.zeros((2,2), float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([1., 2.], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0., 0.],[ 0., 0.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([1., 2.])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 + arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[-1., 3.],[-1., 3.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 + arr2[np.newaxis,:]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[1., 2.],[1., 2.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 + arr2[:,np.newaxis]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[1.,1.],[ 2., 2.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Unlike Python<a id="id68" class="indexterm"/>&#13;
 lists, arrays can be queried using conditions. A typical example is to use Boolean arrays to filter the elements:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([[1, 2], [5, 9]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr &gt;= 7</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ False, False],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>[False, True]], dtype=bool)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[arr &gt;= 7]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 9.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Multiple Boolean expressions can be used to subset the array:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr[np.logical_and(arr &gt; 5, arr &lt; 11)]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 9.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Arrays of integers can be used to specify the indices to select the elements of another array. For example:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([1, 4, 5, 9], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([0, 1, 1, 3, 1, 1, 1], int)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1[arr2]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 1., 4., 4., 9., 4., 4., 4.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The <code class="literal">arr2</code>&#13;
 represents the ordered indices to select elements from array <code class="literal">arr1</code>&#13;
 : the zeroth, first, first, third, first, first, and first elements of <code class="literal">arr1</code>&#13;
 , in that order have been selected. Also lists can be used for the same purpose:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.array([1, 4, 5, 9], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr[[0, 1, 1, 3, 1]]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 1., 4., 4., 9., 4.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>In order to replicate the same operation with multi-dimensional arrays, multiple one-dimensional integer arrays have to be put into the selection bracket, one for each dimension.</p>&#13;
<p>The first selection array represents the values of the first index in the matrix entries, while the values on the second selection array represent the column index of the matrix entries. The following example illustrates the idea:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([[1, 2], [5, 13]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([1, 0, 0, 1], int)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr3 = np.array([1, 1, 0, 1], int)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1[arr2,arr3]</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 13.,   2.,   1.,  13.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The values<a id="id69" class="indexterm"/>&#13;
 on <code class="literal">arr2</code>&#13;
 are the first index (row) on <code class="literal">arr1</code>&#13;
 entries while <code class="literal">arr3</code>&#13;
 are the second index (column) values, so the first chosen entry on <code class="literal">arr1</code>&#13;
 corresponds to row 1 column 1 which is <code class="literal">13</code>&#13;
 .</p>&#13;
<p>The function <code class="literal">take</code>&#13;
 can be used to apply your selection with integer arrays, and it works in the same way as bracket selection:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([7, 6, 6, 9], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([1, 0, 1, 3, 3, 1], int)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1.take(arr2)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 6.,  7.,  6.,  9.,  9.,  6.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Subsets of a multi-dimensional array can be selected along a given dimension specifying the axis argument on the <code class="literal">take</code>&#13;
 function:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([[10, 21], [62, 33]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([0, 0, 1], int)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1.take(arr2, axis=0)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 10.,  21.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 10.,  21.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 62.,  33.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1.take(arr2, axis=1)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 10.,  10.,  21.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 62.,  62.,  33.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The <code class="literal">put</code>&#13;
 function is the opposite of the <code class="literal">take</code>&#13;
 function, and it takes values from an array and puts them at specified indices in the array that calls the <code class="literal">put</code>&#13;
 method:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([2, 1, 6, 2, 1, 9], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([3, 10, 2], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1.put([1, 4], arr2)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 2.,  3.,  6.,  2.,  10.,  9.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>We finish this section with the note that multiplication also remains element-wise for two-dimensional arrays (and does not correspond to matrix multiplication):</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([[11,22], [23,14]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([[25,30], [13,33]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr1 * arr2</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 275.,  660.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 299.,  462.]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<div class="informaltable">&#13;
<table border="1">&#13;
<colgroup><col/>&#13;
<col/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th valign="bottom">&#13;
<p>Method</p>&#13;
</th>&#13;
<th valign="bottom">&#13;
<p>Description</p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">take</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Select<a id="id70" class="indexterm"/>&#13;
 values of an array from indices given by a second array</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">put</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Replace<a id="id71" class="indexterm"/>&#13;
 the values in an array with values of another array at given positions</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
<div class="section" title="Linear algebra operations">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h3 class="title"><a id="ch01lvl3sec05"/>&#13;
 Linear algebra operations</h3>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>The most<a id="id72" class="indexterm"/>&#13;
 common operations between matrices is the inner product of a matrix with its transpose, <span class="emphasis">&#13;
<em>X<sup>T</sup>&#13;
 X</em>&#13;
</span>&#13;
 , using <code class="literal">np.dot</code>&#13;
 :</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; X = np.arange(15).reshape((3, 5))</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; X</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0, 1, 2, 3, 4], </strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 5, 6, 7, 8, 9], </strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [10, 11, 12, 13, 14]]) </strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; X.T</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0, 5, 10],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 1, 6, 11],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 2, 6, 12],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 3, 8, 13],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 4, 9, 14]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt;np.dot(X .T, X)#X^T X</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 2.584 , 1.8753, 0.8888], </strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 1.8753, 6.6636, 0.3884], </strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.8888, 0.3884, 3.9781]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>There are functions to directly calculate the different types of product (<code class="literal">inner</code>&#13;
 , <code class="literal">outer</code>&#13;
 , and <code class="literal">cross</code>&#13;
 ) on arrays (that is matrices or vectors).</p>&#13;
<p>For one-dimensional arrays (vectors) the inner product corresponds to the dot product:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr1 = np.array([12, 43, 10], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr2 = np.array([21, 42, 14], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.outer(arr1, arr2)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[  252.,   504.,   168.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [  903.,  1806.,   602.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [  210.,   420.,   140.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.inner(arr1, arr2)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>2198.0</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.cross(arr1, arr2)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 182.,   42., -399.])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>NumPy also contains a sub-module, <code class="literal">linalg</code>&#13;
 that has a series of functions to perform linear algebra calculations over matrices. The determinant of a matrix can be computed as:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; matrix = np.array([[74, 22, 10], [92, 31, 17], [21, 22, 12]], float)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; matrix</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 74.,  22.,  10.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 92.,  31.,  17.],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 21.,  22.,  12.]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.linalg.det(matrix)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>-2852.0000000000032</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>Also<a id="id73" class="indexterm"/>&#13;
 the inverse of a matrix can be generated using the function <code class="literal">inv</code>&#13;
 :</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; inv_matrix = np.linalg.inv(matrix)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; inv_matrix</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[ 0.00070126,  0.01542777, -0.02244039],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ 0.26192146, -0.23772791,  0.11851332],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [-0.48141655,  0.4088359 , -0.09467041]])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.dot(inv_matrix,matrix)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[  1.00000000e+00,   2.22044605e-16,   4.77048956e-17],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ -2.22044605e-15,   1.00000000e+00,   0.00000000e+00],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [ -3.33066907e-15,  -4.44089210e-16,   1.00000000e+00]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>It is straightforward to calculate the eigenvalues and eigenvectors of a matrix:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; vals, vecs = np.linalg.eig(matrix)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; vals</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([ 107.99587441,   11.33411853,   -2.32999294])</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; vecs</strong>&#13;

</span>&#13;


<span class="strong">
<strong>array([[-0.57891525, -0.21517959,  0.06319955],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [-0.75804695,  0.17632618, -0.58635713],</strong>&#13;

</span>&#13;


<span class="strong">
<strong>       [-0.30036971,  0.96052424,  0.80758352]])</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<div class="informaltable">&#13;
<table border="1">&#13;
<colgroup><col/>&#13;
<col/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th valign="bottom">&#13;
<p>Method</p>&#13;
</th>&#13;
<th valign="bottom">&#13;
<p>Description</p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">dot</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Dot <a id="id74" class="indexterm"/>&#13;
 product between two arrays</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">inner</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Inner <a id="id75" class="indexterm"/>&#13;
 product between multi-dimensional arrays</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">linalg</code>&#13;
 module with functions such as: <code class="literal">linalg.det</code>&#13;
 , <code class="literal">linalg.inv</code>&#13;
 , <code class="literal">linalg.eig</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">linalg</code>&#13;
 is <a id="id76" class="indexterm"/>&#13;
 a module that collects several linear algebra methods among which are the determinant of a matrix (<code class="literal">det</code>&#13;
 ), the inverse of a matrix (<code class="literal">inv</code>&#13;
 ) and the eigenvalues, eigenvectors of a matrix (<code class="literal">eig</code>&#13;
 )</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
<div class="section" title="Statistics and mathematical functions">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h3 class="title"><a id="ch01lvl3sec06"/>&#13;
 Statistics and mathematical functions</h3>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>NumPy provides a<a id="id77" class="indexterm"/>&#13;
 set of functions to compute statistics of the data <a id="id78" class="indexterm"/>&#13;
 contained in the arrays. Operations of the aggregation type, such as sum, mean, median, and standard deviation are available as an attribute of an array. For example, creating a random array (from a normal distribution), it is possible to calculate the mean in two ways:</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">
<span class="strong">
<strong>&gt;&gt;&gt; arr = np.random.rand(8, 4)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr.mean()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>0.45808075801881332</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; np.mean(arr)</strong>&#13;

</span>&#13;


<span class="strong">
<strong>0.45808075801881332</strong>&#13;

</span>&#13;


<span class="strong">
<strong>&gt;&gt;&gt; arr.sum()</strong>&#13;

</span>&#13;


<span class="strong">
<strong>14.658584256602026</strong>&#13;

</span>&#13;


</pre>&#13;
</div>&#13;
<p>The full list of functions is shown in the table below:</p>&#13;
<div class="informaltable">&#13;
<table border="1">&#13;
<colgroup><col/>&#13;
<col/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th valign="bottom">&#13;
<p>Method</p>&#13;
</th>&#13;
<th valign="bottom">&#13;
<p>Description</p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">mean</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>mean<a id="id79" class="indexterm"/>&#13;
 of the elements. If the array is empty, the mean is set to <code class="literal">Na</code>&#13;
 <code class="literal">N</code>&#13;
 by default.</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">std</code>&#13;
 , <code class="literal">var</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Functions <a id="id80" class="indexterm"/>&#13;
 to calculate<a id="id81" class="indexterm"/>&#13;
 the standard deviation (<code class="literal">std</code>&#13;
 ) and variance (<code class="literal">var</code>&#13;
 ) of the array. An optional degree of freedom parameter can be specified (default is the length of the array).</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">min</code>&#13;
 , <code class="literal">max</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>Functions<a id="id82" class="indexterm"/>&#13;
 to determine<a id="id83" class="indexterm"/>&#13;
 the minimum (<code class="literal">min</code>&#13;
 ) and maximum (<code class="literal">max</code>&#13;
 ) value contained in the array.</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td valign="top">&#13;
<p>&#13;
<code class="literal">argmin</code>&#13;
 , <code class="literal">argmax</code>&#13;
</p>&#13;
</td>&#13;
<td valign="top">&#13;
<p>These<a id="id84" class="indexterm"/>&#13;
 functions <a id="id85" class="indexterm"/>&#13;
 return the index of the smallest element (<code class="literal">argmin</code>&#13;
 ) and largest element (<code class="literal">argmax</code>&#13;
 ).</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<div class="section" title="Understanding the pandas module">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h2 class="title"><a id="ch01lvl2sec09"/>&#13;
 Understanding the pandas module</h2>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>pandas is a <a id="id86" class="indexterm"/>&#13;
 powerful Python module that contains a wide range of functions to analyze data structures. pandas relies on the NumPy library and it is designed to make data analysis operations easy and fast. This module offers high performance with respect to normal Python functions, especially for reading or writing files or making databases; pandas is the optimal choice to perform data manipulation. The following paragraphs discuss the main methods to explore the information contained in the data, and how to perform manipulations on it. We start by describing how data is stored in pandas and how to load data into it.</p>&#13;
<div class="note" title="Note">&#13;
<h3 class="title"><a id="note03"/>&#13;
 Note</h3>&#13;
<p>Throughout the rest of the book, we use the following import conventions for <code class="literal">pandas</code>&#13;
 :</p>&#13;
<div class="informalexample">&#13;
<pre class="programlisting">       import pandas as pd</pre>&#13;
</div>&#13;
<p>Therefore, whenever code contains the letters <code class="literal">pd</code>&#13;
 , it is referring to <code class="literal">pandas</code>&#13;
 .</p>&#13;
</div>&#13;
<div class="section" title="Exploring data">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h3 class="title"><a id="ch01lvl3sec07"/>&#13;
 Exploring data</h3>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>In order to<a id="id87" class="indexterm"/>&#13;
 introduce the database structure, called <a id="id88" class="indexterm"/>&#13;
 <span class="strong">&#13;
<strong>DataFrame</strong>&#13;
</span>&#13;
 , into pandas, we need to describe the one-dimensional array-like object containing data of any NumPy data type and an associated array of data label called its index. This structure is called <code class="literal">Series</code>&#13;
 and a simple example is:</p>&#13;
<div class="mediaobject"><img src="Image00001.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The <code class="literal">obj</code>&#13;
 object is composed of two values, the index on the left and the associated value on the right. Given that the length of the data is equal to <span class="emphasis">&#13;
<em>N,</em>&#13;
</span>&#13;
 the default indexing goes from <code class="literal">0</code>&#13;
 to <span class="emphasis">&#13;
<em>N-1</em>&#13;
</span>&#13;
 . The array and index objects of the <code class="literal">Series</code>&#13;
 can be obtained using its values and index attributes, respectively:</p>&#13;
<div class="mediaobject"><img src="Image00002.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The indexing is preserved by applying NumPy array operations (such as scalar multiplication, filtering<a id="id89" class="indexterm"/>&#13;
 with a Boolean array, or applying math functions):</p>&#13;
<div class="mediaobject"><img src="Image00003.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>A Python dictionary can be transformed into a <code class="literal">Series</code>&#13;
 but the indexing will correspond to the key values:</p>&#13;
<div class="mediaobject"><img src="Image00004.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>It is possible to specify a separated list as an index:</p>&#13;
<div class="mediaobject"><img src="Image00005.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>In this<a id="id90" class="indexterm"/>&#13;
 case, the last index value, <code class="literal">g</code>&#13;
 , has not got an associated object value, so by<a id="id91" class="indexterm"/>&#13;
 default a <span class="strong">&#13;
<strong>Not a Number</strong>&#13;
</span>&#13;
 (<span class="strong">&#13;
<strong>NaN</strong>&#13;
</span>&#13;
 ) is inserted.</p>&#13;
<p>The terms of <span class="emphasis">&#13;
<em>missing</em>&#13;
</span>&#13;
 or <span class="emphasis">&#13;
<em>NA</em>&#13;
</span>&#13;
 will be used to refer to missing data. To find the missing data the <code class="literal">isnull</code>&#13;
 and <code class="literal">notnull</code>&#13;
 functions can be used in pandas:</p>&#13;
<div class="mediaobject"><img src="Image00006.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>We can now <a id="id92" class="indexterm"/>&#13;
 start loading a CSV file into a DataFrame structure. A DataFrame represents a data structure containing an ordered set of columns, each of which can be a different value type (numeric, string, Boolean, and others). The DataFrame has two indices (a row and column index) and it can be thought of as a dictionary of <code class="literal">Series</code>&#13;
 that share the same index (column). For the purpose of this tutorial, we <a id="id93" class="indexterm"/>&#13;
 are using the data contained in the <code class="literal">ad.data</code>&#13;
 file stored in the <a class="ulink" href="http://archive.ics.uci.edu">http://archive.ics.uci.edu</a>&#13;
 website (at <a class="ulink" href="http://archive.ics.uci.edu/ml/datasets/Internet+Advertisements">http://archive.ics.uci.edu/ml/datasets/Internet+Advertisements</a>&#13;
 ) as already explained in the preceding machine-learning example.</p>&#13;
<p>The data is loaded in the following way using the terminal (in this case the path is <code class="literal">data_example/ad-dataset/ad-data</code>&#13;
 ):</p>&#13;
<div class="mediaobject"><img src="Image00007.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>This file does <a id="id94" class="indexterm"/>&#13;
 not have a header (set to <code class="literal">none</code>&#13;
 ) so the column's names are numbers and we can get a summary of the DataFrame by using the <code class="literal">describe</code>&#13;
 function on the object data:</p>&#13;
<div class="mediaobject"><img src="Image00008.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>This summarizes quantitative information. We can see that there are <code class="literal">1554</code>&#13;
 numeric columns (indicated by numbers since there is no header) and <code class="literal">3279</code>&#13;
 rows (called <code class="literal">count</code>&#13;
 for each column). Each of the columns has a list of statistical parameters (mean, standard deviation, min, max, and percentiles) that helps to obtain an initial estimate of the quantitative information contained in the data.</p>&#13;
<p>It is possible to obtain the column names using the <code class="literal">columns</code>&#13;
 property:</p>&#13;
<div class="mediaobject"><img src="Image00009.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>So all the columns names are of type <code class="literal">int64</code>&#13;
 and the following command returns the actual types of all the columns:</p>&#13;
<div class="mediaobject"><img src="Image00010.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The first four <a id="id95" class="indexterm"/>&#13;
 columns and the label (last column) are of the type <code class="literal">object,</code>&#13;
 while the others are of the type <code class="literal">int64</code>&#13;
 . Columns can be accessed in two ways. The first method is by specifying the column name like the key in a dictionary:</p>&#13;
<div class="mediaobject"><img src="Image00011.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Multiple columns can be obtained by specifying a list of them with the column names:</p>&#13;
<div class="mediaobject"><img src="Image00012.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The other way <a id="id96" class="indexterm"/>&#13;
 to access columns is by using the <span class="emphasis">&#13;
<em>dot</em>&#13;
</span>&#13;
 syntax, but it will only work if the column name could also be a Python variable name (that is no spaces), if it is not the same as the DataFrame property or function name (such as count or sum), and the name is of the string type (not <code class="literal">int64</code>&#13;
 like in this example).</p>&#13;
<p>To briefly gain an insight into the content of a DataFrame, the function <code class="literal">head()</code>&#13;
 can be used. The first five items in a column (or the first five rows in the DataFrame) are returned by default:</p>&#13;
<div class="mediaobject"><img src="Image00013.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The opposite method is <code class="literal">tail()</code>&#13;
 , which returns the last five items or rows by default. Specifying a number on the <code class="literal">tail()</code>&#13;
 or <code class="literal">head()</code>&#13;
 function, will return the first <span class="emphasis">&#13;
<em>n</em>&#13;
</span>&#13;
 items in the chosen column:</p>&#13;
<div class="mediaobject"><img src="Image00014.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>It is also<a id="id97" class="indexterm"/>&#13;
 possible to use the Python's regular slicing syntax to obtain a certain number of rows of the DataFrame:</p>&#13;
<div class="mediaobject"><img src="Image00015.jpg" alt="Exploring data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>This example shows only rows from <code class="literal">1</code>&#13;
 to <code class="literal">3</code>&#13;
 .</p>&#13;
</div>&#13;
<div class="section" title="Manipulate data">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h3 class="title"><a id="ch01lvl3sec08"/>&#13;
 Manipulate data</h3>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>It is <a id="id98" class="indexterm"/>&#13;
 possible to select row(s) in different ways, such as specifying the index or the condition as follows:</p>&#13;
<div class="mediaobject"><img src="Image00016.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Or specifying multiple conditions:</p>&#13;
<div class="mediaobject"><img src="Image00017.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The data <a id="id99" class="indexterm"/>&#13;
 returned are web pages with feature <code class="literal">1</code>&#13;
 greater than <code class="literal">0</code>&#13;
 and containing an advert.</p>&#13;
<p>The <code class="literal">ix</code>&#13;
 method allows us to select rows specifying the desired index:</p>&#13;
<div class="mediaobject"><img src="Image00018.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Alternatively the function <code class="literal">iloc</code>&#13;
 can be used:</p>&#13;
<div class="mediaobject"><img src="Image00019.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The difference is that <code class="literal">ix</code>&#13;
 works on labels in the index column and <code class="literal">iloc</code>&#13;
 works on the positions in the index (so it only takes integers). Therefore, in this example, <code class="literal">ix</code>&#13;
 finds all the rows from <code class="literal">0</code>&#13;
 until the label <code class="literal">3</code>&#13;
 appears, while the <code class="literal">iloc</code>&#13;
 function returns the rows in the first <code class="literal">3</code>&#13;
 positions <a id="id100" class="indexterm"/>&#13;
 in the data frame. There is a third function to access data in a DataFrame, <code class="literal">loc</code>&#13;
 . This function looks at the index names associated with the rows and it returns their values. For example:</p>&#13;
<div class="mediaobject"><img src="Image00020.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Note that this function behaves differently with respect to the normal slicing in Python because both starting and ending rows are included in the result (the row with index <code class="literal">3</code>&#13;
 is included in the output).</p>&#13;
<p>It is possible to set an entire column to a value:</p>&#13;
<div class="mediaobject"><img src="Image00021.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>To also set a specific cell value to the desired values:</p>&#13;
<div class="mediaobject"><img src="Image00022.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Or the entire row to a set of values (random values between <code class="literal">0</code>&#13;
 and <code class="literal">1</code>&#13;
 and <code class="literal">ad.</code>&#13;
 label in this example):</p>&#13;
<div class="mediaobject"><img src="Image00023.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>After transforming an array of values in a <code class="literal">Series</code>&#13;
 object, it is possible to append a row at the end <a id="id101" class="indexterm"/>&#13;
 of the DataFrame:</p>&#13;
<div class="mediaobject"><img src="Image00024.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Alternatively, the <code class="literal">loc</code>&#13;
 function (as in NumPy) can be used to add a row at the last line:</p>&#13;
<div class="mediaobject"><img src="Image00025.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>It is easy to add a column in the DataFrame by simply assigning the new column name to a value:</p>&#13;
<div class="mediaobject"><img src="Image00026.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>In this case, the new column has all the entries assigned to <span class="emphasis">&#13;
<em>test value</em>&#13;
</span>&#13;
 . Similarly, the column can be deleted using the <code class="literal">drop</code>&#13;
 function:</p>&#13;
<div class="mediaobject"><img src="Image00027.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>A dataset may contain duplicates for various reasons, so pandas provides the method <code class="literal">duplicated</code>&#13;
 to indicate whether each row is a repetition or not:</p>&#13;
<div class="mediaobject"><img src="Image00028.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>More usefully, though, the <code class="literal">drop_duplicates</code>&#13;
 function returns a DataFrame with only the unique <a id="id102" class="indexterm"/>&#13;
 values. For example, for the label the unique values are:</p>&#13;
<div class="mediaobject"><img src="Image00029.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>It is possible to transform the result into a list:</p>&#13;
<div class="mediaobject"><img src="Image00030.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>As we did in the machine-learning example, these labels can be transformed into numeric values using the methods explained in the preceding example:</p>&#13;
<div class="mediaobject"><img src="Image00031.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The label column is still the <code class="literal">object</code>&#13;
 type:</p>&#13;
<div class="mediaobject"><img src="Image00032.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>So the<a id="id103" class="indexterm"/>&#13;
 column now can be converted into the float type:</p>&#13;
<div class="mediaobject"><img src="Image00033.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The first four columns contain mixed values (strings, <code class="literal">?</code>&#13;
 , and float numbers), so we need to remove the string values to convert the columns into a numeric type. We can use the function <code class="literal">replace</code>&#13;
 to substitute all the instances of <code class="literal">?</code>&#13;
 (missing values) with <code class="literal">NaN</code>&#13;
 :</p>&#13;
<div class="mediaobject"><img src="Image00034.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Now we can handle these rows with missing data in two ways. The first method is just to remove the lines with missing values using <code class="literal">dropna</code>&#13;
 :</p>&#13;
<div class="mediaobject"><img src="Image00035.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Instead of removing the rows with missing data (which may lead to deleting important information), the empty entries can be filled. For most purposes, a constant value can be inserted in the empty cells with the <code class="literal">fillna</code>&#13;
 method:</p>&#13;
<div class="mediaobject"><img src="Image00036.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Now that all the values are numeric the columns can be set to type <code class="literal">float,</code>&#13;
 applying the <code class="literal">astype</code>&#13;
 function. Alternatively, we can apply a <code class="literal">lambda</code>&#13;
 function to convert each column in the DataFrame to a numeric type:</p>&#13;
<div class="mediaobject"><img src="Image00037.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Each <span class="emphasis">&#13;
<em>x</em>&#13;
</span>&#13;
 instance<a id="id104" class="indexterm"/>&#13;
 is a column and the <code class="literal">to_numeric</code>&#13;
 function converts it to the closest numeric type (<code class="literal">float</code>&#13;
 in this case).</p>&#13;
<p>For the sake of completeness of this tutorial, we want to show how two DataFrames can be concatenated since this operation can be useful in real applications. Let's create another small DataFrame with random values:</p>&#13;
<div class="mediaobject"><img src="Image00038.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>This new table with two rows can be merged with the original DataFrame using the <code class="literal">concat</code>&#13;
 function placing the rows of <code class="literal">data1</code>&#13;
 at the bottom of the <code class="literal">data</code>&#13;
 :</p>&#13;
<div class="mediaobject"><img src="Image00039.jpg" alt="Manipulate data"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The number of rows of <code class="literal">datatot</code>&#13;
 is now increased by two rows with respect to <code class="literal">data</code>&#13;
 (note that the number of rows is different from the beginning because we dropped the rows with <code class="literal">NaN</code>&#13;
 ).</p>&#13;
</div>&#13;
</div>&#13;
<div class="section" title="Matplotlib tutorial">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h2 class="title"><a id="ch01lvl2sec10"/>&#13;
 Matplotlib tutorial</h2>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>&#13;
<code class="literal">matplotlib.pyplot</code>&#13;
 is a<a id="id105" class="indexterm"/>&#13;
 library that collects a series of methods to plot<a id="id106" class="indexterm"/>&#13;
 data similar to <span class="strong">&#13;
<strong>MATLAB</strong>&#13;
</span>&#13;
 . Since the following chapters will employ this library to visualize some results, a simple example here will explain all the <code class="literal">matplotlib</code>&#13;
 code you will see as you continue in this book:</p>&#13;
<div class="mediaobject"><img src="Image00040.jpg" alt="Matplotlib tutorial"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>After importing<a id="id107" class="indexterm"/>&#13;
 the library (as <code class="literal">plt</code>&#13;
 ), the <code class="literal">figure</code>&#13;
 object is initialized (<code class="literal">fig</code>&#13;
 ) and an <code class="literal">axis</code>&#13;
 object is added (<code class="literal">ax</code>&#13;
 ). Each line plotted into the <code class="literal">ax</code>&#13;
 object through the command <code class="literal">ax.plot()</code>&#13;
 is called a handle. All the following instructions are then recorded by <code class="literal">matplotlib.pyplot</code>&#13;
 and plotted in the <code class="literal">figure</code>&#13;
 object. In this case, the line in green has been shown from the terminal and saved as a <code class="literal">figure.png</code>&#13;
 file, using the commands <code class="literal">plt.show()</code>&#13;
 and <code class="literal">fig.savefig()</code>&#13;
 respectively. The result is equal to:</p>&#13;
<div class="mediaobject"><img src="Image00041.jpg" alt="Matplotlib tutorial"/>&#13;
<div class="caption">&#13;
<p>Example of simple plot</p>&#13;
</div>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The next example illustrates a plot of several lines with different format styles in one command <a id="id108" class="indexterm"/>&#13;
 using Numpy arrays:</p>&#13;
<div class="mediaobject"><img src="Image00042.jpg" alt="Matplotlib tutorial"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<div class="mediaobject"><img src="Image00043.jpg" alt="Matplotlib tutorial"/>&#13;
<div class="caption">&#13;
<p>Example of plot with multiple lines</p>&#13;
</div>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>Note that the function <code class="literal">get_legend_handles_labels()</code>&#13;
 returns the list of handles and labels stored in the object <code class="literal">ax</code>&#13;
 and they are passed to the function legend to be plotted. The symbols <code class="literal">'r--'</code>&#13;
 , <code class="literal">'bs'</code>&#13;
 , and <code class="literal">'g^'</code>&#13;
 refer to the shape of the points and their color (red rectangles, blue squares, and green triangles respectively). The <code class="literal">linewidth</code>&#13;
 parameter sets the thickness of the line while <code class="literal">markersize</code>&#13;
 sets the size of the dots.</p>&#13;
<p>Another <a id="id109" class="indexterm"/>&#13;
 useful plot to visualize the results is the scatter plot in which values for typically two variables of a set of data (data generated using NumPy <code class="literal">random</code>&#13;
 submodule) are displayed:</p>&#13;
<div class="mediaobject"><img src="Image00044.jpg" alt="Matplotlib tutorial"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>The <code class="literal">s</code>&#13;
 option represents the size of the points and <code class="literal">colors</code>&#13;
 are the colors that correspond to each set of points and the handles are passed directly into the legend function (<code class="literal">p1</code>&#13;
 , <code class="literal">p2</code>&#13;
 , <code class="literal">p3</code>&#13;
 ):</p>&#13;
<div class="mediaobject"><img src="Image00045.jpg" alt="Matplotlib tutorial"/>&#13;
<div class="caption">&#13;
<p>Scatter plot of randomly distributed points</p>&#13;
</div>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>For further <a id="id110" class="indexterm"/>&#13;
 details on how to use <code class="literal">matplotlib</code>&#13;
 we advise the reader to read<a id="id111" class="indexterm"/>&#13;
 online material and tutorials such as <a class="ulink" href="http://matplotlib.org/users/pyplot_tutorial.html">http://matplotlib.org/users/pyplot_tutorial.html</a>&#13;
 .</p>&#13;
</div>&#13;
</div>&#13;

<div class="section" title="Scientific libraries used in the book">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch01lvl1sec10"/>&#13;
 Scientific libraries used in the book</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Throughout this book, certain libraries are necessary to implement the machine-learning techniques discussed in each chapter. We are going to briefly describe the most relevant libraries employed hereafter:</p>&#13;
<div class="itemizedlist">&#13;
<ul class="itemizedlist">&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>SciPy</strong>&#13;
</span>&#13;
 is a<a id="id112" class="indexterm"/>&#13;
 collection of mathematical methods based on the NumPy<a id="id113" class="indexterm"/>&#13;
 array objects. It is an open source project so it takes advantage of additional methods continuously written from developers around the world. Python software that employs a SciPy routine is part of advanced projects or applications comparable to similar frameworks such as<a id="id114" class="indexterm"/>&#13;
 MATLAB, <span class="strong">&#13;
<strong>Octave</strong>&#13;
</span>&#13;
 or <span class="strong">&#13;
<strong>RLab</strong>&#13;
</span>&#13;
 . There are a wide range<a id="id115" class="indexterm"/>&#13;
 of methods available from manipulating and visualizing data functions to parallel computing routines that enhance the versatility and potentiality of the Python language.</li>&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>scikit-learn</strong>&#13;
</span>&#13;
 (<span class="strong">&#13;
<strong>sklearn</strong>&#13;
</span>&#13;
 ) is an open source machine learning module for Python programming<a id="id116" class="indexterm"/>&#13;
 language. It implements various algorithms<a id="id117" class="indexterm"/>&#13;
 such as clustering, classification, and <a id="id118" class="indexterm"/>&#13;
 regression<a id="id119" class="indexterm"/>&#13;
 including <a id="id120" class="indexterm"/>&#13;
 support<a id="id121" class="indexterm"/>&#13;
 vector machines, <span class="strong">&#13;
<strong>Naive Bayes</strong>&#13;
</span>&#13;
 , <span class="strong">&#13;
<strong>Decision Trees</strong>&#13;
</span>&#13;
 , <span class="strong">&#13;
<strong>Random Forests</strong>&#13;
</span>&#13;
 , <span class="strong">&#13;
<strong>k-means</strong>&#13;
</span>&#13;
 , and <span class="strong">&#13;
<strong>Density Based Spatial Clustering of Applications with Noise</strong>&#13;
</span>&#13;
 (<span class="strong">&#13;
<strong>DBSCAN</strong>&#13;
</span>&#13;
 ) and it interacts <a id="id122" class="indexterm"/>&#13;
 natively with numerical Python libraries such as NumPy and SciPy. Although most of the routines are written in Python, some functions are <a id="id123" class="indexterm"/>&#13;
 implemented in <span class="strong">&#13;
<strong>Cython</strong>&#13;
</span>&#13;
 to achieve better performance. For instance, support vector machines and logistic<a id="id124" class="indexterm"/>&#13;
 regression <a id="id125" class="indexterm"/>&#13;
 are written in Cython wrapping other external libraries (<span class="strong">&#13;
<strong>LIBSVM</strong>&#13;
</span>&#13;
 , <span class="strong">&#13;
<strong>LIBLINEAR</strong>&#13;
</span>&#13;
 ).</li>&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>The Natural Language Toolkit</strong>&#13;
</span>&#13;
 (<span class="strong">&#13;
<strong>NLTK</strong>&#13;
</span>&#13;
 ), is a collection of libraries and functions for <span class="strong">&#13;
<strong>Natural Language Processing</strong>&#13;
</span>&#13;
 (<span class="strong">&#13;
<strong>NLP</strong>&#13;
</span>&#13;
 ) for Python language processing. NLTK is designed to support research and teaching on NLP and related topics <a id="id126" class="indexterm"/>&#13;
 including artificial <a id="id127" class="indexterm"/>&#13;
 intelligence, cognitive <a id="id128" class="indexterm"/>&#13;
 science, information retrieval, linguistics, and machine learning. It also features a series of text processing routines for tokenization, stemming, tagging, parsing, semantic reasoning, and classification. NLTK includes sample codes and sample data and interfaces to more than 50 corpora and lexical databases.</li>&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>Scrapy</strong>&#13;
</span>&#13;
 is an<a id="id129" class="indexterm"/>&#13;
 open source web crawling framework for the Python<a id="id130" class="indexterm"/>&#13;
 programming language. Originally designed for scraping websites, and as a general purpose crawler, it is also suitable for extracting data through APIs. The Scrapy project is written around <span class="emphasis">&#13;
<em>spiders</em>&#13;
</span>&#13;
 that act by providing a set of instructions. It also features a web crawling shell that allows the developers to test their concepts before actually implementing them. Scrapy is currently maintained by Scrapinghub Ltd., a web scraping development and services Company.</li>&#13;
<li class="listitem">&#13;
<span class="strong">&#13;
<strong>Django</strong>&#13;
</span>&#13;
 is a <a id="id131" class="indexterm"/>&#13;
 free and open source web application framework<a id="id132" class="indexterm"/>&#13;
 implemented in Python following the <span class="emphasis">&#13;
<em>model view controller</em>&#13;
</span>&#13;
 architectural pattern. Django is designed for creation of complex, database-oriented websites. It also allows us to manage the application through an administrative interface, which can create, read, delete, or update data used in the application. There are a series of established websites that currently use Django, such as Pinterest, Instagram, Mozilla, The Washington Times, and Bitbucket.</li>&#13;
</ul>&#13;
</div>&#13;
</div>&#13;

<div class="section" title="When to use machine learning">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch01lvl1sec11"/>&#13;
 When to use machine learning</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Machine learning<a id="id133" class="indexterm"/>&#13;
 is not magic and it may be not be beneficial to all data-related problems. It is important at the end of this introduction to clarify when machine-learning techniques are extremely useful:</p>&#13;
<div class="itemizedlist">&#13;
<ul class="itemizedlist">&#13;
<li class="listitem">It is not possible to code the rules: a series of human tasks (to determine if an e-mail is spam or not, for example) cannot be solved effectively using simple rules methods. In fact, multiple factors can affect the solution and if rules depend on a large number of factors it becomes hard for humans to manually implement these rules.</li>&#13;
<li class="listitem">A solution is not scalable: whenever it is time consuming to manually take decisions on certain data, the machine-learning techniques can scale adequately. For example, a machine-learning algorithm can efficiently go through millions of e-mails and determine if they are spam or not.</li>&#13;
</ul>&#13;
</div>&#13;
<p>However, if it is possible to find a good target prediction, by simply using mathematical rules, computations, or predetermined schemas that can be implemented without needing any data-driven learning, these advanced machine-learning techniques are not necessary (and you should not use them).</p>&#13;
</div>&#13;

<h1>读累了记得休息一会哦~</h1>
<p> </p>
<p><strong>公众号：古德猫宁李</strong></p>
<ul>
<li>电子书搜索下载</li>
<li>书单分享</li>
<li>书友学习交流</li>

<p> </p>
</ul>
<p><strong>网站：</strong><a href="https://www.chenjin5.com">沉金书屋 https://www.chenjin5.com</a></p>
<ul>
<li>电子书搜索下载</li>
<li>电子书打包资源分享</li>
<li>学习资源分享</li>

</ul>

<div class="section" title="Summary">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch01lvl1sec12"/>&#13;
 Summary</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>In this chapter we introduced the basic machine-learning concepts and terminology that will be used in the rest of the book. Tutorials of the most relevant libraries (NumPy, pandas, and matplotlib) used by machine-learning professionals to prepare, t manipulate, and visualize data have been also presented. A general introduction of all the other Python libraries that will be used in the following chapters has been also provided.</p>&#13;
<p>You should have a general knowledge of what the machine-learning field can practically do, and you should now be familiar with the methods employed to transform the data into a usable format, so that a machine-learning algorithm can be applied. In the next chapter we will explain the main unsupervised learning algorithms and how to implement them using the <code class="literal">sklearn</code>&#13;
 library.</p>&#13;
</div>&#13;
</body></html>