["```py\nseq family of functions to initialize vectors in different ways.\n```", "```py\n> c(2.5:4.5, 6, 7, c(8, 9, 10), c(12:15))\n [1]  2.5  3.5  4.5  6.0  7.0  8.0  9.0 10.0 12.0 13.0 14.0 15.0\n> vector(\"numeric\", 5)\n[1] 0 0 0 0 0\n> vector(\"logical\", 5)\n[1] FALSE FALSE FALSE FALSE FALSE\n> logical(5)\n[1] FALSE FALSE FALSE FALSE FALSE\n> # seq is a function which creates sequences\n> seq.int(1,10)\n [1]  1  2  3  4  5  6  7  8  9 10\n> seq.int(1,10,2)\n[1] 1 3 5 7 9\n> seq_len(10)\n [1]  1  2  3  4  5  6  7  8  9 10\n\n```", "```py\n> vec <- c(\"R\", \"Python\", \"Julia\", \"Haskell\", \"Java\", \"Scala\")\n> vec[1]\n[1] \"R\"\n> vec[2:4]\n[1] \"Python\"  \"Julia\"   \"Haskell\"\n> vec[c(1, 3, 5)]\n[1] \"R\"     \"Julia\" \"Java\" \n> nums <- c(5, 8, 10, NA, 3, 11)\n> nums\n[1]  5  8 10 NA  3 11\n> which.min(nums)   # index of the minimum element\n[1] 5\n> which.max(nums)   # index of the maximum element\n[1] 6\n> nums[which.min(nums)]  # the actual minimum element\n[1] 3\n> nums[which.max(nums)]  # the actual maximum element\n[1] 11\n\n```", "```py\n> c(first=1, second=2, third=3, fourth=4, fifth=5)\n\n```", "```py\n> positions <- c(1, 2, 3, 4, 5)\n> names(positions) \nNULL\n> names(positions) <- c(\"first\", \"second\", \"third\", \"fourth\", \"fifth\")\n> positions\n\n```", "```py\n> names(positions)\n[1] \"first\"  \"second\" \"third\"  \"fourth\" \"fifth\"\n> positions[c(\"second\", \"fourth\")]\n\n```", "```py\n> three.dim.array <- array(\n+     1:32,    # input data\n+     dim = c(4, 3, 3),   # dimensions\n+     dimnames = list(    # names of dimensions\n+         c(\"row1\", \"row2\", \"row3\", \"row4\"),\n+         c(\"col1\", \"col2\", \"col3\"),\n+         c(\"first.set\", \"second.set\", \"third.set\")\n+     )\n+ )\n> three.dim.array\n\n```", "```py\n> mat <- matrix(\n+     1:24,   # data\n+     nrow = 6,  # num of rows\n+     ncol = 4,  # num of columns\n+     byrow = TRUE,  # fill the elements row-wise\n+ )\n> mat\n\n```", "```py\n> dimnames(three.dim.array)\n\n```", "```py\n> rownames(three.dim.array)\n[1] \"row1\" \"row2\" \"row3\" \"row4\"\n> colnames(three.dim.array)\n[1] \"col1\" \"col2\" \"col3\"\n> dimnames(mat)\nNULL\n> rownames(mat)\nNULL\n> rownames(mat) <- c(\"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\")\n> colnames(mat) <- c(\"c1\", \"c2\", \"c3\", \"c4\")\n> dimnames(mat)\n\n```", "```py\n> mat\n\n```", "```py\n> dim(three.dim.array)\n[1] 4 3 3\n> nrow(three.dim.array)\n[1] 4\n> ncol(three.dim.array)\n[1] 3\n> length(three.dim.array)  # product of dimensions\n[1] 36\n> dim(mat)\n[1] 6 4\n> nrow(mat)\n[1] 6\n> ncol(mat)\n[1] 4\n> length(mat)\n[1] 24\n\n```", "```py\n> mat1 <- matrix(\n+     1:15,\n+     nrow = 5,\n+     ncol = 3,\n+     byrow = TRUE,\n+     dimnames = list(\n+         c(\"M1.r1\", \"M1.r2\", \"M1.r3\", \"M1.r4\", \"M1.r5\")\n+         ,c(\"M1.c1\", \"M1.c2\", \"M1.c3\")\n+     )\n+ )\n> mat1\n\n```", "```py\n> mat2 <- matrix(\n+     16:30,\n+     nrow = 5,\n+     ncol = 3,\n+     byrow = TRUE,\n+     dimnames = list(\n+         c(\"M2.r1\", \"M2.r2\", \"M2.r3\", \"M2.r4\", \"M2.r5\"),\n+         c(\"M2.c1\", \"M2.c2\", \"M2.c3\")\n+     )\n+ )\n> mat2\n\n```", "```py\n> rbind(mat1, mat2)\n\n```", "```py\n> cbind(mat1, mat2)\n\n```", "```py\n> c(mat1, mat2)\n\n```", "```py\n> mat1 + mat2   # matrix addition\n\n```", "```py\n> mat1 * mat2  # element-wise multiplication\n\n```", "```py\n> tmat2 <- t(mat2)  # transpose\n> tmat2\n\n```", "```py\n> mat1 %*% tmat2   # matrix inner product\n\n```", "```py\n> m <- matrix(c(5, -3, 2, 4, 12, -1, 9, 14, 7), nrow = 3, ncol = 3)\n> m\n\n```", "```py\n> inv.m <- solve(m)  # matrix inverse\n> inv.m\n\n```", "```py\n> round(m %*% inv.m) # matrix * matrix_inverse = identity matrix\n\n```", "```py\n> list.sample <- list(\n+     1:5,\nâ€©+     c(\"first\", \"second\", \"third\"),\n+     c(TRUE, FALSE, TRUE, TRUE),\n+     cos,\n+     matrix(1:9, nrow = 3, ncol = 3)\n+ )\n> list.sample\n\n```", "```py\n> list.with.names <- list(\n+     even.nums = seq.int(2,10,2),\n+     odd.nums  = seq.int(1,10,2),\n+     languages = c(\"R\", \"Python\", \"Julia\", \"Java\"),\n+     cosine.func = cos\n+ )\n> list.with.names\n\n```", "```py\n> list.with.names$cosine.func\nfunction (x)  .Primitive(\"cos\")\n> list.with.names$cosine.func(pi)\n[1] -1\n>\n> list.sample[[4]]\nfunction (x)  .Primitive(\"cos\")\n> list.sample[[4]](pi)\n[1] -1\n>\n> list.with.names$odd.nums\n[1] 1 3 5 7 9\n> list.sample[[1]]\n[1] 1 2 3 4 5\n> list.sample[[3]]\n[1]  TRUE FALSE  TRUE  TRUE\n\n```", "```py\n> l1 <- list(\n+     nums = 1:5,\n+     chars = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n+     cosine = cos\n+ )\n> l2 <- list(\n+     languages = c(\"R\", \"Python\", \"Java\"),\n+     months = c(\"Jan\", \"Feb\", \"Mar\", \"Apr\"),\n+     sine = sin\n+ )\n> # combining the lists now\n> l3 <- c(l1, l2)\n> l3\n\n```", "```py\n> l1 <- 1:5\n> class(l1)\n[1] \"integer\"\n> list.l1 <- as.list(l1)\n> class(list.l1)\n[1] \"list\"\n> list.l1\n\n```", "```py\n> unlist(list.l1)\n[1] 1 2 3 4 5\n\n```", "```py\n> df <- data.frame(\n+     real.name = c(\"Bruce Wayne\", \"Clark Kent\", \"Slade Wilson\", \"Tony Stark\", \"Steve Rogers\"),\n+     superhero.name = c(\"Batman\", \"Superman\", \"Deathstroke\", \"Iron Man\", \"Capt. America\"),\n+     franchise = c(\"DC\", \"DC\", \"DC\", \"Marvel\", \"Marvel\"),\n+     team = c(\"JLA\", \"JLA\", \"Suicide Squad\", \"Avengers\", \"Avengers\"),\n+     origin.year = c(1939, 1938, 1980, 1963, 1941)\n+ )\n> df\n\n```", "```py\n> class(df)\n[1] \"data.frame\"\n> str(df)\n\n```", "```py\n> rownames(df)\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n> colnames(df)\n\n```", "```py\n> dim(df)\n[1] 5 5\n\n```", "```py\n> head(mtcars)   # one of the datasets readily available in R\n\n```", "```py\n> df[2:4,]\n\n```", "```py\n> df[2:4, 1:2]\n\n```", "```py\n> subset(df, team==\"JLA\", c(real.name, superhero.name, franchise))\n\n```", "```py\n> subset(df, team %in% c(\"Avengers\",\"Suicide Squad\"), c(real.name, superhero.name, franchise))\n\n```", "```py\n> df1 <- data.frame(\n+     id = c('emp001', 'emp003', 'emp007'),\n+     name = c('Harvey Dent', 'Dick Grayson', 'James Bond'),\n+     alias = c('TwoFace', 'Nightwing', 'Agent 007')\n+ )\n> \n> df2 <- data.frame(\n+     id = c('emp001', 'emp003', 'emp007'),\n+     location = c('Gotham City', 'Gotham City', 'London'),\n+     speciality = c('Split Persona', 'Expert Acrobat', 'Gadget Master')\n+ )\n> df1\n\n```", "```py\n> df2\n\n```", "```py\n> rbind(df1, df2)   # not possible since column names don't match\nError in match.names(clabs, names(xi)) : \n names do not match previous names\n> cbind(df1, df2)\n\n```", "```py\n> merge(df1, df2, by=\"id\")\n\n```", "```py\n> sqrt(5)\n[1] 2.236068\n> sqrt(c(1,2,3,4,5,6,7,8,9,10))\n[1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751     [8] 2.828427 3.000000 3.162278\n> # aggregating functions\n> mean(c(1,2,3,4,5,6,7,8,9,10))\n[1] 5.5\n> median(c(1,2,3,4,5,6,7,8,9,10))\n[1] 5.5\n\n```", "```py\nsquare <- function(data){\n return (data^2)\n}\n> square(5)\n[1] 25\n> square(c(1,2,3,4,5))\n[1]  1  4  9 16 25\npoint <- function(xval, yval){\n return (c(x=xval,y=yval))\n}\n> p1 <- point(5,6)\n> p2 <- point(2,3)\n> \n> p1\nx y \n5 6 \n> p2\nx y \n2 3\n\n```", "```py\nsquare which computes the square of a single number or even a vector of numbers using the same code. Functions such as point are useful to represent specific entities which represent points in the two-dimensional co-ordinate space. Now we will be looking at how to use the preceding functions together.\n```", "```py\n> # defining the function\neuclidean.distance <- function(point1, point2, square.func){\n distance <- sqrt(\n as.integer(\n square.func(point1['x'] - point2['x'])\n ) +\n as.integer(\n square.func(point1['y'] - point2['y'])\n )\n )\n return (c(distance=distance))\n}\n> # executing the function, passing square as argument\n> euclidean.distance(point1 = p1, point2 = p2, square.func = square)\ndistance \n4.242641 \n> euclidean.distance(point1 = p2, point2 = p1, square.func = square)\ndistance \n4.242641 \n> euclidean.distance(point1 = point(10, 3), point2 = point(-4, 8), square.func = square)\ndistance\n14.86607\n\n```", "```py\n> num = 5\n> if (num == 5){\n+     cat('The number was 5')\n+ }\nThe number was 5\n> \n> num = 7\n> \n> if (num == 5){\n+     cat('The number was 5')\n+ } else{\n+     cat('The number was not 5')\n+ }\nThe number was not 5\n>\n> if (num == 5){\n+     cat('The number was 5')\n+ } else if (num == 7){\n+     cat('The number was 7')\n+ } else{\n+     cat('No match found')\n+ }\nThe number was 7\n> ifelse(num == 5, \"Number was 5\", \"Number was not 5\")\n[1] \"Number was not 5\"\n\n```", "```py\n> switch(\n+ \"first\",\n+ first = \"1st\",\n+ second = \"2nd\",\n+ third = \"3rd\",\n+ \"No position\"\n+ )\n[1] \"1st\"\n> \n> switch(\n+ \"third\",\n+ first = \"1st\",\n+ second = \"2nd\",\n+ third = \"3rd\",\n+ \"No position\"\n+ )\n[1] \"3rd\"\n> # when no match, default statement executes\n> switch(\n+ \"fifth\",\n+ first = \"1st\",\n+ second = \"2nd\",\n+ third = \"3rd\",\n+ \"No position\"\n+ )\n[1] \"No position\"\n\n```", "```py\n> # for loop\n> for (i in 1:10){\n+     cat(paste(i,\" \"))\n+ }\n1  2  3  4  5  6  7  8  9  10 \n> \n> sum = 0\n> for (i in 1:10){\n+     sum <- sum + i\n+ }\n> sum\n[1] 55\n> \n> # while loop\n> count <- 1\n> while (count <= 10){\n+     cat(paste(count, \" \"))\n+     count <- count + 1\n+ }\n1  2  3  4  5  6  7  8  9  10 \n> \n> # repeat infinite loop \n> count = 1\n> repeat{\n+     cat(paste(count, \" \"))\n+     if (count >= 10){\n+         break  # break off from the infinite loop\n+     }\n+     count <- count + 1\n+ }\n1  2  3  4  5  6  7  8  9  10 \n\n```", "```py\n> # lapply function definition\n> lapply\nfunction (X, FUN, ...) \n{\n FUN <- match.fun(FUN)\n if (!is.vector(X) || is.object(X)) \n X <- as.list(X)\n .Internal(lapply(X, FUN))\n}\n<bytecode: 0x00000000003e4f68>\n<environment: namespace:base>\n> # example\n> nums <- list(l1=c(1,2,3,4,5,6,7,8,9,10), l2=1000:1020)\n> lapply(nums, mean)\n\n```", "```py\n> data <- list(l1=1:10, l2=runif(10), l3=rnorm(10,2))\n> data\n\n```", "```py\n> \n> lapply(data, mean)\n\n```", "```py\n> sapply(data, mean)\n\n```", "```py\n> mat <- matrix(rnorm(20), nrow=5, ncol=4)\n> mat\n\n```", "```py\n> # row sums\n> apply(mat, 1, sum)\n[1]  0.79786959  0.53900665 -2.36486927 -1.28221227  0.06701519\n> rowSums(mat)\n[1]  0.79786959  0.53900665 -2.36486927 -1.28221227  0.06701519\n> # row means\n> apply(mat, 1, mean)\n[1]  0.1994674  0.1347517 -0.5912173 -0.3205531  0.0167538\n> rowMeans(mat)\n[1]  0.1994674  0.1347517 -0.5912173 -0.3205531  0.0167538\n>\n> # col sums\n> apply(mat, 2, sum)\n[1] -0.6341087  0.3321890 -2.1345245  0.1932540\n> colSums(mat)\n[1] -0.6341087  0.3321890 -2.1345245  0.1932540\n> apply(mat, 2, mean)\n[1] -0.12682173  0.06643781 -0.42690489  0.03865079\n> colMeans(mat)\n[1] -0.12682173  0.06643781 -0.42690489  0.03865079\n>\n> # row quantiles\n> apply(mat, 1, quantile, probs=c(0.25, 0.5, 0.75))\n\n```", "```py\n> data <- c(1:10, rnorm(10,2), runif(10))\n> data\n\n```", "```py\n> groups <- gl(3,10)\n> groups\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3\nLevels: 1 2 3\n> tapply(data, groups, mean)\n\n```", "```py\n> tapply(data, groups, mean, simplify = FALSE)\n\n```", "```py\n> tapply(data, groups, range)\n\n```", "```py\n> list(rep(1,4), rep(2,3), rep(3,2), rep(4,1))\n\n```", "```py\n> mapply(rep, 1:4, 4:1)\n\n```", "```py\n> help.start()\n\n```"]