["```py\n# My own array-like type for tracking scores\nstruct Scores <: AbstractVector{Float64}\n    values::Vector{Float64}\nend\n\n# implement AbstractArray interface\nBase.size(s::Scores) = (length(s.values),)\nBase.getindex(s::Scores, i::Int) = s.values[i]\n```", "```py\nmodule MyModule\n    import Base.+\n    (+)(s::AbstractString, n::Number) = \"$s$n\"\nend\n```", "```py\nmodule AnotherModule\n    import Base: +, -, *, /\n    (+)(s::AbstractString, n::T) where T <: Number = parse(T, s) + n\n    (-)(s::AbstractString, n::T) where T <: Number = parse(T, s) - n\n    (*)(s::AbstractString, n::T) where T <: Number = parse(T, s) * n\n    (/)(s::AbstractString, n::T) where T <: Number = parse(T, s) / n\nend\n```", "```py\nmodule MyModule\n    import Base.+\n    (+)(s::AbstractString, n::Number) = \"$s$n\"\nend\n```", "```py\nmodule MyModule\n    export @str_str\n    import Base: +, show\n\n    struct MyString\n        value::AbstractString\n    end \n\n    macro str_str(s::AbstractString) \n        MyString(s)\n    end\n\n    show(io::IO, s::MyString) = print(io, s.value)\n    (+)(s::MyString, n::Number) = MyString(s.value * string(n))\n    (+)(n::Number, s::MyString) = MyString(string(n) * s.value)\n    (+)(s::MyString, t::MyString) = MyString(s.value * t.value)\nend\n```", "```py\n# A Party just contains a title and guest names\nstruct Party\n    title::String\n    guests::Vector{String}\nend\n\n# constructor\nParty(title) = Party(title, String[])\n```", "```py\nBase.join(name::String, party::Party) = push!(party.guests, name)\n```", "```py\nhelp?> join\n\n  join([io::IO,] strings, delim, [last])\n```", "```py\nfunction sumprod(A::Vector{Float64}, B::Vector{Float64})\n    return sum(A .* B)\nend\n```", "```py\nfunction test_harness(f, scenario, args...)\n    try \n        f(args...)\n        println(f, \" #$(scenario) success\")\n    catch ex\n        if ex isa MethodError\n            println(f, \" #$(scenario) failure (method not selected)\")\n        else\n            println(f, \" #$(scenario) failure (unknown error $ex)\")\n        end\n    end\nend\n```", "```py\nfunction test_sumprod(f)\n    test_harness(f, 1, [1.0,2.0], [3.0, 4.0]);\n    test_harness(f, 2, [1,2], [3,4]);\n    test_harness(f, 3, [1,2], [3.0,4.0]);\n    test_harness(f, 4, rand(2,2), rand(2,2));\n    test_harness(f, 5, Number[1,2.0], Number[3.0, 4]);\nend\n```", "```py\nsumprod_1(A::Vector{Float64}, B::Vector{Float64}) = sum(A .* B)\n```", "```py\nsumprod_2(A::Vector{Number}, B::Vector{Number}) = sum(A .* B)\n```", "```py\nsumprod_3(A::Vector{T}, B::Vector{T}) where T <: Number = sum(A .* B)\n```", "```py\nsumprod_4(A::Vector{S}, B::Vector{T}) where {S <: Number, T <: Number} = sum(A .* B)\n```", "```py\nsumprod_5(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number} = \n    sum(A .* B)\n```", "```py\nsumprod_6(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where \n    {N, S <: Number, T <: Number} = sum(A .* B)\n```", "```py\nsumprod_7(A, B) = sum(A .* B)\n```", "```py\nusing BenchmarkTools \n\nA = rand(10_000);\nB = rand(10_000);\n\n@btime sumprod_1($A, $B);\n@btime sumprod_5($A, $B);\n@btime sumprod_6($A, $B);\n@btime sumprod_7($A, $B);\n```", "```py\nstruct Point\n    x\n    y\nend\n```", "```py\nstruct Point2\n    x::Any\n    y::Any\nend\n```", "```py\nstruct Point3\n    x::UInt8\n    y::UInt8\nend\n```", "```py\nstruct Point\n    x::Real\n    y::Real\nend\n```", "```py\nstruct Point{T <: Real}\n    x::T\n    y::T\nend\n```", "```py\nusing Statistics: mean\n\nfunction center(points::AbstractVector{T}) where T\n    return T(\n        mean(p.x for p in points), \n        mean(p.y for p in points))\nend\n```", "```py\nmake_points(T::Type, n) = [T(rand(), rand()) for _ in 1:n]\n```"]