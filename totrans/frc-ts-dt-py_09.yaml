- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Including Additional Regressors
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含额外回归因子
- en: In your first model in [*Chapter 2*](B19630_02.xhtml#_idTextAnchor104), *Getting
    Started with Prophet*, you forecasted carbon dioxide levels at Mauna Loa using
    only the date (but no other information) to predict future values. Later, in [*Chapter
    6*](B19630_06.xhtml#_idTextAnchor375), *Forecasting Holiday Effects*, you learned
    how to add holidays as additional information to further refine your predictions
    of bicycle ridership in the Divvy bike share network in Chicago.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的第一个模型中，[*第2章*](B19630_02.xhtml#_idTextAnchor104)，*使用Prophet入门*，你仅使用日期（但没有其他信息）来预测未来的二氧化碳水平。后来，在[*第6章*](B19630_06.xhtml#_idTextAnchor375)，*预测节假日影响*中，你学习了如何将节假日作为附加信息添加，以进一步细化你在芝加哥Divvy自行车共享网络中对自行车骑行量的预测。
- en: The way holidays are implemented in Prophet is actually a special case of adding
    a binary regressor. In fact, Prophet includes a generalized method for adding
    any additional regressor, both binary and continuous.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Prophet中实现节假日的方式实际上是添加二元回归因子的一个特殊情况。实际上，Prophet包括了一种通用的方法来添加任何额外的回归因子，包括二元和连续的。
- en: 'In this chapter, you’ll enrich your Divvy dataset with weather information
    by including it as an additional regressor. First, you will add binary weather
    conditions to describe the presence or absence of sun, clouds, or rain, and then
    you will bring in continuous temperature measurements. Using additional regressors
    can allow you to include more information to inform your models, which leads to
    greater predictive power. In this chapter, you will learn about the following
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过将其作为额外回归因子包括进来，用天气信息丰富你的Divvy数据集。首先，你将添加二元天气条件来描述阳光、云或雨的存在或不存在，然后你将引入连续的温度测量。使用额外的回归因子可以使你包含更多信息来告知你的模型，这会导致更强的预测能力。在本章中，你将学习以下主题：
- en: Adding binary regressors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加二元回归因子
- en: Adding continuous regressors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加连续回归因子
- en: Interpreting the regressor coefficients
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释回归系数
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The data files and code for examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中示例的数据文件和代码可以在[https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition)找到。
- en: Adding binary regressors
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加二元回归因子
- en: 'The first thing to consider with **additional regressors**, whether binary
    or continuous, is that you must have known future values for your entire forecast
    period. This isn’t a problem with holidays because we know exactly when each future
    holiday will occur. All future values must either be known, as with holidays,
    or must have been forecast separately. You must be careful though when building
    a forecast using data that itself has been forecast: the error in the first forecast
    will compound the error in the second forecast, and the errors will continuously
    pile up.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑**额外回归因子**时，无论是二元还是连续的，首先需要考虑的是你必须知道整个预测期间的未来值。这并不是节假日的问题，因为我们确切地知道每个未来节假日的具体时间。所有未来值必须已知，就像节假日一样，或者必须单独进行预测。然而，当使用已经被预测的数据构建预测时，你必须小心：第一次预测的错误会累积到第二次预测中，错误会持续累积。
- en: 'If one variable is much easier to forecast than another, however, then this
    may be a case where these stacked forecasts do make sense. A **hierarchical time
    series** is an example case where this may be useful: you may find good results
    by forecasting the more reliable daily values of one time series, for instance,
    and using those values to forecast hourly values of another time series that is
    more difficult to predict.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个变量的预测比另一个变量容易得多，那么这可能是这些堆叠预测有意义的案例。**分层时间序列**是一个可能有用的情况的例子：你可能通过预测一个时间序列更可靠的日值，例如，并使用这些值来预测另一个更难预测的时间序列的小时值。
- en: In the examples in this chapter, we are going to use a weather forecast to enrich
    our Divvy forecast. This additional regressor is possible because we generally
    do have decent weather forecasts available looking ahead a week or so. In other
    examples in this book, in which we have used Divvy data, we often forecasted a
    full year. In this chapter though, we will only forecast 2 weeks. Let’s be generous
    to Chicago’s weather forecasters and assume that they’ll provide accurate forecasts
    in this time frame.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的例子中，我们将使用天气预报来丰富我们的Divvy预测。这种额外的回归器是可能的，因为我们通常确实有一周左右的相当可靠的天气预报可用。在这本书的其他例子中，当我们使用Divvy数据时，我们经常预测整整一年。然而，在本章中，我们只会预测两周。让我们对芝加哥的天气预报员慷慨一些，并假设他们将在这一时间段内提供准确的预报。
- en: 'To begin, let’s import our necessary packages and load the data:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入必要的包并加载数据：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Please refer to *Figure 5**.6* in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254),
    *Working with Seasonality*, for a plot of the rides per day in this data. *Figure
    5**.7* in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254) showed an excerpt of
    the data contained in this file. So far in this book, we always excluded the two
    columns for weather and temperature in this dataset, but we’ll use them this time
    around. For our first example, let’s consider the weather conditions. By counting
    the number of times each condition occurred in the dataset, we can see their frequencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[*第5章*](B19630_05.xhtml#_idTextAnchor254)中的*图5.6*，*处理季节性*，以查看此数据中每天骑行的图表。[*第5章*](B19630_05.xhtml#_idTextAnchor254)中的*图5.7*显示了此文件中包含的数据的摘录。到目前为止，在这本书中，我们总是排除了此数据集中关于天气和温度的两个列，但这次我们将使用它们。对于我们的第一个例子，让我们考虑天气条件。通过计算每个条件在数据集中出现的次数，我们可以看到它们的频率：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding `print` statement is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`print`语句的输出如下：
- en: '![Figure 9.1 – Count of weather conditions in the Divvy dataset](img/Fig_9.1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Divvy数据集中天气条件的计数](img/Fig_9.1.jpg)'
- en: Figure 9.1 – Count of weather conditions in the Divvy dataset
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Divvy数据集中天气条件的计数
- en: By grouping the data by weather and aggregating by count, we can see the number
    of days each condition was reported. Clear weather occurred on `41` days, and
    cloudy weather was by far the most common, with `1346` occurrences. `Not clear`
    was only reported twice, and `rain or snow` occurred `69` times.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按天气分组数据并按计数聚合，我们可以看到每种条件报告的天数。晴朗的天气出现了`41`天，而多云的天气远远是最常见的，有`1346`次出现。`Not
    clear`只报告了两次，而`rain or snow`出现了`69`次。
- en: Now that we understand what data we’re working with, let’s load it into our
    DataFrame. We’ll also load the `temperature` column, even though we won’t use
    it until the next example when we look at **continuous** columns, those in which
    the value may exist along a continuum.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了我们正在处理的数据，让我们将其加载到我们的DataFrame中。我们还将加载`temperature`列，尽管我们直到下一个例子查看**连续**列（其值可能存在于连续体上）时才会使用它。
- en: 'To load the `weather` column, we will use pandas’ `get_dummies` method to convert
    it into four `1` or `0` – essentially, a flag indicating whether the condition
    is present:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载`weather`列，我们将使用pandas的`get_dummies`方法将其转换为四个`1`或`0` – 实际上，这是一个标志，表示条件是否存在：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can display the first five rows of our DataFrame at this point to see what
    the preceding code has done:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以显示DataFrame的前五行，以查看前面的代码做了什么：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the `head` statement should appear as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`语句的输出应该如下所示：'
- en: '![Figure 9.2 – DataFrame with dummy weather columns](img/Fig_9.2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 带有虚拟天气列的DataFrame](img/Fig_9.2.jpg)'
- en: Figure 9.2 – DataFrame with dummy weather columns
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 带有虚拟天气列的DataFrame
- en: You can now see that each unique value in the `weather` column has been converted
    to a new column. Let’s instantiate our model now, setting the seasonality mode
    to multiplicative and the yearly seasonality to have a Fourier order of `4`, as
    we did in previous chapters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到`weather`列中的每个唯一值都已转换为一个新的列。现在让我们实例化我们的模型，将季节性模式设置为乘法，并将年季节性设置为具有`4`个傅里叶阶数，就像我们在前面的章节中所做的那样。
- en: We will also add our additional regressors using the `add_regressor` method.
    As arguments to this method, you must pass the name of the regressor, which is
    the name of the corresponding column in your DataFrame. You may also use the `prior_scale`
    argument to regularize the regressor, just as you did with holidays, seasonalities,
    and trend changepoints. If no prior scale is specified, then `holidays_prior_scale`
    will be used, which defaults to `10`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`add_regressor`方法添加额外的回归器。作为此方法的参数，您必须传递回归器的名称，这是DataFrame中相应列的名称。您还可以使用`prior_scale`参数来正则化回归器，就像您对假日、季节性和趋势变化点所做的那样。如果没有指定先验尺度，则将使用`holidays_prior_scale`，默认值为`10`。
- en: You may also specify whether the regressor should be additive or multiplicative.
    If nothing is specified, then the regressor adopts that stated in `seasonality_mode`.
    Lastly, the method has a `standardize` argument, which, by default, takes the
    `'auto'` string. This means that the column will be standardized if not binary.
    You can instead explicitly set standardization by setting it to either `True`
    or `False`. In this example, all defaults will work out great.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定回归器应该是加法还是乘法。如果没有指定，则回归器将采用`seasonality_mode`中声明的值。最后，该方法有一个`standardize`参数，默认情况下取`'auto'`字符串。这意味着如果列不是二元的，则将对列进行标准化。您可以通过将其设置为`True`或`False`来显式设置标准化。在这个例子中，所有默认值都将很好地工作。
- en: To make it clear, I’ll explicitly state all arguments in only the first `add_regressor`
    call and for the remaining, we will only state the name of the regressor and otherwise
    accept all default values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其清晰，我将在第一个`add_regressor`调用中明确声明所有参数，而对于其余的，我们只将声明回归器的名称，并接受所有默认值。
- en: We must make one `add_regressor` call for each additional regressor but note
    that we are leaving the regressor for `cloudy` out. For Prophet to get accurate
    forecast results, this isn’t strictly necessary. However, because including all
    four binary columns will introduce **multicollinearity**, this makes interpreting
    the individual effect of each condition difficult, so we will exclude one of them.
    However, Prophet is fairly robust to multicollinearity in additional regressors,
    so it shouldn’t affect your final results significantly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为每个额外的回归器调用一次`add_regressor`，但请注意，我们省略了`cloudy`回归器。为了Prophet能够得到准确的预测结果，这并不是严格必要的。然而，由于包含所有四个二元列将引入**多重共线性**，这使得解释每个条件的个体效应变得困难，因此我们将排除其中一个。但是，Prophet对额外回归器中的多重共线性相当稳健，所以它不应该对您的最终结果产生重大影响。
- en: 'When we called `pd.get_dummies` earlier, we could have specified the `drop_first=True`
    argument to exclude one of the conditions, but I decided not to so we could choose
    for ourselves which column to exclude. The `cloudy` condition is by far the most
    frequent so, by excluding it, we are essentially stating that `cloudy` is the
    *default* weather condition and the other conditions will be stated as deviations
    from it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前调用`pd.get_dummies`时，我们可以指定`drop_first=True`参数来排除一个条件，但我决定不这样做，这样我们就可以自己选择要排除的列。`cloudy`条件是最频繁的，因此，通过排除它，我们实际上是在声明`cloudy`是*默认*天气条件，其他条件将作为对其的偏差来陈述：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, remembering that we need future data for our additional regressors and
    we’re only going to forecast out two weeks, we need to artificially reduce our
    training data by two weeks to simulate having two future weeks of weather data
    but no ridership data. To do that, we’ll need to import `timedelta` from Python’s
    built-in `datetime` package.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们需要为我们的额外回归器提供未来数据，而我们只预测两周，我们需要人为地将我们的训练数据减少两周，以模拟有两个未来周的天气数据但没有乘客数据。为此，我们需要从Python的内置`datetime`包中导入`timedelta`。
- en: 'Using Boolean indexing in pandas, we will create a new DataFrame for training
    data, called `train`, by selecting all dates that are less than the final date
    (`df[''ds''].max()`) minus two weeks (`timedelta(weeks=2)`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pandas中的布尔索引，我们将通过选择所有小于最终日期（`df['ds'].max()`）减去两周（`timedelta(weeks=2)`）的日期来创建一个新的训练数据DataFrame，称为`train`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, we are essentially saying that our data ends not on December
    31, 2017 (as our `df` DataFrame does), but on December 16, 2017, and that we have
    a weather forecast for those two missing weeks. We now fit our model on this `train`
    data and create our `future` DataFrame with 14 days.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上是在说我们的数据不是在2017年12月31日结束（正如我们的`df` DataFrame所做的那样），而是在2017年12月16日结束，并且我们有这两周缺失的天气预报。我们现在在这个`train`数据上拟合我们的模型，并创建一个包含14天的`future`
    DataFrame。
- en: At this point, we need to add those additional regressor columns into our `future`
    DataFrame. Because we created that `train` DataFrame instead of `future` modifying
    our original `df` DataFrame, those values for the weather are stored in `df` and
    we can take them to use in our `future` DataFrame. Finally, we will predict on
    the future.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The forecast plot is going to look similar to our previous Divvy forecasts,
    so let’s just skip it and go straight to the `components` plot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This time, you will see a new subplot included with the other components. The
    following image is a crop of the full `components` plot and only shows the yearly
    seasonality and this new component:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Cropped components plot of binary additional regressors](img/Fig_9.3.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Cropped components plot of binary additional regressors
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The trend, weekly seasonality, and yearly seasonality, which were cropped out,
    look much the same as we’ve seen before with this dataset. However, we have a
    new addition to the `components` plot, called `extra_regressors_multiplicative`.
    Had we specified some of those regressors as `additive`, we would see a second
    subplot here, called `extra_regressors_additive`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: On dates where the value is at 0%, these are our *baseline* dates when the weather
    was cloudy, which we left out of the additional regressors. The other dates are
    those where the weather deviated from cloudy, which we included. We’ll take a
    more in-depth look at this in a bit. But first, let’s bring the temperature into
    our model and add a **continuous regressor**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Adding continuous regressors
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will take everything from the previous example and simply
    add one more regressor for temperature. Let’s begin by looking at the temperature
    data:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Chicago temperature over time](img/Fig_9.4.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Chicago temperature over time
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing too surprising about the preceding plot; daily temperatures
    rise in summer and fall in winter. It does look a lot like *Figure 5**.6* from
    [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254), *Working with Seasonality*, but
    without that increasing trend. Clearly, Divvy ridership and the temperature rise
    and fall together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding temperature, a continuous variable, is no different than adding binary
    variables. We simply add another `add_regressor` call to our Prophet instance,
    specifying `''temp''` for the name, and also including the temperature forecast
    in our `future` DataFrame. As we did before, we are fitting our model on the `train`
    DataFrame we created, which excludes the final 2 weeks’ worth of data. Finally,
    we plot the components to see what we’ve got:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the `extra_regressors_multiplicative` plot shows the same fluctuations
    that our `temperature` plot displayed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Cropped components plot of both binary and continuous additional
    regressors](img/Fig_9.5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Cropped components plot of both binary and continuous additional
    regressors
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Also note that in *Figure 9**.3*, the `yearly` plot peaked at 60% effect magnitude.
    However, now we can see that temperature accounts for some of that effect. The
    `yearly` plot in *Figure 9**.5* shows a peak 30% effect, while the `extra_regressors_multiplicative`
    plot shows a 40% increase on certain summertime dates and a massive 80% decrease
    in ridership on certain wintertime dates. To break this down further, we now need
    to discuss how to interpret this data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the regressor coefficients
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let’s look at how to inspect the effects of these additional regressors.
    Prophet includes a package called `utilities`, which has a function that will
    come in handy here, called `regressor_coefficients`. Let’s import it now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using it is straightforward. Just pass the model as an argument and it will
    output a DataFrame with some helpful information about the extra regressors included
    in the model:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s take a look at this DataFrame:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The regressor coefficients DataFrame](img/Fig_9.6.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – The regressor coefficients DataFrame
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: It features a row for each extra regressor in your model. In this case, we have
    one for temperature and three more for the weather conditions we included. The
    `regressor_mode` column naturally will have strings of either `additive` or `multiplicative`,
    depending upon the effect of each specific regressor on `'y'`. The mean value
    of the pre-standardized regressor (the raw input data) is saved in the `center`
    column. If the regressor wasn’t standardized, then the value will be zero.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The `coef` column is the one you really want to pay attention to. It denotes
    the expected value of the coefficient – that is, the expected impact on `'y'`
    of a unit increase in the regressor. In the preceding DataFrame, the `coef` for
    `temp` is `0.012282`. This coefficient tells us that for every degree higher than
    the `center` (`53.4`, in this case), the expected effect on ridership will be
    `0.012282`, or a 1.2% increase.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: For the `rain or snow` row, which is a binary regressor, it tells us that on
    those rainy or snowy days, then ridership will be down 20.6% compared to cloudy
    days, as that was the regressor we left out. Had we included all four weather
    conditions, to interpret this value, you would say ridership would be down 20.6%
    compared to the value predicted for the same day if modeled without including
    weather conditions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the columns for `'coef_lower'` and `'coef_upper'` indicate the lower
    and upper bounds, respectively, of the uncertainty interval around the coefficient.
    They are only of interest if `mcmc_samples` is set to a value greater than zero.
    `mcmc_samples` is left at the default value, as in these examples, `'coef_lower'`
    and `'coef_upper'` will be equal to `coef`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conclude, we can plot each of these extra regressors individually with
    the `plot_forecast_component` function we first used in [*Chapter 6*](B19630_06.xhtml#_idTextAnchor375),
    *Forecasting Holiday Effects*. After importing it from Prophet’s `plot` package,
    we will loop through each regressor in that `regressor_coefficients` DataFrame
    to plot it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We plotted all of those as subplots in one figure, resulting in the following
    diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Divvy extra regressor plots](img/Fig_9.7.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Divvy extra regressor plots
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: At last, we can visualize the effects of these regressors individually. The
    magnitudes of these plots should match the `coef` values in the DataFrame created
    with the `regressor_coefficients` function seen in *Figure 9**.6*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note regarding additional regressors in Prophet: they are always
    modeled as a linear relationship. This means that, for example, our extra regressor
    of temperature, which was found to increase ridership by 1.2% for every degree
    increase, is modeling a trend that will continue to infinity. That is, if the
    temperature were to spike to 120 degrees Fahrenheit, there’s no way for us to
    change the linear relationship and inform Prophet that ridership will probably
    decrease now that it’s getting so hot outside.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Although this is a limitation of Prophet as currently designed, in practice,
    it is not always a great problem. A linear relationship is very often a good proxy
    for the actual relationship, especially for a small range of data, and will still
    add a lot of additional information to your model to enrich your forecasts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a generalized method to add any additional regressors
    beyond the holidays, which you learned how to add earlier. You learned that adding
    both binary regressors (such as weather conditions) and continuous regressors
    (such as temperature) uses the same `add_regressor` method. You also learned how
    to use the `regressor_coefficients` function in Prophet’s `utilities` package
    to inspect the effects of your additional regressors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Although you may now want to add all sorts of extra regressors to your forecasts,
    you also learned that Prophet requires all additional regressors to have defined
    values going into the future or else there’s no information to inform a forecast.
    This is why we only forecasted 2 weeks out when using weather data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at how Prophet handles outliers and
    how you can exert greater control over the process yourself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
