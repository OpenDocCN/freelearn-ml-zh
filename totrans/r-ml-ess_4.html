<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Step 1 &#x2013; Data Exploration and Feature Engineering"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Step 1 – Data Exploration and Feature Engineering</h1></div></div></div><p>There are different kinds of problems that require a machine learning solution. For instance, our target can be forecasting future outcomes or identifying patterns from the data. The starting point is a set of objects (for example, items) or people (for example, customers of a supermarket). In most situations, a machine learning technique identifies the solution, starting from some features that describe objects/people. The features are numeric and/or categorical attributes, and they are the base of the machine learning model. Having the right features will improve the performance and accuracy of the model, so it is extremely important to define some features that are relevant to the problem.</p><p>In this chapter, you will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build machine learning solutions</li><li class="listitem" style="list-style-type: disc">Build a feature data</li><li class="listitem" style="list-style-type: disc">Clean the data</li><li class="listitem" style="list-style-type: disc">Explore the defined features</li><li class="listitem" style="list-style-type: disc">Modify the features</li><li class="listitem" style="list-style-type: disc">Rank the features using a filter</li></ul></div><div class="section" title="Building a machine learning solution"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Building a machine learning solution</h1></div></div></div><p>In which stage <a id="id181" class="indexterm"/>of a machine learning solution are we defining the features? Let's look at an overview of the whole procedure of building the solution. We can divide the approach into three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the features that we will be using.</li><li class="listitem">Apply one or more techniques to solve the problem.</li><li class="listitem">Evaluate the result and optimize the performance.</li></ol></div><p>In the first step, we can evaluate the relevance of each feature by using a filter and selecting the most relevant feature. We can also define a combination of some features that are good for describing the data.</p><p>In the second step, when we build a model, we can use some techniques (embedded methods) that rank the features and identify the most relevant feature automatically.</p><p>The last step is very important since we have more information, allowing us to identify a more proper feature set. For instance, we can use the same model with different sets of features and evaluate which feature combination performs better. An option is to use a wrapper that consists of building a model with a chosen set of features, iteratively add (or remove) a feature, and retain the change if it improves the accuracy of the model.</p><p>In conclusion, a feature <a id="id182" class="indexterm"/>selection is a cycle rather than a step, and it takes place in each part of the procedure. This chapter shows the feature engineering process, which consists of defining the features, transforming them, and identifying their ranking. The steps are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exploring the data</li><li class="listitem" style="list-style-type: disc">Defining/transforming new features</li><li class="listitem" style="list-style-type: disc">Identifying the most relevant features</li></ul></div><p>Although exploring the data is always at the beginning, all the steps can be repeated until we find a satisfying solution, so they don't always follow the same order. For instance, after identifying the most relevant features, we can explore the data, identify new patterns, and consequently define some new features.</p><p>The process of feature selection is related to the model, and in this chapter, we identify some features that are suitable for many models.</p><p>This chapter shows an example of flags. Based on the flag of a country, our target is to determine the country's language. Assuming that we know the flags of all the countries and the language of only some of them, the model will estimate the language of the others.</p></div></div>
<div class="section" title="Building the feature data"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Building the feature data</h1></div></div></div><p>This section shows <a id="id183" class="indexterm"/>how we can structure the raw data to build the features. For each country, the data is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A picture of the flag</li><li class="listitem" style="list-style-type: disc">Some geographical data such as continent, geographic quadrant, area, and population</li><li class="listitem" style="list-style-type: disc">The language and religion of the country</li></ul></div><p>The target is to build a model that predicts a country language starting from its flag. Most of the models can deal with numeric and/or categorical data, so we can't use the image of the flag as a feature for the model. The solution is to define some features, for instance the number of colors, that describe each flag. In this way, we start from a table whose rows correspond to the countries and whose columns correspond to the flag features.</p><p>It would take a lot of time to build the matrix with the flag attributes based on the pictures. Fortunately, we can use a dataset that contains some features. The data that we have is still a bit messy, so we need to clean and transform it to build a feature table in the <span class="emphasis"><em>right format</em></span>.</p><p>The features contained <a id="id184" class="indexterm"/>in the dataset display some information about:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The colors in the flag</li><li class="listitem" style="list-style-type: disc">The patterns in the flag</li><li class="listitem" style="list-style-type: disc">Some additional elements in the flag, such as text or some stars</li><li class="listitem" style="list-style-type: disc">Some geographical data, such as continent, geographic quadrant, area, and population</li><li class="listitem" style="list-style-type: disc">The language and religion of the country</li></ul></div><p>The steps to lead the table in the right format are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the dataset and the related information from <a class="ulink" href="https://archive.ics.uci.edu/ml/machine-learning-databases/flags/">https://archive.ics.uci.edu/ml/machine-learning-databases/flags/</a> and download <code class="literal">flag.data</code>.</li><li class="listitem">Open RStudio and set the working directory to the folder that contains the data:<div class="informalexample"><pre class="programlisting">setwd('path/containing/the/data')</pre></div></li><li class="listitem">Load the data into the R environment:<div class="informalexample"><pre class="programlisting">dfFlag &lt;- read.csv('flag.data', header=FALSE)</pre></div></li></ol></div><p>Now, we can see the structure of <code class="literal">dfFlag</code> using <code class="literal">str</code>:</p><div class="informalexample"><pre class="programlisting">str(dfFlag)
<span class="strong"><strong>'data.frame':    194 obs. of  30 variables:</strong></span>
<span class="strong"><strong> $ V1 : Factor w/ 194 levels "Afghanistan",..: 1 2 3 4 5 6 7 8 9 10 ...</strong></span>
<span class="strong"><strong> $ V2 : int  5 3 4 6 3 4 1 1 2 2 ...</strong></span>
<span class="strong"><strong> $ V3 : int  1 1 1 3 1 2 4 4 3 3 ...</strong></span>
<span class="strong"><strong> $ V4 : int  648 29 2388 0 0 1247 0 0 2777 2777 ...</strong></span>
<span class="strong"><strong> $ V5 : int  16 3 20 0 0 7 0 0 28 28 ...</strong></span>
<span class="strong"><strong> $ V6 : int  10 6 8 1 6 10 1 1 2 2 ...</strong></span>
<span class="strong"><strong> $ V7 : int  2 6 2 1 0 5 1 1 0 0 ...</strong></span>
<span class="strong"><strong> $ V8 : int  0 0 2 0 3 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V9 : int  3 0 0 0 0 2 1 1 3 3 ...</strong></span>
<span class="strong"><strong> $ V10: int  5 3 3 5 3 3 3 5 2 3 ...</strong></span>
<span class="strong"><strong> $ V11: int  1 1 1 1 1 1 0 1 0 0 ...</strong></span>
<span class="strong"><strong> $ V12: int  1 0 1 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V13: int  0 0 0 1 1 0 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ V14: int  1 1 0 1 1 1 0 1 0 1 ...</strong></span>
<span class="strong"><strong> $ V15: int  1 0 1 1 0 0 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ V16: int  1 1 0 0 0 1 0 1 0 0 ...</strong></span>
<span class="strong"><strong> $ V17: int  0 0 0 1 0 0 1 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V18: Factor w/ 8 levels "black","blue",..:5 7 5 2 4 7 8 7 2 2 ...</strong></span>
<span class="strong"><strong> $ V19: int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V20: int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V21: int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V22: int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V23: int  1 1 1 0 0 1 0 1 0 1 ...</strong></span>
<span class="strong"><strong> $ V24: int  0 0 1 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V25: int  0 0 0 1 0 0 0 1 0 0 ...</strong></span>
<span class="strong"><strong> $ V26: int  1 0 0 1 0 1 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V27: int  0 1 0 1 0 0 1 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V28: int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ V29: Factor w/ 7 levels "black","blue",..: 1 6 4 2 2 6 7 1 2 2 ...</strong></span>
<span class="strong"><strong> $ V30: Factor w/ 8 levels "black","blue",..: 5 7 8 7 7 1 2 7 2 2 ...</strong></span>
</pre></div><p>The <code class="literal">dfFlag</code> object <a id="id185" class="indexterm"/>contains 30 columns whose names are not defined. We have documentation that describes the data contained in <code class="literal">flag.description.txt</code>, which allows us to define the column names. The first seven columns contain some <a id="id186" class="indexterm"/>attributes that are not related to the flag. Let's start defining some vectors that contain the feature names. The first column is the name of the country. These are the steps to define the names:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the country name:<div class="informalexample"><pre class="programlisting">nameCountry &lt;- 'name'</pre></div></li><li class="listitem">Define the names of three geographic features: <code class="literal">continent</code>, <code class="literal">zone</code>, and <code class="literal">area</code>:<div class="informalexample"><pre class="programlisting">namesGeography &lt;- c('continent', 'zone', 'area')</pre></div></li><li class="listitem">Define the names of three features of the countries' citizens, including their language:<div class="informalexample"><pre class="programlisting">namesDemography &lt;- c('population', 'language', 'religion')</pre></div></li><li class="listitem">Define a unique vector that contains the seven attributes in the right order:<div class="informalexample"><pre class="programlisting">namesAttributes &lt;- c(nameCountry, namesGeography, namesDemography)</pre></div></li><li class="listitem">Define the names of the features defining the number of <code class="literal">bars</code>, <code class="literal">stripes</code>, and <code class="literal">colors</code>:<div class="informalexample"><pre class="programlisting">namesNumbers &lt;- c('bars', 'stripes', 'colors')</pre></div></li><li class="listitem">For some colors, there is a variable that displays <code class="literal">1</code> if the flag contains the color and <code class="literal">0</code> otherwise. Define their names:<div class="informalexample"><pre class="programlisting">namesColors &lt;- c('red', 'green', 'blue', 'gold', 'white', 'black', 'orange')</pre></div></li><li class="listitem">Define the name of the predominant color:<div class="informalexample"><pre class="programlisting">nameMainColor &lt;- 'mainhue'</pre></div></li><li class="listitem">Define the name of the attributes that display how many patterns/drawings (for instance, a shape, a picture, or a text) are contained in the flag:<div class="informalexample"><pre class="programlisting">namesDrawings &lt;- c(
  'circles', 'crosses', 'saltires', 'quarters',
  'sunstars', 'crescent', 'triangle', 'icon', 'animate', 'text'
)</pre></div></li><li class="listitem">Dangles: the color in <a id="id187" class="indexterm"/>two out of the four angles:<div class="informalexample"><pre class="programlisting">namesAngles &lt;- c('topleft', 'botright')</pre></div></li><li class="listitem">Define <code class="literal">namesFlag</code> that contains all the names in the right order:<div class="informalexample"><pre class="programlisting">namesFlag &lt;- c(namesNumbers, namesColors, nameMainColor, namesDrawings, namesAngles)</pre></div></li><li class="listitem">Set the <code class="literal">dfFlag</code> column names that bind <code class="literal">namesAttributes</code> and <code class="literal">namesFlag</code>:<div class="informalexample"><pre class="programlisting">names(dfFlag) &lt;- c(namesAttributes, namesFlag)</pre></div></li></ol></div><p>Now, the data frame has the right column names. However, some columns, such as <code class="literal">language</code> contain numbers instead of the attribute name, and the documentation shows what the numbers stand for. For instance, for language, 1 corresponds to English and 2 to Spanish. We can build a data table that has the data in the right format using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Convert <code class="literal">dfFlag</code> into the <code class="literal">dtFlag</code> data table:<div class="informalexample"><pre class="programlisting">library(data.table)
dtFlag &lt;- data.table(dfFlag)</pre></div></li><li class="listitem">Display the <code class="literal">continent</code> column:<div class="informalexample"><pre class="programlisting">dtFlag[1:20, continent]
<span class="strong"><strong>[1] 5 3 4 6 3 4 1 1 2 2 6 3 1 5 5 1 3 1 4 1</strong></span>
</pre></div></li><li class="listitem">The <code class="literal">continent</code> column contains a number between <code class="literal">1</code> and <code class="literal">6</code> and the documentation shows <code class="literal">1=N.America</code>, <code class="literal">2=S.America</code>, <code class="literal">3=Europe</code>, <code class="literal">4=Africa</code>, <code class="literal">5=Asia</code>, <code class="literal">6=Oceania</code>. Then, we define a vector that contains the continents:<div class="informalexample"><pre class="programlisting">vectorContinents &lt;- c('N.America', 'S.America', 'Europe', 'Africa', 'Asia', 'Oceania')</pre></div></li><li class="listitem">Convert <code class="literal">continent</code> into <code class="literal">factor</code> whose levels are <code class="literal">vectorContinents</code>:<div class="informalexample"><pre class="programlisting">dtFlag[, continent := factor(continent, labels=vectorContinents)]</pre></div></li><li class="listitem">Similar to <code class="literal">continent</code>, convert <code class="literal">zone</code> into <code class="literal">factor</code>:<div class="informalexample"><pre class="programlisting">vectorZones &lt;- c('NE', 'SE', 'SW', 'NW')
dtFlag[, zone := factor(zone, labels=vectorZones)]</pre></div></li><li class="listitem">Convert <code class="literal">language</code> into <code class="literal">factor</code>:<div class="informalexample"><pre class="programlisting">vectorLanguages &lt;- c(
  'English', 'Spanish', 'French', 'German', 'Slavic',
  'Other Indo-European', 'Chinese', 'Arabic',
  'Japanese/Turkish/Finnish/Magyar', 'Others')
  dtFlag[, language := factor(language, labels=vectorLanguages)]</pre></div></li><li class="listitem">Convert <a id="id188" class="indexterm"/><code class="literal">religion</code> into <code class="literal">factor</code>:<div class="informalexample"><pre class="programlisting">vectorReligions &lt;- c(
  'Catholic', 'Other Christian', 'Muslim', 'Buddhist',
  'Hindu', 'Ethnic', 'Marxist', 'Others'
)
dtFlag[, religion := factor(religion, labels=vectorReligions)]</pre></div></li></ol></div><p>Let's take a look at <code class="literal">dtFlag</code>:</p><div class="informalexample"><pre class="programlisting">str(dtFlag)
<span class="strong"><strong>Classes 'data.table' and 'data.frame':	194 obs. of  30 variables:</strong></span>
<span class="strong"><strong> $ name      : Factor w/ 194 levels "Afghanistan",..: 1 2 3 4 5 6 7 8 9 10 ...</strong></span>
<span class="strong"><strong> $ continent : int  5 3 4 6 3 4 1 1 2 2 ...</strong></span>
<span class="strong"><strong> $ zone      : Factor w/ 4 levels "NE","SE","SW",..: 1 1 1 3 1 2 4 4 3 3 ...</strong></span>
<span class="strong"><strong> $ area      : int  648 29 2388 0 0 1247 0 0 2777 2777 ...</strong></span>
<span class="strong"><strong> $ population: int  16 3 20 0 0 7 0 0 28 28 ...</strong></span>
<span class="strong"><strong> $ language  : int  10 6 8 1 6 10 1 1 2 2 ...</strong></span>
<span class="strong"><strong> $ religion  : int  2 6 2 1 0 5 1 1 0 0 ...</strong></span>
<span class="strong"><strong> $ bars      : int  0 0 2 0 3 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ stripes   : int  3 0 0 0 0 2 1 1 3 3 ...</strong></span>
<span class="strong"><strong> $ colors    : int  5 3 3 5 3 3 3 5 2 3 ...</strong></span>
<span class="strong"><strong> $ red       : int  1 1 1 1 1 1 0 1 0 0 ...</strong></span>
<span class="strong"><strong> $ green     : int  1 0 1 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ blue      : int  0 0 0 1 1 0 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ gold      : int  1 1 0 1 1 1 0 1 0 1 ...</strong></span>
<span class="strong"><strong> $ white     : int  1 0 1 1 0 0 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ black     : int  1 1 0 0 0 1 0 1 0 0 ...</strong></span>
<span class="strong"><strong> $ orange    : int  0 0 0 1 0 0 1 0 0 0 ...</strong></span>
<span class="strong"><strong> $ mainhue   : Factor w/ 8 levels "black","blue",..: 5 7 5 2 4 7 8 7 2 2 ...</strong></span>
<span class="strong"><strong> $ circles   : int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ crosses   : int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ saltires  : int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ quarters  : int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ sunstars  : int  1 1 1 0 0 1 0 1 0 1 ...</strong></span>
<span class="strong"><strong> $ crescent  : int  0 0 1 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ triangle  : int  0 0 0 1 0 0 0 1 0 0 ...</strong></span>
<span class="strong"><strong> $ icon      : int  1 0 0 1 0 1 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ animate   : int  0 1 0 1 0 0 1 0 0 0 ...</strong></span>
<span class="strong"><strong> $ text      : int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ topleft   : Factor w/ 7 levels "black","blue",..: 1 6 4 2 2 6 7 1 2 2 ...</strong></span>
<span class="strong"><strong> $ botright  : Factor w/ 8 levels "black","blue",..: 5 7 8 7 7 1 2 7 2 2 ...</strong></span>
<span class="strong"><strong> - attr(*, ".internal.selfref")=&lt;externalptr&gt; </strong></span>
</pre></div><p>The data is in the right format. Although we had to transform the data properly, it still took much less time than <a id="id189" class="indexterm"/>defining the features manually.</p></div>
<div class="section" title="Exploring and visualizing the features"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Exploring and visualizing the features</h1></div></div></div><p>After having <a id="id190" class="indexterm"/>defined the features, we can explore them and identify how they are related to the problem. In this section, you will see how to explore the data and define some simple charts.</p><p>Let's start with a <a id="id191" class="indexterm"/>feature, for instance, <code class="literal">mainhue</code>, which displays the predominant color of a flag. We want to identify the most common predominant colors, and for that purpose, we can use <code class="literal">table</code> to count the number of occurrences of each possible value. We can extract the <code class="literal">mainhue</code> column from <code class="literal">dtFlag</code> and apply <code class="literal">table</code> to it:</p><div class="informalexample"><pre class="programlisting">table(dtFlag[, mainhue])
<span class="strong"><strong>black   blue  brown   gold  green orange    red  white </strong></span>
<span class="strong"><strong>     5     40      2     19     31      4     71     22</strong></span>
</pre></div><p>The three most common predominant colors are red, blue, and green. Please note that we could have put <code class="literal">table</code> inside the square brackets, obtaining the same result with cleaner code: <code class="literal">dtFlag[, table(mainhue)]</code>.</p><p>How can we perform the same operation over any other column? First, let's define a string called <code class="literal">nameCol</code> that contains the name of the column that we want to analyze. In order to access the column, we can use <code class="literal">get(nameCol)</code> inside the square brackets of <code class="literal">dtFlag</code>:</p><div class="informalexample"><pre class="programlisting">nameCol &lt;- 'mainhue'
dtFlag[, table(get(nameCol))]</pre></div><p>This notation is very useful because we can easily include it inside a function using the name string, visualizing the same results for all the other columns:</p><div class="informalexample"><pre class="programlisting">listTableCol = lapply(
  namesAngles, function(nameCol){
    dtFlag[, table(get(nameCol))]
  })
listTableCol[[1]]
<span class="strong"><strong> black   blue   gold  green orange    red  white </strong></span>
<span class="strong"><strong>    12     43      6     32      4     56     41 </strong></span>
</pre></div><p>What if we want to <a id="id192" class="indexterm"/>build a chart instead? We can build a histogram using <code class="literal">barplot</code>. Let's first extract the table with each value of frequency:</p><div class="informalexample"><pre class="programlisting">nameCol &lt;- 'language'
freqValues &lt;- dtFlag[, table(get(nameCol))]</pre></div><p>The <code class="literal">freqValues</code> <a id="id193" class="indexterm"/>method contains the number of countries that speak any <a id="id194" class="indexterm"/>language in the list. We can extract a language vector using <code class="literal">names</code>:</p><div class="informalexample"><pre class="programlisting">names(freqValues)</pre></div><p>Now, we have all the necessary data to build a histogram (see the documentation of <code class="literal">barplot</code> if you haven't read <a class="link" href="ch03.html" title="Chapter 3. A Simple Machine Learning Analysis">Chapter 3</a>, <span class="emphasis"><em>A Simple Machine Learning Analysis</em></span>). In addition, we can define the colors using <code class="literal">rainbow</code>:</p><div class="informalexample"><pre class="programlisting">barplot(
  height = freqValues,
  names.arg = names(freqValues),
  main = nameCol,
  col = rainbow(length(freqValues)),
  ylab = 'number of flags'
)</pre></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_04_01.jpg" alt="Exploring and visualizing the features"/></div><p>This chart is very useful if we want to explore an attribute. In order to do this using just one line of code, we can define a function that builds this chart for a generic column, <code class="literal">nameCol</code>. In addition, we <a id="id195" class="indexterm"/>can add <code class="literal">legend</code> that displays the percentage. In order to display <code class="literal">legend</code>, we compute <code class="literal">percValues</code>, which contains the percentage of rows that <a id="id196" class="indexterm"/>display that value, and use it as the <code class="literal">legend.text</code> argument, as shown:</p><div class="informalexample"><pre class="programlisting">barplotAttribute &lt;- function(dtData, nameCol)
{
  # define the frequency
  freqValues &lt;- dtData[, table(get(nameCol))]
  # define the percentage
  percValues &lt;- freqValues / sum(freqValues)
  percValues &lt;- round(percValues * 100)
  percValues &lt;- paste(percValues, '%')
  # generate the histogram
  barplot(
    height = freqValues,
    names.arg = names(freqValues),
    main = nameCol,
    col = rainbow(length(freqValues)),
    legend.text = percValues,
    ylab = 'number of flags'
  )
}</pre></div><p>Let's apply <a id="id197" class="indexterm"/>the <a id="id198" class="indexterm"/>function to another column, for instance <code class="literal">stripes</code>:</p><div class="informalexample"><pre class="programlisting">barplotAttribute(dtFlag, 'stripes')</pre></div><div class="mediaobject"><img src="graphics/7740OS_04_02.jpg" alt="Exploring and visualizing the features"/></div><p>Using a <code class="literal">for</code> loop, we can generate the same chart for each flag attribute. We need time to see the result between, each chart and the following, so we stop the program using <code class="literal">readline</code>. The script pauses until we press <span class="emphasis"><em>Enter</em></span> in the console. In this way, we can explore all the features very quickly, shown as follows:</p><div class="informalexample"><pre class="programlisting">for(nameCol in namesFlag)
{
  barplotAttribute(dtFlag, nameCol)
  readline()
}</pre></div><p>With these few lines of code, we have observed how frequent the values of each feature are.</p><p>Another quick exploration is, given a color, counting the number of flags that contain the color. For instance, let's count the flags that have a red part. There is an attribute called <code class="literal">red</code> whose value is <code class="literal">1</code> if the flag contains a red part and <code class="literal">0</code> otherwise. If we sum up all the column values, we will obtain the total number of flags that contain a red part, as shown:</p><div class="informalexample"><pre class="programlisting">dtFlag[, sum(red)]
<span class="strong"><strong>[1] 153</strong></span>
dtFlag[, sum(get('red'))]
<span class="strong"><strong>[1] 153</strong></span>
</pre></div><p>As we have seen earlier, we <a id="id199" class="indexterm"/>can use <code class="literal">get</code> inside the square brackets. How can we do the same for all the common colors? The <code class="literal">namesColors</code> vector contains the name of all the <a id="id200" class="indexterm"/>color attributes, as shown:</p><div class="informalexample"><pre class="programlisting">namesColors
<span class="strong"><strong>[1] "red"    "green"  "blue"   "gold"   "white"  "black"  "orange"</strong></span>
</pre></div><p>The first element of <code class="literal">namesColors</code> is <code class="literal">red</code>, so we can use it to count the flags that contain red:</p><div class="informalexample"><pre class="programlisting">dtFlag[, sum(get(namesColors[1]))]
<span class="strong"><strong>[1] 153</strong></span>
</pre></div><p>We can use <code class="literal">sapply</code> (see the documentation) to apply a function over each element of <code class="literal">namesColors</code>. In this case, the function counts the number of flags that contain a specific color:</p><div class="informalexample"><pre class="programlisting">sapply(namesColors, function(nameColor){
  dtFlag[, sum(get(nameColor))]
})
<span class="strong"><strong>red  green   blue   gold  white  black orange </strong></span>
<span class="strong"><strong>153     91     99     91    146     52     26 </strong></span>
</pre></div><p>The most common colors are red and green.</p><p>Until now, we have explored the flag's features; the next step is to see how they are related to the country's language. A fast way is to use a decision tree (see <a class="link" href="ch03.html" title="Chapter 3. A Simple Machine Learning Analysis">Chapter 3</a>, <span class="emphasis"><em>A Simple Machine Learning Analysis</em></span>).</p><p>First, let's import the packages to generate and visualize the decision tree:</p><div class="informalexample"><pre class="programlisting">library('rpart')
library('rpart.plot')</pre></div><p>The decision tree model requires a formula object that defines the relationship between the variables. In this case, the formula is <span class="emphasis"><em>language ~ feature1 + feature2 + …</em></span>. We can build the formula by adding <a id="id201" class="indexterm"/>all the names contained in <code class="literal">namesFlag</code> using a <code class="literal">for</code> <a id="id202" class="indexterm"/>loop, as shown:</p><div class="informalexample"><pre class="programlisting">formulaRpart &lt;- 'language ~ '
for(name in namesFlag){
  formulaRpart &lt;- paste(formulaRpart, '+', name)
}
formulaRpart &lt;- formula(formulaRpart)</pre></div><p>We can build the model using <code class="literal">rpart</code> and visualize the tree using <code class="literal">prp</code>:</p><div class="informalexample"><pre class="programlisting">tree &lt;- rpart(formula=formulaRpart, data=dtFlag)
prp(tree)</pre></div><div class="mediaobject"><img src="graphics/7740OS_04_03.jpg" alt="Exploring and visualizing the features"/></div><p>Some nodes of the tree are not clear to read. For instance, <code class="literal">saltires</code> displays <code class="literal">1</code> if the flag has a saltire, and <code class="literal">0</code> otherwise. The first tree node expresses the <span class="strong"><strong>saltires &gt;= 0.5</strong></span> condition, so the flags on the left have a saltire. This reflects the fact that the features are not in the appropriate format, so the next step will be to transform the feature.</p><p>First, let's define a new data table called <code class="literal">dtFeatures</code>, which contains the features and the outcome. From now, we will modify <code class="literal">dtFeatures</code> until all the features are in the right format, as shown:</p><div class="informalexample"><pre class="programlisting">dtFeatures &lt;- dtFlag[, c('language', namesFlag), with=FALSE]</pre></div><p>Let's define a function to visualize the table. We will reuse this function to keep track of progress during the feature transformation, as shown:</p><div class="informalexample"><pre class="programlisting">plotTree &lt;- function(dtFeatures){
  formulaRpart &lt;- paste(names(dtFeatures)[1], '~')
  for(name in names(dtFeatures)[-1]){
    formulaRpart &lt;- paste(formulaRpart, '+', name)
  }
  formulaRpart &lt;- formula(formulaRpart)
  tree &lt;- rpart(formula=formulaRpart, data=dtFeatures)
  prp(tree)
}
plotTree(dtFeatures)</pre></div><p>The chart is exactly the same as before.</p><p>So far, we have seen some <a id="id203" class="indexterm"/>techniques to explore the features. The data exploration allowed us to investigate the data nature, and it's the starting point to clean the current features and define some others. In addition, we have built some functions that <a id="id204" class="indexterm"/>allow us to generate some charts using just one line of code. We can use these functions to keep track of the feature transformation.</p></div>
<div class="section" title="Modifying the features"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Modifying the features</h1></div></div></div><p>Our features are <a id="id205" class="indexterm"/>attributes that describe the flag, and some of them might not be in the right format. In this section, we will take a look at each feature and transform it if necessary.</p><p>In order to keep track of which features we have already processed, let's start defining an empty vector <code class="literal">namesProcessed</code>, which contains the features that we have already processed. When we transform a feature, we add the feature name into <code class="literal">namesProcessed</code>:</p><div class="informalexample"><pre class="programlisting">namesProcessed &lt;- c()</pre></div><p>Let's start with the numeric columns, such as <code class="literal">red</code>, which have two possible outcomes: <code class="literal">0</code>, in case the flag contains red and <code class="literal">1</code> otherwise. The <code class="literal">red</code> variable defines an attribute, so it should be categorical instead of numeric. Then, we can convert <code class="literal">red</code> into a feature that is <code class="literal">yes</code> if the color is red and <code class="literal">no</code> otherwise.</p><p>If we take a look at the charts of each feature, we notice that some of them display only two values that are always <code class="literal">0</code> and <code class="literal">1</code>. In order to convert each of them into the <code class="literal">yes</code> and <code class="literal">no</code> format, we can use a <code class="literal">for</code> loop. For each feature in <code class="literal">namesFlag</code>, we check if there are only two possible values. If so, we convert the feature into a factor. Let's start with <code class="literal">red</code>:</p><div class="informalexample"><pre class="programlisting">nameFeat &lt;- 'red'</pre></div><p>We can check if <code class="literal">nameFeat</code> displays two values:</p><div class="informalexample"><pre class="programlisting">length(unique(dtFeatures[, get(nameFeat)])) == 2</pre></div><p>In this case, the answer is <code class="literal">TRUE</code>, so we can generate a vector that contains the same column with <code class="literal">no</code> and <code class="literal">yes</code> for <code class="literal">0</code> and <code class="literal">1</code> respectively. For this purpose, we use <code class="literal">factor</code>, which specifies that the labels are <code class="literal">no</code> and <code class="literal">yes</code>, as shown:</p><div class="informalexample"><pre class="programlisting">vectorFactor &lt;- dtFeatures[
  , factor(get(nameFeat), labels=c('no', 'yes'))
]
head(vectorFactor)
<span class="strong"><strong>[1] yes yes yes yes yes yes</strong></span>
<span class="strong"><strong>Levels: no yes</strong></span>
</pre></div><p>Now, we can convert <a id="id206" class="indexterm"/>each feature that displays two possible outcomes using a <code class="literal">for</code> loop. For each feature, we check whether it has only two values using <code class="literal">if</code>. After we generate <code class="literal">vectorFactor</code>, we override the old column using <code class="literal">eval</code> inside the square brackets. Doing <code class="literal">dtFeatures[, eval('red') := vectorFactor]</code> is the same as <code class="literal">dtFeatures[, red := vectorFactor]</code>, shown as follows:</p><div class="informalexample"><pre class="programlisting">for(nameFeat in namesFlag){
  if(length(unique(dtFeatures[, get(nameFeat)])) == 2){
    vectorFactor &lt;- dtFeatures[
      , factor(get(nameFeat), labels=c('no', 'yes'))]
    dtFeatures[, eval(nameFeat) := vectorFactor]
    namesProcessed &lt;- c(namesProcessed, nameFeat)
  }
}</pre></div><p>Let's take a look at the features that we haven't transformed yet. The <code class="literal">namesFlag</code> feature contains all the initial features, and <code class="literal">namesProcessed</code> contains the ones that we have already transformed. In order to visualize the features that are not in <code class="literal">namesProcessed</code>, we can use <code class="literal">setdiff</code>, which is a function that gives the elements that are in the first vector and not in the second, as shown:</p><div class="informalexample"><pre class="programlisting">setdiff(namesFlag, namesProcessed)</pre></div><p>There are still many features that we haven't analyzed yet. For instance, <code class="literal">bars</code> is a numeric attribute that displays the number of vertical bars in a flag. If we use <code class="literal">bars</code> as a numeric feature, the model will identify a relationship between the language and the model. All flags of the Spanish-speaking countries contain zero or three bars, so model can learn something like "the language can be Spanish only if we have less than four bars." However, there is no Spanish-speaking country whose flag has 1 or 2 bars. A solution is to group the countries on the basis of the number of bars, as shown:</p><div class="informalexample"><pre class="programlisting">barplotAttribute(dtFeatures, 'bars')</pre></div><div class="mediaobject"><img src="graphics/7740OS_04_04.jpg" alt="Modifying the features"/></div><p>The chart shows that the groups with a significant number of flags are the <span class="strong"><strong>0</strong></span> and <span class="strong"><strong>3</strong></span> bars. Therefore, the groups <a id="id207" class="indexterm"/>can be as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flags with no bars</li><li class="listitem" style="list-style-type: disc">Flags with three bars</li><li class="listitem" style="list-style-type: disc">All the other flags</li></ul></div><p>We can define a new column named <code class="literal">nBars0</code>, which is equal to <code class="literal">TRUE</code> if the flag has no vertical bars:</p><div class="informalexample"><pre class="programlisting">dtFeatures[, nBars0 := bars == 0]</pre></div><p>Similarly, we define <code class="literal">nBars3</code>, which is <code class="literal">TRUE</code> for the flags with three bars. We don't need to define a column with the remaining flags because they can already be identified by checking that <code class="literal">nBars0</code> and <code class="literal">nBars3</code> are <code class="literal">FALSE</code>:</p><div class="informalexample"><pre class="programlisting">dtFeatures[, nBars1_2 := bars %in% c(1, 2)]
dtFeatures[, nBars3 := bars == 3]</pre></div><p>Let's remove the initial <code class="literal">bars</code> column and add <code class="literal">bars</code> to <code class="literal">namesProcessed</code>:</p><div class="informalexample"><pre class="programlisting">dtFeatures[, bars := NULL]
namesProcessed &lt;- c(namesProcessed, 'bars')</pre></div><p>The operation that we performed is called <span class="strong"><strong>discretization</strong></span> because we generated some discrete features, starting from a numeric one.</p><p>Similarly, we can <a id="id208" class="indexterm"/>transform <code class="literal">stripes</code> and <code class="literal">colors</code>:</p><div class="informalexample"><pre class="programlisting">barplotAttribute(dtFeatures, 'stripes')
dtFeatures[, nStrp0 := stripes == 0]
dtFeatures[, nStrp2 := stripes == 2]
dtFeatures[, nStrp3 := stripes == 3]
dtFeatures[, nStrp5 := stripes == 5]
dtFeatures[, stripes := NULL]
namesProcessed &lt;- c(namesProcessed, 'stripes')

barplotAttribute(dtFeatures, 'colors')
dtFeatures[, nCol12 := colors %in% c(1, 2)]
dtFeatures[, nCol3 := colors == 3]
dtFeatures[, nCol4_5 := colors %in% c(4, 5)]
dtFeatures[, colors := NULL]
namesProcessed &lt;- c(namesProcessed, 'colors')</pre></div><p>Let's take a look at the features contained in <code class="literal">namesDrawings</code> that we haven't processed yet:</p><div class="informalexample"><pre class="programlisting">for(nameCol in setdiff(namesDrawings, namesProcessed)){
  barplotAttribute(dtFeatures, nameCol)
  readline()
}</pre></div><div class="mediaobject"><img src="graphics/7740OS_04_05.jpg" alt="Modifying the features"/></div><p>In all these features, most of the flags display <code class="literal">0</code>. Therefore, we can group the flags into two categories: <code class="literal">0</code> and the rest. We are defining a new categorical variable that is <code class="literal">yes</code> if the value is greater than <code class="literal">0</code> and <a id="id209" class="indexterm"/>
<code class="literal">no</code> otherwise. The process is called <span class="strong"><strong>binarization</strong></span> because we transform some <a id="id210" class="indexterm"/>numeric features into categorical features that display two values only, as shown:</p><div class="informalexample"><pre class="programlisting">for(nameCol in setdiff(namesDrawings, namesProcessed)){
  dtFeatures[, eval(nameCol) := ifelse(get(nameCol) &gt; 0, 'yes', 'no')]
  namesProcessed &lt;- c(namesProcessed, nameCol)
}</pre></div><p>Let's explore the remaining features, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">for(nameCol in setdiff(namesFlag, namesProcessed)){
  barplotAttribute(dtFeatures, nameCol)
  readline()
}</pre></div><p>The chart obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_04_06.jpg" alt="Modifying the features"/></div><p>The three remaining features are <code class="literal">topleft</code>, <code class="literal">botright</code>, and <code class="literal">mainhue</code>. They are all categorical and display more than two possible values. For instance, there are eight options for <code class="literal">mainhue</code>. However, only a few flags have <code class="literal">black</code>, <code class="literal">brown</code>, or <code class="literal">orange</code> as their main color. We don't have enough information to take into account the less common colors. In this case, we can define a new categorical variable called <code class="literal">dummy variable</code> for each of them. We can decide to define a dummy variable for each possible color with at least 15 flags. The situation is <a id="id211" class="indexterm"/>similar for <code class="literal">topleft</code> and <code class="literal">botright</code>, so we can transform all of them in the same way, as shown:</p><div class="informalexample"><pre class="programlisting">namesToDummy &lt;- c("topleft", "botright", "mainhue")
for(nameCol in namesToDummy){
  frequencyColors &lt;- dtFeatures[, list(.N), by=nameCol]
  for(color in frequencyColors[N &gt; 20, get(nameCol)]){
    nameFeatNew &lt;- paste(nameCol, color, sep='')
    dtFeatures[, eval(nameFeatNew) := get(nameCol) == color]
  }
  dtFeatures[, eval(nameCol) := NULL]
  namesProcessed &lt;- c(namesProcessed, nameCol)
}</pre></div><p>Now, we have transformed all the features. However, some of the new columns that we have defined are of the <code class="literal">logical</code> class. It's better to visualize them as categorical attributes that display <code class="literal">yes</code> or <code class="literal">no</code>, so it's best to transform them, as shown:</p><div class="informalexample"><pre class="programlisting">for(nameCol in names(dtFeatures)){
  if(dtFeatures[, class(get(nameCol))] == 'logical'){
    print(nameCol)
    dtFeatures[, eval(nameCol) := ifelse(get(nameCol), 'yes', 'no')]
  }
}</pre></div><p>Let's see how the <a id="id212" class="indexterm"/>decision tree has changed using the following code:</p><div class="informalexample"><pre class="programlisting">plotTree(dtFeatures)</pre></div><p>The chart obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_04_07.jpg" alt="Modifying the features"/></div><p>The decision tree is similar to the earlier tree. However, each node of the decision tree is checking a condition whose outcomes are <code class="literal">yes</code> and <code class="literal">no</code>.</p><p>In this chapter, we have seen <a id="id213" class="indexterm"/>three ways of transforming the features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Discretization</strong></span>: Starting <a id="id214" class="indexterm"/>from a numeric variable, we group all the possible values in sets. Then, for each set, we define a new <a id="id215" class="indexterm"/>variable that displays <code class="literal">yes</code> if the numeric variable belongs to the set and <code class="literal">no</code> otherwise.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Binarization</strong></span>: Starting <a id="id216" class="indexterm"/>from a numeric variable, we discretize a numeric variable by defining two sets only. We define a <a id="id217" class="indexterm"/>threshold and we check whether the variable is above or below the threshold.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dummy</strong></span>: Starting from a <a id="id218" class="indexterm"/>categorical variable, we identify the most common outcomes. Then, for each common outcome, we <a id="id219" class="indexterm"/>define a new variable that displays <code class="literal">yes</code> if the variable is equal to the value and <code class="literal">no</code> otherwise.</li></ul></div></div>
<div class="section" title="Ranking the features using a filter or a dimensionality reduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Ranking the features using a filter or a dimensionality reduction</h1></div></div></div><p>In the <a id="id220" class="indexterm"/>previous section, we defined different features. But are <a id="id221" class="indexterm"/>all of them really relevant to the problem? There are some techniques called <span class="strong"><strong>embedded models</strong></span> that automatically select the most relevant features. We can also build the same machine <a id="id222" class="indexterm"/>learning model using different sets of features and <a id="id223" class="indexterm"/>pick the set whose performance is better. Both the options are good, although they require a lot of computational power.</p><p>An alternative is to use filters that are techniques that identify the most relevant features. We use filters before applying any machine learning model, and in this way, we cut a lot of the computational cost of the algorithms. Some filters take account of each feature separately and are very computationally efficient.</p><p>A simple filter is the <span class="strong"><strong>Pearson correlation coefficient</strong></span>, which is a measure of the linear relationship <a id="id224" class="indexterm"/>between variables. The correlation is a number between -1 and 1, and these two extreme values express a clear linear relationship between the two variables. When drawing a chart, all the points lie on the same line. A correlation of 0 expresses that there is no linear dependence between the two variables. The higher the correlation module, the stronger the linear relationship. In our case, we can measure the correlation between each flag attribute and the language, and pick the attributes whose correlation module is higher.</p><p>Another technique that takes account of each feature separately is the information-gain ratio. Let's suppose that we want to build a model without knowing anything about the flags. In this case, the best we can do is to identify the most common language and assume that each country speaks that language. What if we know only which flags contain the color red? The model will definitely be better than not having any information. How much better? The information-gain ratio of a feature is an index that quantifies the improvement that comes from adding the feature.</p><p>The correlation <a id="id225" class="indexterm"/>and information-gain ratio take account of each feature separately, so they completely ignore the interaction between them. For instance, we can have two features that have a high impact on the language and are so strongly related with each other that they contain the same information. Let's suppose that we have already included one of the two features in the model. Adding the other won't provide <a id="id226" class="indexterm"/>any further information, although it would be highly relevant by itself. If the relationship between the two features <a id="id227" class="indexterm"/>is linear, we talk about <span class="strong"><strong>multicollinearity</strong></span>.</p><p>In other situations, we have two features that have a little relevance if taken separately and have a big impact if taken together. If we rank the features using this kind of filter, we will exclude both of them, losing some useful information.</p><p>An alternative to ranking the features is identifying relevant feature combinations. A technique is the <span class="strong"><strong>Principal </strong></span>
<a id="id228" class="indexterm"/>
<span class="strong"><strong>component analysis</strong></span> (<span class="strong"><strong>PCA</strong></span>), and it is based on the correlation between features. Starting from the features, the PCA defines a <a id="id229" class="indexterm"/>set of variables called principal components, which are linearly independent of each other. The number of principal components is equal to or less than the number of features and the components are ranked by variance. Then, it's possible to select a subset of components that have high variances. However, PCA has limitations since it is based on linear relationships only, and it doesn't take account of the attribute to predict things (language, in our example).</p><p>There are different <a id="id230" class="indexterm"/>techniques, and the one that we use in this chapter is the <span class="strong"><strong>information gain ratio</strong></span> as it is simple and meaningful. R provides us with the <code class="literal">FSelector</code> <a id="id231" class="indexterm"/>package that contains different tools for the feature selection. The package requires you to have JRE installed on your computer, as shown:</p><div class="informalexample"><pre class="programlisting">install.packages('FSelector')
library('FSelector')</pre></div><p>Let's build the <code class="literal">namesFeatures</code> vector that contains the name of all the features. Then, we can compute their information gain ratio using the <code class="literal">information.gain</code> function, as shown:</p><div class="informalexample"><pre class="programlisting">namesFeatures &lt;- names(dtFeatures)[-1]
dfGains &lt;- information.gain(language~., dtFeatures)</pre></div><p>The <code class="literal">dfGains</code> <a id="id232" class="indexterm"/>method is a data frame with a <a id="id233" class="indexterm"/>field named <code class="literal">attr_importance</code>. The feature names <a id="id234" class="indexterm"/>are the row names, so let's <a id="id235" class="indexterm"/>add another column that contains the <a id="id236" class="indexterm"/>names:</p><div class="informalexample"><pre class="programlisting">dfGains$feature &lt;- row.names(dfGains)</pre></div><p>Let's convert the data frame into a data table:</p><div class="informalexample"><pre class="programlisting">dtGains &lt;- data.table(dfGains)</pre></div><p>In order to see the most relevant features, we can sort them by relevance:</p><div class="informalexample"><pre class="programlisting">dtGains &lt;- dtGains[order(attr_importance, decreasing = T)]
 head(dtGains)
<span class="strong"><strong>   attr_importance      feature</strong></span>
<span class="strong"><strong>1:       0.1583055         blue</strong></span>
<span class="strong"><strong>2:       0.1537296     saltires</strong></span>
<span class="strong"><strong>3:       0.1313155 botrightblue</strong></span>
<span class="strong"><strong>4:       0.1262545  mainhueblue</strong></span>
<span class="strong"><strong>5:       0.1205012       nStrp3</strong></span>
<span class="strong"><strong>6:       0.1149405     quarters</strong></span>
</pre></div><p>The <code class="literal">blue</code> and <code class="literal">saltires</code> features define very relevant attributes. In order to visualize the most relevant features, we can build a chart with the top 12 attributes, as shown:</p><div class="informalexample"><pre class="programlisting">dtGainsTop &lt;- dtGains[1:12]
barplot(
  height = dtGainsTop[, attr_importance],
  names.arg = dtGainsTop[, feature],
  main = 'information gain',
  col = rainbow(nrow(dtGainsTop)),
  legend.text = dtGainsTop[, feature],
  xlim=c(0, 20)
)</pre></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_04_08.jpg" alt="Ranking the features using a filter or a dimensionality reduction"/></div><p>Now that we have defined feature ranking, we are able to build a model from the most relevant features. We can either include all the features whose relevance is above a chosen threshold, or <a id="id237" class="indexterm"/>pick a defined <a id="id238" class="indexterm"/>number of features starting <a id="id239" class="indexterm"/>from the top. However, we are still not taking into account the interaction between the features. For instance, among the top features, we <a id="id240" class="indexterm"/>have <code class="literal">the flag contains the blue</code>, <code class="literal">blue is the main color</code>, and <code class="literal">the bottom right is blue</code>. Although they are all very relevant, they are all about <code class="literal">blue</code>, so they are redundant and we can exclude one of them.</p><p>In conclusion, the filters are fast and useful methods to rank the features, but we have to be very careful about using them when we build the model.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, you learned how to perform feature selection. After having loaded and explored the features, you saw how to transform them using discretization and binarization. You also converted categoric features into dummy variables. You understood the importance of feature selection and ranked the features using the information gain ratio. In the next chapter, we will predict the language using machine learning techniques.</p></div></body></html>