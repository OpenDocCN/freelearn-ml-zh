["```py\ndef read_frame(): -> Tuple[bool,np.ndarray]:\n```", "```py\n    frame, timestamp = freenect.sync_get_depth() \n    if frame is None:\n        return False, None\n```", "```py\nnp.clip(depth, 0, 2**10-1, depth) \ndepth >>= 2 \n```", "```py\nreturn True, depth.astype(np.uint8) \n```", "```py\ncv2.imshow(\"depth\", read_frame()[1]) \n```", "```py\nimport cv2\nprint(cv2.getBuildInformation())\n```", "```py\ndevice = cv2.cv.CV_CAP_OPENNI \ncapture = cv2.VideoCapture(device) \n```", "```py\ncapture.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH, 640) \ncapture.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT, 480) \n```", "```py\ndef read_frame():\n    if not capture.grab():\n        return False,None\n    return capture.retrieve(cv2.CAP_OPENNI_DEPTH_MAP)\n```", "```py\nimport cv2\nimport numpy as np\nfrom gestures import recognize\nfrom frame_reader import read_frame\n```", "```py\ndef draw_helpers(img_draw: np.ndarray) -> None:\n    # draw some helpers for correctly placing hand\n    height, width = img_draw.shape[:2]\n    color = (0,102,255)\n    cv2.circle(img_draw, (width // 2, height // 2), 3, color, 2)\n    cv2.rectangle(img_draw, (width // 3, height // 3),\n                  (width * 2 // 3, height * 2 // 3), color, 2)\n```", "```py\ndef main():\n    for _, frame in iter(read_frame, (False, None)):\n```", "```py\nnum_fingers, img_draw = recognize(frame)\n```", "```py\n draw_helpers(img_draw)\n```", "```py\n        # print number of fingers on image\n        cv2.putText(img_draw, str(num_fingers), (30, 30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255))\n        cv2.imshow(\"frame\", img_draw)\n        # Exit on escape\n        if cv2.waitKey(10) == 27:\n            break\n```", "```py\ndef recognize(img_gray: np.ndarray) -> Tuple[int,np.ndarray]:\n    # segment arm region\n    segment = segment_arm(img_gray) \n```", "```py\n# find the hull of the segmented area, and based on that find the\n# convexity defects\ncontour, defects = find_hull_defects(segment)\n```", "```py\nimg_draw = cv2.cvtColor(segment, cv2.COLOR_GRAY2RGB)\nnum_fingers, img_draw = detect_num_fingers(contour,\n                                             defects, img_draw)\n```", "```py\nreturn num_fingers, img_draw\n```", "```py\nwidth, height = depth.shape \ncenter_pixel_depth = depth[width/2, height/2] \n```", "```py\nimport numpy as np \n\ndepth_mask = np.where(depth == center_pixel_depth, 255, \n     0).astype(np.uint8)\n```", "```py\ndef segment_arm(frame: np.ndarray, abs_depth_dev: int = 14) -> np.ndarray:\n    height, width = frame.shape\n    # find center (21x21 pixels) region of imageheight frame\n    center_half = 10 # half-width of 21 is 21/2-1\n    center = frame[height // 2 - center_half:height // 2 + center_half,\n                   width // 2 - center_half:width // 2 + center_half]\n```", "```py\nmed_val = np.median(center) \n```", "```py\nframe = np.where(abs(frame - med_val) <= abs_depth_dev,\n                 128, 0).astype(np.uint8)\n```", "```py\nkernel = np.ones((3, 3), np.uint8)\nframe = cv2.morphologyEx(frame, cv2.MORPH_CLOSE, kernel)\n```", "```py\nsmall_kernel = 3\nframe[height // 2 - small_kernel:height // 2 + small_kernel,\n      width // 2 - small_kernel:width // 2 + small_kernel] = 128\n```", "```py\nmask = np.zeros((height + 2, width + 2), np.uint8)\n```", "```py\nflood = frame.copy()\ncv2.floodFill(flood, mask, (width // 2, height // 2), 255,\n              flags=4 | (255 << 8))\n```", "```py\nret, flooded = cv2.threshold(flood, 129, 255, cv2.THRESH_BINARY) \n```", "```py\ndef find_hull_defects(segment: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    contours, hierarchy = cv2.findContours(segment, cv2.RETR_TREE,\n                                           cv2.CHAIN_APPROX_SIMPLE)\n```", "```py\nmax_contour = max(contours, key=cv2.contourArea) \n```", "```py\nepsilon = 0.01 * cv2.arcLength(max_contour, True)\nmax_contour = cv2.approxPolyDP(max_contour, epsilon, True)\n```", "```py\nhull = cv2.convexHull(max_contour, returnPoints=False) \n```", "```py\ndefects = cv2.convexityDefects(max_contour, hull) \n```", "```py\nreturn max_contour, defects \n```", "```py\ndef angle_rad(v1, v2): \n    return np.arctan2(np.linalg.norm(np.cross(v1, v2)), \n         np.dot(v1, v2))\n```", "```py\ndef deg2rad(angle_deg): \n    return angle_deg/180.0*np.pi \n```", "```py\ndef detect_num_fingers(contour: np.ndarray, defects: np.ndarray,\n                       img_draw: np.ndarray, thresh_deg: float = 80.0) -> Tuple[int, np.ndarray]:\n```", "```py\nif defects is None: \n    return [0, img_draw] \n```", "```py\nif len(defects) <= 2: \n    return [0, img_draw] \n```", "```py\nnum_fingers = 1 \n```", "```py\n# Defects are of shape (num_defects,1,4)\nfor defect in defects[:, 0, :]:\n    # Each defect is an array of four integers.\n    # First three indexes of start, end and the furthest\n    # points respectively\n    start, end, far = [contour[i][0] for i in defect[:3]]\n    # draw the hull\n    cv2.line(img_draw, tuple(start), tuple(end), (0, 255, 0), 2)\n```", "```py\n# if angle is below a threshold, defect point belongs to two\n# extended fingers\nif angle_rad(start - far, end - far) < deg2rad(thresh_deg):\n    # increment number of fingers\n    num_fingers += 1\n\n    # draw point as green\n    cv2.circle(img_draw, tuple(far), 5, (0, 255, 0), -1)\nelse:\n    # draw point as red\n    cv2.circle(img_draw, tuple(far), 5, (0, 0, 255), -1)\n```", "```py\nreturn min(5, num_fingers), img_draw\n```"]