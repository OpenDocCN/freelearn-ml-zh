- en: Fun with Filters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与过滤器一起玩乐
- en: The goal of this chapter is to develop a number of image processing filters
    and then apply them to the video stream of a webcam in real time. These filters
    will rely on various OpenCV functions to manipulate matrices through splitting,
    merging, arithmetic operations, and applying lookup tables for complex functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是开发一系列图像处理过滤器，并将它们实时应用于网络摄像头的视频流中。这些过滤器将依赖于各种OpenCV函数，通过分割、合并、算术运算和应用查找表来操作矩阵。
- en: 'We will cover the following three effects, which will help familiarize you
    with OpenCV, and we will build on these effects in future chapters of this book:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍以下三种效果，这将帮助您熟悉OpenCV，并在本书的后续章节中构建这些效果：
- en: '**Warming and cooling filters**: We will implement our own **curve filters**
    using a lookup table.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暖色和冷色过滤器**: 我们将使用查找表实现自己的**曲线过滤器**。'
- en: '**Black-and-white pencil sketch**: We will make use of two image-blending techniques,
    known as **dodging** and **burning**.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑白铅笔素描**: 我们将利用两种图像混合技术，称为** dodging**和** burning**。'
- en: '**Cartoonizer**: We will combine a bilateral filter, a median filter, and adaptive
    thresholding.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卡通化工具**: 我们将结合双边滤波器、中值滤波器和自适应阈值。'
- en: OpenCV is an advanced toolchain. It often raises the question, that is, not
    how to implement something from scratch, but which precanned implementation to
    choose for your needs. Generating complex effects is not hard if you have a lot
    of computing resources to spare. The challenge usually lies in finding an approach
    that not only gets the job done but also gets it done in time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是一个高级工具链。它经常引发这样的问题，即，不是如何从头开始实现某物，而是为您的需求选择哪个预定义的实现。如果您有大量的计算资源，生成复杂效果并不难。挑战通常在于找到一个既能完成任务又能按时完成的方法。
- en: Instead of teaching the basic concepts of image manipulation through theoretical
    lessons, we will take a practical approach and develop a single end-to-end app
    that integrates a number of image filtering techniques. We will apply our theoretical
    knowledge to arrive at a solution that not only works but also speeds up seemingly
    complex effects so that a laptop can produce them in real time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会通过理论课程教授图像处理的基本概念，而是将采取一种实用方法，开发一个单一端到端的应用程序，该程序集成了多种图像过滤技术。我们将应用我们的理论知识，得出一个不仅有效而且能加快看似复杂效果解决方案，以便笔记本电脑可以实时生成它们。
- en: 'In this chapter, you will learn how to do the following using OpenCV:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用OpenCV完成以下操作：
- en: Creating a black-and-white pencil sketch
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建黑白铅笔素描
- en: Applying pencil sketch transformation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用铅笔素描变换
- en: Generating a warming and cooling filter
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成暖色和冷色过滤器
- en: Cartoonizing an image
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像卡通化
- en: Putting it all together
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: Learning this will allow you to familiarize yourself with loading images into
    OpenCV and applying different transformations to those images using OpenCV. This
    chapter will help you learn the basics of how OpenCV operates, so we can focus
    on the internals of the algorithms in the following chapters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这一点将使您熟悉将图像加载到OpenCV中，并使用OpenCV对这些图像应用不同的变换。本章将帮助您了解OpenCV的基本操作，这样我们就可以专注于以下章节中算法的内部结构。
- en: Now, let's take a look at how to get everything up and running.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何让一切运行起来。
- en: Getting started
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习
- en: All of the code in this book is targeted for **OpenCV 4.2** and has been tested
    on **Ubuntu 18.04**. Throughout this book, we will make extensive use of the `NumPy`
    package ([http://www.numpy.org](http://www.numpy.org)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有代码都是针对**OpenCV 4.2**编写的，并在**Ubuntu 18.04**上进行了测试。在整个本书中，我们将广泛使用`NumPy`包([http://www.numpy.org](http://www.numpy.org))。
- en: Additionally, this chapter requires the `UnivariateSpline` module of the `SciPy`
    package ([http://www.scipy.org](http://www.scipy.org)) and the **wxPython 4.0**
    **Graphical User Interface** (**GUI**) ([http://www.wxpython.org/download.php](http://www.wxpython.org/download.php))
    for cross-platform GUI applications. We will try to avoid further dependencies
    where possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还需要`SciPy`包的`UnivariateSpline`模块([http://www.scipy.org](http://www.scipy.org))和**wxPython
    4.0** **图形用户界面** (**GUI**) ([http://www.wxpython.org/download.php](http://www.wxpython.org/download.php))用于跨平台GUI应用程序。我们将尽可能避免进一步的依赖。
- en: For more book-level dependencies, see [Appendix A](a4f1f102-9f62-4644-bcde-f478cd28621a.xhtml),
    *Profiling and Accelerating Your Apps*, and [Appendix B](c86bca68-4b4a-4be6-8edd-67b1d43f0bfa.xhtml),
    *Setting Up a Docker Container*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多书籍级别的依赖项，请参阅附录A *分析和加速您的应用程序*（[Appendix A](a4f1f102-9f62-4644-bcde-f478cd28621a.xhtml)）和附录B
    *设置Docker容器*（[Appendix B](c86bca68-4b4a-4be6-8edd-67b1d43f0bfa.xhtml)）。
- en: 'You can find the code that we present in this chapter at our GitHub repository
    here: [https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter1](https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter1).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub仓库中找到本章中展示的代码：[https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter1](https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter1)。
- en: Let's begin by planning the application we are going to create in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从规划本章将要创建的应用程序开始。
- en: Planning the app
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划应用程序
- en: 'The final app must consist of the following modules and scripts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的应用程序必须包含以下模块和脚本：
- en: '`wx_gui.py`: This module is our implementation of a basic GUI using `wxpython`.
    We will make extensive use of this file throughout the book. This module includes
    the following layouts:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx_gui.py`: 这个模块是我们使用 `wxpython` 实现的基本GUI，我们将在整本书中广泛使用这个文件。此模块包括以下布局：'
- en: '`wx_gui.BaseLayout`: This is a generic layout class from which more complicated
    layouts can be built.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx_gui.BaseLayout`: 这是一个通用布局类，可以从中构建更复杂的布局。'
- en: '`chapter1.py`: This is the main script for this chapter. It contains the following
    functions and classes:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter1.py`: 这是本章的主要脚本。它包含以下函数和类：'
- en: '`chapter1.FilterLayout`: This is a custom layout based on `wx_gui.BaseLayout`,
    which displays the camera feed and a row of radio buttons that allows the user
    to select from the available image filters to be applied to each frame of the
    camera feed.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter1.FilterLayout`: 这是一个基于 `wx_gui.BaseLayout` 的自定义布局，它显示摄像头视频流和一排单选按钮，用户可以通过这些按钮从可用的图像过滤器中选择要应用于摄像头视频流每一帧的过滤器。'
- en: '`chapter1.main`: This is the main routine function for starting the GUI application
    and accessing the webcam.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter1.main`: 这是启动GUI应用程序和访问摄像头的主体函数。'
- en: '`tools.py`: This is a Python module and has a lot of helper functions that
    we use in this chapter, which you can reuse for your projects.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tools.py`: 这是一个Python模块，包含我们在本章中使用的许多辅助函数，您也可以将其用于您的项目。'
- en: The next section demonstrates how to create a black-and-white pencil sketch.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将演示如何创建黑白铅笔素描。
- en: Creating a black-and-white pencil sketch
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建黑白铅笔素描
- en: In order to obtain a pencil sketch (that is, a black-and-white drawing) of the
    camera frame, we will make use of two image-blending techniques, known as **dodging**
    and **burning**. These terms refer to techniques employed during the printing
    process in traditional photography; here, photographers would manipulate the exposure
    time of a certain area of a darkroom print in order to lighten or darken it. Dodging
    *lightens* an image, whereas burning *darkens* it. Areas that were not supposed
    to undergo changes were protected with a **mask**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得摄像头帧的铅笔素描（即黑白绘画），我们将使用两种图像混合技术，称为 ** dodging** 和 **burning**。这些术语指的是在传统摄影打印过程中采用的技术；在这里，摄影师会操纵暗室打印的某个区域的曝光时间，以使其变亮或变暗。Dodging
    *使图像变亮*，而burning *使图像变暗*。未打算发生变化的区域使用 **mask** 进行保护。
- en: Today, modern image editing programs, such as **Photoshop** and **Gimp**, offer
    ways to mimic these effects in digital images. For example, masks are still used
    to mimic the effect of changing the exposure time of an image, wherein areas of
    a mask with relatively intense values will *expose* the image more, thus lightening
    the image. OpenCV does not offer a native function to implement these techniques;
    however, with a little insight and a few tricks, we will arrive at our own efficient
    implementation that can be used to produce a beautiful pencil sketch effect.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，现代图像编辑程序，如 **Photoshop** 和 **Gimp**，提供了在数字图像中模仿这些效果的方法。例如，蒙版仍然用于模仿改变图像曝光时间的效果，其中蒙版中相对强烈的值会
    *曝光* 图像，从而使图像变亮。OpenCV没有提供原生的函数来实现这些技术；然而，通过一点洞察力和几个技巧，我们将达到我们自己的高效实现，可用于产生美丽的铅笔素描效果。
- en: 'If you search on the internet, you might stumble upon the following common
    procedure to achieve a pencil sketch from an **RGB** (**red**, **green**, and
    **blue**) color image:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在网上搜索，可能会遇到以下常见程序，用于从 **RGB**（**红色**、**绿色**和**蓝色**）彩色图像中实现铅笔素描：
- en: First, convert the color image to grayscale.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将彩色图像转换为灰度图像。
- en: Then, invert the grayscale image to get a negative.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将灰度图像反转以得到负片。
- en: Apply a **Gaussian blur** to the negative from *step 2*.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对步骤 2 中的负片应用 **高斯模糊**。
- en: Blend the grayscale image (from *step 1*) with the blurred negative (from *step
    3*) by using **color dodge**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **颜色 dodging** 将步骤 1 中的灰度图像与步骤 3 中的模糊负片混合。
- en: Whereas *steps 1* to *3* are straightforward, *step 4* can be a little tricky.
    Let's get that one out of the way first.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *步骤 1* 到 *3* 很直接，但 *步骤 4* 可能有点棘手。让我们首先解决这个难题。
- en: OpenCV 3 came with a pencil sketch effect right out of the box. The `cv2.pencilSketch`
    function uses a domain filter introduced in the 2011 paper, *Domain Transform
    for Edge-Aware Image and Video Processing*, by Eduardo Gastal and Manuel Oliveira.
    However, for the purposes of this book, we will develop our own filter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 3 直接提供了铅笔素描效果。`cv2.pencilSketch` 函数使用了 2011 年论文中引入的领域滤波器，该论文为 *Domain
    Transform for Edge-Aware Image and Video Processing*，作者是 Eduardo Gastal 和 Manuel
    Oliveira。然而，为了本书的目的，我们将开发自己的滤波器。
- en: The next section shows you how to implement dodging and burning in OpenCV.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将向您展示如何在 OpenCV 中实现 dodging 和 burning。
- en: Understanding approaches for using dodging and burning techniques
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用 dodging 和 burning 技术的方法
- en: Dodging decreases the exposure for areas of the image that we wish to make lighter
    (than before) in an image, `A`. In image processing, we usually select or specify
    areas of the image that need to be altered using masks. A mask, `B`, is an array
    of the same dimensions as the image on which it can be applied (think of it as
    a sheet of paper you use to cover the image that has holes in it). "Holes" in
    the sheet of paper are represented with `255` (or ones if we are working on the
    0-1 range) in an opaque region with zeros.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Dodging 减少了图像中我们希望变亮（相对于之前）的区域的曝光度，`A`。在图像处理中，我们通常使用蒙版选择或指定需要更改的图像区域。蒙版 `B`
    是一个与图像相同维度的数组，可以在其上应用（将其想象成一张带有孔的纸，用于覆盖图像）。纸张上的“孔”用 `255`（或如果我们工作在 0-1 范围内则为 1）表示，在不透明的区域用零表示。
- en: 'In modern image editing tools, such as Photoshop, the color dodging of the
    image `A` with the mask `B` is implemented by using the following ternary statement
    that acts on every pixel using the index `i`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代图像编辑工具中，例如 Photoshop，图像 `A` 与蒙版 `B` 的颜色 dodging 是通过以下三元语句实现的，该语句对每个像素使用索引
    `i` 进行操作：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous code essentially divides the value of the `A[i]` image pixel by
    the inverse of the `B[i]` mask pixel value (which are in the range of `0`-`255`),
    while making sure that the resulting pixel value will be in the range of (0, 255)
    and that we do not divide by 0.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码本质上是将 `A[i]` 图像像素的值除以 `B[i]` 蒙版像素值的倒数（这些值在 `0`-`255` 范围内），同时确保结果像素值在 (0,
    255) 范围内，并且我们不会除以 0。
- en: 'We could translate the previous complex-looking expression or code into the
    following naive Python function, which accepts two OpenCV matrices (`image` and
    `mask`) and returns the blended image:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将之前看起来复杂的表达式或代码翻译成以下简单的 Python 函数，该函数接受两个 OpenCV 矩阵（`image` 和 `mask`）并返回混合图像：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you might have guessed, although the previous code might be functionally
    correct, it will undoubtedly be horrendously slow. Firstly, the function uses
    the `for` loops, which are almost always a bad idea in Python. Secondly, the NumPy
    arrays (the underlying format of OpenCV images in Python) are optimized for the
    array calculations, so accessing and modifying each `image[c, r]` pixel separately
    will be really slow.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，尽管之前的代码可能在功能上是正确的，但它无疑会非常慢。首先，该函数使用了 `for` 循环，这在 Python 中几乎总是不是一个好主意。其次，NumPy
    数组（Python 中 OpenCV 图像的底层格式）针对数组计算进行了优化，因此单独访问和修改每个 `image[c, r]` 像素将会非常慢。
- en: 'Instead, we should realize that the `<<8` operation is the same as multiplying
    the pixel value with the number **2⁸** (**=256**), and that pixel-wise division
    can be achieved with the `cv2.divide` function. Thus, an improved version of our
    `dodge` function that takes advantage of matrix multiplication (which is faster)
    looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该意识到 `<<8` 操作与将像素值乘以数字 **2⁸**（**=256**）相同，并且可以使用 `cv2.divide` 函数实现像素级的除法。因此，我们的
    `dodge` 函数的改进版本利用了矩阵乘法（这更快），看起来如下：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have reduced the `dodge` function to a single line! The new `dodge`
    function produces the same result as `dodge_naive`, but it is orders of magnitude
    faster than the naive version. In addition to this, `cv2.divide` automatically
    takes care of the division by zero, making the result zero, where `255 - mask`
    is zero.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`dodge`函数简化为单行！新的`dodge`函数产生的结果与`dodge_naive`相同，但比原始版本快得多。此外，`cv2.divide`会自动处理除以零的情况，当`255
    - mask`为零时，结果为零。
- en: 'Here is a dodged version of `Lena.png` where we have dodges in the square with
    pixels in the range of (100:300, 100:300**)**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Lena.png`的一个 dodged 版本，其中我们在像素范围（100:300, 100:300**）**的方块中进行了 dodging：
- en: '![](img/12387677-69ad-460a-9cc9-b339d74f9acd.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12387677-69ad-460a-9cc9-b339d74f9acd.png)'
- en: Image credit—"Lenna" by Conor Lawless is licensed under CC BY 2.0
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源——“Lenna”由Conor Lawless提供，许可协议为CC BY 2.0
- en: As you can see, the lightened region is very obvious in the right photograph
    because the transition is very sharp. There are ways to correct this, one of which
    we will take a look at in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在右侧的照片中，亮化区域非常明显，因为过渡非常尖锐。有方法可以纠正这一点，我们将在下一节中探讨其中一种方法。
- en: Let's learn how to obtain a Gaussian blur by using two-dimensional convolution
    next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用二维卷积来获得高斯模糊。
- en: Implementing a Gaussian blur with two-dimensional convolution
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二维卷积实现高斯模糊
- en: A Gaussian blur is implemented by convolving the image with a kernel of Gaussian
    values. Two- dimensional convolution is something that is used very widely in
    image processing. Usually, we have a big picture (let's look at a 5 x 5 subsection
    of that particular image), and we have a kernel (or filter) that is another matrix
    of a smaller size (in our example, 3 x 3).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯模糊是通过用高斯值核卷积图像来实现的。二维卷积在图像处理中应用非常广泛。通常，我们有一个大图片（让我们看看该特定图像的5 x 5子区域），我们有一个核（或过滤器），它是一个更小的矩阵（在我们的例子中，3
    x 3）。
- en: In order to get the convolution values, let's suppose that we want to get the
    value at *location (2, 3)*. We place the kernel centered at the *location* (*2*,
    *3*), and we calculate the pointwise product of the overlay matrix (highlighted
    area, in the following image (red color)) with the kernel and take the overall
    sum. The resulting value (that is, 158.4) is the value we write on the other matrix
    at the *location (2, 3)*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取卷积值，假设我们想要获取位置（2, 3）的值。我们将核中心放在位置（2, 3），并计算叠加矩阵（以下图像中的高亮区域，红色）与核的点积，并取总和。得到的值（即158.4）是我们写在另一个矩阵位置（2,
    3）的值。
- en: 'We repeat this process for all elements, and the resulting matrix (the matrix
    on the right) is the convolution of the kernel with the image. In the following
    diagram, on the left, you can see the original image with the pixel values in
    the boxes (values higher than 100). We also see an orange filter with values in
    the bottom right of each cell (a collection of 0.1 or 0.2 that sum to 1). In the
    matrix on the right, you see the values when the filter is applied to the image
    on the left:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对所有的元素重复这个过程，得到的矩阵（右侧的矩阵）是核与图像的卷积。在下面的图中，左侧可以看到带有像素值的原始图像（值高于100）。我们还看到一个橙色过滤器，每个单元格的右下角有值（0.1或0.2的集合，总和为1）。在右侧的矩阵中，您可以看到当过滤器应用于左侧图像时得到的值：
- en: '![](img/658345ff-7977-4546-94d7-559959cbcdb2.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/658345ff-7977-4546-94d7-559959cbcdb2.png)'
- en: Note that, for points on the boundaries, the kernel is not aligned with the
    matrix, so we have to figure out a strategy to give values for those points. There
    is no single good strategy that works for everything; some of the approaches are
    to either extend the border with zeros or extend with border values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于边界上的点，核与矩阵不对齐，因此我们必须想出一个策略来为这些点赋值。没有一种适用于所有情况的单一良好策略；一些方法是将边界扩展为零，或者使用边界值进行扩展。
- en: Let's take a look at how to transform a normal picture into a pencil sketch.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将普通图片转换为铅笔素描。
- en: Applying pencil sketch transformation
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用铅笔素描转换
- en: With the tricks that we learned from the previous sections in our bag, we are
    now ready to take a look at the entire procedure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从上一节学到了一些技巧，现在我们可以准备查看整个流程了。
- en: The final code can be found in the `convert_to_pencil_sketch` function within
    the `tools.py` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码可以在`tools.py`文件中的`convert_to_pencil_sketch`函数中找到。
- en: 'The following procedure shows you how to convert a color image into grayscale.
    After that, we aim to blend the grayscale image with its blurred negative:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程展示了如何将彩色图像转换为灰度图。之后，我们旨在将灰度图像与其模糊的负图像混合：
- en: 'First, we convert an RGB image (`imgRGB`) into grayscale:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将 RGB 图像 (`imgRGB`) 转换为灰度图：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we have used `cv2.COLOR_RGB2GRAY` as a parameter to the `cv2.cvtColor`
    function, which changes the color spaces. Note that it does not matter whether
    the input image is RGB or BGR (which is the default for OpenCV); we will get a
    nice grayscale image in the end.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已将 `cv2.COLOR_RGB2GRAY` 作为 `cv2.cvtColor` 函数的参数，这改变了颜色空间。请注意，输入图像是 RGB
    还是 BGR（OpenCV 的默认设置）并不重要；最终我们都会得到一个漂亮的灰度图像。
- en: 'Then, we invert the image and blur it with a large Gaussian kernel of size
    `(21,21)`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用大小为 `(21,21)` 的大高斯核对图像进行反转和模糊处理：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We use `dodge` to blend the original grayscale image with the blurred inverse:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `dodge` 将原始灰度图像与模糊的逆变换混合：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The resulting image looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图像看起来是这样的：
- en: '![](img/edd66dc7-744c-4e1e-80ef-facc5258db11.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edd66dc7-744c-4e1e-80ef-facc5258db11.png)'
- en: Image credit—"Lenna" by Conor Lawless is licensed under CC BY 2.0
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源——“Lenna”由 Conor Lawless 提供，授权协议为 CC BY 2.0
- en: Did you notice that our code can be optimized further? Let's take a look at
    how to optimize with OpenCV next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们的代码还可以进一步优化吗？让我们看看如何使用 OpenCV 进行优化。
- en: Using an optimized version of a Gaussian blur
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高斯模糊的优化版本
- en: A Gaussian blur is basically a convolution with a Gaussian function. Well, one
    of the features of convolutions is their associative property. This means that
    it does not matter whether we first invert the image and then blur it, or first
    blur the image and then invert it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯模糊基本上是一个与高斯函数的卷积。嗯，卷积的一个特性是它们的结合性质。这意味着我们首先反转图像然后模糊，还是先模糊图像然后反转，并不重要。
- en: 'If we start with a blurred image and pass its inverse to the `dodge` function,
    then within that function the image will be inverted again (the `255-mask` part),
    essentially yielding the original image. If we get rid of these redundant operations,
    the optimized `convert_to_pencil_sketch` function will look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从模糊的图像开始，并将其逆变换传递给 `dodge` 函数，那么在该函数内部图像将被再次反转（`255-mask` 部分），本质上得到原始图像。如果我们去掉这些冗余操作，优化的
    `convert_to_pencil_sketch` 函数将看起来像这样：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For kicks and giggles, we want to lightly blend our transformed image (`img_sketch`)
    with a background image (`canvas`) that makes it look as though we drew the image
    on a canvas. So, before returning, we would like to blend with `canvas` if it
    exists:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增添乐趣，我们想要将我们的变换图像 (`img_sketch`) 轻轻地与背景图像 (`canvas`) 混合，使其看起来像是在画布上绘制的。因此，在返回之前，我们希望如果存在
    `canvas`，则与 `canvas` 混合：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We name our final function `pencil_sketch_on_canvas`, and it looks like this
    (together with optimizations):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最终的函数命名为 `pencil_sketch_on_canvas`，它看起来是这样的（包括优化）：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is just our `convert_to_pencil_sketch` function, with the optional `canvas`
    argument that can add an artistic touch to the pencil sketch.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们的 `convert_to_pencil_sketch` 函数，它有一个可选的 `canvas` 参数，可以为铅笔素描添加艺术感。
- en: 'And we''re done! The final output looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！最终的输出看起来是这样的：
- en: '![](img/719a8a97-3961-4214-b22e-17abd4c22c02.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/719a8a97-3961-4214-b22e-17abd4c22c02.png)'
- en: Let's take a look at how to generate a warming and cooling filter in the next
    section, where you'll learn how to use **lookup tables** for image manipulation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在下一节中生成暖色和冷色滤镜，你将学习如何使用 **查找表** 进行图像处理。
- en: Generating a warming and cooling filter
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成暖色和冷色滤镜
- en: When we perceive images, our brain picks up on a number of subtle clues to infer
    important details about the scene. For example, in broad daylight, highlights
    may have a slightly yellowish tint because they are in direct sunlight, whereas
    shadows may appear slightly bluish because of the ambient light of the blue sky.
    When we view an image with such color properties, we might immediately think of
    a sunny day.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们感知图像时，大脑会捕捉到许多细微的线索来推断场景的重要细节。例如，在晴朗的白天，高光可能带有轻微的黄色调，因为它们处于直射阳光下，而阴影可能因为蓝色天空的环境光而显得略带蓝色。当我们看到具有这种颜色特性的图像时，我们可能会立刻想到一个晴朗的日子。
- en: This effect is not a mystery to photographers, who sometimes purposely manipulate
    the white balance of an image to convey a certain mood. Warm colors are generally
    perceived as more pleasant, whereas cool colors are associated with night and
    drabness.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果对摄影师来说并不神秘，他们有时会故意操纵图像的白平衡来传达某种情绪。暖色通常被认为更愉快，而冷色则与夜晚和单调联系在一起。
- en: To manipulate the perceived color temperature of an image, we will implement
    a curve filter. These filters control how color transitions appear between different
    regions of an image, allowing us to subtly shift the color spectrum without adding
    an unnatural-looking overall tint to the image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操纵图像的感知色温，我们将实现一个曲线过滤器。这些过滤器控制颜色在不同图像区域之间的过渡，使我们能够微妙地改变色谱，而不会给图像添加看起来不自然的整体色调。
- en: In the next section, we'll look at how to manipulate color using curve shifting.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何通过曲线平移来操纵颜色。
- en: Using color manipulation via curve shifting
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过曲线平移进行颜色操纵
- en: 'A curve filter is essentially a function, ***y = f (x)***, that maps an input
    pixel value, *x*, to an output pixel value, *y*. The curve is parameterized by
    a set of ***n + 1*** anchor points, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线过滤器本质上是一个函数，***y = f (x)***，它将输入像素值 *x* 映射到输出像素值 *y*。曲线由一组 ***n + 1*** 锚点参数化，如下所示：
- en: '![](img/2e3aa2ee-d206-42ee-bdeb-a0fc7aa27fb3.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e3aa2ee-d206-42ee-bdeb-a0fc7aa27fb3.png)'
- en: Here, each anchor point is a pair of numbers that represent the input and output
    pixel values. For example, the pair (30, 90) means that an input pixel value of
    30 is increased to an output value of 90\. Values between anchor points are interpolated
    along a smooth curve (hence, the name curve filter).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个锚点是一对代表输入和输出像素值的数字。例如，对(30, 90)的配对意味着输入像素值30增加到输出值90。锚点之间的值沿着一条平滑的曲线进行插值（因此得名曲线过滤器）。
- en: Such a filter can be applied to any image channel, be it a single grayscale
    channel or the **R** (**red**), **G** (**green**), and **B** (**blue**) channels
    of an RGB color image. Therefore, for our purposes, all values of *x* and *y*
    must stay between 0 and 255.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种过滤器可以应用于任何图像通道，无论是单个灰度通道还是RGB彩色图像的**R**（**红色**）、**G**（**绿色**）和**B**（**蓝色**）通道。因此，为了我们的目的，所有
    *x* 和 *y* 的值都必须保持在0到255之间。
- en: 'For example, if we wanted to make a grayscale image slightly brighter, we could
    use a curve filter with the following set of control points:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想使灰度图像稍微亮一些，我们可以使用以下控制点的曲线过滤器：
- en: '![](img/8b4f25f1-a4eb-491d-9e13-2fab7cf96333.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b4f25f1-a4eb-491d-9e13-2fab7cf96333.png)'
- en: This would mean that all input pixel values except **0** and **255** would be
    increased slightly, resulting in an overall brightening effect on the image.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着除了 **0** 和 **255** 以外的所有输入像素值都会略微增加，从而在图像上产生整体变亮的效果。
- en: 'If we want such filters to produce natural-looking images, it is important
    to respect the following two rules:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望这样的过滤器产生看起来自然的图像，那么遵守以下两条规则是很重要的：
- en: Every set of anchor points should include **(0,0)** and **(255,255)**. This
    is important in order to prevent the image from appearing as if it has an overall
    tint, as black remains black and white remains white.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每组锚点都应该包括 **(0,0)** 和 **(255,255)**。这对于防止图像看起来像有整体色调很重要，因为黑色仍然是黑色，白色仍然是白色。
- en: The *f(x)* function should be monotonously increasing. In other words, by increasing
    *x*, *f(x)* either stays the same or increases (that is, it never decreases).
    This is important for making sure that shadows remain shadows and highlights remain
    highlights.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f(x)* 函数应该是单调递增的。换句话说，通过增加 *x*，*f(x)* 要么保持不变，要么增加（即，它永远不会减少）。这对于确保阴影仍然是阴影，高光仍然是高光非常重要。'
- en: The next section demonstrates how to implement a curve filter using lookup tables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将演示如何使用查找表实现曲线过滤器。
- en: Implementing a curve filter using lookup tables
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用查找表实现曲线过滤器
- en: Curve filters are computationally expensive because the values of *f(x)* must
    be interpolated whenever *x* does not coincide with one of the prespecified anchor
    points. Performing this computation for every pixel of every image frame that
    we encounter would have dramatic effects on performance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线过滤器计算成本较高，因为当 *x* 不与预指定的锚点之一相匹配时，必须对 *f(x)* 的值进行插值。对我们遇到的每个图像帧的每个像素执行此计算将对性能产生重大影响。
- en: 'Instead, we make use of a lookup table. Since there are only 256 possible pixel
    values for our purposes, we need to calculate ***f(x)*** only for all the 256
    possible values of ***x***. Interpolation is handled by the `UnivariateSpline`
    function of the `scipy.interpolate` module, as shown in the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用查找表。由于我们的目的是只有 256 个可能的像素值，因此我们只需要计算所有 256 个可能的 ***x*** 值的 ***f(x)***。插值由
    `scipy.interpolate` 模块的 `UnivariateSpline` 函数处理，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `return` argument of the function is a list of 256 elements that contains
    the interpolated *f(x)* values for every possible value of *x*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的 `return` 参数是一个包含每个可能的 *x* 值的插值 *f(x)* 值的 256 个元素的列表。
- en: 'All we need to do now is to come up with a set of anchor points, (*x[i]*, *y[i]*),
    and we are ready to apply the filter to a grayscale input image (`img_gray`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是提出一组锚点，(*x[i]*, *y[i]*)，然后我们就可以将过滤器应用于灰度输入图像（`img_gray`）：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result looks like this (the original image is on the *left*, and the transformed
    image is on the *right*):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样（原始图像在 *左* 边，转换后的图像在 *右* 边）：
- en: '![](img/9e47feb6-4d50-4fac-b177-981ba3253ca7.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e47feb6-4d50-4fac-b177-981ba3253ca7.png)'
- en: In the next section, we'll design the warming and cooling effect. You will also
    learn how to apply lookup tables to colored images, and how warming and cooling
    effects work.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将设计暖色和冷色效果。你还将学习如何将查找表应用于彩色图像，以及暖色和冷色效果是如何工作的。
- en: Designing the warming and cooling effect
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计暖色和冷色效果
- en: With the mechanism to quickly apply a generic curve filter to any image channel
    in place, we can now turn to the question of how to manipulate the perceived color
    temperature of an image. Again, the final code will have its own function in the
    `tools` module.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了快速将通用曲线过滤器应用于任何图像通道的机制，我们现在可以转向如何操纵图像感知色温的问题。再次强调，最终的代码将在 `tools` 模块中拥有自己的函数。
- en: If you have a minute to spare, I advise you to play around with the different
    curve settings for a while. You can choose any number of anchor points and apply
    the curve filter to any image channel you can think of (red, green, blue, hue,
    saturation, brightness, lightness, and so on). You could even combine multiple
    channels, or decrease one and shift another to the desired region. *What will
    the result look like?*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多余的一分钟时间，我建议你尝试不同的曲线设置一段时间。你可以选择任意数量的锚点，并将曲线过滤器应用于你想到的任何图像通道（红色、绿色、蓝色、色调、饱和度、亮度、明度等等）。你甚至可以将多个通道组合起来，或者降低一个并移动另一个到所需区域。*结果会是什么样子？*
- en: 'However, if the number of possibilities dazzles you, take a more conservative
    approach. First, by making use of our `spline_to_lookup_table` function developed
    in the preceding steps, let''s define two generic curve filters: one that (by
    trend) increases all the pixel values of a channel and one that generally decreases
    them:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果可能性让你眼花缭乱，请采取更保守的方法。首先，通过利用我们在前面步骤中开发的 `spline_to_lookup_table` 函数，让我们定义两个通用曲线过滤器：一个（按趋势）增加通道的所有像素值，另一个通常减少它们：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s examine how we could apply lookup tables to an RGB image. OpenCV
    has a nice function called `cv2.LUT` that takes a lookup table and applies it
    to a matrix. So, first, we have to decompose the image into different channels:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何将查找表应用于 RGB 图像。OpenCV 有一个名为 `cv2.LUT` 的不错函数，它接受一个查找表并将其应用于矩阵。因此，首先，我们必须将图像分解为不同的通道：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we apply a filter to each channel if desired:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果需要，我们可以对每个通道应用过滤器：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Doing this for all the three channels in an RGB image, we get the following
    helper function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对 RGB 图像中的所有三个通道都这样做，我们得到以下辅助函数：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The easiest way to make an image appear as if it was taken on a hot, sunny
    day (maybe close to sunset) is to increase the reds in the image and make the
    colors appear vivid by increasing the color saturation. We will achieve this in
    two steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要让图像看起来像是在炎热的阳光明媚的日子里拍摄的（可能接近日落），最简单的方法是增加图像中的红色，并通过增加颜色饱和度使颜色看起来更加鲜艳。我们将分两步实现这一点：
- en: 'Increase the pixel values in the **R channel** (from RGB image) and decrease
    the pixel values in the **B channel** of an RGB color image using `INCREASE_LOOKUP_TABLE`
    and `DECREASE_LOOKUP_TABLE`, respectively:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `INCREASE_LOOKUP_TABLE` 和 `DECREASE_LOOKUP_TABLE` 分别增加 RGB 颜色图像中 **R 通道**（来自
    RGB 图像）的像素值，并减少 **B 通道**的像素值：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Transform the image into the **HSV** color space (**H** means **hue**, **S**
    means **saturation**, and **V** means **value**), and increase the **S channel**
    using `INCREASE_LOOKUP_TABLE`. This can be achieved with the following function,
    which expects an RGB color image and a lookup table to apply (similar to the `apply_rgb_filters`
    function) as input:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像转换为**HSV**颜色空间（**H**代表**色调**，**S**代表**饱和度**，**V**代表**亮度**），并使用`INCREASE_LOOKUP_TABLE`增加**S通道**。这可以通过以下函数实现，该函数期望一个RGB彩色图像和一个要应用的查找表（类似于`apply_rgb_filters`函数）作为输入：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '![](img/5c931305-7b18-4362-8a56-26647fa3c649.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c931305-7b18-4362-8a56-26647fa3c649.png)'
- en: 'Analogously, we can define a cooling filter that increases the pixel values
    in the B channel, decreases the pixel values in the R channel of an RGB image,
    converts the image into the HSV color space, and decreases color saturation via
    the S channel:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以定义一个冷却滤波器，该滤波器增加RGB图像中的B通道的像素值，减少R通道的像素值，将图像转换为HSV颜色空间，并通过S通道降低色彩饱和度：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now the result looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的结果看起来像这样：
- en: '![](img/e4683d58-a8b6-418d-b0eb-03c672dd4c87.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4683d58-a8b6-418d-b0eb-03c672dd4c87.png)'
- en: Let's explore how to cartoonize an image in the next section, where we'll learn
    what a bilateral filter is and much more.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中探讨如何卡通化图像，我们将学习双边滤波器是什么以及更多内容。
- en: Cartoonizing an image
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡通化图像
- en: Over the past few years, professional cartoonizer software has popped up all
    over the place. In order to achieve a basic cartoon effect, all we need is a **bilateral
    filter** and some **edge detection**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，专业的卡通化软件到处涌现。为了实现基本的卡通效果，我们只需要一个**双边滤波器**和一些**边缘检测**。
- en: The bilateral filter will reduce the color palette or the numbers of colors
    that are used in the image. This mimics a cartoon drawing, wherein a cartoonist
    typically has few colors to work with. Then, we can apply edge detection to the
    resulting image to generate bold silhouettes. The real challenge, however, lies
    in the computational cost of bilateral filters. We will, therefore, use some tricks
    to produce an acceptable cartoon effect in real time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 双边滤波器将减少图像的色彩调色板或使用的颜色数量。这模仿了卡通画，其中卡通画家通常只有很少的颜色可供选择。然后，我们可以对生成的图像应用边缘检测以生成醒目的轮廓。然而，真正的挑战在于双边滤波器的计算成本。因此，我们将使用一些技巧以实时产生可接受的卡通效果。
- en: 'We will adhere to the following procedure to transform an RGB color image into
    a cartoon:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循以下步骤将RGB彩色图像转换为卡通：
- en: First, apply a bilateral filter to reduce the color palette of the image.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，应用双边滤波器以减少图像的色彩调色板。
- en: Then, convert the original color image into grayscale.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将原始彩色图像转换为灰度图。
- en: After that, apply a **median blur** to reduce image noise.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，应用**中值滤波**以减少图像噪声。
- en: Use **adaptive thresholding** to detect and emphasize the edges in an edge mask.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**自适应阈值**在边缘掩码中检测和强调边缘。
- en: Finally, combine the color image from *step 1* with the edge mask from *step
    4*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将步骤1中的颜色图像与步骤4中的边缘掩码结合。
- en: In the upcoming sections, we will learn about the previously mentioned steps
    in detail. First, we'll learn how to use a bilateral filter for edge-aware smoothing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细介绍之前提到的步骤。首先，我们将学习如何使用双边滤波器进行边缘感知平滑。
- en: Using a bilateral filter for edge-aware smoothing
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用双边滤波器进行边缘感知平滑
- en: A strong bilateral filter is ideally suitable for converting an RGB image into
    a color painting or a cartoon, because it smoothens the flat regions while keeping
    the edges sharp. The only drawback of this filter is its computational cost—it
    is orders of magnitude slower than other smoothing operations, such as a Gaussian
    blur.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 强力的双边滤波器非常适合将RGB图像转换为彩色画或卡通，因为它在平滑平坦区域的同时保持边缘锐利。这个滤波器的唯一缺点是它的计算成本——它的速度比其他平滑操作（如高斯模糊）慢得多。
- en: 'The first measure to take when we need to reduce the computational cost is
    to perform an operation on an image of low resolution. In order to downscale an
    RGB image (`imgRGB`) to a quarter of its size (that is, reduce the width and height
    to half), we could use `cv2.resize`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要降低计算成本时，首先要采取的措施是对低分辨率图像进行操作。为了将RGB图像（`imgRGB`）的大小缩小到原来的四分之一（即宽度高度减半），我们可以使用`cv2.resize`：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A pixel value in the resized image will correspond to the pixel average of a
    small neighborhood in the original image. However, this process may produce image
    artifacts, which is also known as **aliasing**. While image aliasing is a big
    problem on its own, the negative effect might be enhanced by subsequent processing,
    for example, edge detection.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 调整大小后的图像中的像素值将对应于原始图像中一个小邻域的像素平均值。然而，这个过程可能会产生图像伪影，这也就是所说的**混叠**。虽然图像混叠本身就是一个大问题，但后续处理可能会增强其负面影响，例如边缘检测。
- en: 'A better alternative might be to use the **Gaussian pyramid** for downscaling
    (again to a quarter of the original size). The Gaussian pyramid consists of a
    blur operation that is performed before the image is resampled, which reduces
    any aliasing effects:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的选择可能是使用**高斯金字塔**进行下采样（再次减小到原始大小的四分之一）。高斯金字塔由在图像重采样之前执行的一个模糊操作组成，这减少了任何混叠效应：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, even at this scale, the bilateral filter might still be too slow to
    run in real time. Another trick is to repeatedly (say, five times) apply a small
    bilateral filter to the image instead of applying a large bilateral filter once:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在这个尺度上，双边滤波器可能仍然运行得太慢，无法实时处理。另一个技巧是反复（比如，五次）对图像应用一个小双边滤波器，而不是一次性应用一个大双边滤波器：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The three parameters in `cv2.bilateralFilter` control the diameter of the pixel
    neighborhood (`d=9`) and the standard deviation of the filter in the color space
    (`sigmaColor=9`) and coordinate space (`sigmaSpace=7`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv2.bilateralFilter`中的三个参数控制像素邻域的直径（`d=9`）、在颜色空间中的滤波器标准差（`sigmaColor=9`）和坐标空间中的标准差（`sigmaSpace=7`）。'
- en: 'So, the final code to run the bilateral filter that we use is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行我们使用的双边滤波器的最终代码如下：
- en: 'Downsample the image using multiple `pyrDown` calls:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个`pyrDown`调用对图像进行下采样：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, apply multiple bilateral filters:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，应用多个双边滤波器：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And finally, upsample it to the original size:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将其上采样到原始大小：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result looks like a blurred color painting of a creepy programmer, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像一幅模糊的彩色画，画的是一个令人毛骨悚然的程序员，如下所示：
- en: '![](img/96cbe5b4-6504-43aa-9795-00cd3cd0caaa.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96cbe5b4-6504-43aa-9795-00cd3cd0caaa.png)'
- en: The next section shows you how to detect and emphasize prominent edges.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将向您展示如何检测和强调突出边缘。
- en: Detecting and emphasizing prominent edges
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和强调突出边缘
- en: Again, when it comes to edge detection, the challenge often does not lie in
    how the underlying algorithm works, but instead lies in which particular algorithm
    to choose for the task at hand. You might already be familiar with a variety of
    edge detectors. For example, **Canny edge detection** (`cv2.Canny`) provides a
    relatively simple and effective method to detect edges in an image, but it is
    susceptible to noise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当涉及到边缘检测时，挑战通常不在于底层算法的工作方式，而在于选择哪种特定的算法来完成手头的任务。您可能已经熟悉各种边缘检测器。例如，**Canny边缘检测**（`cv2.Canny`）提供了一种相对简单且有效的方法来检测图像中的边缘，但它容易受到噪声的影响。
- en: The **Sobel** operator (`cv2.Sobel`) can reduce such artifacts, but it is not
    rotationally symmetric. The **Scharr** operator (`cv2.Scharr`) was targeted at
    correcting this but only looks at the first image derivative. If you are interested,
    there are even more operators for you, such as the **Laplacian ridge operator**
    (which includes the second derivative), but they are far more complex. And in
    the end, for our specific purposes, they might not look better, perhaps because
    they are as susceptible to lighting conditions as any other algorithm.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sobel算子**（`cv2.Sobel`）可以减少这种伪影，但它不是旋转对称的。**Scharr算子**（`cv2.Scharr`）旨在纠正这一点，但它只查看第一图像导数。如果您感兴趣，还有更多算子供您选择，例如**Laplacian脊算子**（它包括二阶导数），但它们要复杂得多。最后，对于我们的特定目的，它们可能看起来并不更好，也许是因为它们像任何其他算法一样容易受到光照条件的影响。'
- en: For the purposes of this project, we will choose a function that might not even
    be associated with conventional edge detection—`cv2.adaptiveThreshold`. Like `cv2.threshold`,
    this function uses a threshold pixel value to convert a grayscale image into a
    binary image. That is, if a pixel value in the original image is above the threshold,
    then the pixel value in the final image will be 255\. Otherwise, it will be 0.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将选择一个可能甚至与传统的边缘检测无关的函数——`cv2.adaptiveThreshold`。像`cv2.threshold`一样，这个函数使用一个阈值像素值将灰度图像转换为二值图像。也就是说，如果原始图像中的像素值高于阈值，则最终图像中的像素值将是255。否则，它将是0。
- en: However, the beauty of adaptive thresholding is that it does not look at the
    overall properties of the image. Instead, it detects the most salient features
    in each small neighborhood independently, without regard to the global image characteristics.
    This makes the algorithm extremely robust to lighting conditions, which is exactly
    what we want when we seek to draw bold black outlines around objects, and people
    in a cartoon.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自适应阈值的美妙之处在于它不会查看图像的整体属性。相反，它独立地检测每个小邻域中最显著的特征，而不考虑全局图像特征。这使得算法对光照条件极为鲁棒，这正是我们在寻求在物体和卡通中的人物周围绘制醒目的黑色轮廓时所希望的。
- en: 'However, it also makes the algorithm susceptible to noise. To counteract this,
    we will preprocess the image with a median filter. A median filter does what its
    name suggests: it replaces each pixel value with the median value of all the pixels
    in a small pixel neighborhood. Therefore, to detect edges, we follow this short
    procedure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也使得算法容易受到噪声的影响。为了对抗这一点，我们将使用中值滤波器对图像进行预处理。中值滤波器做的是它名字所暗示的：它将每个像素值替换为一个小像素邻域中所有像素的中值。因此，为了检测边缘，我们遵循以下简短程序：
- en: 'We first convert the RGB image (`rgb_image`) into grayscale (`img_gray`) and
    then apply a median blur with a seven-pixel local neighborhood:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将RGB图像（`rgb_image`）转换为灰度（`img_gray`），然后使用七像素局部邻域应用中值模糊：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After reducing the noise, it is now safe to detect and enhance the edges using
    adaptive thresholding. Even if there is some image noise left, the `cv2.ADAPTIVE_THRESH_MEAN_C`
    algorithm with `blockSize=9` will ensure that the threshold is applied to the
    mean of a 9 x 9 neighborhood minus `C=2`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在减少噪声后，现在可以安全地使用自适应阈值检测和增强边缘。即使有一些图像噪声残留，`cv2.ADAPTIVE_THRESH_MEAN_C`算法使用`blockSize=9`将确保阈值应用于9
    x 9邻域的均值减去`C=2`：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result of the adaptive thresholding looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应阈值的结果看起来像这样：
- en: '![](img/e3f8ac30-e43d-4040-a25d-2880426348d6.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3f8ac30-e43d-4040-a25d-2880426348d6.png)'
- en: Next, let's look at how to combine colors and outlines to produce a cartoon
    in the following section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在下一节中结合颜色和轮廓来制作卡通。
- en: Combining colors and outlines to produce a cartoon
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合颜色和轮廓制作卡通
- en: 'The last step is to combine the two previously achieved effects. Simply fuse
    the two effects together into a single image using `cv2.bitwise_and`. The complete
    function is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将之前实现的两种效果结合起来。只需使用`cv2.bitwise_and`将两种效果融合成单个图像。完整的函数如下：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result looks like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '![](img/087be866-ebdc-44ac-a391-a39305957070.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/087be866-ebdc-44ac-a391-a39305957070.png)'
- en: In the next section, we'll set up the main script and design a GUI application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将设置主脚本并设计一个GUI应用程序。
- en: Putting it all together
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: In the previous sections, we implemented a couple of nice filters that show
    how we can get nice effects with OpenCV. In this section, we want to build an
    interactive application that will allow you to apply these filters in real time
    to your laptop camera.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们实现了一些很好的过滤器，展示了我们如何使用OpenCV获得很好的效果。在本节中，我们想要构建一个交互式应用程序，允许您实时将这些过滤器应用到您的笔记本电脑摄像头。
- en: So, we need to write a **user interface** (**UI**) that will allow us to capture
    the camera stream and have some buttons so that you can select which filter you
    want to apply. We will start by setting up the camera capture with OpenCV. Then,
    we will build a nice interface around it using `wxPython`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要编写一个**用户界面**（**UI**），它将允许我们捕获相机流并有一些按钮，以便您可以选择要应用哪个过滤器。我们将首先使用OpenCV设置相机捕获。然后，我们将使用`wxPython`构建一个漂亮的界面。
- en: Running the app
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'To run the application, we will turn to the `chapter1.py` script. Follow these
    steps to do so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，我们将转向`chapter1.py`脚本。按照以下步骤操作：
- en: 'We first start by importing all the necessary modules:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先开始导入所有必要的模块：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will also have to import a generic GUI layout (from `wx_gui`) and all the
    designed image effects (from `tools`):'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须导入一个通用的GUI布局（来自`wx_gui`）和所有设计的图像效果（来自`tools`）：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'OpenCV provides a straightforward way to access a computer''s webcam or camera
    device. The following code snippet opens the default camera ID (`0`) of a computer
    using `cv2.VideoCapture`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV提供了一个简单的方法来访问计算机的摄像头或相机设备。以下代码片段使用`cv2.VideoCapture`打开计算机的默认摄像头ID（`0`）：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to give our application a fair chance to run in real time, we will
    limit the size of the video stream to `640` x `480` pixels:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给我们的应用程序一个公平的机会在实时运行，我们将限制视频流的大小为`640` x `480`像素：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, the `capture` stream can be passed to our GUI application, which is an
    instance of the `FilterLayout` class:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，可以将`capture`流传递给我们的GUI应用程序，该应用程序是`FilterLayout`类的一个实例：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After we create `FilterLayout`, we center the layout, so it appears in the center
    of the screen. And we call `Show()` to actually show the layout. Finally, we call
    `app.MainLoop()`, so the application starts working, receiving, and processing
    events.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`FilterLayout`之后，我们将居中布局，使其出现在屏幕中央。然后我们调用`Show()`来实际显示布局。最后，我们调用`app.MainLoop()`，这样应用程序就开始工作，接收和处理事件。
- en: The only thing left to do now is to design the said GUI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一要做的就是设计这个GUI。
- en: Mapping the GUI base class
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射GUI基类
- en: The `FilterLayout` GUI will be based on a generic, plain layout class called
    `BaseLayout`, which we will be able to use in subsequent chapters as well.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterLayout` GUI将基于一个通用的、简单的布局类，称为`BaseLayout`，我们将在后续章节中也能使用它。'
- en: The `BaseLayout` class is designed as an **abstract base class**. You can think
    of this class as a blueprint or recipe that will apply to all the layouts that
    we are yet to design, that is, a skeleton class that will serve as the backbone
    for all of our future GUI code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseLayout`类被设计为一个**抽象基类**。你可以将这个类视为一个蓝图或配方，它将适用于我们尚未设计的所有布局，即一个骨架类，它将作为我们所有未来GUI代码的骨干。'
- en: 'We start the file by importing the packages that we will use—the `wxPython`
    module, which we use to create the GUI; `numpy`, which we use to do matrix manipulations;
    and OpenCV (of course):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从导入我们将使用的包开始——用于创建GUI的`wxPython`模块、用于矩阵操作的`numpy`以及当然的OpenCV：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The class is designed to be derived from the blueprint or skeleton, that is,
    the `wx.Frame` class:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该类设计为从蓝图或骨架派生，即`wx.Frame`类：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Later on, when we write our own custom layout (`FilterLayout`), we will use
    the same notation to specify that the class is based on the `BaseLayout` blueprint
    (or skeleton) class, for example, in `class FilterLayout(BaseLayout):`. But for
    now, let's focus on the `BaseLayout` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后，当我们编写自己的自定义布局（`FilterLayout`）时，我们将使用相同的记法来指定该类基于`BaseLayout`蓝图（或骨架）类，例如，在`class
    FilterLayout(BaseLayout):`。但到目前为止，让我们专注于`BaseLayout`类。
- en: 'An abstract class has at least one abstract method. We are going to make the
    method abstract by ensuring that if the method stays unimplemented, the application
    will not run and we throw an exception:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类至少有一个抽象方法。我们将通过确保如果该方法未实现，应用程序将无法运行并抛出异常来使其方法抽象：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, any class that is derived from it, such as `FilterLayout`, must specify
    a full implementation of that method. This will allow us to create custom layouts,
    as you will see in a moment.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，任何从它派生的类，如`FilterLayout`，都必须指定该方法的完整实现。这将使我们能够创建自定义布局，正如你将在下一刻看到的那样。
- en: But first, let's proceed to the GUI constructor.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们继续到GUI构造函数。
- en: Understanding the GUI constructor
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GUI构造函数
- en: 'The `BaseLayout` constructor accepts an ID (`-1`), a title string (`''Fun with
    Filters''`), a video capture object, and an optional argument that specifies the
    number of frames per second. Then, the first thing to do in the constructor is
    to try to read a frame from the captured object in order to determine the image
    size:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseLayout`构造函数接受一个ID（`-1`）、一个标题字符串（`''Fun with Filters''`）、一个视频捕获对象和一个可选参数，该参数指定每秒的帧数。在构造函数中，首先要做的事情是尝试从捕获对象中读取一个帧，以确定图像大小：'
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will use the image size to prepare a buffer that will store each video frame
    as a bitmap and to set the size of the GUI. Because we want to display a bunch
    of control buttons below the current video frame, we set the height of the GUI
    to `self.imgHeight + 20`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用图像大小来准备一个缓冲区，该缓冲区将存储每个视频帧作为位图，并设置GUI的大小。因为我们想在当前视频帧下方显示一串控制按钮，所以我们把GUI的高度设置为`self.imgHeight
    + 20`：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the next section, we will build a basic layout for our application with a
    video stream and some buttons using `wxPython`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用`wxPython`构建一个包含视频流和一些按钮的基本布局。
- en: Learning about a basic GUI layout
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解基本的GUI布局
- en: 'The most basic layout consists of only a large black panel that provides enough
    room to display the video feed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的布局仅由一个足够大的黑色面板组成，可以提供足够的空间来显示视频流：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order for the layout to be extendable, we add it to a vertically arranged
    `wx.BoxSizer` object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使布局可扩展，我们将它添加到一个垂直排列的`wx.BoxSizer`对象中：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we specify an abstract method, `augment_layout`, for which we will not
    fill in any code. Instead, any user of our base class can make their own custom
    modifications to the basic layout:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定一个抽象方法`augment_layout`，我们将不会填写任何代码。相反，任何使用我们基类的用户都可以对基本布局进行自己的自定义修改：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we just need to set the minimum size of the resulting layout and center
    it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需设置结果的布局的最小尺寸并将其居中：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The next section shows you how to handle video streams.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将向您展示如何处理视频流。
- en: Handling video streams
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理视频流
- en: The video stream of the webcam is handled by a series of steps that begin with
    the `__init__` method. These steps might appear overly complicated at first, but
    they are necessary in order to allow the video to run smoothly, even at higher
    frame rates (that is, to counteract flickering).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 网络摄像头的视频流通过一系列步骤处理，这些步骤从`__init__`方法开始。这些步骤一开始可能看起来过于复杂，但它们是必要的，以便视频能够平滑运行，即使在更高的帧率下（也就是说，为了对抗闪烁）。
- en: 'The `wxPython` module works with events and callback methods. When a certain
    event is triggered, it can cause a certain class method to be executed (in other
    words, a method can *bind* to an event). We will use this mechanism to our advantage
    and display a new frame every so often using the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`wxPython`模块与事件和回调方法一起工作。当某个事件被触发时，它可以导致某个类方法被执行（换句话说，一个方法可以*绑定*到事件）。我们将利用这个机制，并使用以下步骤每隔一段时间显示一个新帧：'
- en: 'We create a timer that will generate a `wx.EVT_TIMER` event whenever `1000./self.fps`
    milliseconds have passed:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个定时器，每当`1000./self.fps`毫秒过去时，它就会生成一个`wx.EVT_TIMER`事件：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Whenever the timer is up, we want the `_on_next_frame` method to be called.
    It will try to acquire a new video frame:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当定时器结束时，我们希望调用`_on_next_frame`方法。它将尝试获取一个新的视频帧：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `_on_next_frame` method will process the new video frame and store the
    processed frame in a bitmap. This will trigger another event, `wx.EVT_PAINT`.
    We want to bind this event to the `_on_paint` method, which will paint the display
    of the new frame. So, we create a placeholder for the video and bind `wx.EVT_PAINT`
    to it:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_on_next_frame`方法将处理新的视频帧并将处理后的帧存储在位图中。这将触发另一个事件，`wx.EVT_PAINT`。我们希望将此事件绑定到`_on_paint`方法，该方法将绘制新帧的显示。因此，我们为视频创建一个占位符并将`wx.EVT_PAINT`绑定到它：'
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `_on_next_frame` method grabs a new frame and, once done, sends the frame
    to another method, `process_frame`, for further processing (which is an abstract
    method and should be implemented by the child class):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`_on_next_frame`方法获取一个新帧，完成后，将帧发送到另一个方法`process_frame`进行进一步处理（这是一个抽象方法，应由子类实现）：'
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The processed frame (`frame`) is then stored in a bitmap buffer (`self.bmp`).
    Calling `Refresh` triggers the aforementioned `wx.EVT_PAINT` event, which binds
    to `_on_paint`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 处理后的帧（`frame`）随后被存储在位图缓冲区（`self.bmp`）中。调用`Refresh`会触发上述的`wx.EVT_PAINT`事件，该事件绑定到`_on_paint`：
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `paint` method then grabs the frame from the buffer and displays it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`paint`方法随后从缓冲区获取帧并显示它：'
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The next section shows you how to create a custom filter layout.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将向您展示如何创建自定义过滤器布局。
- en: Drafting a custom filter layout
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计自定义过滤器布局
- en: 'Now we are almost done! If we want to use the `BaseLayout` class, we need to
    provide code for the two methods that were previously left blank, which are as
    follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎完成了！如果我们想使用`BaseLayout`类，我们需要为之前留空的两个方法提供代码，如下所示：
- en: '`augment_layout`: This is where we can make task-specific modifications to
    the GUI layout.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`augment_layout`：这是我们可以对GUI布局进行特定任务修改的地方。'
- en: '`process_frame`: This is where we perform task-specific processing on each
    captured frame of the camera feed.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process_frame`：这是我们对摄像头捕获的每一帧进行特定任务处理的地方。'
- en: 'We also need to change the constructor to initialize any parameters we will
    need—in this case, the canvas background for the pencil sketch:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改构造函数以初始化我们将需要的任何参数——在这种情况下，铅笔素描的画布背景：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To customize the layout, we arrange a number of radio buttons horizontally—one
    button per image effect mode. Here, the `style=wx.RB_GROUP` option makes sure
    that only one of `radio buttons` can be selected at a time. And to make these
    changes visible, `pnl` needs to be added to a list of existing panels—`self.panels_vertical`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义布局，我们水平排列一系列单选按钮——每个图像效果模式一个按钮。在这里，`style=wx.RB_GROUP`选项确保一次只能选择一个`单选按钮`。并且为了使这些更改可见，`pnl`需要添加到现有面板列表`self.panels_vertical`中：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The last method to be specified is `process_frame`. Recall that this method
    is triggered whenever a new camera frame is received. All that we need to do is
    pick the right image effect to be applied, which depends on the radio button configuration.
    We simply check which of the buttons is currently selected and call the corresponding
    `render` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要指定的方法是 `process_frame`。回想一下，每当接收到新的相机帧时，该方法就会被触发。我们所需做的就是选择要应用的正确图像效果，这取决于单选按钮的配置。我们只需检查哪个按钮当前被选中，并调用相应的
    `render` 方法：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And we''re done! The following screenshot shows us the output pictures with
    different filters:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！以下截图展示了使用不同滤镜的输出图片：
- en: '![](img/15078696-d7c1-48e3-a98f-b0a981674cbb.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15078696-d7c1-48e3-a98f-b0a981674cbb.png)'
- en: The preceding screenshot shows all of the four filters that we created applied
    to a single image.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图展示了我们将创建的四个滤镜应用于单个图像的效果。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored a number of interesting image processing effects.
    We used dodging and burning to create a black-and-white pencil sketch effect,
    explored lookup tables to arrive at an efficient implementation of curve filters,
    and got creative to produce a cartoon effect.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了许多有趣的图像处理效果。我们使用 dodge 和 burn 来创建黑白铅笔素描效果，通过查找表实现了曲线滤镜的高效实现，并发挥创意制作了卡通效果。
- en: One of the techniques used was two-dimesional convolution, which takes a filter
    and an image and creates a new image. In this chapter, we provided the filters
    to get the results we wanted, but we don't always have the filters that are necessary
    to produce the results we want. Recently, deep learning has emerged, which tries
    to learn the values for different filters to help it get the results it wants.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的一种技术是二维卷积，它将一个滤波器和一张图像结合，创建一个新的图像。在本章中，我们提供了获取所需结果的滤波器，但并不总是拥有产生所需结果所需的滤波器。最近，深度学习出现了，它试图学习不同滤波器的值，以帮助它获得所需的结果。
- en: In the next chapter, we will shift gears a bit and explore the use of depth
    sensors, such as **Microsoft Kinect 3D**, to recognize hand gestures in real time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将稍微改变方向，探索使用深度传感器，如 **Microsoft Kinect 3D**，来实时识别手势。
- en: Attributions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: '`Lenna.png`—the image of Lenna is available at [http://www.flickr.com/photos/15489034@N00/3388463896](http://www.flickr.com/photos/15489034@N00/3388463896)
    by Conor Lawless under the generic CC 2.0 attribution.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lenna.png`—Lenna 图片由 Conor Lawless 提供，可在 [http://www.flickr.com/photos/15489034@N00/3388463896](http://www.flickr.com/photos/15489034@N00/3388463896)
    找到，并遵循通用 CC 2.0 许可协议。'
