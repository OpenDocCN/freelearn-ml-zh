- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Calculus in R
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 中的微积分
- en: '**Calculus** is a branch of mathematics that studies the relationship between
    two quantities, connected via a function, from either a micro or a macro perspective.
    Taking a microscopic lens, such a relationship (often denoted by y = f(x)) manifests
    in the form of a very small change in the output y given an infinitesimal change
    in the input x. When switching to the macro perspective, the relationship becomes
    the cumulative change in y as x changes. The micro perspective corresponds to
    differential calculus, and the macro perspective corresponds to integral calculus,
    both introduced in this chapter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**微积分**是数学的一个分支，研究两个量之间的关系，这两个量通过一个函数连接，从微观或宏观的角度来看。从微观的角度来看，这种关系（通常表示为 y =
    f(x)）表现为输出 y 的一个非常小的变化，给定输入 x 的无穷小变化。当切换到宏观视角时，关系变为 y 随 x 变化的累积变化。微观视角对应于微分学，宏观视角对应于积分学，这两者都在本章中介绍。'
- en: By the end of this chapter, you will have grasped essential concepts in differential
    and integral calculus. Practical implementations in R will also be introduced
    to leverage R’s automatic differentiation and integration capabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中使用积分
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码和数据均可在[https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_9/working.R](https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_9/working.R)找到。
- en: Introducing calculus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微积分
- en: Working with calculus in R
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with integration in R
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 R 中使用微积分
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code in this chapter, you will need to have the latest version of
    the `mosaicCalc` package, which is 0.6.0 at the time of writing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用加法或减法等运算的基本数学相比，微积分应用函数和积分来研究变化率。在这里，变化率可以被视为速度，衡量 x 变化时 f(x) 的变化速度。这些变化也有一个方向，意味着当
    x 增加时，f(x) 是增加还是减少。
- en: All the code and data for this chapter is available at [https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_9/working.R](https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_9/working.R).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您需要拥有最新版本的 `mosaicCalc` 包，写作时为 0.6.0。
- en: Introducing calculus
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微积分
- en: 'Calculus is a branch of mathematics that studies the rate of change, such as
    the slope of a curve at any point. It is a fundamental subject widely used in
    many areas, including physics, economics, finance, optimization, **artificial
    intelligence** (**AI**), and more. Calculus was first developed by two gentlemen
    in the late 17th century: Gottfried Leibniz and Isaac Newton. Newton first developed
    calculus to analyze physical systems, while Leibniz independently developed the
    resulting notations we use today. Compared with basic math, which uses operations
    such as addition or subtraction, calculus applies functions and integrals to study
    the rate of change. Here, the rate of change can be regarded as the velocity,
    measuring how fast f(x) changes as x changes. Such changes also have a direction,
    meaning whether f(x) increases or decreases as x increases.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分是数学的一个分支，研究变化率，例如曲线在任何点的斜率。它是广泛应用于许多领域的一个基本学科，包括物理、经济学、金融、优化、**人工智能**（**AI**）等。微积分最初由两位先生在17世纪末开发：戈特弗里德·莱布尼茨和艾萨克·牛顿。牛顿首先发展微积分来分析物理系统，而莱布尼茨独立开发了我们今天使用的符号。
- en: Similarly, we can measure how fast the rate of change of f(x) changes as x changes.
    Such a measure is called acceleration, which assesses whether f(x) increases or
    decreases at an increasing or decreasing rate as x increases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以测量当 x 变化时，f(x) 的变化率如何变化。这样的度量称为加速度，它评估当 x 增加时，f(x) 是否以增加或减少的速率增加或减少。
- en: Differential and integral calculus
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到本章结束时，您将掌握微分和积分微积分的基本概念。还将介绍 R 的自动微分和积分功能在实际应用中的实现。
- en: The two main branches of calculus are **differential calculus** and **integral
    calculus**. Differential calculus studies the rate of change of a particular quantity.
    It examines the rate of change of slopes and curves and studies the sensitivity
    of an outcome variable y to a very small change in the input variable x. On the
    other hand, integral calculus studies the volume or **area under the** **curve**
    (**AUC**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分的两个主要分支是**微分微积分**和**积分微积分**。微分微积分研究特定量的变化率。它检查斜率和曲线的变化率，并研究结果变量y对输入变量x的微小变化的敏感性。另一方面，积分微积分研究体积或**曲线下的****面积**（**AUC**）。
- en: 'As shown in *Figure 9**.1*, we plotted a sample function y = f(x) and picked
    an arbitrary point at x = x 0\. We then added a very small change ∆ x to x 0\.
    This change is so small that it will tend toward 0 in the limit—that is, ∆ x →
    0\. Upon changing x, the dependent variable y will also change, generating a resulting
    change of ∆ y. Dividing these two terms gives an indication of the sensitivity
    of y with respect to x at the point x 0\. When ∆ x → 0, we call the sensitivity
    the derivative of y with respect to x when x = x 0\. Expressed mathematically,
    we have f ′ (x 0) =  ∆ y _ ∆ x as ∆ x → 0, or simply, f ′ (x 0) = lim ∆x→0  ∆
    y _ ∆ x:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图9**.1*所示，我们绘制了一个样本函数y = f(x)并在x = x 0处选择了一个任意点。然后我们向x 0添加了一个非常小的变化∆ x。这个变化如此之小，以至于在极限情况下会趋向于0——也就是说，∆
    x → 0。当x改变时，因变量y也会改变，产生一个结果变化∆ y。将这两个项相除给出了y在点x 0处相对于x的敏感性的指示。当∆ x → 0时，我们称这种敏感性为当x
    = x 0时y相对于x的导数。用数学表达式表示，我们有f ′ (x 0) = ∆ y / ∆ x，当∆ x → 0，或者简单地，f ′ (x 0) = lim(∆x→0)
    ∆ y / ∆ x：
- en: '![Figure 9.1 – A graph illustrating differential calculus that studies the
    rate of change at an arbitrary point](img/B18680_09_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 展示研究任意点变化率的微分微积分的图形](img/B18680_09_001.jpg)'
- en: Figure 9.1 – A graph illustrating differential calculus that studies the rate
    of change at an arbitrary point
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 展示研究任意点变化率的微分微积分的图形
- en: 'The rate of change at point x 0, or the sensitivity of the function y = f(x)
    at the point x = x 0, is expressed as f ′ (x 0) =  ∆ y _ ∆ x when ∆ x is infinitesimally
    small—that is, ∆ x → 0\. On the other hand, integral calculus indicates the AUC
    f(x) for a specific range x ∈ [a, b], as shown in *Figure 9**.2*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在点x 0处的变化率，或函数y = f(x)在点x = x 0处的敏感性，可以表示为f ′ (x 0) = ∆ y / ∆ x，当∆ x无限小的时候——也就是说，∆
    x → 0。另一方面，积分微积分表明特定范围x ∈ [a, b]的AUC f(x)，如图*图9**.2*所示：
- en: '![Figure 9.2 – A graph illustrating the integral calculus as the total AUC](img/B18680_09_002.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 展示积分微积分作为总AUC的图形](img/B18680_09_002.jpg)'
- en: Figure 9.2 – A graph illustrating the integral calculus as the total AUC
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 展示积分微积分作为总AUC的图形
- en: We denote the total area as a result of integration S = ∫ a b f(x)dx, which
    reports a positive quantity in this case. This means that the result of integration
    could also be negative, should the curve be below the *x* axis.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将积分的结果表示为S = ∫ a b f(x)dx，在这种情况下报告一个正量。这意味着积分的结果也可以是负的，如果曲线位于*x*轴下方。
- en: More on functions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于函数的内容
- en: 'Note that a function is a mapping machine between two sets of elements. For
    each element in the input set, there is one and only one corresponding element
    in the output set. The collection of all possible elements in the input set is
    called the domain, and the collection of all corresponding elements in the output
    set is called the range. *Figure 9**.3* shows four different mapping scenarios.
    The first three are valid mappings based on the definition of a function, while
    the last one fails due to the one-to-many mapping relationship:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数是两个元素集合之间的映射机器。对于输入集中的每个元素，输出集中只有一个对应的元素。输入集中所有可能元素的集合称为定义域，所有对应元素的集合称为值域。*图9**.3*显示了四种不同的映射场景。前三个是根据函数的定义有效的映射，而最后一个由于一对一多映射关系而失败：
- en: '![Figure 9.3 – Four different mapping scenarios](img/B18680_09_003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 四种不同的映射场景](img/B18680_09_003.jpg)'
- en: Figure 9.3 – Four different mapping scenarios
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 四种不同的映射场景
- en: The first three mappings are valid functions, while the last one is invalid
    due to one-to-many mapping in the last element (3->6 and 3->2).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个映射是有效的函数，而最后一个由于最后一个元素中的一对多映射（3->6和3->2）而无效。
- en: 'There are multiple names we often use for a function y = f(x) = x 2, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数y = f(x) = x 2，我们经常使用多个名称，如下所示：
- en: The variable x can be called an **independent variable**, a **feature**, a **covariate**,
    or an **input**.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量x可以称为**自变量**、**特征**、**协变量**或**输入**。
- en: The variable y can be called a **dependent variable**, an **outcome**, a **target**,
    a **response**, or an **output**.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量y可以称为**因变量**、**结果**、**目标**、**响应**或**输出**。
- en: The mapping function f(x) = x 2 can be called a **function**, a **mapping**,
    a **projection**, or a **hypothesis**.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射函数f(x) = x^2可以称为**函数**、**映射**、**投影**或**假设**。
- en: '*Figure 9**.4* summarizes these terms and provides a collection of input-output
    samples with the corresponding graph. Note that the input can be any number or
    expressed as a general variable:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.4*总结了这些术语，并提供了一组输入-输出样本及其相应的图形。注意，输入可以是任何数字或表示为一般变量：'
- en: '![Figure 9.4 – Illustrating a sample mapping function of ​y = f​(x)​ = ​x​​ 2​​](img/B18680_09_004.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 示例映射函数y = f(x) = x^2](img/B18680_09_004.jpg)'
- en: Figure 9.4 – Illustrating a sample mapping function of y = f(x) = x 2
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 示例映射函数y = f(x) = x^2
- en: Vertical line test
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直线测试
- en: 'One technique to assess whether a mapping or a curve is a function or not is
    the vertical line test. In particular, any vertical line in the plane can intersect
    the graph of a function at most once. That is, for any function f : A → B, each
    element x ∈ A is mapped to at most one value f(x) ∈ B. *Figure 9**.5* illustrates
    two curves, where the first curve intersects with the vertical line only once
    and thus is a valid function, while the second curve intersects with the vertical
    line twice, thus not satisfying the definition of a function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '评估一个映射或曲线是否为函数的一种技术是垂直线测试。特别是，平面上的任何垂直线最多只能与一个函数的图形相交一次。也就是说，对于任何函数f : A →
    B，每个元素x ∈ A最多映射到B中的一个值f(x) ∈ B。*图9**.5*说明了两个曲线，其中第一个曲线只与垂直线相交一次，因此是一个有效的函数，而第二个曲线与垂直线相交两次，因此不满足函数的定义：'
- en: '![Figure 9.5 – Assessing whether a curve is a function using the vertical line
    test](img/B18680_09_005.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 使用垂直线测试评估曲线是否为函数](img/B18680_09_005.jpg)'
- en: Figure 9.5 – Assessing whether a curve is a function using the vertical line
    test
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 使用垂直线测试评估曲线是否为函数
- en: Functional symmetry
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对称性
- en: There are many special properties a function could have, and functional symmetry
    is one property. For example, a function is called an even function if f(x) =
    f(− x), such as f(x) = |x|, f(x) = x 2, and f(x) = cos(x). A function is called
    an odd function if f(− x) = − f(x), such as f(x) = x 3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能具有许多特殊性质，函数对称性是其中之一。例如，如果f(x) = f(-x)，则函数被称为偶函数，例如f(x) = |x|，f(x) = x^2，f(x)
    = cos(x)。如果f(-x) = -f(x)，则函数被称为奇函数，例如f(x) = x^3。
- en: Increasing and decreasing functions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增减函数
- en: A function can also be increasing or decreasing. A function is increasing on
    the interval [a, b] if f(x 1) > f( x 2) for any x 1 > x 2, and is decreasing on
    the interval [a, b] if f(x 1) < f( x 2) for any x 1 > x 2.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以是增函数或减函数。如果对于任何x_1 > x_2，f(x_1) > f(x_2)，则函数在区间[a, b]上是增函数；如果对于任何x_1 >
    x_2，f(x_1) < f(x_2)，则函数在区间[a, b]上是减函数。
- en: Slope of a function
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的斜率
- en: 'The slope m of a line can be calculated based on any two points ( x 1, y 1)
    and ( x 2, y 2) using the following definition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一条直线的斜率m可以根据任意两点(x_1, y_1)和(x_2, y_2)使用以下定义来计算：
- en: m =  y 2 − y 1 _ x 2 − x 1
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: m = (y_2 - y_1) / (x_2 - x_1)
- en: Connecting to the definition of the derivative in *Figure 9**.1*, the derivative
    is essentially the slope of the tangent line at the point x = x 0.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与*图9**.1*中的导数定义相联系，导数本质上是在点x = x^0处的切线斜率。
- en: Function composition
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数复合
- en: 'Function composition refers to the case when a function consists of more than
    one nested function, denoted as f(g(x)) = (f ∘ g)(x). The mapping sequence is
    this: the input variable x first gets transformed by function g(x), followed by
    transformation by the function f(x). In f(g(x)), g(x) is the interior function
    and f(x) is the exterior function.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数复合指的是一个函数由多个嵌套函数组成的情况，表示为f(g(x)) = (f ∘ g)(x)。映射序列如下：输入变量x首先通过函数g(x)进行转换，然后通过函数f(x)进行转换。在f(g(x))中，g(x)是内部函数，f(x)是外部函数。
- en: 'For example, given f(x) = 2x − 1, g(x) = x 3, we can obtain f(g(x)) as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定f(x) = 2x - 1，g(x) = x^3，我们可以得到f(g(x))如下：
- en: f(g(x)) = 2 x 3 − 1
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: f(g(x)) = 2x^3 - 1
- en: Note that the function composition is not commutative—that is, f(g(x)) ≠ g(f(x)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数复合不是可交换的——也就是说，f(g(x)) ≠ g(f(x))。
- en: Common functions
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见函数
- en: Let’s look at several types of common functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看几种常见的函数类型。
- en: Power function
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 幂函数
- en: 'The **power function**, f(x) = k x p, where k and p are constants, and x is
    the variable. k is also called the coefficient. Examples include the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**幂函数**，f(x) = k x^p，其中 k 和 p 是常数，x 是变量。k 也称为系数。以下是一些例子：'
- en: 'Cube function: f(x) = x 3'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立方函数：f(x) = x^3
- en: 'Square root function: f(x) = √ _ x'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方根函数：f(x) = √x
- en: 'Cube root function: f(x) = 3 √ _ x'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立方根函数：f(x) = 3√x
- en: 'Linear function: f(x) = x'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性函数：f(x) = x
- en: 'Absolute value function: f(x) = |x|'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对值函数：f(x) = |x|
- en: 'Square function: f(x) = x 2'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方函数：f(x) = x^2
- en: Polynominal function
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多项式函数
- en: The **polynomial function**, f(x) = a n x n + a n−1 x n−1 + … + a 1 x + a 0,
    where a n is the leading coefficient. n is a non-negative integer called the degree
    of the polynomial, and the coefficients a 0, … , a n are real numbers with a n
    ≠ 0.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**多项式函数**，f(x) = a_n x^n + a_{n−1} x^{n−1} + … + a_1 x + a_0，其中 a_n 是首项系数。n
    是一个非负整数，称为多项式的次数，系数 a_0, … , a_n 是实数，且 a_n ≠ 0。'
- en: Rational function
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有理函数
- en: The **rational function**, f(x) = n(x) _ d(x) , where both n(x) and d(x) are
    polynomials, and d(x) ≠ 0.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**有理函数**，f(x) = n(x)/(d(x))，其中 n(x) 和 d(x) 都是多项式，且 d(x) ≠ 0。'
- en: Exponential function
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数函数
- en: The **exponential function**, f(x) = b x, where b > 0 and b ≠ 1.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**指数函数**，f(x) = b^x，其中 b > 0 且 b ≠ 1。'
- en: Logarithmic function
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对数函数
- en: 'The **logarithmic function**: f(x) = log bx, where b > 0 and b ≠ 1\. Note that
    when y = log bx, we have the equivalent form of x = b y.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数函数**：f(x) = log_bx，其中 b > 0 且 b ≠ 1。注意，当 y = log_bx 时，我们有等价形式 x = b^y。'
- en: After getting a quick understanding of the many functions and their properties,
    let us look at the concept of a limit, which relates to the derivative.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速了解了许多函数及其性质之后，让我们看看极限的概念，它与导数相关。
- en: Understanding limits
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解极限
- en: 'The limit of a function f(x) says that when the input x is close but not equal
    to a number c, the value of f(x = c) would be close to a real number L. Mathematically,
    we can express it as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 f(x) 的极限表示，当输入 x 接近但不等于一个数 c 时，f(x = c) 的值将接近一个实数 L。数学上，我们可以表示如下：
- en: lim x→c f(x) = L
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: lim x→c f(x) = L
- en: 'Or, equivalently, it could be expressed as f(x) → L as x → c. Note that the
    value of the limit lim x→c f(x) may not necessarily be equal to the value of the
    function at x = c—that is, f(c). Such equality,     lim x→c f(x) = f(c), happens only when f(x) is a continuous function.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以表示为 f(x) → L 当 x → c。注意，极限 lim x→c f(x) 的值可能不一定等于函数在 x = c 处的值——即 f(c)。这种等式，lim
    x→c f(x) = f(c)，仅在 f(x) 是连续函数时发生。
- en: Infinite limit
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无穷大极限
- en: When the limit lim x→c f(x) does not exist as x → c, we say that the function
    f(x) tends to infinity and thus leads to an infinite limit as x → c. We can also
    say that x = c is the vertical asymptote of the function f(x).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当极限 lim x→c f(x) 在 x → c 时不存在，我们说函数 f(x) 趋向于无穷大，因此当 x → c 时导致无穷大极限。我们也可以说 x
    = c 是函数 f(x) 的垂直渐近线。
- en: One example is f(x) =  1 _ x − 1\. We know that the domain is x ≠ 1\. As x →
    1, we have lim x→1  1 _ x − 1 = ∞, which breaks down into approaching from the
    left lim x→1 −  1 _ x − 1 = − ∞ and approaching from the right lim x→1 +  1 _ x
    − 1 = ∞. Both results jointly lead to lim x→1  1 _ x − 1 = ∞, thus lim x→1  1 _ x
    − 1 does not exist. The vertical asymptote is x = 1.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是 f(x) = 1/(x - 1)。我们知道定义域是 x ≠ 1。当 x → 1 时，我们有 lim x→1 1/(x - 1) = ∞，这分解为从左侧接近
    lim x→1− 1/(x - 1) = −∞ 和从右侧接近 lim x→1+ 1/(x - 1) = ∞。这两个结果共同导致 lim x→1 1/(x -
    1) = ∞，因此 lim x→1 1/(x - 1) 不存在。垂直渐近线是 x = 1。
- en: Limit at infinity
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无穷大极限
- en: The limit at infinity is concerned with the value of f(x) when x → ∞ or x →
    − ∞. This gives the horizontal asymptote of the function—that is, lim x→∞ f(x)
    and  lim x→−∞f(x). We call that y = b is a horizontal asymptote if either lim x→∞ f(x)
    = b or  lim x→−∞f(x) = b.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 无穷大极限关注的是当 x → ∞ 或 x → −∞ 时 f(x) 的值。这给出了函数的水平渐近线——即 lim x→∞ f(x) 和 lim x→−∞
    f(x)。我们称 y = b 为水平渐近线，如果 lim x→∞ f(x) = b 或 lim x→−∞ f(x) = b。
- en: Let us look at a few examples. For the square function f(x) = x 2, we have lim x→∞ x 2
    = ∞ and  lim x→−∞x 2 = ∞. For the square root function f(x) = √ _ x , since the
    domain is x ≥ 0, we have lim x→∞ √ _ x  = ∞. For the natural logarithmic function
    f(x) = lnx, since the domain is x > 0, we have lim x→∞ √ _ x  = ∞. For a general
    result, we have lim x→∞ x p = ∞ and lim x→∞  1 _ x p = ∞.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子。对于平方函数 f(x) = x^2，我们有 lim x→∞ x^2 = ∞ 和 lim x→−∞ x^2 = ∞。对于平方根函数 f(x)
    = √x，由于定义域是 x ≥ 0，我们有 lim x→∞ √x = ∞。对于自然对数函数 f(x) = lnx，由于定义域是 x > 0，我们有 lim
    x→∞ √x = ∞。对于一般结果，我们有 lim x→∞ x^p = ∞ 和 lim x→∞ 1/x^p = ∞。
- en: The next section formally introduces derivatives.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分正式介绍了导数。
- en: Introducing derivatives
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍导数
- en: 'For a function y = f(x), the derivative of f at x, denoted as f′(x), is defined
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数y = f(x)，f在x处的导数，记作f′(x)，定义为以下内容：
- en: f ′(x) = lim h→0  f(x + h) − f(x) _ h , if the limit exists.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: f′(x) = lim(h→0) f(x + h) - f(x) / h，如果极限存在。
- en: When f′(x) exists for each value of x in the range [a, b], we say that the function
    f is differentiable over x ∈ [a, b].
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当f′(x)在区间[a, b]内的每个x值上存在时，我们说函数f在x ∈ [a, b]上是可导的。
- en: There are multiple applications of a derivative. Besides the previous point
    on interpreting the derivative as the slope of the tangent line, the most common
    application is that we can use the derivative to determine if a function is rising/increasing
    or falling/decreasing at a specific point. It also represents the instantaneous
    rate of change, or velocity, at a given point x.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 导数有多种应用。除了将导数解释为切线斜率之外，最常见的应用是我们可以使用导数来确定函数在特定点上是上升/增加还是下降/减少。它还表示在给定点x的瞬时变化率，或速度。
- en: 'A graphical illustration will help our understanding here. *Figure 9**.6* provides
    a sample curve of f(x) with a **secant** line connecting two points (a, f(a))
    and (b, f(b)). Here, a secant line is a straight line that intersects the curve
    of a function at two or more distinct points. We obtain a second point (a + h,
    f(a + h)) by adding a small amount h to the point (a, f(a)). Connecting these
    two points gives the secant line that crosses the function f(x) by these two points.
    As h → 0, the secant line will gradually approach the tangent line obtained at
    x = a. Eventually, the secant line will overlap with the tangent line in the limit,
    and the slope of the secant line, expressed as f(a + h) − f(a) _ h , will become
    the slope of the tangent line when they overlap in the limit:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图形说明将有助于我们的理解。*图9.6*提供了一个f(x)的样本曲线，其中有一条**割线**连接两个点(a, f(a))和(b, f(b))。在这里，割线是穿过函数曲线的两个或更多不同点的直线。我们通过在点(a,
    f(a))上加上一个小的量h得到第二个点(a + h, f(a + h))。连接这两个点给出通过这两个点穿过函数f(x)的割线。当h趋近于0时，割线将逐渐接近在x
    = a处得到的切线。最终，割线将在极限中与切线重叠，割线的斜率，表示为f(a + h) - f(a) / h，将变为它们在极限中重叠时的切线斜率：
- en: '![Figure 9.6 – A graph illustrating the derivation of a derivative](img/B18680_09_006.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 展示导数推导过程的图形](img/B18680_09_006.jpg)'
- en: Figure 9.6 – A graph illustrating the derivation of a derivative
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 展示导数推导过程的图形
- en: In *Figure 9**. 6*, the second point (a + h, f(a + h)) is produced by adding
    a small amount h to the point (a, f(a)). Connecting these two points gives the
    secant line. As h → 0, the secant line will gradually approach the tangent line
    at x = a, eventually overlapping with the tangent line in the limit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.6*中，第二个点(a + h, f(a + h))是通过在点(a, f(a))上加上一个小的量h得到的。连接这两个点给出割线。当h趋近于0时，割线将逐渐接近x
    = a处的切线，最终在极限中与切线重叠。
- en: 'The slope of the secant line, also called the average rate of change, is calculated
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 割线的斜率，也称为平均变化率，计算如下：
- en: f(a + h) − f(a) _ (a + h) − a  =  f(a + h) − f(a) _ h
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: f(a + h) - f(a) / (a + h) - a = f(a + h) - f(a) / h
- en: 'This is provided that h ≠ 0\. When h → 0, the secant line infinitely approaches
    the tangent line at x = a, giving the instantaneous rate of change at this point
    (provided that the limit exists):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在h ≠ 0的前提下提供的。当h趋近于0时，割线无限接近于x = a处的切线，给出该点的瞬时变化率（如果极限存在的话）：
- en: lim h→0  f(a + h) − f(a) _ h
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当h趋近于0时，函数f在a + h处的极限为f(a + h)减去f(a)除以h
- en: In general, if y = f(x), we can express the derivative as f′(x), y′,  dy _ dx,
    or  d _ dx f(x).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果y = f(x)，我们可以将导数表示为f′(x)，y′，dy/dx，或者d/dx f(x)。
- en: The following section introduces a few common derivatives.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分介绍一些常见的导数。
- en: Common derivatives
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见导数
- en: 'Here, we provide a list of derivatives for several common functions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了一些常见函数的导数列表：
- en: 'Constant function:  d _ dx(c) = 0'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数函数：d/dx(c) = 0
- en: 'Power function:  d _ dx(x n) = n x n−1'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幂函数：d/dx(x^n) = nx^(n-1)
- en: 'Exponential function:  d _ dx(e x) = e x,  d _ dx(b x) = (lnb)b x, b > 0'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数函数：d/dx(e^x) = e^x, d/dx(b^x) = (lnb)b^x, 其中b > 0
- en: 'Logarithmic function:  d _ dx(lnx) = 1 _ x ,  d _ dx(log bx) =  1 _ (lnb)x,
    b > 0, b ≠ 1'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数函数：d/dx(lnx) = 1/x, d/dx(log_bx) = 1/(lnb)x, 其中b > 0, b ≠ 1
- en: 'Sine and cosine functions:  d _ dx(sinx) = cosx,  d _ dx cosx = − sinx'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正弦和余弦函数：d/dx(sinx) = cosx, d/dx(cosx) = -sinx
- en: Calculating the derivative often involves multiple basic functions. The next
    section covers a set of properties and rules on derivative calculation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 计算导数通常涉及多个基本函数。下一节将介绍关于导数计算的一组性质和规则。
- en: Common properties and rules of derivatives
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导数的常见性质和规则
- en: 'We introduce two common properties—the constant multiple property and the sum
    and difference property—followed by three common rules: the product rule, the
    quotient rule, and the chain rule. We assume that all limits exist in the following
    list:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入两个常见的性质——常数倍性质和和差性质——然后是三个常见的规则：乘法法则、除法法则和链式法则。我们假设以下列表中的所有极限都存在：
- en: '**Constant multiple property**: For a constant c, if y = f(x) = ch(x), then
    f′(x) = ch′(x). Expressed differently, we have y ′  = ch′, and  dy _ dx = c dh _ dx .'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常数倍性质**：对于常数c，如果y = f(x) = ch(x)，那么f′(x) = ch′(x)。用不同的方式表达，我们有y′ = ch′，并且dy/dx
    = c dh/dx。'
- en: '**Sum and difference property**: If y = f(x) = h(x) ± g(x), then f′(x) = h′(x)
    ± g′(x). Expressed differently, we have y ′  = h ′  + g′, and  dy _ dx = dh _ dx 
    +  dg _ dx.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**和差性质**：如果y = f(x) = h(x) ± g(x)，那么f′(x) = h′(x) ± g′(x)。用不同的方式表达，我们有y′ =
    h′ + g′，并且dy/dx = dh/dx + dg/dx。'
- en: '**Product rule**: If y = f(x) = h(x)g(x), then f ′ (x) = h ′ (x)g(x) + h(x)g′(x).
    Expressed differently, we have y ′  = h ′ g + hg′, and  dy _ dx = g dh _ dx  +
    h  dg _ dx.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法法则**：如果y = f(x) = h(x)g(x)，那么f′(x) = h′(x)g(x) + h(x)g′(x)。用不同的方式表达，我们有y′
    = h′g + hg′，并且dy/dx = g dh/dx + h dg/dx。'
- en: '**Quotient rule**: If y = f(x) = h(x) _ g(x) , then f ′ (x) = g(x)h ′ (x) −
    h(x)g ′ (x) _ [g(x)] 2 . Expressed differently, we have y ′  = gh ′  − hg ′  _ g 2 ,
    and  dy _ dx = g dh _ dx  − h  dg _ dx _ g 2 .'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除法法则**：如果y = f(x) = h(x) / g(x)，那么f′(x) = g(x)h′(x) - h(x)g′(x) / [g(x)]²。用不同的方式表达，我们有y′
    = gh′ - hg′ / g²，并且dy/dx = g dh/dx - h dg/dx / g²。'
- en: '**Chain rule**: Given a composite function y = f(x) = h(g(x)), we have f′(x)
    = h′(g(x))g′(x). Equivalently, if we have y = h(u) and u = g(x), then  dy _ dx
    =  dy _ du du _ dx .'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链式法则**：给定一个复合函数y = f(x) = h(g(x))，我们有f′(x) = h′(g(x))g′(x)。等价地，如果我们有y = h(u)和u
    = g(x)，那么dy/dx = dy/du du/dx。'
- en: In the next section, we will switch to integral calculus.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将转向积分微积分。
- en: Introducing integral calculus
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍积分微积分
- en: Integration is the inverse of differentiation. For example, differentiating
    the distance traveling S(t) with respect to time gives the velocity at a specific
    time point v(t). We can calculate the cumulative distance traveled from time t
    = a to t = b as S = ∑ i=0 n−1 v( t i) ∆ t, after dividing the time period into
    n equally spaced intervals. When the number of intervals approaches infinity—that
    is, n → ∞, we have S = lim n→∞ ∑ i=0 n−1 v(t i)Δt = ∫ a b v(t)dt.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 积分是微分的逆运算。例如，对距离函数S(t)关于时间的微分给出特定时间点的速度v(t)。我们可以通过将时间周期分为n个等间距的区间来计算从时间t = a到t
    = b的累积距离S = ∑i=0^(n-1) v(ti)Δt，在n个区间数趋于无穷大时——即n → ∞，我们得到S = lim(n→∞) ∑i=0^(n-1)
    v(ti)Δt = ∫a^b v(t)dt。
- en: The result of integration is called an antiderivative, which allows us to reconstruct
    a function from its derivative. It is the opposite of differentiation. Formally,
    a function F(x) is an antiderivative of f(x) if F ′ (x) = f(x).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 积分的结果称为不定积分，它允许我们从导数重建函数。这是微分运算的逆运算。形式上，如果函数F(x)是f(x)的不定积分，那么F′(x) = f(x)。
- en: '*Figure 9**.7* illustrates the equivalence between integration and AUC. We
    can use integration to find the AUC of a general function f(x). This area can
    be obtained by adding slices of rectangles that approach zero width. The width
    of each rectangle is dx, which, by definition, refers to an infinitesimal change
    in x—that is, differential in x:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.7* 说明了积分与AUC之间的等价性。我们可以使用积分来找到一般函数f(x)的AUC。这个面积可以通过添加趋近于零宽度的矩形切片来获得。每个矩形的宽度是dx，根据定义，它指的是x的无穷小变化，即x的微分：'
- en: '![Figure 9.7 – A graph illustrating the equivalence between integration and
    AUC](img/B18680_09_007.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 说明积分与AUC等价性的图表](img/B18680_09_007.jpg)'
- en: Figure 9.7 – A graph illustrating the equivalence between integration and AUC
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 说明积分与AUC等价性的图表
- en: Note that an integral can be definite or indefinite. A definite integral has
    an explicit starting and ending point of integration. For example, if x ∈ [a,
    b], the definite integral becomes ∫ a b f(x)dx. On the other hand, an indefinite
    integral has no explicit boundary, giving ∫ f(x)dx, which is used to represent
    the family of all antiderivatives of f(x).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，积分可以是定积分或不定积分。定积分有一个明确的积分起始点和结束点。例如，如果x ∈ [a, b]，定积分变为∫a^b f(x)dx。另一方面，不定积分没有明确的边界，给出∫f(x)dx，它用来表示f(x)的所有不定积分的集合。
- en: The following section delves more into indefinite integrals.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将更深入地探讨不定积分。
- en: Indefinite integrals
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不定积分
- en: Generally, we can represent an indefinite integral as ∫ f(x)dx = F(x) + C if
    F ′ (x) = f(x), where C is a constant and appears here to represent a family of
    all antiderivative functions whose derivative is f(x). In other words, we have
     d _ dx[∫ f(x)dx] = f(x) and ∫ F′(x)dx = F(x) + C.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果我们有 F′(x) = f(x)，那么我们可以将不定积分表示为 ∫ f(x)dx = F(x) + C，其中 C 是一个常数，在这里用来表示所有导数为
    f(x) 的反导函数的集合。换句话说，我们有 d/dx[∫ f(x)dx] = f(x) 和 ∫ F′(x)dx = F(x) + C。
- en: 'Now, let us understand the expression of the indefinite integral ∫ f(x)dx a
    bit more. ∫ is the integral symbol, f(x) is the integrand, and dx is a slice along
    x, indicating that the antidifferentiation is performed on x. *Figure 9**.8* illustrates
    the naming convention:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地理解不定积分 ∫ f(x)dx 的表达式。∫ 是积分符号，f(x) 是被积函数，dx 是沿 x 的一个切片，表示反导数是在 x 上进行的。*图
    9.8* 展示了命名约定：
- en: '![Figure 9.8 – Summarizing the naming convention of indefinite integrals](img/B18680_09_008.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 总结不定积分的命名约定](img/B18680_09_008.jpg)'
- en: Figure 9.8 – Summarizing the naming convention of indefinite integrals
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 总结不定积分的命名约定
- en: We will now look at indefinite integrals of common basic functions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将研究常见基本函数的不定积分。
- en: Indefinite integrals of basic functions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本函数的不定积分
- en: 'The following list provides the indefinite integrals of basic functions. Again,
    note that the constant C is used to represent a family of all antiderivative functions
    having the same derivative:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了基本函数的不定积分。再次注意，常数 C 用来表示所有具有相同导数的反导函数的集合：
- en: ∫ x ndx =  1 _ n + 1 x n+1 + C
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∫ x^n dx = (1/(n+1))x^(n+1) + C
- en: ∫ e xdx = e x + C
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∫ e xdx = e x + C
- en: ∫ b xdx =  b x _ lnb + C
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∫_b^xdx = (1/2)x^2 + C
- en: ∫ 1 _ x dx = ln|x| + C
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∫ 1/x dx = ln|x| + C
- en: ∫ sinxdx = − cosx + C
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∫ sinxdx = − cosx + C
- en: ∫ cosxdx = sinx + C
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∫ cosxdx = sinx + C
- en: Properties of indefinite integrals
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不定积分的性质
- en: 'This section covers a set of properties that correspond to the derivative function.
    The following two properties are straightforward linear operations:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了与导数函数相对应的一组性质。以下两个性质是直接的线性运算：
- en: ∫ Kf(x)dx = K∫ f(x)dx
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∫ Kf(x)dx = K∫ f(x)dx
- en: ∫ [f(x) ± g(x)]dx = ∫ f(x)dx ± ∫ f(x)dx
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∫ [f(x) ± g(x)]dx = ∫ f(x)dx ± ∫ g(x)dx
- en: 'The following list contains a few general formulas to calculate the indefinite
    integral:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含了一些计算不定积分的一般公式：
- en: ∫ [f(x)] n f'(x)dx =  [f(x)] n+1 _ n + 1  + C, n ≠ 1
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ [f(x)]^n f'(x)dx = [(f(x))]^(n+1)/(n+1) + C, n ≠ 1
- en: ∫ e f(x) f'(x)dx = e f(x) + C
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ e^(f(x)) f'(x)dx = e^(f(x)) + C
- en: ∫  1 _ f(x)  f'(x)dx = ln|f(x)| + C
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ 1/f(x)f'(x)dx = ln|f(x)| + C
- en: 'Next, we introduce one of the most widely used techniques: integration by parts.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍最广泛使用的技术之一：分部积分。
- en: Integration by parts
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分部积分
- en: 'We know the following based on the product rule introduced earlier:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前引入的乘积法则，我们知道以下内容：
- en: d _ dx [f(x)g(x)] = f ′ (x)g(x) + f(x)g'(x)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: d/dx[f(x)g(x)] = f′(x)g(x) + f(x)g′(x)
- en: 'We can then integrate both sides and move terms around to get the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对方程的两边进行积分，并重新排列项，得到以下结果：
- en: ∫ f(x)g'(x)dx = f(x)g(x) − ∫ g(x)f'(x)dx
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ f(x)g'(x)dx = f(x)g(x) − ∫ g(x)f'(x)dx
- en: 'This gives the integration by parts formula. More succinctly, we can define
    v = g(x) and u = f(x). Thus, dv = g ′ (x)dx and du = f ′ (x)dx. The preceding
    equation then becomes this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了分部积分公式。更简洁地说，我们可以定义 v = g(x) 和 u = f(x)。因此，dv = g′(x)dx 和 du = f′(x)dx。前面的方程变为：
- en: ∫ udv = uv − ∫ vdu
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ udv = uv − ∫ vdu
- en: Next, we delve more into definite integrals.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更深入地探讨定积分。
- en: Definite integrals
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定积分
- en: 'If f(x) is a continuous function on x ∈ [a, b] and F(x) is the antiderivative
    of f(x), that is expressed as F(x) = ∫ f(x)dx + C. The following formula gives
    the fundamental theorem of calculus:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 f(x) 是 x ∈ [a, b] 上的连续函数，且 F(x) 是 f(x) 的反导数，即 F(x) = ∫ f(x)dx + C。以下公式给出了微积分的基本定理：
- en: ∫ a bf(x)dx = F(b) − F(a)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ a bf(x)dx = F(b) − F(a)
- en: This expression says that the AUC f(x) in the range [a, b] can be calculated
    as the difference between evaluations of the antiderivative function F(x) at the
    two endpoints.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式说明，在区间 [a, b] 内的 AUC f(x) 可以通过计算反导函数 F(x) 在两个端点的评估差来得到。
- en: 'Definite integrals share mostly the same properties as indefinite integrals,
    with the following addition:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 定积分与不定积分具有大部分相同的性质，以下是一个额外的性质：
- en: ∫ a cf(x)dx = ∫ a bf(x)dx + ∫ b cf(x)dx
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ∫_a^cf(x)dx = ∫_a^bf(x)dx + ∫_b^cf(x)dx
- en: The next section will visit the implementation side of things in calculus using
    R.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将探讨使用 R 进行微积分的实现方面。
- en: Working with calculus in R
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 R 中使用微积分
- en: 'In this section, we will use the `mosaicCalc` package to perform calculus-related
    operations. The functions we will work with are mostly analytical (have explicit
    expression) and simple in nature. The following code snippet checks if this package
    is installed and will install the package if the condition evaluates to `true`,
    followed by importing the package to the current session:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`mosaicCalc`包来执行与微积分相关的操作。我们将使用的函数大多是分析性的（有显式表达式）且性质简单。以下代码片段检查此包是否已安装，如果条件评估为`true`，则会安装该包，然后将其导入当前会话：
- en: '[PRE0]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To avoid too much imagination, a good way to learn about unknown functions is
    to plot them out. Let us see how to plot a function using the `mosaicCalc` package.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免过多的想象，了解未知函数的一个好方法是绘制它们。让我们看看如何使用`mosaicCalc`包绘制函数。
- en: Plotting basic functions
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制基本函数
- en: There are a few input parameters we need to specify upon plotting a function
    using the `mosaicCalc` package. Overall, we need to specify the expression of
    the function, the input variable(s), the domain of each input variable used to
    plot the function, and the values of other parameters set in advance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`mosaicCalc`包绘制函数时，我们需要指定一些输入参数。总的来说，我们需要指定函数的表达式、用于绘制函数的输入变量（s）、每个输入变量的域以及预先设置的参数值。
- en: 'There are three common graphing functions for plotting purposes: `slice_plot()`,
    used to plot functions with only one input variable, `contour_plot()`, used to
    plot functions with two input variables, and `interactive_plot()`, used to plot
    interactive graphs. These functions allow us to translate mathematical expressions
    into code and then plots. Let us explore each of them via the following exercise.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘图方面，有三个常见的绘图函数：`slice_plot()`，用于绘制只有一个输入变量的函数，`contour_plot()`，用于绘制具有两个输入变量的函数，以及`interactive_plot()`，用于绘制交互式图形。这些函数允许我们将数学表达式转换为代码，然后绘制图形。让我们通过以下练习来探索每个函数。
- en: Exercise 9.1 – Plotting basic functions
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9.1 – 绘制基本函数
- en: 'This exercise will explore the plotting capabilities of the preceding functions,
    starting with `slice_plot()`. Follow the next steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习将探索前面函数的绘图功能，从`slice_plot()`开始。请按照以下步骤进行：
- en: 'Plot the function y = 2x + 1 for x ∈ [ − 5,5] using the `slice_plot()` function,
    like so:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`slice_plot()`函数绘制函数y = 2x + 1，其中x ∈ [−5, 5]，如下所示：
- en: '[PRE1]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we put the function expression 2x + 1 on the left of the tilde sign (`~`)
    and the input variable x on the right. We also specify the domain by passing the
    boundaries to the `range()` function. Running this command generates the output
    shown in *Figure 9**.9*:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将函数表达式2x + 1放在波浪号（`~`）的左边，输入变量x放在右边。我们还通过传递边界给`range()`函数来指定域。运行此命令将生成如*图9**.9*所示的输出：
- en: '![Figure 9.9 – Plotting a straight line using the slice_plot() function](img/B18680_09_009.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 使用slice_plot()函数绘制直线](img/B18680_09_009.jpg)'
- en: Figure 9.9 – Plotting a straight line using the slice_plot() function
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 使用slice_plot()函数绘制直线
- en: 'We can also make the function more general by setting the prior parameters
    for the coefficient m and intercept b of the line y = mx + b. This makes the code
    more general since we only need to specify `m` and `b` in the following code snippet
    to plot any straight line:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过设置直线y = mx + b的系数m和截距b的先验参数来使函数更通用。这使得代码更通用，因为我们只需要在以下代码片段中指定`m`和`b`来绘制任何直线：
- en: '[PRE2]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that an error would occur if no initial value for the input parameter
    were set, as shown in the following snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有设置输入参数的初始值，将会发生错误，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition, we can use the `makeFun()` function to give a name to the function
    to be plotted, as shown in the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`makeFun()`函数给要绘制的函数命名，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the function is named, we can pass an arbitrary input value to evaluate
    the function. For example, setting x = 2 gives a return of `5`, as seen here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦给函数命名，我们就可以传递任意输入值来评估函数。例如，设置x = 2将返回`5`，如下所示：
- en: '[PRE5]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we look at generating a contour plot for a function with two input variables.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看如何为具有两个输入变量的函数生成等高线图。
- en: 'Make a contour plot of the equation z = 2x + 3y using the `contour_plot()`
    function, like so:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`contour_plot()`函数绘制方程z = 2x + 3y的等高线图，如下所示：
- en: '[PRE6]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we use the `&` sign to indicate more than one input variable and set
    the corresponding range for both variables. Running this command generates the
    output shown in *Figure 9**.10*:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Generating a contour plot of ​z = 2x + 3y​ using the contour_plot()
    function](img/B18680_09_010.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Generating a contour plot of z = 2x + 3y using the contour_plot()
    function
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at generating an interactive plot using the `interactive_plot()`
    function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate an interactive 3D plot for the same expression using the `interactive_plot()`
    function, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running this command generates the output shown in *Figure 9**.11*. Note that
    the resulting plot is an interactive HTML widget, allowing us to move around and
    displaying auxiliary information upon mouseover:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Generating an interactive 3D plot for ​z = 2x + 3y​ using the
    interactive_plot() function](img/B18680_09_011.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Generating an interactive 3D plot for z = 2x + 3y using the interactive_plot()
    function
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers working with derivatives via the differentiation operation
    using the `D()` function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Working with derivatives
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The differentiation operation is completed via the `D()` differentiation operator
    in R, which inputs a single expression and outputs the derivative function. The
    input specifies the same expression as required by the plotting function earlier.
    For example, to specify the function y = x 2 + 1, we can pass `x^2+1 ~ x` to the
    `D()` function, which will then automatically calculate the derivative function
    y ′  = 2x. We can then assign the result to another variable, which serves as
    the derivative function and can be used to evaluate the derivative value at any
    point in the domain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates the process of obtaining the derivative
    function. The return of the `D()` operator is the derivative function, which is
    y ′  = 2x after printing it out:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code snippet evaluates two input values. The result shows that
    the `D()` function is able to correctly calculate the derivative function and
    perform an evaluation at an arbitrary input location:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the `D()` function can carry out the rules mentioned previously upon
    calculating the derivative function. For example, to obtain the derivative of
    y = sin( x 2 − 5), we would invoke the chain rule and calculate the derivative
    as y''= 2xcos( x 2 − 5). The `D()` function completes this for us, as shown in
    the following code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us also verify the quotient rule. In the following code snippet, we pass
    the function y =  2x _ x + 1 to `D()`, which should ideally return the derivative
    function y''= 2(x + 1) − 2x _ (x + 1) 2 . The result shows that this is indeed
    the case:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next section covers the use of symbolic parameters in functions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Using symbolic parameters
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symbolic parameters offer generality in constructing functions. The same as
    earlier, we can encode the prior values of parameters before passing them to the
    expression of the function. The following exercise illustrates this point.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.2 –Using symbolic parameters
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will look at a general function y = A x 3 + Bx + 3, where
    A and B are constants and x is the only random input variable. The derivative
    function will be y ′  = 3A x 2 + B. Follow the next steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the derivative of the function y = A x 3 + Bx + 3, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We see that the derivative function is correctly calculated.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the derivative function when x = 2, A = 2, and B = 3, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can also evaluate the function via multiple points, which amounts to plotting
    the derivative function across a specific range.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Plot the derivative function within the range x ∈ [ − 5,5] with A = 2 and B
    = 3, like so:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running this command generates the output shown in *Figure 9**.12*:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Visualizing the derivative function ​​y ′ ​ = 6 ​x​​ 2​ + 3​](img/B18680_09_012.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Visualizing the derivative function y ′  = 6 x 2 + 3
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers the second derivative.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Working with the second derivative
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second derivative, expressed as f″(x), is just the derivative of the first
    derivative of the raw function f(x). In the previous example, when y = A x 3 +
    Bx + 3, we have y ′  = 2A x 2 + B. Taking another derivative gives y ″  = 4Ax.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at how to obtain the second derivative via the following exercise.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.3 – Calculating the second derivative
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this exercise, we will calculate the second derivative of a raw function
    f(x). The second derivative can be considered as differentiating f(x) with respect
    to x twice, giving f ″ (x) = y ″  =  d 2 _ d x 2 f(x). The double differentiation
    is achieved by having two x''s on the right-hand side of the tilde sign. Follow
    the next steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the second derivative f ″ (x), as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result shows that the second derivative of the draw function is correctly
    calculated.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the second derivative function by setting when x = 2, A = 2, and B
    = 3, as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In fact, since the second derivative function has nothing to do with the parameter
    B, any value of B will render the same result. For example, the following code
    returns the same result even when B = 1:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Plot the second derivative function within the range x ∈ [ − 5,5] with A =
    2, like so:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running this command generates the output shown in *Figure 9**.13*. Here, we
    note that the second derivative function is a straight line as compared to the
    bell-shaped curve of the first derivative function. This straight line represents
    how fast the first derivative function changes:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Visualizing the second derivative function ​​y ″ ​ = 12x​](img/B18680_09_013.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Visualizing the second derivative function y ″  = 12x
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers more general partial derivative functions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Working with partial derivatives
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second derivative function can be considered a special case of a partial
    derivative function. Assume a two-dimensional function z = f(x, y). The second
    derivative of x is obtained by differentiating x twice. We can also differentiate
    x first and y later, giving  d 2 _ dxdy z or, equivalently,  d 2 _ dydx z. Let
    us see how this works via the following exercise.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.4 – Calculating the partial derivative
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will calculate three different partial derivatives:  d 2 _ d
    x 2 z,  d 2 _ dxdy z (or  d 2 _ dydx z), and  d 2 _ d y 2 z, based on the raw
    function z = A x 2 + Bxy + C y 2\. Follow the next steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the second derivative of z with respect to x. Check whether the result
    is  d 2 _ d x 2 z = 2A:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The result shows that the calculation is correct.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calculate the partial derivative of z with regard to x and then y. Check whether
    the result is  d 2 _ dxdy z = B:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result shows that the calculation is correct. We can also differentiate
    y first and then x. As shown in the following code snippet, this gives the same
    result:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Calculate the partial derivative of z with respect to x and then y. Check whether
    the result is  d 2 _ d y 2 z = 2C:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The result shows that the calculation is correct.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next section covers calculating integrals, or antiderivatives, using R.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Working with integration in R
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that differentiation is performed using the `D()` function. Assuming
    y = A x 2 + Bx + 3, we have y ′  = f′(x) = 2Ax + B. We can plot the raw function
    f(x) and its derivative function f′(x) to facilitate the comparison.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we create this expression using the `makeFun()`
    function and name the function `f`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can do a simple evaluation as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we obtain the derivative function and store the function in `f_prime`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a new function derived from the original function. We also do a simple
    evaluation for this function, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let us plot the raw function f(x) = x 2 + x + 3:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Running the command generates the output shown in *Figure 9**.14*. Here, we
    have used the `gf_labs()` function to set the title of the graph:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Visualizing the raw function ​f​(x)​ = ​x​​ 2​ + x + 3​](img/B18680_09_014.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Visualizing the raw function f(x) = x 2 + x + 3
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'We also plot the derivative function f ′ (x) = 2x + 1 as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the command generates the output shown in *Figure 9**.15*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Visualizing the derivative function ​​​f ′ ​​(​​x​)​​ = 2x + 1​​](img/B18680_09_015.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Visualizing the derivative function f ′ (x) = 2x + 1
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'With the derivative function in place, we can obtain its antiderivative using
    the `antiD()` function, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the correct form of the original function is recovered, besides the
    additional constant `C` that is added as an additional input argument to the antiderivative
    function with a default value of 0.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'We can evaluate the antiderivative function as well, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Taking `A=1`, `B=1`, and `C=0`, the antiderivative function F(x) = x 2 + x
    is visualized as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Running the command generates the output shown in *Figure 9**.16*:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Visualizing the derivative function ​​​f ′ ​​(​​x​)​​ = 2x + 1​​](img/B18680_09_016.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Visualizing the derivative function f ′ (x) = 2x + 1
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we differentiate the antiderivative function F(x) = A x 2 + Bx + C
    again, we would expect to obtain the same derivative function f(x) = 2Ax + B.
    The following code snippet verifies this result:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let us pause a moment and look at the relationship between derivative functions
    and their antiderivatives.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: More on antiderivatives
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The anti-differentiation operation that produces F(x) = ∫ f'(x)dx + C is the
    reverse of the differentiation that generates f'(x). It represents a family of
    functions, including the original function f(x). These functions are very much
    related to each other. Specifically, the derivative function f'(x), which is a
    derived function, tells the rate of change of the original function f(x) for an
    arbitrary input point x. It gives a local property of f(x) in a microscopic lens,
    measuring the sensitivity of f(x) at the current point.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: However, we may not always need to derive f'(x) in every scenario. Sometimes,
    we will work with the derivative function f'(x) as a start, and would be interested
    in deriving the original function—that is, the antiderivative function F(x). This
    gives a global property of the raw function f(x), representing the values accumulated
    within a specific range.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the unknown raw function is called anti-differentiation, or integration.
    The result is called the integral. Depending on whether the integration is evaluated
    on specific boundaries or not, we have an indefinite integral and a definite integral.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'The integration operation generates a family of anti-derivative functions.
    As in the previous example, the anti-derivative function is F(x) = A x 2 + Bx
    + C. Setting `A=1` and `B=1`, we will obtain different results at the same input
    location for different choices of C, as shown in the following code snippet:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Although these are different raw functions, they all share the same derivative
    function, as illustrated in the following snippet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The family of antiderivative functions, denoted by F(x) = ∫ f′(x)dx + C, thus
    corresponds to infinitely many functions, including the raw function f(x). These
    infinitely many antiderivative functions are essentially vertical shifts of f(x),
    giving F(x) = f(x) + C.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that the derivative function shares the same set of input arguments
    as the original function, as verified in the following code snippet:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, the antiderivative function requires an additional argument—the constant
    `C`, as seen here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The next section looks at how to evaluate the definite integral.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the definite integral
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Calculating the definite integral requires evaluating the indefinite integral
    twice: once at the starting point of integration, and once at the end point of
    integration.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume the antiderivative function is F(x) = x 2 + x + C for A=1
    and B=1\. To calculate the indefinite integral ∫ 2 3 f′(x)dx, we would evaluate
    F(x) at both x = 2 and x = 3 and take their difference, giving F(3) − F(2). The
    following code snippet shows the result:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, one thing to note is that the constant `C` is assumed to be `0` in both
    evaluations. In fact, it does not matter which value it assumes, since the constants
    from both evaluations will always cancel out each other. In other words, we will
    always have a fixed definite integral, despite the indefinite integral corresponding
    to infinitely many values at a specific input point.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of calculus, including differential calculus
    and integral calculus. In the first section, we introduced an intuitive understanding
    of these two branches of calculus and covered the fundamentals of common functions
    and their properties. We started introducing the concept of limit and its connection
    to the definition of a derivative, followed by covering common derivative rules
    and properties. We also discussed integral calculus, including indefinite integrals
    and definite integrals, along with their rules and properties.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The second and third sections touched upon implementations in R. We introduced
    how to carry out common differentiation and integration using the `D()` and `antiD()`
    functions, with several examples illustrating their usage and conversion between
    the derivative function and its antiderivative.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will enter into the realm of mathematical statistics,
    starting with the basics of probability.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
