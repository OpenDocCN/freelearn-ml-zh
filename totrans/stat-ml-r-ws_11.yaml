- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculus in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Calculus** is a branch of mathematics that studies the relationship between
    two quantities, connected via a function, from either a micro or a macro perspective.
    Taking a microscopic lens, such a relationship (often denoted by y = f(x)) manifests
    in the form of a very small change in the output y given an infinitesimal change
    in the input x. When switching to the macro perspective, the relationship becomes
    the cumulative change in y as x changes. The micro perspective corresponds to
    differential calculus, and the macro perspective corresponds to integral calculus,
    both introduced in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have grasped essential concepts in differential
    and integral calculus. Practical implementations in R will also be introduced
    to leverage R’s automatic differentiation and integration capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing calculus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with calculus in R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with integration in R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the code in this chapter, you will need to have the latest version of
    the `mosaicCalc` package, which is 0.6.0 at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: All the code and data for this chapter is available at [https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_9/working.R](https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_9/working.R).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing calculus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calculus is a branch of mathematics that studies the rate of change, such as
    the slope of a curve at any point. It is a fundamental subject widely used in
    many areas, including physics, economics, finance, optimization, **artificial
    intelligence** (**AI**), and more. Calculus was first developed by two gentlemen
    in the late 17th century: Gottfried Leibniz and Isaac Newton. Newton first developed
    calculus to analyze physical systems, while Leibniz independently developed the
    resulting notations we use today. Compared with basic math, which uses operations
    such as addition or subtraction, calculus applies functions and integrals to study
    the rate of change. Here, the rate of change can be regarded as the velocity,
    measuring how fast f(x) changes as x changes. Such changes also have a direction,
    meaning whether f(x) increases or decreases as x increases.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can measure how fast the rate of change of f(x) changes as x changes.
    Such a measure is called acceleration, which assesses whether f(x) increases or
    decreases at an increasing or decreasing rate as x increases.
  prefs: []
  type: TYPE_NORMAL
- en: Differential and integral calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two main branches of calculus are **differential calculus** and **integral
    calculus**. Differential calculus studies the rate of change of a particular quantity.
    It examines the rate of change of slopes and curves and studies the sensitivity
    of an outcome variable y to a very small change in the input variable x. On the
    other hand, integral calculus studies the volume or **area under the** **curve**
    (**AUC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 9**.1*, we plotted a sample function y = f(x) and picked
    an arbitrary point at x = x 0\. We then added a very small change ∆ x to x 0\.
    This change is so small that it will tend toward 0 in the limit—that is, ∆ x →
    0\. Upon changing x, the dependent variable y will also change, generating a resulting
    change of ∆ y. Dividing these two terms gives an indication of the sensitivity
    of y with respect to x at the point x 0\. When ∆ x → 0, we call the sensitivity
    the derivative of y with respect to x when x = x 0\. Expressed mathematically,
    we have f ′ (x 0) =  ∆ y _ ∆ x as ∆ x → 0, or simply, f ′ (x 0) = lim ∆x→0  ∆
    y _ ∆ x:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A graph illustrating differential calculus that studies the
    rate of change at an arbitrary point](img/B18680_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – A graph illustrating differential calculus that studies the rate
    of change at an arbitrary point
  prefs: []
  type: TYPE_NORMAL
- en: 'The rate of change at point x 0, or the sensitivity of the function y = f(x)
    at the point x = x 0, is expressed as f ′ (x 0) =  ∆ y _ ∆ x when ∆ x is infinitesimally
    small—that is, ∆ x → 0\. On the other hand, integral calculus indicates the AUC
    f(x) for a specific range x ∈ [a, b], as shown in *Figure 9**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – A graph illustrating the integral calculus as the total AUC](img/B18680_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – A graph illustrating the integral calculus as the total AUC
  prefs: []
  type: TYPE_NORMAL
- en: We denote the total area as a result of integration S = ∫ a b f(x)dx, which
    reports a positive quantity in this case. This means that the result of integration
    could also be negative, should the curve be below the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: More on functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that a function is a mapping machine between two sets of elements. For
    each element in the input set, there is one and only one corresponding element
    in the output set. The collection of all possible elements in the input set is
    called the domain, and the collection of all corresponding elements in the output
    set is called the range. *Figure 9**.3* shows four different mapping scenarios.
    The first three are valid mappings based on the definition of a function, while
    the last one fails due to the one-to-many mapping relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Four different mapping scenarios](img/B18680_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Four different mapping scenarios
  prefs: []
  type: TYPE_NORMAL
- en: The first three mappings are valid functions, while the last one is invalid
    due to one-to-many mapping in the last element (3->6 and 3->2).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple names we often use for a function y = f(x) = x 2, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable x can be called an **independent variable**, a **feature**, a **covariate**,
    or an **input**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable y can be called a **dependent variable**, an **outcome**, a **target**,
    a **response**, or an **output**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mapping function f(x) = x 2 can be called a **function**, a **mapping**,
    a **projection**, or a **hypothesis**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 9**.4* summarizes these terms and provides a collection of input-output
    samples with the corresponding graph. Note that the input can be any number or
    expressed as a general variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Illustrating a sample mapping function of ​y = f​(x)​ = ​x​​ 2​​](img/B18680_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Illustrating a sample mapping function of y = f(x) = x 2
  prefs: []
  type: TYPE_NORMAL
- en: Vertical line test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One technique to assess whether a mapping or a curve is a function or not is
    the vertical line test. In particular, any vertical line in the plane can intersect
    the graph of a function at most once. That is, for any function f : A → B, each
    element x ∈ A is mapped to at most one value f(x) ∈ B. *Figure 9**.5* illustrates
    two curves, where the first curve intersects with the vertical line only once
    and thus is a valid function, while the second curve intersects with the vertical
    line twice, thus not satisfying the definition of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Assessing whether a curve is a function using the vertical line
    test](img/B18680_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Assessing whether a curve is a function using the vertical line
    test
  prefs: []
  type: TYPE_NORMAL
- en: Functional symmetry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many special properties a function could have, and functional symmetry
    is one property. For example, a function is called an even function if f(x) =
    f(− x), such as f(x) = |x|, f(x) = x 2, and f(x) = cos(x). A function is called
    an odd function if f(− x) = − f(x), such as f(x) = x 3.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing and decreasing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function can also be increasing or decreasing. A function is increasing on
    the interval [a, b] if f(x 1) > f( x 2) for any x 1 > x 2, and is decreasing on
    the interval [a, b] if f(x 1) < f( x 2) for any x 1 > x 2.
  prefs: []
  type: TYPE_NORMAL
- en: Slope of a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The slope m of a line can be calculated based on any two points ( x 1, y 1)
    and ( x 2, y 2) using the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: m =  y 2 − y 1 _ x 2 − x 1
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the definition of the derivative in *Figure 9**.1*, the derivative
    is essentially the slope of the tangent line at the point x = x 0.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Function composition refers to the case when a function consists of more than
    one nested function, denoted as f(g(x)) = (f ∘ g)(x). The mapping sequence is
    this: the input variable x first gets transformed by function g(x), followed by
    transformation by the function f(x). In f(g(x)), g(x) is the interior function
    and f(x) is the exterior function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given f(x) = 2x − 1, g(x) = x 3, we can obtain f(g(x)) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: f(g(x)) = 2 x 3 − 1
  prefs: []
  type: TYPE_NORMAL
- en: Note that the function composition is not commutative—that is, f(g(x)) ≠ g(f(x)).
  prefs: []
  type: TYPE_NORMAL
- en: Common functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at several types of common functions.
  prefs: []
  type: TYPE_NORMAL
- en: Power function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **power function**, f(x) = k x p, where k and p are constants, and x is
    the variable. k is also called the coefficient. Examples include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cube function: f(x) = x 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Square root function: f(x) = √ _ x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cube root function: f(x) = 3 √ _ x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linear function: f(x) = x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Absolute value function: f(x) = |x|'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Square function: f(x) = x 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polynominal function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **polynomial function**, f(x) = a n x n + a n−1 x n−1 + … + a 1 x + a 0,
    where a n is the leading coefficient. n is a non-negative integer called the degree
    of the polynomial, and the coefficients a 0, … , a n are real numbers with a n
    ≠ 0.
  prefs: []
  type: TYPE_NORMAL
- en: Rational function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **rational function**, f(x) = n(x) _ d(x) , where both n(x) and d(x) are
    polynomials, and d(x) ≠ 0.
  prefs: []
  type: TYPE_NORMAL
- en: Exponential function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **exponential function**, f(x) = b x, where b > 0 and b ≠ 1.
  prefs: []
  type: TYPE_NORMAL
- en: Logarithmic function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **logarithmic function**: f(x) = log bx, where b > 0 and b ≠ 1\. Note that
    when y = log bx, we have the equivalent form of x = b y.'
  prefs: []
  type: TYPE_NORMAL
- en: After getting a quick understanding of the many functions and their properties,
    let us look at the concept of a limit, which relates to the derivative.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The limit of a function f(x) says that when the input x is close but not equal
    to a number c, the value of f(x = c) would be close to a real number L. Mathematically,
    we can express it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: lim x→c f(x) = L
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, equivalently, it could be expressed as f(x) → L as x → c. Note that the
    value of the limit lim x→c f(x) may not necessarily be equal to the value of the
    function at x = c—that is, f(c). Such equality,     lim x→c f(x) = f(c), happens only when f(x) is a continuous function.'
  prefs: []
  type: TYPE_NORMAL
- en: Infinite limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the limit lim x→c f(x) does not exist as x → c, we say that the function
    f(x) tends to infinity and thus leads to an infinite limit as x → c. We can also
    say that x = c is the vertical asymptote of the function f(x).
  prefs: []
  type: TYPE_NORMAL
- en: One example is f(x) =  1 _ x − 1\. We know that the domain is x ≠ 1\. As x →
    1, we have lim x→1  1 _ x − 1 = ∞, which breaks down into approaching from the
    left lim x→1 −  1 _ x − 1 = − ∞ and approaching from the right lim x→1 +  1 _ x
    − 1 = ∞. Both results jointly lead to lim x→1  1 _ x − 1 = ∞, thus lim x→1  1 _ x
    − 1 does not exist. The vertical asymptote is x = 1.
  prefs: []
  type: TYPE_NORMAL
- en: Limit at infinity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The limit at infinity is concerned with the value of f(x) when x → ∞ or x →
    − ∞. This gives the horizontal asymptote of the function—that is, lim x→∞ f(x)
    and  lim x→−∞f(x). We call that y = b is a horizontal asymptote if either lim x→∞ f(x)
    = b or  lim x→−∞f(x) = b.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at a few examples. For the square function f(x) = x 2, we have lim x→∞ x 2
    = ∞ and  lim x→−∞x 2 = ∞. For the square root function f(x) = √ _ x , since the
    domain is x ≥ 0, we have lim x→∞ √ _ x  = ∞. For the natural logarithmic function
    f(x) = lnx, since the domain is x > 0, we have lim x→∞ √ _ x  = ∞. For a general
    result, we have lim x→∞ x p = ∞ and lim x→∞  1 _ x p = ∞.
  prefs: []
  type: TYPE_NORMAL
- en: The next section formally introduces derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a function y = f(x), the derivative of f at x, denoted as f′(x), is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: f ′(x) = lim h→0  f(x + h) − f(x) _ h , if the limit exists.
  prefs: []
  type: TYPE_NORMAL
- en: When f′(x) exists for each value of x in the range [a, b], we say that the function
    f is differentiable over x ∈ [a, b].
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple applications of a derivative. Besides the previous point
    on interpreting the derivative as the slope of the tangent line, the most common
    application is that we can use the derivative to determine if a function is rising/increasing
    or falling/decreasing at a specific point. It also represents the instantaneous
    rate of change, or velocity, at a given point x.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graphical illustration will help our understanding here. *Figure 9**.6* provides
    a sample curve of f(x) with a **secant** line connecting two points (a, f(a))
    and (b, f(b)). Here, a secant line is a straight line that intersects the curve
    of a function at two or more distinct points. We obtain a second point (a + h,
    f(a + h)) by adding a small amount h to the point (a, f(a)). Connecting these
    two points gives the secant line that crosses the function f(x) by these two points.
    As h → 0, the secant line will gradually approach the tangent line obtained at
    x = a. Eventually, the secant line will overlap with the tangent line in the limit,
    and the slope of the secant line, expressed as f(a + h) − f(a) _ h , will become
    the slope of the tangent line when they overlap in the limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – A graph illustrating the derivation of a derivative](img/B18680_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – A graph illustrating the derivation of a derivative
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9**. 6*, the second point (a + h, f(a + h)) is produced by adding
    a small amount h to the point (a, f(a)). Connecting these two points gives the
    secant line. As h → 0, the secant line will gradually approach the tangent line
    at x = a, eventually overlapping with the tangent line in the limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The slope of the secant line, also called the average rate of change, is calculated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: f(a + h) − f(a) _ (a + h) − a  =  f(a + h) − f(a) _ h
  prefs: []
  type: TYPE_NORMAL
- en: 'This is provided that h ≠ 0\. When h → 0, the secant line infinitely approaches
    the tangent line at x = a, giving the instantaneous rate of change at this point
    (provided that the limit exists):'
  prefs: []
  type: TYPE_NORMAL
- en: lim h→0  f(a + h) − f(a) _ h
  prefs: []
  type: TYPE_NORMAL
- en: In general, if y = f(x), we can express the derivative as f′(x), y′,  dy _ dx,
    or  d _ dx f(x).
  prefs: []
  type: TYPE_NORMAL
- en: The following section introduces a few common derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: Common derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we provide a list of derivatives for several common functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constant function:  d _ dx(c) = 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Power function:  d _ dx(x n) = n x n−1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exponential function:  d _ dx(e x) = e x,  d _ dx(b x) = (lnb)b x, b > 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logarithmic function:  d _ dx(lnx) = 1 _ x ,  d _ dx(log bx) =  1 _ (lnb)x,
    b > 0, b ≠ 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sine and cosine functions:  d _ dx(sinx) = cosx,  d _ dx cosx = − sinx'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the derivative often involves multiple basic functions. The next
    section covers a set of properties and rules on derivative calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Common properties and rules of derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We introduce two common properties—the constant multiple property and the sum
    and difference property—followed by three common rules: the product rule, the
    quotient rule, and the chain rule. We assume that all limits exist in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constant multiple property**: For a constant c, if y = f(x) = ch(x), then
    f′(x) = ch′(x). Expressed differently, we have y ′  = ch′, and  dy _ dx = c dh _ dx .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sum and difference property**: If y = f(x) = h(x) ± g(x), then f′(x) = h′(x)
    ± g′(x). Expressed differently, we have y ′  = h ′  + g′, and  dy _ dx = dh _ dx 
    +  dg _ dx.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product rule**: If y = f(x) = h(x)g(x), then f ′ (x) = h ′ (x)g(x) + h(x)g′(x).
    Expressed differently, we have y ′  = h ′ g + hg′, and  dy _ dx = g dh _ dx  +
    h  dg _ dx.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quotient rule**: If y = f(x) = h(x) _ g(x) , then f ′ (x) = g(x)h ′ (x) −
    h(x)g ′ (x) _ [g(x)] 2 . Expressed differently, we have y ′  = gh ′  − hg ′  _ g 2 ,
    and  dy _ dx = g dh _ dx  − h  dg _ dx _ g 2 .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chain rule**: Given a composite function y = f(x) = h(g(x)), we have f′(x)
    = h′(g(x))g′(x). Equivalently, if we have y = h(u) and u = g(x), then  dy _ dx
    =  dy _ du du _ dx .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will switch to integral calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing integral calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integration is the inverse of differentiation. For example, differentiating
    the distance traveling S(t) with respect to time gives the velocity at a specific
    time point v(t). We can calculate the cumulative distance traveled from time t
    = a to t = b as S = ∑ i=0 n−1 v( t i) ∆ t, after dividing the time period into
    n equally spaced intervals. When the number of intervals approaches infinity—that
    is, n → ∞, we have S = lim n→∞ ∑ i=0 n−1 v(t i)Δt = ∫ a b v(t)dt.
  prefs: []
  type: TYPE_NORMAL
- en: The result of integration is called an antiderivative, which allows us to reconstruct
    a function from its derivative. It is the opposite of differentiation. Formally,
    a function F(x) is an antiderivative of f(x) if F ′ (x) = f(x).
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.7* illustrates the equivalence between integration and AUC. We
    can use integration to find the AUC of a general function f(x). This area can
    be obtained by adding slices of rectangles that approach zero width. The width
    of each rectangle is dx, which, by definition, refers to an infinitesimal change
    in x—that is, differential in x:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – A graph illustrating the equivalence between integration and
    AUC](img/B18680_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – A graph illustrating the equivalence between integration and AUC
  prefs: []
  type: TYPE_NORMAL
- en: Note that an integral can be definite or indefinite. A definite integral has
    an explicit starting and ending point of integration. For example, if x ∈ [a,
    b], the definite integral becomes ∫ a b f(x)dx. On the other hand, an indefinite
    integral has no explicit boundary, giving ∫ f(x)dx, which is used to represent
    the family of all antiderivatives of f(x).
  prefs: []
  type: TYPE_NORMAL
- en: The following section delves more into indefinite integrals.
  prefs: []
  type: TYPE_NORMAL
- en: Indefinite integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, we can represent an indefinite integral as ∫ f(x)dx = F(x) + C if
    F ′ (x) = f(x), where C is a constant and appears here to represent a family of
    all antiderivative functions whose derivative is f(x). In other words, we have
     d _ dx[∫ f(x)dx] = f(x) and ∫ F′(x)dx = F(x) + C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us understand the expression of the indefinite integral ∫ f(x)dx a
    bit more. ∫ is the integral symbol, f(x) is the integrand, and dx is a slice along
    x, indicating that the antidifferentiation is performed on x. *Figure 9**.8* illustrates
    the naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Summarizing the naming convention of indefinite integrals](img/B18680_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Summarizing the naming convention of indefinite integrals
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at indefinite integrals of common basic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Indefinite integrals of basic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following list provides the indefinite integrals of basic functions. Again,
    note that the constant C is used to represent a family of all antiderivative functions
    having the same derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ x ndx =  1 _ n + 1 x n+1 + C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∫ e xdx = e x + C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∫ b xdx =  b x _ lnb + C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∫ 1 _ x dx = ln|x| + C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∫ sinxdx = − cosx + C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∫ cosxdx = sinx + C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties of indefinite integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section covers a set of properties that correspond to the derivative function.
    The following two properties are straightforward linear operations:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ Kf(x)dx = K∫ f(x)dx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∫ [f(x) ± g(x)]dx = ∫ f(x)dx ± ∫ f(x)dx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list contains a few general formulas to calculate the indefinite
    integral:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ [f(x)] n f'(x)dx =  [f(x)] n+1 _ n + 1  + C, n ≠ 1
  prefs: []
  type: TYPE_NORMAL
- en: ∫ e f(x) f'(x)dx = e f(x) + C
  prefs: []
  type: TYPE_NORMAL
- en: ∫  1 _ f(x)  f'(x)dx = ln|f(x)| + C
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we introduce one of the most widely used techniques: integration by parts.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration by parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know the following based on the product rule introduced earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: d _ dx [f(x)g(x)] = f ′ (x)g(x) + f(x)g'(x)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then integrate both sides and move terms around to get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ f(x)g'(x)dx = f(x)g(x) − ∫ g(x)f'(x)dx
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives the integration by parts formula. More succinctly, we can define
    v = g(x) and u = f(x). Thus, dv = g ′ (x)dx and du = f ′ (x)dx. The preceding
    equation then becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ udv = uv − ∫ vdu
  prefs: []
  type: TYPE_NORMAL
- en: Next, we delve more into definite integrals.
  prefs: []
  type: TYPE_NORMAL
- en: Definite integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If f(x) is a continuous function on x ∈ [a, b] and F(x) is the antiderivative
    of f(x), that is expressed as F(x) = ∫ f(x)dx + C. The following formula gives
    the fundamental theorem of calculus:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ a bf(x)dx = F(b) − F(a)
  prefs: []
  type: TYPE_NORMAL
- en: This expression says that the AUC f(x) in the range [a, b] can be calculated
    as the difference between evaluations of the antiderivative function F(x) at the
    two endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definite integrals share mostly the same properties as indefinite integrals,
    with the following addition:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ a cf(x)dx = ∫ a bf(x)dx + ∫ b cf(x)dx
  prefs: []
  type: TYPE_NORMAL
- en: The next section will visit the implementation side of things in calculus using
    R.
  prefs: []
  type: TYPE_NORMAL
- en: Working with calculus in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will use the `mosaicCalc` package to perform calculus-related
    operations. The functions we will work with are mostly analytical (have explicit
    expression) and simple in nature. The following code snippet checks if this package
    is installed and will install the package if the condition evaluates to `true`,
    followed by importing the package to the current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To avoid too much imagination, a good way to learn about unknown functions is
    to plot them out. Let us see how to plot a function using the `mosaicCalc` package.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting basic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few input parameters we need to specify upon plotting a function
    using the `mosaicCalc` package. Overall, we need to specify the expression of
    the function, the input variable(s), the domain of each input variable used to
    plot the function, and the values of other parameters set in advance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three common graphing functions for plotting purposes: `slice_plot()`,
    used to plot functions with only one input variable, `contour_plot()`, used to
    plot functions with two input variables, and `interactive_plot()`, used to plot
    interactive graphs. These functions allow us to translate mathematical expressions
    into code and then plots. Let us explore each of them via the following exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.1 – Plotting basic functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise will explore the plotting capabilities of the preceding functions,
    starting with `slice_plot()`. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot the function y = 2x + 1 for x ∈ [ − 5,5] using the `slice_plot()` function,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we put the function expression 2x + 1 on the left of the tilde sign (`~`)
    and the input variable x on the right. We also specify the domain by passing the
    boundaries to the `range()` function. Running this command generates the output
    shown in *Figure 9**.9*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Plotting a straight line using the slice_plot() function](img/B18680_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Plotting a straight line using the slice_plot() function
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also make the function more general by setting the prior parameters
    for the coefficient m and intercept b of the line y = mx + b. This makes the code
    more general since we only need to specify `m` and `b` in the following code snippet
    to plot any straight line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that an error would occur if no initial value for the input parameter
    were set, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we can use the `makeFun()` function to give a name to the function
    to be plotted, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the function is named, we can pass an arbitrary input value to evaluate
    the function. For example, setting x = 2 gives a return of `5`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we look at generating a contour plot for a function with two input variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a contour plot of the equation z = 2x + 3y using the `contour_plot()`
    function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we use the `&` sign to indicate more than one input variable and set
    the corresponding range for both variables. Running this command generates the
    output shown in *Figure 9**.10*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Generating a contour plot of ​z = 2x + 3y​ using the contour_plot()
    function](img/B18680_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Generating a contour plot of z = 2x + 3y using the contour_plot()
    function
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at generating an interactive plot using the `interactive_plot()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate an interactive 3D plot for the same expression using the `interactive_plot()`
    function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 9**.11*. Note that
    the resulting plot is an interactive HTML widget, allowing us to move around and
    displaying auxiliary information upon mouseover:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Generating an interactive 3D plot for ​z = 2x + 3y​ using the
    interactive_plot() function](img/B18680_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Generating an interactive 3D plot for z = 2x + 3y using the interactive_plot()
    function
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers working with derivatives via the differentiation operation
    using the `D()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Working with derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The differentiation operation is completed via the `D()` differentiation operator
    in R, which inputs a single expression and outputs the derivative function. The
    input specifies the same expression as required by the plotting function earlier.
    For example, to specify the function y = x 2 + 1, we can pass `x^2+1 ~ x` to the
    `D()` function, which will then automatically calculate the derivative function
    y ′  = 2x. We can then assign the result to another variable, which serves as
    the derivative function and can be used to evaluate the derivative value at any
    point in the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates the process of obtaining the derivative
    function. The return of the `D()` operator is the derivative function, which is
    y ′  = 2x after printing it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet evaluates two input values. The result shows that
    the `D()` function is able to correctly calculate the derivative function and
    perform an evaluation at an arbitrary input location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `D()` function can carry out the rules mentioned previously upon
    calculating the derivative function. For example, to obtain the derivative of
    y = sin( x 2 − 5), we would invoke the chain rule and calculate the derivative
    as y''= 2xcos( x 2 − 5). The `D()` function completes this for us, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us also verify the quotient rule. In the following code snippet, we pass
    the function y =  2x _ x + 1 to `D()`, which should ideally return the derivative
    function y''= 2(x + 1) − 2x _ (x + 1) 2 . The result shows that this is indeed
    the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next section covers the use of symbolic parameters in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using symbolic parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symbolic parameters offer generality in constructing functions. The same as
    earlier, we can encode the prior values of parameters before passing them to the
    expression of the function. The following exercise illustrates this point.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.2 –Using symbolic parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will look at a general function y = A x 3 + Bx + 3, where
    A and B are constants and x is the only random input variable. The derivative
    function will be y ′  = 3A x 2 + B. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the derivative of the function y = A x 3 + Bx + 3, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that the derivative function is correctly calculated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the derivative function when x = 2, A = 2, and B = 3, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also evaluate the function via multiple points, which amounts to plotting
    the derivative function across a specific range.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Plot the derivative function within the range x ∈ [ − 5,5] with A = 2 and B
    = 3, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 9**.12*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Visualizing the derivative function ​​y ′ ​ = 6 ​x​​ 2​ + 3​](img/B18680_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Visualizing the derivative function y ′  = 6 x 2 + 3
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers the second derivative.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the second derivative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second derivative, expressed as f″(x), is just the derivative of the first
    derivative of the raw function f(x). In the previous example, when y = A x 3 +
    Bx + 3, we have y ′  = 2A x 2 + B. Taking another derivative gives y ″  = 4Ax.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at how to obtain the second derivative via the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.3 – Calculating the second derivative
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this exercise, we will calculate the second derivative of a raw function
    f(x). The second derivative can be considered as differentiating f(x) with respect
    to x twice, giving f ″ (x) = y ″  =  d 2 _ d x 2 f(x). The double differentiation
    is achieved by having two x''s on the right-hand side of the tilde sign. Follow
    the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the second derivative f ″ (x), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result shows that the second derivative of the draw function is correctly
    calculated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the second derivative function by setting when x = 2, A = 2, and B
    = 3, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In fact, since the second derivative function has nothing to do with the parameter
    B, any value of B will render the same result. For example, the following code
    returns the same result even when B = 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot the second derivative function within the range x ∈ [ − 5,5] with A =
    2, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 9**.13*. Here, we
    note that the second derivative function is a straight line as compared to the
    bell-shaped curve of the first derivative function. This straight line represents
    how fast the first derivative function changes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Visualizing the second derivative function ​​y ″ ​ = 12x​](img/B18680_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Visualizing the second derivative function y ″  = 12x
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers more general partial derivative functions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with partial derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second derivative function can be considered a special case of a partial
    derivative function. Assume a two-dimensional function z = f(x, y). The second
    derivative of x is obtained by differentiating x twice. We can also differentiate
    x first and y later, giving  d 2 _ dxdy z or, equivalently,  d 2 _ dydx z. Let
    us see how this works via the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.4 – Calculating the partial derivative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will calculate three different partial derivatives:  d 2 _ d
    x 2 z,  d 2 _ dxdy z (or  d 2 _ dydx z), and  d 2 _ d y 2 z, based on the raw
    function z = A x 2 + Bxy + C y 2\. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the second derivative of z with respect to x. Check whether the result
    is  d 2 _ d x 2 z = 2A:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result shows that the calculation is correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calculate the partial derivative of z with regard to x and then y. Check whether
    the result is  d 2 _ dxdy z = B:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result shows that the calculation is correct. We can also differentiate
    y first and then x. As shown in the following code snippet, this gives the same
    result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the partial derivative of z with respect to x and then y. Check whether
    the result is  d 2 _ d y 2 z = 2C:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result shows that the calculation is correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next section covers calculating integrals, or antiderivatives, using R.
  prefs: []
  type: TYPE_NORMAL
- en: Working with integration in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that differentiation is performed using the `D()` function. Assuming
    y = A x 2 + Bx + 3, we have y ′  = f′(x) = 2Ax + B. We can plot the raw function
    f(x) and its derivative function f′(x) to facilitate the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we create this expression using the `makeFun()`
    function and name the function `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do a simple evaluation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we obtain the derivative function and store the function in `f_prime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a new function derived from the original function. We also do a simple
    evaluation for this function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us plot the raw function f(x) = x 2 + x + 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the command generates the output shown in *Figure 9**.14*. Here, we
    have used the `gf_labs()` function to set the title of the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Visualizing the raw function ​f​(x)​ = ​x​​ 2​ + x + 3​](img/B18680_09_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Visualizing the raw function f(x) = x 2 + x + 3
  prefs: []
  type: TYPE_NORMAL
- en: 'We also plot the derivative function f ′ (x) = 2x + 1 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the command generates the output shown in *Figure 9**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Visualizing the derivative function ​​​f ′ ​​(​​x​)​​ = 2x + 1​​](img/B18680_09_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Visualizing the derivative function f ′ (x) = 2x + 1
  prefs: []
  type: TYPE_NORMAL
- en: 'With the derivative function in place, we can obtain its antiderivative using
    the `antiD()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that the correct form of the original function is recovered, besides the
    additional constant `C` that is added as an additional input argument to the antiderivative
    function with a default value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can evaluate the antiderivative function as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking `A=1`, `B=1`, and `C=0`, the antiderivative function F(x) = x 2 + x
    is visualized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the command generates the output shown in *Figure 9**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Visualizing the derivative function ​​​f ′ ​​(​​x​)​​ = 2x + 1​​](img/B18680_09_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Visualizing the derivative function f ′ (x) = 2x + 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we differentiate the antiderivative function F(x) = A x 2 + Bx + C
    again, we would expect to obtain the same derivative function f(x) = 2Ax + B.
    The following code snippet verifies this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let us pause a moment and look at the relationship between derivative functions
    and their antiderivatives.
  prefs: []
  type: TYPE_NORMAL
- en: More on antiderivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The anti-differentiation operation that produces F(x) = ∫ f'(x)dx + C is the
    reverse of the differentiation that generates f'(x). It represents a family of
    functions, including the original function f(x). These functions are very much
    related to each other. Specifically, the derivative function f'(x), which is a
    derived function, tells the rate of change of the original function f(x) for an
    arbitrary input point x. It gives a local property of f(x) in a microscopic lens,
    measuring the sensitivity of f(x) at the current point.
  prefs: []
  type: TYPE_NORMAL
- en: However, we may not always need to derive f'(x) in every scenario. Sometimes,
    we will work with the derivative function f'(x) as a start, and would be interested
    in deriving the original function—that is, the antiderivative function F(x). This
    gives a global property of the raw function f(x), representing the values accumulated
    within a specific range.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the unknown raw function is called anti-differentiation, or integration.
    The result is called the integral. Depending on whether the integration is evaluated
    on specific boundaries or not, we have an indefinite integral and a definite integral.
  prefs: []
  type: TYPE_NORMAL
- en: 'The integration operation generates a family of anti-derivative functions.
    As in the previous example, the anti-derivative function is F(x) = A x 2 + Bx
    + C. Setting `A=1` and `B=1`, we will obtain different results at the same input
    location for different choices of C, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Although these are different raw functions, they all share the same derivative
    function, as illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The family of antiderivative functions, denoted by F(x) = ∫ f′(x)dx + C, thus
    corresponds to infinitely many functions, including the raw function f(x). These
    infinitely many antiderivative functions are essentially vertical shifts of f(x),
    giving F(x) = f(x) + C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that the derivative function shares the same set of input arguments
    as the original function, as verified in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the antiderivative function requires an additional argument—the constant
    `C`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The next section looks at how to evaluate the definite integral.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the definite integral
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Calculating the definite integral requires evaluating the indefinite integral
    twice: once at the starting point of integration, and once at the end point of
    integration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume the antiderivative function is F(x) = x 2 + x + C for A=1
    and B=1\. To calculate the indefinite integral ∫ 2 3 f′(x)dx, we would evaluate
    F(x) at both x = 2 and x = 3 and take their difference, giving F(3) − F(2). The
    following code snippet shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, one thing to note is that the constant `C` is assumed to be `0` in both
    evaluations. In fact, it does not matter which value it assumes, since the constants
    from both evaluations will always cancel out each other. In other words, we will
    always have a fixed definite integral, despite the indefinite integral corresponding
    to infinitely many values at a specific input point.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of calculus, including differential calculus
    and integral calculus. In the first section, we introduced an intuitive understanding
    of these two branches of calculus and covered the fundamentals of common functions
    and their properties. We started introducing the concept of limit and its connection
    to the definition of a derivative, followed by covering common derivative rules
    and properties. We also discussed integral calculus, including indefinite integrals
    and definite integrals, along with their rules and properties.
  prefs: []
  type: TYPE_NORMAL
- en: The second and third sections touched upon implementations in R. We introduced
    how to carry out common differentiation and integration using the `D()` and `antiD()`
    functions, with several examples illustrating their usage and conversion between
    the derivative function and its antiderivative.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will enter into the realm of mathematical statistics,
    starting with the basics of probability.
  prefs: []
  type: TYPE_NORMAL
