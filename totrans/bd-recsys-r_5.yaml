- en: Chapter 5. Case Study – Building Your Own Recommendation Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous two chapters showed how you how to build, test, and optimize recommender
    systems using R. Although the chapters were full of examples, they were based
    on datasets provided by an R package. The data was structured using redyal and
    was ready to be processed. However, in real life, the data preparation is an important,
    time-consuming, and tough step.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of the previous examples is that they are based on the ratings
    only. In most of the situations, there are other data sources such as item descriptions
    and user profiles. A good solution comes from a combination of all the relevant
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter shows a practical example in which we will build and optimize
    a recommender system, starting from raw data. This chapter will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the data to build a recommendation engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the data through visualization techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing and building a recommendation model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the performance of the recommendation model by setting its parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, we will build an engine that generates recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from raw data, this section will show you how to prepare the input
    for the recommendation models.
  prefs: []
  type: TYPE_NORMAL
- en: Description of the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data is about Microsoft users visiting a website during one week. For each
    user, the data displays which areas the users visited. For the sake of simplicity,
    from now on we will refer to the website areas with the term "items".
  prefs: []
  type: TYPE_NORMAL
- en: There are 5,000 users and they are represented by sequential numbers between
    10,001 and 15,000\. Items are represented by numbers between 1,000 and 1,297,
    even if they are less than 298.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset is an unstructured text file. Each record contains a number of
    fields between 2 and 6\. The first field is a letter defining what the record
    contains. There are three main types of records, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute (A)**: This is the description of the website area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case (C)**: This is the case for each user, containing its ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vote (V)**: This is the vote lines for the case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each case record is followed by one or more votes, and there is just one case
    for each user.
  prefs: []
  type: TYPE_NORMAL
- en: Our target is to recommend each user to explore some areas of the website that
    they haven't explored yet.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will show you how to import data. First, let''s load the packages
    that we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is explained in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data.table`: This manipulates the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ggplot2`: This builds charts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recommenderlab`: This builds recommendation engines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`countrycode`: This package contains the country names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, let''s load the table into memory. If the text file is already in our
    working directory, it''s enough to define its name. Otherwise, we need to define
    its full path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The rows contain different numbers of columns, which means that the data is
    unstructured. However, there are at most six columns, so we can load the file
    into a table using `read.csv`. The rows with fewer than six fields will have just
    empty values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| V1 | V2 | V3 | V4 | V5 | V6 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `I` | `4` | `www.microsoft.com` | `created by getlog.pl` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | `1` | `VRoot` | `0` | `0` | `VRoot` |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | `0` | `0` |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | `1` | `1` |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | `2` | `Hide1` | `0` | `0` | `Hide` |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | `0` | `0` |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: 'The first two columns contain the user IDs and their purchases. We can just
    drop the other columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to process the data more easily, we can convert it into a data table,
    using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The columns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`category`: This is a letter specifying the content of the column. The columns
    containing a user or an item ID belong to the categories C and V, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This is a number specifying the user or item ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can assign the column names and select the rows containing either users
    or items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| category | value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | `10001` |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | `1038` |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | `1026` |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | `1034` |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | `10002` |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | `1008` |'
  prefs: []
  type: TYPE_TB
- en: The `table_users` object contains structured data, which is our starting point
    to define a rating matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a rating matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our target is to define a table having a row for each item and a column for
    each purchase. For each user, `table_users` contains its ID and purchases in separate
    rows. In each block or rows, the first column contains the user ID and the other
    contains the item IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following steps to define a rating matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: Label the cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a table in the long format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a table in the wide format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the rating matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to reshape the table, the first step is to define a field called `chunk_user`
    containing an incremental number for each user. The `category == "C"` condition
    is true for the user rows, which are the first rows of the chunks. Using `cumsum`,
    we are incrementing the index of 1 whenever there is a row with a new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| category | value | chunk_user |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | `10001` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | `1038` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | `1026` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | `1034` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | `10002` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | `1008` | `2` |'
  prefs: []
  type: TYPE_TB
- en: 'The next step is to define a table in which rows correspond to the purchases.
    We need a column with the user ID and a column with the item ID. The new table
    is called `table_long`, because it''s in a `long` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| chunk_user | user | item |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `10001` | `1038` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `10001` | `1026` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `10001` | `1034` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `10002` | `1008` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `10002` | `1056` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `10002` | `1032` |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we can define a table having a row for each user and a column for each
    item. The values are equal to 1 if the item has been purchased, and 0 otherwise.
    We can build the table using the `reshape` function. Its inputs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: This is the table in the `long` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direction`: This shows whether we are reshaping from long to wide or otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idvar`: This is the variable identifying the group, which, in this case, is
    the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timevar`: This is the variable identifying the record within the same group.
    In this case, it''s the item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v.names`: This is name of the values. In this case, it''s the rating that
    is always equal to one. Missing user-item combinations will be NA values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After defining the column `value` equal to `1`, we can build `table_wide` using
    `reshape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| chunk_user | user | value.1038 | value.1026 | value.1034 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `10001` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `10002` | `NA` | `NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `10003` | `1` | `1` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `10004` | `NA` | `NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `10005` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `6` | `10006` | `NA` | `NA` | `1` |'
  prefs: []
  type: TYPE_TB
- en: 'In order to build the rating matrix, we need to keep only the columns containing
    ratings. In addition, the user name will be the matrix row names, so we need to
    store them in the `vector_users` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to have the column names equal to the item names, we need from the
    `value` prefix. For this purpose, we can use the `substring` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to store the rating matrix within a `recommenderlab` object. For this
    purpose, we need to convert `table_wide` in a matrix first. In addition, we need
    to set the row names equal to the user names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| user | 1038 | 1026 | 1034 | 1008 | 1056 | 1032 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **10001** | `1` | `1` | `1` | `NA` | `NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| **10002** | `NA` | `NA` | `NA` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| **10003** | `1` | `1` | `NA` | `NA` | `NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| **10004** | `NA` | `NA` | `NA` | `NA` | `NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| **10005** | `1` | `1` | `1` | `1` | `NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| **10006** | `NA` | `NA` | `1` | `NA` | `NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: 'The last step is coercing `matrix_wide` into a binary rating matrix using `as`,
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the matrix using `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the binary rating matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a rating matrix](img/B03888_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, the matrix is sparse. We can also visualize the distributions
    of the number of users purchasing an item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays the distribution of the number of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a rating matrix](img/B03888_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are some outliers, that is, items purchased by many users. Let''s visualize
    the distribution excluding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays the distribution of the numbers of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a rating matrix](img/B03888_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many items that have been purchased by a few users only, and we won''t
    recommend them. Since they increase the computational time, we can just remove
    them by defining a minimum number of purchases, for example, `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have 166 items, compared to the initial 236\. As regards users, we
    want to recommend items to everyone. However, there might be users that have purchased
    only items that we removed. Let''s check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are 15 users with no purchases. These purchases should be removed. In
    addition, users who have purchased just a few items are difficult to deal with.
    Therefore, we only keep users that have purchased at least five items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Extracting item attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `table_in` raw data contains some records starting with `A`, and they display
    some information about the items. In order to extract these records, we can convert
    `table_in` into a data table and extract the rows having `A` in the first column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| V1 | V2 | V3 | V4 | V5 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | `1277` | `1` | `NetShow for PowerPoint` | `/stream` |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | `1253` | `1` | `MS Word Development` | `/worddev` |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | `1109` | `1` | `TechNet (World Wide Web Edition)` | `/technet` |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | `1038` | `1` | `SiteBuilder Network Membership` | `/sbnmember` |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | `1205` | `1` | `Hardware Supprt` | `/hardwaresupport` |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | `1076` | `1` | `NT Workstation Support` | `/ntwkssupport` |'
  prefs: []
  type: TYPE_TB
- en: 'The relevant columns are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**V2**: Item ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**V4**: Item description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**V5**: Web page URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to have a more clear table, we can extract and rename them. In addition,
    we can sort the table by item ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| id | description | url |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1000` | `regwiz` | `/regwiz` |'
  prefs: []
  type: TYPE_TB
- en: '| `1001` | `Support desktop` | `/support` |'
  prefs: []
  type: TYPE_TB
- en: '| `1002` | `End user produced view` | `/athome` |'
  prefs: []
  type: TYPE_TB
- en: '| `1003` | `Knowledge base` | `/kb` |'
  prefs: []
  type: TYPE_TB
- en: '| `1004` | `Microsoft.com search` | `/search` |'
  prefs: []
  type: TYPE_TB
- en: '| `1005` | `Norway` | `/norge` |'
  prefs: []
  type: TYPE_TB
- en: 'We need to identify one or more features describing the items. If we look at
    the table, we can identify two categories of web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geographic location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can identify the records containing a geographic location, and consider
    the remaining as products. For this purpose, we can start defining the field `category`
    that, at the moment, is equal to `product` for all the records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The country code package provides us with the `countrycode_data` object that
    contains most of the country names. We can define the `name_countries` vector
    that contains the names of countries and geographic locations. Then, we can categorize
    as `region` all the records whose description is in `name_countries`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other records containing the word `region`. We can identify them
    through a regular expression using `grepl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| V2 | description | url | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1000` | `regwiz` | `/regwiz` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1001` | `Support Desktop` | `/support` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1002` | `End User Produced View` | `/athome` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1003` | `Knowledge Base` | `/kb` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1004` | `Microsoft.com Search` | `/search` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1005` | `Norway` | `/norge` | `region` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s take a look at the result and find out the number of items we have for
    each category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| category | n_items |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `product` | `248` |'
  prefs: []
  type: TYPE_TB
- en: '| `region` | `46` |'
  prefs: []
  type: TYPE_TB
- en: About 80 percent of the web pages are products, and the remaining 20 percent
    are regions.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to build recommendation models.
  prefs: []
  type: TYPE_NORMAL
- en: Building the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will show you how to build a recommendation model using item descriptions
    and user purchases. The model combines item-based collaborative filtering with
    some information about the items. We will include the item description using a
    monolithic hybrid system with feature combination. The recommender will learn
    from the two data sources in two separate stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the approach described in [Chapter 3](ch03.html "Chapter 3. Recommender
    Systems"), *Recommender Systems*, let''s split the data into the training and
    the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can build an IBCF model using `Recommender`. Since the rating matrix
    is binary, we will set the distance method to `Jaccard`. For more details, look
    at the *Collaborative filtering on binary data* section in [Chapter 3](ch03.html
    "Chapter 3. Recommender Systems"), *Recommender Systems*. The remaining parameters
    are left to their defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The engine of IBCF is based on a similarity matrix about the items. The distances
    are computed from the purchases. The more the number of items purchased by the
    same users, the more similar they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract the matrix from the `sim` element in the slot model. Let''s
    take a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The matrix belongs to the `dgCMatrix` class, and it is square. We can visualize
    it using `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the model](img/B03888_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can''t identify any clear pattern, and it''s because the items are not sorted.
    Let''s take a look at the range of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: All the distances are between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our target is to combine the distance matrix with the item descriptions, via
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a similarity matrix based on the purchases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a similarity matrix based on the item descriptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine the two matrices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Starting from `recc_model`, we can define the purchases similarity matrix.
    All we need to do is to convert the `dgCMatrix` object into `matrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to build the matrix based on item descriptions, we can use the `dist`
    function. Given that it''s based on a category column only, the distance will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1, if the two items belong to the same category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0, if the two items belong to different categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to build a similarity matrix, and we have a distance matrix. Since
    distances are between 0 and 1, we can just use `1 - dist()`. All the operations
    are performed within the data table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dist_category` raw data is a `dist` object that can be easily converted
    into a matrix using the `as()` function :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare the dimensions of `dist_category` with `dist_ratings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `dist_category` table has more rows and columns, and the reason is that
    it contains all the items, whereas `dist_ratings` contains only the ones that
    have been purchased.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to combine `dist_category` with `dist_ratings`, we need to have the
    same items. In addition, they need to be sorted in the same way. We can match
    them using the item names using these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that both the matrices have the item names in their row and column
    names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the row and column names from `dist_ratings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subset and order `dist_category` according to the names of `dist_ratings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `dist_ratings` table already contains the row and column names. We need
    to add them to `dist_category`, starting from `table_items`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s sufficient to extract the names from `dist_ratings` and subset `dist_category`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether the two matrices match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is identical, so they match. Let''s take a look at `dist_category`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the model](img/B03888_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The matrix contains only 0s and 1s, and it's based on two categories, so there
    are clear patterns. In addition, we can notice that the matrix is symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to combine the two tables, and we can do it with a weighted average.
    Since `dist_category` takes account of two categories of items only, it''s better
    not to give it too much relevance. For instance, we can set its weight to 25 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `dist_tot` matrix using `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the model](img/B03888_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see some white dots representing items that are very similar. In addition,
    we can still see the patterns of `dist_category` in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can include the new matrix within `recc_model`. For this purpose, it''s
    sufficient to convert `dist_tot` into `dgCMatrix` and insert it in `recc_model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in [Chapter 3](ch03.html "Chapter 3. Recommender Systems"), *Recommender
    Systems*, we can recommend items using `predict()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `itemLabels` slot of `recc_predicted` contains the item names, that is,
    their code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to display the item description, we can use `table_items`. All we
    need to do is make sure that the items are ordered in the same way as `itemLabels`.
    For this purpose, we will prepare a data frame containing the item information.
    We will also make sure that it''s sorted in the same way as the item labels using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a data frame having a column with the ordered item labels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Left-join between `table_labels` and `table_items`. Note the argument `sort
    = FALSE` that does not let us re-sort the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the description from factor to character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at `table_labels`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '| id | description | url | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1038` | `SiteBuilder Network Membership` | `/sbnmember` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1026` | `Internet Site Construction for Developers` | `/sitebuilder` | `product`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `1034` | `Internet Explorer` | `/ie` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1008` | `Free Downloads` | `/msdownload` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1056` | `sports` | `/sports` | `product` |'
  prefs: []
  type: TYPE_TB
- en: '| `1032` | `Games` | `/games` | `product` |'
  prefs: []
  type: TYPE_TB
- en: 'As expected, the table contains the description of the items. Now, we are able
    to extract the recommendations. For instance, we can do it for the first user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Windows family of OSs, Support Desktop, Knowledge Base, Microsoft.com Search,
    Products, and Windows 95.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can define a table with the recommendations to all users. Each column
    corresponds to a user and each row to a recommended item. Having set `n_recommended`
    to `10`, the table should have 10 rows. For this purpose, we can use `sapply()`
    For each element of `recc_predicted@items`, we identify the related item descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the number of recommended items per user is a number between 1 and
    10, which is not the same for each user. In order to define a structured table
    with 10 rows, we need the same number of elements for each user. For this reason,
    we will replace the missing recommendations with empty strings. We can obtain
    it by replicating the empty string with `rep()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the recommendations for the first three users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '| Windows family of OSs | Products | Developer workshop |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Support Desktop | MS Word | SiteBuilder Network Membership |'
  prefs: []
  type: TYPE_TB
- en: '| Knowledge Base | isapi | isapi |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft.com Search | regwiz | Microsoft.com Search |'
  prefs: []
  type: TYPE_TB
- en: '| Products | Windows family of OSs | Windows Family of OSs |'
  prefs: []
  type: TYPE_TB
- en: '| Windows 95 | Microsoft.com Search | Web Site Builder''s Gallery |'
  prefs: []
  type: TYPE_TB
- en: 'We can notice that some items have been recommended to the three of them: Products
    and Support Desktop. Therefore, we suspect that some items are much more likely
    to be recommended.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we did in [Chapter 3](ch03.html "Chapter 3. Recommender Systems"),
    *Recommender Systems*, we can explore the output. For each item, we can count
    how many times it has been recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to visualize the result, we `bin_recomm_per_item` using `cut()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `qplot`, we can visualize the `recomm_per_item` distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays the recommendations per item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the model](img/B03888_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the items have been recommended 10 times or fewer, and a few of them
    have more than 100 recommendations. The distribution has a long tail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also identify the most popular items by sorting `recomm_per_item`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '| name | n_recomm |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Internet Explorer` | `126` |'
  prefs: []
  type: TYPE_TB
- en: '| `Windows Family of OSs` | `120` |'
  prefs: []
  type: TYPE_TB
- en: '| `Knowledge Base` | `118` |'
  prefs: []
  type: TYPE_TB
- en: '| `Products` | `115` |'
  prefs: []
  type: TYPE_TB
- en: In this section, we built and explored a hybrid recommender model. The next
    step is to evaluate it and optimize its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating and optimizing the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will show you how to evaluate the performance of our recommender.
    Starting from the evaluation, we can try some parameter configurations and choose
    the one performing the best. For more details, see [Chapter 4](ch04.html "Chapter 4. Evaluating
    the Recommender Systems"), *Evaluating the Recommender Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to evaluate and optimize the model:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a function that evaluates the model given a parameter configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the function to test different parameter configurations and pick the best
    one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go through these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Building a function to evaluate the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will show you how to define a function that:'
  prefs: []
  type: TYPE_NORMAL
- en: Sets up cross validation using the *k*-fold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Builds a hybrid IBCF.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recommends the items to the users in the test sets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluates the recommendation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The inputs of our function are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**: This is the rating matrix table with the item description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**k-fold parameters**: This is the number of folds, the number of items to
    keep in the test set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model parameters**: This is the number of nearest neighbors, weight to the
    description-based distance, number of items to recommend'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define the function arguments. You can find the description of each
    argument as a comment next to its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can walk through the function body step by step. For a more detailed
    explanation, see the previous section and [Chapter 4](ch04.html "Chapter 4. Evaluating
    the Recommender Systems"), *Evaluating the Recommender Systems*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `evaluationScheme()` function, set-up a *k*-fold. The parameters
    *k* and given are set according to the inputs `n_fold` and `items_to_keep`, respectively.
    The `set.seed(1)` command makes sure that the example is reproducible, that is,
    the random component will be the same if repeated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `Recommender()`, build an IBCF defining the distance function as `Jaccard`
    and the *k* argument as the `number_neighbors` input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract the rating-based distance matrix from the `recc_model` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Starting from the `table_items` input, define the description-based distance
    matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the distance matrix combining `dist_ratings` and `dist_category`. The
    combination is a weighted average, and the weight is defined by the `weight_description`
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Predict the test set users with known purchases. Since we are using a table
    with 0 and 1 ratings only, we can specify that we predict the top `n` recommendations
    with the argument `type = "topNList"`. The argument `n`, defining the number of
    items to recommend, comes from the `items_to_recommend` input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluate the model performance using `calcPredictionAccuracy()`. Specifying
    `byUser = FALSE`, we have a table with the average indices such as precision and
    recall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function output is the `eval_accuracy` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can test our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '| index | value |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `TP` | `2` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `FP` | `8` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `FN` | `1` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `TN` | `145` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `precision` | `19%` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `recall` | `64%` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `TPR` | `64%` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `FPR` | `5%` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: You can find a detailed description of the indices in [Chapter 4](ch04.html
    "Chapter 4. Evaluating the Recommender Systems"), *Evaluating the Recommender
    Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we defined a function evaluating our model with given settings.
    This function will help us with parameter optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the model parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with our `evaluateModel()` function, we can optimize the model parameters.
    In this section, we will optimize these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number_neighbors`: This is the number of nearest neighbors of IBCF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weight_description`: This is the weight given to the description-based distance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we could optimize other parameters, we will just leave them to their
    defaults, for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Our recommender model combines IBCF with the item descriptions. Therefore, it's
    a good practice to optimize IBCF first, that is, the `number_neighbors` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to decide which values we want to test. We take account of k,
    that is, at most, half of the items, that is, about `80`. On the other hand, we
    exclude values that are smaller than 4, since the algorithm would be too unstable.
    Setting a granularity of `2`, we can generate a vector with the values to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can measure the performance depending on `number_neighbors`. Since
    we are optimizing the IBCF part only, we will set weight_`description = 0`. Using
    `lapply`, we can build a list of elements that contain the performance for each
    value of `nn_to_test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the first element of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '| name | value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TP` | `1.663` |'
  prefs: []
  type: TYPE_TB
- en: '| `FP` | `8.337` |'
  prefs: []
  type: TYPE_TB
- en: '| `FN` | `1.683` |'
  prefs: []
  type: TYPE_TB
- en: '| `TN` | `144.3` |'
  prefs: []
  type: TYPE_TB
- en: '| `precision` | `0.1663` |'
  prefs: []
  type: TYPE_TB
- en: '| `recall` | `0.5935` |'
  prefs: []
  type: TYPE_TB
- en: '| `TPR` | `0.5935` |'
  prefs: []
  type: TYPE_TB
- en: '| `FPR` | `0.05449` |'
  prefs: []
  type: TYPE_TB
- en: The first element contains all the performance metrics. In order to evaluate
    our model, we can use the precision and recall. See [Chapter 4](ch04.html "Chapter 4. Evaluating
    the Recommender Systems"), *Evaluating the Recommender Systems* for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract a vector of precisions (or recalls) using `sapply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to analyze the output, we can define a table whose columns are `nn_to_test`,
    precisions, and recalls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we can define a performance index that we will optimize. The performance
    index can be a weighted average between the precision and the recall. The weights
    depend on the use case, so we can just leave them to 50 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '| nn | precision | recall | performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `0.1663` | `0.5935` | `0.3799` |'
  prefs: []
  type: TYPE_TB
- en: '| `6` | `0.1769` | `0.621` | `0.399` |'
  prefs: []
  type: TYPE_TB
- en: '| `8` | `0.1769` | `0.5973` | `0.3871` |'
  prefs: []
  type: TYPE_TB
- en: '| `10` | `0.175` | `0.5943` | `0.3846` |'
  prefs: []
  type: TYPE_TB
- en: '| `12` | `0.174` | `0.5909` | `0.3825` |'
  prefs: []
  type: TYPE_TB
- en: '| `14` | `0.1808` | `0.6046` | `0.3927` |'
  prefs: []
  type: TYPE_TB
- en: The precision is the percentage of recommended items that have been purchased,
    and the recall is the percentage of purchased items that have been recommended.
  prefs: []
  type: TYPE_NORMAL
- en: The `table_performance` table contains all the evaluation metrics. Starting
    with it, we can build charts that help us identify the optimal `nn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before building the charts, let''s define the `convertIntoPercent()` function
    that we will use within the `ggplot2` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to build the charts. The first chart is about the precision based
    on `nn`. We can build it using these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qplot`: This builds the scatterplot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geom_smooth`: This adds a smoothing line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale_y_continuous`: This changes the `y` scale. In our case, we just want
    to display the percentage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command consists of the preceding points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing the model parameters](img/B03888_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The smoothed line grows until the global maximum, which is around `nn = 35`,
    slowly decreases. This index expresses the percentage of recommendations that
    have been successful, so it's useful when there are high costs associated with
    advertising.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the recall, using the same commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is the output of the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing the model parameters](img/B03888_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The maximum recall is around `nn = 40`. This index expresses the percentage
    of purchases that we recommended, so it's useful if we want to be sure to predict
    most of the purchases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance takes account of the precision and the recall at the same time.
    Let''s take a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![Optimizing the model parameters](img/B03888_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The optimal performances are between 30 and 45\. We can identify the best `nn`
    using `which.max`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The optimal value is `34`. We optimized the IBCF parameter, and the next step
    is determining the weight of the item description component. First, let''s define
    the weights to try. The possible weights range between 0 and 1, and we just need
    to set the granularity, for instance, `0.05`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `lapply`, we can test the recommender based on the weight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we did earlier, we can build a table containing precisions, recalls,
    and performances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can visualize the performance based on the weight through a chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing the model parameters](img/B03888_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The performance is the same for each point, with the exception of the extremes.
    Therefore, the smoothing line is not useful.
  prefs: []
  type: TYPE_NORMAL
- en: We have the best performance that takes account of both ratings and descriptions.
    The extreme **0.00** corresponds to pure IBCF, and it performs slightly worse
    than the hybrid. The model in the extreme **1.00** is based on the item description
    only, and that's why it performs so badly.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why the performance doesn't change much is that the item description
    is based on a binary feature only. If we add other features, we will see a greater
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: This section showed you how to optimize our recommendation algorithm on the
    basis of two parameters. A next step could be optimizing on the basis of the remaining
    IBCF parameters and improving the item description.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed you how to apply the techniques in a real-life context.
    Starting with raw unstructured data, we built a rating matrix, which is the input
    of collaborative filtering. In addition, we extracted the item description, which
    improved the performance of our model. Using performance evaluations, we optimized
    the model parameters. The same approach can be applied in real-life contexts,
    if properly refined.
  prefs: []
  type: TYPE_NORMAL
- en: This book is a path that shows, first, the basics of machine learning and then
    a practical application. After having read this book, you will be able to deal
    with real-life challenges, identifying the most appropriate recommendation solution.
    Thank you for following until this point.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any queries, don't hesitate to contact us.
  prefs: []
  type: TYPE_NORMAL
