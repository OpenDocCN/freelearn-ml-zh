- en: Chapter 8. Querying Structured Data in a Natural Way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 以自然方式查询结构化数据
- en: In the previous chapter, we learned how we can use the current context to extend
    our knowledge on a certain topic. Throughout this chapter, we will continue discussing
    about the knowledge APIs. More specifically, we will learn how to explore relationships
    between academic papers and journals. We will see how we can interpret natural
    language queries, and retrieve query expressions. Using these expressions, we
    will learn how to find academic entities. We will then focus more on how to set
    up this kind of service on your own. At the end of this chapter, we will look
    at QnA Maker to see how we can create FAQ services from existing content.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何利用当前上下文来扩展我们对某个主题的知识。在本章中，我们将继续讨论关于知识API的内容。更具体地说，我们将学习如何探索学术论文和期刊之间的关系。我们将看到如何解释自然语言查询，并检索查询表达式。使用这些表达式，我们将学习如何找到学术实体。然后，我们将更多地关注如何在个人设置中建立此类服务。在本章结束时，我们将探讨QnA
    Maker，看看如何从现有内容中创建FAQ服务。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Interpreting natural-language user queries using Project Academic Knowledge
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目学术知识解释自然语言用户查询
- en: Assisting the user with queries using autocomplete features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动完成功能协助用户进行查询
- en: Using autocomplete queries to retrieve academic entities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动完成查询检索学术实体
- en: Calculating the distribution of academic entities from queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从查询中计算学术实体的分布
- en: Hosting the Project Knowledge Exploration Service with your own schema
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自己的模式托管项目知识探索服务
- en: Creating an FAQ service from existing content using QnA Maker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QnA Maker从现有内容创建FAQ服务
- en: Tapping into academic content using the academic API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用学术API获取学术内容
- en: '**Microsoft Academic Graph** (**MAG**) is a knowledge base for web-scale, heterogeneous
    entity graphs. Entities model scholarly activities, and contain information such
    as the field of study, author(s), institution, and more.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft Academic Graph** (**MAG**) 是一个用于网络规模、异构实体图的数据库。实体模型了学术活动，并包含诸如研究领域、作者、机构等信息。'
- en: Data contained in MAG is indexed from the Bing web index. As this is continuously
    indexed, the data is always up to date.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MAG中的数据是从Bing网络索引中索引的。由于这些数据持续被索引，因此数据始终是最新的。
- en: Using the Project Academic Knowledge API, we can tap into this knowledge base.
    This API allows us to combine search suggestions, research paper graph search
    results, and histogram distributions. The API enables a knowledge-driven and interactive
    dialog.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用项目学术知识API，我们可以访问这个知识库。此API允许我们结合搜索建议、研究论文图搜索结果和直方图分布。该API支持知识驱动和交互式对话。
- en: When a user searches for research papers, the API can provide query completion.
    It may suggest queries based on the input. With a complete query, we can evaluate
    a query expression. This will retrieve a set of matching paper entities from the
    knowledge base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户搜索研究论文时，API可以提供查询补全。它可能会根据输入建议查询。使用完整的查询，我们可以评估查询表达式。这将从知识库中检索一组匹配的论文实体。
- en: Setting up an example project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置示例项目
- en: To test Project Academic Knowledge, we will first want to create a new example
    project. We will create this from the MVVM template created in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Microsoft Cognitive Services"), *Getting Started
    with Microsoft Cognitive Services*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试项目学术知识，我们首先需要创建一个新的示例项目。我们将从[第1章](ch01.html "第1章. 使用Microsoft认知服务入门")中创建的MVVM模板开始，即*使用Microsoft认知服务入门*。
- en: Project Academic Knowledge does not have any client packages available. This
    means that we need to call the API ourselves. Copy the `WebRequest.cs` file from
    the `Model` folder in the smart house application and paste it into the `Model`
    folder of the newly created project. Make sure that you correct the namespace.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 项目学术知识没有提供任何客户端包。这意味着我们需要自己调用API。从智能家居应用程序的`Model`文件夹中复制`WebRequest.cs`文件，并将其粘贴到新创建的项目中的`Model`文件夹中。确保您已正确修改命名空间。
- en: To be able to compile this, we will need to add references to `System.Web` and
    `System.Runtime.Serializable`. We will also be working with JSON, so go ahead
    and add the `Newtonsoft.Json` package through the NuGet package manager.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够编译此内容，我们需要添加对`System.Web`和`System.Runtime.Serializable`的引用。我们还将处理JSON，因此请通过NuGet包管理器添加`Newtonsoft.Json`包。
- en: As this will be the only API tested in this sample project, we can add UI elements
    in the `MainView.xaml` file. Open this file now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Our `View` should have a `TextBox` element for our input query. It should have
    a `ComboBox` element to list the suggested query expressions. We need three `Button`
    elements, one for `Interpret`, one for `Evaluate`, and one for `Histogram`, which
    are all functions we will be executing. Last but not least, we need a `TextBox`
    element to display our results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In the `MainViewModel.cs` file, we will need to add corresponding properties.
    Add three `string` properties, one for the input query, one for the results, and
    one for the selected query expression. Add an `ObservableCollection` property
    of the `string` type for our available query expressions. We also need three `ICommand`
    properties, one for each of our buttons.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a private member for our `WebRequest` object. Make the constructor look
    like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have not already done so, sign up for an API key at [https://labs.cognitive.microsoft.com/en-us/project-academic-knowledge](https://labs.cognitive.microsoft.com/en-us/project-academic-knowledge)
    and click the **Subscribe** button.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The `CanInterpret` parameter should return `true` if we have entered any text
    into the query textbox. The `CanExecuteCommands` parameter should return `true`
    if we have selected a query expression. We will cover `Interpret`, `Evaluate`,
    and the `CalculateHistogram` parameters in the upcoming sections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the application compiles and runs before continuing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting natural language queries
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The query expressions that the API uses to evaluate a query are not in a natural
    language format. To ensure that users can make queries in a natural way, we need
    to interpret their input.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: When calling the `Interpret` feature of the API, it accepts a query string.
    This will be returned and formatted to reflect the user intent using academic
    grammar. In addition, this feature can be called as the user is writing, to provide
    an interactive experience.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The request is a `GET` request, as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We start the call by creating a `queryString` variable. The parameters we can
    input are specified in the following table:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `query` (required) | The query from the user. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `complete` (optional) | If this is set to `1`, then the service will return
    suggestions using the query as a prefix. A value of `0` means there will be no
    autocomplete. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `count` (optional) | The maximum number of interpretations to return. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `offset` (optional) | The index of the first interpretation. This is useful
    if a lot of results are expected and you need to add pagination. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `timeout` (optional) | The timeout specified in milliseconds. Only results
    found before this limit will be returned. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `model` (optional) | The name of the model you want to query. This defaults
    to the latest model. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: 'We call the API to get interpretations, as shown in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As this is a `GET` request, we do not need to specify any request bodies. We
    do, however, expect a result to be serialized into an `InterpretResponse` object.
    This is a data contract, containing properties from the result.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call to the API will result in a JSON response, which looks as
    follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result contains the original `query`. It also contains an array with `interpretations`.
    Each item in this array consists of the data shown in the following table:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '| Data field | Description |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `prob` | This is the probability of the current interpretation being correct.
    The scale goes from `0` to `1`, where `1` is the highest. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `parse` | This is an XML string showing interpretations for each part of
    the string. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `rules` | This is an array with one or more rules defined. There will always
    be one rule for the academic API. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `rules[x].name` | This is the name of the current rule. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `rules[x].output` | This is the output of the current rule. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `rules[x].output.type` | This is the type of the rule output. This will always
    be `query` for the academic API. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| `rules[x].output.value` | This is the output value for the rule. This will
    be a query expression string. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: Create the `InterpretResponse` data contract based on the preceding JSON output.
    We are interested in the last data field, `rules[x].output.value`. This is the
    query expression string, which we will use to evaluate queries.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'When the API call has succeeded, we want to update the `ObservableCollection`
    class as to the available query expressions, using the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We loop through all `interpretations`, adding the `outputvalue` from a rule
    to our `AvailableQueryExpressions`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the selected `QueryExpression` as the first one available. This
    is just for our own convenience.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful test run can generate the following results:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpreting natural language queries](img/B12373_08_01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'An unsuccessful call will produce an error response code. The response codes
    that can be generated are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '| Response code | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `400` | Bad argument; request parameter is missing |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `401` | Invalid subscription key |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `403` | The call volume quota has been exceeded |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `404` | The requested resources are not found |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `500` | Internal server error |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: Finding academic entities in query expressions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a query expression available, we can retrieve a set of academic
    entities using the `Evaluate` endpoint. This is a `GET` request, where we need
    to specify the attributes we want returned for each entity. We will cover the
    available attributes later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a query string, as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The parameters we can add are described in the following table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `expr` (required) | This is the query expression found in the `Interpret`
    call. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| `attributes` (optional) | This is a comma-separated list of attributes to
    be included in the response. Each attribute is case-sensitive. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `attributes` (可选) | 这是要包含在响应中的属性逗号分隔列表。每个属性都是大小写敏感的。 |'
- en: '| `model` (optional) | This is the model you wish to use for a query. This
    defaults to the latest model. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `model` (可选) | 这是要用于查询的模型。默认为最新模型。 |'
- en: '| `count` (optional) | This is the number of entities to return. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `count` (可选) | 这是要返回的实体数量。 |'
- en: '| `offset` (optional) | This is the index of the first result to return; it
    can be useful for pagination purposes. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `offset` (可选) | 这是要返回的第一个结果的索引；它可以用于分页目的。 |'
- en: '| `orderby` (optional) | This specifies the order in which to sort the entities.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `orderby` (可选) | 这指定了排序实体的顺序。 |'
- en: Note that, while the `attributes` parameter is optional, you should specify
    which attributes you want. If none are specified, only the entity ID is returned.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然 `attributes` 参数是可选的，但您应该指定您想要的属性。如果没有指定任何属性，则只返回实体 ID。
- en: 'We call the API, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式调用 API：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As this is a `GET` request, we do not need any request bodies. With a successful
    call, we expect an `EvaluateResponse` object in return. This is a data contract,
    which will be deserialized from the JSON response.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 `GET` 请求，我们不需要任何请求体。成功的调用将返回一个 `EvaluateResponse` 对象。这是一个数据合约，它将从 JSON
    响应反序列化。
- en: 'A successful response will give a JSON response like the following code (depending
    on the attributes specified):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的响应将给出如下代码所示的 JSON 响应（取决于指定的属性）：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The response contains the query expression we used. It also contains an array
    of entities. Each item in this array will contain the probability of it being
    correct. It will also contain all the attributes that we specified, in the form
    of either string or numeric values. It can also be in the form of objects, which
    we will need to have data contracts for.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含我们使用的查询表达式。它还包含一个实体数组。数组中的每个项目将包含它正确的概率。它还将包含我们指定的所有属性，以字符串或数值形式呈现。它也可以是对象的形式，我们需要为这些对象提供数据合约。
- en: 'For our request, we specified some attributes. These were the entity ID, title,
    year and date of publication, citation count, and author name. Knowing these attributes,
    we can use the following code to output the result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的请求，我们指定了一些属性。这些是实体 ID、标题、出版年份和日期、引用次数和作者姓名。了解这些属性后，我们可以使用以下代码来输出结果：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A successful call can give the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用可以给出以下输出：
- en: '![Finding academic entities in query expressions](img/B12373_08_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![在查询表达式中查找学术实体](img/B12373_08_02.jpg)'
- en: Any error responses will produce response codes, as described previously.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 任何错误响应都将产生响应代码，如前所述。
- en: Calculating the distribution of attributes from academic entities
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算学术实体的属性分布
- en: Another feature of the academic API is the ability to calculate the distribution
    of attribute values for a set of paper entities. This can be done by calling the
    `calchistogram` API endpoint.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 学术 API 的另一个功能是能够计算一组论文实体的属性值分布。这可以通过调用 `calchistogram` API 端点来完成。
- en: 'This is a `GET` request, so we start by creating a query string, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `GET` 请求，因此我们首先创建一个查询字符串，如下所示：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The parameters we can specify are the same as with `Evaluate`, except that we
    do not have the `orderby` parameter. For this call, we want to get the year of
    publication (`Y`) and the name of the field of study (`F.FN`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定的参数与 `Evaluate` 相同，除了我们没有 `orderby` 参数。对于这个调用，我们想要获取出版年份（`Y`）和研究领域的名称（`F.FN`）。
- en: 'We make the call to the API without specifying any request bodies, as shown
    in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 API 时不指定任何请求体，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the call succeeds, we expect a `HistogramResponse` object in return. This
    is a data contract, which should contain the data from the JSON response.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，我们期望返回一个 `HistogramResponse` 对象。这是一个数据合约，它应该包含来自 JSON 响应的数据。
- en: 'A successful request should give the following JSON response (depending on
    the requested attributes):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的请求应给出以下 JSON 响应（取决于请求的属性）：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The response contains the original query expression that we used. It will give
    us a count of the number of matching entities. An array of histograms will also
    be present. This will contain an item for each of the attributes we requested.
    The data for each item is described in the following table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '| Data field | Description |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| `attribute` | This is the attribute name. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| `distinct_values` | This is the number of distinct values that match the
    entities for this attribute. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `total_count` | This is the total number of value instances among the matching
    entities for this attribute. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `histogram` | This is an array containing the histogram data for this attribute.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `histogram[x].value` | This is the value for the current histogram. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `histogram[x].prob` | This is the probability that matching entities have
    this attribute value. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `histogram[x].count` | This is the number of matching entities that have
    this value. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: 'With a successful response, we loop through the data, presenting it in the
    UI using the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A successful call gives us the following result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating the distribution of attributes from academic entities](img/B12373_08_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: An unsuccessful API call will return an error, containing a response code. The
    potential response codes are the same as described in the previous section on
    the `Interpret` feature.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Entity attributes
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rather important element of this API is the usage of attributes. You will
    most definitely want to get some data from the query, but not all of the data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'We have previously seen how to specify attributes in each request. The following
    table describes all available attributes. Please make sure that all attributes
    specified in a request are correct per casing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `Id` | Entity ID |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `Ti` | Paper title |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `Y` | Paper year |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `D` | Paper date |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `CC` | Citation count |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `ECC` | Estimated citation count |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `AA.AuN` | Author name |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `AA.AuId` | Author ID |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `AA.AfN` | Author affiliation name |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `AA.AfId` | Author affiliation ID |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `F.FN` | Name of field of study |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `F.Fid` | Field of study ID |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `J.JN` | Journal name |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `J.JId` | Journal ID |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `C.CN` | Conference series name |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `C.Cid` | Conference series ID |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `Rid` | Reference ID |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `W` | Words from the paper title/abstract for full text search |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `E` | Extended metadata |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: 'The extended metadata is described in the following table:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `DN` | Display name of the paper |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `D` | Description |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `S` | Sources (web sources of the paper, sorted by static rank) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `S.Ty` | Source type (HTML/text/PDF/DOC/PPT/XLS/PS) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `S.U` | Source URL |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `VFN` | Venue full name - full name of journal or conference |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `VSN` | Venue short name - short name of the journal or conference |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `V` | Journal volume |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `I` | Journal issue |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `FP` | First page of paper |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `LP` | Last page of paper |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `DOI` | Digital object identifier |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: Creating the backend using the Knowledge Exploration Service
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用知识探索服务创建后端
- en: The **Knowledge Exploration Service** (**KES**) is, in some ways, the backend
    for the academic API. It allows us to build a compressed index from structured
    data, authoring grammar to interpret natural language.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识探索服务**（**KES**）在某种程度上是学术API的后端。它允许我们从一个结构化数据中构建一个压缩索引，编写语法来解释自然语言。'
- en: To get started with the KES, we need to install the service locally.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用KES，我们需要在本地安装服务。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To download the KES installer, go to [https://www.microsoft.com/en-us/download/details.aspx?id=51488](https://www.microsoft.com/en-us/download/details.aspx?id=51488).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载KES安装程序，请访问 [https://www.microsoft.com/en-us/download/details.aspx?id=51488](https://www.microsoft.com/en-us/download/details.aspx?id=51488)。
- en: With the installation comes some example data, which we will use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程中会附带一些示例数据，我们将使用这些数据。
- en: 'The steps required to have a working service are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个工作的服务，所需的步骤如下：
- en: Define a schema
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个schema
- en: Generate data
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成数据
- en: Build the index
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建索引
- en: Author the grammar
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语法
- en: Compile the grammar
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译语法
- en: Host the service
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 托管服务
- en: Defining attributes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义属性
- en: The `schema` file defines the attribute structure in our domain. When we previously
    discussed the academic API, we saw a list of different entity attributes, which
    we could retrieve through the queries. This is defined in a schema.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema` 文件定义了我们领域中的属性结构。当我们之前讨论学术API时，我们看到了一系列不同的实体属性，我们可以通过查询检索这些属性。这些在schema中定义。'
- en: If you open the `Academic.schema` file in the `Example` folder where the KES
    is installed, you will see the attributes defined. We have a title, year, and
    keyword, which are basic attribute types. In addition, we have a `Composite` attribute
    for the author. This attribute contains more attributes related to the author.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开KES安装的 `Example` 文件夹中的 `Academic.schema` 文件，你会看到定义的属性。我们有一个标题、年份和关键词，这些都是基本属性类型。此外，我们还有一个
    `Composite` 属性用于作者。这个属性包含与作者相关的更多属性。
- en: 'Each attribute will support all attribute operations. There may be cases where
    this is not desired. Explicitly defining the operations for a given attribute
    may reduce the index size. In the case of the author ID, we just want to be able
    to check whether it is equal to something, which we can achieve by adding the
    following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都将支持所有属性操作。可能存在不需要这种情况。为特定属性显式定义操作可能会减小索引大小。在作者ID的情况下，我们只想能够检查它是否等于某个值，这可以通过添加以下内容来实现：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding data
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据
- en: With a schema defined, we can add some data. The example contains a file, called
    `Academic.data`, which holds all the example data. Open the file to learn what
    the data can look like.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了schema之后，我们可以添加一些数据。示例中包含一个名为 `Academic.data` 的文件，它包含了所有示例数据。打开文件以了解数据可能的样子。
- en: Each line in the data file specifies the attribute values for an object. It
    can also contain a `logprob` value, which will indicate the return order of matching
    objects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数据文件中的每一行指定了一个对象的属性值。它也可以包含一个 `logprob` 值，这将指示匹配对象的返回顺序。
- en: Building the index
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建索引
- en: With the attribute schema and data file in place, we can build the compressed
    binary index. This will hold all our data objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了属性schema和数据文件之后，我们可以构建压缩的二进制索引。这将包含我们所有的数据对象。
- en: 'Using our example files, we can build the index by running the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的示例文件，我们可以通过运行以下命令来构建索引：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A successful execution should produce the `Academic.index` file, which we will
    use when we are hosting the service.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行应生成 `Academic.index` 文件，我们将用它来托管服务。
- en: 'When running the command, the application will continuously output the status,
    which can look like the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行命令时，应用程序将连续输出状态，可能看起来如下：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Understanding natural language
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自然语言
- en: After we have built an index, we can start creating our grammar file. This specifies
    what natural language the service can understand, and how it can translate into
    semantic query expressions. Open the `academic.xml` file to see an example of
    how a grammar file can look.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建索引之后，我们可以开始创建我们的语法文件。这指定了服务可以理解的自然语言，以及它如何将其翻译成语义查询表达式。打开 `academic.xml`
    文件，看看语法文件可以看起来像什么。
- en: The grammar is based on a **W3C** standard for speech recognition, called **SRGS**.
    The top-level element is the grammar element. This requires a `root` attribute
    to specify the root rule, which is the starting point of the grammar.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 语法基于一个名为**SRGS**的**W3C**语音识别标准。顶级元素是语法元素。这需要一个`root`属性来指定根规则，它是语法的起点。
- en: 'To allow attribute references, we add the `import` element. This needs to be
    a child of the `grammar` element, and should come before anything else. It contains
    two required attributes: the name of the schema file to import, and a name that
    elements can use for referencing the schema. Note that the schema file must be
    in the same folder as the grammar file.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许属性引用，我们添加`import`元素。这需要是`grammar`元素的子元素，并且应该在其他任何内容之前。它包含两个必需的属性：要导入的方案文件名称，以及元素可以用来引用方案的名字。请注意，方案文件必须与语法文件在同一个文件夹中。
- en: Next in line is the `rule` element. This defines a structural unit, which specifies
    what query expressions the service can interpret. A `rule` element requires an
    `id` attribute. Optionally, you can add an `example` element, which is used to
    describe phrases that may be accepted by the `rule` element. In that case, this
    will be a child element of the rule.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`rule`元素。这定义了一个结构单元，它指定了服务可以解释的查询表达式。`rule`元素需要一个`id`属性。可选地，你可以添加一个`example`元素，它用于描述可能被`rule`元素接受的短语。在这种情况下，这将是规则的子元素。
- en: A `rule` element also contains an `item` element. This groups a sequence of
    grammar constructs, and can be used to indicate repetitions of the sequence. Alternatively,
    it can be used to specify alternatives, together with one-of elements.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`rule`元素还包含一个`item`元素。这组成了一个语法构造的序列，可以用来指示序列的重复。或者，它可以用来指定替代方案，与one-of元素一起使用。'
- en: One-of elements specify expansions among one of the item elements. The item
    by may be defined as a one-of element, with written by and authored *by* as expansions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: One-of元素指定了项目元素之间的扩展。项目可以定义为one-of元素，其中“written by”和“authored by”作为扩展。
- en: Using the `ruleref` element allows us to create more complex expressions by
    using simpler rules. It simply references other rules by adding a URI attribute.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ruleref`元素，我们可以通过使用更简单的规则来创建更复杂的表达式。它只是通过添加URI属性来引用其他规则。
- en: The `attrref` element references an `index` attribute, which allows us to match
    against attributes in the index. The attribute URI is required, which must specify
    the index schema and attribute name to reference. This must match a schema that
    is imported through the `import` element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrref`元素引用了`index`属性，这允许我们与索引中的属性进行匹配。属性URI是必需的，它必须指定要引用的索引模式和属性名称。这必须匹配通过`import`元素导入的模式。'
- en: The `tag` element defines the path through the grammar. This element allows
    you to assign variables or execute functions to help the flow of the grammar.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`元素定义了通过语法的路径。此元素允许你分配变量或执行函数以帮助语法的流程。'
- en: 'Once the grammar file is completed, we can compile it into binary grammar.
    This is done by running the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦语法文件完成，我们可以将其编译成二进制语法。这是通过运行以下命令来完成的：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running this command will produce output similar to the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将生成类似以下内容的输出：
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Local hosting and testing
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地托管和测试
- en: With the index and grammar in place, we can go on to test the service locally.
    Locally testing the service allows for rapid prototyping, which allows us to define
    the scheme and grammar quickly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引和语法就绪后，我们可以继续在本地测试服务。本地测试服务允许快速原型设计，这使我们能够快速定义方案和语法。
- en: When we are testing locally, the KES only supports up to 10,000 objects and
    10 requests per second. It also terminates after a total of 1,000 requests have
    been executed. We will learn how to bypass these restrictions in a bit.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本地测试时，KES仅支持最多10,000个对象和每秒10个请求。在执行了总共1,000个请求后，它也会终止。我们将在稍后学习如何绕过这些限制。
- en: 'To host the KES locally, run the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要本地托管KES，请运行以下命令：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will start up the service, running on port `8080`. To verify that it is
    working as intended, open your browser and go to `http://localhost:8080`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动在端口`8080`上运行的服务。为了验证它是否按预期工作，请打开您的浏览器并转到`http://localhost:8080`。
- en: 'Doing so should present you with the following screen:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做应该会显示以下屏幕：
- en: '![Local hosting and testing](img/B12373_08_04.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![本地托管和测试](img/B12373_08_04.jpg)'
- en: Running the KES as a local service also allows us to use the academic API for
    testing. We are going to make some modifications to our example application—created
    for the academic API—in order to support this.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to modify the `WebRequest.cs` file. We need to make sure
    that we can change the endpoint, so add the following function to the class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to add a new `TextBox` element to the `MainView.xaml` file. This
    will allow us to enter a URL. This needs a corresponding string property in the
    `MainViewModel.cs` file. When changing this property, we need to call `SetEndpoint`
    on the `_webRequest` object. This can look as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we need to update the constructor of our `ViewModel`. Change the first
    line to the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will let the default endpoint be the original API address, but allows us
    to use the application to test the KES locally.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'By testing the application with the local endpoint, the following result can
    be produced:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Local hosting and testing](img/B12373_08_05.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `evaluate` and `calchistogram` will need to update the attributes
    in the request of the test application for it to work with the local KES.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Going for scale
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is nice to be able to create local prototypes, the limitations ensure
    that we need to deploy the service elsewhere for production. In this case, this
    means deploying the KES to Microsoft Azure.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at the steps required to deploy the KES to Microsoft Azure.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into Microsoft Azure
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to download the **Azure publish settings** file. This needs
    to be saved as `AzurePublishSettings.xml` and stored in the directory in which
    `kes.exe` runs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the Azure publish settings file at [https://manage.windowsazure.com/publishsettings/](https://manage.windowsazure.com/publishsettings/).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to build and host the KES without restrictions. The first
    way is to boot up a **Windows virtual machine** in Azure. On this VM, you should
    follow the same steps that we took locally. This allows for rapid prototyping,
    but without any restrictions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way is to run `kes.exe` locally, but adding `--remote` as a parameter.
    This will create a temporary Azure VM, build the index, and upload the index to
    a specified target blob storage. An example command could look as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This process can take up to 10 minutes, so ideally, prototyping should be done
    locally, or through an Azure VM.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the service
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the grammar and index in place and prototyping done, we can deploy the
    service to a Microsoft Azure cloud service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn how to create a Microsoft Azure cloud service, head over to [https://azure.microsoft.com/en-us/documentation/articles/cloud-services-how-to-create-deploy/](https://azure.microsoft.com/en-us/documentation/articles/cloud-services-how-to-create-deploy/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the service to a staging slot, run the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will allow us to perform basic tests before deploying the service to a
    production slot. When the testing is done, we can deploy it to production by running
    the same command again, specifying `Production` as the last parameter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: When the service is deployed, we can test it by visiting `http://<serviceName>.cloudapp.net`
    in a browser.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Answering FAQs using QnA Maker
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QnA Maker allows us to use existing **frequently asked questions** (**FAQs**)
    to create a bot that answers these questions. We can generate a knowledge base
    from existing FAQs, and train a model from it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, head over to [https://qnamaker.ai](https://qnamaker.ai). Log
    on or register by clicking Sign in, in the upper-right corner. This will present
    you with the following screen:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Answering FAQs using QnA Maker](img/B12373_08_06.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Creating a knowledge base from frequently asked questions
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If no services have been created, we can create one by clicking on the Create
    a knowledge base tab. This will present us with the following screen, as shown
    in the following two screenshots:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a knowledge base from frequently asked questions](img/B12373_08_07.jpg)![Creating
    a knowledge base from frequently asked questions](img/B12373_08_08.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: Create a QnA service in Microsoft Azure by clicking the blue button in **S****TEP
    1** in the screenshot.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the QnA service to the knowledge base.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a name for the service.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the baseline FAQs to use. This can either be in the form of one or more
    URLs, or a file containing question-and-answer pairs. For our example, we will
    be generating a knowledge base from the URL.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the rest of the settings be default.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create your KB**.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not have any FAQs to use, you can use [https://www.microsoft.com/en-us/software-download/faq](https://www.microsoft.com/en-us/software-download/faq)
    from Microsoft.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the knowledge base has been created, you will be taken to a page with
    all the question-and-answer pairs. This is shown in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a knowledge base from frequently asked questions](img/B12373_08_09.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: On this page, we can look through all question-and-answer pairs, from all our
    FAQ sources. We can also add new pairs by clicking **Add QnA** pair.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Training the model
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time we make changes to the knowledge base, it is wise to click **Save**
    and **Train**. This will ensure that our model is up to date, with the most current
    question-and-answer pairs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have trained the model, we can test it. This can be done by clicking
    the **Test** button on the right-hand side. This will present us with the following
    chat window:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Training the model](img/B12373_08_10.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: From this chat dialog, we can test some or all of our questions to verify that
    we get the correct answers. We can also improve the model by asking questions
    in different ways. In some cases, this will present us with the wrong answer.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: If we have been presented with the wrong answer, we can change this by selecting
    the correct one. With any given question, the possible answers will be listed
    by clicking the Inspect button beneath the question, ordered by probability. Selecting
    the correct answer and retraining the model will ensure a correct answer when
    asking the same question later.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the model
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we are done with training, it is time to publish the service. We can do
    so by clicking Publish in the top menu. Doing so will present us with a basic
    HTTP request that we can try, as shown in the following screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing the model](img/B12373_08_11.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see the endpoint to use, the required application
    ID, the subscription key, and a sample question in the request body. All those
    parameters are required to get a successful response.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call to the service will provide us with a JSON response as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we have an application that uses this, we can decide not to use the answer
    if the score has fallen below a certain threshold.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Typically, we would be using bots of different kinds to use this service. We
    can, for example, add this to a Skype bot or Slackbot, or simply integrate it
    with a chatbot on a customer support site.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have learned about the Project Academic Knowledge
    API and Project Knowledge Exploration Service. We looked at how to interpret natural
    language queries to get query expressions for evaluation. Through this evaluation,
    we have retrieved academic papers from the Microsoft Academic Graph knowledge
    base. From there, we learned how to set up the Knowledge Exploration Service itself,
    going from defining the schemas all the way to deploying it to a Microsoft Azure
    cloud service. In the end, we learned how to set up a simple QnA Maker service.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to looking at search APIs, learning how
    to utilize the different search APIs offered by Bing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
