- en: Chapter 8. Querying Structured Data in a Natural Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how we can use the current context to extend
    our knowledge on a certain topic. Throughout this chapter, we will continue discussing
    about the knowledge APIs. More specifically, we will learn how to explore relationships
    between academic papers and journals. We will see how we can interpret natural
    language queries, and retrieve query expressions. Using these expressions, we
    will learn how to find academic entities. We will then focus more on how to set
    up this kind of service on your own. At the end of this chapter, we will look
    at QnA Maker to see how we can create FAQ services from existing content.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting natural-language user queries using Project Academic Knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assisting the user with queries using autocomplete features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using autocomplete queries to retrieve academic entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the distribution of academic entities from queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting the Project Knowledge Exploration Service with your own schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an FAQ service from existing content using QnA Maker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tapping into academic content using the academic API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microsoft Academic Graph** (**MAG**) is a knowledge base for web-scale, heterogeneous
    entity graphs. Entities model scholarly activities, and contain information such
    as the field of study, author(s), institution, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Data contained in MAG is indexed from the Bing web index. As this is continuously
    indexed, the data is always up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Project Academic Knowledge API, we can tap into this knowledge base.
    This API allows us to combine search suggestions, research paper graph search
    results, and histogram distributions. The API enables a knowledge-driven and interactive
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: When a user searches for research papers, the API can provide query completion.
    It may suggest queries based on the input. With a complete query, we can evaluate
    a query expression. This will retrieve a set of matching paper entities from the
    knowledge base.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an example project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test Project Academic Knowledge, we will first want to create a new example
    project. We will create this from the MVVM template created in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Microsoft Cognitive Services"), *Getting Started
    with Microsoft Cognitive Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Project Academic Knowledge does not have any client packages available. This
    means that we need to call the API ourselves. Copy the `WebRequest.cs` file from
    the `Model` folder in the smart house application and paste it into the `Model`
    folder of the newly created project. Make sure that you correct the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to compile this, we will need to add references to `System.Web` and
    `System.Runtime.Serializable`. We will also be working with JSON, so go ahead
    and add the `Newtonsoft.Json` package through the NuGet package manager.
  prefs: []
  type: TYPE_NORMAL
- en: As this will be the only API tested in this sample project, we can add UI elements
    in the `MainView.xaml` file. Open this file now.
  prefs: []
  type: TYPE_NORMAL
- en: Our `View` should have a `TextBox` element for our input query. It should have
    a `ComboBox` element to list the suggested query expressions. We need three `Button`
    elements, one for `Interpret`, one for `Evaluate`, and one for `Histogram`, which
    are all functions we will be executing. Last but not least, we need a `TextBox`
    element to display our results.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MainViewModel.cs` file, we will need to add corresponding properties.
    Add three `string` properties, one for the input query, one for the results, and
    one for the selected query expression. Add an `ObservableCollection` property
    of the `string` type for our available query expressions. We also need three `ICommand`
    properties, one for each of our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a private member for our `WebRequest` object. Make the constructor look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have not already done so, sign up for an API key at [https://labs.cognitive.microsoft.com/en-us/project-academic-knowledge](https://labs.cognitive.microsoft.com/en-us/project-academic-knowledge)
    and click the **Subscribe** button.
  prefs: []
  type: TYPE_NORMAL
- en: The `CanInterpret` parameter should return `true` if we have entered any text
    into the query textbox. The `CanExecuteCommands` parameter should return `true`
    if we have selected a query expression. We will cover `Interpret`, `Evaluate`,
    and the `CalculateHistogram` parameters in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the application compiles and runs before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting natural language queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The query expressions that the API uses to evaluate a query are not in a natural
    language format. To ensure that users can make queries in a natural way, we need
    to interpret their input.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the `Interpret` feature of the API, it accepts a query string.
    This will be returned and formatted to reflect the user intent using academic
    grammar. In addition, this feature can be called as the user is writing, to provide
    an interactive experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request is a `GET` request, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the call by creating a `queryString` variable. The parameters we can
    input are specified in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `query` (required) | The query from the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `complete` (optional) | If this is set to `1`, then the service will return
    suggestions using the query as a prefix. A value of `0` means there will be no
    autocomplete. |'
  prefs: []
  type: TYPE_TB
- en: '| `count` (optional) | The maximum number of interpretations to return. |'
  prefs: []
  type: TYPE_TB
- en: '| `offset` (optional) | The index of the first interpretation. This is useful
    if a lot of results are expected and you need to add pagination. |'
  prefs: []
  type: TYPE_TB
- en: '| `timeout` (optional) | The timeout specified in milliseconds. Only results
    found before this limit will be returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `model` (optional) | The name of the model you want to query. This defaults
    to the latest model. |'
  prefs: []
  type: TYPE_TB
- en: 'We call the API to get interpretations, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As this is a `GET` request, we do not need to specify any request bodies. We
    do, however, expect a result to be serialized into an `InterpretResponse` object.
    This is a data contract, containing properties from the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call to the API will result in a JSON response, which looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result contains the original `query`. It also contains an array with `interpretations`.
    Each item in this array consists of the data shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `prob` | This is the probability of the current interpretation being correct.
    The scale goes from `0` to `1`, where `1` is the highest. |'
  prefs: []
  type: TYPE_TB
- en: '| `parse` | This is an XML string showing interpretations for each part of
    the string. |'
  prefs: []
  type: TYPE_TB
- en: '| `rules` | This is an array with one or more rules defined. There will always
    be one rule for the academic API. |'
  prefs: []
  type: TYPE_TB
- en: '| `rules[x].name` | This is the name of the current rule. |'
  prefs: []
  type: TYPE_TB
- en: '| `rules[x].output` | This is the output of the current rule. |'
  prefs: []
  type: TYPE_TB
- en: '| `rules[x].output.type` | This is the type of the rule output. This will always
    be `query` for the academic API. |'
  prefs: []
  type: TYPE_TB
- en: '| `rules[x].output.value` | This is the output value for the rule. This will
    be a query expression string. |'
  prefs: []
  type: TYPE_TB
- en: Create the `InterpretResponse` data contract based on the preceding JSON output.
    We are interested in the last data field, `rules[x].output.value`. This is the
    query expression string, which we will use to evaluate queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the API call has succeeded, we want to update the `ObservableCollection`
    class as to the available query expressions, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We loop through all `interpretations`, adding the `outputvalue` from a rule
    to our `AvailableQueryExpressions`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the selected `QueryExpression` as the first one available. This
    is just for our own convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful test run can generate the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpreting natural language queries](img/B12373_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An unsuccessful call will produce an error response code. The response codes
    that can be generated are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Response code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | Bad argument; request parameter is missing |'
  prefs: []
  type: TYPE_TB
- en: '| `401` | Invalid subscription key |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | The call volume quota has been exceeded |'
  prefs: []
  type: TYPE_TB
- en: '| `404` | The requested resources are not found |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | Internal server error |'
  prefs: []
  type: TYPE_TB
- en: Finding academic entities in query expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a query expression available, we can retrieve a set of academic
    entities using the `Evaluate` endpoint. This is a `GET` request, where we need
    to specify the attributes we want returned for each entity. We will cover the
    available attributes later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a query string, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters we can add are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `expr` (required) | This is the query expression found in the `Interpret`
    call. |'
  prefs: []
  type: TYPE_TB
- en: '| `attributes` (optional) | This is a comma-separated list of attributes to
    be included in the response. Each attribute is case-sensitive. |'
  prefs: []
  type: TYPE_TB
- en: '| `model` (optional) | This is the model you wish to use for a query. This
    defaults to the latest model. |'
  prefs: []
  type: TYPE_TB
- en: '| `count` (optional) | This is the number of entities to return. |'
  prefs: []
  type: TYPE_TB
- en: '| `offset` (optional) | This is the index of the first result to return; it
    can be useful for pagination purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| `orderby` (optional) | This specifies the order in which to sort the entities.
    |'
  prefs: []
  type: TYPE_TB
- en: Note that, while the `attributes` parameter is optional, you should specify
    which attributes you want. If none are specified, only the entity ID is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As this is a `GET` request, we do not need any request bodies. With a successful
    call, we expect an `EvaluateResponse` object in return. This is a data contract,
    which will be deserialized from the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful response will give a JSON response like the following code (depending
    on the attributes specified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The response contains the query expression we used. It also contains an array
    of entities. Each item in this array will contain the probability of it being
    correct. It will also contain all the attributes that we specified, in the form
    of either string or numeric values. It can also be in the form of objects, which
    we will need to have data contracts for.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our request, we specified some attributes. These were the entity ID, title,
    year and date of publication, citation count, and author name. Knowing these attributes,
    we can use the following code to output the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful call can give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding academic entities in query expressions](img/B12373_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any error responses will produce response codes, as described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the distribution of attributes from academic entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another feature of the academic API is the ability to calculate the distribution
    of attribute values for a set of paper entities. This can be done by calling the
    `calchistogram` API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a `GET` request, so we start by creating a query string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The parameters we can specify are the same as with `Evaluate`, except that we
    do not have the `orderby` parameter. For this call, we want to get the year of
    publication (`Y`) and the name of the field of study (`F.FN`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We make the call to the API without specifying any request bodies, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the call succeeds, we expect a `HistogramResponse` object in return. This
    is a data contract, which should contain the data from the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful request should give the following JSON response (depending on
    the requested attributes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The response contains the original query expression that we used. It will give
    us a count of the number of matching entities. An array of histograms will also
    be present. This will contain an item for each of the attributes we requested.
    The data for each item is described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `attribute` | This is the attribute name. |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct_values` | This is the number of distinct values that match the
    entities for this attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| `total_count` | This is the total number of value instances among the matching
    entities for this attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| `histogram` | This is an array containing the histogram data for this attribute.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `histogram[x].value` | This is the value for the current histogram. |'
  prefs: []
  type: TYPE_TB
- en: '| `histogram[x].prob` | This is the probability that matching entities have
    this attribute value. |'
  prefs: []
  type: TYPE_TB
- en: '| `histogram[x].count` | This is the number of matching entities that have
    this value. |'
  prefs: []
  type: TYPE_TB
- en: 'With a successful response, we loop through the data, presenting it in the
    UI using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful call gives us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating the distribution of attributes from academic entities](img/B12373_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An unsuccessful API call will return an error, containing a response code. The
    potential response codes are the same as described in the previous section on
    the `Interpret` feature.
  prefs: []
  type: TYPE_NORMAL
- en: Entity attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rather important element of this API is the usage of attributes. You will
    most definitely want to get some data from the query, but not all of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have previously seen how to specify attributes in each request. The following
    table describes all available attributes. Please make sure that all attributes
    specified in a request are correct per casing:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Id` | Entity ID |'
  prefs: []
  type: TYPE_TB
- en: '| `Ti` | Paper title |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | Paper year |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Paper date |'
  prefs: []
  type: TYPE_TB
- en: '| `CC` | Citation count |'
  prefs: []
  type: TYPE_TB
- en: '| `ECC` | Estimated citation count |'
  prefs: []
  type: TYPE_TB
- en: '| `AA.AuN` | Author name |'
  prefs: []
  type: TYPE_TB
- en: '| `AA.AuId` | Author ID |'
  prefs: []
  type: TYPE_TB
- en: '| `AA.AfN` | Author affiliation name |'
  prefs: []
  type: TYPE_TB
- en: '| `AA.AfId` | Author affiliation ID |'
  prefs: []
  type: TYPE_TB
- en: '| `F.FN` | Name of field of study |'
  prefs: []
  type: TYPE_TB
- en: '| `F.Fid` | Field of study ID |'
  prefs: []
  type: TYPE_TB
- en: '| `J.JN` | Journal name |'
  prefs: []
  type: TYPE_TB
- en: '| `J.JId` | Journal ID |'
  prefs: []
  type: TYPE_TB
- en: '| `C.CN` | Conference series name |'
  prefs: []
  type: TYPE_TB
- en: '| `C.Cid` | Conference series ID |'
  prefs: []
  type: TYPE_TB
- en: '| `Rid` | Reference ID |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | Words from the paper title/abstract for full text search |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | Extended metadata |'
  prefs: []
  type: TYPE_TB
- en: 'The extended metadata is described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DN` | Display name of the paper |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | Sources (web sources of the paper, sorted by static rank) |'
  prefs: []
  type: TYPE_TB
- en: '| `S.Ty` | Source type (HTML/text/PDF/DOC/PPT/XLS/PS) |'
  prefs: []
  type: TYPE_TB
- en: '| `S.U` | Source URL |'
  prefs: []
  type: TYPE_TB
- en: '| `VFN` | Venue full name - full name of journal or conference |'
  prefs: []
  type: TYPE_TB
- en: '| `VSN` | Venue short name - short name of the journal or conference |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | Journal volume |'
  prefs: []
  type: TYPE_TB
- en: '| `I` | Journal issue |'
  prefs: []
  type: TYPE_TB
- en: '| `FP` | First page of paper |'
  prefs: []
  type: TYPE_TB
- en: '| `LP` | Last page of paper |'
  prefs: []
  type: TYPE_TB
- en: '| `DOI` | Digital object identifier |'
  prefs: []
  type: TYPE_TB
- en: Creating the backend using the Knowledge Exploration Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Knowledge Exploration Service** (**KES**) is, in some ways, the backend
    for the academic API. It allows us to build a compressed index from structured
    data, authoring grammar to interpret natural language.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with the KES, we need to install the service locally.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To download the KES installer, go to [https://www.microsoft.com/en-us/download/details.aspx?id=51488](https://www.microsoft.com/en-us/download/details.aspx?id=51488).
  prefs: []
  type: TYPE_NORMAL
- en: With the installation comes some example data, which we will use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps required to have a working service are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a schema
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the index
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Author the grammar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the grammar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Host the service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `schema` file defines the attribute structure in our domain. When we previously
    discussed the academic API, we saw a list of different entity attributes, which
    we could retrieve through the queries. This is defined in a schema.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the `Academic.schema` file in the `Example` folder where the KES
    is installed, you will see the attributes defined. We have a title, year, and
    keyword, which are basic attribute types. In addition, we have a `Composite` attribute
    for the author. This attribute contains more attributes related to the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each attribute will support all attribute operations. There may be cases where
    this is not desired. Explicitly defining the operations for a given attribute
    may reduce the index size. In the case of the author ID, we just want to be able
    to check whether it is equal to something, which we can achieve by adding the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a schema defined, we can add some data. The example contains a file, called
    `Academic.data`, which holds all the example data. Open the file to learn what
    the data can look like.
  prefs: []
  type: TYPE_NORMAL
- en: Each line in the data file specifies the attribute values for an object. It
    can also contain a `logprob` value, which will indicate the return order of matching
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Building the index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the attribute schema and data file in place, we can build the compressed
    binary index. This will hold all our data objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our example files, we can build the index by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A successful execution should produce the `Academic.index` file, which we will
    use when we are hosting the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the command, the application will continuously output the status,
    which can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Understanding natural language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have built an index, we can start creating our grammar file. This specifies
    what natural language the service can understand, and how it can translate into
    semantic query expressions. Open the `academic.xml` file to see an example of
    how a grammar file can look.
  prefs: []
  type: TYPE_NORMAL
- en: The grammar is based on a **W3C** standard for speech recognition, called **SRGS**.
    The top-level element is the grammar element. This requires a `root` attribute
    to specify the root rule, which is the starting point of the grammar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow attribute references, we add the `import` element. This needs to be
    a child of the `grammar` element, and should come before anything else. It contains
    two required attributes: the name of the schema file to import, and a name that
    elements can use for referencing the schema. Note that the schema file must be
    in the same folder as the grammar file.'
  prefs: []
  type: TYPE_NORMAL
- en: Next in line is the `rule` element. This defines a structural unit, which specifies
    what query expressions the service can interpret. A `rule` element requires an
    `id` attribute. Optionally, you can add an `example` element, which is used to
    describe phrases that may be accepted by the `rule` element. In that case, this
    will be a child element of the rule.
  prefs: []
  type: TYPE_NORMAL
- en: A `rule` element also contains an `item` element. This groups a sequence of
    grammar constructs, and can be used to indicate repetitions of the sequence. Alternatively,
    it can be used to specify alternatives, together with one-of elements.
  prefs: []
  type: TYPE_NORMAL
- en: One-of elements specify expansions among one of the item elements. The item
    by may be defined as a one-of element, with written by and authored *by* as expansions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ruleref` element allows us to create more complex expressions by
    using simpler rules. It simply references other rules by adding a URI attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `attrref` element references an `index` attribute, which allows us to match
    against attributes in the index. The attribute URI is required, which must specify
    the index schema and attribute name to reference. This must match a schema that
    is imported through the `import` element.
  prefs: []
  type: TYPE_NORMAL
- en: The `tag` element defines the path through the grammar. This element allows
    you to assign variables or execute functions to help the flow of the grammar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the grammar file is completed, we can compile it into binary grammar.
    This is done by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command will produce output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Local hosting and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the index and grammar in place, we can go on to test the service locally.
    Locally testing the service allows for rapid prototyping, which allows us to define
    the scheme and grammar quickly.
  prefs: []
  type: TYPE_NORMAL
- en: When we are testing locally, the KES only supports up to 10,000 objects and
    10 requests per second. It also terminates after a total of 1,000 requests have
    been executed. We will learn how to bypass these restrictions in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To host the KES locally, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will start up the service, running on port `8080`. To verify that it is
    working as intended, open your browser and go to `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing so should present you with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Local hosting and testing](img/B12373_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running the KES as a local service also allows us to use the academic API for
    testing. We are going to make some modifications to our example application—created
    for the academic API—in order to support this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to modify the `WebRequest.cs` file. We need to make sure
    that we can change the endpoint, so add the following function to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a new `TextBox` element to the `MainView.xaml` file. This
    will allow us to enter a URL. This needs a corresponding string property in the
    `MainViewModel.cs` file. When changing this property, we need to call `SetEndpoint`
    on the `_webRequest` object. This can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to update the constructor of our `ViewModel`. Change the first
    line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will let the default endpoint be the original API address, but allows us
    to use the application to test the KES locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'By testing the application with the local endpoint, the following result can
    be produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Local hosting and testing](img/B12373_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `evaluate` and `calchistogram` will need to update the attributes
    in the request of the test application for it to work with the local KES.
  prefs: []
  type: TYPE_NORMAL
- en: Going for scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is nice to be able to create local prototypes, the limitations ensure
    that we need to deploy the service elsewhere for production. In this case, this
    means deploying the KES to Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at the steps required to deploy the KES to Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into Microsoft Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to download the **Azure publish settings** file. This needs
    to be saved as `AzurePublishSettings.xml` and stored in the directory in which
    `kes.exe` runs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the Azure publish settings file at [https://manage.windowsazure.com/publishsettings/](https://manage.windowsazure.com/publishsettings/).
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to build and host the KES without restrictions. The first
    way is to boot up a **Windows virtual machine** in Azure. On this VM, you should
    follow the same steps that we took locally. This allows for rapid prototyping,
    but without any restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way is to run `kes.exe` locally, but adding `--remote` as a parameter.
    This will create a temporary Azure VM, build the index, and upload the index to
    a specified target blob storage. An example command could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This process can take up to 10 minutes, so ideally, prototyping should be done
    locally, or through an Azure VM.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the grammar and index in place and prototyping done, we can deploy the
    service to a Microsoft Azure cloud service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn how to create a Microsoft Azure cloud service, head over to [https://azure.microsoft.com/en-us/documentation/articles/cloud-services-how-to-create-deploy/](https://azure.microsoft.com/en-us/documentation/articles/cloud-services-how-to-create-deploy/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the service to a staging slot, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to perform basic tests before deploying the service to a
    production slot. When the testing is done, we can deploy it to production by running
    the same command again, specifying `Production` as the last parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When the service is deployed, we can test it by visiting `http://<serviceName>.cloudapp.net`
    in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Answering FAQs using QnA Maker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QnA Maker allows us to use existing **frequently asked questions** (**FAQs**)
    to create a bot that answers these questions. We can generate a knowledge base
    from existing FAQs, and train a model from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, head over to [https://qnamaker.ai](https://qnamaker.ai). Log
    on or register by clicking Sign in, in the upper-right corner. This will present
    you with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Answering FAQs using QnA Maker](img/B12373_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a knowledge base from frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If no services have been created, we can create one by clicking on the Create
    a knowledge base tab. This will present us with the following screen, as shown
    in the following two screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a knowledge base from frequently asked questions](img/B12373_08_07.jpg)![Creating
    a knowledge base from frequently asked questions](img/B12373_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a QnA service in Microsoft Azure by clicking the blue button in **S****TEP
    1** in the screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the QnA service to the knowledge base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a name for the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the baseline FAQs to use. This can either be in the form of one or more
    URLs, or a file containing question-and-answer pairs. For our example, we will
    be generating a knowledge base from the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the rest of the settings be default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create your KB**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not have any FAQs to use, you can use [https://www.microsoft.com/en-us/software-download/faq](https://www.microsoft.com/en-us/software-download/faq)
    from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the knowledge base has been created, you will be taken to a page with
    all the question-and-answer pairs. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a knowledge base from frequently asked questions](img/B12373_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this page, we can look through all question-and-answer pairs, from all our
    FAQ sources. We can also add new pairs by clicking **Add QnA** pair.
  prefs: []
  type: TYPE_NORMAL
- en: Training the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time we make changes to the knowledge base, it is wise to click **Save**
    and **Train**. This will ensure that our model is up to date, with the most current
    question-and-answer pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have trained the model, we can test it. This can be done by clicking
    the **Test** button on the right-hand side. This will present us with the following
    chat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Training the model](img/B12373_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From this chat dialog, we can test some or all of our questions to verify that
    we get the correct answers. We can also improve the model by asking questions
    in different ways. In some cases, this will present us with the wrong answer.
  prefs: []
  type: TYPE_NORMAL
- en: If we have been presented with the wrong answer, we can change this by selecting
    the correct one. With any given question, the possible answers will be listed
    by clicking the Inspect button beneath the question, ordered by probability. Selecting
    the correct answer and retraining the model will ensure a correct answer when
    asking the same question later.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we are done with training, it is time to publish the service. We can do
    so by clicking Publish in the top menu. Doing so will present us with a basic
    HTTP request that we can try, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing the model](img/B12373_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see the endpoint to use, the required application
    ID, the subscription key, and a sample question in the request body. All those
    parameters are required to get a successful response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call to the service will provide us with a JSON response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we have an application that uses this, we can decide not to use the answer
    if the score has fallen below a certain threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, we would be using bots of different kinds to use this service. We
    can, for example, add this to a Skype bot or Slackbot, or simply integrate it
    with a chatbot on a customer support site.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have learned about the Project Academic Knowledge
    API and Project Knowledge Exploration Service. We looked at how to interpret natural
    language queries to get query expressions for evaluation. Through this evaluation,
    we have retrieved academic papers from the Microsoft Academic Graph knowledge
    base. From there, we learned how to set up the Knowledge Exploration Service itself,
    going from defining the schemas all the way to deploying it to a Microsoft Azure
    cloud service. In the end, we learned how to set up a simple QnA Maker service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to looking at search APIs, learning how
    to utilize the different search APIs offered by Bing.
  prefs: []
  type: TYPE_NORMAL
