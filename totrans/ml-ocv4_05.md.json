["```py\nIn [5]: X_normalized_l1 = preprocessing.normalize(X, norm='l1')\n...     X_normalized_l1\nOut[5]: array([[ 0.2, -0.4, 0.4],\n               [ 1\\. , 0\\. , 0\\. ],\n               [ 0\\. , 0.5, -0.5]])\n```", "```py\nIn [6]: X_normalized_l2 = preprocessing.normalize(X, norm='l2')\n...     X_normalized_l2\nOut[6]: array([[ 0.33333333, -0.66666667, 0.66666667],\n               [ 1\\. , 0\\. , 0\\. ],\n               [ 0\\. , 0.70710678, -0.70710678]])\n```", "```py\nIn [7]: min_max_scaler = preprocessing.MinMaxScaler()...     X_min_max = min_max_scaler.fit_transform(X)...     X_min_maxOut[7]: array([[ 0.33333333, 0\\. , 1\\. ],               [ 1\\. , 0.66666667, 0.33333333],               [ 0\\. , 1\\. , 0\\. ]])\n```", "```py\nIn [8]: min_max_scaler = preprocessing.MinMaxScaler(feature_range ...\n```", "```py\nIn [9]: X\nOut[9]: array([[ 1., -2., 2.],\n               [ 3., 0., 0.],\n               [ 0., 1., -1.]])\n```", "```py\nIn [10]: binarizer = preprocessing.Binarizer(threshold=0.5)\n...      X_binarized = binarizer.transform(X)\n...      X_binarized\nOut[10]: array([[ 1., 0., 1.],\n                [ 1., 0., 0.],\n                [ 0., 1., 0.]])\n```", "```py\nIn [11]: from numpy import nan...      X = np.array([[ nan, 0,   3 ],...                    [ 2,   9,  -8 ],...                    [ 1,   nan, 1 ],...                    [ 5,   2,   4 ],...                    [ 7,   6,  -3 ]])\n```", "```py\nIn [9]:  from sklearn import decomposition\nIn [10]: ica = decomposition.FastICA(tol=0.005)\n```", "```py\nIn [11]: X2 = ica.fit_transform(X)\n```", "```py\nIn [12]: plt.figure(figsize=(10, 6))\n...      plt.plot(X2[:, 0], X2[:, 1], 'o')\n...      plt.xlabel('first independent component')\n...      plt.ylabel('second independent component')\n...      plt.axis([-0.2, 0.2, -0.2, 0.2])\nOut[12]: [-0.2, 0.2, -0.2, 0.2]\n```", "```py\nIn [13]: nmf = decomposition.NMF()In [14]: X2 = nmf.fit_transform(X)In [15]: plt.plot(X2[:, 0], X2[:, 1], 'o')...      plt.xlabel('first non-negative component')...      plt.ylabel('second non-negative component')...      plt.axis([-5, 20, -5, 10])Out[15]: [-5, 20, ...\n```", "```py\nIn [1]: import numpy as np\nIn [2]: from sklearn.datasets import load_digits\nIn [3]: digits = load_digits()\nIn [4]: X, y = digits.data/255.0, digits.target\nIn [5]: print(X.shape, y.shape)\nOut[5]: (1797, 64) (1797,)\n```", "```py\nIn [6]: from sklearn.manifold import TSNE\nIn [7]: tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)\nIn [8]: tsne_results = tsne.fit_transform(df.loc[:,features].values)\nOut[8]: [t-SNE] Computing 121 nearest neighbors...\n... [t-SNE] Indexed 1797 samples in 0.009s...\n... [t-SNE] Computed neighbors for 1797 samples in 0.395s...\n... [t-SNE] Computed conditional probabilities for sample 1000 / 1797\n... [t-SNE] Computed conditional probabilities for sample 1797 / 1797\n... [t-SNE] Mean sigma: 0.048776\n... [t-SNE] KL divergence after 250 iterations with early exaggeration: 61.094833\n... [t-SNE] KL divergence after 300 iterations: 0.926492\n```", "```py\nIn [9]: import matplotlib.pyplot as plt\nIn [10]: plt.scatter(tsne_results[:,0],tsne_results[:,1],c=y/10.0)\n...      plt.xlabel('x-tsne')\n...      plt.ylabel('y-tsne')\n...      plt.title('t-SNE')\nIn [11]: plt.show()\n```", "```py\nIn [1]: sample = [\n...        'feature engineering',\n...        'feature selection',\n...        'feature extraction'\n...     ]\n```", "```py\nIn [2]: from sklearn.feature_extraction.text import CountVectorizer\n...     vec = CountVectorizer()\n...     X = vec.fit_transform(sample)\n...     X\nOut[2]: <3x4 sparse matrix of type '<class 'numpy.int64'>'\n                with 6 stored elements in Compressed Sparse Row format>\n```", "```py\nIn [3]: X.toarray()\nOut[3]: array([[1, 0, 1, 0],\n               [0, 0, 1, 1],\n               [0, 1, 1, 0]], dtype=int64)\n```", "```py\nIn [4]: vec.get_feature_names()\nOut[4]: ['engineering', 'extraction', 'feature', 'selection']\n```", "```py\nIn [5]: from sklearn.feature_extraction.text import TfidfVectorizer\n...     vec = TfidfVectorizer()\n...     X = vec.fit_transform(sample)\n...     X.toarray()\nOut[5]: array([[ 0.861037 , 0\\. , 0.50854232, 0\\. ],\n               [ 0\\. , 0\\. , 0.50854232, 0.861037 ],\n               [ 0\\. , 0.861037 , 0.50854232, 0\\. ]])\n```", "```py\nIn [6]: vec.get_feature_names()\nOut[6]: ['engineering', 'extraction', 'feature', 'selection']\n```", "```py\nIn [5]: img_hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)\n```", "```py\nIn [23]: img = cv2.imread('data/rubic-cube.png')\nIn [24]: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n```", "```py\nIn [25]: star = cv2.xfeatures2d.StarDetector_create()\nIn [26]: brief = cv2.xfeatures2d.BriefDescriptorExtractor_create()\n```", "```py\nIn [27]: keyPoints = star.detect(gray, None)\nIn [28]: keyPoints, descriptors = brief.compute(img, keyPoints)\n```", "```py\nIn [29]: def drawKeypoint (img, keypoint, color):\n...          draw_shift_bits = 4\n...          draw_multiplier = 1 << draw_shift_bits\n\n...          center = (int(round(keypoint.pt[0])),int(round(keypoint.pt[1])))\n\n...          radius = int(round(keypoint.size/2.0))\n\n...          # draw the circles around keypoints with the keypoints size\n...          cv2.circle(img, center, radius, color, 1, cv2.LINE_AA)\n\n...          # draw orientation of the keypoint, if it is applicable\n...          if keypoint.angle != -1:\n\n...              srcAngleRad = keypoint.angle * np.pi/180.0\n\n...              orient = (int(round(np.cos(srcAngleRad)*radius)), \\\n                 int(round(np.sin(srcAngleRad)*radius)))\n\n...              cv2.line(img, center, (center[0]+orient[0],\\\n                               center[1]+orient[1]),\\\n                 color, 1, cv2.LINE_AA)\n...          else:\n...              # draw center with R=1\n...              radius = 1 * draw_multiplier\n...              cv2.circle(img, center, radius,\\\n                  color, 1, cv2.LINE_AA)\n\n...          return img\nIn [30]: from random import randint\n...      def drawKeypoints(image, keypoints):\n...          for keypoint in keypoints:\n...              color = (randint(0,256),randint(0,256),randint(0,256))\n...              image = drawKeypoint(image, keypoint, color)\n...          return image\n```", "```py\nIn [31]: result = drawKeypoints(img, keyPoints)\nIn [32]: print(\"Number of keypoints = {}\".format(len(keyPoints)))\nOut[32]: Number of keypoints = 453\nIn [33]: plt.figure(figsize=(18,9))\n...      plt.imshow(result)\n```", "```py\nIn [34]: img = cv2.imread('data/rubic-cube.png')...      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)In [35]: orb = cv2.ORB_create()In [36]: keyPoints = orb.detect(gray,None)In [37]: keyPoints, descriptors ...\n```"]