- en: Developing Segmentation Algorithms for Text Recognition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发用于文本识别的分割算法
- en: In the previous chapters, we learned about a wide range of image processing
    techniques such as thresholding, contours descriptors, and mathematical morphology.
    In this chapter, we will discuss common problems that you may face while dealing
    with scanned documents, such as identifying where the text is or adjusting its
    rotation. We will also learn how to combine techniques presented in the previous
    chapters to solve those problems. By the end of this chapter, we will have segmented
    regions of text that can be sent to an **optical character recognition** (**OCR**)
    library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了广泛的各种图像处理技术，如阈值、轮廓描述符和数学形态学。在本章中，我们将讨论在处理扫描文档时可能遇到的一些常见问题，例如识别文本位置或调整其旋转。我们还将学习如何结合前面章节中介绍的技术来解决这些问题。到本章结束时，我们将分割出可以发送到
    **光学字符识别** (**OCR**) 库的文本区域。
- en: 'By the end of this chapter, you should be able to answer the following questions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够回答以下问题：
- en: What kind of OCR applications exists?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些类型的 OCR 应用程序？
- en: What are the common problems while writing an OCR application?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写 OCR 应用程序时，常见的难题有哪些？
- en: How do I identify regions of documents?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何识别文档的区域？
- en: How do I deal with problems like skewing and other elements in the middle of
    the text?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何处理文本中的倾斜和其他中间元素等问题？
- en: How do I use Tesseract OCR to identify my text?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何使用 Tesseract OCR 来识别我的文本？
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires familiarity with the basic C++ programming language. All
    of the code that's used in this chapter can be downloaded from the following GitHub
    link:[https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_10](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_10).
    The code can be executed on any operating system, though it has only been tested
    on Ubuntu.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要熟悉基本的 C++ 编程语言。本章中使用的所有代码都可以从以下 GitHub 链接下载：[https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_10](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_10)。代码可以在任何操作系统上执行，尽管它只在
    Ubuntu 上进行了测试。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，看看代码的实际应用：
- en: '[http://bit.ly/2KIoJFX](http://bit.ly/2KIoJFX)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2KIoJFX](http://bit.ly/2KIoJFX)'
- en: Introducing optical character recognition
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍光学字符识别
- en: 'Identifying text in an image is a very popular application for computer vision.
    This process is commonly called **optical character recognition**, and is divided
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中识别文本是计算机视觉中一个非常流行的应用。这个过程通常被称为 **光学字符识别**，并分为以下几部分：
- en: '**Text preprocessing and segmentation**: During this step, the computer must
    deal with image noise, and rotation (skewing), and identify what areas are candidate
    text.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本预处理和分割**：在这个步骤中，计算机必须处理图像噪声、旋转（倾斜）并识别哪些区域是候选文本区域。'
- en: '**Text identification**: This is the process of identifying each letter in
    text. Although this is also a computer vision topic, we will not show how you
    to do this in this book purely using OpenCV. Instead, we will show you how to
    use the Tesseract library to do this step, since it was integrated in OpenCV 3.0\.
    If you are interested in learning how to do what Tesseract does by yourself, take
    a look at Packt''s *Mastering OpenCV* book, which presents a chapter on car plate
    recognition.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本识别**：这是识别文本中每个字母的过程。尽管这也是一个计算机视觉话题，但在这本书中，我们不会仅使用 OpenCV 展示如何做到这一点。相反，我们将向您展示如何使用
    Tesseract 库来完成这一步，因为它集成在 OpenCV 3.0 中。如果您对学习如何自己完成 Tesseract 所做的工作感兴趣，请查看 Packt
    的 *Mastering OpenCV* 书籍，其中有一章介绍车牌识别。'
- en: 'The preprocessing and segmentation phase can vary greatly depending on the
    source of the text. Let''s take a look at common situations where preprocessing
    is done:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理和分割阶段可能会因文本来源而大相径庭。让我们看看预处理通常进行的常见情况：
- en: '**Production OCR applications with a scanner**: This is a very reliable source
    of text. In this scenario, the background of the image is usually white and the
    document is almost aligned with the scanner margins. The content that''s being
    scanned contains basically text, with almost no noise. This kind of application
    relies on simple preprocessing techniques that can adjust text quickly and maintain
    a fast scanning pace. When writing production OCR software, it is common to delegate
    the identification of important text regions to the user, and create a quality
    pipeline for text verification and indexing.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用扫描仪生产OCR应用**: 这是一个非常可靠的文本来源。在这种情况下，图像的背景通常是白色的，文档几乎与扫描仪的边缘对齐。正在扫描的内容基本上是文本，几乎没有任何噪声。这类应用依赖于简单的预处理技术，可以快速调整文本并保持快速的扫描速度。在编写生产OCR软件时，通常会将重要文本区域的识别委托给用户，并创建一个用于文本验证和索引的质量管道。'
- en: '**Scanning text in a casually taken picture or in a video**: This is a much
    more complex scenario, since there''s no indication of where the text can be.
    This scenario is called **scene text recognition**, and OpenCV 4.0 contains a
    contrib library to deal with it. We will cover this in [Chapter 11](e39c0201-3568-4793-911b-9af5d1883d66.xhtml),
    *Text Recognition with Tesseract*. Usually, the preprocessor will use texture
    analysis techniques to identify the text patterns.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扫描随意拍摄的图片或视频中的文本**: 这是一个更加复杂的场景，因为没有指示文本可能的位置。这种情况被称为**场景文本识别**，OpenCV 4.0包含一个用于处理此问题的contrib库。我们将在[第11章](e39c0201-3568-4793-911b-9af5d1883d66.xhtml)，*使用Tesseract进行文本识别*中介绍。通常，预处理器会使用纹理分析技术来识别文本模式。'
- en: '**Creating a production quality OCR for historical texts**: Historical texts
    are also scanned, but they have several additional problems, such as noise that''s
    created by the old paper color and the use of ink. Other common problems are decorated
    letters and specific text fonts, and low contrast content that''s created by ink
    that is erased over time. It''s not uncommon to write specific OCR software for
    the documents at hand.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为历史文本创建生产质量的OCR**: 历史文本也被扫描，但它们有几个额外的问题，例如由旧纸张颜色和墨水使用产生的噪声。其他常见问题包括装饰字母和特定的文本字体，以及由随着时间的推移被擦除的墨水产生的低对比度内容。为手头的文档编写特定的OCR软件并不罕见。'
- en: '**Scanning maps**, **diagrams**, **and charts**: Maps, diagrams, and charts
    pose an especially difficult scenario since the text is usually in any orientation
    and in the middle of image content. For example, city names are often clustered,
    and ocean names often follow country shore contour lines. Some charts are heavily
    colored, with text appearing in both clear and dark tones.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扫描地图、图表和图表**: 地图、图表和图表构成了一个特别困难的场景，因为文本通常以任何方向出现在图像内容中间。例如，城市名称通常成群分布，海洋名称通常沿着国家海岸轮廓线。一些图表颜色很深，文本以清晰和暗色调出现。'
- en: OCR application strategies also vary according to the objective of the identification.
    Will it be used for a full text search? Or should the text be separated into logical
    fields to index a database with information for a structured search?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OCR应用策略也根据识别的目标而变化。它将被用于全文搜索吗？或者应该将文本分离成逻辑字段以索引包含结构化搜索信息的数据库？
- en: 'In this chapter, we will focus on preprocessing scanned text, or text that''s
    been photographed by a camera. We''ll consider that the text is the main purpose
    of the image, such as in a photographed piece of paper or card, for example, in
    this parking ticket:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于预处理扫描文本或由相机拍摄的文本。我们将考虑文本是图像的主要目的，例如，在一张照片或卡片上，例如，在这张停车票上：
- en: '![](img/33c9ec1a-b339-43aa-ba68-b3a2425be2a6.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33c9ec1a-b339-43aa-ba68-b3a2425be2a6.png)'
- en: We'll try to remove common noise, deal with text rotation (if any), and crop
    the possible text regions. While most OCR APIs already do these things automatically
    – and probably with state-of-the-art algorithms—it is still worth knowing how
    things happen under the hood. This will allow you to better understand most OCR
    APIs parameters and will give you better knowledge about the potential OCR problems
    you may face.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试移除常见的噪声，处理文本旋转（如果有），并裁剪可能的文本区域。虽然大多数OCR API已经自动执行这些操作——并且可能使用最先进的算法——但了解这些操作背后的原理仍然很有价值。这将使您更好地理解大多数OCR
    API参数，并为您提供有关您可能遇到的潜在OCR问题的更好知识。
- en: Preprocessing stage
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理阶段
- en: Software that identifies letters does so by comparing text with previously recorded
    data. Classification results can be improved greatly if the input text is clear,
    if the letters are in a vertical position, and if there's no other elements, such
    as images sent to the classification software. In this section, we'll learn how
    to adjust text by using **preprocessing**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 软件通过将文本与先前记录的数据进行比较来识别字母。如果输入文本清晰、字母处于垂直位置且没有其他元素（例如发送给分类软件的图像），则分类结果可以大大提高。在本节中，我们将学习如何通过使用**预处理**来调整文本。
- en: Thresholding the image
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像阈值化
- en: 'We usually start preprocessing by thresholding the image. This eliminates all
    color information. Most OpenCV functions consider information to be written in
    white, and the background to be black. So, let''s start by creating a threshold
    function to match this criteria:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过阈值化图像开始预处理。这消除了所有颜色信息。大多数OpenCV函数认为信息是以白色写入的，而背景是黑色的。因此，让我们首先创建一个阈值函数来匹配这些标准：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `binarize` function applies a threshold, similar to what we did in [Chapter
    4](ceaab6b4-2f4a-45e4-9f5d-2544c75bd405.xhtml), *Delving into Histogram and Filters*.
    But here, we will use the Otsu method by passing `THRESH_OTSU` in the fourth parameter
    of the function. The Otsu method maximizes inter-class variance. Since a threshold
    creates only two classes (the black and white pixels), this is the same as minimizing
    the intraclass variance. This method works using the image histogram. Then, it
    iterates through all the possible threshold values and calculates the spread for
    the pixel values for each side of the threshold, that is, the pixels that are
    either in the background or in the foreground of the image. The purpose of this
    process is to find the threshold value where the sum of both spreads are at their
    minimum.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`binarize`函数应用一个阈值，类似于我们在[第4章](ceaab6b4-2f4a-45e4-9f5d-2544c75bd405.xhtml)“深入直方图和滤波器”中所做的。但在这里，我们将通过在函数的第四个参数中传递`THRESH_OTSU`来使用Otsu方法。Otsu方法最大化类间方差。由于阈值只创建两个类别（黑色和白色像素），这等同于最小化类内方差。这种方法使用图像直方图。然后，它遍历所有可能的阈值值，并计算阈值两侧像素值的扩散，即图像的背景或前景中的像素。这个过程的目的在于找到使两个扩散之和达到最小值的阈值值。'
- en: After the thresholding is done, the function counts how many white pixels are
    in the image. The black pixels are simply the total number of pixels in the image,
    given by the image area, minus the white pixel count. Since text is usually written
    over a plain background, we will verify whether there are more white pixels than
    there are black pixels. In this case, we are dealing with black text over a white
    background, so we will invert the image for further processing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值化完成后，该函数会计算图像中白色像素的数量。黑色像素只是图像中像素的总数，由图像面积给出，减去白色像素计数。由于文本通常是在纯背景上书写的，我们将验证白色像素是否多于黑色像素。在这种情况下，我们处理的是黑色文字在白色背景上，因此我们将图像反转以进行进一步处理。
- en: 'The result of the thresholding process with the parking ticket image is as
    follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用停车票图像进行阈值化处理的结果如下：
- en: '![](img/49e0e74e-2cf2-436f-9f97-bdfabcace97c.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49e0e74e-2cf2-436f-9f97-bdfabcace97c.png)'
- en: Text segmentation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本分割
- en: 'The next step is to find where the text is located and extract it. There are
    two common strategies for this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到文本的位置并提取它。为此有两种常见的策略：
- en: '**Using connected component analysis**: Searching groups of connected pixels
    in the image. This will be the technique that will be used in this chapter.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用连通分量分析**：在图像中搜索连接像素的组。这将是本章中使用的技巧。'
- en: '**Use classifiers to search for a previously trained letter texture pattern**:
    with texture features such as **Haralick **features, wavelet transforms are often
    used. Anther option is to identify **maximally stable extremal regions** (**MSER**s)
    in this task. This approach is more robust for text in a complex background and
    will be studied in [Chapter 11](e39c0201-3568-4793-911b-9af5d1883d66.xhtml), *Text
    Recognition with Tesseract*. You can read about Haralick features at his own website,
    which can be found at [http://haralick.org/journals/TexturalFeatures.pdf](http://haralick.org/journals/TexturalFeatures.pdf).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用分类器搜索先前训练的字母纹理模式**：使用如**Haralick**特征这样的纹理特征，通常使用小波变换。另一种选择是在此任务中识别**最大稳定极值区域**（**MSER**）。这种方法对于复杂背景中的文本更稳健，将在[第11章](e39c0201-3568-4793-911b-9af5d1883d66.xhtml)“使用Tesseract进行文本识别”中研究。您可以在Haralick特征的官方网站上了解更多信息，网址为[http://haralick.org/journals/TexturalFeatures.pdf](http://haralick.org/journals/TexturalFeatures.pdf)。'
- en: Creating connected areas
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建连通区域
- en: If you take a closer look at the image, you'll notice that the letters are always
    together in blocks, formed by text paragraphs. That leaves us with the question,
    how do we detect and remove these blocks?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察图像，你会注意到字母总是成块地在一起，由文本段落形成。这让我们提出了一个问题，我们如何检测和移除这些块？
- en: 'The first step is to make these blocks even more evident. We can do this by
    using the dilation morphological operator. Recall from [Chapter 8](58a72603-be5a-465f-aa7b-fc8ab1aae596.xhtml),
    *Video Surveillance*, *Background Modeling*, *and Morphological Operations*, that
    dilation makes the image elements thicker. Let''s look at a small code snippet
    that does the trick:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使这些块更加明显。我们可以通过使用膨胀形态学算子来实现这一点。回想一下[第8章](58a72603-be5a-465f-aa7b-fc8ab1aae596.xhtml)，*视频监控*，*背景建模*，*和形态学操作*，膨胀会使图像元素变厚。让我们看看一个小代码片段，它完成了这个任务：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we start by creating a 3 x 3 cross kernel that will be
    used in the morphological operation. Then, we apply dilation five times, centered
    on this kernel. The exact kernel size and number of times vary according to the
    situation. Just make sure that the values glue all of the letters in the same
    line together.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了一个3 x 3的十字形核，它将在形态学操作中使用。然后，我们以这个核为中心进行五次膨胀。确切的核大小和次数根据情况而变化。只需确保这些值将同一行上的所有字母粘合在一起即可。
- en: 'The result of this operation is presented in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的成果如下截图所示：
- en: '![](img/3e7f8e70-3d29-4e4d-9a76-15df7d9db8e7.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e7f8e70-3d29-4e4d-9a76-15df7d9db8e7.png)'
- en: Notice that we now have huge white blocks. They match exactly with each paragraph
    of text, and also match with other non-textual elements, like images or the border
    noise.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在有了巨大的白色块。它们与每段文本完全匹配，也与其他非文本元素匹配，如图像或边缘噪声。
- en: The ticket image that comes with the code is a low resolution image. OCR engines
    usually work with high resolution images (200 or 300 DPI), so it may be necessary
    to apply dilation more than five times.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码附带的票据图像是低分辨率图像。OCR引擎通常与高分辨率图像（200或300 DPI）一起工作，因此可能需要将膨胀应用超过五次。
- en: Identifying paragraph blocks
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别段落块
- en: 'The next step is to perform connect component analysis to find blocks that
    correspond with paragraphs. OpenCV has a function for this, which we previously
    used in [Chapter 5](b788527c-5892-4547-8add-0864ccbd3f95.xhtml), *Automated Optical
    Inspection*, *Object Segmentation*, *and Detection*. This is the `findContours`
    function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是执行连通组件分析以找到与段落对应的块。OpenCV有一个用于此目的的函数，我们之前在[第5章](b788527c-5892-4547-8add-0864ccbd3f95.xhtml)，*自动光学检测*，*对象分割*，*和检测*中已经使用过。这是`findContours`函数：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the first parameter, we pass our dilated image. The second parameter is
    the vector of detected contours. Then, we use the option to retrieve only external
    contours and to use simple approximation. The image contours are presented as
    follows. Each tone of gray represents a different contour:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个参数中，我们传递我们的膨胀图像。第二个参数是检测到的轮廓的向量。然后，我们使用选项仅检索外部轮廓并使用简单近似。图像轮廓如下所示。每种灰度色调代表不同的轮廓：
- en: '![](img/77e6041a-d703-4078-ab93-1e24f2a6c85e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77e6041a-d703-4078-ab93-1e24f2a6c85e.png)'
- en: 'The last step is to identify the minimum rotated bounding rectangle of each
    contour. OpenCV provides a handy function for this operation called `minAreaRect`.
    This function receives a vector of arbitrary points and returns a `RoundedRect`
    containing the bounding box. This is also a good opportunity to discard unwanted
    rectangles, that is, rectangles that are obviously not text. Since we are making
    software for OCR, we''ll assume that the text contains a group of letters. With
    this assumption, we''ll discard text in the following situations:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是识别每个轮廓的最小旋转边界矩形。OpenCV提供了一个方便的函数来完成这个操作，称为`minAreaRect`。这个函数接收一个任意点的向量，并返回一个包含边界框的`RoundedRect`。这也是丢弃不需要的矩形的良好机会，即显然不是文本的矩形。由于我们正在为OCR制作软件，我们将假设文本包含一组字母。基于这个假设，我们将以下情况中的文本丢弃：
- en: The rectangle width or size is too small, that is, smaller than 20 pixels. This
    will help discard border noises and other small artifacts.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形宽度或大小太小，即小于20像素。这将有助于丢弃边缘噪声和其他小瑕疵。
- en: The rectangle of the image has a width/height proportion smaller than two. That
    is, rectangles that resemble a square, such as the image icons, or are much taller,
    will also be discarded.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的矩形宽度/高度比例小于 2。也就是说，类似于正方形的矩形，如图像图标，或者非常高的矩形，也将被丢弃。
- en: There's a little caveat in the second condition. Since we are dealing with rotated
    bounding boxes, we must test whether the bounding box angle is smaller than -45
    degrees. If it is, the text is vertically rotated, so the proportion that we must
    take into account is height/width.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条件中有一个小问题。由于我们处理的是旋转的边界框，我们必须测试边界框的角度是否小于 -45 度。如果是，文本是垂直旋转的，因此我们必须考虑的高度/宽度比例。
- en: 'Let''s check this out by looking at the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码来查看一下：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see which boxes this algorithm selected:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个算法选择了哪些框：
- en: '![](img/740e6bb3-bd1c-4304-b490-fb7e2711ce0e.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/740e6bb3-bd1c-4304-b490-fb7e2711ce0e.png)'
- en: That's certainly a good result!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个很好的结果！
- en: We should notice that the algorithm described in step 2, in the preceding code,
    will also discard single letters. This is not a big issue since we are creating
    an OCR preprocessor, and single symbols are usually meaningless with context information;
    one example of such a case is the page numbers. The page numbers will be discarded
    with this process since they usually appear alone at the bottom of the page, and
    the size and proportion of the text will also be disturbed. But this will not
    be a problem, since after the text passes through the OCR, you will end up with
    a huge amount of text files with no page division at all.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意到，在前面代码的第 2 步中描述的算法也会丢弃单个字母。这不是一个大问题，因为我们正在创建一个 OCR 预处理器，并且单个符号通常在没有上下文信息的情况下没有意义；一个这样的例子是页码。由于页码通常单独出现在页面底部，并且文本的大小和比例也会受到影响，因此这个过程会将页码丢弃。但这不会成为问题，因为文本通过
    OCR 后，你将得到大量没有任何分页的文本文件。
- en: 'We''ll place all of this code in a function with the following signature:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把所有这些代码放在一个具有以下签名的函数中：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Text extraction and skewing adjustment
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本提取和倾斜调整
- en: 'Now, all we must do is extract the text and adjust the text skew. This is done
    by the `deskewAndCrop` function, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要提取文本并调整文本倾斜。这是通过 `deskewAndCrop` 函数完成的，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, we start by reading the desired region angle and size. As we saw earlier,
    the angle may be less than -45 degrees. This means that the text is vertically
    aligned, so we must add 90 degrees to the rotation angle and switch the width
    and height properties. Next, we need to rotate the text. First, we start by creating
    a 2D affine transformation matrix that describes the rotation. We do so by using
    the `getRotationMatrix2D` OpenCV function. This function takes three parameters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从读取所需的区域角度和大小开始。正如我们之前看到的，角度可能小于 -45 度。这意味着文本是垂直对齐的，因此我们必须将旋转角度增加 90 度，并切换宽度和高度属性。接下来，我们需要旋转文本。首先，我们创建一个描述旋转的
    2D 仿射变换矩阵。我们通过使用 `getRotationMatrix2D` OpenCV 函数来实现这一点。这个函数有三个参数：
- en: '**CENTER**: The central position of the rotation. The rotation will pivot around
    this center. In our case, we use the box center.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CENTER**: 旋转的中心位置。旋转将围绕这个中心旋转。在我们的情况下，我们使用框的中心。'
- en: '**ANGLE**: The rotation angle. If the angle is negative, the rotation will
    occur in a clockwise direction.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ANGLE**: 旋转角度。如果角度是负数，旋转将以顺时针方向进行。'
- en: '**SCALE**: The isotropic scale factor. We will use `1.0` since we want to keep
    the box''s original scale untouched.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCALE**: 各向同性的缩放因子。我们将使用 `1.0`，因为我们想保持框的原始比例不变。'
- en: 'The rotation itself is made by using the `warpAffine` function. This function
    takes four mandatory arguments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转本身是通过使用 `warpAffine` 函数实现的。这个函数有四个必选参数：
- en: '**SRC**: The input `mat` array to be transformed.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SRC**: 要变换的输入 `mat` 数组。'
- en: '**DST**: The destination `mat` array.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DST**: 目标 `mat` 数组。'
- en: '**M**: A transformation matrix. This matrix is a 2 x 3 affine transformation
    matrix. This may be a translation, scale, or rotation matrix. In our case, we
    will just use the matrix we recently created.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M**: 变换矩阵。这个矩阵是一个 2 x 3 的仿射变换矩阵。这可能是一个平移、缩放或旋转矩阵。在我们的情况下，我们只会使用我们最近创建的矩阵。'
- en: '**SIZE**: The size of the output image. We will generate an image that''s the
    same size as our input image.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIZE**: 输出图像的大小。我们将生成与输入图像大小相同的图像。'
- en: 'The following are another three optional arguments:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下还有另外三个可选参数：
- en: '**FLAGS**: These indicate how the image should be interpolated. We use `BICUBIC_INTERPOLATION`
    for better quality. The default is `LINEAR_INTERPOLATION`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FLAGS**: 这些指示图像应该如何插值。我们使用 `BICUBIC_INTERPOLATION` 以获得更好的质量。默认为 `LINEAR_INTERPOLATION`。'
- en: '**BORDER**: Border mode. We use the default, `BORDER_CONSTANT`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BORDER**: 边框模式。我们使用默认值，`BORDER_CONSTANT`。'
- en: '**BORDER VALUE**: The color of the border. We use the default, which is black.
    Then, we use the `getRectSubPix` function. After we rotate our image, we need
    to crop the rectangle area of our bounding box. This function takes four mandatory
    arguments and one optional argument, and returns the cropped image:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BORDER VALUE**: 边框的颜色。我们使用默认值，即黑色。然后，我们使用 `getRectSubPix` 函数。在我们旋转图像后，我们需要裁剪边界框的矩形区域。此函数接受四个强制参数和一个可选参数，并返回裁剪后的图像：'
- en: '**IMAGE**: The image to crop.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IMAGE**: 要裁剪的图像。'
- en: '**SIZE**: A `cv::Size` object describing the width and height of the box to
    be cropped.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIZE**: 描述要裁剪的框的宽度和高度的 `cv::Size` 对象。'
- en: '**CENTER**: The central pixel of the area to be cropped. Notice that since
    we rotated around the center, this point is conveniently the same.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CENTER**: 要裁剪区域的中心像素。请注意，由于我们围绕中心旋转，这个点很方便地是相同的。'
- en: '**PATCH**: The destination image.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH**: 目标图像。'
- en: '**PATCH_TYPE**: The depth of the destination image. We use the default value,
    representing the same depth of the source image.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH_TYPE**: 目标图像的深度。我们使用默认值，表示与源图像相同的深度。'
- en: 'The final step is done by the `copyMakeBorder` function. This function adds
    a border around the image. This is important, since the classification stage usually
    expects a margin around the text. The function parameters are very simple: the
    input and output images, the border thickness at the top, bottom, left, and right,
    the border type, and the color of the new border.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步由 `copyMakeBorder` 函数完成。此函数在图像周围添加边框。这很重要，因为分类阶段通常期望文本周围有边距。函数参数非常简单：输入和输出图像、顶部、底部、左侧和右侧的边框厚度、边框类型以及新边框的颜色。
- en: 'For the card image, the following images will be generated:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于卡片图像，将生成以下图像：
- en: '![](img/4fb5fee5-8e34-40b6-b20c-2544729a0efc.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fb5fee5-8e34-40b6-b20c-2544729a0efc.png)'
- en: 'Now, it''s time to put every function together. Let''s present the main method
    that does the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将每个函数组合在一起了。让我们展示以下主要方法：
- en: Loads the ticket image
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载票据图像
- en: Calls our binarization function
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用我们的二值化函数
- en: Find all text regions
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有文本区域
- en: Shows each region in a window
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口中显示每个区域
- en: 'We will present the main method as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如下展示主要方法：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the complete source code, take a look at the `segment.cpp` file that comes
    with this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的源代码，请查看本书附带 `segment.cpp` 文件。
- en: Installing Tesseract OCR on your operating system
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的操作系统上安装 Tesseract OCR
- en: 'Tesseract is an open source OCR engine that was originally developed by Hewlett-Packard
    Laboratories Bristol and Hewlett-Packard Co. All of its code is licensed under
    the Apache License and hosted on GitHub at [https://github.com/tesseract-ocr](https://github.com/tesseract-ocr).
    It is considered one of the most accurate OCR engines available: it can read a
    wide variety of image formats and can convert text written in more than 60 languages.
    In this session, we will teach you how to install Tesseract on Windows or Mac.
    Since there''s lots of Linux distributions, we will not teach you how to install
    it on this operating system. Normally, Tesseract offers installation packages
    in your package repository, so, before compiling Tesseract yourself, just search
    for it there.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Tesseract 是一个开源的 OCR 引擎，最初由惠普实验室布里斯托尔和惠普公司开发。其所有代码均根据 Apache 许可证授权，并在 GitHub
    上托管在 [https://github.com/tesseract-ocr](https://github.com/tesseract-ocr)。它被认为是可用的最准确的
    OCR 引擎之一：它可以读取多种图像格式，并且可以将超过 60 种语言的文本转换为文本。在本节中，我们将向您展示如何在 Windows 或 Mac 上安装
    Tesseract。由于有大量的 Linux 发行版，我们不会教您如何在操作系统上安装它。通常，Tesseract 在您的软件仓库中提供安装包，因此，在自行编译
    Tesseract 之前，只需在那里搜索即可。
- en: Installing Tesseract on Windows
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Tesseract
- en: Tesseract uses the **C++ Archive Network** (**CPPAN**) as its dependency manager.
    To install Tesseract, follow these steps.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Tesseract 使用 **C++ 归档网络**（**CPPAN**）作为其依赖项管理器。要安装 Tesseract，请按照以下步骤操作。
- en: Building the latest library
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建最新库
- en: Download the latest CPPAN client from [https://cppan.org/client/](https://cppan.org/client/).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://cppan.org/client/](https://cppan.org/client/) 下载最新的 CPPAN 客户端。
- en: In the command line, run
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中运行
- en: '`cppan --build pvt.cppan.demo.google.tesseract.tesseract-master`.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cppan --build pvt.cppan.demo.google.tesseract.tesseract-master`。'
- en: Setting up Tesseract in Visual Studio
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Visual Studio中设置Tesseract
- en: Set up `vcpkg`,the Visual C++ Package Manager, at [https://github.com/Microsoft/vcpkg](https://github.com/Microsoft/vcpkg).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://github.com/Microsoft/vcpkg](https://github.com/Microsoft/vcpkg)设置`vcpkg`，Visual
    C++包管理器。
- en: For a 64-bit compilation, use `vcpkg install tesseract:x64-windows`. You may
    also add `--head` for the master branch.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于64位编译，使用`vcpkg install tesseract:x64-windows`。你也可以为master分支添加`--head`。
- en: Static linking
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态链接
- en: 'It''s also possible to static link ([https://github.com/tesseract-ocr/tesseract/wiki/Compiling#static-linking](https://github.com/tesseract-ocr/tesseract/wiki/Compiling#static-linking))
    Tesseract in your project. This will avoid `dlls` to be packaged with your executable
    files. To do this, use `vcpkg`, like we did previously, with the following command
    for a 32-bit installation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在你的项目中静态链接{Tesseract}([https://github.com/tesseract-ocr/tesseract/wiki/Compiling#static-linking](https://github.com/tesseract-ocr/tesseract/wiki/Compiling#static-linking))。这将避免`dlls`与你的可执行文件一起打包。为此，使用与之前相同的`vcpkg`，对于32位安装使用以下命令：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can use the following command for a 64-bit installation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下命令进行64位安装：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Installing Tesseract on Mac
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac上安装Tesseract
- en: The easiest way to install Tesseract OCR on Mac is using **Homebrew**. If you
    don't have Homebrew installed, just go to Homebrew's site ([http://brew.sh/](http://brew.sh/)),
    open your console, and run the **Ruby script** that is on the front page. You
    may be required to type in your administrator password.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上安装Tesseract OCR最简单的方法是使用**Homebrew**。如果你还没有安装Homebrew，只需访问Homebrew的网站([http://brew.sh/](http://brew.sh/))，打开你的控制台，并运行首页上的**Ruby脚本**。你可能需要输入管理员密码。
- en: 'After Homebrew is installed, just type in the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Homebrew后，只需输入以下命令：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The English language is already included in this installation. If you want
    to install other language packs, just run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 英语语言已经包含在这个安装中。如果你想安装其他语言包，只需运行以下命令：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will install all of the language packs. Then, just go to the Tesseract
    installation directory and delete any unwanted languages. Homebrew usually installs
    stuff in the `/usr/local/` directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所有语言包。然后，只需转到Tesseract安装目录，删除任何不需要的语言。Homebrew通常在`/usr/local/`目录中安装东西。
- en: Using the Tesseract OCR library
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tesseract OCR库
- en: While Tesseract OCR is already integrated with OpenCV 3.0, it's still worth
    studying its API since it allows for finer grained control over Tesseract parameters.
    This integration will be studied in [Chapter 11](e39c0201-3568-4793-911b-9af5d1883d66.xhtml),
    *Text Recognition with Tesseract*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然{Tesseract OCR}已经与OpenCV 3.0集成，但仍然值得研究其API，因为它允许对Tesseract参数进行更细粒度的控制。这种集成将在第11章[文本识别与Tesseract](e39c0201-3568-4793-911b-9af5d1883d66.xhtml)中进行研究。
- en: Creating an OCR function
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个OCR函数
- en: 'We''ll change the previous example to work with Tesseract. Start by adding
    `tesseract/baseapi.h` and `fstream` to the `include` list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改之前的示例以使用Tesseract。首先，将`tesseract/baseapi.h`和`fstream`添加到`include`列表中：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we''ll create a global `TessBaseAPI` object that represents our Tesseract
    OCR engine:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个全局的`TessBaseAPI`对象，它代表我们的Tesseract OCR引擎：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ocr` engine is completely self-contained. If you want to create a multi-threaded
    piece of OCR software, just add a different `TessBaseAPI` object in each thread,
    and the execution will be fairly thread-safe. You just need to guarantee that
    file writing is not done over the same file, otherwise you'll need to guarantee
    safety for this operation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`ocr`引擎是完全自包含的。如果你想创建一个多线程的OCR软件，只需在每个线程中添加一个不同的`TessBaseAPI`对象，执行将相当线程安全。你只需要确保文件写入不是在同一个文件上，否则你需要确保这个操作的安全性。'
- en: 'Next, we will create a function called **identify text **(`identifyText`) that
    will run the `ocr`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为**识别文本**(`identifyText`)的函数，该函数将运行`ocr`：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s explain this function line-by-line. In the first line, we start by initializing
    `tesseract`. This is done by calling the `Init` function. This function has the
    following signature:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解释这个函数。在第一行，我们首先初始化`tesseract`。这是通过调用`Init`函数来完成的。这个函数有以下签名：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s explain each parameter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解释每个参数：
- en: '`datapath`: This is the path to the root directory of `tessdata` files. The
    path must end with a backslash `/` character. The `tessdata` directory contains
    the language files that you installed. Passing `NULL` to this parameter will make
    `tesseract` search its installation directory, which is the location that this
    folder is normally present in. It''s common to change this value to `args[0]`
    when deploying an application, and include the `tessdata` folder in your application
    path.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datapath`: 这是`tessdata`文件根目录的路径。路径必须以反斜杠`/`字符结尾。`tessdata`目录包含您安装的语言文件。将`NULL`传递给此参数将使`tesseract`搜索其安装目录，这是该文件夹通常所在的位置。在部署应用程序时，通常将此值更改为`args[0]`，并将`tessdata`文件夹包含在您的应用程序路径中。'
- en: '`language`: This is a three letter word for the language code (for example,
    eng for English, por for Portuguese, or hin for Hindi). Tesseract supports loading
    multiple language codes by using the `+` sign. Therefore, passing `eng+por` will
    load both the English and Portuguese languages. Of course, you can only use languages
    you have previously installed, otherwise the loading process will fail. A language
    config file may specify that two or more languages must be loaded together. To
    prevent that, you may use a tilde `~`. For example, you can use `hin+~eng` to
    guarantee that English is not loaded with Hindi, even if it is configured to do
    so.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language`: 这是一个表示语言代码的三字母词（例如，eng表示英语，por表示葡萄牙语，或hin表示印地语）。Tesseract可以通过使用`+`符号加载多个语言代码。因此，传递`eng+por`将加载英语和葡萄牙语。当然，您只能使用您之前安装的语言，否则加载过程将失败。语言配置文件可能指定必须一起加载两种或多种语言。为了防止这种情况，您可以使用波浪号`~`。例如，您可以使用`hin+~eng`来确保即使配置了这样做，也不会将英语与印地语一起加载。'
- en: '`OcrEngineMode`: These are the OCR algorithms that will be used. It can have
    one of the following values:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OcrEngineMode`: 这些是将要使用的OCR算法。它可以有以下值之一：'
- en: '`OEM_TESSERACT_ONLY`: Uses just `tesseract`. It''s the fastest method, but
    it also has less precision.'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM_TESSERACT_ONLY`: 仅使用`tesseract`。这是最快的方法，但精度较低。'
- en: '`OEM_CUBE_ONLY`: Uses the Cube engine. It''s slower, but more precise. This
    will only work if your language was trained to support this engine mode. To check
    if that''s the case, look for `.cube` files for your language in the `tessdata`
    folder. The support for English language is guaranteed.'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM_CUBE_ONLY`: 使用Cube引擎。它较慢，但更精确。这仅在您的语言被训练以支持此引擎模式时才会工作。要检查是否如此，请查看`tessdata`文件夹中您语言的`.cube`文件。对英语语言的支持是保证的。'
- en: '`OEM_TESSERACT_CUBE_COMBINED`: This combines both Tesseract and Cube to achieve
    the best possible OCR classification. This engine has the best accuracy and the
    slowest execution time.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM_TESSERACT_CUBE_COMBINED`: 这结合了Tesseract和Cube以实现最佳的OCR分类。此引擎具有最佳精度和最慢的执行时间。'
- en: '`OEM_DEFAULT`: This infers the strategy based on the language config file,
    command-line config file or, in the absence of both, uses `OEM_TESSERACT_ONLY`.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM_DEFAULT`: 这基于语言配置文件、命令行配置文件推断策略，如果两者都不存在，则使用`OEM_TESSERACT_ONLY`。'
- en: It's important to emphasize that the `Init` function can be executed many times.
    If a different language or engine mode is provided, Tesseract will clear the previous
    configuration and start again. If the same parameters are provided, Tesseract
    is smart enough to simply ignore the command. The `init` function returns `0`
    in case of success and `-1` in case of failure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，`Init`函数可以执行多次。如果提供了不同的语言或引擎模式，Tesseract将清除之前的配置并重新开始。如果提供了相同的参数，Tesseract足够智能，可以简单地忽略该命令。`init`函数在成功时返回`0`，在失败时返回`-1`。
- en: 'Our program will then proceed by setting the page segmentation mode:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的程序将通过设置页面分割模式继续进行：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are several segmentation modes available:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种分割模式可用：
- en: '`PSM_OSD_ONLY`: Using this mode, Tesseract will just run its preprocessing
    algorithms to detect orientation and script detection.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_OSD_ONLY`: 使用此模式，Tesseract将仅运行其预处理算法以检测方向和脚本检测。'
- en: '`PSM_AUTO_OSD`: This tells Tesseract to do automatic page segmentation with
    orientation and script detection.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_AUTO_OSD`: 这指示Tesseract进行带有方向和脚本检测的自动页面分割。'
- en: '`PSM_AUTO_ONLY`: This does page segmentation, but avoids doing orientation,
    script detection, or OCR.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_AUTO_ONLY`: 这进行页面分割，但避免进行方向、脚本检测或OCR。'
- en: '`PSM_AUTO`: This does page segmentation and OCR, but avoids doing orientation
    or script detection.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_AUTO`: 这进行页面分割和OCR，但避免进行方向或脚本检测。'
- en: '`PSM_SINGLE_COLUMN`: This assumes that the text of variable sizes is displayed
    in a single column.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_COLUMN`: 这假设可变大小的文本显示在单列中。'
- en: '`PSM_SINGLE_BLOCK_VERT_TEXT`: This treats the image as a single uniform block
    of vertically aligned text.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_BLOCK_VERT_TEXT`: 这将图像视为一个单一生均匀垂直对齐文本块。'
- en: '`PSM_SINGLE_BLOCK`: This assumes a single block of text, and is the default
    configuration. We will use this flag since our preprocessing phase guarantees
    this condition.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_BLOCK`: 这假设有一个单独的文本块，并且是默认配置。我们将使用此标志，因为我们的预处理阶段保证了这种条件。'
- en: '`PSM_SINGLE_LINE`: Indicates that the image contains only one line of text.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_LINE`: 表示图像只包含一行文本。'
- en: '`PSM_SINGLE_WORD`: Indicates that the image contains just one word.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_WORD`: 表示图像只包含一个单词。'
- en: '`PSM_SINGLE_WORD_CIRCLE`: Informs us that the image is a just one word disposed
    in a circle.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_WORD_CIRCLE`: 通知我们图像是一个圆形中仅有一个单词。'
- en: '`PSM_SINGLE_CHAR`: Indicates that the image contains a single character.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_CHAR`: 表示图像包含单个字符。'
- en: Notice that Tesseract already has **deskewing** and text segmentation algorithms
    implemented, just like most OCR libraries do. But it's interesting to know of
    such algorithms since you may provide your own preprocessing phase for specific
    needs. This allows you to improve text detection in many cases. For example, if
    you are creating an OCR application for old documents, the default threshold used
    by Tesseract may create a dark background. Tesseract may also be confused by borders
    or severe text skewing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Tesseract 已经实现了**倾斜校正**和文本分割算法，就像大多数 OCR 库一样。但了解这些算法是有趣的，因为你可以为特定需求提供自己的预处理阶段。这允许你在许多情况下提高文本检测。例如，如果你正在为旧文档创建
    OCR 应用程序，Tesseract 默认使用的阈值可能会创建一个深色背景。Tesseract 也可能被边缘或严重的文本倾斜所困惑。
- en: 'Next, we call the `SetImage` method with the following signature:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下签名调用`SetImage`方法：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The parameters are almost self-explanatory, and most of them can be read directly
    from our `Mat` object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 参数几乎都是自我解释的，并且大多数都可以直接从我们的`Mat`对象中读取：
- en: '`data`: A raw byte array containing image data. OpenCV contains a function
    called `data()` in the `Mat` class that provides a direct pointer to the data.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`: 包含图像数据的原始字节数组。OpenCV 在`Mat`类中包含一个名为`data()`的函数，它提供对数据的直接指针。'
- en: '`width`: Image width.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`: 图像宽度。'
- en: '`height`: Image height.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`: 图像高度。'
- en: '`bytes_per_pixel`: Number of bytes per pixel. We are using `1`, since we are
    dealing with a binary image. If you want the code to be more generic, you could
    also use the `Mat::elemSize()` function, which provides the same information.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes_per_pixel`: 每个像素的字节数。由于我们处理的是二进制图像，我们使用`1`。如果你想使代码更通用，你也可以使用`Mat::elemSize()`函数，它提供相同的信息。'
- en: '`bytes_per_line`: Number of bytes in a single line. We are using the `Mat::step`
    property since some images add trailing bytes.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes_per_line`: 单行中的字节数。我们使用`Mat::step`属性，因为某些图像添加了尾随字节。'
- en: Then, we call `GetUTF8Text` to run the recognition itself. The recognized text
    is returned, encoded with UTF8 and without BOM. Before returning it, we also print
    some debug information.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`GetUTF8Text`来运行识别本身。识别的文本返回，使用 UTF8 编码且不带 BOM。在返回之前，我们还打印了一些调试信息。
- en: '`MeanTextConf` returns a confidence index, which may by a number from `0` to
    `100`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeanTextConf` 返回一个置信度指数，可能是一个从`0`到`100`的数字：'
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sending the output to a file
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输出发送到文件
- en: 'Let''s change our main method to send the recognized output to a file. We do
    this by using a standard `ofstream`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将主方法更改为将识别输出发送到文件。我们通过使用标准`ofstream`来完成此操作：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following line opens the file in binary mode:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行以二进制模式打开文件：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is important since Tesseract returns text encoded in UTF-8, taking into
    account special characters that are available in Unicode. We also write the output
    directly using the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为 Tesseract 返回的文本使用 UTF-8 编码，考虑到 Unicode 中可用的特殊字符。我们还将输出直接使用以下命令写入：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this sample, we called the `identify` function using Portuguese as an input
    language (this is the language the ticket was written in). You may use another
    photo, if you like.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用葡萄牙语作为输入语言调用了`identify`函数（这是票证所写的语言）。如果你喜欢，可以使用另一张照片。
- en: The complete source file is provided in the `segmentOcr.cpp` file, which comes
    with this book.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码文件包含在`segmentOcr.cpp`文件中，该文件与本书一起提供。
- en: '`ticket.png` is a low resolution image, since we imagined you would want to
    display a window with the image while studying this code. For this image, the
    Tesseract results are rather poor. If you want to test with a higher resolution
    image, the code for this book provides you with a `ticketHigh.png` image. To test
    with this image, change the dilation repetitions to `12` and the minimum box size
    from `20` to `60`. You''ll get a much higher confidence rate (about 87%), and
    the resulting text will be almost fully readable. The `segmentOcrHigh.cpp` file
    contains these modifications.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ticket.png` 是一个低分辨率图像，因为我们想象你在学习这段代码时可能想要显示一个包含图像的窗口。对于这个图像，Tesseract的结果相当差。如果你想使用更高分辨率的图像进行测试，本书提供的代码为你提供了一个
    `ticketHigh.png` 图像。要使用这个图像进行测试，将膨胀重复次数改为 `12`，并将最小框大小从 `20` 改为 `60`。你将获得更高的置信率（大约
    87%），并且生成的文本将几乎完全可读。`segmentOcrHigh.cpp` 文件包含这些修改。'
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we presented a brief introduction to OCR applications. We saw
    that the preprocessing phase of such systems must be adjusted according to the
    type of document we are planning to identify. We have learned about common operations
    while preprocessing text files, such as thresholding, cropping, skewing, and text
    region segmentation. Finally, we learned how to install and use Tesseract OCR
    to convert our image into text.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了OCR应用。我们了解到，这类系统的预处理阶段必须根据我们计划识别的文档类型进行调整。我们学习了在预处理文本文件时的常见操作，例如阈值处理、裁剪、倾斜和文本区域分割。最后，我们学习了如何安装和使用Tesseract
    OCR将我们的图像转换为文本。
- en: In the next chapter, we'll use a more sophisticated OCR technique to identify
    text in a casually taken picture or video –a situation known as scene text recognition.
    This is a much more complex scenario, since the text can be anywhere, in any font,
    and with different illuminations and orientations. There can even be no text at
    all! We'll also learn how to use the OpenCV 3.0 text contribution module, which
    is fully integrated with Tesseract.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用更高级的OCR技术来识别随意拍摄的图片或视频中的文本——这种情况被称为场景文本识别。这是一个更为复杂的场景，因为文本可能出现在任何位置，使用任何字体，并且具有不同的照明和方向。甚至可能完全没有文本！我们还将学习如何使用与Tesseract完全集成的OpenCV
    3.0文本贡献模块。
