- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deep Learning with Redshift ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We explored **supervised learning** in *Chapters 6* and *7* and **unsupervised
    learning** models in [*Chapter 8*](B19071_08.xhtml#_idTextAnchor139). In this
    chapter, we will explore **deep learning algorithms**, a **multilayer perceptron**
    (**MLP**), which is a **feedforward artificial neural network** (**ANN**), and
    understand how it handles data that is not linearly separable (which means the
    data points in your data cannot be separated by a clear line). This chapter will
    provide detailed steps on how to perform deep learning in Amazon Redshift ML using
    MLP. By the end of this chapter, you will be in a position to identify a business
    problem that can be solved using MLP and know how to create the model, evaluate
    the performance of the model, and run predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to deep learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading and analyzing the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multiclass classification model using MLP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running predictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires a web browser and access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Redshift Serverless endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Redshift Query Editor v2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code used in this chapter here: [https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter9/chapter9.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter9/chapter9.sql).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to deep learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deep learning is a type of **artificial intelligence** (**AI**) that uses algorithms
    to analyze and learn data to draw output similar to the way humans do. Deep learning
    can leverage both supervised and unsupervised learning using **artificial neural
    networks** (**ANNs**). In deep learning, a set of outputs is generated from the
    input layers using a feedforward ANN called an MLP. The MLP utilizes backpropagation
    to feed the errors from the outputs back into the layers to compute one layer
    at a time and iterates until the model has learned the patterns and relationships
    in the input data to arrive at a specific output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature learning** is a set of techniques where the machine uses raw data
    to derive the characteristics of a class in the data to derive a specific task
    at hand. Deep learning models use feature learning efficiently to learn complex,
    redundant, and variable input data and classify the specified task. Thus, it eliminates
    the need for manual feature engineering for designing and selecting the input
    features. Deep learning is very useful when your datasets cannot be separated
    by a straight line, known as non-linear data.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in classifying financial transactions as fraudulent or legitimate,
    there may not be a clear linear boundary between the two classes of data. In such
    cases, deep learning models can learn these variable and complex non-linear relationships
    between the features of the input data and thus improve the accuracy of the target
    classification.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working on classification problems, an easy way to determine whether your
    dataset is linearly separated is to draw a scatter plot for classes and see whether
    two classes can be separated by a line or not. In the following diagram, the left-hand
    chart shows that two classes are linearly separated and the right-hand chart shows
    that they are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Linear versus non-linear datasets](img/B19071_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Linear versus non-linear datasets
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create models in Redshift ML when your dataset cannot be linearly separated
    by using the MLP algorithm. Common use cases where MLP algorithms are useful are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Speech recognition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image recognition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine translation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will show you how to build deep learning models in Amazon Redshift
    ML using the MLP algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Business problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use a wall-following robot navigation dataset to build a machine learning
    model using the MLP algorithm. The robot is equipped with ultrasound sensors and
    data is collected as the robot navigates through the room in a clockwise direction.
    The goal here is to guide the robot to follow the wall by giving simple directions
    such as *Move-Forward*, *Slight-Right-Turn*, *Sharp-Right-Turn*, and *Slight-Left-Turn*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there are classes to predict for a given set of sensor readings, this
    is going to be a multiclass problem. We will use MLP to correctly guide the robot
    to follow the wall. (This data is taken from [https://archive.ics.uci.edu/ml/datasets/Wall-Following+Robot+Navigation+Data](https://archive.ics.uci.edu/ml/datasets/Wall-Following+Robot+Navigation+Data)
    and is attributed to Ananda Freire, Marcus Veloso, and Guilherme Barreto (2019).
    UCI Machine Learning Repository [[http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml)].
    Irvine, CA: University of California, School of Information and Computer Science.)'
  prefs: []
  type: TYPE_NORMAL
- en: Please follow the detailed document on the page to gain more understanding of
    the use case.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will upload the data, analyze it, and prepare for training the model.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading and analyzing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have sensor readings data stored in the following S3 location:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s3://packt-serverless-ml-redshift/chapter09/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully connecting to Redshift as an admin or database developer,
    load data into Amazon Redshift:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Redshift query editor v2** and connect to **Serverless: workgroup2**
    and then to the **dev** database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Connect to the dev database](img/B19071_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Connect to the dev database
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to create the schema and customer table, and load
    the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following query to examine some sample data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In *Figure 9**.3*, we can see that our data has been loaded successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Sample output](img/B19071_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Sample output
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding screenshot, we can see that there are several sensor readings.
    Run the following query to see the distribution of the different directions of
    the robot’s movements, as shown in *Figure 9**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To view the results as a bar graph, please click on the toggle **C****hart**
    button (![](img/B19071_09_Icone_1.png)) on the **Result** pane. Under **Traces**,
    click on **+ Trace** (![](img/B19071_09_Icone_2.png)) and set **Type** as **Bar**,
    **X-axis** as **Direction**, and **Y-axis** as **Count** from the dropdown. Keep
    **Orientation** as **Vertical**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Graph generated using Query Editor v2](img/B19071_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Graph generated using Query Editor v2
  prefs: []
  type: TYPE_NORMAL
- en: You can notice that there are more *Sharp-Right-Turn* and *Move-Forward* directions
    than *Slight-Right-Turn* and *Slight-Left-Turn* directions. We will use these
    inputs to predict the future movement of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Prediction goal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this is a multiclass classification problem, the goal of this model is
    to predict which direction the robot will take next based on the 24 sensor readings.
  prefs: []
  type: TYPE_NORMAL
- en: The dataset has one ID column, which uniquely identifies a row of 24 sensor
    readings named `us1`, `us2`, …, `us24`, and a `direction` variable, which has
    4 values in it. The `direction` variable is the class variable that we are trying
    to predict.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s split the dataset into a training dataset, which will be input to
    our model, and a test dataset, which we will use to do our predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting data into training and test datasets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to split our table into two datasets, train and test, with an approximately
    80:20 split. Let’s use the `mod` function in Redshift to split our table. The
    `mod` function returns the remainder of two numbers. We will pass in the ID and
    the number `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To train the model, let’s use `where mod(id,5)` is not equal to `0`, which
    represents our training set of 80%. Run the following command in Query Editor
    v2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 9**.5*, we see the data distribution based on ~80% of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Training dataset distribution](img/B19071_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Training dataset distribution
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might see a different count than we have shown. We are using Redshift’s
    `Identity` function to generate the values for the `id` column. To be sure that
    the identity values are unique, Amazon Redshift skips some values when creating
    the identity values. Identity values are unique but the order might not match.
    Hence, you might see a different count but the data is 80% of the total count
    (5,456 rows).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Chart** function in Query Editor v2 depicts this in a bar chart format
    as shown in *Figure 9**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Training set bar chart](img/B19071_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Training set bar chart
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the model, let’s use `where mod(id,5)` is equal to `0`, which represents
    our test dataset of 20%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 9**.7*, we see the data distribution based on ~20% of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Test dataset distribution](img/B19071_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Test dataset distribution
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Chart** function in Query Editor v2 depicts this in a bar chart format
    as shown in *Figure 9**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Test data bar chart](img/B19071_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Test data bar chart
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have analyzed our data and determined how we will split it into
    training and test datasets, let’s create our model using the MLP algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multiclass classification model using MLP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this exercise, we are going to guide the `CREATE MODEL` statement to use
    the MLP model. You will achieve that by setting the `model_type` parameter to
    `MLP`. The rest of the parameters can be set to default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a model to predict the direction of the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `CREATE MODEL` function is run with a `max_runtime` value of `1800` seconds.
    This means the maximum amount of time to train the model is 30 minutes. Training
    jobs often complete sooner depending on the dataset size. Since we have not set
    other parameters (for example, objective or problem type), Amazon SageMaker Autopilot
    will be doing the bulk of the work to identify the parameters for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `SHOW MODEL` command to check whether model training is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check **Model State** in *Figure 9**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – SHOW MODEL output](img/B19071_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – SHOW MODEL output
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can see that the **Model State** field shows
    the status as **TRAINING**, which means the model is still under training. But
    notice that Redshift ML has picked up **Model Type** as **mlp**; other parameters
    such as **Problem Type** and **Objective** are empty now, but after the model
    has been trained, we will see these values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `SHOW MODEL` command again after some time to check whether model training
    is complete or not. From the following screenshot, notice that model training
    has finished and **Accuracy** has been selected as the objective for model evaluation.
    This is auto-selected by Redshift ML. Also notice that Redshift ML correctly recognized
    this as a multiclass classification problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – SHOW MODEL output](img/B19071_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – SHOW MODEL output
  prefs: []
  type: TYPE_NORMAL
- en: Now that our model has finished training, let’s run predictions using the function
    that was created. In *Figure 9**.10*, `predict_robot_direction_fn` and we will
    refer to that in our prediction query.
  prefs: []
  type: TYPE_NORMAL
- en: Also note the `validation:accuracy` value of `.940026` in *Figure 9**.10*. This
    means our model has an accuracy of >94%, which is very good.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might get a different accuracy value due to different hyperparameters selected
    for the algorithm in the background, and this can slightly affect accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Since our model has been successfully trained, let’s run some predictions on
    our test dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Running predictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this first query, we will be using the function returned by the `CREATE
    MODEL` command to compare the actual direction with our predicted directions.
    Run the following query in Query Editor v2 to see how many times we predicted
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In *Figure 9**.11*, we see that our model correctly predicted the robot’s direction
    1,033 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that your count might be slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Actual directions versus predicted direction](img/B19071_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Actual directions versus predicted direction
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run a query against the test dataset to predict which direction
    the robot will move. Run the following query in Query Editor v2 to return the
    first 10 rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 9**.12*, we show the first 10 rows and the direction based on the
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Predicted direction by ID](img/B19071_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Predicted direction by ID
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s modify the query to summarize our predicted robot movements. Run
    the following in Query Editor v2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In *Figure 9**.13*, we can see that **Move-Forward** is the most popular direction,
    followed closely by **Sharp-Right-Turn**. Please note that your counts might differ
    slightly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Summary of predicted direction](img/B19071_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Summary of predicted direction
  prefs: []
  type: TYPE_NORMAL
- en: You have now created a model using the MLP algorithm and run predictions on
    the test dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed deep learning models and why you need them and
    showed you how to create an MLP model on sensor-reading data to predict the next
    movement of the robot. You learned that non-linear datasets are suited for deep
    learning and created a multiclass classification model using the MLP algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will show you how to create a model with complete control
    of hyper-tuning parameters using XGBoost algorithms.
  prefs: []
  type: TYPE_NORMAL
