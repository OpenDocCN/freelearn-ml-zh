["```py\nfrom Cryptodome.Cipher import AESfrom Cryptodome.Random import get_random_bytes\n```", "```py\ndata = b'CC(=O)NC1=CC=C(C=C1)O'key_random = get_random_bytes(16)\ncipher_molecule = AES.new(key_random, AES.MODE_EAX)\nciphertext, tag = cipher_molecule.encrypt_and_digest(data)\nout_encrypt = open(\"molecule_enc.bin\", \"wb\")\n[out_encrypt.write(x) for x in (cipher_molecule.nonce, tag,\n    ciphertext) ]\nout_encrypt.close()\n```", "```py\nin_encrypt = open(\"molecule_enc.bin\", \"rb\")nonce, tag, ciphertext = [in_encrypt.read(x) for x in (16,\n    16, -1) ]\nin_encrypt.close()\n# let's assume that the key is somehow available again\ndecipher_molecule = AES.new(key_random, AES.MODE_EAX,nonce)\ndata = decipher_molecule.decrypt_and_verify(ciphertext,tag)\nprint('Decrypted data: {}'.format(data))\n```", "```py\nimport tenseal as tscontext = ts.context(ts.SCHEME_TYPE.BFV,\n    poly_modulus_degree=4096, plain_modulus=1032193)\n```", "```py\nplain_list = [50, 60, 70]\n```", "```py\nencrypted_list = ts.bfv_vector(context, plain_list)\n```", "```py\nadd_result = encrypted_vector + [1, 2, 3]\n```", "```py\ndef gaussian_add_noise(query_result: float,    sensitivity: float, epsilon: float):\n        std_dev = sensitivity / epsilon\n        noise = np.random.normal(loc=0.0, scale=std_dev)\n        noisy_result = query_result + noise\n    return noisy_result\n```", "```py\nquery_list = []noisy_list = []\nfor iter in range(1000):\n    # Generating a random value between 0 and 100\n    query_val = np.random.rand()*100\n    noisy_val = gaussian_add_noise(query_val, sensitivity,\n        epsilon_budget)\n    query_list.append(query_val)\n    noisy_list.append(noisy_val)\nprint('Mean of the original distribution:\n    {}'.format(np.mean(query_list)))\nprint('Mean of the nosiy distribution:\n    {}'.format(np.mean(noisy_list)))\nprint('Standard deviation of the original distribution:\n    {}'.format(np.std(query_list)))\nprint('Standard deviation of the nosiy distribution:\n    {}'.format(np.std(noisy_list)))\n```"]