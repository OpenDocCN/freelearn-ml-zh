["```py\nMat image = imread(\"Test.png\"); \nif(image.empty()) \n    return -1; \nMat grayImg; \ncvtColor(image, grayImg, COLOR_BGR2GRAY); \n\nint bins = 256; \nint nimages = 1; \nint channels[] = {0}; \nMat mask; \nint dims = 1; \nint histSize[] = { bins }; \nfloat rangeGS[] = {0, 256}; \nconst float* ranges[] = { rangeGS }; \nbool uniform = true; \nbool accumulate = false; \nMat histogram; \ncalcHist(&grayImg, \n         nimages, \n         channels, \n         mask, \n         histogram, \n         dims, \n         histSize, \n         ranges, \n         uniform, \n         accumulate); \n```", "```py\nint gRows = 200; // height \nint gCol = 500; // width \nScalar backGroundColor = Scalar(0, 255, 255); // yellow \nScalar graphColor = Scalar(0, 0, 0); // black \nint thickness = 2; \nLineTypes lineType = LINE_AA; \n\nMat theGraph(gRows, gCol, CV_8UC(3), backGroundColor); \n\nPoint p1(0,0), p2(0,0); \nfor(int i=0; i<bins; i++) \n{ \n    float value = histogram.at<float>(i,0); \n    value = maxVal - value; // invert \n    value = value / maxVal * theGraph.rows; // scale \n    line(theGraph, \n         p1, \n         Point(p1.x,value), \n         graphColor, \n         thickness, \n         lineType); \n    p1.y = p2.y = value; \n    p2.x = float(i+1) * float(theGraph.cols) / float(bins); \n    line(theGraph, \n         p1, p2, \n         Scalar(0,0,0)); \n    p1.x = p2.x; \n} \n```", "```py\ndouble maxVal = 0; \nminMaxLoc(histogram, \n          0, \n          &maxVal, \n          0, \n          0);\n```", "```py\nPoint p1(0,0), p2(0, theGraph.rows-1); \nfor(int i=0; i<bins; i++) \n{ \n    float value = histogram.at<float>(i,0); \n    value *= 0.95f; // 5% empty at top \n    value = maxVal - value; // invert \n    value = value / (maxVal) * theGraph.rows; // scale \n    p1.y = value; \n    p2.x = float(i+1) * float(theGraph.cols) / float(bins); \n    rectangle(theGraph, \n              p1, \n              p2, \n              graphColor, \n              CV_FILLED, \n              lineType); \n    p1.x = p2.x; \n} \n```", "```py\nMat image = imread(\"Test.png\"); \nif(image.empty()) \n{ \n    cout << \"Empty input image!\"; \n    return -1; \n} \n\nMat imgChannels[3]; \nMat histograms[3]; \nsplit(image, imgChannels); \n\n// each imgChannels element is an individual 1-channel image\nCvHistGraphColor, and running it would produce a result similar to what is seen in the following diagram:\n```", "```py\nScalar graphColor = Scalar(i == 0 ? 255 : 0, \n                           i == 1 ? 255 : 0, \n                           i == 2 ? 255 : 0); \n```", "```py\ncalcBackProject(&image, \n                nimages, \n                channels, \n                histogram, \n                backProj, \n                ranges, \n                scale, \n                uniform); \n```", "```py\nnormalize(histogram, \n          histogram, \n          0, \n          255, \n          NORM_MINMAX);\n```", "```py\nint bins = 10; // we need 10 slices \nfloat rangeGS[] = {0, 256}; \nconst float* ranges[] = { rangeGS }; \nint channels[] = {0}; \nMat histogram(bins, 1, CV_32FC1, Scalar(0.0)); \nhistogram.at<float>(9, 0) = 255.0; \ncalcBackProject(&imageGray, \n                1, \n                channels, \n                histogram, \n                backProj, \n                ranges);\n```", "```py\nMat image = imread(\"Test.png\"); \nif(image.empty()) \n{ \n    cout << \"Empty input image!\"; \n    return -1; \n} \n\nMat imgHsv, hue; \nvector<Mat> hsvChannels; \ncvtColor(image, imgHsv, COLOR_BGR2HSV); \nsplit(imgHsv, hsvChannels); \nhue = hsvChannels[0]; \n```", "```py\nint bins = 360; \nint blueHue = 240; \nint hueOffset = 50; \nMat histogram(bins, 1, CV_32FC1); \nfor(int i=0; i<bins; i++) \n{ \n    histogram.at<float>(i, 0) =  \n        (i > blueHue - hueOffset) \n            && \n        (i < blueHue + hueOffset) \n            ? \n        255.0 : 0.0; \n}\n```", "```py\ndouble maxVal = 255.0; \n\nint gW = 800, gH = 100; \nMat theGraph(gH, gW, CV_8UC3, Scalar::all(0)); \n\nMat colors(1, bins, CV_8UC3); \nfor(int i=0; i<bins; i++) \n{ \n    colors.at<Vec3b>(i) = \n            Vec3b(saturate_cast<uchar>( \n                      (i+1)*180.0/bins), 255, 255); \n} \ncvtColor(colors, colors, COLOR_HSV2BGR); \nPoint p1(0,0), p2(0,theGraph.rows-1); \nfor(int i=0; i<bins; i++) \n{ \n    float value = histogram.at<float>(i,0); \n    value = maxVal - value; // invert \n    value = value / maxVal * theGraph.rows; // scale \n    p1.y = value; \n    p2.x = float(i+1) * float(theGraph.cols) / float(bins); \n    rectangle(theGraph, \n              p1, \n              p2, \n              Scalar(colors.at<Vec3b>(i)), \n              CV_FILLED); \n    p1.x = p2.x; \n}\n```", "```py\nMat histogram(bins, 1, CV_32FC1); \nfor(int i=0; i<bins; i++) \n{ \n    histogram.at<float>(i, 0) = 255.0; \n}\n```", "```py\nint nimages = 1; \nint channels[] = {0}; \nMat backProject; \nfloat rangeHue[] = {0, 180}; \nconst float* ranges[] = {rangeHue}; \ndouble scale = 1.0; \nbool uniform = true; \ncalcBackProject(&hue, \n                nimages, \n                channels, \n                histogram, \n                backProject, \n                ranges, \n                scale, \n                uniform); \n```", "```py\nint shift = -50; \nfor(int i=0; i<imgHsv.rows; i++) \n{ \n    for(int j=0; j<imgHsv.cols; j++) \n    { \n        if(backProject.at<uchar>(i, j)) \n        { \n            imgHsv.at<Vec3b>(i,j)[0] += shift; \n        } \n    } \n} \nMat imgHueShift; \ncvtColor(imgHsv, imgHueShift, CV_HSV2BGR);\n```", "```py\nint bins = 36; \nint histSize[] = {bins}; \nint nimages = 1; \nint dims = 1; \nint channels[] = {0}; \nfloat rangeHue[] = {0, 180}; \nconst float* ranges[] = {rangeHue}; \nbool uniform = true; \nbool accumulate = false; \nMat histogram, mask; \n\ncalcHist(&hue, \n         nimages, \n         channels, \n         mask, \n         histogram, \n         dims, \n         histSize, \n         ranges, \n         uniform, \n         accumulate); \n```", "```py\nHistCompMethods method = HISTCMP_CORREL; \ndouble result = compareHist(histogram1, histogram2, method); \n```", "```py\ncout << \"HISTCMP_CORREL: \" << \n  compareHist(histogram1, histogram2, HISTCMP_CORREL) \n    << endl; \ncout << \"HISTCMP_CHISQR: \" << \n  compareHist(histogram1, histogram2, HISTCMP_CHISQR) \n    << endl; \ncout << \"HISTCMP_INTERSECT: \" << \n  compareHist(histogram1, histogram2, HISTCMP_INTERSECT) \n    << endl; \ncout << \"HISTCMP_BHATTACHARYYA: \" << \n  compareHist(histogram1, histogram2, HISTCMP_BHATTACHARYYA) \n    << endl; \ncout << \"HISTCMP_HELLINGER: \" << \n  compareHist(histogram1, histogram2, HISTCMP_HELLINGER) \n    << endl; \ncout << \"HISTCMP_CHISQR_ALT: \" << \n  compareHist(histogram1, histogram2, HISTCMP_CHISQR_ALT) \n    << endl; \ncout << \"HISTCMP_KL_DIV: \" << \n  compareHist(histogram1, histogram2, HISTCMP_KL_DIV) \n    << endl; \n```", "```py\nHISTCMP_CORREL: 1 \nHISTCMP_CHISQR: 0 \nHISTCMP_INTERSECT: 426400 \nHISTCMP_BHATTACHARYYA: 0 \nHISTCMP_HELLINGER: 0 \nHISTCMP_CHISQR_ALT: 0 \nHISTCMP_KL_DIV: 0\n```", "```py\nHISTCMP_CORREL: -0.0449654 \nHISTCMP_CHISQR: 412918 \nHISTCMP_INTERSECT: 64149 \nHISTCMP_BHATTACHARYYA: 0.825928 \nHISTCMP_HELLINGER: 0.825928 \nHISTCMP_CHISQR_ALT: 1.32827e+06 \nHISTCMP_KL_DIV: 3.26815e+06 \n```", "```py\nHISTCMP_CORREL: -0.0449654 \nHISTCMP_CHISQR: 3.26926e+06 \nHISTCMP_INTERSECT: 64149 \nHISTCMP_BHATTACHARYYA: 0.825928 \nHISTCMP_HELLINGER: 0.825928 \nHISTCMP_CHISQR_ALT: 1.32827e+06 \nHISTCMP_KL_DIV: 1.15856e+07 \n```", "```py\nMat equalized; \nequalizeHist(gray, equalized); \n```"]