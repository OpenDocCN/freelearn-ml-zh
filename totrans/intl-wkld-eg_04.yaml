- en: '*Chapter 2*: Foundations of Edge Workloads'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will explore the next level of detail regarding **edge workloads**
    and your first hands-on activity. You will learn how **AWS IoT Greengrass** meets
    the needs for designing and delivering modern edge ML solutions. You will learn
    how to prepare your edge device to work with AWS by deploying a tool that checks
    your device for compatible requirements. Additionally, you will learn how to install
    the IoT Greengrass core software and deploy your first IoT Greengrass core device.
    You will learn about the structure of components, examine the fundamental unit
    of software in IoT Greengrass, and write your first edge workload component.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should start to feel comfortable with the basics
    of IoT Greengrass and its local development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of an edge ML solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IoT Greengrass for the win
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking compatibility with IoT Device Tester
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing IoT Greengrass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your first edge component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are the same as those described
    in the Hands-on prerequisites section in [*Chapter 1*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013)*,
    Introduction to the Data-Driven Edge with Machine Learning*. Please refer to the
    full requirements mentioned in that chapter. As a reminder, you will need the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system to deploy the IoT Greengrass software. A Raspberry Pi 3B,
    or later, is recommended. The installation instructions are similar to other Linux-based
    systems. Please refer to the following GitHub repository for further guidance
    when the hands-on steps differ for systems other than a Raspberry Pi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A system to install and use the AWS **Command-Line Interface** (**CLI**), enabling
    access to the AWS Management Console website (typically, your PC/laptop).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access this chapter's technical resources from the GitHub repository,
    under the `chapter2` folder, at [https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter2](https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter2).
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of an edge ML solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter introduced the concept of an edge solution along with
    the three key kinds of tools that define an edge solution with ML applications.
    This chapter provides more detail regarding the layers of an edge solution. The
    three layers addressed in this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **business logic layer** includes the customized code that dictates the
    solution's behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **physical interface layer** connects your solution to the analog world
    with sensors and actuators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **network interface layer** connects your solution to other digital entities
    in the wider network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning more about these layers is important because they will inform how you,
    as the IoT architect, make trade-offs when designing your edge ML solution. First,
    we'll start by defining the business logic layer.
  prefs: []
  type: TYPE_NORMAL
- en: Designing code for business logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The business logic layer is where all the code of your edge solution lives.
    This code can take many shapes, such as *precompiled binaries* (such as a C program),
    *shell scripts*, *code evaluated by a runtime* (such as a Java or Python program),
    and *ML models*. Additionally, code can be organized in a few different ways such
    as shipping everything into a monolithic application, splitting up code into services
    or libraries, or bundling code to run in a container. All of these options come
    with implications for architecting and shipping an edge ML solution, such as security,
    cost, consistency, productivity, and durability. Some of the challenges of delivering
    code for the business logic layer are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing and testing code that will run on your edge hardware platforms. For
    example, writing code that will work on variations of hardware platforms as incremental
    new versions are rolled out. You will want to minimize the number of forks of
    code you maintain that meet the needs of all your hardware platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a robust edge solution that encompasses many features. For example,
    bundling features to process new sensor data, analyze data, and communicate with
    web services that do not create conflicts with common dependencies or local resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing code with a team of people all working on an aggregate edge solution.
    For example, a monolithic application with many contributors can require each
    author to fully know the solution to make an incremental change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To address the challenges of writing your business layer logic, the best practice
    for shipping code to the edge is to use **isolated services** where practical.
  prefs: []
  type: TYPE_NORMAL
- en: Isolated services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On your *Home Base Solutions hub device* (the fictional product we are creating
    from the story in [*Chapter 1*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013),
    *Introduction to the Data-Driven Edge with Machine Learning*), code will be deployed
    and run as isolated services. In this context, a **service** is a self-contained
    unit of business logic that is either invoked by another entity to perform a task
    or performs a task on its own. **Isolation** means that the service will bundle
    with it the code, resources, and dependencies it needs for its operation. For
    example, a service you will create in [*Chapter 7*](B17595_07_Final_SS_ePub.xhtml#_idTextAnchor138),
    *Machine Learning Workloads at the Edge*, will run code to read from a data source
    or collection of images, periodically compute inferences using a bundled ML model,
    then publish any inference results to a local stream or the cloud. This pattern
    of isolated services is selected for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The first reason is that a **service-oriented architecture** enables architects
    to design capabilities that are decoupled from one another. **Decoupling** means
    we use data structures, such as buffers, queues, and streams, to add a layer of
    abstraction between our services, reducing dependencies to allow services to run
    independently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy updates to individual services without touching other running
    services and, therefore, reduce the risk of impact on them. Decoupled, service-oriented
    architecture is a best practice for designing well-architected cloud solutions
    that are also a good fit for edge ML solutions where multiple services are simultaneously
    running and emphasize a need for reliability. For example, a service that interfaces
    a sensor writes new measurements to a data structure and nothing more; it has
    a single job and doesn't need to be aware of how the data is consumed by a later
    capability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second reason is that the **isolation** of code enables developers to focus
    on what that code does instead of where the code is going or how dependencies
    are managed at the destination. By using principles of isolation to bundle runtime
    dependencies and resources with code, we get stronger consistency that code will
    work deterministically wherever it is deployed. Developers free up the effort
    required for dependency management and have more confidence that the code will
    work the same way on the edge platform, which is likely different than their development
    environment. That's not to say an edge solution developer won't need to test the
    behavior of their code against physical interfaces such as sensors and actuators.
    However, it does mean that development teams can deliver self-contained services
    that work independently regardless of the rest of the services deployed in the
    aggregate edge solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of isolation include **Python** virtual environments, which explicitly
    specify a Python runtime version and package, and **Docker Engine**, which uses
    containers to bundle dependencies, resources, and achieve process isolation on
    the host. The following diagram illustrates the separation of concerns achieved
    with isolated services:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.1 – An edge solution using decoupled, isolated services'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – An edge solution using decoupled, isolated services
  prefs: []
  type: TYPE_NORMAL
- en: In tandem, the patterns of isolation and services offer compelling benefits
    for edge ML solutions. Of course, every decision in development comes with trade-offs.
    The solution would be simpler if deployed as a singular monolith of code and faster
    to derive a minimum viable product. We opt for more architectural complexity because
    this leads to better resiliency and a scaling up of the solution over time. We
    lean on strong patterns and good tooling to balance that complexity.
  prefs: []
  type: TYPE_NORMAL
- en: IoT Greengrass is designed with this pattern in mind. Later, in this chapter
    and throughout the book, you will learn how to use this pattern with IoT Greengrass
    to develop well-architected edge ML solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Physical interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cyber-physical solution is defined by the use of physical interfaces to interact
    with the analog world. These interfaces come in two classifications: *sensors
    for taking measurements from the analog world* and *actuators for exerting change
    back upon it*. Some machines do both, such as a refrigerator that senses internal
    temperature and activates its compressor to cycle a refrigerant through coils.
    In these cases, the aggregation of sensing and actuating is logical, meaning the
    sensor and actuator have a relationship but are functionally independent and are
    coordinated via a mechanism such as a switch, circuit, or microcontroller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sensors that perform analog-to-digital conversion do so by sampling the voltage
    from an electrical signal and converting it into a digital value. These digital
    values are interpreted by code to derive data such as temperature, light, and
    pressure. Actuators convert digital signals into analog actions, typically, by
    manipulating the voltage going to a switch or circuit. A command to engage a motor
    is interpreted as raising a voltage to the level that activates the circuit. Diving
    deeper into the electrical engineering of physical interfaces is beyond the scope
    of this book. Please refer to the *References* section for recommendations on
    deeper dives on that topic. The following diagram shows a simple analog example
    of a refrigerator and the relationship between the thermostat (sensor), switch
    (controller), and compressor (actuator):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – An analog controller with a sensor and an actuator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – An analog controller with a sensor and an actuator
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand the patterns of input and output delivered by a
    cyber-physical solution and the relationship to a higher-level outcome delivered
    through an edge ML solution. Throughout the project delivered in this book, you
    will gain hands-on experience applying these patterns. Some of the services of
    the Home Base Solutions hub device will serve as interfaces to the physical layer,
    providing new measurements from the sensors and converting the commands to change
    the state of local devices. If you are working with a physical edge device, such
    as the Raspberry Pi, you will get some experience of using code to interact with
    the physical interfaces of that device.
  prefs: []
  type: TYPE_NORMAL
- en: Network interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third layer to introduce for our edge solution anatomy is the *network interface*.
    A differentiator between our definitions of cyber-physical solutions and edge
    solutions is that an edge solution will, at some point, interact with another
    entity over a network. For example, the design of our new appliance monitoring
    kit for Home Base Solutions uses wireless communication between the monitoring
    kit and the hub device. There is no physical connection between the two for the
    purposes of analog-to-digital signal conversion from the monitor's sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the hub device will also exchange messages with a cloud service
    to store telemetry to use in the training of the ML model, to deploy new resources
    to the device, and to alert customers of recognized events. The following diagram
    illustrates the flow of messages and the relationships between a **Sensor**, **Actuator**,
    hub device (**Gateway**), and the cloud service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – An edge device exchanging messages with local sensors, actuators,
    and the cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – An edge device exchanging messages with local sensors, actuators,
    and the cloud
  prefs: []
  type: TYPE_NORMAL
- en: Wireless communications are common in IoT solutions, and specific implementations
    enable connectivity at a wide range of distances. Each specification and implementation
    makes trade-offs for range, data transmission rate, hardware cost, and energy
    consumption. Short-range radio specifications such as **Zigbee** (IEEE 802.15.4),
    **Bluetooth** (IEEE 802.15.1), and **WiFi** (IEEE 802.11) are suitable for bridging
    devices within personal and local area networks. Long-range radio specifications
    such as conventional cellular networks (for example, **GSM**, **CDMA**, and **LTE**)
    and **low-power wide-area networks** (**LPWANs**) such as **LoRaWAN** and **NB-IoT**
    deliver connectivity options for devices deployed (either static or roaming) across
    a particular campus, city, or region.
  prefs: []
  type: TYPE_NORMAL
- en: Wired communications are still common for connecting edge devices such as TVs,
    game consoles, and PCs to home network solutions such as switches and routers
    over **Ethernet**. Wired connectivity is less common in smart home products due
    to the limited number of Ethernet ports on home networking routers (typically,
    there are only 1–8 ports), the restrictions regarding where the device can be
    placed, and the burden of adding wires throughout the home.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Home Base Solutions appliance monitoring kit would likely use
    a Zigbee, or equivalent implementation, and a battery to balance energy consumption
    with the anticipated data rate. If the kit required a power supply from a nearby
    outlet, Wi-Fi becomes more of an option; however, it would limit the overall product
    utility as the placement of the kinds of appliances to monitor don't always have
    a spare outlet. Additionally, it wouldn't make sense to use Ethernet to connect
    the kits to the hub directly since customers likely wouldn't find all of the extra
    wires running throughout the home appealing. The hub device that communicates
    with the kit could use Ethernet or Wi-Fi to bridge to the customer's local network
    to gain access to the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of the three layers of an edge solution,
    let's evaluate the selected edge runtime solution and how it implements each layer.
  prefs: []
  type: TYPE_NORMAL
- en: IoT Greengrass for the win
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important question to answer in a book about using IoT Greengrass to
    deliver edge ML solutions is *why IoT Greengrass?* When evaluating the unique
    challenges of edge ML solutions and the key tools required to deliver them, you
    want to select tools that solve as many problems for you as possible while staying
    out of your way in terms of being productive. IoT Greengrass is a purpose-built
    tool with IoT and ML solutions at the forefront of the value proposition.
  prefs: []
  type: TYPE_NORMAL
- en: 'IoT Greengrass is prescriptive in how it solves the problem of the *undifferentiated
    heavy lifting* of common requirements while remaining non-prescriptive in how
    you implement your business logic. This means that the out-of-box experience yields
    many capabilities for rapid iteration without being obstructive about how you
    use them to reach your end goals. The following is a list of some of the capabilities
    that IoT Greengrass has to offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security at the edge**: IoT Greengrass is installed with root permissions
    and uses operating system user permissions to protect the code and resources deployed
    at the edge from tampering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security to the cloud**: IoT Greengrass uses mutual **transport layer security**
    (**TLS**) with public key infrastructure to exchange messages between the edge
    and the cloud. Resources are fetched during deployments using HTTPS and AWS Signature
    Version 4 to verify the identity of the requester and protect data in transit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime orchestration**: Developers can design applications however they
    prefer (with monoliths, services, or containers) and deploy them to the edge with
    ease. IoT Greengrass provides hooks for smartly integrating with component life
    cycle events, or developers can ignore them and simply bootstrap applications
    with a single command. Individual components can be added or updated without interrupting
    other running services. A dependency tree allows developers to abstract out the
    installation of libraries and configuration activities to decouple from code artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging and monitoring**: By default, IoT Greengrass creates logs for each
    component and allows developers to indicate which log files should be synchronized
    to the cloud for operational purposes. Additionally, the cloud service keeps track
    of device health automatically, making it easier for team members to identify
    and respond to unhealthy devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling up the fleet**: Deploying updates to one device is not much different
    than deploying updates to a fleet of devices. It is easy to define groups, classify
    similar devices together, and then push updates to groups of devices using a managed
    deployment service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native integrations**: AWS provides many components to deploy into IoT Greengrass
    solutions that augment the baseline functionality and also for integrating with
    other AWS services. A stream management component enables you to define, write
    to, and consume streams at the edge. A Docker application manager allows you to
    download Docker images from public repositories or private repositories in **Amazon
    Elastic Container Registry**. Pretrained and optimized ML models are available
    for tasks such as object detection and image classification with **Deep Learning
    Runtime** and **TensorFlow Lite**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In playing your role as the Home Base Solutions architect with a solution to
    build, you could propose that the engineering team invest the time and resources
    to build out all this functionality and test that it is production-ready. However,
    the IoT Greengrass baseline services and optional add-ons are ready to accelerate
    the development life cycle and come vetted by AWS, where *security is the top
    priority*.
  prefs: []
  type: TYPE_NORMAL
- en: IoT Greengrass does not do everything for you. In fact, a fresh installation
    of IoT Greengrass doesn't do anything but wait for further instruction in the
    form of a deployment. Think of it as a blank canvas, paint, and brush. It's everything
    you need to get started, but you have to develop the solution that it runs. Let's
    review the operating model for IoT Greengrass, both at the edge and within the
    cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing IoT Greengrass architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IoT Greengrass is both a managed service running on AWS and an edge runtime
    tool. The managed service is where your devices are defined individually and in
    groups. When you want to push a new deployment to the edge, you are, in fact,
    invoking an API in the managed service that is then responsible for communicating
    with the edge runtime to coordinate the delivery of that deployment. Here is a
    sequence diagram showing the process of you, as the developer, configuring a component
    and requesting that a device running the IoT Greengrass core software receive
    and run that component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Pushing a deployment through IoT Greengrass'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Pushing a deployment through IoT Greengrass
  prefs: []
  type: TYPE_NORMAL
- en: The **component** is the fundamental unit of functionality that is deployed
    to a device running IoT Greengrass. Components are defined by a manifest file,
    called a **recipe**, which tells IoT Greengrass what the name, version, dependencies,
    and instructions are for that component. In addition to this, a component can
    define zero or more **artifacts** that are fetched during deployment. These artifacts
    can be binaries, source code, compiled code, archives, images, or data files;
    really any kind of file or resource that is stored on disk. Component recipes
    can define dependencies on other components that get resolved via a graph by the
    IoT Greengrass software.
  prefs: []
  type: TYPE_NORMAL
- en: 'During a deployment activity, one or more components are added or updated in
    that deployment. The component''s artifacts are downloaded to the local device
    from the cloud; then, the component is started by way of evaluating life cycle
    instructions. A life cycle instruction could be something that happens during
    startup; it could be the main command to run, such as starting a Java application
    or something to do after the component has concluded running. Components might
    continue in the running state indefinitely or perform a task and exit. The following
    diagram provides an example of the component graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – An example graph of components showing the life cycle and dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – An example graph of components showing the life cycle and dependencies
  prefs: []
  type: TYPE_NORMAL
- en: That's everything we need to cover before taking your first steps toward readying
    your edge device to run a solution with IoT Greengrass!
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will validate that your edge device is ready
    to run the IoT Greengrass software, install the software, and then author your
    first component. In addition to this, you will get a closer look at components
    and deployments through the hands-on activities to come.
  prefs: []
  type: TYPE_NORMAL
- en: Checking compatibility with IoT Device Tester
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IoT Device Tester** (**IDT**) is a software client provided by AWS to assess
    device readiness for use in AWS IoT solutions. It assists developers by running
    a series of qualification tests to validate whether the destination system is
    ready to run the IoT Greengrass core software. Additionally, it runs a series
    of tests to prove that edge capabilities are already present, such as establishing
    MQTT connections to AWS and running ML models locally. IDT works for one device
    you are testing locally or scales up to run customized test suites against any
    number of device groups, so long as they are accessible over the network.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of your role as the IoT architect at Home Base Solutions, you
    should use IDT to prove that your target edge device platform (in this case, platform
    refers to hardware and software) is capable of running the runtime orchestration
    tool of choice, IoT Greengrass. This pattern of using tools to prove compatibility
    is a best practice over manually evaluating the target platform and/or assuming
    that a certain combination of listed requirements is met. For example, a potential
    device platform might advertise that its hardware requirements and operating system
    meet your needs, but it could be missing a critical library dependency that doesn't
    surface until later in the development life cycle. It is best to prove early that
    everything you need is present and accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: IDT does more than qualify hardware for running IoT Greengrass core software.
    The tool can also qualify hardware running FreeRTOS to validate that the device
    is capable of interoperating with AWS IoT Core. Developers can write their own
    custom tests and bundle them into suites to incorporate into your **software development
    life cycle** (**SDLC**).
  prefs: []
  type: TYPE_NORMAL
- en: The following steps will enable you to prepare your Raspberry Pi device for
    use as the edge system (that is, the Home Base Solutions hub device in our fictional
    project) and configure your AWS account before finally running the IDT software.
    Optionally, you can skip the *Booting the Raspberry Pi* and *Configuring the AWS
    account and permissions* sections if you already have a device and AWS account
    configured for use. If you are using a different platform for your edge device,
    you just need to ensure you can reach the device over SSH with a system user that
    has root permissions from your command-and-control device.
  prefs: []
  type: TYPE_NORMAL
- en: Booting the Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps were run on a Raspberry Pi 3B with a clean installation
    of the May 2021 release of the Raspberry Pi OS. Please refer to [https://www.raspberrypi.org/software/](https://www.raspberrypi.org/software/)
    for the **Raspberry Pi Imager** tool. Use your command-and-control system to run
    the imaging tool to flash a Micro SD card with a fresh image of the Raspberry
    Pi OS. For this book''s project, we recommended that you use a blank slate to
    avoid any unforeseen consequences of preexisting software and configuration changes.
    Here is a screenshot of the Raspberry Pi Imager tool and the image to select:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The Raspberry Pi Imager tool and the image to select'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – The Raspberry Pi Imager tool and the image to select
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of steps to perform after flashing the Micro SD card
    with the Imager tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert the Micro SD card into the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on the Raspberry Pi by plugging in the power source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the first-time boot wizard. Update the default password, set your locale
    preferences, and connect to Wi-Fi (this is optional if you are using Ethernet).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal app and run `sudo apt-get update` and `sudo apt-get upgrade`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot the Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal app and run the `hostname` command. Copy the value and make
    a note of it; for example, write it in a scratch file on your command-and-control
    system. On Raspberry Pi devices, the default is `raspberrypi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Raspberry Pi preferences app and enable the SSH interface. This must
    be enabled for the IDT to access the device. Open **Preferences**, choose **Raspberry
    Pi Configuration**, choose **Interfaces**, and enable SSH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this milestone, your Raspberry Pi device is configured to join the same local
    network of your command-and-control system and can be accessed via a remote shell
    session. If you are using a different device or a virtual machine as your edge
    device for the hands-on project, you should be able to access that device via
    SSH. A good test to check whether this is working properly is to try connecting
    to your edge device from your command-and-control system using a Terminal application
    (or `ssh pi@raspberrypi`. Replace `raspberrypi` if you have a different hostname
    from *step 6*. Next, you will configure your AWS account in order to run IDT on
    your edge device.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AWS account and permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complete all of the steps in this section on your command-and-control system.
    For readers who don''t yet have an AWS account (skip to *step 5* if you already
    have access to an account), perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create your AWS account. Navigate to [https://portal.aws.amazon.com/billing/signup](https://portal.aws.amazon.com/billing/signup)
    in your web browser and complete the prompts. You will require an email address,
    phone number, and credit card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console using your root login and navigate to
    the **Identity and Access Management** (**IAM**) service. You can find this at
    [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the IAM service console to set up your administrative group and user account.
    It is a best practice to create a new user for yourself instead of continuing
    to use the root user login. You will use that new user to complete any later AWS
    steps using the AWS management console or AWS CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new user called `AdministratorAccess` (it is easier to use the filter
    field and type that in). This policy is managed by AWS to grant administrator-level
    permissions to users. The best practice is to relate permissions to groups and
    then assign users to groups to inherit permissions. This makes it easier to audit
    permissions and understand the kinds of access that users have from well-named
    groups.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Log out of the AWS management console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, you should have access to an AWS account with an administrative
    user. Complete the following steps to set up the AWS CLI (please skip to *step
    7* if you already have the AWS CLI configured with your admin user).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install the AWS CLI. Platform-specific instructions can be found at [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/).
    In this book, the AWS CLI steps will use AWS CLI v2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, configure the AWS CLI and use the credentials you downloaded
    for the `aws configure`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted for `json`, `yaml`, `text`, `table`]. The author's preference
    is `json` and will be reflected in any examples of AWS CLI output that appear
    in the book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will use your `Admin` user to create a few more resources in preparation
    for the following sections to use the IDT and install the IoT Greengrass core
    software. These are permissions resources, similar to your `Admin` user, which
    will be used by IDT and IoT Greengrass software to interact with AWS on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to the AWS management console using your custom sign-in link from *step
    3A*. Use the `Admin` username and password provided in the CSV file containing
    credentials.*   Return to the IAM service console, which can be found at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/).*   Create
    a new user named `idtgg` (short for *IDT and Greengrass*) and select the **Programmatic
    access** type. This user will not require a password for management console access.
    Skip the permissions and tags sections. Make sure that you download the CSV file
    containing the credentials for this user as well.*   Create a new policy. The
    first step is to define the permissions for the policy. Choose the `chapter2/policies/idtgg-policy.json`.
    Skip the tags section. In the review section, enter the name of `idt-gg-permissions`,
    enter the description of **permissions for IoT Device Tester and IoT Greengrass**,
    and choose **Create policy**.*   Create a new user group with the name of `idt-gg-permissions`
    policy, and select the `idtgg` user. Choose **Create group**. You have now set
    up a new group, attached permissions, and assigned the programmatic access user
    that will serve as authentication and authorization for the IDT client and IoT
    Greengrass provisioning tool.*   In your Terminal or PowerShell application, configure
    a new AWS CLI profile for this new user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `aws configure --profile idtgg`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted for access keys and secret keys, use the new values from the credentials
    CSV file downloaded in *step 9*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted for the default region, use the book's default of **us-west-2**
    or the AWS region you are using for all of the projects in this book.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: That concludes all of the preparatory steps to configure your AWS account, permissions,
    and CLI. The next milestone is to install the IDT client and prepare it to test
    the Home Base Solutions prototype hub device.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring IDT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will run the IDT software from your command-and-control system, and the
    IDT will access the edge device system remotely through SSH to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The following steps reflect the configuration and use of IDT at the time of
    writing. If you get stuck, it might be that the latest version differs from the
    version that we used at the time of writing. You can check the AWS documentation
    for IDT for the latest guidance on installation, configuration, and use. Please
    refer to [https://docs.aws.amazon.com/greengrass/v2/developerguide/device-tester-for-greengrass-ug.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/device-tester-for-greengrass-ug.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to use IDT to verify the edge device system is ready to
    run IoT Greengrass. All of the following steps are completed on macOS using IoT
    Greengrass core software v2.4.0 and IDT v4.2.0 with test suite GGV2Q_2.0.1\. For
    Windows, Linux, or later AWS software versions, please alter the commands and
    directories as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: On your command-and-control system, open a web browser and navigate to [https://docs.aws.amazon.com/greengrass/v2/developerguide/dev-test-versions.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/dev-test-versions.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `C:\projects\idt` on Windows or `~/projects/idt` on macOS and Linux:![Figure
    2.7 – The AWS documentation website for downloading IDT; exact text and versions
    might differ
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17595_02_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.7 – The AWS documentation website for downloading IDT; exact text and
    versions might differ
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unzip the archive contents in place in the directory. In a file explorer, double-click
    on the archive to extract them. If using Terminal, use a command such as `unzip
    devicetester_greengrass_v2_4.0.2_testsuite_1.1.0_mac.zip`. This is what the directory
    looks like on macOS:![Figure 2.8 – macOS Finder showing the directory contents
    after unzipping the IDT archive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17595_02_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.8 – macOS Finder showing the directory contents after unzipping the
    IDT archive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a new tab in your browser and paste the following link to prompt a download
    of the latest IoT Greengrass core software: [https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-2.4.0.zip](https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-2.4.0.zip)
    (if this link doesn''t work, you can find the latest guidance at [https://docs.aws.amazon.com/greengrass/v2/developerguide/quick-installation.html#download-greengrass-core-v2](https://docs.aws.amazon.com/greengrass/v2/developerguide/quick-installation.html#download-greengrass-core-v2)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the downloaded file as `aws.greengrass.nucleus.zip` and move it to an
    IDT directory such as `~/projects/idt/devicetester_greengrass_v2_mac/products/aws.greengrass.nucleus.zip`:![Figure
    2.9 – The IoT Greengrass software in place to be used by IDT
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17595_02_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.9 – The IoT Greengrass software in place to be used by IDT
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a text file such as `~/projects/idt/devicetester_greengrass_v2_mac/configs/config.json`
    and update the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Optionally) update `awsRegion` if you are not using the book's default of `us-west-2`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the `idtgg` profile that you configured earlier, set the value of `auth`
    as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open a text file such as `~/projects/idt/devicetester_greengrass_v2_mac/configs/device.json`
    and update the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"id": "pool1"`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"sku": "hbshub"` (`hbshub` stands for Home Base Solutions hub).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath `"features"`, for the name-value pair named `"arch"`, set `"value":
    "armv7l"` (this is for Raspberry Pi devices; alternatively, you can choose the
    appropriate architecture for your device).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath `"features"`, for the remaining name-value pairs such as `"ml"`,
    `"docker"`, and `"streamManagement"`, set `"value": "no"`. For now, we will disable
    these tests because we have no immediate plans to use the tested features. Feel
    free to enable them if you''d like to evaluate your device''s compatibility, although
    expect the tests to fail on a freshly imaged Raspberry Pi.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath `"devices"`, set `"id": "raspberrypi"` (or any device ID you prefer).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `"connectivity"`, set the value of `"ip"` to the IP address of your
    edge device (for Raspberry Pi users, the value is the output of *step 6* from
    the *Booting the Raspberry Pi* section).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath `"auth"`, set `"method": "password"`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `"credentials"`, set the value of `"user"` to the username used to
    SSH to the edge device (typically, this will be `"pi"` for Raspberry Pi users).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `"credentials"`, set the value of `"password"` to the password used
    to SSH to the edge device.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `"credentials"`, delete the line for `"privKeyPath"`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the changes to this file. You can view a sample version of this file in
    the book's GitHub repository at `chapter2/policies/idt-device-sample.json`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a text file such as `~/projects/idt/devicetester_greengrass_v2_mac/configs/userdata.json`
    and update the following values. Ensure that you specify absolute paths instead
    of relative paths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"TempResourcesDirOnDevice": "/tmp/idt"`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"InstallationDirRootOnDevice": "/greengrass"`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"GreengrassNucleusZip": "Users/ryan/projects/idt/devicetester_greengrass_v2_mac/products/aws.greengrass.nucleus.zip"`
    (update this based on where you stored the `aws.greengrass.nucleus.zip` file in
    *step 5* of this section).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the changes to this file. You can view a sample version of this file in
    the book's GitHub repository at `chapter2/policies/idt-userdata-sample.json`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Open an application such as Terminal on macOS/Linux or PowerShell on Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change your present working directory to where the IDT launcher is located:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~/projects/idt/devicetester_greengrass_v2_mac/bin` on macOS'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~/projects/idt/devicetester_greengrass_v2_linux/bin` on Linux'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`C:\projects\idt\devicetester_greengrass_v2_win\bin` on Windows'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the command to start IDT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./devicetester_mac_x86-64 run-suite --userdata userdata.json` on macOS'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./devicetester_linux_x86-64 run-suite --userdata userdata.json` on Linux'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`devicetester_win_x86-64.exe run-suite --userdata userdata.json` on Windows'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running IDT will start a local application that connects to your edge device
    over SSH and completes the series of tests. It will stop upon encountering the
    first failed test case or run until all test cases have passed. If you are running
    IDT against a fresh installation of your Raspberry Pi, as defined by previous
    steps, you should observe an output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The step to install Java on the Raspberry Pi was intentionally left out in order
    to demonstrate how IDT identifies missing dependencies; apologies for the deception!
    If you ran the IDT test suite and passed all of the test cases, then you are ahead
    of schedule and can skip to the *Installing IoT Greengrass* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To fix this missing dependency, return to your Raspberry Pi interface and open
    the Terminal app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Java on the Pi using `sudo apt-get install default-jdk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to your command-and-control system and run IDT again (repeat the command
    in *step 11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your test suite should now pass the Java requirement test. If you encounter
    other failures, you will need to use the test report and logs in the `idt/devicetester_greengrass_v2_mac/results`
    folder to triage and fix them. Some common missteps include missing AWS credentials,
    AWS credentials without sufficient permissions, and incorrect paths to resources
    defined in `userdata.json`. A fully passed suite of test cases looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the introductory use of IDT to analyze and assist in preparing
    your devices to use IoT Greengrass. Here, the best practice is to use software
    tests, not just for your own code but to assess whether the edge device itself
    is ready to work with your solution. Lean on tools such as IDT that do the heavy
    lifting of proving that the device is ready to use and validate this for each
    new type of device enrolled or major solution version released. You should be
    able to configure IDT for your next project and qualify a new device or group
    of devices to run IoT Greengrass. In the next section, you will learn how to install
    IoT Greengrass on your device in order to configure your first edge component.
  prefs: []
  type: TYPE_NORMAL
- en: Installing IoT Greengrass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have used IDT to validate that your edge device is compatible with
    IoT Greengrass, the next milestone in this chapter is to install IoT Greengrass.
  prefs: []
  type: TYPE_NORMAL
- en: 'From your edge device (that is, the prototype Home Base Solutions hub), open
    the Terminal app, or use your command-and-control device to remotely access it
    using SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the directory to your user''s home directory: `cd ~/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the IoT Greengrass core software: `curl -s` [https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-nucleus-latest.zip](https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-nucleus-latest.zip)
    > greengrass-nucleus-latest.zip.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unzip the archive: `unzip greengrass-nucleus-latest.zip -d greengrass && rm
    greengrass-nucleus-latest.zip`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your edge device requires AWS credentials in order to provision cloud resources
    on your behalf. You can use the same credentials that you created for the `idtgg`
    user in the previous *Configuring the AWS account and permissions* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`export AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`export AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the IoT Greengrass core software using the following command. If you
    are using an AWS region other than `us-west-2`, update the value of the `--aws-region`
    argument. You can copy and paste this command from `chapter2/commands/provision-greengrass.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it! The last few lines of output from this provisioning command should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The installation of the IoT Greengrass core software and the provisioning of
    the initial resources is much smoother after validating compatibility with the
    IDT suite. Now your edge device has the first fundamental tool installed: the
    runtime orchestrator. Let''s review the resources that have been created at the
    edge and in AWS from this provisioning step.'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing what has been created so far
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On your edge device, the IoT Greengrass software was installed in the `/greengrass/v2`
    file path. In that directory, the public and private keypairs are generated for
    connecting to AWS, service logs, a local repository of packages for recipes and
    artifacts, and a directory for past and present deployments pushed to this device.
    Feel free to explore the directory at `/greengrass/v2` to get familiar with what
    is stored on the device; though, you will need to escalate permissions using `sudo`
    to browse everything.
  prefs: []
  type: TYPE_NORMAL
- en: The installation added the first `aws.greengrass.Nucleus`. The nucleus component
    is the foundation of IoT Greengrass; it is the only mandatory component, and it
    facilitates key functionality such as deployments, orchestration, and life cycle
    management for all other components. Without the nucleus component, there is no
    IoT Greengrass.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the installation created the first `--deploy-dev-tools true` argument.
    That deployment installed a component named `aws.greengrass.Cli`. This second
    component includes a script, called `greengrass-cli`, that is used for local development
    tasks such as reviewing deployments, components, and logs. It can also be used
    to create new components and deployments. Remember, with IoT Greengrass, you can
    work locally on the device or push deployments remotely to it through AWS. Remote
    deployments are introduced in [*Chapter 4*](B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073),
    *Extending the Cloud to the Edge*.
  prefs: []
  type: TYPE_NORMAL
- en: In AWS, a few different resources were created. First, a new `hbshub001` from
    the IoT Greengrass provisioning argument, `--thing-name`. Similarly, a new `hbshubprototypes`,
    from the `--thing-group-name` provisioning argument. A thing group contains zero
    or more things and thing groups. The design of IoT Greengrass uses thing groups
    to identify sets of edge devices that should have the same deployments running
    on them. For example, if you provisioned another hub prototype device, you would
    add it to the same `hbshubprototypes` thing group such that the new prototype
    deployments would travel to all of your prototype devices.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, your `hbshub001` thing has an entity attached to it called a `/greengrass/v2`
    directory and is used to establish mutually authenticated connections to AWS.
    The certificate is how AWS recognizes the device when it connects with its private
    key (the certificate is attached to the `hbshub001` thing record) and knows how
    to look up permissions for the device. Those permissions are defined in another
    resource called the **IoT policy**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IoT policy is similar to an AWS IAM policy in that it defines explicit permissions
    for what an actor is allowed to do when interacting with AWS. In the case of an
    IoT policy, the actor is the device and permissions are for actions such as opening
    a connection, publishing and receiving messages, and accessing static resources
    defined in deployments. Devices get their permissions through their certificate,
    meaning a thing is attached to the certificate, and the certificate is attached
    to one or more policies. Here''s a sketch of how these basic resources are related
    in the edge and the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Illustrating the relationships between the IoT Core thing registry
    and edge resources'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Illustrating the relationships between the IoT Core thing registry
    and edge resources
  prefs: []
  type: TYPE_NORMAL
- en: 'In the cloud service of IoT Greengrass, a few more resources were defined for
    the initial provisioning of your device and its first deployment. An IoT Greengrass
    **core** is a mapping of a device (which is also known as a thing), the components
    and deployments running on the device, and the associated thing group the device
    is in. Additionally, a core stores metadata such as the version of IoT Greengrass
    core software installed and the status of the last known health check. Here is
    an alternate view of the relationship graph with IoT Greengrass resources included:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Illustrating the relationships between IoT Core, IoT Greengrass,
    and the edge device'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Illustrating the relationships between IoT Core, IoT Greengrass,
    and the edge device
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have installed IoT Greengrass and have an understanding of the
    resources created on provisioning, let's review what a component looks like when
    deployed to inform your implementation of the *Hello, world* component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first edge component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic milestone of any developer education is the *Hello, world* example.
    For your first edge component deployed to IoT Greengrass, you will create a simple
    *Hello, world* application in order to reinforce concepts such as component definition,
    a dependency graph, and how to create a new deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing an existing component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you get started with drafting a new component, take a moment to familiarize
    yourself with the existing components that have already been deployed by using
    the IoT Greengrass CLI. This CLI was installed by the `--deploy-dev-tools true`
    argument that was passed in during the installation. This tool is designed to
    help you with a local development loop; however, as a best practice, it is not
    installed in production solutions. It is installed at `/greengrass/v2/bin/greengrass-cli`.
    The following steps demonstrate how to use this tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Try invoking the `help` command. In the Terminal app of your edge device, run
    `/greengrass/v2/bin/greengrass-cli help`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should view the output of the `help` command, including references to the
    `component`, `deployment`, and `logs` commands. Try invoking the `help` command
    on the `component` command: `/greengrass/v2/bin/greengrass-cli help component`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should view instructions regarding how to use the `component` command.
    Next, try invoking the `component list` command to show all of the locally installed
    components, `/greengrass/v2/bin/greengrass-cli component list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`sudo /greengrass/v2/bin/greengrass-cli component list`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You don''t need to run the following *A* and *B* commands. They are included
    here to show you how to find the file contents later on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To find the recipe file, use `sudo ls /greengrass/v2/packages/recipes/`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To inspect the file, use `sudo` `less /greengrass/v2/recipes/rQVjcR-rX_XGFHg0WYKAnptIez3HKwtctL_2BKKZegM@2.4.0.recipe.yaml`
    (note that your filename will be different):'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are a few important observations to review in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: Component names use a reverse domain scheme that is similar to the `namespacing`
    Java package. Your custom components in this book's project will start with `com.hbs.hub`,
    signifying components written for the Home Base Solutions hub product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This component is tied to specific versions of the IoT Greengrass nucleus, which
    is why the version is 2.4.0\. Your components can specify any version here, and
    the best practice is to follow the semantic versioning specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ComponentType` property is only used by AWS plugins such as this CLI. Your
    custom components will not define this property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This component only works with a specific version of the nucleus, so it defines
    a soft dependency on the `aws.greengrass.nucleus` component. Your custom components
    do not need to specify a nucleus dependency by default. This is where you will
    define dependencies on other components, for example, a component that ensures
    Python3 is installed before loading a component with a Python application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This component defines no specific life cycle activities, either at the global
    level or specific to the `linux` platform version of the manifest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The artifacts defined are for specific IoT Greengrass service files. You can
    view these files on disk in the `/greengrass/v2/packages/artifacts` directory.
    Your artifact URIs will use the `s3://path/to/my/file` pattern when deploying
    them from the cloud. During local development, your manifest does not need to
    define artifacts, as they are expected to already be on disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the permissions on the two artifacts. The ZIP file can be read by any system
    user. In comparison, the JAR file can only be read by the `OWNER`, which in this
    scenario, means the default system user that was defined at installation, for
    example, the `ggc_user` user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this review of the component structure, it's time to write your own component
    with an artifact and a recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the first component that we wish to create is a simple
    "Hello, world" application. In this component, you will create a shell script
    that prints `Hello, world` with the `echo` command. That shell script is an artifact
    for your component. Additionally, you will write a recipe file that tells IoT
    Greengrass how to use that shell script as a component. Finally, you will use
    the local IoT Greengrass CLI to deploy this component and check it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local component development uses artifacts and recipe files available on the
    local disk, so you will need to create some folders for your working files. There
    is no folder in `/greengrass/v2` that is designed to store your working files.
    Therefore, you will create a simple folder tree and add your component files there:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Terminal app of your edge device, change the directory to your user''s
    home directory: `cd ~/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new folder to hold your local component resources: `mkdir -p hbshub/{artifacts,recipes}`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create the path for a new artifact and add a shell script to its folder.
    Let''s choose the component name of `com.hbs.hub.HelloWorld` and start the version
    at 1.0.0\. Change the directory to the artifacts folder: `cd hbshub/artifacts`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make a new directory for your component''s artifacts: `mkdir -p com.hbs.hub.HelloWorld/1.0.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file for the shell script: `touch com.hbs.hub.HelloWorld/1.0.0/hello.sh`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give this file write permissions: `chmod +x com.hbs.hub.HelloWorld/1.0.0/hello.sh`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file in an editor: `nano com.hbs.hub.HelloWorld/1.0.0/hello.sh`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this editor, add the following content (this is also available in this
    chapter''s GitHub repository):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your script with and without an argument. The script will print `Hello,
    world` unless provided with an argument to substitute for `world`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./com.hbs.hub.HelloWorld/1.0.0/hello.sh`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./com.hbs.hub.HelloWorld/1.0.0/hello.sh friend`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s all you need for your component''s artifact. Next, you will learn how
    to take advantage of passing in arguments from inside the recipe file. Change
    the directory to the recipes directory: `cd ~/hbshub/recipes`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the editor to create the recipe file: `nano com.hbs.hub.HelloWorld-1.0.0.json`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following content to the file. You can also copy this file from the
    book''s GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This recipe is straightforward: it defines a life cycle step to run our `hello.sh`
    script that it will find in the deployed artifacts path. One new addition that
    has not yet been covered is the component configuration. The `ComponentConfiguration`
    object allows developers to define arbitrary key-value pairs that can be referenced
    in the rest of the recipe file. In this scenario, we define a default value to
    pass as an argument to the script. This value can be overridden when deploying
    a component to customize how each edge device uses the deployed component.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, how do you test a component now that you've written the recipe and provided
    the artifacts? The next step is to create a new deployment that tells the local
    IoT Greengrass environment to load your new component and start evaluating life
    cycle events for it. This is where the IoT Greengrass CLI can help.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following command to create a new deployment that includes your new
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should view a response similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can verify that the component was successfully deployed (and has already
    finished running) with `sudo /greengrass/v2/bin/greengrass-cli component list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can view the output of this component in its log file: `sudo less /greengrass/v2/logs/com.hbs.hub.HelloWorld.log`
    (remember, the `/greengrass/v2 directory` is owned by root, so the log files must
    also be accessed with `sudo`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations! You have written and deployed your first component to your
    Home Base Solutions prototype hub using IoT Greengrass. In the log output, you
    can observe two noteworthy observations. First, you can view the chronology of
    the component's life cycle change state from `STARTING` to `RUNNING` before reporting
    a successful exit code back to IoT Greengrass. The component concludes at that
    point, so we don't view an entry in the log that shows it move to the `FINISHED`
    state, although that is visible in the `greengrass.log` file.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you can view the message written to `STDOUT` with an exclamation point
    included (`world!`). This means that the script received your component's default
    configuration instead of falling back on the default built into `hello.sh` (`world`).
    You could also override the default configuration value of "world!" in the recipe
    file with a custom value included in the deployment command. You'll learn how
    to use that technique to configure fleets in [*Chapter 4*](B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073)*,
    Extending the Cloud to the Edge*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics regarding a specific tool we will use
    throughout this book that satisfies one of the key needs of any edge ML solution,
    that is, the runtime orchestrator. IoT Greengrass provides out-of-the-box features
    to focus developers on their business solutions instead of the undifferentiated
    work to architect a flexible, resilient edge runtime and deployment mechanism.
    You learned that the fundamental unit of software in IoT Greengrass is the component,
    which is made up of a recipe and a set of artifacts, and components make their
    way to the solution via deployments. You learned how to validate that a device
    is ready to work with IoT Greengrass using the IDT. You learned how to install
    IoT Greengrass, develop your first component, and get it running in the local
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deeper dive into how IoT Greengrass works
    by exploring how it enables gateway functionality, common protocols used at the
    edge, security best practices, and builds out new components used to sense and
    actuate in a cyber-physical solution.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving on to the next chapter, test your knowledge by answering these
    questions. The answers can be found at the end of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is the best practice for how to organize code in edge
    ML solutions? A monolithic application or isolated services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of decoupling services in your edge architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of isolating your code and dependencies from other services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one trade-off to consider when choosing between wired and wireless networking
    implementations in IoT solutions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an example of a smart home device that uses both a sensor and an actuator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two kinds of resources that define an IoT Greengrass component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: A component must define at least one artifact in its recipe.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it a good design principle that, by default, only the root system user
    can interact with files in the IoT Greengrass directory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Components can be deployed to IoT Greengrass devices either
    locally or remotely.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you think of three different methods that you could use to update the behavior
    of your `Hello, world` component to print `Hello, Home Base Solutions customer!`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following resources for additional information on the concepts
    discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The semantic versioning specification at [https://semver.org](https://semver.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Service-Oriented Architecture: Analysis and Design for Services and Microservices*
    by Erl Thomas, Pearson, 2016.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Foundations of Analog and Digital Electric Circuits* by Anant Agarwal, Jeffrey
    H. Lang, and Morgan Kaufmann, 2005.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
