- en: '*Chapter 2*: Foundations of Edge Workloads'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：边缘工作负载的基础'
- en: This chapter will explore the next level of detail regarding **edge workloads**
    and your first hands-on activity. You will learn how **AWS IoT Greengrass** meets
    the needs for designing and delivering modern edge ML solutions. You will learn
    how to prepare your edge device to work with AWS by deploying a tool that checks
    your device for compatible requirements. Additionally, you will learn how to install
    the IoT Greengrass core software and deploy your first IoT Greengrass core device.
    You will learn about the structure of components, examine the fundamental unit
    of software in IoT Greengrass, and write your first edge workload component.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨关于**边缘工作负载**的更深入细节以及您的第一次动手实践。您将了解AWS IoT Greengrass如何满足设计和交付现代边缘机器学习解决方案的需求。您将学习如何通过部署一个检查设备兼容性要求的工具来准备您的边缘设备与AWS协同工作。此外，您还将学习如何安装IoT
    Greengrass核心软件并部署您的第一个IoT Greengrass核心设备。您将了解组件的结构，检查IoT Greengrass中的软件的基本单元，并编写您的第一个边缘工作负载组件。
- en: By the end of this chapter, you should start to feel comfortable with the basics
    of IoT Greengrass and its local development life cycle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该开始熟悉IoT Greengrass及其本地开发生命周期的基础知识。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The anatomy of an edge ML solution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘机器学习解决方案的解剖结构
- en: IoT Greengrass for the win
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoT Greengrass大获全胜
- en: Checking compatibility with IoT Device Tester
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查与IoT设备测试器的兼容性
- en: Installing IoT Greengrass
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装IoT Greengrass
- en: Your first edge component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的第一个边缘组件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are the same as those described
    in the Hands-on prerequisites section in [*Chapter 1*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013)*,
    Introduction to the Data-Driven Edge with Machine Learning*. Please refer to the
    full requirements mentioned in that chapter. As a reminder, you will need the
    following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求与[*第一章*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013)“使用机器学习的数据驱动边缘简介”中描述的手动先决条件部分相同。请参阅该章节中提到的完整要求。提醒一下，您将需要以下内容：
- en: A Linux-based system to deploy the IoT Greengrass software. A Raspberry Pi 3B,
    or later, is recommended. The installation instructions are similar to other Linux-based
    systems. Please refer to the following GitHub repository for further guidance
    when the hands-on steps differ for systems other than a Raspberry Pi.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Linux的系统用于部署IoT Greengrass软件。建议使用Raspberry Pi 3B或更高版本。安装说明与其他基于Linux的系统类似。当其他系统（如Raspberry
    Pi）的手动步骤不同时，请参考以下GitHub仓库以获取进一步指导。
- en: A system to install and use the AWS **Command-Line Interface** (**CLI**), enabling
    access to the AWS Management Console website (typically, your PC/laptop).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用AWS **命令行界面**（**CLI**）的系统，以便访问AWS管理控制台网站（通常是您的PC/笔记本电脑）。
- en: You can access this chapter's technical resources from the GitHub repository,
    under the `chapter2` folder, at [https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter2](https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub仓库的`chapter2`文件夹中访问本章的技术资源，网址为[https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter2](https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter2)。
- en: The anatomy of an edge ML solution
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘机器学习解决方案的解剖结构
- en: 'The previous chapter introduced the concept of an edge solution along with
    the three key kinds of tools that define an edge solution with ML applications.
    This chapter provides more detail regarding the layers of an edge solution. The
    three layers addressed in this section are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了边缘解决方案的概念以及定义具有机器学习应用的边缘解决方案的三个关键工具。本章提供了关于边缘解决方案各层的更多细节。本节中讨论的三个层如下：
- en: The **business logic layer** includes the customized code that dictates the
    solution's behavior.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务逻辑层**包括决定解决方案行为的定制代码。'
- en: The **physical interface layer** connects your solution to the analog world
    with sensors and actuators.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理接口层**通过传感器和执行器将您的解决方案连接到模拟世界。'
- en: The **network interface layer** connects your solution to other digital entities
    in the wider network.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络接口层**将您的解决方案连接到更广泛网络中的其他数字实体。'
- en: Learning more about these layers is important because they will inform how you,
    as the IoT architect, make trade-offs when designing your edge ML solution. First,
    we'll start by defining the business logic layer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些层对于重要，因为它们将告知您作为物联网架构师在设计边缘机器学习解决方案时如何进行权衡。首先，我们将从定义业务逻辑层开始。
- en: Designing code for business logic
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为业务逻辑设计代码
- en: 'The business logic layer is where all the code of your edge solution lives.
    This code can take many shapes, such as *precompiled binaries* (such as a C program),
    *shell scripts*, *code evaluated by a runtime* (such as a Java or Python program),
    and *ML models*. Additionally, code can be organized in a few different ways such
    as shipping everything into a monolithic application, splitting up code into services
    or libraries, or bundling code to run in a container. All of these options come
    with implications for architecting and shipping an edge ML solution, such as security,
    cost, consistency, productivity, and durability. Some of the challenges of delivering
    code for the business logic layer are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑层是您的边缘解决方案所有代码的存放地。这些代码可以有多种形式，例如*预编译的二进制文件*（如C程序）、*shell脚本*、*由运行时评估的代码*（如Java或Python程序）和*机器学习模型*。此外，代码可以以几种不同的方式组织，例如将所有内容打包到一个单体应用程序中、将代码拆分为服务或库，或将代码捆绑到容器中运行。所有这些选项都对架构和发送边缘机器学习解决方案有影响，例如安全性、成本、一致性、生产力和耐用性。业务逻辑层交付代码的一些挑战如下：
- en: Writing and testing code that will run on your edge hardware platforms. For
    example, writing code that will work on variations of hardware platforms as incremental
    new versions are rolled out. You will want to minimize the number of forks of
    code you maintain that meet the needs of all your hardware platforms.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和测试将在您的边缘硬件平台上运行的代码。例如，编写将在硬件平台的新版本推出时工作的代码，您将希望最小化维护满足所有硬件平台需求的代码分支数量。
- en: Designing a robust edge solution that encompasses many features. For example,
    bundling features to process new sensor data, analyze data, and communicate with
    web services that do not create conflicts with common dependencies or local resources.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个包含许多功能的强大边缘解决方案。例如，将功能捆绑在一起以处理新的传感器数据、分析数据和与不与常见依赖项或本地资源冲突的Web服务进行通信。
- en: Writing code with a team of people all working on an aggregate edge solution.
    For example, a monolithic application with many contributors can require each
    author to fully know the solution to make an incremental change.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与一个团队一起编写代码，该团队正在共同开发一个边缘解决方案。例如，一个由许多贡献者组成的单体应用程序可能需要每个作者完全了解解决方案才能进行增量更改。
- en: To address the challenges of writing your business layer logic, the best practice
    for shipping code to the edge is to use **isolated services** where practical.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决编写业务层逻辑的挑战，将代码发送到边缘的最佳实践是在实际可行的情况下使用**独立服务**。
- en: Isolated services
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立服务
- en: 'On your *Home Base Solutions hub device* (the fictional product we are creating
    from the story in [*Chapter 1*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013),
    *Introduction to the Data-Driven Edge with Machine Learning*), code will be deployed
    and run as isolated services. In this context, a **service** is a self-contained
    unit of business logic that is either invoked by another entity to perform a task
    or performs a task on its own. **Isolation** means that the service will bundle
    with it the code, resources, and dependencies it needs for its operation. For
    example, a service you will create in [*Chapter 7*](B17595_07_Final_SS_ePub.xhtml#_idTextAnchor138),
    *Machine Learning Workloads at the Edge*, will run code to read from a data source
    or collection of images, periodically compute inferences using a bundled ML model,
    then publish any inference results to a local stream or the cloud. This pattern
    of isolated services is selected for two reasons:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的*Home Base Solutions hub设备*（我们从[*第1章*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013)，《利用机器学习的数据驱动边缘介绍》）中，代码将以独立服务的形式部署和运行。在这个背景下，一个**服务**是一个包含业务逻辑的自包含单元，它可以被另一个实体调用以执行任务，或者自行执行任务。**隔离**意味着服务将捆绑其操作所需的代码、资源和依赖项。例如，您将在[*第7章*](B17595_07_Final_SS_ePub.xhtml#_idTextAnchor138)，《边缘机器学习工作负载》中创建的服务将运行代码以从数据源或图像集合中读取，定期使用捆绑的机器学习模型进行推理，然后将任何推理结果发布到本地流或云端。选择这种独立服务模式有两个原因：
- en: The first reason is that a **service-oriented architecture** enables architects
    to design capabilities that are decoupled from one another. **Decoupling** means
    we use data structures, such as buffers, queues, and streams, to add a layer of
    abstraction between our services, reducing dependencies to allow services to run
    independently.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个原因是**服务导向架构**使架构师能够设计相互解耦的能力。**解耦**意味着我们使用数据结构，如缓冲区、队列和流，在服务之间添加一层抽象，减少依赖性，使服务能够独立运行。
- en: You can deploy updates to individual services without touching other running
    services and, therefore, reduce the risk of impact on them. Decoupled, service-oriented
    architecture is a best practice for designing well-architected cloud solutions
    that are also a good fit for edge ML solutions where multiple services are simultaneously
    running and emphasize a need for reliability. For example, a service that interfaces
    a sensor writes new measurements to a data structure and nothing more; it has
    a single job and doesn't need to be aware of how the data is consumed by a later
    capability.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在不触及其他正在运行的服务的情况下部署单个服务的更新，因此可以降低对它们的影响风险。解耦的服务导向架构是设计良好架构的云解决方案的最佳实践，同时也非常适合边缘机器学习解决方案，在这些解决方案中，多个服务同时运行，并强调对可靠性的需求。例如，一个与传感器接口的服务将新的测量值写入数据结构，仅此而已；它只有一个任务，不需要了解数据是如何被后续功能消费的。
- en: The second reason is that the **isolation** of code enables developers to focus
    on what that code does instead of where the code is going or how dependencies
    are managed at the destination. By using principles of isolation to bundle runtime
    dependencies and resources with code, we get stronger consistency that code will
    work deterministically wherever it is deployed. Developers free up the effort
    required for dependency management and have more confidence that the code will
    work the same way on the edge platform, which is likely different than their development
    environment. That's not to say an edge solution developer won't need to test the
    behavior of their code against physical interfaces such as sensors and actuators.
    However, it does mean that development teams can deliver self-contained services
    that work independently regardless of the rest of the services deployed in the
    aggregate edge solution.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因是**代码隔离**使开发者能够专注于代码的功能，而不是代码的去向或依赖项在目标位置的管理方式。通过使用隔离原则将运行时依赖项和资源与代码捆绑在一起，我们获得了更强的确定性，即代码将在部署的任何地方都能确定性地工作。开发者可以释放出用于依赖项管理的努力，并且更有信心代码将在边缘平台上以相同的方式工作，这可能与他们的开发环境不同。这并不是说边缘解决方案的开发者不需要测试他们的代码对物理接口（如传感器和执行器）的行为。然而，这意味着开发团队能够交付自包含的服务，这些服务可以独立工作，而不管在聚合的边缘解决方案中部署的其他服务如何。
- en: 'Examples of isolation include **Python** virtual environments, which explicitly
    specify a Python runtime version and package, and **Docker Engine**, which uses
    containers to bundle dependencies, resources, and achieve process isolation on
    the host. The following diagram illustrates the separation of concerns achieved
    with isolated services:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 隔离的例子包括**Python**虚拟环境，它明确指定了Python运行时版本和包，以及**Docker Engine**，它使用容器来打包依赖项、资源和在主机上实现进程隔离。以下图表展示了使用隔离服务实现的关注点分离：
- en: '![Figure 2.1 – An edge solution using decoupled, isolated services'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 使用解耦、隔离服务的边缘解决方案'
- en: '](img/B17595_02_001.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B17595_02_001.jpg](img/B17595_02_001.jpg)'
- en: Figure 2.1 – An edge solution using decoupled, isolated services
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 使用解耦、隔离服务的边缘解决方案
- en: In tandem, the patterns of isolation and services offer compelling benefits
    for edge ML solutions. Of course, every decision in development comes with trade-offs.
    The solution would be simpler if deployed as a singular monolith of code and faster
    to derive a minimum viable product. We opt for more architectural complexity because
    this leads to better resiliency and a scaling up of the solution over time. We
    lean on strong patterns and good tooling to balance that complexity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，隔离和服务模式为边缘机器学习解决方案提供了引人注目的好处。当然，开发中的每一个决策都伴随着权衡。如果作为单一代码单体部署，解决方案会更简单，并且更快地推出最小可行产品。我们选择更复杂的架构，因为这会导致更好的弹性和随时间扩展的解决方案。我们依靠强大的模式和良好的工具来平衡这种复杂性。
- en: IoT Greengrass is designed with this pattern in mind. Later, in this chapter
    and throughout the book, you will learn how to use this pattern with IoT Greengrass
    to develop well-architected edge ML solutions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网 Greengrass 是按照这种模式设计的。在本章及整本书中，你将学习如何使用这种模式与物联网 Greengrass 结合，开发结构良好的边缘机器学习解决方案。
- en: Physical interfaces
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理接口
- en: 'A cyber-physical solution is defined by the use of physical interfaces to interact
    with the analog world. These interfaces come in two classifications: *sensors
    for taking measurements from the analog world* and *actuators for exerting change
    back upon it*. Some machines do both, such as a refrigerator that senses internal
    temperature and activates its compressor to cycle a refrigerant through coils.
    In these cases, the aggregation of sensing and actuating is logical, meaning the
    sensor and actuator have a relationship but are functionally independent and are
    coordinated via a mechanism such as a switch, circuit, or microcontroller.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 网络物理解决方案是通过使用物理接口与模拟世界进行交互来定义的。这些接口分为两类：*用于从模拟世界获取测量的传感器*和*用于对它施加变化的执行器*。一些机器两者都做，例如冰箱可以感知内部温度并激活其压缩机循环制冷剂。在这些情况下，传感和执行器的聚合是逻辑的，这意味着传感器和执行器之间存在关系，但在功能上是独立的，并且通过开关、电路或微控制器等机制进行协调。
- en: 'Sensors that perform analog-to-digital conversion do so by sampling the voltage
    from an electrical signal and converting it into a digital value. These digital
    values are interpreted by code to derive data such as temperature, light, and
    pressure. Actuators convert digital signals into analog actions, typically, by
    manipulating the voltage going to a switch or circuit. A command to engage a motor
    is interpreted as raising a voltage to the level that activates the circuit. Diving
    deeper into the electrical engineering of physical interfaces is beyond the scope
    of this book. Please refer to the *References* section for recommendations on
    deeper dives on that topic. The following diagram shows a simple analog example
    of a refrigerator and the relationship between the thermostat (sensor), switch
    (controller), and compressor (actuator):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 执行模拟到数字转换的传感器通过采样电信号中的电压并将其转换为数字值。这些数字值通过代码解释以推导出数据，如温度、光和压力。执行器将数字信号转换为模拟动作，通常通过操纵通往开关或电路的电压来实现。深入探讨物理接口的电气工程超出了本书的范围。请参阅
    *参考文献* 部分以获取关于该主题深入研究的建议。以下图表展示了一个简单的模拟示例，包括冰箱以及恒温器（传感器）、开关（控制器）和压缩机（执行器）之间的关系：
- en: '![Figure 2.2 – An analog controller with a sensor and an actuator'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 带有传感器和执行器的模拟控制器'
- en: '](img/B17595_02_002.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17595_02_002.jpg)'
- en: Figure 2.2 – An analog controller with a sensor and an actuator
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 带有传感器和执行器的模拟控制器
- en: It's important to understand the patterns of input and output delivered by a
    cyber-physical solution and the relationship to a higher-level outcome delivered
    through an edge ML solution. Throughout the project delivered in this book, you
    will gain hands-on experience applying these patterns. Some of the services of
    the Home Base Solutions hub device will serve as interfaces to the physical layer,
    providing new measurements from the sensors and converting the commands to change
    the state of local devices. If you are working with a physical edge device, such
    as the Raspberry Pi, you will get some experience of using code to interact with
    the physical interfaces of that device.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 理解由网络物理解决方案提供的输入和输出模式以及与通过边缘机器学习解决方案提供的更高层次结果之间的关系是很重要的。在本书中交付的项目中，你将获得实际应用这些模式的经验。Home
    Base Solutions 中心设备的一些服务将作为物理层的接口，提供来自传感器的新的测量值，并将命令转换为改变本地设备状态的命令。如果你正在使用物理边缘设备，例如
    Raspberry Pi，你将获得一些使用代码与该设备的物理接口交互的经验。
- en: Network interfaces
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络接口
- en: The third layer to introduce for our edge solution anatomy is the *network interface*.
    A differentiator between our definitions of cyber-physical solutions and edge
    solutions is that an edge solution will, at some point, interact with another
    entity over a network. For example, the design of our new appliance monitoring
    kit for Home Base Solutions uses wireless communication between the monitoring
    kit and the hub device. There is no physical connection between the two for the
    purposes of analog-to-digital signal conversion from the monitor's sensors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍我们的边缘解决方案结构时，需要引入的第三层是*网络接口*。我们定义的物理-网络解决方案与边缘解决方案之间的区别在于，边缘解决方案在某个时刻将通过网络与另一个实体进行交互。例如，我们为Home
    Base Solutions设计的新设备监控套件使用监控套件与中心设备之间的无线通信。为了将监控器的传感器信号从模拟转换为数字，这两个设备之间没有物理连接。
- en: 'Similarly, the hub device will also exchange messages with a cloud service
    to store telemetry to use in the training of the ML model, to deploy new resources
    to the device, and to alert customers of recognized events. The following diagram
    illustrates the flow of messages and the relationships between a **Sensor**, **Actuator**,
    hub device (**Gateway**), and the cloud service:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，中心设备也会与云服务交换消息，以存储用于训练机器学习模型的数据、向设备部署新资源以及向客户通知已识别的事件。以下图示说明了消息流以及**传感器**、**执行器**、中心设备（**网关**）和云服务之间的关系：
- en: '![Figure 2.3 – An edge device exchanging messages with local sensors, actuators,
    and the cloud'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 一个边缘设备与本地传感器、执行器和云交换消息'
- en: '](img/B17595_02_003.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17595_02_003.jpg]'
- en: Figure 2.3 – An edge device exchanging messages with local sensors, actuators,
    and the cloud
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 一个边缘设备与本地传感器、执行器和云交换消息
- en: Wireless communications are common in IoT solutions, and specific implementations
    enable connectivity at a wide range of distances. Each specification and implementation
    makes trade-offs for range, data transmission rate, hardware cost, and energy
    consumption. Short-range radio specifications such as **Zigbee** (IEEE 802.15.4),
    **Bluetooth** (IEEE 802.15.1), and **WiFi** (IEEE 802.11) are suitable for bridging
    devices within personal and local area networks. Long-range radio specifications
    such as conventional cellular networks (for example, **GSM**, **CDMA**, and **LTE**)
    and **low-power wide-area networks** (**LPWANs**) such as **LoRaWAN** and **NB-IoT**
    deliver connectivity options for devices deployed (either static or roaming) across
    a particular campus, city, or region.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网解决方案中，无线通信很常见，并且特定的实现可以在广泛的距离范围内实现连接。每个规范和实现都会在范围、数据传输速率、硬件成本和能耗之间做出权衡。短距离无线电规范，如**Zigbee**（IEEE
    802.15.4）、**蓝牙**（IEEE 802.15.1）和**WiFi**（IEEE 802.11），适用于连接个人和局域网内的设备。长距离无线电规范，如传统的蜂窝网络（例如，**GSM**、**CDMA**和**LTE**）以及**低功耗广域网络**（**LPWANs**）如**LoRaWAN**和**NB-IoT**，为部署（无论是静态还是漫游）在特定校园、城市或地区的设备提供了连接选项。
- en: Wired communications are still common for connecting edge devices such as TVs,
    game consoles, and PCs to home network solutions such as switches and routers
    over **Ethernet**. Wired connectivity is less common in smart home products due
    to the limited number of Ethernet ports on home networking routers (typically,
    there are only 1–8 ports), the restrictions regarding where the device can be
    placed, and the burden of adding wires throughout the home.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有线通信仍然用于连接边缘设备，如电视、游戏机和PC，通过**以太网**连接到家庭网络解决方案，如交换机和路由器。由于家庭网络路由器上以太网端口的数量有限（通常只有1-8个端口），设备放置的限制以及在家中的布线负担，有线连接在智能家居产品中不太常见。
- en: For example, the Home Base Solutions appliance monitoring kit would likely use
    a Zigbee, or equivalent implementation, and a battery to balance energy consumption
    with the anticipated data rate. If the kit required a power supply from a nearby
    outlet, Wi-Fi becomes more of an option; however, it would limit the overall product
    utility as the placement of the kinds of appliances to monitor don't always have
    a spare outlet. Additionally, it wouldn't make sense to use Ethernet to connect
    the kits to the hub directly since customers likely wouldn't find all of the extra
    wires running throughout the home appealing. The hub device that communicates
    with the kit could use Ethernet or Wi-Fi to bridge to the customer's local network
    to gain access to the public internet.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，家庭基站解决方案的设备监控套件可能会使用Zigbee或等效实现，以及电池来平衡能量消耗与预期的数据速率。如果套件需要从附近的插座获取电源，Wi-Fi就成为一个更可行的选择；然而，它将限制整体产品的实用性，因为要监控的设备类型放置位置并不总是有额外的插座。此外，直接使用以太网将套件连接到集线器也没有意义，因为客户可能不会觉得家里到处都是额外的电线很吸引人。与套件通信的集线器设备可以使用以太网或Wi-Fi连接到客户的本地网络，从而访问公共互联网。
- en: Now that you have a better understanding of the three layers of an edge solution,
    let's evaluate the selected edge runtime solution and how it implements each layer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了边缘解决方案的三个层次，让我们来评估选定的边缘运行时解决方案以及它是如何实现每一层的。
- en: IoT Greengrass for the win
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网Greengrass大获全胜
- en: The most important question to answer in a book about using IoT Greengrass to
    deliver edge ML solutions is *why IoT Greengrass?* When evaluating the unique
    challenges of edge ML solutions and the key tools required to deliver them, you
    want to select tools that solve as many problems for you as possible while staying
    out of your way in terms of being productive. IoT Greengrass is a purpose-built
    tool with IoT and ML solutions at the forefront of the value proposition.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在一本关于使用物联网Greengrass提供边缘机器学习解决方案的书中，最重要的一个问题是要回答*为什么是物联网Greengrass？*在评估边缘机器学习解决方案的独特挑战和实现它们所需的关键工具时，你希望选择尽可能解决你问题的工具，同时在提高生产效率方面不给你带来麻烦。物联网Greengrass是一个专门构建的工具，其价值主张将物联网和机器学习解决方案置于前沿。
- en: 'IoT Greengrass is prescriptive in how it solves the problem of the *undifferentiated
    heavy lifting* of common requirements while remaining non-prescriptive in how
    you implement your business logic. This means that the out-of-box experience yields
    many capabilities for rapid iteration without being obstructive about how you
    use them to reach your end goals. The following is a list of some of the capabilities
    that IoT Greengrass has to offer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网Greengrass在解决常见需求的*无差别的繁重工作*问题时具有指导性，但在实现你的业务逻辑时则不具有指导性。这意味着开箱即用的体验提供了许多快速迭代的能力，同时不会阻碍你如何使用它们来实现最终目标。以下是一些物联网Greengrass提供的能力列表：
- en: '**Security at the edge**: IoT Greengrass is installed with root permissions
    and uses operating system user permissions to protect the code and resources deployed
    at the edge from tampering.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘安全**：物联网Greengrass以root权限安装，并使用操作系统用户权限来保护在边缘部署的代码和资源，防止篡改。'
- en: '**Security to the cloud**: IoT Greengrass uses mutual **transport layer security**
    (**TLS**) with public key infrastructure to exchange messages between the edge
    and the cloud. Resources are fetched during deployments using HTTPS and AWS Signature
    Version 4 to verify the identity of the requester and protect data in transit.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云安全**：物联网Greengrass使用与公共密钥基础设施互操作的**传输层安全**（**TLS**）来在边缘和云之间交换消息。在部署期间使用HTTPS和AWS签名版本4来验证请求者的身份并保护传输中的数据。'
- en: '**Runtime orchestration**: Developers can design applications however they
    prefer (with monoliths, services, or containers) and deploy them to the edge with
    ease. IoT Greengrass provides hooks for smartly integrating with component life
    cycle events, or developers can ignore them and simply bootstrap applications
    with a single command. Individual components can be added or updated without interrupting
    other running services. A dependency tree allows developers to abstract out the
    installation of libraries and configuration activities to decouple from code artifacts.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时编排**：开发者可以按自己的喜好设计应用程序（使用单体、服务或容器），并轻松地将它们部署到边缘。物联网Greengrass提供了智能集成组件生命周期事件的钩子，或者开发者可以忽略它们，只需一个命令就可以引导应用程序。可以添加或更新单个组件，而不会中断其他正在运行的服务。依赖关系树允许开发者将库的安装和配置活动抽象出来，从而与代码工件解耦。'
- en: '**Logging and monitoring**: By default, IoT Greengrass creates logs for each
    component and allows developers to indicate which log files should be synchronized
    to the cloud for operational purposes. Additionally, the cloud service keeps track
    of device health automatically, making it easier for team members to identify
    and respond to unhealthy devices.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志和监控**：默认情况下，IoT Greengrass 为每个组件创建日志，并允许开发者指定哪些日志文件应同步到云端以供操作使用。此外，云服务会自动跟踪设备健康状况，使团队成员更容易识别和响应不健康的设备。'
- en: '**Scaling up the fleet**: Deploying updates to one device is not much different
    than deploying updates to a fleet of devices. It is easy to define groups, classify
    similar devices together, and then push updates to groups of devices using a managed
    deployment service.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展车队规模**：向单个设备部署更新与向设备车队部署更新并没有太大区别。定义组、将类似设备分类在一起，然后使用托管部署服务向设备组推送更新很容易。'
- en: '**Native integrations**: AWS provides many components to deploy into IoT Greengrass
    solutions that augment the baseline functionality and also for integrating with
    other AWS services. A stream management component enables you to define, write
    to, and consume streams at the edge. A Docker application manager allows you to
    download Docker images from public repositories or private repositories in **Amazon
    Elastic Container Registry**. Pretrained and optimized ML models are available
    for tasks such as object detection and image classification with **Deep Learning
    Runtime** and **TensorFlow Lite**.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生集成**：AWS 为部署到 IoT Greengrass 解决方案提供了许多组件，这些组件增强了基线功能，并可用于与其他 AWS 服务集成。一个流管理组件使您能够在边缘定义、写入和消费流。一个
    Docker 应用程序管理器允许您从公共存储库或**Amazon Elastic Container Registry**中的私有存储库下载 Docker
    镜像。预训练和优化的 ML 模型可用于对象检测和图像分类等任务，这些任务由**Deep Learning Runtime**和**TensorFlow Lite**提供支持。'
- en: In playing your role as the Home Base Solutions architect with a solution to
    build, you could propose that the engineering team invest the time and resources
    to build out all this functionality and test that it is production-ready. However,
    the IoT Greengrass baseline services and optional add-ons are ready to accelerate
    the development life cycle and come vetted by AWS, where *security is the top
    priority*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在扮演作为构建解决方案的 Home Base 解决方案架构师的角色时，您可能会建议工程团队投入时间和资源来构建所有这些功能，并测试其是否已准备好投入生产。然而，IoT
    Greengrass 基线服务和可选附加组件已准备好加速开发周期，并由 AWS 审核通过，其中**安全性是首要任务**。
- en: IoT Greengrass does not do everything for you. In fact, a fresh installation
    of IoT Greengrass doesn't do anything but wait for further instruction in the
    form of a deployment. Think of it as a blank canvas, paint, and brush. It's everything
    you need to get started, but you have to develop the solution that it runs. Let's
    review the operating model for IoT Greengrass, both at the edge and within the
    cloud.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: IoT Greengrass 并不会为您做所有事情。实际上，IoT Greengrass 的全新安装不会做任何事情，只是等待进一步的指令，即部署。把它想象成一张空白画布、颜料和画笔。它提供了您开始所需的一切，但您必须开发它所运行的解决方案。让我们回顾
    IoT Greengrass 的运营模式，包括边缘和云端的运营模式。
- en: Reviewing IoT Greengrass architecture
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 IoT Greengrass 架构
- en: 'IoT Greengrass is both a managed service running on AWS and an edge runtime
    tool. The managed service is where your devices are defined individually and in
    groups. When you want to push a new deployment to the edge, you are, in fact,
    invoking an API in the managed service that is then responsible for communicating
    with the edge runtime to coordinate the delivery of that deployment. Here is a
    sequence diagram showing the process of you, as the developer, configuring a component
    and requesting that a device running the IoT Greengrass core software receive
    and run that component:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: IoT Greengrass 既是运行在 AWS 上的托管服务，也是边缘运行时工具。托管服务是您定义设备的地方，包括单个设备和分组。当您想要将新的部署推送到边缘时，实际上是在托管服务中调用一个
    API，然后该 API 负责与边缘运行时通信，以协调该部署的交付。以下是一个序列图，展示了您作为开发者配置组件并请求运行 IoT Greengrass 核心软件的设备接收并运行该组件的过程：
- en: '![Figure 2.4 – Pushing a deployment through IoT Greengrass'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 通过 IoT Greengrass 推送部署'
- en: '](img/B17595_02_004.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17595_02_004.jpg](img/B17595_02_004.jpg)'
- en: Figure 2.4 – Pushing a deployment through IoT Greengrass
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 通过 IoT Greengrass 推送部署
- en: The **component** is the fundamental unit of functionality that is deployed
    to a device running IoT Greengrass. Components are defined by a manifest file,
    called a **recipe**, which tells IoT Greengrass what the name, version, dependencies,
    and instructions are for that component. In addition to this, a component can
    define zero or more **artifacts** that are fetched during deployment. These artifacts
    can be binaries, source code, compiled code, archives, images, or data files;
    really any kind of file or resource that is stored on disk. Component recipes
    can define dependencies on other components that get resolved via a graph by the
    IoT Greengrass software.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是部署到运行IoT Greengrass的设备上的功能的基本单元。组件由一个名为**配方**的清单文件定义，它告诉IoT Greengrass该组件的名称、版本、依赖项和指令。除此之外，组件还可以定义零个或多个在部署期间获取的**工件**。这些工件可以是二进制文件、源代码、编译代码、存档、图像或数据文件；实际上，任何存储在磁盘上的文件或资源。组件配方可以定义对其他组件的依赖关系，这些依赖关系将通过IoT
    Greengrass软件通过图来解析。'
- en: 'During a deployment activity, one or more components are added or updated in
    that deployment. The component''s artifacts are downloaded to the local device
    from the cloud; then, the component is started by way of evaluating life cycle
    instructions. A life cycle instruction could be something that happens during
    startup; it could be the main command to run, such as starting a Java application
    or something to do after the component has concluded running. Components might
    continue in the running state indefinitely or perform a task and exit. The following
    diagram provides an example of the component graph:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署活动期间，在该部署中添加或更新一个或多个组件。组件的工件从云中下载到本地设备；然后，通过评估生命周期指令来启动组件。生命周期指令可能是启动期间发生的事情；它可能是要运行的主要命令，例如启动Java应用程序或组件运行结束后要做的事情。组件可能会无限期地保持运行状态，或者执行任务后退出。以下图表提供了一个组件图的示例：
- en: '![Figure 2.5 – An example graph of components showing the life cycle and dependencies'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.5 – 组件的生命周期和依赖关系的示例图]'
- en: '](img/B17595_02_005.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17595_02_005.jpg]'
- en: Figure 2.5 – An example graph of components showing the life cycle and dependencies
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.5 – 组件的生命周期和依赖关系的示例图
- en: That's everything we need to cover before taking your first steps toward readying
    your edge device to run a solution with IoT Greengrass!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们准备开始将边缘设备准备好运行带有IoT Greengrass的解决方案之前需要涵盖的所有内容！
- en: In the following sections, you will validate that your edge device is ready
    to run the IoT Greengrass software, install the software, and then author your
    first component. In addition to this, you will get a closer look at components
    and deployments through the hands-on activities to come.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，您将验证您的边缘设备是否已准备好运行IoT Greengrass软件，安装软件，然后编写您的第一个组件。此外，您将通过即将到来的动手活动更深入地了解组件和部署。
- en: Checking compatibility with IoT Device Tester
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查与IoT设备测试器的兼容性
- en: '**IoT Device Tester** (**IDT**) is a software client provided by AWS to assess
    device readiness for use in AWS IoT solutions. It assists developers by running
    a series of qualification tests to validate whether the destination system is
    ready to run the IoT Greengrass core software. Additionally, it runs a series
    of tests to prove that edge capabilities are already present, such as establishing
    MQTT connections to AWS and running ML models locally. IDT works for one device
    you are testing locally or scales up to run customized test suites against any
    number of device groups, so long as they are accessible over the network.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**IoT设备测试器**（**IDT**）是AWS提供的一个软件客户端，用于评估设备在AWS IoT解决方案中的使用准备情况。它通过运行一系列资格测试来帮助开发者验证目标系统是否已准备好运行IoT
    Greengrass核心软件。此外，它还运行一系列测试来证明边缘能力已经存在，例如建立与AWS的MQTT连接或在本地运行机器学习模型。IDT适用于您正在本地测试的一个设备，或者可以扩展以运行针对任何数量的设备组的定制测试套件，只要它们可以通过网络访问。'
- en: In the context of your role as the IoT architect at Home Base Solutions, you
    should use IDT to prove that your target edge device platform (in this case, platform
    refers to hardware and software) is capable of running the runtime orchestration
    tool of choice, IoT Greengrass. This pattern of using tools to prove compatibility
    is a best practice over manually evaluating the target platform and/or assuming
    that a certain combination of listed requirements is met. For example, a potential
    device platform might advertise that its hardware requirements and operating system
    meet your needs, but it could be missing a critical library dependency that doesn't
    surface until later in the development life cycle. It is best to prove early that
    everything you need is present and accounted for.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在您作为Home Base Solutions的物联网架构师的角色下，您应使用IDT来证明您的目标边缘设备平台（在这种情况下，平台指的是硬件和软件）能够运行所选的运行时编排工具，即物联网Greengrass。使用工具来证明兼容性的这种模式是手动评估目标平台和/或假设满足列出的某些要求组合的最佳实践。例如，一个潜在的设备平台可能会宣传其硬件要求和操作系统符合您的需求，但它可能缺少一个在开发生命周期后期才显现的关键库依赖项。最好尽早证明您需要的所有东西都已存在并得到考虑。
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: IDT does more than qualify hardware for running IoT Greengrass core software.
    The tool can also qualify hardware running FreeRTOS to validate that the device
    is capable of interoperating with AWS IoT Core. Developers can write their own
    custom tests and bundle them into suites to incorporate into your **software development
    life cycle** (**SDLC**).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: IDT不仅能够使硬件具备运行物联网Greengrass核心软件的资格。该工具还可以使运行FreeRTOS的硬件具备资格，以验证设备能够与AWS IoT
    Core进行互操作。开发者可以编写自己的自定义测试，并将它们捆绑成套件，以纳入您的**软件开发生命周期**（**SDLC**）。
- en: The following steps will enable you to prepare your Raspberry Pi device for
    use as the edge system (that is, the Home Base Solutions hub device in our fictional
    project) and configure your AWS account before finally running the IDT software.
    Optionally, you can skip the *Booting the Raspberry Pi* and *Configuring the AWS
    account and permissions* sections if you already have a device and AWS account
    configured for use. If you are using a different platform for your edge device,
    you just need to ensure you can reach the device over SSH with a system user that
    has root permissions from your command-and-control device.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您准备您的Raspberry Pi设备作为边缘系统（即，在我们虚构项目中的Home Base Solutions中心设备）使用，并在最终运行IDT软件之前配置您的AWS账户。如果您的设备已经配置了AWS账户并准备使用，您可以选择跳过*启动Raspberry
    Pi*和*配置AWS账户和权限*部分。如果您正在使用不同的平台作为边缘设备，您只需确保您可以通过SSH从您的指挥控制设备访问设备，并且有一个具有root权限的系统用户。
- en: Booting the Raspberry Pi
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动Raspberry Pi
- en: 'The following steps were run on a Raspberry Pi 3B with a clean installation
    of the May 2021 release of the Raspberry Pi OS. Please refer to [https://www.raspberrypi.org/software/](https://www.raspberrypi.org/software/)
    for the **Raspberry Pi Imager** tool. Use your command-and-control system to run
    the imaging tool to flash a Micro SD card with a fresh image of the Raspberry
    Pi OS. For this book''s project, we recommended that you use a blank slate to
    avoid any unforeseen consequences of preexisting software and configuration changes.
    Here is a screenshot of the Raspberry Pi Imager tool and the image to select:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是在带有Raspberry Pi OS 2021年5月版干净安装的Raspberry Pi 3B上运行的。请参阅[https://www.raspberrypi.org/software/](https://www.raspberrypi.org/software/)以获取**Raspberry
    Pi Imager**工具。使用您的指挥控制系统运行映像工具，用Raspberry Pi OS的新映像闪存Micro SD卡。对于本书的项目，我们建议您使用一张空白磁盘，以避免任何预存软件和配置更改的意外后果。以下是Raspberry
    Pi Imager工具和要选择的映像的截图：
- en: '![Figure 2.6 – The Raspberry Pi Imager tool and the image to select'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – Raspberry Pi Imager工具和要选择的映像'
- en: '](img/B17595_02_006.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17595_02_006.jpg)'
- en: Figure 2.6 – The Raspberry Pi Imager tool and the image to select
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – Raspberry Pi Imager工具和要选择的映像
- en: 'The following is a list of steps to perform after flashing the Micro SD card
    with the Imager tool:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用Imager工具对Micro SD卡进行闪存操作后需要执行的步骤列表：
- en: Insert the Micro SD card into the Raspberry Pi.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Micro SD卡插入Raspberry Pi。
- en: Turn on the Raspberry Pi by plugging in the power source.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过插入电源插头启动Raspberry Pi。
- en: Complete the first-time boot wizard. Update the default password, set your locale
    preferences, and connect to Wi-Fi (this is optional if you are using Ethernet).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成首次启动向导。更新默认密码，设置您的区域首选项，并连接到Wi-Fi（如果您使用的是以太网，则此步骤为可选）。
- en: Open the Terminal app and run `sudo apt-get update` and `sudo apt-get upgrade`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot the Pi.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal app and run the `hostname` command. Copy the value and make
    a note of it; for example, write it in a scratch file on your command-and-control
    system. On Raspberry Pi devices, the default is `raspberrypi`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Raspberry Pi preferences app and enable the SSH interface. This must
    be enabled for the IDT to access the device. Open **Preferences**, choose **Raspberry
    Pi Configuration**, choose **Interfaces**, and enable SSH.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this milestone, your Raspberry Pi device is configured to join the same local
    network of your command-and-control system and can be accessed via a remote shell
    session. If you are using a different device or a virtual machine as your edge
    device for the hands-on project, you should be able to access that device via
    SSH. A good test to check whether this is working properly is to try connecting
    to your edge device from your command-and-control system using a Terminal application
    (or `ssh pi@raspberrypi`. Replace `raspberrypi` if you have a different hostname
    from *step 6*. Next, you will configure your AWS account in order to run IDT on
    your edge device.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AWS account and permissions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complete all of the steps in this section on your command-and-control system.
    For readers who don''t yet have an AWS account (skip to *step 5* if you already
    have access to an account), perform the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Create your AWS account. Navigate to [https://portal.aws.amazon.com/billing/signup](https://portal.aws.amazon.com/billing/signup)
    in your web browser and complete the prompts. You will require an email address,
    phone number, and credit card.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console using your root login and navigate to
    the **Identity and Access Management** (**IAM**) service. You can find this at
    [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the IAM service console to set up your administrative group and user account.
    It is a best practice to create a new user for yourself instead of continuing
    to use the root user login. You will use that new user to complete any later AWS
    steps using the AWS management console or AWS CLI:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new user called `AdministratorAccess` (it is easier to use the filter
    field and type that in). This policy is managed by AWS to grant administrator-level
    permissions to users. The best practice is to relate permissions to groups and
    then assign users to groups to inherit permissions. This makes it easier to audit
    permissions and understand the kinds of access that users have from well-named
    groups.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Log out of the AWS management console.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, you should have access to an AWS account with an administrative
    user. Complete the following steps to set up the AWS CLI (please skip to *step
    7* if you already have the AWS CLI configured with your admin user).
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install the AWS CLI. Platform-specific instructions can be found at [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/).
    In this book, the AWS CLI steps will use AWS CLI v2.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, configure the AWS CLI and use the credentials you downloaded
    for the `aws configure`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted for `json`, `yaml`, `text`, `table`]. The author's preference
    is `json` and will be reflected in any examples of AWS CLI output that appear
    in the book.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will use your `Admin` user to create a few more resources in preparation
    for the following sections to use the IDT and install the IoT Greengrass core
    software. These are permissions resources, similar to your `Admin` user, which
    will be used by IDT and IoT Greengrass software to interact with AWS on your behalf.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to the AWS management console using your custom sign-in link from *step
    3A*. Use the `Admin` username and password provided in the CSV file containing
    credentials.*   Return to the IAM service console, which can be found at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/).*   Create
    a new user named `idtgg` (short for *IDT and Greengrass*) and select the **Programmatic
    access** type. This user will not require a password for management console access.
    Skip the permissions and tags sections. Make sure that you download the CSV file
    containing the credentials for this user as well.*   Create a new policy. The
    first step is to define the permissions for the policy. Choose the `chapter2/policies/idtgg-policy.json`.
    Skip the tags section. In the review section, enter the name of `idt-gg-permissions`,
    enter the description of **permissions for IoT Device Tester and IoT Greengrass**,
    and choose **Create policy**.*   Create a new user group with the name of `idt-gg-permissions`
    policy, and select the `idtgg` user. Choose **Create group**. You have now set
    up a new group, attached permissions, and assigned the programmatic access user
    that will serve as authentication and authorization for the IDT client and IoT
    Greengrass provisioning tool.*   In your Terminal or PowerShell application, configure
    a new AWS CLI profile for this new user:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `aws configure --profile idtgg`.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted for access keys and secret keys, use the new values from the credentials
    CSV file downloaded in *step 9*.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted for the default region, use the book's default of **us-west-2**
    or the AWS region you are using for all of the projects in this book.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: That concludes all of the preparatory steps to configure your AWS account, permissions,
    and CLI. The next milestone is to install the IDT client and prepare it to test
    the Home Base Solutions prototype hub device.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Configuring IDT
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will run the IDT software from your command-and-control system, and the
    IDT will access the edge device system remotely through SSH to run the tests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The following steps reflect the configuration and use of IDT at the time of
    writing. If you get stuck, it might be that the latest version differs from the
    version that we used at the time of writing. You can check the AWS documentation
    for IDT for the latest guidance on installation, configuration, and use. Please
    refer to [https://docs.aws.amazon.com/greengrass/v2/developerguide/device-tester-for-greengrass-ug.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/device-tester-for-greengrass-ug.html).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to use IDT to verify the edge device system is ready to
    run IoT Greengrass. All of the following steps are completed on macOS using IoT
    Greengrass core software v2.4.0 and IDT v4.2.0 with test suite GGV2Q_2.0.1\. For
    Windows, Linux, or later AWS software versions, please alter the commands and
    directories as needed:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: On your command-and-control system, open a web browser and navigate to [https://docs.aws.amazon.com/greengrass/v2/developerguide/dev-test-versions.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/dev-test-versions.html).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `C:\projects\idt` on Windows or `~/projects/idt` on macOS and Linux:![Figure
    2.7 – The AWS documentation website for downloading IDT; exact text and versions
    might differ
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17595_02_007.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.7 – The AWS documentation website for downloading IDT; exact text and
    versions might differ
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unzip the archive contents in place in the directory. In a file explorer, double-click
    on the archive to extract them. If using Terminal, use a command such as `unzip
    devicetester_greengrass_v2_4.0.2_testsuite_1.1.0_mac.zip`. This is what the directory
    looks like on macOS:![Figure 2.8 – macOS Finder showing the directory contents
    after unzipping the IDT archive
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17595_02_008.jpg)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.8 – macOS Finder showing the directory contents after unzipping the
    IDT archive
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a new tab in your browser and paste the following link to prompt a download
    of the latest IoT Greengrass core software: [https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-2.4.0.zip](https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-2.4.0.zip)
    (if this link doesn''t work, you can find the latest guidance at [https://docs.aws.amazon.com/greengrass/v2/developerguide/quick-installation.html#download-greengrass-core-v2](https://docs.aws.amazon.com/greengrass/v2/developerguide/quick-installation.html#download-greengrass-core-v2)).'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the downloaded file as `aws.greengrass.nucleus.zip` and move it to an
    IDT directory such as `~/projects/idt/devicetester_greengrass_v2_mac/products/aws.greengrass.nucleus.zip`:![Figure
    2.9 – The IoT Greengrass software in place to be used by IDT
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17595_02_009.jpg)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.9 – The IoT Greengrass software in place to be used by IDT
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a text file such as `~/projects/idt/devicetester_greengrass_v2_mac/configs/config.json`
    and update the following values:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Optionally) update `awsRegion` if you are not using the book's default of `us-west-2`.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the `idtgg` profile that you configured earlier, set the value of `auth`
    as follows:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open a text file such as `~/projects/idt/devicetester_greengrass_v2_mac/configs/device.json`
    and update the following values:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"id": "pool1"`.'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"sku": "hbshub"` (`hbshub` stands for Home Base Solutions hub).'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath `"features"`, for the name-value pair named `"arch"`, set `"value":
    "armv7l"` (this is for Raspberry Pi devices; alternatively, you can choose the
    appropriate architecture for your device).'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath `"features"`, for the remaining name-value pairs such as `"ml"`,
    `"docker"`, and `"streamManagement"`, set `"value": "no"`. For now, we will disable
    these tests because we have no immediate plans to use the tested features. Feel
    free to enable them if you''d like to evaluate your device''s compatibility, although
    expect the tests to fail on a freshly imaged Raspberry Pi.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath `"devices"`, set `"id": "raspberrypi"` (or any device ID you prefer).'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `"connectivity"`, set the value of `"ip"` to the IP address of your
    edge device (for Raspberry Pi users, the value is the output of *step 6* from
    the *Booting the Raspberry Pi* section).
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath `"auth"`, set `"method": "password"`.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `"credentials"`, set the value of `"user"` to the username used to
    SSH to the edge device (typically, this will be `"pi"` for Raspberry Pi users).
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `"credentials"`, set the value of `"password"` to the password used
    to SSH to the edge device.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath `"credentials"`, delete the line for `"privKeyPath"`.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the changes to this file. You can view a sample version of this file in
    the book's GitHub repository at `chapter2/policies/idt-device-sample.json`.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a text file such as `~/projects/idt/devicetester_greengrass_v2_mac/configs/userdata.json`
    and update the following values. Ensure that you specify absolute paths instead
    of relative paths:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"TempResourcesDirOnDevice": "/tmp/idt"`.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"InstallationDirRootOnDevice": "/greengrass"`.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"GreengrassNucleusZip": "Users/ryan/projects/idt/devicetester_greengrass_v2_mac/products/aws.greengrass.nucleus.zip"`
    (update this based on where you stored the `aws.greengrass.nucleus.zip` file in
    *step 5* of this section).'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the changes to this file. You can view a sample version of this file in
    the book's GitHub repository at `chapter2/policies/idt-userdata-sample.json`.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Open an application such as Terminal on macOS/Linux or PowerShell on Windows.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change your present working directory to where the IDT launcher is located:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~/projects/idt/devicetester_greengrass_v2_mac/bin` on macOS'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~/projects/idt/devicetester_greengrass_v2_linux/bin` on Linux'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`C:\projects\idt\devicetester_greengrass_v2_win\bin` on Windows'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the command to start IDT:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./devicetester_mac_x86-64 run-suite --userdata userdata.json` on macOS'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./devicetester_linux_x86-64 run-suite --userdata userdata.json` on Linux'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`devicetester_win_x86-64.exe run-suite --userdata userdata.json` on Windows'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running IDT will start a local application that connects to your edge device
    over SSH and completes the series of tests. It will stop upon encountering the
    first failed test case or run until all test cases have passed. If you are running
    IDT against a fresh installation of your Raspberry Pi, as defined by previous
    steps, you should observe an output similar to the following:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行IDT将启动一个本地应用程序，通过SSH连接到您的边缘设备并完成一系列测试。它将在遇到第一个失败的测试案例时停止，或者一直运行直到所有测试案例都通过。如果您正在按照前面的步骤运行IDT针对新的Raspberry
    Pi安装，您应该观察到以下类似的输出：
- en: '[PRE1]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The step to install Java on the Raspberry Pi was intentionally left out in order
    to demonstrate how IDT identifies missing dependencies; apologies for the deception!
    If you ran the IDT test suite and passed all of the test cases, then you are ahead
    of schedule and can skip to the *Installing IoT Greengrass* section.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 故意省略了在Raspberry Pi上安装Java的步骤，以演示IDT如何识别缺失的依赖项；对于这种欺骗表示歉意！如果您运行了IDT测试套件并且通过了所有测试案例，那么您已经提前完成了计划，可以跳转到*安装IoT
    Greengrass*部分。
- en: To fix this missing dependency, return to your Raspberry Pi interface and open
    the Terminal app.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复这个缺失的依赖项，请返回您的Raspberry Pi界面并打开终端应用程序。
- en: Install Java on the Pi using `sudo apt-get install default-jdk`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sudo apt-get install default-jdk`在Pi上安装Java。
- en: Return to your command-and-control system and run IDT again (repeat the command
    in *step 11*).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回您的命令和控制系统，并再次运行IDT（重复*步骤11*中的命令）。
- en: 'Your test suite should now pass the Java requirement test. If you encounter
    other failures, you will need to use the test report and logs in the `idt/devicetester_greengrass_v2_mac/results`
    folder to triage and fix them. Some common missteps include missing AWS credentials,
    AWS credentials without sufficient permissions, and incorrect paths to resources
    defined in `userdata.json`. A fully passed suite of test cases looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试套件现在应该通过Java要求测试。如果您遇到其他失败，您将需要使用`idt/devicetester_greengrass_v2_mac/results`文件夹中的测试报告和日志来分类和修复它们。一些常见的错误包括缺少AWS凭证、权限不足的AWS凭证以及指向`userdata.json`中定义的资源的不正确路径。一个完全通过的测试案例集看起来像这样：
- en: '[PRE2]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This concludes the introductory use of IDT to analyze and assist in preparing
    your devices to use IoT Greengrass. Here, the best practice is to use software
    tests, not just for your own code but to assess whether the edge device itself
    is ready to work with your solution. Lean on tools such as IDT that do the heavy
    lifting of proving that the device is ready to use and validate this for each
    new type of device enrolled or major solution version released. You should be
    able to configure IDT for your next project and qualify a new device or group
    of devices to run IoT Greengrass. In the next section, you will learn how to install
    IoT Greengrass on your device in order to configure your first edge component.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了使用IDT分析并协助准备设备使用IoT Greengrass的入门介绍。在这里，最佳实践是使用软件测试，不仅是为了您自己的代码，还要评估边缘设备本身是否准备好与您的解决方案一起工作。依靠像IDT这样的工具，这些工具承担着证明设备准备好使用的繁重工作，并为每种新注册的设备或主要解决方案版本发布进行验证。您应该能够为您的下一个项目配置IDT，并使新的设备或设备组能够运行IoT
    Greengrass。在下一节中，您将学习如何在您的设备上安装IoT Greengrass，以便配置您的第一个边缘组件。
- en: Installing IoT Greengrass
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装IoT Greengrass
- en: Now that you have used IDT to validate that your edge device is compatible with
    IoT Greengrass, the next milestone in this chapter is to install IoT Greengrass.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用IDT验证了您的边缘设备与IoT Greengrass兼容，本章的下一个里程碑是安装IoT Greengrass。
- en: 'From your edge device (that is, the prototype Home Base Solutions hub), open
    the Terminal app, or use your command-and-control device to remotely access it
    using SSH:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的边缘设备（即原型Home Base Solutions中心），打开终端应用程序，或者使用您的命令和控制设备通过SSH远程访问它：
- en: 'Change the directory to your user''s home directory: `cd ~/`.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到您的用户主目录：`cd ~/`。
- en: 'Download the IoT Greengrass core software: `curl -s` [https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-nucleus-latest.zip](https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-nucleus-latest.zip)
    > greengrass-nucleus-latest.zip.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载IoT Greengrass核心软件：`curl -s` [https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-nucleus-latest.zip](https://d2s8p88vqu9w66.cloudfront.net/releases/greengrass-nucleus-latest.zip)
    > greengrass-nucleus-latest.zip。
- en: 'Unzip the archive: `unzip greengrass-nucleus-latest.zip -d greengrass && rm
    greengrass-nucleus-latest.zip`.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压存档：`unzip greengrass-nucleus-latest.zip -d greengrass && rm greengrass-nucleus-latest.zip`。
- en: 'Your edge device requires AWS credentials in order to provision cloud resources
    on your behalf. You can use the same credentials that you created for the `idtgg`
    user in the previous *Configuring the AWS account and permissions* section:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的边缘设备需要AWS凭证以便代表您配置云资源。您可以使用在上一节*配置AWS账户和权限*中为`idtgg`用户创建的相同凭证：
- en: '`export AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`export AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE`'
- en: '`export AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`export AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY`'
- en: 'Install the IoT Greengrass core software using the following command. If you
    are using an AWS region other than `us-west-2`, update the value of the `--aws-region`
    argument. You can copy and paste this command from `chapter2/commands/provision-greengrass.sh`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装物联网Greengrass核心软件。如果您使用的是除`us-west-2`以外的AWS区域，请更新`--aws-region`参数的值。您可以从`chapter2/commands/provision-greengrass.sh`复制并粘贴此命令：
- en: '[PRE3]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s it! The last few lines of output from this provisioning command should
    look like this:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！此配置命令的最后几行输出应该看起来像这样：
- en: '[PRE4]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The installation of the IoT Greengrass core software and the provisioning of
    the initial resources is much smoother after validating compatibility with the
    IDT suite. Now your edge device has the first fundamental tool installed: the
    runtime orchestrator. Let''s review the resources that have been created at the
    edge and in AWS from this provisioning step.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在与IDT套件验证兼容性后，物联网Greengrass核心软件的安装和初始资源的配置过程会更加顺畅。现在您的边缘设备已经安装了第一个基本工具：运行时编排器。让我们回顾一下在此配置步骤中在边缘和AWS上创建的资源。
- en: Reviewing what has been created so far
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看到目前为止已创建的内容
- en: On your edge device, the IoT Greengrass software was installed in the `/greengrass/v2`
    file path. In that directory, the public and private keypairs are generated for
    connecting to AWS, service logs, a local repository of packages for recipes and
    artifacts, and a directory for past and present deployments pushed to this device.
    Feel free to explore the directory at `/greengrass/v2` to get familiar with what
    is stored on the device; though, you will need to escalate permissions using `sudo`
    to browse everything.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的边缘设备上，物联网Greengrass软件安装在了`/greengrass/v2`文件路径下。在该目录中，生成了用于连接AWS的公钥和私钥对、服务日志、用于存储食谱和工件本地包的本地存储库，以及用于推送到此设备的过去和现在部署的目录。您可以自由探索`/greengrass/v2`目录以熟悉设备上存储的内容；尽管如此，您需要使用`sudo`提升权限才能浏览所有内容。
- en: The installation added the first `aws.greengrass.Nucleus`. The nucleus component
    is the foundation of IoT Greengrass; it is the only mandatory component, and it
    facilitates key functionality such as deployments, orchestration, and life cycle
    management for all other components. Without the nucleus component, there is no
    IoT Greengrass.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 安装添加了第一个`aws.greengrass.Nucleus`。核组件是物联网Greengrass的基础；它是唯一必需的组件，它促进了所有其他组件的关键功能，如部署、编排和生命周期管理。没有核组件，就没有物联网Greengrass。
- en: Additionally, the installation created the first `--deploy-dev-tools true` argument.
    That deployment installed a component named `aws.greengrass.Cli`. This second
    component includes a script, called `greengrass-cli`, that is used for local development
    tasks such as reviewing deployments, components, and logs. It can also be used
    to create new components and deployments. Remember, with IoT Greengrass, you can
    work locally on the device or push deployments remotely to it through AWS. Remote
    deployments are introduced in [*Chapter 4*](B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073),
    *Extending the Cloud to the Edge*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，安装还创建了第一个`--deploy-dev-tools true`参数。该部署安装了一个名为`aws.greengrass.Cli`的组件。第二个组件包括一个名为`greengrass-cli`的脚本，用于本地开发任务，例如审查部署、组件和日志。它还可以用于创建新组件和部署。记住，使用物联网Greengrass，您可以在设备本地工作，或者通过AWS将其远程部署到设备。远程部署在[*第4章*](B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073)中介绍，*将云扩展到边缘*。
- en: In AWS, a few different resources were created. First, a new `hbshub001` from
    the IoT Greengrass provisioning argument, `--thing-name`. Similarly, a new `hbshubprototypes`,
    from the `--thing-group-name` provisioning argument. A thing group contains zero
    or more things and thing groups. The design of IoT Greengrass uses thing groups
    to identify sets of edge devices that should have the same deployments running
    on them. For example, if you provisioned another hub prototype device, you would
    add it to the same `hbshubprototypes` thing group such that the new prototype
    deployments would travel to all of your prototype devices.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, your `hbshub001` thing has an entity attached to it called a `/greengrass/v2`
    directory and is used to establish mutually authenticated connections to AWS.
    The certificate is how AWS recognizes the device when it connects with its private
    key (the certificate is attached to the `hbshub001` thing record) and knows how
    to look up permissions for the device. Those permissions are defined in another
    resource called the **IoT policy**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'An IoT policy is similar to an AWS IAM policy in that it defines explicit permissions
    for what an actor is allowed to do when interacting with AWS. In the case of an
    IoT policy, the actor is the device and permissions are for actions such as opening
    a connection, publishing and receiving messages, and accessing static resources
    defined in deployments. Devices get their permissions through their certificate,
    meaning a thing is attached to the certificate, and the certificate is attached
    to one or more policies. Here''s a sketch of how these basic resources are related
    in the edge and the cloud:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Illustrating the relationships between the IoT Core thing registry
    and edge resources'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_010.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Illustrating the relationships between the IoT Core thing registry
    and edge resources
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'In the cloud service of IoT Greengrass, a few more resources were defined for
    the initial provisioning of your device and its first deployment. An IoT Greengrass
    **core** is a mapping of a device (which is also known as a thing), the components
    and deployments running on the device, and the associated thing group the device
    is in. Additionally, a core stores metadata such as the version of IoT Greengrass
    core software installed and the status of the last known health check. Here is
    an alternate view of the relationship graph with IoT Greengrass resources included:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Illustrating the relationships between IoT Core, IoT Greengrass,
    and the edge device'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17595_02_011.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Illustrating the relationships between IoT Core, IoT Greengrass,
    and the edge device
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have installed IoT Greengrass and have an understanding of the
    resources created on provisioning, let's review what a component looks like when
    deployed to inform your implementation of the *Hello, world* component.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first edge component
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic milestone of any developer education is the *Hello, world* example.
    For your first edge component deployed to IoT Greengrass, you will create a simple
    *Hello, world* application in order to reinforce concepts such as component definition,
    a dependency graph, and how to create a new deployment.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing an existing component
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you get started with drafting a new component, take a moment to familiarize
    yourself with the existing components that have already been deployed by using
    the IoT Greengrass CLI. This CLI was installed by the `--deploy-dev-tools true`
    argument that was passed in during the installation. This tool is designed to
    help you with a local development loop; however, as a best practice, it is not
    installed in production solutions. It is installed at `/greengrass/v2/bin/greengrass-cli`.
    The following steps demonstrate how to use this tool:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Try invoking the `help` command. In the Terminal app of your edge device, run
    `/greengrass/v2/bin/greengrass-cli help`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should view the output of the `help` command, including references to the
    `component`, `deployment`, and `logs` commands. Try invoking the `help` command
    on the `component` command: `/greengrass/v2/bin/greengrass-cli help component`.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should view instructions regarding how to use the `component` command.
    Next, try invoking the `component list` command to show all of the locally installed
    components, `/greengrass/v2/bin/greengrass-cli component list`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`sudo /greengrass/v2/bin/greengrass-cli component list`'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You don''t need to run the following *A* and *B* commands. They are included
    here to show you how to find the file contents later on:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To find the recipe file, use `sudo ls /greengrass/v2/packages/recipes/`.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To inspect the file, use `sudo` `less /greengrass/v2/recipes/rQVjcR-rX_XGFHg0WYKAnptIez3HKwtctL_2BKKZegM@2.4.0.recipe.yaml`
    (note that your filename will be different):'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are a few important observations to review in this file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Component names use a reverse domain scheme that is similar to the `namespacing`
    Java package. Your custom components in this book's project will start with `com.hbs.hub`,
    signifying components written for the Home Base Solutions hub product.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This component is tied to specific versions of the IoT Greengrass nucleus, which
    is why the version is 2.4.0\. Your components can specify any version here, and
    the best practice is to follow the semantic versioning specification.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ComponentType` property is only used by AWS plugins such as this CLI. Your
    custom components will not define this property.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This component only works with a specific version of the nucleus, so it defines
    a soft dependency on the `aws.greengrass.nucleus` component. Your custom components
    do not need to specify a nucleus dependency by default. This is where you will
    define dependencies on other components, for example, a component that ensures
    Python3 is installed before loading a component with a Python application.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This component defines no specific life cycle activities, either at the global
    level or specific to the `linux` platform version of the manifest.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The artifacts defined are for specific IoT Greengrass service files. You can
    view these files on disk in the `/greengrass/v2/packages/artifacts` directory.
    Your artifact URIs will use the `s3://path/to/my/file` pattern when deploying
    them from the cloud. During local development, your manifest does not need to
    define artifacts, as they are expected to already be on disk.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the permissions on the two artifacts. The ZIP file can be read by any system
    user. In comparison, the JAR file can only be read by the `OWNER`, which in this
    scenario, means the default system user that was defined at installation, for
    example, the `ggc_user` user.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this review of the component structure, it's time to write your own component
    with an artifact and a recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first component
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the first component that we wish to create is a simple
    "Hello, world" application. In this component, you will create a shell script
    that prints `Hello, world` with the `echo` command. That shell script is an artifact
    for your component. Additionally, you will write a recipe file that tells IoT
    Greengrass how to use that shell script as a component. Finally, you will use
    the local IoT Greengrass CLI to deploy this component and check it works.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Local component development uses artifacts and recipe files available on the
    local disk, so you will need to create some folders for your working files. There
    is no folder in `/greengrass/v2` that is designed to store your working files.
    Therefore, you will create a simple folder tree and add your component files there:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Terminal app of your edge device, change the directory to your user''s
    home directory: `cd ~/`.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new folder to hold your local component resources: `mkdir -p hbshub/{artifacts,recipes}`.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create the path for a new artifact and add a shell script to its folder.
    Let''s choose the component name of `com.hbs.hub.HelloWorld` and start the version
    at 1.0.0\. Change the directory to the artifacts folder: `cd hbshub/artifacts`.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make a new directory for your component''s artifacts: `mkdir -p com.hbs.hub.HelloWorld/1.0.0`.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file for the shell script: `touch com.hbs.hub.HelloWorld/1.0.0/hello.sh`.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give this file write permissions: `chmod +x com.hbs.hub.HelloWorld/1.0.0/hello.sh`.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file in an editor: `nano com.hbs.hub.HelloWorld/1.0.0/hello.sh`.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this editor, add the following content (this is also available in this
    chapter''s GitHub repository):'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Test your script with and without an argument. The script will print `Hello,
    world` unless provided with an argument to substitute for `world`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./com.hbs.hub.HelloWorld/1.0.0/hello.sh`'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./com.hbs.hub.HelloWorld/1.0.0/hello.sh friend`'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s all you need for your component''s artifact. Next, you will learn how
    to take advantage of passing in arguments from inside the recipe file. Change
    the directory to the recipes directory: `cd ~/hbshub/recipes`.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the editor to create the recipe file: `nano com.hbs.hub.HelloWorld-1.0.0.json`.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following content to the file. You can also copy this file from the
    book''s GitHub repository:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This recipe is straightforward: it defines a life cycle step to run our `hello.sh`
    script that it will find in the deployed artifacts path. One new addition that
    has not yet been covered is the component configuration. The `ComponentConfiguration`
    object allows developers to define arbitrary key-value pairs that can be referenced
    in the rest of the recipe file. In this scenario, we define a default value to
    pass as an argument to the script. This value can be overridden when deploying
    a component to customize how each edge device uses the deployed component.'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, how do you test a component now that you've written the recipe and provided
    the artifacts? The next step is to create a new deployment that tells the local
    IoT Greengrass environment to load your new component and start evaluating life
    cycle events for it. This is where the IoT Greengrass CLI can help.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following command to create a new deployment that includes your new
    component:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should view a response similar to the following:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can verify that the component was successfully deployed (and has already
    finished running) with `sudo /greengrass/v2/bin/greengrass-cli component list`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can view the output of this component in its log file: `sudo less /greengrass/v2/logs/com.hbs.hub.HelloWorld.log`
    (remember, the `/greengrass/v2 directory` is owned by root, so the log files must
    also be accessed with `sudo`):'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Congratulations! You have written and deployed your first component to your
    Home Base Solutions prototype hub using IoT Greengrass. In the log output, you
    can observe two noteworthy observations. First, you can view the chronology of
    the component's life cycle change state from `STARTING` to `RUNNING` before reporting
    a successful exit code back to IoT Greengrass. The component concludes at that
    point, so we don't view an entry in the log that shows it move to the `FINISHED`
    state, although that is visible in the `greengrass.log` file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Second, you can view the message written to `STDOUT` with an exclamation point
    included (`world!`). This means that the script received your component's default
    configuration instead of falling back on the default built into `hello.sh` (`world`).
    You could also override the default configuration value of "world!" in the recipe
    file with a custom value included in the deployment command. You'll learn how
    to use that technique to configure fleets in [*Chapter 4*](B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073)*,
    Extending the Cloud to the Edge*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics regarding a specific tool we will use
    throughout this book that satisfies one of the key needs of any edge ML solution,
    that is, the runtime orchestrator. IoT Greengrass provides out-of-the-box features
    to focus developers on their business solutions instead of the undifferentiated
    work to architect a flexible, resilient edge runtime and deployment mechanism.
    You learned that the fundamental unit of software in IoT Greengrass is the component,
    which is made up of a recipe and a set of artifacts, and components make their
    way to the solution via deployments. You learned how to validate that a device
    is ready to work with IoT Greengrass using the IDT. You learned how to install
    IoT Greengrass, develop your first component, and get it running in the local
    environment.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deeper dive into how IoT Greengrass works
    by exploring how it enables gateway functionality, common protocols used at the
    edge, security best practices, and builds out new components used to sense and
    actuate in a cyber-physical solution.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge check
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving on to the next chapter, test your knowledge by answering these
    questions. The answers can be found at the end of the book:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is the best practice for how to organize code in edge
    ML solutions? A monolithic application or isolated services?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of decoupling services in your edge architecture?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of isolating your code and dependencies from other services?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one trade-off to consider when choosing between wired and wireless networking
    implementations in IoT solutions?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an example of a smart home device that uses both a sensor and an actuator?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two kinds of resources that define an IoT Greengrass component?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: A component must define at least one artifact in its recipe.'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it a good design principle that, by default, only the root system user
    can interact with files in the IoT Greengrass directory?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Components can be deployed to IoT Greengrass devices either
    locally or remotely.'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you think of three different methods that you could use to update the behavior
    of your `Hello, world` component to print `Hello, Home Base Solutions customer!`?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following resources for additional information on the concepts
    discussed in this chapter:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The semantic versioning specification at [https://semver.org](https://semver.org).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Service-Oriented Architecture: Analysis and Design for Services and Microservices*
    by Erl Thomas, Pearson, 2016.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Foundations of Analog and Digital Electric Circuits* by Anant Agarwal, Jeffrey
    H. Lang, and Morgan Kaufmann, 2005.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
