- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Beyond Code Debugging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码调试之外
- en: '**Artificial intelligence** (**AI**), like human intelligence, is a capability
    and tool that can be used for decision-making and task accomplishment. As humans,
    we use our intelligence in making our daily decisions and thinking about the challenges
    and problems we deal with. We use our brains and central nervous systems to receive
    information from our surroundings and process them for decision-making and reactions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**），像人类智能一样，是一种可用于决策和任务完成的特性和工具。作为人类，我们在做出日常决策、思考我们面临的挑战和问题时使用我们的智能。我们使用我们的大脑和神经系统从周围环境中接收信息，并处理它们以进行决策和反应。'
- en: Machine learning models are the AI techniques that are used nowadays to tackle
    problems across healthcare and finance. Machine learning models have been used
    in robotic systems in manufacturing facilities to package products or identify
    products that might have been damaged. They have been used in our smartphones
    to identify our faces for security purposes, by e-commerce companies to suggest
    the most suited products or movies to us, and even for improving healthcare and
    drug development to bring new more effective drugs onto the market for severe
    diseases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型是当今用于解决医疗保健和金融等领域问题的AI技术。机器学习模型已在制造设施中的机器人系统中用于包装产品或识别可能损坏的产品。它们被用于我们的智能手机中，用于安全目的识别我们的面部，电子商务公司为我们推荐最合适的产品或电影，甚至用于改善医疗保健和药物开发，将新的更有效的药物推向市场以治疗严重疾病。
- en: In this chapter, we will provide a quick review of different types of machine
    learning modeling. You will learn about different techniques and challenges in
    debugging your machine learning code. We will also discuss why debugging machine
    learning modeling goes far beyond just code debugging.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速回顾不同类型的机器学习建模。您将了解调试机器学习代码的不同技术和挑战。我们还将讨论为什么调试机器学习建模远不止代码调试。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Machine learning at a glance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习速览
- en: Types of machine learning modeling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习建模的类型
- en: Debugging in software development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发中的调试
- en: Flaws in data used for modeling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于建模的数据缺陷
- en: Model and prediction-centric debugging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以模型和预测为中心的调试
- en: This chapter is an introduction to this book to prepare you for more advanced
    concepts that will be presented later. This will help you improve your models
    and move toward becoming an expert in the machine learning era.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是本书的介绍，旨在为您准备后续将介绍的更高级概念。这将帮助您提高模型，并朝着成为机器学习时代的专家迈进。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Debugging-Machine-Learning-Models-with-Python/tree/main/Chapter01](https://github.com/PacktPublishing/Debugging-Machine-Learning-Models-with-Python/tree/main/Chapter01).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Debugging-Machine-Learning-Models-with-Python/tree/main/Chapter01](https://github.com/PacktPublishing/Debugging-Machine-Learning-Models-with-Python/tree/main/Chapter01)。
- en: Machine learning at a glance
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习速览
- en: 'You need three fundamental elements to build a machine learning model: an algorithm,
    data, and computing power (*Figure 1**.1*). A machine learning algorithm needs
    to be fed with the right data and trained using the necessary computing power.
    It can then be used to predict what it has been trained on for unseen data:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 构建机器学习模型需要三个基本要素：算法、数据和计算能力（**图1.1**）。机器学习算法需要用正确的数据喂养，并使用必要的计算能力进行训练。然后，它可以用于预测它所训练的未见数据：
- en: '![Figure 1.1 – The three elements in the machine learning triangle](img/B16369_01_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 机器学习三角形的三个要素](img/B16369_01_01.jpg)'
- en: Figure 1.1 – The three elements in the machine learning triangle
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 机器学习三角形的三个要素
- en: Machine learning applications can be generally categorized as **automation**
    and **discovery**. In the automation category, the goal of the machine learning
    model and the software and hardware systems built around it is to do the tasks
    that are possible and usually easy but tedious, repetitive, boring, or dangerous
    for human beings. Some examples of this include recognizing damaged products in
    manufacturing lines or recognizing employees’ faces at entrances in high-security
    facilities. Sometimes, it is not possible to use human beings for some of these
    tasks, although the task would be easy. For example, for face recognition on your
    phone, if your phone was stolen, you would not be there to recognize that the
    person who is trying to log into your phone is not you and your phone should be
    able to do it by itself. But we cannot come up with a generalizable mathematical
    formulation for these tasks to tell the machine what to do in each situation.
    So, the machine learning model learns how to come up with its prediction, for
    example, in terms of recognizing faces, according to the identified patterns in
    the data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习应用可以大致分为**自动化**和**发现**。在自动化类别中，机器学习模型及其围绕其构建的软件和硬件系统的目标是执行人类可能且通常容易但繁琐、重复、无聊或危险的任务。这方面的例子包括在制造线中识别损坏的产品或在高度安全设施入口处识别员工的面孔。有时，尽管这些任务可能很容易，但无法使用人类来完成。例如，对于手机上的面部识别，如果你的手机被盗，你就无法在那里识别试图登录你手机的人不是你，而你的手机应该能够自动完成这项任务。但是，我们无法为这些任务提出一个通用的数学公式，告诉机器在每个情况下应该做什么。因此，机器学习模型学习如何根据数据中识别出的模式来提出其预测，例如，在识别面部方面。
- en: On the other hand, in the discovery category of machine learning modeling, we
    want the models to provide information and insight about unknowns that are either
    not easy or fully discovered, or even impossible, for human experts or non-experts
    to extract. For example, discovering new drugs for cancer patients is not a task
    where you can learn all aspects of it by going through a couple of courses and
    books. In such cases, machine learning can help us come up with new insights to
    help discover new drugs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在机器学习建模的发现类别中，我们希望模型能够提供关于未知信息的信息和洞察，这些信息对于人类专家或非专家来说可能不容易或完全未被发现，甚至是不可能提取的。例如，为癌症患者发现新药并不是一个可以通过参加几门课程和阅读几本书就能全面了解其所有方面的任务。在这种情况下，机器学习可以帮助我们提出新的见解，以帮助发现新药。
- en: For both discovery and automation, different types of machine learning modeling
    can help us achieve our goals. We will explore this in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发现和自动化，不同类型的机器学习建模可以帮助我们实现目标。我们将在下一节中探讨这一点。
- en: Types of machine learning modeling
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习建模类型
- en: 'Machine learning contains multiple modeling types that may rely on output data,
    a variable type of model output, and learning from prerecorded data or experience.
    Although the examples in this book focus on supervised learning, we will review
    other types of modeling, including unsupervised learning, self-supervised learning,
    semi-supervised learning, **reinforcement learning** (**RL**), and generative
    machine learning to cover the six major categories of machine learning modeling
    (*Figure 1**.2*). We will also talk about techniques in machine learning modeling
    and provide code examples that are not parallel to these categories, such as active
    learning, transfer learning, ensemble learning, and deep learning:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习包含多种建模类型，这些类型可能依赖于输出数据、不同类型的模型输出，以及从预先录制的数据或经验中进行学习。尽管本书中的例子主要关注监督学习，但我们将回顾其他类型的建模，包括无监督学习、自监督学习、半监督学习、**强化学习**（**RL**）和生成式机器学习，以涵盖机器学习建模的六大主要类别（*图1**.2*）。我们还将讨论机器学习建模的技术，并提供与这些类别不平行但相关的代码示例，例如主动学习、迁移学习、集成学习和深度学习：
- en: '![Figure 1.2 – Types of machine learning modeling](img/B16369_01_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 机器学习建模类型](img/B16369_01_02.jpg)'
- en: Figure 1.2 – Types of machine learning modeling
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 机器学习建模类型
- en: Self-supervised and semi-supervised learning are sometimes considered sub-categories
    of supervised learning. However, we will separate them here so that we can establish
    the differences between the usual supervised learning models you are familiar
    with and these two types of modeling.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自监督和半监督学习有时被认为是监督学习的子类别。然而，我们将在这里将它们分开，以便我们可以区分你熟悉的通常的监督学习模型和这两种建模类型。
- en: Supervised learning
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监督学习
- en: Supervised learning is about identifying the relationship between inputs/features
    and the output for each data point. But what do input and output mean?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 监督学习是关于识别每个数据点的输入/特征与输出之间的关系。但输入和输出是什么意思呢？
- en: Imagine that we want to build a machine learning model to predict whether a
    person is likely to get breast cancer or not. The output of the model could be
    1 for *getting breast cancer* and 0 for *not getting breast cancer* and the inputs
    could be the characteristics of the people, such as their age, weight, and whether
    they smoke or not. There could even be inputs that are measured using advanced
    technologies, such as the genetic information of each person. In this case, we
    want to use our machine learning model to predict which patient will get cancer
    in the future.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要构建一个机器学习模型来预测一个人是否可能患上乳腺癌。模型的输出可以是1表示*患上乳腺癌*，0表示*未患上乳腺癌*，输入可以是人的特征，如年龄、体重以及他们是否吸烟。甚至可能有使用先进技术测量的输入，例如每个人的遗传信息。在这种情况下，我们想要使用我们的机器学习模型来预测哪位病人在未来会患上癌症。
- en: You can also design a machine learning model to estimate the price of houses
    in a city. Here, your model could use characteristics of houses, such as the number
    of bedrooms and size of the house, the neighborhood, and access to schools, to
    estimate house prices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设计一个机器学习模型来估算一个城市的房价。在这里，你的模型可以使用房屋的特征，如卧室数量和房屋大小、社区以及学校可访问性，来估算房价。
- en: In both of these examples, we have models trying to identify patterns within
    input features, such as a high number of bedrooms but only one bathroom, and associate
    those with the output. Depending on the output variable type, your model can be
    categorized as a classification model, in which the output is categorical, such
    as *getting* or *not getting cancer*, or a regression model, in which the output
    is continuous, such as house prices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，我们都有模型试图在输入特征中识别模式，例如拥有很多卧室但只有一个浴室，并将这些与输出关联起来。根据输出变量的类型，你的模型可以被归类为分类模型，其中输出是分类的，例如*得到*或*未得到癌症*，或者回归模型，其中输出是连续的，例如房价。
- en: Unsupervised learning
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无监督学习
- en: The majority of our life, at least in childhood, has been spent using our five
    senses (eyesight, hearing, taste, touch, and smell) to collect information about
    our surroundings, food, and so on, without us trying to find supervised learning
    style relationships such as whether a banana is ripe or not based on its color
    and shape. Similarly, in unsupervised learning, we are not seeking to identify
    the relationship between the features (input) and the output. Instead, the goal
    is to identify relationships between data points, as in clustering, extract new
    features (that is, embeddings or representations), and, if needed, reduce the
    dimensionality (that is, the number of features) of our data without using any
    output for the data points.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分生活，至少在童年时期，都是通过使用我们的五种感官（视力、听力、味觉、触觉和嗅觉）来收集关于我们周围环境、食物等信息，而无需我们试图找到基于颜色和形状判断香蕉是否成熟的监督学习风格的关系。同样，在无监督学习中，我们不是寻求识别特征（输入）和输出之间的关系。相反，目标是识别数据点之间的关系，如在聚类中，提取新的特征（即嵌入或表示），如果需要，在不使用任何输出数据点的情况下减少数据的维度（即特征的数量）。
- en: Self-supervised learning
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自监督学习
- en: The third category of machine learning modeling is called self-supervised learning.
    In this category, the goal is to identify the relationship between inputs and
    outputs, but the difference with supervised learning is the source of outputs.
    For example, if the goal of the supervised machine learning model is to translate
    from English to French, the inputs come from English words and sentences and the
    outputs come from French words and sentences. However, we can have a self-supervised
    learning model within English sentences to try to predict the next word or a missing
    word in a sentence. For example, let’s say we aim to recognize that “talking”
    is a good candidate to fill the gap in “Jack is ____ with Julie.” Self-supervised
    learning models have been used in recent years across different fields to identify
    new features. This is commonly called representation learning. We will talk about
    some examples of self-supervised learning in [*Chapter 14*](B16369_14.xhtml#_idTextAnchor379),
    *Introduction to* *Recent Advancements in* *Machine Learning*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习建模的第三类被称为自监督学习。在这个类别中，目标是识别输入和输出之间的关系，但与监督学习的不同之处在于输出的来源。例如，如果监督机器学习模型的目的是将英语翻译成法语，那么输入来自英语单词和句子，输出来自法语单词和句子。然而，我们可以在英语句子内部有一个自监督学习模型，试图预测句子中的下一个单词或缺失的单词。例如，假设我们的目标是识别“talking”是填补“Jack
    is ____ with Julie.”空缺的好候选词。近年来，自监督学习模型被广泛应用于不同领域以识别新特征。这通常被称为表示学习。我们将在[*第14章*](B16369_14.xhtml#_idTextAnchor379)，“*机器学习最新进展导论*”中讨论一些自监督学习的例子。
- en: Semi-supervised learning
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 半监督学习
- en: Semi-supervised learning can help us benefit from supervised learning without
    throwing out the data points that don’t have output values. Sometimes, we have
    data points for which we don’t have the output values and only their feature values
    are available. In such cases, semi-supervised learning helps us use data points
    with or without output. One simple process to do so is to group data points that
    are similar to each other and use known outputs of the data points in each group
    to assign output for other data points of the same group that don’t have output
    value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 半监督学习可以帮助我们利用监督学习的好处，而不必丢弃那些没有输出值的数据点。有时，我们有一些数据点，我们没有输出值，只有它们的特征值可用。在这种情况下，半监督学习帮助我们使用带有或没有输出的数据点。一个简单的做法是将相似的数据点分组，并使用每个组中数据点的已知输出为同一组中其他没有输出值的数据点分配输出。
- en: Reinforcement learning
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强化学习
- en: In RL, a model is rewarded according to its experience in an environment (real
    or virtual). In other words, RL is about identifying relationships with piecewise
    example addition. In RL, data is not considered part of the model and is independent
    of the model itself. We will go through some details of RL in [*Chapter 14*](B16369_14.xhtml#_idTextAnchor379),
    *Introduction to* *Recent Advancements in* *Machine Learning*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在强化学习（RL）中，模型根据其在环境（真实或虚拟）中的经验获得奖励。换句话说，强化学习是关于通过分段示例添加识别关系。在强化学习中，数据不被视为模型的一部分，并且与模型本身独立。我们将在[*第14章*](B16369_14.xhtml#_idTextAnchor379)，“*机器学习最新进展导论*”中详细介绍强化学习的某些细节。
- en: Generative machine learning
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成式机器学习
- en: Generative machine learning modeling helps us develop models that can generate
    images, text, or any data point that is close to the probability distribution
    of data provided in the training process. ChatGPT is one of the most famous tools
    that’s built on top of a generative model to generate realistic and meaningful
    text in response to user questions and answers ([https://openai.com/blog/chatgpt](https://openai.com/blog/chatgpt)).
    We will go through more details about generative modeling and the available tools
    built on top of it in [*Chapter 14*](B16369_14.xhtml#_idTextAnchor379), *Introduction
    to* *Recent Advancements in* *Machine Learning*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 生成式机器学习建模帮助我们开发出能够生成图像、文本或任何接近训练过程中提供的数据概率分布的数据点的模型。ChatGPT 是基于生成模型构建的、用于生成对用户提问和回答的逼真且有意义的文本的最著名工具之一（[https://openai.com/blog/ChatGPT](https://openai.com/blog/ChatGPT)）。我们将在[*第14章*](B16369_14.xhtml#_idTextAnchor379)，“*机器学习最新进展导论*”中详细介绍生成式建模及其之上的可用工具。
- en: In this section, we provided a brief review of the basic components for building
    machine learning models and different types of modeling. But if you want to develop
    machine learning models for automation or discovery, for healthcare or any other
    application, with a low or high number of data points, on your laptop or the cloud,
    using a **central processing unit** (**CPU**) or **graphics processing unit**
    (**GPU**), you need to develop high-quality code that works as expected. Although
    this book is not a software debugging book, an overview of software debugging
    challenges and techniques could help you in developing your machine learning models.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要回顾了构建机器学习模型的基本组件和不同类型的建模。但如果你想要开发用于自动化或发现、医疗保健或任何其他应用的机器学习模型，无论数据点的数量是低还是高，无论是在你的笔记本电脑上还是在云端，使用
    **中央处理器**（**CPU**）或 **图形处理器**（**GPU**），你需要开发出按预期工作的优质代码。尽管这本书不是一本软件调试的书，但软件调试挑战和技术概述可能有助于你在开发机器学习模型时。
- en: Debugging in software development
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发中的调试
- en: 'If you want to use Python and its libraries to build machine learning and deep
    learning models, you need to make sure your code works as expected. Let’s consider
    the following examples of the same function for returning the multiplication of
    two variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 Python 及其库来构建机器学习与深度学习模型，你需要确保你的代码按预期工作。让我们考虑以下相同函数的例子，用于返回两个变量的乘积：
- en: 'Correct code:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的代码：
- en: '[PRE0]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code with a typo:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在拼写错误的代码：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code with an indentation issue:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在缩进问题的代码：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: def multiply(x, y):    z = x ** y    return z
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: def multiply(x, y):    z = x ** y    return z
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, there could be typos in the code and issues with indentation
    that prevent the code from running. You might also face issues because of an incorrect
    operator being used, such as `**` for multiplication instead of `*`. In this case,
    your code will run but the expected result will be different than what the function
    is supposed to do, which is multiplying the input variables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码中可能有拼写错误和缩进问题，这会阻止代码运行。你也可能因为使用了不正确的运算符而遇到问题，例如使用 `**` 而不是 `*` 进行乘法。在这种情况下，你的代码将运行，但预期的结果将与函数本应执行的操作不同，即乘以输入变量。
- en: Error messages in Python
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的错误信息
- en: 'Sometimes, there are issues with our code that don’t let it continue running.
    These issues could result in different error messages in Python. Here are some
    examples of error messages you might face when you’re running your Python code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的代码中存在一些问题，导致代码无法继续运行。这些问题可能导致 Python 中出现不同的错误信息。以下是一些你运行 Python 代码时可能遇到的错误信息的例子：
- en: '`SyntaxError`: This is a type of error you’ll get when the syntax you used
    in your code is not the correct Python syntax. It could be caused by a typo, such
    as having `retunr` instead of `return`, as shown previously, or using a command
    that doesn’t exist, such as using `giveme` instead of `return`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyntaxError`: 当你在代码中使用的语法不是正确的 Python 语法时，你会得到此类错误。这可能是由于一个错误，例如之前显示的 `retunr`
    而不是 `return`，或者使用了一个不存在的命令，例如使用 `giveme` 而不是 `return`。'
- en: '`TypeError`: This error will be raised when your code tries to perform an operation
    on an object or variable that cannot be done in Python. For example, if your code
    tries to multiply two numbers while the variables are in string format instead
    of float or integer format.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeError`: 当你的代码尝试在 Python 中对一个对象或变量执行无法进行的操作时，会引发此类错误。例如，如果你的代码尝试将两个数字相乘，而变量是以字符串格式而不是浮点数或整数格式存在。'
- en: '`AttributeError`: This type of error is raised when an attribute is used for
    an object that it is not defined for. For example, `isnull` is not defined for
    a list. So, `my_list.isnull()` results in `AttributeError`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AttributeError`: 当一个属性被用于一个未定义其属性的物体时，会引发此类错误。例如，`isnull` 对于列表未定义。因此，`my_list.isnull()`
    会引发 `AttributeError`。'
- en: '`NameError`: This error is raised when you try to call a function, class, or
    other names and modules that are not defined in your code. For example, if you
    haven’t defined a `neural_network` class in your code but call it in your code
    as `neural_network()`, you will get a `NameError` message.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NameError`: 当你尝试调用未在代码中定义的函数、类或其他名称和模块时，会引发此类错误。例如，如果你没有在代码中定义 `neural_network`
    类，但在代码中调用它为 `neural_network()`，你将收到 `NameError` 信息。'
- en: '`IndentationError`: Python is a programming language that relies on correct
    indentation – that is, the necessary spaces at the beginning of each line of code
    – to understand relationships between the lines. It also helps with code readability.
    `IndentationError` is the result of the wrong type of indentation being used in
    your code. But not all wrong indentation, based on the objective you have in mind,
    results in `IndentationError`. For example, the following code examples work without
    any error, but only the first one meets the objective of counting the number of
    odd numbers in a list. The bottom function returns the length of the input list
    instead. As a result, if you run the top part of the code, you will get 3 as the
    output, which is the total number of odd numbers in the input list, while the
    bottom part of the code returns 5, which is the length of the list. These types
    of errors, which don’t stop the code from running but generate an incorrect output,
    are called *logical errors*.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndentationError`：Python是一种依赖于正确缩进的编程语言——也就是说，每行代码开头的必要空格——以理解行之间的关系。它还有助于代码的可读性。`IndentationError`是由于代码中使用了错误的缩进类型而产生的。但并非所有错误的缩进都会导致`IndentationError`。例如，以下代码示例在没有错误的情况下运行，但只有第一个示例达到了统计列表中奇数个数的目标。底部函数返回输入列表的长度。因此，如果你运行代码的上半部分，你会得到3作为输出，这是输入列表中奇数的总数，而代码的下半部分返回5，这是列表的长度。这些类型的错误不会阻止代码运行，但会产生不正确的输出，被称为*逻辑错误*。'
- en: 'Here is some example code in which using the wrong indention results in wrong
    results without any error message:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例代码，其中错误的缩进导致错误的结果，但没有错误信息：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code runs but generates unintended results:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以运行，但会产生意外的结果：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are other errors whose meanings are clear based on their name, such as
    `ZeroDivisionError` when your code tries to return division by zero, `IndexError`
    if your code tries to get a value based on an index that is greater than the length
    of a list, or `ImportError` when you’re trying to import a function or class that
    cannot be found.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有些错误根据其名称就能清楚地了解其含义，例如，当你的代码尝试执行除以零的操作时，会引发`ZeroDivisionError`；如果代码尝试根据一个大于列表长度的索引获取值，则会引发`IndexError`；当你尝试导入一个找不到的函数或类时，会引发`ImportError`。
- en: In the previous code examples, we used `docstring` to specify the type of input
    parameter (that is, a list) and the intended output. Having this information helps
    you and new users of your code to better understand the code and resolve any issue
    with it quickly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们使用了`docstring`来指定输入参数的类型（即列表）和预期的输出。拥有这些信息有助于你和新用户更好地理解代码，并快速解决与之相关的问题。
- en: These are simple examples of issues that can happen in your software and pipelines.
    In machine learning modeling, you need to conduct debugging to deal with hundreds
    or thousands of lines of code and tens or hundreds of functions and classes. However,
    debugging could be much more challenging compared to these examples. It could
    be even more difficult if you need to start working on a piece of code that you
    have not written yourself when, for example, you’re joining a new team in the
    industry or academia. You need to use techniques and tools that help you debug
    your code with minimum effort and time. Although this book is not designed for
    code debugging, reviewing some debugging techniques could help you in developing
    high-quality code that runs as planned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在你的软件和管道中可能发生的一些简单问题示例。在机器学习建模中，你需要进行调试来处理数百或数千行代码以及数十或数百个函数和类。然而，与这些示例相比，调试可能更具挑战性。例如，当你加入一个新的行业或学术团队，需要开始处理你未曾编写过的代码时，调试可能会更加困难。你需要使用技术和工具来帮助你以最少的努力和时间调试代码。尽管这本书不是为代码调试而设计的，但回顾一些调试技术可能有助于你开发出按计划运行的优质代码。
- en: Debugging techniques
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试技术
- en: There are techniques to help you in the process of debugging a piece of code
    or software. You might have used one or more of these techniques, even without
    remembering or knowing their names. We will review four of them here.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些技术可以帮助你在调试代码或软件的过程中。你可能已经使用过其中的一种或多种技术，即使你忘记了或不知道它们的名称。在这里，我们将回顾其中的四种。
- en: Traceback
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Traceback
- en: When you get an error message in Python, it usually provides you with the necessary
    information to find the issue. This information creates a report-like message
    about the lines of your code that the error occurred in, as well as the types
    of error and function or class calls that resulted in such errors. This report-like
    message is called a **traceback** in Python.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Python中收到错误消息时，它通常会提供您查找问题的必要信息。这些信息创建了一个类似报告的消息，关于错误发生的代码行，以及导致这些错误的错误类型和函数或类调用。这种类似报告的消息在Python中称为**回溯**。
- en: 'Consider the following code, in which the `reverse_multiply` function is supposed
    to return a list of element-wise multiplication of an input list and its reverse.
    Here, `reverse_multiply` uses the `multiply` command to multiply the two lists.
    Since `multiply` is designed for multiplying two float numbers, not two lists,
    the code returns the traceback message with the necessary information for finding
    the issue, starting from the bottom operation. It specifies that `TypeError` occurred
    on line 8 within `multiply`, which is the bottom operation, and then lets us know
    that this issue results in an error occurring on line 21, in `reverse_multiply`,
    and eventually line 27 in the whole code module. Both the PyCharm IDE and Jupyter
    return this information. The following code examples show you how to use traceback
    to find necessary information so that you can debug a small and simple piece of
    Python code in both PyCharm and Jupyter Notebook:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，其中`reverse_multiply`函数本应返回一个列表，该列表包含输入列表及其反转的逐元素乘积。在这里，`reverse_multiply`使用`multiply`命令来乘以两个列表。由于`multiply`是为乘以两个浮点数而设计的，而不是两个列表，因此代码返回了包含必要信息的回溯消息，从底部操作开始。它指定在`multiply`的第8行发生了`TypeError`，这是底部操作，然后让我们知道这个问题导致在`reverse_multiply`的第21行发生错误，并最终在代码模块的第27行。PyCharm
    IDE和Jupyter都返回了这些信息。以下代码示例展示了如何使用回溯来查找必要信息，以便您可以在PyCharm和Jupyter Notebook中调试一小段简单的Python代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following lines show you the **traceback** error message when you run the
    previous code in Jupyter Notebook:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在Jupyter Notebook中运行先前代码时的**回溯**错误消息：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Python traceback messages seem to be very useful for debugging our code. However,
    they are not enough for debugging large code bases that contain many functions
    and classes. You need to use complementary techniques to help you in the debugging
    process.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python的回溯消息似乎对调试我们的代码非常有用。然而，对于包含许多函数和类的庞大代码库，它们并不足够。您需要使用辅助技术来帮助您在调试过程中。
- en: Induction and deduction
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 归纳与演绎
- en: 'When you have found an error in your code, you can either start by collecting
    as much information as you can and try to find potential issues using the information,
    or you can jump into checking your suspicions. These two approaches differentiate
    induction from the deduction process in terms of code debugging:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在代码中找到错误时，您可以从收集尽可能多的信息开始，并尝试使用这些信息查找潜在的问题，或者您可以跳入检查您的怀疑。这两种方法在代码调试方面区分了归纳和演绎过程：
- en: '**Induction**: In the induction process, you start collecting information and
    data about the problem in your code that helps you come up with a list of potential
    issues resulting from the error. Then, you can narrow the list down and, if necessary,
    collect more information and data from the process until you fix the error.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**归纳**：在归纳过程中，您开始收集有关代码中问题的信息和数据，这有助于您列出由错误引起的潜在问题列表。然后，您可以缩小列表，并在必要时从过程中收集更多信息和数据，直到修复错误。'
- en: '**Deduction**: In the deduction process, you come up with a short list of your
    points of suspicion regarding the issues in your code and try to find if any one
    of them is the actual source of the issue. You continue this process and gather
    more information and come up with new potential sources of the problem. You continue
    this process until you fix the problem.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演绎**：在演绎过程中，您会列出有关代码中问题的怀疑点，并尝试找出它们中是否有任何一个是问题的实际来源。您继续这个过程，收集更多信息，并提出新的潜在问题来源。您继续这个过程，直到解决问题。'
- en: In both approaches, you go through an iterative process of coming up with potential
    sources of issues and building hypotheses and then collect the necessary information
    until you fix the error in your code. If a piece of code or software is new to
    you, this process could take time. In such cases, try to get help from your teammates
    with more experience with the code to collect more data and come up with more
    relevant hypotheses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种方法中，你都会经历一个迭代过程，即提出潜在的问题来源，建立假设，然后收集必要的信息，直到你修复代码中的错误。如果一段代码或软件对你来说是新的，这个过程可能会花费一些时间。在这种情况下，尝试从对代码有更多经验的队友那里寻求帮助，收集更多数据并提出更相关的假设。
- en: Bug clustering
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误聚类
- en: As stated in the Pareto principle, named after Vilfredo Pareto, a famous Italian
    sociologist and economist, 80% of the results originate from 20% of the causes.
    The exact number is not the point here. This principle helps us better understand
    that the majority of the problems and errors in our code are caused by a minority
    of its modules. By grouping bugs, we can hit multiple birds with one stone as
    resolving an issue in a group of bugs could potentially resolve most others within
    the same group.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如帕累托原则所述，该原则以著名的意大利社会学家和经济学家维弗雷多·帕累托命名，80%的结果源于20%的原因。具体的数字在这里并不重要。这个原则帮助我们更好地理解，我们代码中的大多数问题和错误都是由少数模块引起的。通过分组错误，我们可以一石多鸟，因为解决一组错误中的问题可能会潜在地解决同一组中的大多数其他问题。
- en: Problem simplification
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题简化
- en: The idea here is to simplify the code so that you can identify the cause of
    the error and fix it. You could replace big data objects with smaller and even
    synthetic ones or limit function calling in a big module. This process could help
    you quickly eliminate the options for identifying the causes of the issues in
    your code, or even in the data format you have used as inputs of functions or
    classes in your code. Especially in a machine learning setting, where you might
    deal with complex data processes, big data files, or streams of data, this simplification
    process for debugging could be very useful.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是简化代码，以便你可以识别错误的来源并修复它。你可以用更小甚至合成的数据对象替换大数据对象，或者限制在大模块中的函数调用。这个过程可以帮助你快速排除识别代码中问题原因的选项，甚至在你代码中用作函数或类输入的数据格式中。特别是在机器学习环境中，你可能需要处理复杂的数据处理、大数据文件或数据流，这种调试过程中的简化过程可能非常有用。
- en: Debuggers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器
- en: 'Each IDE you might use, such as PyCharm, or if you use Jupyter Notebook to
    experiment with your ideas using Python, has built-in features for debugging.
    There are also free or paid tools you can benefit from to facilitate your debugging
    processes. For example, in PyCharm and most other IDEs, you can use breakpoints
    as pausing places when running a big piece of code so that you can follow the
    operations in your code (*Figure 1**.3*) and eventually find the cause of the
    issue:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会使用每个IDE，例如PyCharm，或者如果你使用Jupyter Notebook用Python来实验你的想法，它们都有内置的调试功能。还有免费或付费的工具可以帮助你简化调试过程。例如，在PyCharm和大多数其他IDE中，你可以在运行一大段代码时使用断点作为暂停点，以便你可以跟踪代码中的操作（*图1.3*）并最终找到问题的原因：
- en: '![Figure 1.3 – Using breakpoints in PyCharm for code debugging](img/B16369_01_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 在PyCharm中使用断点进行代码调试](img/B16369_01_03.jpg)'
- en: Figure 1.3 – Using breakpoints in PyCharm for code debugging
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 在PyCharm中使用断点进行代码调试
- en: The breakpoint capabilities in different IDEs are not the same. For example,
    you can use PyCharm’s conditional breakpoints to speed up your debugging process,
    which helps you not execute a line of code in a loop or repeat function calls
    manually. Read more about the debugging features of the IDE you use and consider
    them as another tool in your toolbox for better and easier Python programming
    and machine learning modeling.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不同IDE中的断点功能并不相同。例如，你可以使用PyCharm的条件断点来加速你的调试过程，这有助于你避免在循环中执行代码行或手动重复函数调用。了解更多关于你使用的IDE的调试功能，并将它们视为你工具箱中另一个更好的、更简单的Python编程和机器学习建模工具。
- en: The debugging techniques and tools we’ve briefly explained here, or those you
    already know about, could help you develop a piece of code that runs and provides
    the intended results. You could also follow some best practices for high-quality
    Python programming and building your machine learning models.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里简要解释的调试技术和工具，或者你已经知道的那些，可以帮助你开发出能够运行并提供预期结果的代码。你也可以遵循一些高质量Python编程和构建你的机器学习模型的最佳实践。
- en: Best practices for high-quality Python programming
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高质量Python编程的最佳实践
- en: 'Prevention is better than a cure. There are practices you can follow to prevent
    or decrease the chance of bugs occurring in your code. In this section, we will
    talk about three of those practices: **incremental programming**, **logging**,
    and **defensive programming**. Let’s look at each in detail.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 预防胜于治疗。你可以遵循一些实践来预防或减少代码中发生错误的机会。在本节中，我们将讨论其中三种实践：**增量编程**、**日志记录**和**防御性编程**。让我们逐一详细探讨。
- en: Incremental programming
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量编程
- en: Machine learning modeling in practice, in academia or industry, is beyond writing
    a few lines of code to train a simple model such as a logistic regression model
    using datasets that already exist in `scikit-learn`. It requires many modules
    for processing data, training and testing model and postprocessing inferences,
    or predictions to assess the reliability of the models. Writing code for every
    small component, then testing it and writing test code using PyTest, for example,
    could help you avoid issues with each function or class you wrote. It also helps
    you make sure that the outputs of one module that feed another module as its input
    are compatible. This process is what is called **incremental programming**. When
    you write a piece of software or pipeline, try to write and test it piece by piece.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，无论是学术界还是工业界，机器学习建模都不仅仅是写几行代码来训练一个简单的模型，比如使用`scikit-learn`中已存在的数据集训练逻辑回归模型。它需要许多模块来处理数据、训练和测试模型以及后处理推断或预测以评估模型的可靠性。为每个小组件编写代码，然后使用PyTest等工具进行测试和编写测试代码，可以帮助你避免你编写的每个函数或类的问题。它还帮助你确保作为另一个模块输入的模块的输出是兼容的。这个过程被称为**增量编程**。当你编写软件或管道时，尽量分步骤编写和测试。
- en: Logging
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'Every car has a series of dashboard lights that get turned on when there is
    a problem with the car. These problems could stop the car from running or cause
    serious damage if they’re not acted upon, such as low gas or engine oil change
    lights. Now, imagine there was no light or warning, and all of a sudden, the car
    you are driving stops or makes a terrible sound, and you don’t know what to do.
    When you develop functions and classes in Python, you can benefit from `basicConfig()`,
    which does the basic configuration for the logging system:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每辆车都有一系列仪表盘灯，当车辆出现问题时，这些灯会亮起。这些问题如果不采取行动，可能会停止车辆运行或造成严重损坏，例如燃油低或发动机油更换灯。现在，想象一下如果没有灯光或警告，你驾驶的汽车突然停止或发出可怕的声音，而你不知道该怎么办。当你用Python开发函数和类时，你可以从`basicConfig()`中受益，它为日志系统进行基本配置：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you run the previous code, you will get the following messages and output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的代码时，你会得到以下信息和输出：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The logged error messages are the results of attempting to multiply `'no'`,
    which is a string with another number.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的错误信息是尝试将字符串`'no'`与另一个数字相乘的结果。
- en: Defensive programming
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防御性编程
- en: 'Defensive programming is about preparing yourself for mistakes that can be
    made by you, your teammates, and your collaborators. There are tools, techniques,
    and Python classes to defend the code against such mistakes, such as `AssertionError:
    Variable should be of` `type float`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '防御性编程是关于为可能由你、你的队友和你的合作伙伴犯下的错误做好准备。有一些工具、技术和Python类可以用来防御代码中的这些错误，例如`AssertionError:
    Variable should be of type float`：'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Version control
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: The tools and practices we covered here are just examples of how you can improve
    the quality of your programming and decrease the amount of time needed to eliminate
    issues and errors in your code. Another important tool in improving your machine
    learning modeling is **versioning**. We will talk about data and model versioning
    in [*Chapter 10*](B16369_10.xhtml#_idTextAnchor286), *Versioning and Reproducible
    Machine Learning Modeling*, but let’s briefly talk about code versioning here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的工具和实践只是如何提高你的编程质量以及减少消除代码中问题和错误所需时间的例子。在提高你的机器学习建模能力方面，另一个重要的工具是**版本控制**。我们将在[*第10章*](B16369_10.xhtml#_idTextAnchor286)“版本控制和可重复的机器学习建模”中讨论数据和模型版本控制，但让我们简要地谈谈代码版本控制。
- en: Version control systems allow you to manage changes in your code and files that
    exist in a code base and help you in tracking those changes, gain access to the
    history of changes, and collaborate in developing different components of a machine
    learning pipeline. You can use version control systems such as **Git** and its
    associated hosting services such as **GitHub**, **GitLab**, and **BitBucket**
    for your projects. These tools let you and your teammates and collaborators work
    on different branches of code without disrupting each other’s work. It also lets
    you easily go back to the history of changes and find out when a change happened
    in the code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统允许你管理代码库中代码和文件的变化，并帮助你跟踪这些变化，访问变化的历史记录，并在开发机器学习管道的不同组件时进行协作。你可以使用如**Git**及其关联的托管服务**GitHub**、**GitLab**和**BitBucket**等版本控制系统来管理你的项目。这些工具让你和你的团队成员以及合作者可以在不同的代码分支上工作，而不会相互干扰。它还允许你轻松地回到变化的历史记录中，并找出代码中的变化发生在何时。
- en: If you have not used version control systems, don’t consider them as a new complicated
    tool or programming language you need to start learning. There are a couple of
    core concepts and terms you need to learn first, such as `commit`, `push`, `pull`,
    and `merge`, when using Git. Using these functionalities could be even as simple
    as a few clicks in an IDE such as PyCharm if you don’t want to or know how to
    use the **command-line** **interface** (**CLI**).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有使用版本控制系统，不要把它们当作一个你需要开始学习的新复杂工具或编程语言。在使用Git时，你需要首先了解一些核心概念和术语，例如`commit`、`push`、`pull`和`merge`。如果你不想或不知道如何使用**命令行界面**（**CLI**），使用这些功能可能就像在PyCharm这样的IDE中点击几下那么简单。
- en: We reviewed some commonly used techniques and tools to help you in debugging
    your code and high-quality Python programming. However, there are more advanced
    tools built on top of models such as GPT, such as ChatGPT ([https://openai.com/blog/chatgpt](https://openai.com/blog/chatgpt))
    and GitHub Copilot ([https://github.com/features/copilot](https://github.com/features/copilot)),
    that you can use to develop your code faster and increase the quality of your
    code and even your code debugging efforts. We will talk about some of these tools
    in [*Chapter 14*](B16369_14.xhtml#_idTextAnchor379), *Introduction to* *Recent
    Advancements in* *Machine Learning*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了一些常用的技术和工具，以帮助你调试代码和高质量的Python编程。然而，还有一些更高级的工具建立在模型之上，如GPT，例如ChatGPT（[https://openai.com/blog/ChatGPT](https://openai.com/blog/ChatGPT)）和GitHub
    Copilot（[https://github.com/features/copilot](https://github.com/features/copilot)），你可以使用这些工具来更快地开发代码，提高代码和代码调试工作的质量。我们将在[*第14章*](B16369_14.xhtml#_idTextAnchor379)“*机器学习最新进展的介绍”中讨论一些这些工具。
- en: Although using the preceding debugging techniques or best practices to avoid
    issues in your Python code helps you have a low-bug code base, it doesn’t prevent
    all the problems with machine learning models. This book is about going beyond
    Python programming for machine learning to help you identify problems with your
    machine learning models and develop high-quality models.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用前面的调试技术或最佳实践来避免Python代码中的问题可以帮助你拥有低bug的代码库，但它并不能防止所有与机器学习模型相关的问题。这本书是关于超越Python编程进行机器学习，帮助你识别机器学习模型中的问题并开发高质量模型。
- en: Debugging beyond Python
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越Python的调试
- en: Eliminating code issues doesn’t resolve all the issues that may exist in a machine
    learning model or a pipeline for data preparation and modeling. There could be
    issues that don’t result in any error message, such as problems that originate
    from data used for modeling, and differences between test data and production
    data (that is, data that the model needs to be used for eventually).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 消除代码问题并不能解决机器学习模型或数据准备和建模管道中可能存在的所有问题。可能存在一些不会产生任何错误消息的问题，例如来自用于建模的数据的问题，以及测试数据和生产数据（即模型最终需要使用的数据）之间的差异。
- en: Production versus development environments
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境与开发环境
- en: The **development environment** is where we develop our models, such as our
    computers or cloud environments we use for development. It is where we develop
    our code, debug it, process data, train models, and validate them. But what we
    do in this stage doesn’t affect users directly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**是我们开发模型的地方，比如我们用于开发的计算机或云环境。在这里，我们编写代码、调试代码、处理数据、训练模型并验证它们。但我们在这个阶段所做的工作不会直接影响用户。'
- en: The **production environment** is where the model is ready to be used by end
    users or could affect them. For example, a model could get into production in
    the Amazon platform for recommending products, be delivered to other teams in
    a banking system for fraud detection, or even be used in hospitals to help clinicians
    in diagnosing patients’ conditions better.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产环境**是模型准备供最终用户使用或可能影响他们的地方。例如，一个模型可以在亚马逊平台上用于推荐产品，被发送到银行系统的其他团队进行欺诈检测，甚至被用于医院以帮助临床医生更好地诊断患者的病情。'
- en: Flaws in data used for modeling
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于建模的数据缺陷
- en: Data is one of the core components of machine learning modeling (*Figure 1**.1*).
    Applications of machine learning across different industries such as healthcare,
    finance, automotive, retail, and marketing are made possible by getting access
    to the necessary data for training and testing machine learning models. As the
    data gets fed into machine learning models for training (that is, identifying
    optimal model parameters) and testing, flaws in data could result in problems
    in models, such as low performance in training (for example, high bias), low generalizability
    (for example high variance), or socioeconomic biases. Here, we will discuss examples
    of flaws and properties of data that need to be considered when designing a machine
    learning model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是机器学习建模的核心组件（*图1.1*）。通过获取训练和测试机器学习模型所需的数据，使得机器学习在不同行业如医疗保健、金融、汽车、零售和营销等领域的应用成为可能。当数据被输入到机器学习模型中进行训练（即识别最佳模型参数）和测试时，数据中的缺陷可能导致模型出现问题，例如训练性能低（例如，高偏差）、低泛化能力（例如高方差）或社会经济偏差。在这里，我们将讨论在设计机器学习模型时需要考虑的数据缺陷和属性示例。
- en: Data format and structure
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据格式和结构
- en: There could be issues with how data is stored, read, and moved through different
    functions and classes in your code or pipeline. You might need to work with structured
    or tabular data or unstructured data such as videos and text documents. This data
    could be stored in relational databases such as **MySQL** or **NoSQL** (that is,
    non-relational) databases, data warehouses, and data lakes, or even stored locally
    in different file formats, such as **CSV**. Either way, the expected and existing
    file data structure and formats need to match. For example, if your code is expecting
    a tab-separated file format but instead the input file of the corresponding function
    is comma-separated, then all the columns could be lumped together. Luckily, most
    of the time, these kinds of issues result in errors in the code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在你的代码或管道中的存储、读取和移动方式可能存在问题。你可能需要处理结构化或表格数据，或者非结构化数据，如视频和文本文档。这些数据可以存储在关系型数据库中，如**MySQL**或**NoSQL**（即非关系型）数据库、数据仓库和数据湖中，甚至可以以不同的文件格式存储在本地，如**CSV**。无论如何，预期的和现有的文件数据结构和格式需要匹配。例如，如果你的代码期望一个制表符分隔的文件格式，但相应的函数的输入文件却是逗号分隔的，那么所有列可能会被合并在一起。幸运的是，大多数情况下，这类问题会导致代码中的错误。
- en: 'There could also be mismatches in the provided and expected data that wouldn’t
    cause any errors if the code is not defended against them and not enough information
    is logged. For example, imagine a scikit-learn `fit` function that expects training
    data with 100 features and at the same time, you have 100 data points. In this
    case, your code will not return any errors if features are in rows or columns
    of an input DataFrame. Then, your code needs to check if each row of an input
    DataFrame contains values of one feature across all data points or the feature
    values of one data point. The following figure shows how switching features with
    data points, such as transposing a DataFrame that switches rows with columns,
    could provide wrong input files but result in no error. In this figure, we have
    considered four columns and rows for simplicity. Here, F and D are used as abbreviations
    for feature and data point, respectively:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的数据和预期数据之间可能存在不匹配，如果代码没有针对这些不匹配进行防御并且没有足够的信息记录，则不会引起任何错误。例如，想象一个scikit-learn的`fit`函数期望有100个特征的训练数据，同时你有100个数据点。在这种情况下，如果你的代码将特征放在输入DataFrame的行或列中，代码将不会返回任何错误。然后，你的代码需要检查输入DataFrame的每一行是否包含所有数据点的单个特征值或单个数据点的特征值。以下图示展示了如何通过交换特征和数据点，例如通过转置DataFrame来交换行和列，可能会提供错误的输入文件但不会产生错误。在这个图中，我们为了简化考虑了四列和四行。在这里，F和D分别用作特征和数据点的缩写：
- en: '![Figure 1.4 – Simplified example showcasing how the transpose of a DataFrame
    can be used by mistake in a scikit-learn fit function that expects four features](img/B16369_01_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 简化示例，展示如何在期望四个特征的scikit-learn fit函数中错误地使用DataFrame的转置](img/B16369_01_04.jpg)'
- en: Figure 1.4 – Simplified example showcasing how the transpose of a DataFrame
    can be used by mistake in a scikit-learn fit function that expects four features
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 简化示例，展示如何在期望四个特征的scikit-learn fit函数中错误地使用DataFrame的转置
- en: Data flaws are not restricted to structure and format issues. Some data characteristics
    need to be considered when you’re trying to build and improve a machine learning
    model.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数据缺陷不仅限于结构和格式问题。当你试图构建和改进机器学习模型时，需要考虑一些数据特征。
- en: Data quantity and quality
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据数量和质量
- en: Despite machine learning being a more than half-century-old concept, the rise
    of excitement around machine learning started in 2012\. Although there were algorithmic
    advancements for image classification between 2010 and 2015, it was the availability
    of 1.2 million high-resolution images in the ImageNet LSVRC-2010 contest and the
    necessary computing power that played a crucial role in the development of the
    first high-performance image classification models, such as AlexNet (Krizhevsky
    et al., 2012) and VGG (Simonyan and Zisserman, 2014).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管机器学习是一个超过半个世纪的概念，但围绕机器学习的兴奋情绪始于2012年。尽管在2010年至2015年之间图像分类算法有所进步，但1.2百万张高分辨率图像在ImageNet
    LSVRC-2010竞赛中的可用性以及必要的计算能力在开发第一个高性能图像分类模型（如AlexNet（Krizhevsky等人，2012）和VGG（Simonyan和Zisserman，2014））中发挥了关键作用。
- en: In addition to data quantity, the quality of the data also plays a very important
    role. In some applications, such as clinical cancer settings, a high quantity
    of high-quality data is not accessible. Benefitting from both quantity and quality
    could also become a tradeoff as we could have access to more data but with lower
    quality. We can choose to stick to high-quality data or low-quality ones or try
    to benefit from both high-quality and low-quality data if possible. Selecting
    the right approach is domain-specific and depends on the data and algorithm used
    for modeling.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据量，数据的质量也起着非常重要的作用。在某些应用中，例如临床癌症设置，高质量的大量数据是不可获取的。从数量和质量中受益也可能成为一种权衡，因为我们可能能够获取更多数据，但质量较低。我们可以选择坚持高质量数据或低质量数据，或者如果可能的话，尝试从高质量和低质量数据中受益。选择正确的方法是特定于领域的，并取决于用于建模的数据和算法。
- en: Data biases
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据偏见
- en: Machine learning models can have different kinds of biases, depending on the
    data we feed them. **Correctional Offender Management Profiling for Alternative
    Sanctions** (**COMPAS**) is a famous example of machine learning models with reported
    biases. COMPAS is designed to estimate the likelihood of a defendant to re-offend
    based on their response to more than 100 survey questions. A summary of the responses
    to the questions results in a risk score, which includes questions such as whether
    one of the prisoner’s parents was ever in prison. Although the tool has been successful
    in many examples, when it has been wrong in terms of prediction, the results for
    white and black offenders were not the same. The developer company of COMPAS presented
    data that supports its algorithm’s findings. You can find articles and blog posts
    to read more about its current status and whether it is still used or still has
    biases or not.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型可能具有不同的偏见，这取决于我们提供给它们的资料。**纠正性罪犯管理配置文件用于替代制裁**（**COMPAS**）是机器学习模型中具有报告偏见的著名例子。COMPAS旨在根据被告对超过100个调查问题的回答来估计其再犯的可能性。对问题的回答的总结产生一个风险评分，其中包括是否有一位囚犯的父母曾入狱等问题。尽管这个工具在许多例子中都取得了成功，但当它在预测方面出错时，白人和黑人罪犯的结果并不相同。COMPAS的开发公司提供了支持其算法发现的数据。你可以找到文章和博客文章了解更多关于其当前状态以及它是否仍在使用或是否仍有偏见的信息。
- en: These were some examples of issues in data and their consequences in the resulting
    machine learning models. But there are other problems in models that do not originate
    from data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是数据问题和它们在结果机器学习模型中的后果的一些例子。但模型中还有其他问题并非源于数据。
- en: Model and prediction-centric debugging
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型和预测中心调试
- en: The predictions of a model in the training, testing, and production stages could
    help us detect issues with the models and find opportunities to improve them.
    Here, we will briefly review some aspects of model- and prediction-centric model
    debugging. You can read more details about these problems and other considerations
    in achieving a reliable model, how to identify the source of the issues, and how
    to resolve them in future chapters of this book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 训练、测试和生产阶段模型的预测可以帮助我们检测模型的问题并找到改进它们的机会。在这里，我们将简要回顾一些以模型和预测为中心的模型调试方面。你可以在本书的未来章节中了解更多关于这些问题和其他考虑因素，如何识别问题的根源，以及如何在未来的章节中解决它们。
- en: Underfitting and overfitting
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欠拟合和过拟合
- en: 'When we train a model, such as a supervised learning model, the goal is to
    have high performance not just in training but also in testing. When a model has
    low performance even in a training set, we need to deal with the issue of **underfitting**.
    We can develop more complicated models, such as a random forest or deep learning
    model, instead of linear and logistic regression models. More complex models might
    result in lower underfitting, but they might cause **overfitting** and result
    in lower generalizability of the prediction to test or production data (*Figure
    1**.5*):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们训练一个模型，例如监督学习模型时，目标是不仅在训练阶段，而且在测试阶段都拥有高性能。当一个模型即使在训练集上表现不佳时，我们需要处理**欠拟合**的问题。我们可以开发更复杂的模型，例如随机森林或深度学习模型，而不是线性回归和逻辑回归模型。更复杂的模型可能会降低欠拟合，但它们可能会引起**过拟合**，导致预测对测试或生产数据的泛化能力降低（*图1.5*）：
- en: '![Figure 1.5 – Schematic illustration of underfitting and overfitting](img/B16369_01_05.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 欠拟合和过拟合的示意图](img/B16369_01_05.jpg)'
- en: Figure 1.5 – Schematic illustration of underfitting and overfitting
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 欠拟合和过拟合的示意图
- en: Algorithm and hyperparameter selection determine the level of complexity and
    the chance of underfitting or overfitting when training and testing a machine
    learning model. For example, by choosing a model that can learn nonlinear patterns
    instead of linear models, your model could have a higher chance of low underfitting
    as it could identify more complex patterns in training data. But at the same time,
    you could increase the chance of overfitting as some of the complex patterns in
    the training data might not be generalizable to the test data (*Figure 1**.5*).
    There are approaches to assess underfitting and overfitting that will help you
    develop a high-performance and generalizable model. We will discuss these in future
    chapters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 算法和超参数的选择决定了在训练和测试机器学习模型时的复杂程度以及欠拟合或过拟合的可能性。例如，通过选择可以学习非线性模式的模型而不是线性模型，你的模型在训练数据中能够识别更复杂的模式，因此有更高的可能性降低欠拟合。但与此同时，你可能会增加过拟合的可能性，因为训练数据中的一些复杂模式可能无法推广到测试数据（*图1.5*）。有一些方法可以评估欠拟合和过拟合，这有助于你开发高性能且可泛化的模型。我们将在未来的章节中讨论这些问题。
- en: Model hyperparameters
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 模型超参数
- en: Some parameters can affect the performance of a machine learning model that
    usually do not get optimized automatically in the training process. These are
    called hyperparameters. We will go through examples of such hyperparameters, such
    as the number of trees in a random forest model or the size of hidden layers in
    neural network models, in future chapters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数可能会影响机器学习模型的性能，这些参数在训练过程中通常不会自动优化。这些被称为超参数。我们将在未来的章节中通过一些这样的超参数的例子进行说明，例如随机森林模型中的树的数量或神经网络模型中隐藏层的大小。
- en: Inference in model testing and production
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型测试和生产中的推理
- en: The eventual goal of machine learning modeling is to have a highly effective
    model in production. When we test the model, we are assessing its generalizability,
    but we cannot be sure about its performance on the data it has not seen. The data
    that’s used for training machine learning models could become out of date. For
    example, the changes in the trends of the clothing market could make predictions
    of a model for clothing recommendation unreliable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习建模的最终目标是拥有在生产环境中高度有效的模型。当我们测试模型时，我们正在评估其泛化能力，但我们不能确定它在未见过的数据上的表现。用于训练机器学习模型的数据可能会过时。例如，服装市场趋势的变化可能会使服装推荐模型的预测不可靠。
- en: There are different concepts in this topic, such as data variance, data drift,
    and model drift, all of which we will cover in the next few chapters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中存在不同的概念，如数据方差、数据漂移和模型漂移，我们将在接下来的几章中涵盖这些内容。
- en: Data or hyperparameters for changing landscapes
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于改变景观的数据或超参数
- en: When we train a machine learning model with specific training data and a set
    of hyperparameters, the values of model parameters get changed so that they’re
    as close to an optimum point as possible for a defined objective or loss function.
    The two other tools to achieve a better model are providing better data for training
    and selecting better hyperparameters. Each algorithm has a capacity for performance
    improvement. By playing with model hyperparameters alone, you cannot develop the
    best possible model. In the same way, by increasing the quality and quantity of
    your data and keeping your model hyperparameters the same, you could also not
    achieve the best performance possible. So, data and hyperparameters come hand
    in hand. Before you read the next chapters, remember that by spending more time
    and money on hyperparameter optimization alone, you cannot necessarily get a better
    model. We will look at this in more detail later in this book.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用特定的训练数据和一组超参数训练机器学习模型时，模型参数的值会发生变化，以便它们尽可能地接近定义的目标或损失函数的最优点。实现更好模型的另外两个工具是提供更好的训练数据和选择更好的超参数。每个算法都有提高性能的潜力。仅通过调整模型超参数，你无法开发出最佳模型。同样，仅通过增加数据和保持模型超参数不变，你也无法实现最佳性能。因此，数据和超参数是相辅相成的。在你阅读下一章之前，请记住，仅通过在超参数优化上投入更多的时间和金钱，你并不一定能得到更好的模型。我们将在本书的后面更详细地探讨这一点。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed important concepts and approaches for debugging
    in software development and their differences with machine learning model debugging.
    You learned that debugging in machine learning modeling is beyond software debugging
    and how data and algorithms, in addition to code, could cause flawed or low-performance
    models and unreliable predictions. You can benefit from these understandings and
    the tools and techniques you will learn about throughout this book to develop
    reliable machine learning models.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了软件开发中调试的重要概念和方法，以及它们与机器学习模型调试的区别。你了解到，在机器学习建模中的调试超出了软件调试的范畴，以及数据和算法，除了代码之外，也可能导致模型存在缺陷或性能低下，以及预测不可靠。你可以从这些理解以及本书中将要学习的工具和技术中受益，以开发可靠的机器学习模型。
- en: In the next chapter, you will learn about the different components of the machine
    learning life cycle. You will also learn how modularizing machine learning modeling
    with these components helps us in identifying opportunities for improving our
    models before and after training and testing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解机器学习生命周期的不同组成部分。你还将学习如何通过这些组件模块化机器学习建模，这有助于我们在训练和测试前后识别改进模型的机会。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Could your code have unintended indentation but not return any error message?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码是否有意外的缩进，但不会返回任何错误信息？
- en: What is the difference between `AttributeError` and `NameError` in Python?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中，`AttributeError`和`NameError`之间的区别是什么？
- en: How does data dimensionality affect model performance?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据维度如何影响模型性能？
- en: What information do *traceback* messages in Python provide you about the errors
    in your code?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python中的*traceback*消息提供了关于你代码中错误的信息是什么？
- en: Could you explain two best practices for high-quality Python programming?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能解释两个高质量的Python编程的最佳实践吗？
- en: Could you explain why you might have features or data points with different
    levels of confidence?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能解释为什么你可能有不同置信水平的特征或数据点吗？
- en: Could you provide suggestions on how to reduce underfitting or overfitting when
    building a model for a given dataset?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能提供有关如何减少在为给定数据集构建模型时欠拟合或过拟合的建议吗？
- en: Could we have a model with significantly lower performance in production than
    testing?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否可能有一个在生产环境中性能显著低于测试环境的模型？
- en: Is it a good idea to focus on hyperparameter optimization when we can also improve
    the quality or quantity of the training data?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们也可以提高训练数据的质量或数量时，专注于超参数优化是否是一个好主意？
- en: References
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Widyasari, Ratnadira, et al. *BugsInPy: A database of existing bugs in Python
    programs to enable controlled testing and debugging studies.* Proceedings of the
    28th ACM joint meeting on European software engineering conference and symposium
    on the foundations of software engineering. 2020.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Widyasari, Ratnadira, 等人. *BugsInPy: 一个用于Python程序现有错误的数据库，以实现受控的测试和调试研究.* 第28届ACM欧洲软件工程会议和软件工程基础研讨会论文集。2020。'
- en: '*The Art of Software Testing, Second Edition*, by Glenford J. Myers, Corey
    Sandler, Tom Badgett, Todd M. Thomas.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《软件测试的艺术，第二版》，作者：Glenford J. Myers, Corey Sandler, Tom Badgett, Todd M. Thomas*.'
- en: Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. *Imagenet classification
    with deep convolutional neural networks*. Advances in neural information processing
    systems 25 (2012).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Krizhevsky, Alex, Ilya Sutskever, 和 Geoffrey E. Hinton. *使用深度卷积神经网络的ImageNet分类*.
    神经信息处理系统进展 25 (2012).
- en: Simonyan, Karen, and Andrew Zisserman. “Very deep convolutional networks for
    large-scale image recognition.” arXiv preprint arXiv:1409.1556 (2014). [https://arxiv.org/abs/1409.1556](https://arxiv.org/abs/1409.1556).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Simonyan, Karen, 和 Andrew Zisserman. “用于大规模图像识别的超深层卷积神经网络.” arXiv预印本 arXiv:1409.1556
    (2014). [https://arxiv.org/abs/1409.1556](https://arxiv.org/abs/1409.1556).
