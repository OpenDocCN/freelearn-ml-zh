<html><head></head><body><div><div><h1 id="_idParaDest-46"><a id="_idTextAnchor046"/><em class="italic">Chapter 2</em>: Understanding and Working with Signals</h1>
			<p>In this chapter, you will learn about several different signal types that you are likely to see when integrating the sensors that you have chosen for your project. You will also learn about the various signal architectures, and the chapter will help you choose the one that is most appropriate for your application. Each has its pitfalls, protocols, and prescriptions.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Signal types</li>
				<li>Analog verus digital</li>
				<li>Serial data</li>
				<li>CAN</li>
				<li>UDP</li>
				<li>TCP</li>
			</ul>
			<p>By the end of this chapter, you will be able to apply your understanding of each protocol. You will be able to decode the serial data of various protocols by hand to aid in debugging signals. Most importantly, you will have the knowledge required to help you apply open source tools to do the heavy lifting for you.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>Technical requirements</h1>
			<p>To execute the instructions in this chapter, you need the following:</p>
			<ul>
				<li>Basic electrical circuit knowledge (about voltage, current, and resistance)</li>
				<li>Binary, hexadecimal, and ASCII programming knowledge</li>
				<li>Oscilloscope experience for probing sensor signals</li>
			</ul>
			<p>The code for the chapter can be found at:</p>
			<p><a href="https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2">https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2</a></p>
			<p>The Code in Action videos for this chapter can be found here:</p>
			<p><a href="https://bit.ly/2HpFqZa">https://bit.ly/2HpFqZa</a></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Understanding signal types</h1>
			<p>You will encounter many different<a id="_idIndexMarker114"/> signal types when integrating sensors, actuators, and controllers for a self-driving car. You will need an understanding of the strengths and weaknesses of each type to help you select the correct devices to integrate. The next few sections will cover all the details regarding each signal type and arm you with the knowledge to make the right choices.</p>
			<p>Here are the basic signal types that you will encounter in robotics and self-driving cars:</p>
			<ul>
				<li>Serial</li>
				<li>Parallel</li>
				<li>Analog</li>
				<li>Digital</li>
				<li>Single-ended</li>
				<li>Differential</li>
			</ul>
			<p>In the next section, you will learn the difference between analog and digital signals.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Analog versus digital</h1>
			<p>The <a id="_idIndexMarker115"/>first thing to remember is that we live in an analog world. Nothing<a id="_idIndexMarker116"/> is instantaneous and everything is continuous. This is the reason why we can't teleport, sadly!</p>
			<p>Similarly, analog signals are continuous and everchanging; they don't jump instantaneously but instead smoothly transition from one state to another. A prime example of an analog<a id="_idIndexMarker117"/> signal is the old <strong class="bold">Amplitude Modulation</strong> (<strong class="bold">AM</strong>) radio. You can see in the following figure how the smooth data signal is modulated onto a smooth carrier wave to create the smooth AM signal. Here, the pitch is represented by how quickly the amplitude is changing and the volume is represented by how great the amplitude is:</p>
			<div><div><img src="img/B16322_02_01.jpg" alt="Figure 2.1 – Analog signal example" width="1065" height="250"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Analog signal example</p>
			<p>In contrast, a <a id="_idIndexMarker118"/>digital signal is one that is sampled at known points in time. When<a id="_idIndexMarker119"/> the signal is sampled, it is checked to see whether it is above or below a certain threshold, which will determine whether it is a logic <code>0</code> or <code>1</code>. You can see an example of this in the following figure:</p>
			<div><div><img src="img/B16322_02_02.jpg" alt="Figure 2.2 – Digital signal example" width="741" height="455"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Digital signal example</p>
			<p class="callout-heading">Analog hides in the digital</p>
			<p class="callout">Although we talk about digital as jumping from one state to another, it really isn't. It is just changing very quickly but in an analog fashion. We simply choose to sample it in the middle of a pulse. The world is always analog, but sometimes we interpret it digitally.</p>
			<p>If you<a id="_idIndexMarker120"/> look carefully at the following figure, you see the analog <a id="_idIndexMarker121"/>nature that hides in the corners!</p>
			<div><div><img src="img/B16322_02_03.jpg" alt="Figure 2.3 – Digital signal oscilloscope – before and after signal has run" width="589" height="206"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Digital signal oscilloscope – before and after signal has run</p>
			<p>Do you see it? Although<a id="_idIndexMarker122"/> this is supposed to be a sharp transition between<a id="_idIndexMarker123"/> voltages, you can see the rounding of what should be square corners. This is due to the fact that nothing in nature is instantaneous and everything transitions smoothly from one state to another. </p>
			<p>In the next section, you will learn the difference between serial and parallel data transfer.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Serial versus parallel</h1>
			<p>Serial data is <a id="_idIndexMarker124"/>probably the most ubiquitous type of data transfer. It is how we <a id="_idIndexMarker125"/>as humans are accustomed to communicating. You are doing it right now as you read this. Serial communication simply means that data is transmitted and received one unit at a time (as opposed to several units of data being transmitted in parallel).</p>
			<p>In the case of reading this book, your eyes are processing each word by scanning each line of text from left to right, then proceeding back to the beginning of the next line and continuing. You are processing a serial stream of words that are used to communicate some thoughts and ideas. Conversely, imagine if you could read the book several lines at a time. This would be considered parallel data transfer and it would be awesome!</p>
			<p>The unit of data that is used in computing is the bit, which is a binary representation for on or off, more commonly 1 or 0.</p>
			<p>Parallel data transfer was popular in the early years of computing since it allowed the simultaneous transfer of bits across multiple (usually 8) wires, which greatly increased data transfer speeds. This speed comes at several costs. More wires mean more weight, cost, and noise. Since the<a id="_idIndexMarker126"/> multiple wires are usually next to each other, you<a id="_idIndexMarker127"/> get a lot of noise induced on adjacent wires, known as crosstalk. This noise leads to shorter distances of transmission. The following figure illustrates how 8 bits are transferred serially versus in parallel:</p>
			<div><div><img src="img/B16322_02_04.jpg" alt="Figure 2.4 – Serial versus parallel" width="539" height="471"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Serial versus parallel</p>
			<p>Now you can see a single wire is dedicated to each bit. This was fine in early computing when 8 bits were being sent, but you can imagine how quickly this becomes unmanageable when you consider 32- and 64-bit data. Thankfully, once protocol speeds increased, it became clear that serial transfer was far cheaper and simpler to integrate. That is not to say that parallel data transfer doesn't still exist; it does in applications where speed is paramount.</p>
			<p>There are several types of <a id="_idIndexMarker128"/>serial data protocols, such as UART, I2C, SPI, Ethernet, and <a id="_idIndexMarker129"/>CAN. You will get an introduction to each of them in the next few sections.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>Universal Asynchronous Receive and Transmit (UART)</h2>
			<p>UART is a very <a id="_idIndexMarker130"/>common protocol, thanks to its simplicity and cost. Many low data rate applications will use it to transmit and receive data. A common application of UART that you will see in self-driving applications is time synchronization to GPS. A message from a GPS receiver containing all the position and time information will be sent to a lidar, camera, radar, or other sensor to synchronize <a id="_idIndexMarker131"/>them to <strong class="bold">Coordinated Universal Time</strong> (<strong class="bold">UTC</strong>).</p>
			<p class="callout-heading">Pardon me, I think your acronym is mixed up</p>
			<p class="callout">The French and the English<a id="_idIndexMarker132"/> couldn't agree on the acronym, so rather than CUT in English or <strong class="bold">TUC</strong> (<strong class="bold">Temps Universel Coordonné</strong>) in French, they mixed it up for both to not favor either language. If I can't have it my way, neither can you! Voilà, UTC is born!</p>
			<p>Okay, so what does UART look like? The first thing you need to understand is that the protocol is asynchronous, meaning that a clock signal (wire) is not needed. Instead, the two devices must each have pretty good internal clocks to keep time for themselves. Right, so no clock wire needed; but what wires do you need? You only need two wires: one to transmit and one to receive. As such, the two devices need to agree on some ground rules before they start the game:</p>
			<ol>
				<li><strong class="bold">Baud rate</strong>: This sets the number of bits per second that will be exchanged between the devices. In other words, it is the duration of the bit count. Common baud rates are 9,600, 19,200, 38,400, 57,600, 115,200, 128,000, and 256,000.</li>
				<li><strong class="bold">Data bits</strong>: This sets the number of bits in a data frame for the payload (data).</li>
				<li><strong class="bold">Parity</strong>: This sets whether you will have a parity bit in the packet. This can be used to verify the integrity of the message received. This is done by counting the number of 1s in the data frame and setting the parity bit to 0 for an even number of 1s or 1 for an odd number of 1s.</li>
				<li><strong class="bold">Stop bits</strong>: This sets the number of stop bits signifying the end of a packet.</li>
				<li><strong class="bold">Flow control</strong>: This sets whether you will be using hardware flow control. This is not as common since it requires two additional wires for <strong class="bold">Ready To Send</strong> (<strong class="bold">RTS</strong>) and <strong class="bold">Clear To Send</strong> (<strong class="bold">CTS</strong>).</li>
			</ol>
			<p>Great, we have the <a id="_idIndexMarker133"/>ground rules. Now let's see what a packet looks like and then decode one.</p>
			<p>The following figure illustrates the structure of a packet for a UART message. You can see we start with exactly one start bit (low), followed by 5 to 9 data bits, followed by the parity bit if one is in the rules, and finally the stop bit(s) (1 to 2, high). The idle state is often the high voltage state representing a <code>1</code> with the active state usually low, representing a <code>0</code>. This is a normal polarity. You can reverse the polarity if needed, as long as you lay the ground rules ahead of time:</p>
			<div><div><img src="img/B16322_02_05.jpg" alt="Figure 2.5 – UART packet structure" width="676" height="276"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – UART packet structure</p>
			<p>The following is an example signal trace showing how to decode the bits with eight data bits, no parity, and one stop bit. We begin in the idle (high) state, then the packet begins with a low voltage position. This signifies that the following eight bits are the data. Next, we see five counts of high voltage, signifying five 1 bits, followed by three counts of low voltage, signifying three 0 bits. You should know that UART messages are sent with the least significant bit first, meaning the lowest binary value or 20 position, followed by the 21 position, then the 22 position, and so on. So, if you reorder them into a human-readable format, your data message is 0 0 0 1 1 1 1 1; translated into decimal, that would be 31 or 1F in hexadecimal. There is a great resource at <a href="https://www.mathsisfun.com/binary-decimal-hexadecimal.html">https://www.mathsisfun.com/binary-decimal-hexadecimal.html</a> for different base number systems, such as binary, decimal, and hexadecimal. There is another handy resource for decoding <a id="_idIndexMarker134"/>ASCII characters from binary at <a href="http://www.asciitable.com/">http://www.asciitable.com/</a>:</p>
			<div><div><img src="img/B16322_02_06.jpg" alt="Figure 2.6 – UART example bits" width="568" height="183"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – UART example bits</p>
			<p class="callout-heading">Easter Egg</p>
			<p class="callout">Take out your decoder ring. It's time to learn the meaning of life, the universe, and everything...</p>
			<p class="callout"><img src="img/B16322_02_Art1.png" alt="" width="207" height="16"/></p>
			<p>Excellent, now you know how to decode UART serial messages.</p>
			<p>Okay, so you may ask, <em class="italic">UART is so simple, why would I use anything else?</em> Let's go over some pros and cons of UART.</p>
			<p>The <a id="_idIndexMarker135"/>pros are as follows:</p>
			<ul>
				<li>Cheap</li>
				<li>Full duplex (send and receive at the same time)</li>
				<li>Asynchronous (no clock line)</li>
				<li>Simple, with only two wires between each device</li>
				<li>Parity for error checking</li>
				<li>Widely used</li>
			</ul>
			<p>The cons are as follows:</p>
			<ul>
				<li>Maximum <a id="_idIndexMarker136"/>bits per frame of nine bits.</li>
				<li>Device clocks must be within 10% of each other.</li>
				<li>It is slow by modern standards, with standard bit rates ranging from 9,600-230,400 bits per second.</li>
				<li>Requires a direct connection between each device rather than a bus architecture.</li>
				<li>Some overhead with start and stop bits, demanding complex hardware for transmitting and receiving.</li>
			</ul>
			<p>If you would like to gain experience with UART and Python, the simplest device for you to test UART communication on, will be an Arduino. If you have one, great! You can then jump directly to the documentation on PySerial and start communicating with your Arduino. If you don't have an Arduino, you can find an example emulator code for practicing in the book's repository, in the <code>Chapter 2</code> folder:</p>
			<p><a href="https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2">https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2</a></p>
			<p>Next, you will learn about two different standards that use UART messages.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/>Differential versus single-ended</h2>
			<p>UART signals <a id="_idIndexMarker137"/>can be <a id="_idIndexMarker138"/>transmitted in a few different ways. The<a id="_idIndexMarker139"/> two <a id="_idIndexMarker140"/>most common are <strong class="bold">Recommended Standard 232</strong> (<strong class="bold">RS-232</strong>) and <strong class="bold">Recommended Standard 422</strong> (<strong class="bold">RS-422</strong>).</p>
			<p>RS-232 is a single-ended signal, meaning that its voltage is compared directly to the electrical ground of the system (0 V). The following figure depicts a single-ended signal:</p>
			<div><div><img src="img/B16322_02_07.jpg" alt="Figure 2.7 – Single-ended line" width="589" height="92"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Single-ended line</p>
			<p>In contrast, RS-422 is a differential signal, meaning the voltage is compared across the two wires independent of the electrical ground of the system:</p>
			<div><div><img src="img/B16322_02_08.jpg" alt="Figure 2.8 – Differential line" width="571" height="92"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – Differential line</p>
			<p>Now for storytime...</p>
			<p>Once upon a<a id="_idIndexMarker141"/> time, the signal was born, with one mission: to <a id="_idIndexMarker142"/>take messages from its senders to the far-off lands where receivers live. The world is full of goblins and ghosts that are conspiring against our hero signals. These goblins and ghosts trip and mangle our poor friend the signal. The longer the signal travels on its journey, the more these bad actors will sneak in and wreak havoc. Generally, on short sojourns, the signal is unaffected and passes through the enchanted forest relatively undisturbed. However, the longer the journey, the more the signal needs to find tricks, friends, and guardians to get to its receiver safely.</p>
			<p>So, who are these ghosts and goblins? They are electromagnetic fields and induced currents. You see, any time a ghost electromagnetic field moves near the signal's path (wire), it spawns a goblin (current) on the path. This goblin in turn uses its magical powers to stretch and shrink the signal's arms until it arrives at its destination, where the receiver sees the signal's arms as shorter or longer than they should be.</p>
			<p>But have no fear – the tricks, friends, and guardians are here! The signal has a great little trick to thwart the ghosts and goblins, but first it must spawn a doppelganger: we'll call it the langis (that's <em class="italic">signal</em> backward). The langis and the signal twist around each other on their way to the receiver. This confuses the ghosts and causes them to spawn two equal but opposite goblins that unwittingly smash into each other and vanish before they can use their magical powers.</p>
			<p>The other trick the langis and the signal have is that they promise to always hold hands and move together on their journey no matter what goblins strike them. So, when they arrive at their destination, the receiver just measures the distance between the langis and the signal to get the message!</p>
			<p>Okay, so <a id="_idIndexMarker143"/>what does this fairy tale look like in real life? Rather<a id="_idIndexMarker144"/> than having only one transmit wire, you instead use two wires. You then set one wire to be your high voltage (V+) and the other to be your low voltage (V-). Now when comparing the signals on the receiver side, you measure the voltage difference between V+ and V- to determine whether you have a high or low signal. The following figure shows a single-ended signal (1a) and a differential signal (1b):</p>
			<div><div><img src="img/B16322_02_09.jpg" alt="Figure 2.9 – Single-ended versus differential signal" width="312" height="157"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Single-ended versus differential signal</p>
			<p>This has the wonderful effect of having any induced noise affect both V+ and V- similarly, so that when you measure the difference between V+ and V-, it is unchanged from how it was when it was sent. The following figure illustrates what this looks like:</p>
			<div><div><img src="img/B16322_02_10.jpg" alt="Figure 2.10 – Noise on a differential line" width="973" height="571"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – Noise on a differential line</p>
			<p>The <a id="_idIndexMarker145"/>other trick was to twist the two wires of a differential<a id="_idIndexMarker146"/> pair around each other. This has the effect of canceling any induced currents in the wires. The following illustration shows the difference between straight cables and twisted pair cable currents. You can see that at each twist, the wires switch sides, so the noise current is alternating at each twist, effectively canceling itself out:</p>
			<div><div><img src="img/B16322_02_11.jpg" alt="Figure 2.11 – Noise cancellation on differential twisted pair cable" width="534" height="452"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – Noise cancellation on differential twisted pair cable</p>
			<p>So, what <a id="_idIndexMarker147"/>does this all mean for you when choosing between<a id="_idIndexMarker148"/> single-ended and differential?</p>
			<p>Here is a comparison table to help:</p>
			<div><div><img src="img/B16322_Table_01.jpg" alt="Table 2.1" width="1650" height="364"/>
				</div>
			</div>
			<p class="figure-caption">Table 2.1</p>
			<p>In the next section, you will learn about another form of serial communication that speeds things up a bit, along with some other very handy benefits.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>I2C</h2>
			<p><strong class="bold">I2C</strong>, or I2C, is <a id="_idIndexMarker149"/>short for <strong class="bold">Inter-Integrated Circuit</strong> and is another serial data transfer protocol with a few cool new features. More on those in a bit. I2C is commonly used to communicate between components on a single <strong class="bold">Printed Circuit Board</strong> (<strong class="bold">PCB</strong>). It <a id="_idIndexMarker150"/>boasts data rates of 100-400 kHz, which is generally supported, and the specification even has room for up to 5 MHz communication, although this is not commonly supported on many devices.</p>
			<p>You may ask, "Why use I2C? UART is already very simple and easy." Well, I2C adds some very cool features that you don't have with UART. Recall that UART requires two wires connected between each device, which means you need a connector for each device that you want to communicate with. This quickly spins an unmanageable web of wires when you want several devices interconnected. You also don't have the concept of master or slave in UART, since devices talk directly to each other on separate Tx and Rx lines. You can see an example of a fully connected UART architecture in the following figure:</p>
			<div><div><img src="img/B16322_02_12.jpg" alt="Figure 2.12 – Fully connected UART network" width="419" height="377"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – Fully connected UART network</p>
			<p>I2C to the rescue! I2C also uses<a id="_idIndexMarker151"/> only two wires: a <strong class="bold">Serial Clock Wire</strong> (<strong class="bold">SCL</strong>) and a <strong class="bold">Serial Data Wire</strong> (<strong class="bold">SDA</strong>) – more on how these work later. It uses these two wires to set up a<a id="_idIndexMarker152"/> new architecture between devices, a bus. A bus is simply a set of shared wires that transmits a signal to all devices attached to them. The following illustration will help us understand this better:</p>
			<div><div><img src="img/B16322_02_13.jpg" alt="Figure 2.13 – I2C bus architecture" width="329" height="142"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13 – I2C bus architecture</p>
			<p>This allows multiple <a id="_idIndexMarker153"/>devices to talk to each other without requiring dedicated lines from each device to every other device it needs to talk with.</p>
			<p>You might be thinking, <em class="italic">How can everyone be talking on the same lines and understand anything?</em> The I2C protocol implements the concept of master and slave devices. A master controls the flow of communication by announcing to everyone, <em class="italic">Hey, listen up everyone, I am talking to RasPi1, please acknowledge you are there, then send me data!</em> The master then gives control to RasPi1, who quickly shouts, <em class="italic">I'm here and have understood the request! Here is the data you requested; please acknowledge you received it</em>. The master then says, <em class="italic">Got it!</em> Then the process starts over. The following figure is a timing diagram of an I2C exchange:</p>
			<div><div><img src="img/B16322_02_14.jpg" alt="Figure 2.14 – I2C timing diagram" width="1650" height="405"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14 – I2C timing diagram</p>
			<p>Let's walk through a communication sequence. The sequence begins with the master pulling the SDA line low followed by pulling the SCL line low. This signifies the start condition. The next series of 7-10 bits (depending on your settings) is the address of the slave that is being spoken to. The next bit, the R/W bit, instructs the slave to either write to (logical 0) or read from (logical 1) its memory register. The bit that follows the R/W is the acknowledge (ACK) bit. This is set by the slave that is being addressed if it heard, understood, acknowledged, and will respond to the request. The master will then continue generating pulses on the SCL line while either the slave or the master starts placing data on the eight data bits on the SDA. </p>
			<p class="callout-heading">Bigger bits first</p>
			<p class="callout">Contrary to UART, bits are transmitted MSB first in I2C.</p>
			<p>For example, if the R/W bit was set to 0, the slave would receive the data being placed on the SDA and write it to memory. Immediately following the eight data bits, the slave will pull the SDA line low for one clock count to acknowledge that it received the data, stored it, and is ready to give back control of the SDA line to the master. At this point, the master pulls the SDA back low. Finally, to stop the sequence, the master will release the SCL followed by the SDA.</p>
			<p>When so many devices<a id="_idIndexMarker154"/> can be talking on the bus at the same time, it is important to have some rules to ensure that there is no clashing. I2C achieves this by using an <em class="italic">open-drain</em> system, which simply means that any master or slave can only pull the line to ground. The idle states of the SCL and SDA are held in the high voltage state through pull-up resistors. This can be seen in <em class="italic">Figure 2.13</em> with the resistors connected to VDD. When a master or slave wants to send data, they pull the line to ground (or open the drain). This ensures that you will never have one device driving the line high while another is driving it low.</p>
			<p>Another interesting feature of the I2C protocol is that not only can there be multiple slave devices on the bus, but there can also be multiple masters. Here, you'll ask, <em class="italic">But wait, you said the master controls the flow. How will we know who is in control?</em> The genius in this architecture is that every device is connected to the same lines (bus), so they can all see what is happening at any given time. So, if two masters are trying to control the bus at nearly the same time, the first one to pull the SDA line low wins! The other master backs off and becomes a temporary slave. There is a case when two masters pull low at the exact same time and it is unclear who has control. In this case, arbitration begins. The first master to release to high on the SDA loses arbitration and becomes a slave.</p>
			<p class="callout-heading">Easter Egg</p>
			<p class="callout">If a hen and a half lay an egg and a half in a day and a half, how many eggs will half a dozen hens lay in half a dozen days? Decode the following signal for the answer!</p>
			<p class="callout"><img src="img/B16322_02_Art2.png" alt="" width="175" height="27"/></p>
			<p>Here is a summary of the benefits and disadvantages of I2C.</p>
			<p>These are the <a id="_idIndexMarker155"/>benefits:</p>
			<ul>
				<li>A multiple-master, multiple-slave architecture, up to 1,024 devices in 10-bit address mode</li>
				<li>Bus-based with only two wires (SCL and SDA) required</li>
				<li>Speeds of up to 5 MHz</li>
				<li>Inexpensive</li>
				<li>Message acknowledgment</li>
			</ul>
			<p>These are the<a id="_idIndexMarker156"/> disadvantages:</p>
			<ul>
				<li>Half-duplex, cannot transmit and receive at the same time.</li>
				<li>Overhead of start, stop, and acknowledge conditions reduces throughput.</li>
				<li>The pull-up resistors limit clock speed, eat up PCB space, and increase power dissipation.</li>
				<li>Short maximum wire lengths (1 cm–2 m) dependent on capacitance, resistance, and speed.</li>
			</ul>
			<p>You have learned a lot about I2C, which has armed you with even more knowledge about dealing with serial data. In the next section, you will learn about yet another serial communication protocol with a bit more spunk but traded for something else.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>SPI</h2>
			<p><strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) is <a id="_idIndexMarker157"/>a serial transmission link used primarily in microcontrollers to link peripherals such as USB, memory, and onboard sensors. Its main advantage is its speed and the simplicity of is implementation. SPI is not commonly used for sensors that you will be using in your self-driving car applications, but it is worth knowing a bit about in case you come across it. It is a full-duplex link with four wires used: SCLK, MOSI, MISO, and SS. The following illustration will help as we talk through their functions:</p>
			<div><div><img src="img/B16322_02_15.jpg" alt="Figure 2.15 – SPI connection diagram" width="1046" height="809"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15 – SPI connection diagram</p>
			<p>SPI is a synchronous serial link that uses a master clock signal (SCLK), much like what you learned about in I2C. The clock rate is typically in the region of 6-12.5 MHz, which is also its bit rate. The data is passed between devices on <a id="_idIndexMarker158"/>the <strong class="bold">Master Out Slave In</strong> (<strong class="bold">MOSI</strong>) and <strong class="bold">Master In Slave Out</strong> (<strong class="bold">MISO</strong>) lines. MOSI, MISO, and SCLK can be used as a bus <a id="_idIndexMarker159"/>architecture, much like I2C. The final wire is the <strong class="bold">Slave Select</strong> (<strong class="bold">SS</strong>) wire. This is pulled low to notify the slave connected to it that it should listen to the coming message.</p>
			<p>This contrasts with I2C, which sent the slave address the information about which slave to listen for. As you can see in <em class="italic">Figure 2.15</em>, a separate wire and pin must be dedicated to each slave that is added to the system (denoted by <em class="italic">SS1</em>, <em class="italic">SS2</em>, and <em class="italic">SS3</em> in the figure). The hardware used to implement SPI is quite simple and usually relies on shift-registers. <em class="italic">What is a shift-register?</em> you say. Well, this is a simple memory register that holds a certain number of bits, say, eight. Each time a new<a id="_idIndexMarker160"/> bit is brought in from one side, a bit from the other side is pushed out. The following figure illustrates how this works in SPI:</p>
			<div><div><img src="img/B16322_02_16.jpg" alt="Figure 2.16 – SPI shift register" width="927" height="187"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16 – SPI shift register</p>
			<p>SPI data transfer is very simple since there is only one master allowed on the bus. The following figure helps to illustrate how SCK, MOSI, MISO, and SS are used to conduct the transfer of data in full duplex:</p>
			<div><div><img src="img/B16322_02_17.jpg" alt="Figure 2.17 – SPI timing diagram" width="627" height="425"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.17 – SPI timing diagram</p>
			<p>The master pulls the SS line<a id="_idIndexMarker161"/> low, which lets the target slave know, <em class="italic">Hey, SS1, this message is for you, please be ready to receive.</em> Then the master sends clock pulses on the SCK line that tell the slave when they should sample the data coming on MOSI. If it has been predetermined that the slave should send something back, the master then follows with SCK pulses for when the slave should send data on the MISO line. Since there are two lines, MISO and MOSI, these two transactions can happen at the same time using shift-register format.</p>
			<p>SPI is not standardized like UART or I2C in terms of protocol. Because of this, you will need to consult the interface control documents for the devices that you want to connect to determine the specific commands, register sizes, clock modes, and so on that are required to operate the device.</p>
			<p>You can see there is no overhead in SPI as there was in UART and I2C. There are no start bits, addresses, stop bits, acknowledge bits, or any other overhead. It is pure, sweet, high-speed data. On the other hand, there is a lot more programming and prearranged setup needed to communicate between two devices. SPI also can drive high and low on the data lines, allowing to slew faster from a <code>0</code> to a <code>1</code>, which leads to the faster transmission rate discussed.</p>
			<p>So, let's summarize the pros and cons.</p>
			<p>These are the <a id="_idIndexMarker162"/>pros:</p>
			<ul>
				<li>Fast data rates of 6-12.5 MHz</li>
				<li>Full-duplex communication</li>
				<li>Simple shift-register hardware can be used</li>
				<li>Multiple slaves</li>
				<li>Bus architecture</li>
			</ul>
			<p>These are the<a id="_idIndexMarker163"/> cons:</p>
			<ul>
				<li>Single master only</li>
				<li>Four wires needed, plus a slave select wire for each slave.</li>
				<li>Short transmission length dependent on speed, impedance, and capacitance with a max estimated at 3 m</li>
			</ul>
			<p>In the next section, we will discuss a very common protocol that is used in nearly every vehicle on the road! Start your engines!</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/>Framed-based serial protocols</h1>
			<p>Up until now, we <a id="_idIndexMarker164"/>have been discussing protocols that have fairly small message sizes in the region of 8-10 bits. What if you want to send more? In the next few sections, you will learn about protocols that support larger message sizes and package them into frames or packets.</p>
			<p>You will learn about the following protocols:</p>
			<ul>
				<li>CAN</li>
				<li>Ethernet: UDP and TCP</li>
			</ul>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>Understanding CAN</h2>
			<p><strong class="bold">Controller Area Network</strong> (<strong class="bold">CAN</strong>) is <a id="_idIndexMarker165"/>a message-based protocol that was <a id="_idIndexMarker166"/>developed, by Bosch, to reduce the number of wires connecting the ever-growing number of<a id="_idIndexMarker167"/> microcontrollers and <strong class="bold">Electronic Control Units</strong> (<strong class="bold">ECUs</strong>) in vehicles.</p>
			<p>It is a bus-based protocol with two wires acting as a differential pair, CAN-HI and CAN-LO. You learned about differential pairs in the <em class="italic">Single-ended versus differential</em> section. </p>
			<p class="callout-heading">Ghost and goblins</p>
			<p class="callout">Do you recall the trick we used to provide safe passage to the langis and the signal on their journey? There is a real <em class="italic">twist</em> to that story.</p>
			<p>CAN is a feature-packed protocol that is very robust, reliable, and rapid. Here are some of the features of <a id="_idIndexMarker168"/>the protocol:</p>
			<ul>
				<li>Decentralized multi-master communication</li>
				<li>Prioritized messages</li>
				<li>Bus arbitration</li>
				<li>Remote terminal request</li>
				<li>Data integrity with cyclic redundancy checks</li>
				<li>Flexible expandable network</li>
				<li>Centralized diagnostics and configuration</li>
				<li>EMI noise rejection through a twisted differential pair</li>
			</ul>
			<p>The CAN bus architecture is devilishly simple and is illustrated in the following figure:</p>
			<div><div><img src="img/B16322_02_18.jpg" alt="Figure 2.18 – CAN bus architecture" width="1650" height="439"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.18 – CAN bus architecture</p>
			<p>You can see that nodes <a id="_idIndexMarker169"/>may be added anywhere <a id="_idIndexMarker170"/>on the bus inside of the bus terminations, Rterm. A consideration when connecting a node is the unterminated stub length, which the standard recommends keeping below 0.3 m.</p>
			<p>Now let's see how bits are transmitted on the CAN HI and CAN LO differential twisted pair lines. The figure that follows illustrates the dominant and recessive voltages of the CAN protocol:</p>
			<p class="callout-heading">Zero to hero</p>
			<p class="callout"><code>0</code> rules the bus with its dominant differential voltage rising up above the minimum threshold.</p>
			<p class="callout-heading">One and done</p>
			<p class="callout"><code>1</code> sleeps on the bus with its recessive differential voltage, which lies below the minimum threshold.</p>
			<div><div><img src="img/B16322_02_19.jpg" alt="Figure 2.19 – CAN dominant and recessive voltages" width="1285" height="408"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.19 – CAN dominant and recessive voltages</p>
			<p class="figure-caption">By EE JRW – ow<a href="https://commons.wikimedia.org/w/index.php?curid=55237229">n work, CC BY-SA 4.0, https://commons.wikimedia.org/w/in</a>dex.php?curid=55237229</p>
			<p>Now that you see how bits are<a id="_idIndexMarker171"/> placed on the bus, let's look at the CAN frame structure. This will be useful if you find yourself debugging or reading CAN bus traffic. The following figure depicts the segments of a CAN frame:</p>
			<div><div><img src="img/B16322_02_20.jpg" alt="Figure 2.20 – CAN message format" width="761" height="179"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.20 – CAN message format</p>
			<p>CAN frames<a id="_idIndexMarker172"/> begin with a <code>0</code>, which is the dominant differential voltage. This may sound a bit similar to what you learned in UART communication, which also started with a logical <code>0</code>. Much like in UART, the SOF bit in CAN is a transition from an idle state to an active one. Unlike UART, however, the active and dominant state is a high voltage state.</p>
			<p>Following the SOF bit is the arbitration field. This can be thought of as the ECU's functional address (for example, the steering module, oxygen sensor, lidar sensor, and so on).</p>
			<p class="callout-heading">Less is best</p>
			<p class="callout">ECUs with a smaller address in the arbitration fields are considered higher priority in the CAN protocol. The smaller address will win the arbitration when two or more devices start transmitting at the same time.</p>
			<p>The <a id="_idIndexMarker173"/>next bit is the <code>1</code>, the recessive state.</p>
			<p>The next six bits are the <strong class="bold">Data Length Code</strong> (<strong class="bold">DLC</strong>) section of the frame, which says how long the upcoming data field will be. The data for a CAN message can be 0 to 8 bytes in length.</p>
			<p>Immediately following the DLC is the data, which can be 0-64 (0-8 bytes) bits in length.</p>
			<p class="callout-heading">Bit order</p>
			<p class="callout">CAN sends its information with the MSB first.</p>
			<p>Next is the <strong class="bold">Cyclic Redundancy Check</strong> (<strong class="bold">CRC</strong>) field, which is 15 bits long and is used for error checking the message. The sending ECU performs a checksum calculation on the data field and places this in the CRC field. Once the receiving ECU gets the frame, it runs the same checksum calculation on the data field and verifies that it matches the CRC field in the received frame. The CRC is immediately followed by the CRC delimiter field to give it separation from the ACK bit.</p>
			<p>The <code>1</code> recessive so that any receiving ECU can acknowledge receipt of the error-free data during this bit interval. The ACK bit is followed by the ACK delimiter to allow for any timing difference that overruns the ACK bit.</p>
			<p>Finally, the <code>1</code> bits, which indicate – you guessed it – the end of the frame.</p>
			<p>Okay, one more thing: there is an <strong class="bold">Inter Frame Space</strong> (<strong class="bold">IFS</strong>), which is defined by the CAN controller of the system.</p>
			<p>Sweet – that was long. Don't worry, though; CAN is a very well-supported protocol and there are plenty of software and hardware modules that you can find that will do the heavy lifting for you. You will likely only need to dust this knowledge off when things aren't working right and you pull out the old oscilloscope to probe the CAN bus and verify that messages are transmitting properly.</p>
			<p>Let's recap the pros and cons of the CAN bus protocol.</p>
			<p>These are<a id="_idIndexMarker174"/> the pros:</p>
			<ul>
				<li>Decentralized multi-master communication</li>
				<li>Prioritized messages</li>
				<li>Bus arbitration</li>
				<li>RTR</li>
				<li>Data integrity with CRCs</li>
				<li>Flexible, expandable network</li>
				<li>Centralized diagnostics and configuration</li>
				<li>EMI noise rejection through a twisted differential pair </li>
				<li>Maximum cable length of 40 m</li>
			</ul>
			<p>This is the <a id="_idIndexMarker175"/>only con, really:</p>
			<ul>
				<li>Careful attention to the wiring bus terminations and stub lengths is needed.</li>
			</ul>
			<p>In the next section, you will learn about the most ubiquitous networking protocols used in modern times, both in cars and at home.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Ethernet and internet protocols</h2>
			<p>Ethernet<a id="_idIndexMarker176"/> is a framework <a id="_idIndexMarker177"/>of protocols and layers<a id="_idIndexMarker178"/> that is used in modern <a id="_idIndexMarker179"/>networking in nearly every application you interact with today. Ethernet is in your home, the train you ride, the plane you fly in, and definitely in your self-driving car. It consists of both the physical and protocol standards for network-based communication. It all starts with the <strong class="bold">Open Systems Interconnection</strong> (<strong class="bold">OSI</strong>) model of<a id="_idIndexMarker180"/> the different layers. The following figure illustrates the seven layers of the OSI model and what each layer is tasked with:</p>
			<div><div><img src="img/B16322_02_21.jpg" alt="Figure 2.21 – The seven layers of the OSI model" width="840" height="623"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.21 – The seven layers of the OSI model</p>
			<p>Each of<a id="_idIndexMarker181"/> these layers has its own protocol for processing data. It <a id="_idIndexMarker182"/>all starts with the raw data, or bits, at the application layer. The data<a id="_idIndexMarker183"/> gets processed at each layer to <a id="_idIndexMarker184"/>be passed onto the next layer. Each layer wraps the previous layer's frame into a new frame, which is why the model shows the frames getting larger and larger. The following figure illustrates the protocols at each layer:</p>
			<div><div><img src="img/B16322_02_22.jpg" alt="Figure 2.22 – Protocols of the OSI model" width="1100" height="776"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.22 – Protocols of the OSI model</p>
			<p>We could spend an entire book talking about the details of each layer and protocol. Instead, we will focus on two protocols (UDP and TCP) that you will encounter when working with sensors and actuators in a self-driving car.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>Understanding UDP</h2>
			<p><strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) is a<a id="_idIndexMarker185"/> very popular protocol for <a id="_idIndexMarker186"/>sensors such as lidars, cameras, and radars. It is a connection-less protocol. <em class="italic">Wait – if it's connection-less, how is it sending data?</em> Connection-less, in this sense, just means that the protocol doesn't verify that it can reach the destination before it sends data. UDP lives on the transport layer of the OSI model. You can see in the following figure that the transport layer is the first layer to add a header:</p>
			<div><div><img src="img/B16322_02_23.jpg" alt="Figure 2.23 – UDP on the transport layer" width="1604" height="665"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.23 – UDP on the transport layer</p>
			<p>If you were sending a <a id="_idIndexMarker187"/>gift to someone, what would you want them to know <a id="_idIndexMarker188"/>about the gift so that they could be confident that it was intended for them and was not swapped for someone else's gift? You might say something like, <em class="italic">Tenretni Olleh, I am sending you this luxurious pair of rainbow pajamas in size large and I hope they fit. Please try them on.</em> This is exactly what the UDP header's function is. It stores the source port, the destination port, the length of the data including the header, and finally a checksum. The checksum is simply a number that is created with an algorithm before the data is sent to ensure that when it is received, the data is intact and not corrupted. This is done by running the same algorithm on the received data and comparing the number generated to the checksum value. This is akin to sending a picture of the pajamas that were sent to Tenretni so they knew they received the correct gift.</p>
			<p>The following figure illustrates the fields within a UDP header and the actual message itself:</p>
			<div><div><img src="img/B16322_02_24.jpg" alt="Figure 2.24 – UDP header fields" width="1179" height="316"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.24 – UDP header fields</p>
			<p class="callout-heading">Port, plugs, and sockets</p>
			<p class="callout">A port in the Ethernet protocol can be thought of like a power socket in your wall. You plug different devices into the sockets, such as lamps and TVs. Each plug, once connected, serves a specific device power. Similarly, a port is where a digital socket is created for a specific device or protocol to send and/or receive data.</p>
			<p>The UDP header<a id="_idIndexMarker189"/> is always 8 bytes (64 bits), while the data (message) can be up <a id="_idIndexMarker190"/>to 65,507 bytes in length. The following figure is a relevant example, to self-driving cars, of the data (message) field size of a UDP packet from a popular family of high-resolution lidar sensors:</p>
			<div><div><img src="img/B16322_02_25.jpg" alt="Figure 2.25 – Ouster lidar UDP data structure" width="1292" height="1282"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.25 – Ouster lidar UDP data structure</p>
			<p>You can see <a id="_idIndexMarker191"/>from this, if<a id="_idIndexMarker192"/> you carefully multiply all the bytes, that you get 389 words * 4 bytes/word * 16 azimuths/packet = 24,896 bytes/packet. This is well within the data limit size of a UDP packet, 65,507 bytes. In order to send this data over UDP, what must the lidar sensor append to this data? You guessed it – there needs to be a UDP header with the 8 bytes of source, destination, data length, and checksum information.</p>
			<p>UDP is often used for streaming-type devices such as lidar sensors, cameras, and radars since it does not make sense to resend data if it is not received. Imagine you didn't receive a few azimuths in the lidar sensor example. Would it be useful to you to have that data resent to you? Probably not, since whatever the lasers bounced off is now in the past and <a id="_idIndexMarker193"/>likely in<a id="_idIndexMarker194"/> a different position. Another reason to use UDP for such devices is that due to the high data rates, it would slow things down tremendously to have to resend lost or corrupted data.</p>
			<p>In the next section, we will discuss a protocol that will address cases where you might want to ensure that there is a three-way handshake for each packet of data.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Understanding TCP</h2>
			<p>If you were going to send a command to turn the steering wheel of your self-driving car, would you be okay if the command never made it, was wrong, or corrupted? Would you be okay if you didn't know whether the steering actuator received the command? Probably not!</p>
			<p>This is where <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) can serve you! TCP operates similarly<a id="_idIndexMarker195"/> to UDP...well, actually, it's <a id="_idIndexMarker196"/>completely different. Unlike UDP, TCP is a connection-based protocol. This means that each time you want to send data, you need to do a three-way handshake. This is done through a process known as SYN-SYN/ACK-ACK. Let's break that down to understand it better:</p>
			<ul>
				<li>SYN – The client sends a SYN (synchronization) packet with a randomly selected initial sequence number (<code>x</code>), which is used to count the bytes that are being sent. It also sets the SYN bit flag to <code>1</code> (more on this later).</li>
				<li>SYN/ACK – The server receives the SYN packet:</li>
			</ul>
			<ol>
				<li value="1">It increments <code>x</code> by one. This becomes the acknowledgement (ACK) number (<code>x+1</code>), which is the number of the next byte it expects.</li>
				<li>It then sends a SYN/ACK packet back to the client with the ACK number as well as the server's own randomly selected sequence number (<code>y</code>).<ul><li>ACK – The client receives the SYN/ACK packet with the ACK number (<code>x+1</code>) and server sequence number (<code>y</code>):</li></ul><ol><li value="1">It increments the server's initial sequence number to <code>y+1</code>.</li><li>It sends an ACK packet with the ACK number (<code>y+1</code>) and ACK bit flag set to <code>1</code> back to the server to establish the connection.</li></ol></li>
			</ol>
			<p>The following diagram <a id="_idIndexMarker197"/>illustrates the <a id="_idIndexMarker198"/>connection sequence:</p>
			<div><div><img src="img/B16322_02_26.jpg" alt="Figure 2.26 – TCP connection sequence diagram" width="1650" height="597"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.26 – TCP connection sequence diagram</p>
			<p>Now the connection is established and data can begin to flow. Each packet that is sent will be followed by an ACK packet with the number of bytes received plus one, indicating that the packet was received intact and what byte number it expects next. The sequence number is incremented by one for SYN and SYN/ACK packets and by the number of bytes of payload received for ACK packets.</p>
			<p>You can already see that in order to do all this, the header is going to need more fields than with UDP. The following figure illustrates the fields of a TCP header:</p>
			<div><div><img src="img/B16322_02_27.jpg" alt="Figure 2.27 – TCP header fields" width="676" height="219"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.27 – TCP header fields</p>
			<p>Let's unpack each field<a id="_idIndexMarker199"/> and its purpose:</p>
			<ul>
				<li><strong class="bold">Source port</strong>: This is the port the <a id="_idIndexMarker200"/>packet is sent from. This is usually a randomly assigned port number.</li>
				<li><code>22</code>. A list of well-known ports can be found at this link: <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.</a></li>
				<li><strong class="bold">Sequence number</strong>: This is the number of the first byte being sent in the payload; or, for SYN and SYN/ACK packets, it is the randomly selected initial sequence number.</li>
				<li><strong class="bold">Acknowledgment number</strong>: This is the number of bytes that have been received plus one, indicating the next byte number expected.</li>
				<li><strong class="bold">Data offset</strong>: This is the length of the TCP header, that is, the offset before the payload.</li>
				<li><strong class="bold">Reserved</strong>: These are bits that are unused but reserved for future protocol improvements.</li>
				<li><code>0</code> or <code>1</code>). This is used to mark a packet as urgent.</li>
				<li><code>ACK</code> bit flag, which is set to <code>1</code> when a valid acknowledgment number is being sent.</li>
				<li><code>1</code> when the data should be pushed to the application immediately.</li>
				<li><code>1</code> when the connection needs to be<a id="_idTextAnchor060"/> reset.</li>
				<li><code>1</code> when the SYN-SYN/ACK connection establishment process is initiated. It indicates that there is a valid sequence number in the sequence number field.</li>
				<li><code>1</code> when the connection should be closed after all data is sent.</li>
				<li><strong class="bold">Window</strong>: This is the size of the buffer that the receiving end can accept before losing data.</li>
				<li><code>payload+header</code> that is used to verify that the data received is valid and unchanged.</li>
				<li><code>URG</code> bit flag is set to <code>1</code>.</li>
			</ul>
			<p>TCP uses all this header information for the task of ensuring that all data is received, verified, and acknowledged. If data is ever missed, the last valid sequence number can be used to resend the data. Now you can send your steering commands over Ethernet with confidence, knowing th<a id="_idTextAnchor061"/>at you won't go careening off a cliff!</p>
			<p class="callout-heading">Cars use CAN, mostly...</p>
			<p class="callout">Although we used steering as an example for TCP here, you will typically find that vehicle control commands are sent using CAN bus over Ethernet bus from the factory. Increasingly, though, self-driving car creators are relying on Ethernet for its higher data throughput and security. There is talk of moving to Ethernet bus for factory vehicles in the future. Military aircraft have already started doing so!</p>
			<p>Okay – goodness, that was a lot to take in. Do not worry, though: now that you have seen this once and understand it, you can rely on open source tools to parse through this in the future. Where you will find this useful is when things start going wrong and you need to debug the traffic flow of your data.</p>
			<p>Speaking of which, Wireshark is a fantastic tool for <strong class="bold">sniffing</strong> Ethernet packets on your network and seeing the flow of information for debugging and testing. You can find all the information you need on installation and use at <a href="https://www.wireshark.org/">https://www.wireshark.org/</a>.</p>
			<p>As you can see, TCP is a powerful protocol for connection-based, highly reliable, and secure data transfer. Now get out there and start using the Ethernet protocol with the open source tools listed at the end of this chapter!</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor062"/>Summary</h1>
			<p>Congratulations, you have completed your quest with your new friends, the langis and the signal! You have had quite an adventure! You battled ghosts and goblins in the form of electromagnetic waves and induced currents. You learned so much along the way about serial versus parallel data transfer; digital versus analog signals; and protocols such as UART, I2C, SPI, CAN, UDP, and TCP and their secret decoder rings! You are now armed with the knowledge you will need when integrating sensors and actuators into your real self-driving car.</p>
			<p>In the next chapter, you will learn how to use OpenCV to detect lanes on the road, a vital skill to ensure the safe and legal operation of your self-driving car!</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor063"/>Questions</h1>
			<p>After reading this chapter, you should be able to answer the following questions:</p>
			<ol>
				<li value="1">How many wires does each protocol require and what are their names?</li>
				<li>What are two methods to reduce noise in a signal?</li>
				<li>What is the difference between serial and parallel data transmission?</li>
				<li>Which protocols use a bus architecture?</li>
				<li>Which protocols have a clock signal?</li>
				<li>What protocol is used widely to send GPS information to other sensors?</li>
			</ol>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>Further reading</h1>
			<ul>
				<li>Texas Instruments Controller Area Network Physical Layer Requirements (<a href="http://www.ti.com/lit/an/slla270/slla270.pdf?HQS=slla270-aaj&amp;ts=1589256007656">http://www.ti.com/lit/an/slla270/slla270.pdf?HQS=slla270-aaj&amp;ts=1589256007656</a>)</li>
				<li>Texas Instruments Introduction to the Controller Area Network (CAN) (<a href="http://www.ti.com/lit/an/sloa101b/sloa101b.pdf">http://www.ti.com/lit/an/sloa101b/sloa101b.pdf</a>)</li>
				<li>Universal Asynchronous Receiver and Transmitter (UART) (<a href="https://ieeexplore.ieee.org/document/7586376">https://ieeexplore.ieee.org/document/7586376</a>)</li>
				<li>Understanding the I2C Bus (<a href="http://www.ti.com/lit/an/slva704/slva704.pdf?&amp;ts=1589265769229">http://www.ti.com/lit/an/slva704/slva704.pdf?&amp;ts=1589265769229</a>)</li>
			</ul>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>Open source protocol tools</h2>
			<p>You can also refer to the following resources to learn more about the tools for programming with the protocols covered:</p>
			<ul>
				<li><code>PySerial</code> (<a href="https://pypi.org/project/pyserial/">https://pypi.org/project/pyserial/</a>) for UART (RS-232, RS-422, RS-485)</li>
				<li><code>python-periphery</code> (<a href="https://python-periphery.readthedocs.io/en/latest/index.html">https://python-periphery.readthedocs.io/en/latest/index.html</a>) for UART, I2C, SPI, and more</li>
				<li><code>smbus2</code> (<a href="https://pypi.org/project/smbus2/">https://pypi.org/project/smbus2/</a>) for I2C</li>
				<li><code>spidev</code> (<a href="https://pypi.org/project/spidev/">https://pypi.org/project/spidev/</a>) for SPI</li>
				<li><code>python-can</code> (<a href="https://pypi.org/project/python-can/">https://pypi.org/project/python-can/</a>) for CAN</li>
				<li><code>socket</code> (<a href="https://docs.python.org/3/library/socket.html">https://docs.python.org/3/library/socket.html</a>) for Ethernet TCP, UDP, and more</li>
			</ul>
		</div>
	</div>



  </body></html>