- en: Modeling the Differential Drive Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to model the differential drive robot and
    create the URDF model of this robot in ROS. The main use case of the robot that
    we are going to design in this chapter is to serve food and drinks in hotels and
    restaurants. The robot is named *Chefbot.* We will cover the complete modeling
    of this robot in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the CAD design of various mechanical components used in this
    robot and how to assemble them. We will look at the 2D and 3D CAD design of this
    robot and will discuss how to create the URDF model of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: The actual robot model deployed in hotels may be big in size, but here we intend
    to build a miniature version for testing our software. If you are interested in
    building a robot from scratch, this chapter is for you. If you are not interested
    in building the robot, you can choose some robotic platforms, such as Turtlebot,
    which are already available on the market, to work with this book.
  prefs: []
  type: TYPE_NORMAL
- en: To build the robot hardware, first we need to get the requirements of the robot.
    After getting the requirements, we can design it and draw the model in 2D CAD
    tools to manufacture the robot parts. The 3D modeling of the robot will give us
    more idea about the looks of the robot. After the 3D modeling, we can convert
    the design into a URDF model that can be used along with ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing robot parameters from the given specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing robot body parts in 2D using LibreCAD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a 3D robot model using Blender and Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a URDF model for Chefbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing the Chefbot model in Rviz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test the application and code in this chapter, you need an Ubuntu 16.04 LTS
    PC/laptop with ROS Kinetic installed
  prefs: []
  type: TYPE_NORMAL
- en: Requirements of a service robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before designing any robotic system, the first procedure is to identify the
    requirements of the system. The following are the set of robot design requirements
    to be met by this robot. This includes hardware and software requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot should have a provision to carry food
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot should carry a maximum payload of 2 kg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot should move at a speed between 0.25 m/s and 0.35 m/s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground clearance of the robot should be greater than 3 cm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot has to work for 2 hours continuously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot should be able to move and supply food to any table, avoiding obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot height can be between 80 cm and 100 cm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot should be of low cost (less than 500 USD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have the design requirements, such as payload, speed, ground clearance,
    robot height, cost of the robot, and the capabilities to be implemented in the
    robot, we can design a robot body and select components that are matching the
    aforementioned requirements. Let's discuss the robot mechanism we can use to match
    these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Robot drive mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the cost-effective solutions for mobile robot navigation is the differential
    drive system. It''s one of the simplest drive mechanisms for a mobile robot and
    is mainly indented for indoor navigation. The **differential drive robot** consists
    of two wheels mounted on a common axis controlled by two separate motors. There
    are two supporting wheels called caster wheels. This ensures stability and weight
    distribution of the robot. The following diagram shows a typical differential
    drive system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77e74c2b-f427-4faf-9627-e7d2f86925ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Differential drive system
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to select the mechanical components of this robot drive system,
    that is, mainly motors, wheels, and robot chassis. Based on the requirements,
    we will first discuss how to select the motor.
  prefs: []
  type: TYPE_NORMAL
- en: Selection of motors and wheels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Motors are selected after a look at the specifications. Some of the important
    parameters for motor selection are torque and RPM. We can compute these values
    from the given requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Calculation of RPM of motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The range of speed required for this robot is from 0.25 to 0.35m/s. We can take
    the maximum speed of this robot as 0.35 m/s for the design. Take the diameter
    of the wheel as 9 cm, because according to the requirement, the ground clearance
    should be greater than 3 cm and we will fix the robot body in same level as the
    motor shaft. In that case, we will get more ground clearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following equation, we can calculate the RPM of the motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '*RPM = ((60 * Speed /(3.14 * Diameter of Wheel)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*RPM = (60 * 0.35)/(3.14 * 0.09) = 21 / 0.2826 = 74 RPM*'
  prefs: []
  type: TYPE_NORMAL
- en: You can also take a look at [http://www.robotshop.com/blog/en/vehicle-speed-rpm-and-wheel-diameter-finder-9786](http://www.robotshop.com/blog/en/vehicle-speed-rpm-and-wheel-diameter-finder-9786)
    for the computation.
  prefs: []
  type: TYPE_NORMAL
- en: The calculated RPM with a 9 cm diameter wheel and 0.35 m/s speed is 74 RPM.
    We can consider 80 RPM as the standard value.
  prefs: []
  type: TYPE_NORMAL
- en: Calculation of motor torque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s calculate the torque required to move the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of wheels = Four wheels including two caster wheels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Number of motors = Two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's assume the coefficient of friction is 0.6 and radius of the wheel is 4.5
    cm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the total weight of robot = weight of robot + payload = (W = mg) = (~100
    N + ~20 N) W= ~ 150 N, whereas total mass = 12 Kg.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The weight acting on the four wheels can be written as *2 * N1 + 2 * N2 = W*;
    that is, *N1* is the weight acting on each caster wheel and *N2* on motor wheels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume that the robot is stationary. The maximum torque is required when the
    robot starts moving. It should also overcome friction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can write the frictional force as robot torque = 0 until the robot moves.
    If we get the robot torque in this condition, we get the maximum torque as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*µ * N * r - T = 0*, where *µ* is the coefficient of friction, *N* is the average
    weight acting on each wheel, *r* is the radius of wheels, and *T* is the torque.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N = W/2* (in the robot, actuation is only for two wheels, so we are taking
    W/2 for computing the maximum torque).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we get: *0.6 * (120/2) * 0.045 - T = 0*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, **T = 1.62 N-m or 16.51 Kg-cm**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The design summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the design, we calculate the following values and rounding to standard
    motor specifications that are available in the market:'
  prefs: []
  type: TYPE_NORMAL
- en: Motor RPM = 80 (rounding to standard value)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor torque = 18 kg-cm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wheel diameter = 9 cm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot chassis design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After computing the robot's motors and wheels parameters, we can design the
    robot chassis or robot body. As required, the robot chassis should have a provision
    to hold food, it should be able to withstand up to 5 kg payload, the ground clearance
    of the robot should be greater than 3 cm, and it should be low in cost. Apart
    from this, the robot should have a provision to place electronics components,
    such as a **personal computer** (**PC**), sensors, and a battery.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the easiest designs to satisfy these requirements is a multi-layered
    architecture such as Turtlebot 2 (http://www.turtlebot.com/). It has three layers
    in the chassis. The robot platform called **Kobuki** (http://kobuki.yujinrobot.com/about2/)
    is the primary drive mechanism of this platform. The Roomba platform has motors
    and sensors inbuilt, so there is no need to worry about designing the robot drive
    system. The following image shows the **TurtleBot 2** robot chassis design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c92d9887-5210-4ed3-9e3d-12a3201ce345.png)'
  prefs: []
  type: TYPE_IMG
- en: TurtleBot 2 robot (http://robots.ros.org/turtlebot/)
  prefs: []
  type: TYPE_NORMAL
- en: We will design a robot similar to TurtleBot 2 with our own moving platform and
    components. Our design also has a three-layer architecture. Let's identify all
    the tools that we need before we start designing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start designing the robot chassis, we need **computer-aided design**
    (**CAD**) tools. The popular tools available for CAD are:'
  prefs: []
  type: TYPE_NORMAL
- en: SolidWorks ([http://www.solidworks.com/default.html](http://www.solidworks.com/default.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AutoCAD ([http://www.autodesk.com/products/autocad/overview](http://www.autodesk.com/products/autocad/overview))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maya ([http://www.autodesk.com/products/maya/overview](http://www.autodesk.com/products/maya/overview))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventor ([http://www.autodesk.com/products/inventor/overview](http://www.autodesk.com/products/inventor/overview))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SketchUp ([http://www.sketchup.com/](http://www.sketchup.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blender ([http://www.blender.org/download/](http://www.blender.org/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LibreCAD ([http://librecad.org/cms/home.html](http://librecad.org/cms/home.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chassis design can be designed in any software you are comfortable with.
    Here, we will demonstrate the 2D model in **LibreCAD** and 3D model in **Blender**.
    One of the highlights of these applications is that they are free and available
    for all OS platforms. We will use a 3D mesh viewing tool called **MeshLab** to
    view and check the 3D model design and use Ubuntu as the main operating system.
    Also, we can see the installation procedures of these applications in Ubuntu 16.04
    to start the designing process. We will provide tutorial links to install applications
    in other platforms too.
  prefs: []
  type: TYPE_NORMAL
- en: Installing LibreCAD, Blender, and MeshLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LibreCAD** is a free, open source 2D CAD application for Windows, OS X, and
    Linux. **Blender** is a free, open source 3D computer graphics software used to
    create 3D models, animation, and video games. It comes with a GPL license, allowing
    users to share, modify, and distribute the application. **MeshLab** is an open
    source, portable, and extensible system to process and edit unstructured 3D triangular
    meshes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the links to install LibreCAD in Windows, Linux, and OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://librecad.org/cms/home.html](http://librecad.org/cms/home.htmlhttp:/librecad.org/cms/home.html)
    to download LibreCAD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [http://librecad.org/cms/home/from-source/linux.html](http://librecad.org/cms/home/from-source/linux.html) [to
    build LibreCAD from source](http://librecad.org/cms/home/from-source/linux.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [http://librecad.org/cms/home/installation/linux.html](http://librecad.org/cms/home/installation/linux.html) to
    install LibreCAD in Debian/Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [http://librecad.org/cms/home/installation/rpm-packages.html](http://librecad.org/cms/home/installation/rpm-packages.html)
    to install LibreCAD in Fedora
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [http://librecad.org/cms/home/installation/osx.html](http://librecad.org/cms/home/installation/osx.html)
    to install LibreCAD in OS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [http://librecad.org/cms/home/installation/windows.html](http://librecad.org/cms/home/installation/windows.html)
    to install LibreCAD in Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the documentation on LibreCAD at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.librecad.org/index.php/Main_Page](http://wiki.librecad.org/index.php/Main_Page).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing LibreCAD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation procedure for all operating systems is provided. If you are
    an Ubuntu user, you can simply install it from the Ubuntu Software Center as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the commands to install LibreCAD if you are using Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit the following download page to install Blender for your OS platform:
    [http://www.blender.org/download/](http://www.blender.org/download/).You can find
    the latest version of Blender here. Also, you can find the latest documentation
    on Blender at [http://wiki.blender.org/](http://wiki.blender.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Ubuntu/Linux, you can simply install Blender via the Ubuntu
    Software Center or use following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Installing MeshLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MeshLab** is available for all OS platforms. The following link will provide
    you with the download links of prebuilt binaries and the source code of MeshLab: [http://meshlab.sourceforge.net/](http://meshlab.sourceforge.net/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are an Ubuntu user, you can install **MeshLab** from an apt package
    manager using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating 2D CAD drawing of a robot using LibreCAD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will take a look at the basic interface of LibreCAD. The following screenshot
    shows the interface of LibreCAD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cdc331b-5c04-46eb-b1b3-d6f38612a98e.png)'
  prefs: []
  type: TYPE_IMG
- en: LibreCAD tool
  prefs: []
  type: TYPE_NORMAL
- en: 'A CAD toolbar has the necessary components to draw a model. The following diagram
    shows the detailed overview of the CAD toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15792b40-facc-47f1-98e6-f8c093d7bd1d.png)[http://wiki.librecad.org/](http://wiki.librecad.org/)'
  prefs: []
  type: TYPE_IMG
- en: 'A detailed description of LibreCAD tools is available at the following link:
    [http://wiki.librecad.org/index.php/LibreCAD_users_Manual](http://wiki.librecad.org/index.php/LibreCAD_users_Manual)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short explanation of each tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command Box**: This is used to draw figures by only using commands. We can
    draw diagrams without touching any toolbar. A detail explanation about the usage
    of the Command Box can be found at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer List**: This will have layers used in the current drawing. A basic
    concept in computer-aided drafting is the use of layers to organize a drawing.
    A detailed explanation of layers can be found at: [http://wiki.librecad.org/index.php/Layers](http://wiki.librecad.org/index.php/Layers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocks**: This is a group of entities and can be inserted in the same drawing
    more than once with different attributes at different locations, different scales,
    and rotation angles. A detailed explanation of Blocks can be found at the following
    link: [http://wiki.librecad.org/index.php/Blocks](http://wiki.librecad.org/index.php/Blocks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Absolute Zero**: This is the origin of the drawing (0,0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, start sketching by setting the unit of drawing. Set the drawing unit to
    centimeters. Open LibreCAD, and navigate to Edit | Application Preference. Set
    Unit as Centimeter, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32e23b0b-cfe8-468f-968e-02726e89e1c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with the base plate design of the robot. The base plate has provisions
    to connect motors, place a battery, and a control board.
  prefs: []
  type: TYPE_NORMAL
- en: The base plate designs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows the robot''s base plate. This plate provides provisions
    for two motors for the differential drive and each caster wheel on the front and
    back of the base plate. Motors are mentioned as **M1** and **M2** in the diagram
    and caster wheels are represented as **C1** and **C2**. It also holds four poles
    to connect to the next plates. Poles are represented as **P1-1**, **P1-2**, **P1-3**,
    and **P1-4**. The screws are indicated as **S** and we will use the same screws
    here. There is a hole at the center to bring the wires from the motor to the top
    of the plate. The plate is cut on the left-hand side and the right-hand side so
    that the wheels can be attached to the motor. The distance from the center to
    the caster wheels is mentioned as **12.5** cm and the distance from the center
    to motors is mentioned as **5.5** cm. The center of poles is at **9** cm in length
    and **9** cm in height from the center. The holes of all the plates follow the
    same dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/910fe464-2213-46b3-a2a7-671da42cb1f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Design of base plate
  prefs: []
  type: TYPE_NORMAL
- en: 'The dimensions are not marked in the diagram; instead, they are listed in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parts** | **Dimension(cm) (Length x Height) ( radius)** |'
  prefs: []
  type: TYPE_TB
- en: '| **M1** and **M2** | 5 x 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **C1** and **C2** | Radius = 1.5 |'
  prefs: []
  type: TYPE_TB
- en: '| **S** (Screw) (not shown in diagram) | 0.15 |'
  prefs: []
  type: TYPE_TB
- en: '| **P1-1**,**P1-2**,**P1-3**,**P1-4** | Outer radius 0.7, Height 3.5cm |'
  prefs: []
  type: TYPE_TB
- en: '| Left and right wheel sections | 2.5 x 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Base plate | Radius = 15 |'
  prefs: []
  type: TYPE_TB
- en: We will discuss the motor dimensions and clamp dimensions in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Base plate pole design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The base plate has four poles to extend to the next layer. The poles are **3.5**
    cm in length with a radius of **0.7** cm. We can extend to the next plate by attaching
    hollow tubes to the poles. At the top of the hollow tube, we will insert a hard
    plastic to make a screw hole. This hole will be useful for extending to the top
    layer. The base plate pole and hollow tubes on each pole are shown in the following
    diagram. The hollow tube has a radius of **0.75** cm and length of **15** cm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78ca83f3-10db-4e9e-9750-51da05d5e477.png)'
  prefs: []
  type: TYPE_IMG
- en: Design of hollow tube 15 cm
  prefs: []
  type: TYPE_NORMAL
- en: Wheel, motor, and motor clamp design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to decide the diameter of the wheel and compute motor requirements.
    Here, we are giving a typical motor and wheel that we can use if the design is
    successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1afa7fb9-bdb0-4923-b804-ccffc987a3c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Motor design of robot
  prefs: []
  type: TYPE_NORMAL
- en: The motor design can vary according to the motor selection; if necessary, this
    motor can be taken as the design and can change after simulation. The **L **value
    in the motor diagram can vary according to the speed and torque of the motors.
    This is the gear assembly of the motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a typical wheel that we can use with a diameter
    of **90** cm. The wheel with a diameter of **86.5** mm will become **90** mm after
    placing the grip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c19a13cb-861e-4147-a323-2ad6f47dd814.png)'
  prefs: []
  type: TYPE_IMG
- en: Wheel design of robot
  prefs: []
  type: TYPE_NORMAL
- en: 'The motors need to be mounted on the base plate. To mount, we need a clamp
    that can be screwed onto the plate and also connect the motor to the clamp. The
    following diagram shows a typical clamp that we can use for this purpose. It''s
    an L-shaped clamp with which we can mount the motor on one side and fit another
    side to the plate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9217af88-b741-448a-a614-00a0a0d0d1ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Typical clamp design of robot
  prefs: []
  type: TYPE_NORMAL
- en: Caster wheel design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caster wheels need not have a special design; we can use any caster wheel that
    can touch the ground similar to the wheels. The following link has a collection
    of caster wheels that we can use for this design: [http://www.pololu.com/category/45/pololu-ball-casters](http://www.pololu.com/category/45/pololu-ball-casters).[](http://www.pololu.com/category/45/pololu-ball-casters)
  prefs: []
  type: TYPE_NORMAL
- en: Middle plate design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dimension of this plate is same as the base plate and the screw size is
    also similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/286755cb-0148-45d9-a978-8092c6850b00.png)'
  prefs: []
  type: TYPE_IMG
- en: Design of middle plate of robot
  prefs: []
  type: TYPE_NORMAL
- en: 'The middle plate can be held above the hollow tubes from the base plate. This
    arrangement is connected using another hollow tube that extends from the middle
    plate. The tube from the middle plate will have a screw at the bottom to fix the
    tube from the base plate and the middle plate and a hollow end to connect the
    top plate. The top and side view of the tube extending from the middle plate is
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad0087ef-9ad1-4645-be2f-8591b1d6b0ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Design of hollow tube 20 cm
  prefs: []
  type: TYPE_NORMAL
- en: This tube will connect the middle plate to the base plate and at the same time
    provide a connect the top plate.
  prefs: []
  type: TYPE_NORMAL
- en: Top plate design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The top plate is similar to the other plates; it has four small poles of 3
    cm, similar to the base plate. The poles can be placed on the hollow tubes from
    the middle plate. The four poles are connected to the plate itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4c20270-1e8f-4660-b8ee-d11a193ccd4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Design of top plate
  prefs: []
  type: TYPE_NORMAL
- en: After the top plate design, the robot chassis design is almost finished. Let's
    look at the 3D model building of this robot using Blender. The 3D model is built
    for simulation purposes and the 2D design we build is mainly for manufacturing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a 3D model of the robot using Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will design the 3D model of the robot. The 3D model is mainly
    used for simulation purposes. The modeling will be done using Blender. The version
    must be greater than 2.6 because we only tested the tutorials on these versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Blender workspace and tools that can be
    used to work with 3D models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0365757-7ac5-49e6-a1ed-cfc6b7d7757d.png)'
  prefs: []
  type: TYPE_IMG
- en: Blender 3D CAD tools
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason why we are using Blender here is that we can model the robot
    using Python scripts. Blender has an inbuilt Python interpreter and a Python script
    editor for coding purposes. We will not discuss the user interface of Blender
    here. You can find a good tutorial of Blender on its website. Refer to the following
    link to learn about Blender''s user interface: [http://www.blender.org/support/tutorials/](http://www.blender.org/support/tutorials/).
    [](http://www.blender.org/support/tutorials/)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start coding in Blender using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python scripting in Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Blender** is mainly written in C, C++, and Python. Users can write their
    own Python script and access all the functionalities of Blender. If you are an
    expert in Blender Python APIs, you can model the entire robot using a Python script
    instead of manual modeling.'
  prefs: []
  type: TYPE_NORMAL
- en: Blender uses Python 3.x. Blender. The Python APIs are generally stable, but
    some areas are still added and improved. Refer to [http://www.blender.org/documentation/blender_python_api_2_69_7/](http://www.blender.org/documentation/blender_python_api_2_69_7/)
    for the documentation on the Blender Python APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's give a quick overview of the Blender Python APIs that we will use in our
    robot model script.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Blender Python APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python APIs in Blender can do most of the functionalities of Blender. The main
    jobs that can be done by the APIs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit any data inside Blender, such as scenes, meshes, particles, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify user preferences, key maps, and themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new Blender tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw the 3D view using OpenGL commands from Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blender provides the **bpy** module to the Python interpreter. This module
    can be imported in a script and gives access to Blender data, classes, and functions;
    scripts that deal with Blender data will need to import this module. The main
    Python modules we will use in bpy are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context access**: This provides access to Blender user interface functions
    from the (`bpy.context`) script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data access**: This provides access to the Blender internal data (`bpy.data`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operators**: This provides Python access to calling operators, which includes
    operators written in C, Python, or Macros (`bpy.ops`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For switching to scripting in Blender, we need to change the screen layout
    of Blender. The following screenshot shows the option that helps you to switch
    to the Scripting layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bacef5a3-2e89-4c8d-9328-593898a5fcce.png)'
  prefs: []
  type: TYPE_IMG
- en: Blender Scripting option
  prefs: []
  type: TYPE_NORMAL
- en: After selecting the Scripting tab, we can see a text editor and Python console
    window in Blender. In the text editor, we can code using Blender APIs and also
    try Python commands via the Python console. Click on the New button to create
    a new Python script and name it `robot.py`. Now, we can design the 3D model of
    the robot using only Python scripts. The upcoming section has the complete script
    to design our robot model. We can discuss the code before running it. Hopefully,
    you have read the Python APIs of Blender from their site. The code in the upcoming
    section is split into six Python functions to draw three robot plates, draw motors
    and wheels, draw four support tubes, and export into the **STereoLithography**
    (**STL**) 3D file format for simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Python script of the robot model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the Python script of the robot model that we will design:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting the Python script in Blender, we must import the `bpy` module.
    The `bpy` module contains all the functionalities of Blender and it can only be
    accessed from inside the Blender application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function will draw the base plate of the robot. This function
    will draw a cylinder with a radius of 5 cm and cut a portion from the opposite
    sides so that motors can be connected using the `Boolean` modifier inside Blender:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two commands will create two cubes with a radius of 0.05 meters
    on either side of the base plate. The purpose of these cubes is to create a modifier
    that subtracts the cubes from the base plate. So in effect, we will get a base
    plate with two cuts. After cutting the two sides, we will delete the cubes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function will draw motors and wheels attached to the base plate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands will draw a cylinder with a radius of 0.045 and 0.01
    meters in depth for the wheels. After creating the wheels, it will be rotated
    and translated into the cut portion of the base plate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will add two dummy motors to the base plate. The dimensions
    of the motors are mentioned in the 2D design. The motor is basically a cylinder
    and it will be rotated and placed in the base plate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will add a shaft to the motors, similar to the motor model.
    The shaft is also a cylinder and it will be rotated and inserted into the motor
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will add two caster wheels on the base plate. Currently,
    we are adding a cylinder as a wheel. In the simulation, we can assign it as a
    wheel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will add a dummy Kinect sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will draw the middle plate of the robot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will draw all the four supporting hollow tubes for all the three
    plates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will export the designed robot to STL. We have to change the
    STL filepath before executing the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After entering the code in the text editor, execute the script by pressing
    the Run Script button, as shown in the following screenshot. The output 3D model
    will be shown on the 3D view of Blender. Also, if we check the desktop, we can
    see the `exported.stl` file for the simulation purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45f6226a-3e5c-4a58-b153-9603b79dcdc6.png)'
  prefs: []
  type: TYPE_IMG
- en: Running Python script in Blender
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exported.stl` file can be opened with MeshLab and the following is a screenshot
    of MeshLab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/82c5e5d2-5009-4be1-8acf-8786fc2403d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D model of Chefbot in MeshLab
  prefs: []
  type: TYPE_NORMAL
- en: Creating a URDF model of the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **robot model** in ROS contains packages to model the various aspects of
    the robot, which is specified in the XML Robot Description Format. The core package
    of this stack is URDF, which parses URDF files and constructs an object model
    of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unified Robot Description Format** (**URDF**) is an XML specification to
    describe the model of a robot. We can represent the following features of the
    robot using URDF:'
  prefs: []
  type: TYPE_NORMAL
- en: The kinematic and dynamic description of the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The visual representation of the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collision model of the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The description of the robot consists of a set of **links** (parts), elements,
    and a set of **joint** elements, which connect these links together. A typical
    robot description is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be good if you refer to the following links for more information on
    URDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.ros.org/urdf](http://wiki.ros.org/urdf) [http://wiki.ros.org/urdf/Tutorials](http://wiki.ros.org/urdf/Tutorials)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Xacro** (XML Macros) is an XML macro language. With xacro, we can create
    shorter and more readable XML files. We can use xacro along with URDF to simplify
    the URDF file. If we add xacro to URDF, we have to call the additional parser
    program to convert xacro to URDF.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following link will give you further details about xacro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.ros.org/xacro](http://wiki.ros.org/xacro)'
  prefs: []
  type: TYPE_NORMAL
- en: '**robot_state_publisher** allows you to publish the state of the robot to **tf**
    ([http://wiki.ros.org/tf](http://wiki.ros.org/tf)). This node read the URDF parameter
    called **robot_description** and reads the joint angles of the robot from a topic
    called **joint_states** as input and publishes the 3D poses of the robot links
    using the kinematic tree model of the robot. The package can be used as a library
    and as an ROS node. This package has been well tested and the code is stable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**World files**: These represent the environment of Gazebo, which has to be
    loaded along with the robot model. *empty.world* and *playground.world* are some
    examples of Gazebo world files. *empty.world* contains just an empty space. In
    *playground.world*, there will be some static objects in the environment. We can
    create our own `*.world` file using Gazebo. We will cover Gazebo world files further
    in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMakeList.txt and package.xml**: These files are created during the creation
    of the package. The `CmakeList.txt` file helps to build the ROS C++ nodes or libraries
    within a package and the `package.xml` file holds the list of all the dependencies
    of this package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Chefbot description ROS package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chefbot_description` package contains the URDF model of our robot. Before
    creating this package by yourself, you can go through the downloaded packages
    of Chefbot from `chapter3_codes`. It will help you to speed up the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check how to create the `chefbot_description` package. The following
    procedure will guide you in creating this package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to switch to the `chefbot` folder in the `src` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will create the robot description package along with
    dependencies, such as `urdf` and `xacro`. This will create the `chefbot_description`
    package in the `catkin_ws/src` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Copy all the folders from the downloaded `chefbot_description` package to the
    new package folder. The `meshes` folder holds the 3D parts of the robot and the
    `urdf` folder contains the URDF files that have the kinematics and dynamics model
    of the robot. The robot model is split into several xacro files, which enables
    easier debugging and better readability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the functionality of each file inside this package. You can
    check each of the files inside `chefbot_description`. The following diagram shows
    the files inside this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/902c33d6-de00-4fcc-a863-6c56f9a3e31c.png)*Chefbot description package*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functionalities of each file in the package are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`urdf/chefbot.xacro`: This is the main xacro file that has kinematic and dynamic
    parameters of the robot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urdf/common_properties.xacro`: This xacro file consists of some properties
    and its values used inside the robot model. For example, different color definitions
    of robot links and some constants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gazebo/chefbot.gazebo.xacro`: This file consists of simulation parameters
    of the robot. It mainly has Gazebo parameters and plugins for performing simulations.
    These parameters will only be active when we start the simulation using this model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch/upload_model.launch`: This launch file has a node that basically parses
    the robot xacro file and uploads the parsed data to a ROS parameter called `robot_description`.
    The `robot_description` parameter is then used in Rviz for visualization and used
    in Gazebo for simulation. If our xacro model is wrong, then this launch file will
    throw an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch/view_model.launch`: This launch file will upload the robot URDF model
    and view the model in Rviz.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch/view_navigation.launch`: The will show the URDF model and navigation-related
    display types in Rviz.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch/view_robot_gazebo.launch`: This will launch the URDF model in Gazebo
    and start all Gazebo plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meshes/`: This folder contains the necessary meshes for the robot model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build the workspace using the *catkin_make* command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After building the packages, we can launch the Chefbot model in Rviz using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The robot model in Rviz is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/060447dc-471a-4ba0-ac05-4ae76553b7e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chefbot URDF model in Rviz
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `view_robot.launch` file that visualizes the robot in Rviz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the definition of `upload_model. launch`. The `xacro` command is to
    parse the `chefbot.xacro` file and store to `robot_description`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can have a look at the `udf/chefbot.xacro`, which is the main URDF model
    file. We can see how the links and joints are defined inside the xacro file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the header of the robot xacro model. It has
    an XML version, robot name, and it includes some other xacro files, such as `common_properties.xacro`
    and `chefbot.gazebo.xacro.` After that, we can see some camera properties that
    are defined in the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows the definition of links and joints in the
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we can see the definition of two links called `base_footprint` and
    `base_link`. The `base_footprint` link is a dummy link, meaning it has any properties;
    it is just for showing the origin of the robot. The `base_link` is the origin
    of the robot and it has visual and collision properties. We can also see that
    the link is visualized as a mesh file. We can also see the inertial parameters
    of the link in the definition. The joint is the combination of two link. We can
    define a joint in URDF by mentioning two links and the type of the joint. There
    are different types of joints available in URDF, such as fixed, revolute, continuous,
    and prismatic. In this snippet, we are creating a fixed joint because there is
    no movement between these frames.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has been all about the basics of the Chefbot URDF. We will learn
    more about Chefbot simulation and give an explanation of the parameters in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the modeling of the Chefbot robot. The modeling
    involves 2D and 3D designing of the robot hardware and ends up in as URDF model,
    which can be used in ROS. The chapter started with the various requirements to
    be satisfied by the robot and we have seen how to calculate various design parameters.
    After calculating the design parameters, we started to design the 2D sketches
    of the robot hardware. The designing was done using LibreCAD, a free CAD tool.
    After that, we worked on the 3D model in Blender using Python scripting. We have
    created the mesh model from Blender and created the URDF model of the robot. After
    the creation of the URDF model, we looked at how to visualize the robot in Rviz.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to simulate this robot and perform
    mapping and localization.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is robot modeling and what are its uses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the aim of a 2D robot model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the aim of a 3D robot model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of Python scripting over manual modeling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a URDF file and what are its uses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about URDF and Xacro and Gazebo you can refer book: *Mastering
    ROS for Robotics Programming - Second Edition* ([https://www.packtpub.com/hardware-and-creative/mastering-ros-robotics-programming-second-edition](https://www.packtpub.com/hardware-and-creative/mastering-ros-robotics-programming-second-edition))'
  prefs: []
  type: TYPE_NORMAL
