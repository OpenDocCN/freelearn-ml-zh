<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Social Media Insight using Naive Bayes</h1>
            </header>

            <article>
                
<p>Text-based documents contain lots of information. Examples include books, legal documents, social media, and e-mail. Extracting information from text-based documents is critically important to modern AI systems, for example in search engines, legal AI, and automated news services. </p>
<p>Extraction of useful features from text is a difficult problem. Text is not numerical in nature, therefore a model must be used to create features that can be used with data mining algorithms. The good news is that there are some simple models that do a great job at this, including the bag-of-words model that we will use in this chapter.</p>
<p>In this chapter, we look at extracting <span>features </span>from text for use in data mining applications. The specific problem we tackle in this chapter is term disambiguation on social media - determining which meaning a word has based on its context.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Downloading data from social network APIs</li>
<li>Transformers and models for text data</li>
<li>The Naive Bayes classifier</li>
<li>Using JSON for saving and loading datasets</li>
<li>The NLTK library for feature creation</li>
<li>The F-measure for evaluation</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Disambiguation</h1>
            </header>

            <article>
                
<p>Text data is often called an <em>unstructured format</em>. There is a lot of information in text, but it is just <em>there</em>; no headings, no required format (save for normal grammatical rules), loose syntax, and other problems prohibit the easy extraction of information from text. The data is also highly connected, with lots of mentions and cross-references—just not in a format that allows us to easily extract it! Even seemingly easy problems, such as determining if a word is a noun, have lots of weird edge cases that make it difficult to do reliably.</p>
<p>We can compare the information stored in a book with that stored in a large database to see the difference. In the book, there are characters, themes, places, and lots of information. However, a book needs to be read and interpreted, with cultural context, to gain this information. In contrast, a database sits on your server with column names and data types. All the information is there and the level of interpretation needed to extract specific information is quite low.</p>
<p>Information about the data, such as its type or its meaning, is called metadata. Text lacks metadata. A book also contains some metadata in the form of a table of contents and index but the degree of information included in these sections is significantly lower than that of a database.</p>
<p>One of the problems in working with text is <strong>term disambiguation</strong>. When a person uses the word <em>bank</em><span class="packt_screen">,</span> is this a financial message or an environmental message (such as river bank)? This type of disambiguation is quite easy in many circumstances for humans (although there are still troubles), but much harder for computers to do.</p>
<p>In this chapter, we will look at disambiguating the use of the term <span class="packt_screen">Python</span> on Twitter's stream. When people talk about Python, they could be talking about the following things:</p>
<ul>
<li>The programming language Python</li>
<li>Monty Python, the classic comedy group</li>
<li>The snake Python</li>
<li>A make of shoe called Python</li>
</ul>
<p>There can be many other things called Python. The aim of our experiment is to take a tweet mentioning Python and determine whether it is talking about the programming language, based only on the content of the tweet.</p>
<div class="packt_infobox">A message on Twitter is called a <em>tweet</em> and is limited to 140 characters. Tweets include lots of metadata, such as the time and date of posting, who posted it, and so on. However in regards to the topic of the tweet, there is not much in this regard.</div>
<p>In this chapter, we are going to perform a data mining experiment consisting of the following steps:</p>
<ol>
<li>Download a set of tweets from Twitter.</li>
<li>Manually classify them to create a dataset.</li>
<li>Save the dataset so that we can replicate our research.</li>
<li>Use the Naive Bayes classifier to create a classifier to perform term disambiguation.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Downloading data from a social network</h1>
            </header>

            <article>
                
<p>We are first going to download a corpus of data from Twitter and use it to sort out spam from useful content. Twitter provides a robust API for collecting information from its servers and this API is free for small-scale usage. It is, however, subject to some conditions that you'll need to be aware of if you start using Twitter's data in a commercial setting.</p>
<p>First, you'll need to sign up for a Twitter account (which is free). Go to <a href="http://twitter.com">http://twitter.com</a>  and register an account if you do not already have one.</p>
<p>Next, you'll need to ensure that you only make a certain number of requests per minute. This limit is currently 15 requests per 15 minutes (it depends on the exact API). It can be tricky ensuring that you don't breach this limit, so it is highly recommended that you use a library to talk to Twitter's API.</p>
<div class="packt_tip">If you are using your own code (that is making the web calls with your own code) to connect with a web-based API, ensure that you read the documentation about rate limiting their documentation and understand the limitations. In Python, you can use the <kbd>time</kbd> library to perform a pause between calls to ensure you do not breach the limit.</div>
<p>You <span>will </span>then <span>need a key to access Twitter's data. Go to</span> <a href="http://twitter.com">http://twitter.com</a> <span>and sign in to your account. When you are logged in, go to</span> <a href="https://apps.twitter.com/">https://apps.twitter.com/</a> <span>and click on</span> <span class="packt_screen">Create New App</span><span>. Create a name and description for your app, along with a website address.</span>If you don't have a website to use, insert a placeholder. Leave the <span class="packt_screen">Callback URL</span> field blank for this app—we won't need it. Agree to the terms of use (if you do) and click on <span class="packt_screen">Create your Twitter application</span>.</p>
<p>Keep the resulting website open—you'll need the access keys that are on this page. Next, we need a library to talk to Twitter. There are many options; the one I like is simply called <kbd>twitter</kbd>, and is the official Twitter Python library.</p>
<div class="packt_tip">You can install <kbd>twitter</kbd> using <span class="packt_screen">pip3 install twitter</span> (on the command line) if you are using pip to install your packages. At the time of writing, Anaconda does not include twitter, therefore you can't use <kbd>conda</kbd> to install it. If you are using another system or want to build from source, check the documentation at <a href="https://github.com/sixohsix/twitter">https://github.com/sixohsix/twitter</a></div>
<p>Create a new Jupyter Notebook to download the data. We will create several notebooks in this chapter for various different purposes, so it might be a good idea to also create a folder to keep track of them. This first notebook, <kbd>ch6_get_twitter</kbd>, is specifically for downloading new Twitter data.</p>
<p>First, we import the twitter library and set our authorization tokens. The consumer key and consumer secret will be available on the <span class="packt_screen">Keys and Access Tokens</span> tab on your Twitter app's page. To get the access tokens, you'll need to click on the Create my access token button, which is on the same page. Enter the keys into the appropriate places in the following code:</p>
<pre>
<span><span><span>import twitter<br/></span></span></span><span><span><span>consumer_key = <span><span>"&lt;Your Consumer Key Here&gt;"<br/></span></span></span></span></span><span><span><span>consumer_secret = <span><span>"&lt;Your Consumer Secret Here&gt;"<br/></span></span></span></span></span><span><span><span>access_token = <span><span>"&lt;Your Access Token Here&gt;"<br/></span></span></span></span></span><span><span><span>access_token_secret = <span><span>"&lt;Your Access Token Secret Here&gt;"<br/></span></span></span></span></span><span><span><span>authorization = twitter.OAuth(access_token, access_token_secret, consumer_key, consumer_secret)<br/></span></span></span>
</pre>
<p>We are going to get our tweets from Twitter's search function. We will create a reader that connects to twitter using our authorization, and then use that reader to perform searches. In the Notebook, we set the filename where the tweets will be stored:</p>
<pre>
import os<br/>output_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "python_tweets.json")
</pre>
<p>Next, create an object that can read from Twitter. We create this object with our authorization object that we set up earlier:</p>
<pre>
t = twitter.Twitter(auth=authorization)
</pre>
<p>We then open our output file for writing. We open it for appending—this allows us to rerun the script to obtain more tweets. We then use our Twitter connection to perform a search for the word Python. We only want the statuses that are returned for our dataset. This code takes the tweet, uses the <span class="packt_screen">json</span> library to create a string representation using the dumps function, and then writes it to the file. It then creates a blank line under the tweet so that we can easily distinguish where one tweet starts and ends in our file:</p>
<pre>
import json<br/>with open(output_filename, 'a') as output_file:<br/>    search_results = t.search.tweets(q="python", count=100)['statuses']<br/>    for tweet in search_results:<br/>        if 'text' in tweet:<br/>            output_file.write(json.dumps(tweet))<br/>            output_file.write("nn")
</pre>
<p>In the preceding loop, we also perform a check to see whether there is text in the tweet or not. Not all of the objects returned by twitter will be actual tweets (for example, some responses will be actions to delete tweets). The key difference is the inclusion of text as a key, which we test for. Running this for a few minutes will result in 100 tweets being added to the output file.</p>
<div class="packt_tip">You can keep re-running this script to add more tweets to your dataset, keeping in mind that you may get some duplicates in the output file if you rerun it too fast (that is before Twitter gets new tweets to return!). For our initial experiment, 100 tweets will be enough, but you will probably want to come back and rerun this code to get that up to about 1000.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Loading and classifying the dataset</h1>
            </header>

            <article>
                
<p>After we have collected a set of tweets (our dataset), we need labels to perform classification. We are going to label the dataset by setting up a form in a Jupyter Notebook to allow us to enter the labels. We do this by loading the tweets we collected in the previous section, iterating over them and providing (manually) a classification on whether they refer to Python the programming language or not.</p>
<p>The dataset we have stored is nearly, but not quite, in a <strong>JSON</strong> format. JSON is a format for data that doesn't impose much structure on the contents, just on the syntax. The idea behind JSON is that the data is in a format directly readable in JavaScript (hence the name, <em>JavaScript Object Notation</em>). JSON defines basic objects such as numbers, strings, lists, and dictionaries, making it a good format for storing datasets, if they contain data that isn't numerical. If your dataset is fully numerical, you would save space and time using a matrix-based format like in NumPy.</p>
<div class="packt_infobox">A key difference between our dataset and real JSON is that we included newlines between tweets. The reason for this was to allow us to easily append new tweets (the actual JSON format doesn't allow this easily). Our format is a JSON representation of a Tweet, followed by a newline, followed by the next Tweet, and so on.</div>
<p>To parse it, we can use the <span class="packt_screen">json</span> library but we will have to first split the file by newlines to get the actual tweet objects themselves. Set up a new Jupyter Notebook, I called mine <span class="packt_screen">ch6_label_twitter</span>. Within it, we will first load the data from our input filename by iterating over the file, storing tweets as we loop. The code below does a basic check that there is actual text in the tweet. If it does, we use the <span class="packt_screen">json</span> library to load the tweet and then we add it to a list:</p>
<pre>
import json<br/>import os<br/><br/># Input filename<br/>input_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "python_tweets.json")<br/># Output filename<br/>labels_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "python_classes.json")<br/><br/>tweets = []<br/>with open(input_filename) as inf:<br/>    for line in inf:<br/>        if len(line.strip()) == 0:<br/>            continue<br/>        tweets.append(json.loads(line))
</pre>
<p>We are now interested in manually classifying whether an item is relevant to us or not (in this case, relevant means refers to the programming language Python). We will use the Jupyter Notebook's ability to embed HTML and talk between JavaScript and Python to create a viewer of tweets to allow us to easily and quickly classify the tweets as spam or not. The code will present a new tweet to the user (you) and ask for a label: <em>is it relevant or not?</em> It will then store the input and present the next tweet to be labeled.</p>
<p>First, we create a list for storing the labels. These labels will be stored whether or not the given tweet refers to the programming language Python, and it will allow our classifier to learn how to differentiate between meanings.</p>
<p>We also check if we have any labels already and load them. This helps if you need to close the notebook down midway through labeling. This code will load the labels from where you left off. It is generally a good idea to consider how to save at midpoints for tasks like this. Nothing hurts quite like losing an hour of work because your computer crashed before you saved the labels! The code to do this loading follows:</p>
<pre>
labels = []<br/>if os.path.exists(labels_filename):<br/>    with open(labels_filename) as inf:<br/>        labels = json.load(inf)
</pre>
<p>The first time you run this, nothing will happen. After manually classifying some examples you can save your progress and then close the Notebook. After that, you can reopen the Notebook and return to where you were up to. </p>
<div class="packt_tip">If you make one or two mistakes classifying, don't worry too much. If you make lots of mistakes and want to start again, delete just <span class="packt_screen">python_classes.json</span> and the above code will pick up with an empty set of classifications. If you need to delete all of your data and start again with new tweets, make sure to delete (or move) both files - <span class="packt_screen">python_tweets.json</span> and <span class="packt_screen">python_classes.json</span>. Otherwise, this Notebook will get confused, giving classes from the old dataset to the new tweets.</div>
<p>Next, we create a simple function that will return the next tweet that needs to be labeled. We can work out which is the next tweet by finding the first one that hasn't yet been labeled. The code is pretty straight-forward. We determine how many tweets we have labeled (with <kbd>len(labels)</kbd>), and get the next tweet in the <span class="packt_screen">tweet_sample</span> list:</p>
<pre>
def get_next_tweet():<br/>    return tweets[len(labels)]['text']
</pre>
<p>The next step in our experiment is to collect information from the user (you!) on which tweets are referring to Python (the programming language) and which are not.</p>
<div class="packt_infobox">As of yet, there is not a good, straightforward way to get interactive feedback with pure Python in Jupyter Notebooks for such a large number of text documents. For this reason, we will use some JavaScript and HTML to get this input from the user. There are many ways to do this, below is just one example.</div>
<p>To get the feedback, we need a JavaScript component to load the next tweet and show it. We also need a HTML component to create the HTML elements to display that tweet. I won't go into the details of the code here, except to give this general workflow:</p>
<ol>
<li>Obtain the next tweet that needs to be classified with <kbd>load_next_tweet</kbd></li>
<li>Show it to the user with <kbd>handle_output</kbd></li>
<li>Wait for the user to press either 0 or 1 with <kbd>$("input#capture").keypress</kbd></li>
<li>Store that result in the classes list with <kbd>set_label</kbd></li>
</ol>
<p>This keeps happening until we reach the end of the list (at which point an IndexError occurs, indicating we have no more tweets to classify). The code is below (remember that you can get the code from Packt or from the official GitHub repository):</p>
<pre>
%%html<br/>&lt;div name="tweetbox"&gt;<br/> Instructions: Click in text box. Enter a 1 if the tweet is relevant, enter 0 otherwise.&lt;br&gt;<br/> Tweet: &lt;div id="tweet_text" value="text"&gt;&lt;/div&gt;&lt;br&gt;<br/> &lt;input type=text id="capture"&gt;&lt;/input&gt;&lt;br&gt;<br/>&lt;/div&gt;<br/><br/>&lt;script&gt;<br/>function set_label(label){<br/> var kernel = IPython.notebook.kernel;<br/> kernel.execute("labels.append(" + label + ")");<br/> load_next_tweet();<br/>}<br/><br/>function load_next_tweet(){<br/> var code_input = "get_next_tweet()";<br/> var kernel = IPython.notebook.kernel;<br/> var callbacks = { 'iopub' : {'output' : handle_output}};<br/> kernel.execute(code_input, callbacks, {silent:false});<br/>}<br/><br/>function handle_output(out){<br/> console.log(out);<br/> var res = out.content.data["text/plain"];<br/> $("div#tweet_text").html(res);<br/>}<br/><br/>$("input#capture").keypress(function(e) {<br/> console.log(e);<br/> if(e.which == 48) {<br/> // 0 pressed<br/> set_label(0);<br/> $("input#capture").val("");<br/> }else if (e.which == 49){<br/> // 1 pressed<br/> set_label(1); <br/> $("input#capture").val("");<br/> }<br/>});<br/><br/>load_next_tweet();<br/>&lt;/script&gt;
</pre>
<p>You will need to enter all of this code into a single cell (or copy it from the code bundle). It contains the mix of HTML and JavaScript necessary to get input from you to manually classify the tweets. If you need to stop or save your progress, run the following code in the next cell. It will save your progress (and doesn't interrupt the above HTML code either, which can be left running):</p>
<pre>
<span><span><span>with open(labels_filename, 'w') as outf:<br/></span></span></span><span><span><span>    json.dump(labels, outf)</span></span></span>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a replicable dataset from Twitter</h1>
            </header>

            <article>
                
<p>In data mining, there are lots of variables. These aren't the parameters of the data mining algorithms - they are the methods of data collection, how the environment is set up, and many other factors. Being able to replicate your results is important as it enables you to verify or improve upon your results.</p>
<p>Getting 80 percent accuracy on one dataset with algorithm X, and 90 percent accuracy on another dataset with algorithm Y doesn't mean that Y is better. We need to be able to test on the same dataset in the same conditions to be able to properly compare. With running the preceding code, you will get a different dataset to the one I created and used. The main reasons are that Twitter will return different search results for you than me based on the time you performed the search.</p>
<p>Even after that, your labeling of tweets might be different from what I do. While there are obvious examples where a given tweet relates to the python programming language, there will always be gray areas where the labeling isn't obvious. One tough gray area I ran into was tweets in non-English languages that I couldn't read. In this specific instance, there are options in Twitter's API for setting the language, but even these aren't going to be perfect.</p>
<p>Due to these factors, it is difficult to replicate experiments on databases that are extracted from social media, and Twitter is no exception. Twitter explicitly disallows sharing datasets directly. One solution to this is to share tweet IDs only, which you can share freely. In this section, we will first create a tweet ID dataset that we can freely share. Then, we will see how to download the original tweets from this file to recreate the original dataset. First, we save the replicable dataset of tweet IDs.</p>
<p>After creating another new Jupyter Notebook, first set up the filenames as before. This is done in the same way we did labeling but there is a new filename where we can store the replicable dataset. The code is as follows:</p>
<pre>
import os<br/>input_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "python_tweets.json")<br/>labels_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "python_classes.json")<br/>replicable_dataset = os.path.join(os.path.expanduser("~"), "Data", "twitter", "replicable_dataset.json")
</pre>
<p>We load the tweets and labels as we did in the previous notebook:</p>
<pre>
import json<br/>tweets = []<br/>with open(input_filename) as inf:<br/>    for line in inf:<br/>        if len(line.strip()) == 0:<br/>            continue<br/>        tweets.append(json.loads(line))<br/>if os.path.exists(labels_filename):<br/>    with open(labels_filename) as inf:<br/>        labels = json.load(inf)
</pre>
<p>Now we create a dataset by looping over both the tweets and labels at the same time and saving those in a list. An important side-effect of this code is, by putting labels first in the zip function, it will only load enough tweets for the labels we have created. In other words, you can run this code on partially classified data:</p>
<pre>
dataset = [(tweet['id'], label) for label, tweet in zip(labels, tweets)]
</pre>
<p>Finally, we save the results in our file:</p>
<pre>
with open(replicable_dataset, 'w') as outf:<br/>    json.dump(dataset, outf)
</pre>
<p>Now that we have the Tweet IDs and labels saved, we can recreate the original dataset. If you are looking to recreate the dataset I used for this chapter, it can be found in the code bundle that comes with this book. Loading the preceding dataset <span>is not difficult but it can take some time.</span></p>
<p><span>Start a new Jupyter Notebook and set the dataset, label, and tweet ID filenames as before. I've adjusted the filenames here to ensure that you don't overwrite your previously collected dataset, but feel free to change these if you do want to override.</span></p>
<p><span>The code is as follows:</span></p>
<pre>
import os<br/>tweet_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "replicable_python_tweets.json")<br/>labels_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "replicable_python_classes.json")<br/>replicable_dataset = os.path.join(os.path.expanduser("~"), "Data", "twitter", "replicable_dataset.json")
</pre>
<p>Next, load the tweet IDs from the file using JSON:</p>
<pre>
import json<br/>with open(replicable_dataset) as inf:<br/>    tweet_ids = json.load(inf)
</pre>
<p>Saving the labels is very easy. We just iterate through this dataset and extract the IDs. We could do this quite easily with just two lines of code (open file and save tweets). However, we can't guarantee that we will get all the tweets we are after (for example, some may have been changed to private since collecting the dataset) and therefore the labels will be incorrectly indexed against the data. As an example, I tried to recreate the dataset just one day after collecting them and already two of the tweets were missing (they might be deleted or made private by the user). For this reason, it is important to only print out the labels that we need.</p>
<p>To do this, we first create an empty actual labels list to store the labels for tweets that we actually recover from twitter, and then create a dictionary mapping the tweet IDs to the labels. The code is as follows:</p>
<pre>
actual_labels = []<br/>label_mapping = dict(tweet_ids)
</pre>
<p>Next, we are going to create a twitter server to collect all of these tweets. This is going to take a little longer. Import the twitter library that we used before, creating an authorization token and using that to create the twitter object:</p>
<pre>
import twitter<br/>consumer_key = "&lt;Your Consumer Key Here&gt;"<br/>consumer_secret = "&lt;Your Consumer Secret Here&gt;"<br/>access_token = "&lt;Your Access Token Here&gt;"<br/>access_token_secret = "&lt;Your Access Token Secret Here&gt;"<br/>authorization = twitter.OAuth(access_token, access_token_secret, consumer_key, consumer_secret)<br/>t = twitter.Twitter(auth=authorization)
</pre>
<p>Next, we will loop through each of the tweet ids, and ask twitter to recover the original tweet. A good feature of twitter's API is that we can ask for 100 tweets at a time, drastically reducing the number of API calls. Interestingly, from twitter's point of view, it is the same number of calls to get one tweet or 100 tweets, as long as its a single request.</p>
<p>The following code will loop through our tweets in groups of 100, join together the id values, and get the tweet information for each of them.</p>
<pre>
all_ids = [tweet_id for tweet_id, label in tweet_ids]<br/>with open(tweet_filename, 'a') as output_file:<br/>    # We can lookup 100 tweets at a time, which saves time in asking twitter for them<br/>    for start_index in range(0, len(all_ids), 100):<br/>        id_string = ",".join(str(i) for i in all_ids[start_index:start_index+100])<br/>        search_results = t.statuses.lookup(_id=id_string)<br/>        for tweet in search_results:<br/>            if 'text' in tweet:<br/>                # Valid tweet - save to file<br/>                output_file.write(json.dumps(tweet))<br/>                output_file.write("nn")<br/>                actual_labels.append(label_mapping[tweet['id']])
</pre>
<p>In this code, we then check each tweet to see if it is a valid tweet and then save it to our file if it is. Our final step is to save our resulting labels:</p>
<pre>
with open(labels_filename, 'w') as outf:<br/>    json.dump(actual_labels, outf)
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Text transformers</h1>
            </header>

            <article>
                
<p>Now that we have our dataset, how are we going to perform data mining on it?</p>
<p>Text-based datasets include books, essays, websites, manuscripts, programming code, and other forms of written expression. All of the algorithms we have seen so far deal with numerical or categorical features, so how do we convert our text into a format that the algorithm can deal with? There are a number of measurements that could be taken.</p>
<p>For instance, average word and average sentence length are used to predict the readability of a document. However, there are lots of feature types such as word occurrence which we will now investigate.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Bag-of-words models</h1>
            </header>

            <article>
                
<p>One of the simplest but highly effective models is to simply count each word in the dataset. We create a matrix, where each row represents a document in our dataset and each column represents a word. The value of the cell is the frequency of that word in the document. This is known as the <strong>bag-of-words model</strong>.</p>
<p>Here's an excerpt from <q>The Lord of the Rings, J.R.R. Tolkien: </q></p>
<div class="packt_figref"><q>Three Rings for the Elven-kings under the sky,</q></div>
<div class="packt_figref"><q>Seven for the Dwarf-lords in halls of stone, Nine for Mortal Men, doomed to die,</q></div>
<div class="packt_figref"><q>One for the Dark Lord on his dark throne In the Land of Mordor where the Shadows lie.</q></div>
<div class="packt_figref"><q>One Ring to rule them all, One Ring to find them,</q></div>
<div class="packt_figref"><q>One Ring to bring them all and in the darkness bind them.</q></div>
<div class="packt_figref"><em><q> </q>In the Land of Mordor where the Shadows lie.</em></div>
<div class="packt_figref"><q>                                                                  - J.R.R. Tolkien's epigraph to The Lord of The Rings</q></div>
<p>The word <span class="packt_screen">the</span> appears nine times in this quote, while the words <span class="packt_screen">in</span>, <span class="packt_screen">for</span>, <span class="packt_screen">to</span>, and <span class="packt_screen">one</span> each appear four times. The word <span class="packt_screen">ring</span> appears three times, as does the word <span class="packt_screen">of</span>.</p>
<p>We can create a dataset from this, choosing a subset of words and counting the frequency:</p>
<table style="width: 321px;height: 60px">
<tbody>
<tr>
<td>Word</td>
<td>the</td>
<td>one</td>
<td>ring</td>
<td>to</td>
</tr>
<tr>
<td>Frequency</td>
<td>9</td>
<td>4</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>To do this for all words in a single document, we can use the <strong>Counter</strong> class. When counting words, it is normal to convert all letters to lowercase, which we do when creating the string. The code is as follows:</p>
<pre>
 s = """Three Rings for the Elven-kings under the sky, Seven for the Dwarf-lords in halls of stone, Nine for Mortal Men, doomed to die, One for the Dark Lord on his dark throne In the Land of Mordor where the Shadows lie. One Ring to rule them all, One Ring to find them, One Ring to bring them all and in the darkness bind them. In the Land of Mordor where the Shadows lie. """.lower()<br/>words = s.split()<br/>from collections import Counter<br/>c = Counter(words)<br/>print(c.most_common(5))
</pre>
<p>Printing <kbd>c.most_common(5)</kbd> gives the list of the top five most frequently occurring words. Ties are not handled well as only five are given and a very large number of words all share a tie for fifth place.</p>
<p>The bag-of-words model has three major types, with many variations and alterations.</p>
<ul>
<li>The first is to use the raw frequencies, as shown in the preceding example. This has the same drawback as any non-normalised data - words with high variance due to high overall values (such as) <em>the</em> overshadow lower frequency (and therefore lower-variance) words, even though the presence of the word <em>the</em> rarely has much importance.</li>
<li>The second model is to use the normalized frequency, where each document's sum equals 1. This is a much better solution as the length of the document doesn't matter as much, but it still means words like the overshadow lower frequency words. The third type is to simply use binary features—a value is 1 if it occurs, and 0 otherwise. We will use binary representation in this chapter.</li>
<li>Another (arguably more popular) method for performing normalization is called <strong>term frequency-inverse document frequency</strong> (<strong>tf-idf</strong>). In this weighting scheme, term counts are first normalized to frequencies and then divided by the number of documents in which it appears in the corpus. We will use tf-idf in <a href="964e5bbd-7a61-498a-9076-831967ec6df7.xhtml">Chapter 10</a><em>, Clustering News Articles</em>.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">n-gram features</h1>
            </header>

            <article>
                
<p>One variation on the standard bag-of-words model is called the <span class="packt_screen">n-gram</span> model. An n-grams model addresses the deficiency of context in the bag-of-words model. With a bag-of-words model, only individual words are counted by themselves. This means that common word pairs, such as <em>United States</em>, lose meaning they have in the sentence because they are treated as individual words.</p>
<p>There are algorithms that can read a sentence, parse it into a tree-like structure, and use this to create very accurate representations of the meaning behind words. Unfortunately, these algorithms are computationally expensive. This makes it difficult to apply them to large datasets.</p>
<p>To compensate for these issues of context and complexity, the n-grams model fits into the middle ground. It has more context than the bag-of-words model, while only being slightly more expensive computationally.</p>
<p>An n-gram is a subsequence of <em>n</em> consecutive, overlapping, tokens. In this experiment, we use word n-grams, which are n-grams of word-tokens. They are counted the same way as a bag-of-words, with the n-grams forming a <em>word</em> that is put in the bag. The value of a cell in this dataset is the frequency that a particular n-gram appears in the given document.</p>
<div class="packt_infobox">The value of n is a parameter. For English, setting it to between 2 to 5 is a good start, although some applications call for higher values. Higher values for n result in sparse datasets, as when n increases it is less likely to have the same n-gram appear across multiple documents. Having n=1 results in simply the bag-of-words model.</div>
<p>As an example, <kbd>for n=3</kbd>, we extract the first few n-grams in the following quote:</p>
<div class="packt_quote"><em>Always look on the bright side of life.</em></div>
<p>The first n-gram (of size 3) is <em>Always look on</em>, the second is <em>look on the</em>, the third is <em>on the bright</em>. As you can see, the n-grams overlap and cover three words each. Word n-grams have advantages over using single words. This simple concept introduces some context to word use by considering its local environment, without a large overhead of understanding the language computationally.</p>
<p>A disadvantage of using n-grams is that the matrix becomes even sparser—word n-grams are unlikely to appear twice (especially in tweets and other short documents!). Specifically for social media and other short documents, word n-grams are unlikely to appear in too many different tweets, unless it is a retweet. However, in larger documents, word n-grams are quite effective for many applications. Another form of n-gram for text documents is that of a character n-gram. That said, you'll see shortly that word n-grams are quite effective in practice.</p>
<p>Rather than using sets of words, we simply use sets of characters (although character n-grams have lots of options for how they are computed!). This type of model can help identify words that are misspelled, as well as providing other benefits to classification. We will test character n-grams in this chapter and see them again in <a href="3b134aaf-e967-486f-adc6-83f8ed1943c4.xhtml">Chapter 9</a><em>, Authorship Attribution</em>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Other text features</h1>
            </header>

            <article>
                
<p>There are other features that can be extracted too. These include syntactic features, such as the usage of particular words in sentences. Part-of-speech tags are also popular for data mining applications that need to understand meaning in text. Such feature types won't be covered in this book. If you are interested in learning more, I recommend <em>Python 3 Text Processing with NLTK 3 Cookbook, Jacob Perkins, Packt publication</em>.</p>
<p>There are a number of libraries for working with text data in Python. The most commonly known one is called the <span class="packt_screen">Natural Language ToolKit (NLTK)</span>. The <span class="packt_screen">scikit-learn</span> library also has the <span class="packt_screen">CountVectorizer</span> class that performs a similar action, and it is recommended you take a look at it (we will use it in <a href="3b134aaf-e967-486f-adc6-83f8ed1943c4.xhtml" target="_blank">Chapter 9</a><em>, Authorship Attribution</em>). NLTK has more features for word tokenization and part of speech tagging (that is identifying which words are nouns, verbs and so on).</p>
<p>The library we are going to use is called spaCy. It is designed from the ground up to be fast and reliable for natural language processing. Its less-well-known than NLTK, but is rapidly growing in popularity. It also simplifies some of the decisions, but has a slightly more difficult syntax to use, compared to NLTK.</p>
<div class="packt_tip">For production systems, I recommend using spaCy, which is faster than NLTK. NLTK was built for teaching, while spaCy was built for production. They have different syntaxes, meaning it can be difficult to port code from one library to another. If you aren't looking into experimenting with different types of natural language parsers, I recommend using spaCy.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Naive Bayes</h1>
            </header>

            <article>
                
<p>Naive Bayes is a probabilistic model that is, unsurprisingly, built upon a naive interpretation of Bayesian statistics. Despite the naive aspect, the method performs very well in a large number of contexts. Because of the naive aspect, it works quite quickly. It can be used for classification of many different feature types and formats, but we will focus on one in this chapter: binary features in the bag-of-words model.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Understanding Bayes' theorem</h1>
            </header>

            <article>
                
<p>For most of us, when we were taught statistics, we started from a <strong>frequentist approach</strong>. In this approach, we assume the data comes from some distribution and we aim to determine what the parameters are for that distribution. However, those parameters are (perhaps incorrectly) assumed to be fixed. We use our model to describe the data, even testing to ensure the data fits our model.</p>
<p>Bayesian statistics instead model how people (at least, non-frequentist statisticians) actually reason. We have some data, and we use that data to update our model about how likely something is to occur. In Bayesian statistics, we use the data to describe the model rather than using a model and confirming it with data (as per the frequentist approach).</p>
<p>It should be noted that frequentist statistics and Bayesian statistics ask and answer slightly different questions. A direct comparison is not always correct.</p>
<p>Bayes' theorem computes the value of <span class="packt_screen">P(A|B)</span>. That is, knowing that <span class="packt_screen">B</span> has occurred, what is the probability of event <span class="packt_screen">A</span> occurring. In most cases, <span class="packt_screen">B</span> is an observed event such as <em>it rained yesterday</em>, and <span class="packt_screen">A</span> is a prediction it will rain today. For data mining, <span class="packt_screen">B</span> is usually <em>we observed this sample</em> and <span class="packt_screen">A</span> is <em>does the sample belong to this class</em> (the class prediction). We will see how to use Bayes' theorem for data mining in the next section.</p>
<p>The equation for Bayes' theorem is given as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="50" src="assets/B06162_06_01.png" width="225"/></div>
<p>As an example, we want to determine the probability that an e-mail containing the word <span class="packt_screen">drugs</span> is spam (as we believe that such a tweet may be a pharmaceutical spam).</p>
<p><em>A</em>, in this context, is the probability that this tweet is spam. We can compute <em>P(A)</em>, called the prior belief directly from a training data by computing the percentage of tweets in our dataset that are spam. If our dataset contains 30 spam messages for every 100 e-mails, <em>P(A)</em> is 30/100 or 0.3.</p>
<p><em>B</em>, in this context, is this tweet contains the word <em>drugs</em>. Likewise, we can compute <em>P(B)</em> by computing the percentage of tweets in our dataset containing the word drugs. If 10 e-mails in every 100 of our training dataset contain the word drugs, <em>P(B)</em> is 10/100 or 0.1. Note that we don't care if the e-mail is spam or not when computing this value.</p>
<p><em>P(B|A)</em> is the probability that an e-mail contains the word drugs if it is spam. This is also easy to compute from our training dataset. We look through our training set for spam e-mails and compute the percentage of them that contain the word drugs. Of our 30 spam e-mails, if 6 contain the word drugs, then <em>P(B|A)</em> is calculated as 6/30 or 0.2.</p>
<p>From here, we use Bayes' theorem to compute <em>P(A|B)</em>, which is the probability that a tweet containing the word drugs is spam. Using the previous equation, we see the result is 0.6. This indicates that if an e-mail has the word drugs in it, there is a 60 percent chance that it is spam.</p>
<div class="packt_tip">Note the empirical nature of the preceding example—we use evidence directly from our training dataset, not from some preconceived distribution. In contrast, a frequentist view of this would rely on us creating a distribution of the probability of words in tweets to compute similar equations.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Naive Bayes algorithm</h1>
            </header>

            <article>
                
<p>Looking back at our Bayes' theorem equation, we can use it to compute the probability that a given sample belongs to a given class. This allows the equation to be used as a classification algorithm.</p>
<p>With <em>C</em> as a given class and <em>D</em> as a sample in our dataset, we create the elements necessary for Bayes' theorem, and subsequently Naive Bayes. Naive Bayes is a classification algorithm that utilizes Bayes' theorem to compute the probability that a new data sample belongs to a particular class.</p>
<p><em>P(D)</em> is the probability of a given data sample. It can be difficult to compute this, as the sample is a complex interaction between different features, but luckily it is constant across all classes. Therefore, we don't need to compute it at all, as all we do in the final step is compare relative values. </p>
<p><em>P(D|C)</em> is the probability of the data point belonging to the class. This could also be difficult to compute due to the different features. However, this is where we introduce the naive part of the Naive Bayes algorithm. We naively assume that each feature is independent of each other. Rather than computing the full probability of <em>P(D|C)</em>, we compute the probability of each feature <em>D1, D2, D3, ...</em> and so on. Then, we just multiply them together:</p>
<p>P<em>(D|C) = P(D1|C) x P(D2|C).... x P(Dn|C)</em></p>
<p>Each of these values is relatively easy to compute with binary features; we simply compute the percentage of times it is equal in our sample dataset.</p>
<div class="packt_infobox">In contrast, if we were to perform a non-naive Bayes version of this part, we would need to compute the correlations between different features for each class. Such computation is infeasible at best, and nearly impossible without vast amounts of data or adequate language analysis models.</div>
<p>From here, the algorithm is straightforward. We compute <span class="packt_screen">P(C|D)</span> for each possible class, ignoring the <span class="packt_screen">P(D)</span> term entirely. Then we choose the class with the highest probability. As the <span class="packt_screen">P(D)</span> term is consistent across each of the classes, ignoring it has no impact on the final prediction.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works</h1>
            </header>

            <article>
                
<p>As an example, suppose we have the following (binary) feature values from a sample in our dataset: <span class="packt_screen">[0, 0, 0, 1]</span>.</p>
<p>Our training dataset contains two classes with 75 percent of samples belonging to the class 0, and 25 percent belonging to the class 1. The likelihood of the feature values for each class are as follows:</p>
<p>For class 0: <span class="packt_screen">[0.3, 0.4, 0.4, 0.7]</span></p>
<p>For class 1: <span class="packt_screen">[0.7, 0.3, 0.4, 0.9]</span></p>
<p>These values are to be interpreted as: for feature 1, it has a value of 1 in 30 percent of cases for samples with class 0. It is a value of 1 in 70 percent of samples with class 1. </p>
<p>We can now compute the probability that this sample should belong to the class 0. <span class="packt_screen">P(C=0) = 0.75</span> which is the probability that the class is 0. Again, <span class="packt_screen">P(D)</span> isn't needed for the Naive Bayes algorithm and is simply removed from the equation. Let's take a look at the calculation:</p>
<pre>
P(D|C=0) = P(D1|C=0) x P(D2|C=0) x P(D3|C=0) x P(D4|C=0) <br/>= 0.3 x 0.6 x 0.6 x 0.7 <br/>= 0.0756
</pre>
<div class="packt_infobox">The second and third values are 0.6, because the value of that feature in the sample was 0. The listed probabilities are for values of 1 for each feature. Therefore, the probability of a 0 is its inverse: <em>P(0) = 1 – P(1)</em>. </div>
<p>Now, we can compute the probability of the data point belonging to this class. Let's take a look at the calculation:</p>
<pre>
P(C=0|D) = P(C=0) P(D|C=0) = 0.75 * 0.0756 = 0.0567 
</pre>
<p>Now, we compute the same values for the class 1:</p>
<pre>
P(D|C=1) = P(D1|C=1) x P(D2|C=1) x P(D3|C=1) x P(D4|C=1)<br/>         = 0.7 x 0.7 x 0.6 x 0.9<br/>         = 0.2646 P(C=1|D) <br/>         = P(C=1)P(D|C=1)<br/>         = 0.25 * 0.2646<br/>         = 0.06615
</pre>
<div class="packt_infobox">Normally, <span class="packt_screen">P(C=0|D) + P(C=1|D)</span> should equal to 1. After all, those are the only two possible options! However, the probabilities are not 1 due to the fact we haven't included the computation of <span class="packt_screen">P(D)</span> in our equations here.</div>
<p>As the value for <em>P(C=1|D)</em> is more than <em>P(C=0|D)</em>, the data point should be classified as belonging to the class 1. You may have guessed this while going through the equations anyway; however, you may have been a bit surprised that the final decision was so close. After all, the probabilities in computing <em>P(D|C)</em> were much, much higher for the class 1. This is because we introduced a prior belief that most samples generally belong to the class 0.</p>
<p>If the classes had been equal sizes, the resulting probabilities would be much different. Try it yourself by changing both <em>P(C=0)</em> and <em>P(C=1)</em> to 0.5 for equal class sizes and computing the result again.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Applying of Naive Bayes</h1>
            </header>

            <article>
                
<p>We will now create a pipeline that takes a tweet and determines whether it is relevant or not, based only on the content of that tweet.</p>
<p>To perform the word extraction, we will be using the spaCy, a library that contains a large number of tools for performing analysis on natural language. We will use spaCy in future chapters as well.</p>
<div class="packt_infobox">To get spaCy on your computer, use pip to install the package: <span class="packt_screen">pip install spacy<br/></span>If that doesn't work, see the spaCy installation instructions at <a href="https://spacy.io/">https://spacy.io/</a> for information specific to your platform.</div>
<p>We are going to create a pipeline to extract the word features and classify the tweets using Naive Bayes. Our pipeline has the following steps:</p>
<ul>
<li>Transform the original text documents into a dictionary of counts using spaCy's word tokenization.</li>
<li>Transform those dictionaries into a vector matrix using the <kbd><span class="packt_screen">DictVectorizer</span></kbd> transformer in scikit-learn. This is necessary to enable the Naive Bayes classifier to read the feature values extracted in the first step.</li>
<li>Train the Naive Bayes classifier, as we have seen in previous chapters.</li>
</ul>
<p>We will need to create another Notebook (last one for the chapter!) called <kbd>ch6_classify_twitter</kbd> for performing the classification.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Extracting word counts</h1>
            </header>

            <article>
                
<p>We are going to use spaCy to extract our word counts. We still want to use it in a pipeline, but spaCy doesn't conform to our transformer interface. We will need to create a basic transformer to do this to obtain both fit and transform methods, enabling us to use this in a pipeline.</p>
<p>First, set up the transformer class. We don't need to <em>fit</em> anything in this class, as this transformer simply extracts the words in the document. Therefore, our fit is an empty function, except that it returns self which is necessary for transformer objects to conform to the scikit-learn API.</p>
<p>Our transform is a little more complicated. We want to extract each word from each document and record True if it was discovered. We are only using the binary features here—True if in the document, False otherwise. If we wanted to use the frequency we would set up counting dictionaries, as we have done in several of the past chapters.</p>
<p>Let's take a look at the code:</p>
<pre>
import spacy<br/>from sklearn.base import TransformerMixin<br/><br/># Create a spaCy parser<br/>nlp = spacy.load('en')<br/><br/><br/>class BagOfWords(TransformerMixin):<br/>    def fit(self, X, y=None):<br/>        return self<br/><br/>    def transform(self, X):<br/>        results = []<br/>        for document in X:<br/>            row = {}<br/>            for word in list(nlp(document, tag=False, parse=False, entity=False)):<br/>                if len(word.text.strip()): # Ignore words that are just whitespace<br/>                    row[word.text] = True<br/>                    results.append(row)<br/>        return results
</pre>
<p>The result is a list of dictionaries, where the first dictionary is the list of words in the first tweet, and so on. Each dictionary has a word as key and the value <span class="packt_screen">True</span> to indicate this word was discovered. Any word not in the dictionary will be assumed to have not occurred in the tweet. Explicitly stating that a word's occurrence is <span class="packt_screen">False</span> will also work, but will take up needless space to store.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Converting dictionaries to a matrix</h1>
            </header>

            <article>
                
<p>The next step converts the dictionaries built as per the previous step into a matrix that can be used with a classifier. This step is made quite simple through the <span class="packt_screen">DictVectorizer</span> transformer that is provided as part of scikit-learn.</p>
<p>The <kbd>DictVectorizer</kbd> class simply takes a list of dictionaries and converts them into a matrix. The features in this matrix are the keys in each of the dictionaries, and the values correspond to the occurrence of those features in each sample. Dictionaries are easy to create in code, but many data algorithm implementations prefer matrices. This makes <kbd>DictVectorizer</kbd> a very useful class.</p>
<p>In our dataset, each dictionary has words as keys and only occurs if the word actually occurs in the tweet. Therefore, our matrix will have each word as a feature and a value of True in the cell if the word occurred in the tweet.</p>
<p>To use <kbd>DictVectorizer</kbd>, simply import it using the following command:</p>
<pre>
from sklearn.feature_extraction import DictVectorizer
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Putting it all together</h1>
            </header>

            <article>
                
<p>Finally, we need to set up a classifier and we are using Naive Bayes for this chapter. As our dataset contains only binary features, we use the <kbd>BernoulliNB</kbd> classifier that is designed for binary features. As a classifier, it is very easy to use. As with <kbd>DictVectorizer</kbd>, we simply import it and add it to our pipeline:</p>
<pre>
from sklearn.naive_bayes import BernoulliNB
</pre>
<p>Now comes the moment to put all of these pieces together. In our Jupyter Notebook, set the filenames and load the dataset and classes as we have done before. Set the filenames for both the tweets themselves (not the IDs!) and the labels that we assigned to them. The code is as follows:</p>
<pre>
import os<br/>input_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "python_tweets.json")<br/>labels_filename = os.path.join(os.path.expanduser("~"), "Data", "twitter", "python_classes.json")
</pre>
<p>Load the tweets themselves. We are only interested in the content of the tweets, so we extract the text value and store only that. The code is as follows:</p>
<pre>
import json<br/><br/>tweets = []<br/>with open(input_filename) as inf:<br/>    for line in inf:<br/>        if len(line.strip()) == 0: continue<br/>        tweets.append(json.loads(line)['text'])<br/><br/>with open(labels_filename) as inf:<br/>    labels = json.load(inf)<br/><br/># Ensure only classified tweets are loaded<br/>tweets = tweets[:len(labels)]
</pre>
<p>Now, create a pipeline putting together the components from before. Our pipeline has three parts:</p>
<ol>
<li>The NLTKBOW transformer we created.</li>
<li>A DictVectorizer transformer.</li>
<li>A BernoulliNB classifier.</li>
</ol>
<p>The code is as follows:</p>
<pre>
from sklearn.pipeline import Pipeline<br/><br/>pipeline = Pipeline([('bag-of-words', BagOfWords()), ('vectorizer', DictVectorizer()), ('naive-bayes', BernoulliNB()) ])
</pre>
<p>We can nearly run our pipeline now, which we will do with <kbd>cross_val_score</kbd>  as we have done many times before. Before we perform the data mining, we will introduce a better evaluation metric than the accuracy metric we used before. As we will see, the use of accuracy is not adequate for datasets when the number of samples in each class is different.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Evaluation using the F1-score</h1>
            </header>

            <article>
                
<div class="packt_infobox">When choosing an evaluation metric, it is always important to consider cases where that evaluation metric is not useful. Accuracy is a good evaluation metric in many cases, as it is easy to understand and simple to compute. However, it can be easily faked. In other words, in many cases, you can create algorithms that have a high accuracy but have a poor utility.</div>
<p>While our dataset of tweets (typically, your results may vary) contains about 50 percent programming-related and 50 percent nonprogramming, many datasets aren't as <em>balanced</em> as this.</p>
<p>As an example, an e-mail spam filter may expect to see more than 80 percent of incoming e-mails be spam. A spam filter that simply labels everything as spam is quite useless; however, it will obtain an accuracy of 80 percent!</p>
<p>To get around this problem, we can use other evaluation metrics. One of the most commonly employed is called an <strong>f1-score</strong> (also called f-score, f-measure, or one of many other variations on this term).</p>
<div class="packt_infobox">The F1-score is defined on a per-class basis and is based on two concepts: the precision and recall. The precision is the percentage of all the samples that were predicted as belonging to a specific class, that were actually from that class. The recall is the percentage of samples in the dataset that are in a class and actually labeled as belonging to that class.</div>
<p>In the case of our application, we could compute the value for both classes (python-programming and not <span>python-programming</span>).</p>
<p>Our precision computation becomes the question: <q>of all the tweets that were predicted as being relevant, what percentage were actually relevant?</q></p>
<p>Likewise, the recall becomes the question: <q>of all the relevant tweets in the data set, how many were predicted as being relevant?</q></p>
<p>After you compute both the precision and recall, the f1-score is the harmonic mean of the precision and recall:</p>
<p>To use the f1-score in scikit-learn methods, simply set the scoring parameter to f1. By default, this will return the f1-score of the class with label 1. Running the code on our dataset, we simply use the following line of code:</p>
<pre>
from sklearn.cross_validation import cross_val_score<br/>scores = cross_val_score(pipeline, tweets, labels, scoring='f1')<br/># We then print out the average of the scores:<br/>import numpy as np<br/>print("Score: {:.3f}".format(np.mean(scores)))
</pre>
<p>The result is 0.684, which means we can accurately determine if a tweet using Python relates to the programing language nearly 70 percent of the time. This is using a dataset with only 300 tweets in it.</p>
<p>Go back and collect more data and you will find that the results increase! Keep in mind that your dataset may differ, and therefore your results would too. </p>
<div class="packt_tip">More data usually means a better accuracy, but it is not guaranteed!</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting useful features from models</h1>
            </header>

            <article>
                
<p>One question you may ask is, what are the best features for determining if a tweet is relevant or not? We can extract this information from our Naive Bayes model and find out which features are the best individually, according to Naive Bayes.</p>
<p>First, we fit a new model. While the <kbd>cross_val_score</kbd> gives us a score across different folds of cross-validated testing data, it doesn't easily give us the trained models themselves. To do this, we simply fit our pipeline with the tweets, creating a new model. The code is as follows:</p>
<pre>
 model = pipeline.fit(tweets, labels)
</pre>
<div class="packt_infobox">Note that we aren't really evaluating the model here, so we don't need to be as careful with the training/testing split. However, before you put these features into practice, you should evaluate on a separate test split. We skip over that here for the sake of clarity.</div>
<p>A pipeline gives you access to the individual steps through the <kbd>named_steps</kbd> attribute and the name of the step (we defined these names ourselves when we created the pipeline object itself). For instance, we can get the Naive Bayes model:</p>
<pre>
nb = model.named_steps['naive-bayes']<br/>feature_probabilities = nb.feature_log_prob_
</pre>
<p>From this model, we can extract the probabilities for each word. These are stored as log probabilities, which is simply <em>log(P(A|f))</em>, where <em>f</em> is a given feature.</p>
<p>The reason these are stored as log probabilities is because the actual values are very low. For instance, the first value is -3.486, which correlates to a probability under 0.03 percent. Logarithm probabilities are used in computation involving small probabilities like this as they stop underflow errors where very small values are just rounded to zeros. Given that all of the probabilities are multiplied together, a single value of 0 will result in the whole answer always being 0! Regardless, the relationship between values is still the same; the higher the value, the more useful that feature is.</p>
<p>We can get the most useful features by sorting the array of logarithm probabilities. We want descending order, so we simply negate the values first. The code is as follows:</p>
<pre>
top_features = np.argsort(-nb.feature_log_prob_[1])[:50]
</pre>
<p>The preceding code will just give us the indices and not the actual feature values. This isn't very useful, so we will map the feature's indices to the actual values. The key is the DictVectorizer step of the pipeline, which created the matrices for us. Luckily this also records the mapping, allowing us to find the feature names that correlate to different columns. We can extract the features from that part of the pipeline:</p>
<pre>
dv = model.named_steps['vectorizer']
</pre>
<p>From here, we can print out the names of the top features by looking them up in the <kbd>feature_names_</kbd> attribute of DictVectorizer. Enter the following lines into a new cell and run it to print out a list of the top features:</p>
<pre>
for i, feature_index in enumerate(top_features):<br/>    print(i, dv.feature_names_[feature_index], np.exp(feature_probabilities[1][feature_index]))
</pre>
<p>The first few features include : RT, and even Python. These are likely to be noise (although the use of a colon is not very common outside programming), based on the data we collected. Collecting more data is critical to smoothing out these issues. Looking through the list though, we get a number of more obvious programming features:</p>
<pre>
9 for 0.175<br/>14 ) 0.10625<br/>15 ( 0.10625<br/>22 jobs 0.0625<br/>29 Developer 0.05
</pre>
<p>There are some others too that refer to Python in a work context, and therefore might be referring to the programming language (although freelance snake handlers may also use similar terms, they are less common on Twitter).</p>
<p>That last one is usually in the format: <q>We're looking for a candidate for this job</q>.</p>
<p>Looking through these features gives us quite a few benefits. We could train people to recognize these tweets, look for commonalities (which give insight into a topic), or even get rid of features that make no sense. For example, the word RT appears quite high in this list; however, this is a common Twitter phrase for retweet (that is, forwarding on someone else's tweet). An expert could decide to remove this word from the list, making the classifier less prone to the noise we introduced by having a small dataset.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we looked at text mining—how to extract features from text, how to use those features, and ways of extending those features. In doing this, we looked at putting a tweet in context—was this tweet mentioning python referring to the programming language? We downloaded data from a web-based API, getting tweets from the popular microblogging website Twitter. This gave us a dataset that we labeled using a form we built directly in the Jupyter Notebook.</p>
<p>We also looked at reproducibility of experiments. While Twitter doesn't allow you to send copies of your data to others, it allows you to send the tweet's IDs. Using this, we created code that saved the IDs and recreated most of the original dataset. Not all tweets were returned; some had been deleted in the time since the ID list was created and the dataset was reproduced.</p>
<p>We used a Naive Bayes classifier to perform our text classification. This is built upon the Bayes' theorem that uses data to update the model, unlike the frequentist method that often starts with the model first. This allows the model to incorporate and update new data, and incorporate a prior belief. In addition, the naive part allows to easily compute the frequencies without dealing with complex correlations between features.</p>
<p>The features we extracted were word occurrences—did this word occur in this tweet? This model is called bag-of-words. While this discards information about where a word was used, it still achieves a high accuracy on many datasets. This entire pipeline of using the bag-of-words model with Naive Bayes is quite robust. You will find that it can achieve quite good scores on most text-based tasks. It is a great baseline for you, before trying more advanced models. As another advantage, the Naive Bayes classifier doesn't have any parameters that need to be set (although there are some if you wish to do some tinkering).</p>
<p>To extend the work we did in this chapter, first start by collecting more data. You'll need to manually classify these as well, but you'll find some similarities between tweets that might make it easier. For example, there is a field of study called Locality Sensitive Hashes, that determines whether two tweets are similar. Two similar tweets are likely about the same topic. Another method for extending the research is to consider how you would build a model that incorporates the twitter user's history into the equation - in other words, if the user often tweets about python-as-a-programming-language, then they are more likely to be using python in a future tweet.</p>
<p>In the next chapter, we will look at extracting features from another type of data, graphs, in order to make recommendations on who to follow on social media.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>