["```py\npip install flask\npip install flask-restful\n```", "```py\nfrom fileinput import filename\nfrom flask import *\nfrom radon.complexity import cc_visit\nfrom radon.cli.harvest import CCHarvester\napp = Flask(__name__)\n# Dictionary to store the metrics for the file submitted\n# Metrics: lines of code and McCabe complexity\nmetrics = {}\ndef calculate_metrics(file_path):\n    with open(file_path, 'r') as file:\n        content = file.read()\n    # Count lines of code\n    lines = len(content.splitlines())\n    # Calculate McCabe complexity\n    complexity = cc_visit(content)\n    # Store the metrics in the dictionary\n    metrics[file_path] = {\n        'lines_of_code': lines,\n        'mccabe_complexity': complexity\n    }\n@app.route('/')\ndef main():\n    return render_template(\"index.html\")\n@app.route('/success', methods=['POST'])\ndef success():\n    if request.method == 'POST':\n        f = request.files['file']\n        # Save the file to the server\n        file_path = f.filename\n        f.save(file_path)\n        # Calculate metrics for the file\n        calculate_metrics(file_path)\n        # Return the metrics for the file\n        return metrics[file_path]\n@app.route('/metrics', methods=['GET'])\ndef get_metrics():\n    if request.method == 'GET':\n        return metrics\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True)\n```", "```py\n<html>\n<head>\n    <title>Machine learning best practices for software engineers: Chapter 16 - Upload a file to make predictions</title>\n</head>\n<body>\n    <h1>Machine learning best practices for software engineers - Chapter 16</h1>\n    <p>This page allows to upload a file to a web service that has been written using Flask. The web application behind this interface calculates metrics that are important for the predictions. It returns a JSON string with the metrics.  </p>\n    <p>We need another web app that contains the model in order to actually obtain predictions if the file can contain defects. </p>\n    <h1>Upload a file to make predictions</h1>\n    <p>The file should be a .c or .cpp file</p>\n    <form action = \"/success\" method = \"post\" enctype=\"multipart/form-data\">\n        <input type=\"file\" name=\"file\" />\n        <input type = \"submit\" value=\"Upload\">\n    </form>\n    <p>Disclaimer: the container saves the file it its local folder, so don't send any sensitive files for analysis.</p>\n    <p>This is a research prototype</p>\n</body>\n</html>\n```", "```py\n#\n# This is a flask web service to make predictions on the data\n# that is sent to it. It is meant to be used with the measurement instrument\n#\nfrom flask import *\nfrom joblib import load\nimport pandas as pd\napp = Flask(__name__)   # create an app instance\n# entry point where we send JSON with two parameters:\n# LOC and MCC\n# and make prediction using make_prediction method\n@app.route('/predict/<loc>/<mcc>')\ndef predict(loc,mcc):\n    return {'Defect': make_prediction(loc, mcc)}\n@app.route('/')\ndef hello():\n    return 'Welcome to the predictor! You need to send a GET request with two parameters: LOC (lines of code) and MCC (McCabe complexity))'\n# the main method for making the prediction\n# using the model that is stored in the joblib file\ndef make_prediction(loc, mcc):\n    # now read the model from the joblib file\n    # and predict the defects for the X_test data\n    dt = load('dt.joblib')\n    # input data to the model\n    input = {'LOC': loc,\n             'MCC': mcc}\n    # convert input data into dataframe\n    X_pred = pd.DataFrame(input, index=[0])\n    # make prediction\n    y_pred = dt.predict(X_pred)\n    # return the prediction\n    # as an integer\n    return int(y_pred[0])\n# run the application\nif __name__ == '__main__':\n    app.run(debug=True)\n```", "```py\nFROM alpine:latest\nRUN apk update\nRUN apk add py-pip\nRUN apk add --no-cache python3-dev\nRUN pip install --upgrade pip\nWORKDIR /app\nCOPY . /app\nRUN pip --no-cache-dir install -r requirements.txt\nCMD [\"python3\", \"main.py\"]\n```", "```py\nflask\nflask-restful\n```", "```py\ndocker build -t measurementinstrument .\n```", "```py\ndocker run -t -p 5000:5000 measurementinstrument\n```", "```py\nFROM ubuntu:latest\nRUN apt update && apt install python3 python3-pip -y\nWORKDIR /app\nCOPY . /app\nRUN pip --no-cache-dir install -q -r requirements.txt\nCMD [\"python3\", \"main.py\"]\n```", "```py\nscikit-learn\nscipy\nflask\nflask-restful\njoblib\npandas\nnumpy\n```", "```py\ndocker build -t predictor .\n```", "```py\ndocker run -t -p 5001:5000 predictor\n```", "```py\nimport requests\n# URL of the Flask web service for file upload\nupload_url = 'http://localhost:5000/success'  # Replace with the actual URL\n# URL of the Flask web service for predictions\nprediction_url = 'http://localhost:5001/predict/'  # Replace with the actual URL\ndef upload_file_and_get_metrics(file_path):\n    try:\n        # Open and read the file\n        with open(file_path, 'rb') as file:\n            # Create a dictionary to hold the file data\n            files = {'file': (file.name, file)}\n            # Send a POST request with the file to the upload URL\n            response = requests.post(upload_url, files=files)\n            response.raise_for_status()\n            # Parse the JSON response\n            json_result = response.json()\n            # Extract LOC and mccabe_complexity from the JSON result\n            loc = json_result.get('lines_of_code')\n            mccabe_complexity = json_result.get('mccabe_complexity')[0][-1]\n            if loc is not None and mccabe_complexity is not None:\n                print(f'LOC: [3], McCabe Complexity: {mccabe_complexity}')\n                return loc, mccabe_complexity\n            else:\n                print('LOC or McCabe Complexity not found in JSON result.')\n    except Exception as e:\n        print(f'Error: {e}')\ndef send_metrics_for_prediction(loc, mcc):\n    try:\n        # Create the URL for making predictions\n        predict_url = f'{prediction_url}[3]/[4]'\n        # Send a GET request to the prediction web service\n        response = requests.get(predict_url)\n        response.raise_for_status()\n        # Parse the JSON response to get the prediction\n        prediction = response.json().get('Defect')\n        print(f'Prediction: {prediction}')\n    except Exception as e:\n        print(f'Error: {e}')\nif __name__ == '__main__':\n    # Specify the file path you want to upload\n    file_path = './main.py'  # Replace with the actual file path\n    # Upload the specified file and get LOC and McCabe Complexity\n    loc, mcc = upload_file_and_get_metrics(file_path)\n    send_metrics_for_prediction(loc, mcc)\n```"]