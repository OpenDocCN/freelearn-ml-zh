- en: Chapter 6. Getting Started with Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Django** is an open source web framework employed in commercial environments
    because it is easy to use, stable, and flexible (it takes advantage of the multiple
    libraries available in Python).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the features that we think are crucial for
    managing and analyzing data in the framework. We also explain the main parts relevant
    to building an essential web application, but further details and information
    can be found online at [https://docs.djangoproject.com](https://docs.djangoproject.com)
    or other sources. We will introduce the main parts of the framework with the basic
    concepts of a web server application (settings, models, and commands), the basics
    of HTML and the shell interface, and the general ideas of a REST framework interface
    and how it is implemented in Django (serializers, REST calls, and swagger). After
    a brief introduction of the HTTP GET and POST method for transferring data over
    the Internet, we start installing and creating a new server in Django.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP – the basics of the GET and POST methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hypertext Transfer Protocol** ( **HTTP** ) allows a client (for example,
    the web browser) to interact with a server (our application). Given a URL of a
    server web page, the GET method is the way the client queries data from the server,
    specifying some parameters. This can be explained using the `curl` command, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After the `?` symbol, the name/value pair specifies which data to query, and
    they are separated by a `&` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way a client transfers data to the server is called POST, and the data
    is in the *body* of the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start discussing how to create a new server and an application using
    Django.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and server creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Django library is installed by typing the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should install Django Version 1.7 or above (the author used version
    1.7). In order to start a new app, we type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It will generate a new folder `test_app` with the following tree of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that, inside the folder, we have the `manage.py` file, which allows
    the programmer to run various actions, and another subfolder, `test_app` , with
    the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`settings.py` : This stores all the parameters'' settings to configure the
    server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urls.py` : This collects all the URL paths available on your web application,
    and the actual functions behind the web pages are usually written in the `views.py`
    app file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsgi.py` : This is a module to make a server communicate with a web application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__init__.py` : This file is used to define every folder as a package, to import
    modules internally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On our local machine, the server with a **Welcome to Django** page is deployed
    on `http://127.0.0` `.1:8080/` simply by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `8080` is the port on which the server is started (if no port is specified,
    by default the server is started on `port 8000` ). Now that the server is ready,
    we can create as many applications as we want by simply typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new folder, `nameapp` , inside the `test_app` folder at
    root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss the contents of this folder and its functions after we explain
    the most important settings parameters. Note that for Django Version 1.9, the
    `nameapp` folder contains the `apps.py` file in order to configure `nameapp` without
    using the `settings.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `settings.py` file stores all the configurations needed for the Django
    server to operate. The most important parameters to set are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the common Django apps installed by default to manage a website,
    we will also install the REST framework:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The REST framework is an application that allows the Django app (`nameapp` in
    this case) to communicate through a REST API, and the REST Framework Swagger is
    just a web interactive interface to manage the REST APIs. These functionalities
    will be explained in the following sections. Also, note that each app created
    needs to be added in this field (in this case, `nameapp` ).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Different backend databases ( **MySQL** , **Oracle** , **PostgreSQL** , and
    so on) can be used to store the data. In this case, we use **SQLite3** (the default
    option):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The web pages are written in HTML, so a folder to store the HTML code is required.
    The `templates` folder is usually used to store the web pages layout:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To embellish a website, the CSS formatting and JavaScript code are usually
    stored in another folder, `static` , at the same level as the `server` folder.
    Then the settings need to be configured to take the files from the folder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set the URL of the website, the settings are configured to take the path
    from the file (in this case, `test_server/urls.py` ):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is possible to set up a file to store all the printout statements we want
    to put in the code for debugging purposes. We use the `logging` library and the
    following configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `test_server.log` file stores all the print statements defined using
    the `logging` library (for example, `logging.debug('write something')` ).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that all the most important settings are configured, we can focus on developing
    a new app that creates a simple email address book. So we create the app as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add the templates and static folder on the root `test_server` directory
    of the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `nameapp` on the `INSTALLED_APPS` becomes `addressesapp` . In
    the following section, we will discuss the main features of how to implement the
    app. All the code can be found in the `chapter_6` folder of the author's GitHub
    repository ([https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_6](https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_6)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Writing an app – most important features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a web application that stores e-mail addresses, we will need a table
    that stores the data and web pages that allow the end user to add, delete, and
    review the address book. Furthermore, we may want to transform the address book
    to read as a spreadsheet, or send the data to another app through the Internet.
    There are specific Django features to accomplish all these actions (`models` ,
    `views` , `admin` , API REST-framework, and `commands` ) and we will now discuss
    the way the data is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an e-mail address book, we need to store, in a table, the name of
    each contact with their e-mail address. A table in Django is called a model and
    it is defined in the `models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In Django, the columns of a table are the fields of the model, and can be of
    different types: integer, char, and so on. Note that Django automatically adds
    an incremental ID field to any new object. The unique option means that duplicate
    names cannot exist in the model, and blank states whether the field can be empty
    or not. The `__unicode__` function is optional, and it is used to render each
    person as a string (we set the name string in this case).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the model has been created, we need to apply it to the SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`makemigrations` will transform the model changes to migration files (for folder
    `migrations` inside `addressesapp` ), while `migrate` applies the change to the
    database schema. Note that in case multiple applications are used by the same
    website, then the command to generate migrations is `python manage.py makemigrations
    ''appname''` .'
  prefs: []
  type: TYPE_NORMAL
- en: URL and views behind HTML web pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to store data, we need to record contacts through a web
    page and show the contacts in another page. In the following section, the pages
    are described giving a brief overview of the main properties of HTML pages.
  prefs: []
  type: TYPE_NORMAL
- en: HTML pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the code explained in this section is stored in the folder template under
    the `test_server` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main page of the application allows the user to record a new contact, and
    it looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML pages](img/Image00528.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the body of the page is specified by two boxes to be filled
    in with the person''s name and their e-mail address, pressing **Add** to add them
    to the database. The HTML file, `home.html` , is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the POST form to submit the data collected by the two paragraph fields
    (specified by `<p>...</p>` ) and activated by the **Add** button tag (`&raquo`
    : is to render the small arrows after the text). The title of the page, **Add
    person to address book** , is rendered by a header of type 2 (`<h2>...</h2>` ).
    Note the `csrt_token` tag, which enables the cross-site forgery protection request
    (see more at [https://www.squarefree.com/securitytips/web-developers.html#CSRF](https://www.squarefree.com/securitytips/web-developers.html#CSRF)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The style of the page (CSS and JavaScript files), as well as the page footer
    and the header bar with the **Home** , **Emails Book** , and **Find** buttons,
    are defined in the `base.html` file (see the `template` folder). The **Find**
    button is implemented as a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `div` tag has been used to define the text field and the **Find** button,
    which activates a GET call to the URL defined as `get_contacts` in the `urls.py`
    file (see the following section).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other page to display is the address book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML pages](img/Image00529.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, `base.html` is called to render the main header buttons, the footer,
    and the style. After a header (of type 2) containing **Email address book** ,
    a `for` loop on the alphabet letters, `{% for letter in alphabet %}` , is performed
    to show only the contacts starting with the corresponding letter. This is achieved
    by calling the `addressesbook` URL with the letter to query `{{letter}}` . The
    list of contacts shown is then rendered, looping over the contacts list `{% for
    contact in contacts %}` : a paragraph tag displays the name, email, and a button
    to use to delete the person from the database. We will now discuss the implementation
    of the page actions (add, find, or delete person, and show address book).'
  prefs: []
  type: TYPE_NORMAL
- en: URL declarations and views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now discuss the way `urls.py` and `views.py` work together with the
    HTML code of each page to perform the desired actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen, the two main pages of the application, home and address book,
    are associated with a URL, which in Django is declared in the `urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Each URL is specified by a regex (an `r` in front of the URL string), so the
    main page is specified by `http://127.0.0.1:8000/` (the `^` start symbol is followed
    by the `$` end symbol) and its action (`add record` ) is implemented in the `main`
    function of the `views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the user posts a new contact to be store, the POST method redirects
    the call to a GET method. If the name and the email have been provided, a new
    object of the `Person` model will be added, or updated if it already exists. In
    this method, the same name but in capital letters will be considered a distinct
    name, so `Andrea` , `ANDREA` , and `andrea` will be three separate contacts. To
    change this, the reader can simply apply the lower function over the name field,
    so that the three `andrea` expressions will all refer to one `andrea` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The find action in the `base.html` file is associated with the `http://127.0.0.1:8000/book-search/`
    URL, and the action is defined in the `get_contacts` function in `views.py` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the user specifies a non-empty string on the text header field, the function
    will redirect to the `addressesbook` function with the name to search (otherwise
    a not found page is displayed).
  prefs: []
  type: TYPE_NORMAL
- en: 'The header button **Emails book** is linked to the `http://127.0.0.1:8000/book/`
    URL, which shows the contacts according to the `addressesbook` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The letter field stores the name (in case of redirection from the **Find** header
    button) or the letter (in case of calling from the emails book page), and a lookup
    over the contacts in the `Person` model is performed. The retrieved contacts are
    then stored in the `contacts` context object, while the letters are stored in
    the `alphabet` context object. If no letter is specified, all the contacts in
    the database are returned. Note that the name can have both a capital and a lowercase
    first letter, so the usual `order_by` method will not sort the names in alphabetical
    order. Therefore, the function `sort_lower` will convert each name to lowercase
    and sort the contacts alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The delete action is performed by the `delete_person` function and called by
    the `http://127.0.0.1:8000/delete/(?P<name>.*)/` URL. The `.*` indicates that
    all the characters are valid for forming a name (note that if we wanted only character
    numbers and whitespace, we should have `[a-zA-Z0-9 ]+` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `name` query variable is searched on the `Person` table in the database
    and deleted. The function returns the emails book page with the remaining contacts.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, the not found URL activates the not found function, and you
    should now be able to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The admin URL refers to the Django interface (see following section) while the
    docs is the REST framework swagger discussed in the *RESTful application programming
    interfaces (APIs)* section of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The admin panel is a user interface for managing the application, accessible
    through the browser. In the `admin.py` file, we can add the model just created
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All the models can be accessed by a user interface at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:8000/admin/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this link, the user name and password are required. We create that with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then we type a username and password (in my case, `andrea/a` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can explore the panel that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Admin](img/Image00530.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on **Persons** , we will see all `Person` objects shown by name (because
    the`__unicode__` function in the model refers to the name field):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Admin](img/Image00531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shell interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Django framework also provides a shell to explore the created models and
    test them. To start it, we type the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can import the `Person` model and play with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In these lines, we have created a new contact, `myfriend1` , and verified it
    has been added to the list of `Person` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Django framework also allows us to write custom commands through the `manage.py`
    module. For example, we would like to export the entire list of contacts into
    a CSV file. To achieve that, we create a `commands` folder inside a `management`
    folder (with `__init__.py` in each folder). The file implements the custom command
    to export the contacts list to CSV, extending the `BaseCommand` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The command must define a `handler` function, which will perform the export
    operation. Type the following from the `test_server` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: RESTful application programming interfaces (APIs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A RESTful API is an application programming interface that employs HTTP requests
    (such as GET and POST) to manage the data of an application. In this case, the
    API is used to obtain the address book through a `curl` call. In order to do that,
    we have defined the `rest_framework` app in the `INSTALLED_APPS` section of `settings.py`
    , and then the `api.py` file implements the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the `ListAPIView` class to return all `Person` objects, or only
    the one that matches the `name` value. Since the returned list may be too large,
    we need to override the `PageNumberPagination` class to show more objects on the
    same page; the `LargeResultsSetPagination` class allows a maximum of 10,000 objects
    per page. This API needs to transform the `Person` objects to a JSON format object,
    which is performed by the `AddressesSerializer serializer` implemented in `serializers.py`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the address book can be retrieved using the `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the forward slash at the end of the URL. In the same way, we can Note
    the forward slash at the end of the URL. In the same way, we can specify a name
    value to get their email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can always specify the page query parameter, in case the number
    of contacts is too large (or change the pagination size value). In the `urls.py`
    file, we also defined the docs URL to be our Swagger RESTful API, which allows
    the user to explore and test the API using a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RESTful application programming interfaces (APIs)](img/Image00532.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a user-friendly way to verify that the API is working as expected and
    the data is shown in the correct format.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to create a web application using the
    Django framework. The main features of Django, such as the `models` , `admin`
    , `views` , `commands` , `shell` , and the `RESTful API` , have been described,
    so the reader should now have the necessary knowledge to develop a web application
    in a real-life scenario.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this knowledge, together with what we have learned in the preceding
    chapters, to build our movie recommendation engine and movie sentiment analysis
    application in the following two chapters.
  prefs: []
  type: TYPE_NORMAL
