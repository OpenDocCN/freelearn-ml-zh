<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Inheritance and Variance</h1>
                </header>
            
            <article>
                
<p>If we had to choose the most important thing to learn in Julia, or in any programming language, then it has to be the concept of the data type. Abstract types and concrete types work together, providing the programmer with a powerful tool to model solutions to solve real-world problems. Multiple dispatch rely on well-defined data types to invoke the right functions. Parametric types are used so that we can reuse the basic structure of an object with a specific physical representation of the underlying data. As you can see, having a well-thought-out design for data types is of the utmost importance in software engineering practice.</p>
<p>In <a href="48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml">Chapter 2</a>, <em>Modules, Packages, and Data Type Concepts</em>, we learned about the basics of abstract and concrete types and how to build a type hierarchy based upon an inheritance relationship between the types. In <a href="6c453014-3590-4a63-9d39-9bdd735185d5.xhtml">Chapter 3</a>, <em>Designing Functions and Interfaces,</em> and <a href="962e7c27-570f-498e-89b9-d9075c58cd45.xhtml">Chapter 5</a>, <em>Reusability Patterns</em>, we also touched <span>on the subject of</span> parametric types and parametric methods. In order to utilize these concepts and language features effectively, we need a good understanding of how <em>subtyping</em> works. It may sound similar to inheritance, but it is fundamentally different.</p>
<p><span>In this chapter, we will go deeper and explore the meaning of subtyping and related topics, which includes the following topics:</span></p>
<ul>
<li><span>Implementation inheritance and behavior subtyping</span></li>
<li>Covariance, contravariance, and invariance</li>
<li>Parametric methods and diagonal rule</li>
</ul>
<p>By the end of this chapter, you will have a good understanding of subtyping in Julia. You will be more equipped to design your own data type hierarchy and utilize multiple dispatch more effectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter12">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter12</a>.</p>
<p>The code is tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing inheritance and behavior subtyping</h1>
                </header>
            
            <article>
                
<p>When we learned about inheritance, we realized that abstract types can be used to describe real-world concepts. W<span>e can say q</span><span>uite confidently that we already know how to classify concepts with parent–child relationships. With this knowledge, we can build a type hierarchy around those concepts. For example, the personal asset type hierarchy from</span> <a href="48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml">Chapter 2</a><span>, </span><em>Modules, Packages, and Data Type Concepts</em><span>, looks like the following:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc754bd8-c903-4a4a-96e7-76ff9b6dfb2f.png" style="width:42.67em;height:18.17em;"/></p>
<p>All data types shown in the preceding diagram are abstract types. Going from the bottom up, we know that both <strong>House</strong> and <strong>Apartment</strong> are subtypes of <strong>Property</strong>, and we know that both <strong>Property</strong> and <strong>Investment</strong> are a subtype of <strong>Asset</strong>. These are all reasonable interpretations based on how we speak about these concepts in our daily life.</p>
<p class="mce-root">We also talked about concrete types that are the physical realization of abstract concepts. For this same example, we ended up having <kbd>Stock</kbd> as a subtype of <kbd>Equity</kbd> and <kbd>Bond</kbd> as a subtype of <kbd>FixedIncome</kbd>. As you may recall, the <kbd>Stock</kbd> type can be defined as follows:</p>
<pre><span>struct Stock &lt;: Equity
    symbol::String<br/></span><span>    name::String
end
</span></pre>
<p class="column">Back then, we did not emphasize the fact that we cannot declare any field inside abstract types, which is something that is given in some <strong>object-oriented programming</strong> (<strong>OOP</strong>) languages, such as Java. If you come from an OOP background, then you may mistakenly feel that this is a huge constraint in Julia's inheritance system. <span>Why is Julia designed the way it is? </span>In this section, we will try to analyze inheritance in greater depth and answer this very question.</p>
<p>There are two important concepts related to inheritance that are very similar, but fundamentally different—implementation inheritance and behavior subtyping. We will discuss both in the next few sections. <span>Let's start with implementation inheritance.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding implementation inheritance</h1>
                </header>
            
            <article>
                
<p class="column">Implementation inheritance<span> allows a subclass to inherit <em>both</em> fields and methods from its superclass. As Julia does not support implementation inheritance, we will switch language for a moment and present the following example in Java. Here is a class that provides a container for holding any number of objects:</span></p>
<pre>import java.util.ArrayList;<br/><br/>public class Bag<br/>{<br/>    ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();<br/><br/>    public void add(final Object object) {<br/>        this.items.add(object);<br/>    }<br/><br/>    public void addMany(final Object[] objects) {<br/>        for (Object obj : objects) {<br/>            this.add(obj);<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>Bag</kbd> class basically maintains a list of objects in the <kbd>items</kbd> field and provides two convenient functions, <kbd>add</kbd> and <kbd>addMany</kbd>, for adding a single object or an array of objects to the bag. </p>
<p>To demonstrate code reuse, we can develop a new <kbd>CountingBag</kbd> class that inherits from <kbd>Bag</kbd> and provides additional functionality for keep tracking of how many items are stored in the bag:</p>
<pre>public class CountingBag extends Bag<br/>{<br/>    int count = 0;<br/><br/>    public void add(Object object) {<br/>        super.add(object);<br/>        this.count += 1;<br/>    }<br/><br/>    public int size() {<br/>        return count;<br/>    }<br/>}</pre>
<p>In this <kbd>CountingBag</kbd> class, we have a new field called <kbd>count</kbd> to keep track of the bag size. Whenever a new item is added to the bag, the <kbd>count</kbd> variable is incremented. The <kbd>size</kbd> function is used to report the size of the bag. So what is the situation with <kbd>CountingBag</kbd>? Let's quickly summarize:</p>
<ul>
<li>The <kbd>count</kbd> field is available as defined here.</li>
<li>The <kbd>items</kbd> field is available as inherited from <kbd>Bag</kbd>.</li>
<li>The <kbd>add</kbd> method overrides the parent's implementation, but it also reuses the parent's method via <kbd>super.add</kbd>.</li>
<li>The <kbd>addMany</kbd> method is available as inherited from <kbd>Bag</kbd>.</li>
<li>The <kbd>size</kbd> method is available as defined here.</li>
</ul>
<p>As both fields and methods are inherited, this is called implementation inheritance. The effect is almost the same as if the code from the superclass was copied into the subclass.</p>
<p>Next, let's talk about behavior subtyping.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding behavior subtyping</h1>
                </header>
            
            <article>
                
<p>Behavior subtyping is sometimes called interface inheritance. In order to avoid confusion with the overloaded word <em>inheritance</em>, we will avoid using the term interface inheritance here. Behavior subtyping says that a subtype <span>only</span><span> </span><span>inherits behaviors from the supertype. </span></p>
<div class="packt_tip">As we switch the language back to Julia, we will refer to <em>types</em> rather than <em>classes</em>.</div>
<p>Julia supports behavior subtyping. Every data type inherits functions that are defined for its supertype. Let's try a quick and fun exercise in the Julia REPL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/96050300-8545-44fa-8d6e-c5203674b49d.png" style="width:20.33em;height:9.83em;"/></p>
<p>Here, an abstract type, <kbd>Vehicle</kbd>, is defined with a subtype of <kbd>Car</kbd>. We have also defined a <kbd>move</kbd> function for <kbd>Vehicle</kbd>. When we pass a <kbd>Car</kbd> object to the <kbd>move</kbd> function, it still works properly because <kbd>Car</kbd> is a subtype of <kbd>Vehicle</kbd>. This is consistent with the Liskov substitution principle, which says that a program accepting type T can also accept any subtype of T and continue to work properly without any unintended outcome.</p>
<p>Now, the inheritance of a method can travel quite far over multiple levels. Let's create another level of abstraction:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1f69026c-ab52-4d4e-a7b4-5cf07ad3ed9b.png" style="width:27.17em;height:12.67em;"/></p>
<p>We just defined a new <kbd>FlyingVehicle</kbd> abstract type and a <kbd>Helicopter</kbd> struct. The <kbd>move</kbd> function is available for a helicopter as inherited from <kbd>Vehicle</kbd>, and the <kbd>liftoff</kbd> function is also available, as inherited from <kbd>FlyingVehicle</kbd>. </p>
<p>Additional methods can be defined for more specific types, and the most specific one would be chosen for dispatch. Doing this essentially has the same effect as method overrides in implementation inheritance. Here's an example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1656f588-ca10-4176-b729-89c4be8ecf13.png" style="width:28.92em;height:4.00em;"/></p>
<p>So far, we have defined two <kbd>liftoff</kbd> methods—one accepting <kbd>FlyingVehicle</kbd> and another for <kbd>Helicopter</kbd>. When a <kbd>Helicopter</kbd> object is passed to the function, it is dispatched to the one defined for <kbd>Helicopter</kbd>, because it is the most specific method that works with helicopters.</p>
<p>The relationship can be summarized in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c5949296-b354-4bc5-8cdf-62454a8696ea.png" style="width:31.33em;height:23.92em;"/></p>
<p>According to behavior subtyping, a car should behave like a vehicle, a flying vehicle should behave like a vehicle, and a helicopter should behave like a flying vehicle and also like a vehicle. Behavior subtyping allows us to reuse the behavior already defined for a supertype.</p>
<div class="packt_infobox">In Java, behavior subtyping can be achieved using interfaces.</div>
<p>Now that we know about implementation inheritance and behavior subtyping, we can revisit our earlier question: why does Julia not <span>support implementation inheritance? What are the reasons for not following other mainstream OOP languages? </span><span>In order to understand this, we can review some of the well-known issues with implementation inheritance. Let's start with the square-rectangle problem.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The square-rectangle problem</h1>
                </header>
            
            <article>
                
<p><span>Julia does not support implementation inheritance. Let's list the reasons:</span></p>
<ul>
<li><span>All concrete types are final, so there is no way to create new subtypes from another concrete type. Therefore, it is not possible to inherit object fields from anywhere.</span></li>
<li><span>You cannot declare any field in an abstract type because otherwise, it would be concrete rather than abstract.</span></li>
</ul>
<p><span>The core developers of the Julia programming language made a very early design decision to avoid implementation inheritance for a number of reasons. One of them is the so-called <em>square-rectangle problem</em>, also sometimes called the circle-ellipse problem.</span></p>
<p>The square-rectangle problem presents a clear challenge for implementation inheritance. As we know by common sense, every square is a rectangle with an additional constraint that the length of both sides is equal. In order to model these concepts in a class-based, object-oriented language, we may attempt to create a <kbd>Rectangle</kbd> class and a <kbd>Square</kbd> subclass:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ddda9d4a-64a2-4579-9d76-39de1690d6fe.png" style="width:11.17em;height:15.08em;"/></p>
<p>Very quickly, we realize that we have already gotten ourselves into trouble. If a <kbd>Square</kbd> has to inherit all fields from its parent class, then it would have inherited both <kbd>width</kbd> and <kbd>height</kbd>. But we really want to have a single field called <kbd>length</kbd> instead.</p>
<div class="packt_infobox">The exact same issue is sometimes presented as the circle–ellipse problem. In that case, a circle is an ellipse, but there is only one radius rather than major and minor axis lengths.</div>
<p>How do we solve this kind of problem? Well, one way is to ignore the issue and create a <kbd>Square</kbd> subclass without any field defined. Then, when a <kbd>Square</kbd> is instantiated with a particular length, both <kbd>width</kbd> and <kbd>height</kbd> fields are populated with the same value. Is that good enough? The answer is no. Given that <kbd>Square</kbd> also inherits the methods of <kbd>Rectangle</kbd>, we probably need to provide override methods for the mutating methods, such as <kbd>setWidth</kbd> and <kbd>setHeight</kbd>, so that we can keep both fields with the same value. In the end, we have a solution that seems to work functionally but is terrible in performance and memory usage.</p>
<p>But how did we get into trouble in the first place? To analyze this further, we should realize that a square, while it can be classified as a rectangle, is a more restrictive version of a rectangle in nature. This is already starting to sound unintuitive—typically, when we create subclasses, we extend the parent class and <em>add</em> more fields and functionalities. When do we want to remove fields or functionality in subclasses? It already seems to be <span>logically</span><span> backward. Maybe we should make <kbd>Rectangle</kbd> a subclass of <kbd>Square</kbd>? That does not sound very logical either.</span></p>
<p>We end up with a conundrum. On one hand, we would like to model real-world concepts properly in code. On the other hand, the code does not really fit without causing maintenance or performance issues. By now, we cannot help but ask ourselves whether we really want to write code to work around problems with implementation inheritance. We don't.</p>
<p>Perhaps you are not <span>yet</span><span> 100% convinced that implementation inheritance is more evil than good. Let's look at another problem.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The fragile base class problem</h1>
                </header>
            
            <article>
                
<p>Another problem with implementation inheritance is that changes to the base class (parent class) can possibly break functionalities of its subclasses. From the earlier Java example, we have a <kbd>CountingBag</kbd> class that extends from the <kbd>Bag</kbd> class. Let's look at the complete source code, including the <kbd>main</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e281b138-70b8-4936-b9a9-c09558b5868e.png" style="width:27.67em;height:31.83em;"/></p>
<p>The program simply creates a <kbd>CountingBag</kbd> object. Then it adds <kbd>apple</kbd> using the <kbd>add</kbd> method and adds <kbd>banana</kbd> and <kbd>orange</kbd> using the <kbd>addMany</kbd> method. Finally, it prints out the items in the bag and the size of the bag. The output is shown in the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/70e7db7a-c377-4e93-b16d-4b0f4387d178.png" style="width:12.17em;height:2.83em;"/></p>
<p>Everything looks fine at the moment. But let's say that the original author of <kbd>Bag</kbd> realizes that the <kbd>addMany</kbd> method can be improved by directly adding objects into the <kbd>items</kbd> array list:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd1de7db-5bd9-4fe7-bd7b-109a478b90f2.png" style="width:45.92em;height:5.83em;"/></p>
<p>Unfortunately, this seemingly safe change in the parent class ends up in a disaster for <kbd>CountingBag</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f5f402ab-e3d6-4d02-b68a-1994cd3f2cb4.png" style="width:16.00em;height:3.00em;"/></p>
<p>What happened? When <kbd>CountingBag</kbd> was designed, it was assumed that the <kbd>add</kbd> method would always be called when new items are added to the bag. When the <kbd>addMany</kbd> method stops calling the <kbd>add</kbd> method, the assumption no longer applies.</p>
<p>Whose fault is this? Of course, the designer of the <kbd>Bag</kbd> class cannot foresee who will inherit the class. The change in the <kbd>addMany</kbd> method did not violate any contract; the same functionality is provided, only with a different implementation under the hood. <span>The designer of</span> the <kbd>CountingBag</kbd><span> class thought it was wise to <em>tag along</em> and leverage the fact that</span> <kbd>addMany</kbd> <span>was already calling</span> the <kbd>add</kbd> <span>method, and so only the</span> <kbd>add</kbd> <span>method needed to be overridden to make <kbd>counting</kbd> work.</span></p>
<p>This poses a second issue with implementation inheritance. The subclass developer has too much knowledge about the implementation of the parent class. The ability to override the parent class's <kbd>add</kbd> method has also violated the principle of encapsulation.</p>
<p>How does OOP solve this problem? In Java, there are multiple facilities to prevent the problem presented in the preceding example:</p>
<ul>
<li>A method can be annotated with the <kbd>final</kbd> keyword to prevent the subclass from overriding the method.</li>
<li>A field can be annotated with the <kbd>private</kbd> keyword to prevent the subclass from accessing the field.</li>
</ul>
<p>The trouble is that the developer must <em>anticipate</em> how classes are going to be inherited <em>in the future</em>. Methods must be carefully examined to determine whether it is safe to allow subclasses to access or override. <span><span>L</span></span>ikewise for fields. As you can see, the problem is called the fragile base class problem for a good reason.</p>
<p>I hope we have shown you that implementation inheritance does more harm than good. For reference, in the GoF design patterns book, it was also suggested that composition is preferred over inheritance. Julia took a more radical approach by just disallowing implementation inheritance altogether.</p>
<p>Next, we will go a little further and look at a specific kind of behavior subtyping called duck typing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Revisiting duck typing</h1>
                </header>
            
            <article>
                
<p><span>There are two ways to implement behavior subtyping: <strong>nominal subtyping</strong> and <strong>structural subtyping</strong>:</span></p>
<ul>
<li><span>With nominal subtyping, you must explicitly define the relationship between a type and its supertype. Julia uses nominal subtyping, where types are explicitly annotated in function arguments. That is why a type hierarchy needs to be built to express type relationships. </span></li>
<li><span>With</span> structural subtyping, the relationship is implicitly derived as long as the subtype implements the required functions from the supertype. Julia supports structural subtyping when functions are defined with arguments and not annotated with any type.</li>
</ul>
<p><span>Julia supports structural subtyping via <strong>duck typing</strong><em>. </em></span>We first mentioned duck typing in <a href="6c453014-3590-4a63-9d39-9bdd735185d5.xhtml">Chapter 3</a>, <em>Designing Functions and Interfaces</em>. The saying is as follows:</p>
<div class="packt_quote"><span>"If it walks like a duck and quacks like a duck, then it is a duck."</span></div>
<p>In a <span>dynamic </span>type language, we sometimes care less about the exact type as long as we get the behavior we want. If we just want to hear a quack sound, who cares if we get <span>a frog? As long as it makes that quack sound, we will be happy.</span></p>
<p>Sometimes, we want duck typing for good reasons. For example, we do not normally consider horses as vehicles; however, think about the old days when horses were used for transport. In our definition, anything that implements the <kbd>move</kbd> function can be considered a vehicle. So, if we have any algorithm that needs something that moves, then there is no reason why we cannot pass a <kbd>horse</kbd> object to the algorithm:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8335a797-ae4f-41cc-8199-e198d79355a3.png" style="width:20.50em;height:9.50em;"/></p>
<p>For some people, duck typing is a little loose because you cannot easily figure out whether a type supports an interface (such as <kbd>move</kbd>). The general remedy is to use the Holy Trait pattern as described in <a href="962e7c27-570f-498e-89b9-d9075c58cd45.xhtml">Chapter 5</a>, <em>Reusability Patterns</em>.</p>
<p>Next, we will look at an important concept called variance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Covariance, invariance, and contravariance</h1>
                </header>
            
            <article>
                
<p>As it turns out, the rules for subtyping are not very straightforward. When you look at a simple type hierarchy, you can immediately tell whether one type is a subtype of another by tracing the relationships of the data types in the hierarchy. The situation becomes more complex when parametric types are involved. In this section, we will take a look at how Julia is designed with respect to <strong>variance</strong>, a concept that explains subtyping relationships for parametric types.</p>
<p>Let's first review the different kinds of variance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding different kinds of variance</h1>
                </header>
            
            <article>
                
<p>There are four different kinds of variance as described in computer science literature. We will first describe them in a formal manner first and then come back to do more hands-on exercises to reinforce our understanding. </p>
<p>Given that <kbd>S</kbd> is a subtype of <kbd>T</kbd>, there are four different ways to reason about the relationship between parametric types <kbd>P{S}</kbd> and <kbd>P{T}</kbd>:</p>
<ul>
<li>Covariant: <kbd>P{S}</kbd> is a subtype of <kbd>P{T}</kbd> (<kbd>co</kbd> here means the same direction)</li>
<li>Contravariant: <kbd>P{T}</kbd> is a subtype of <kbd>P{S}</kbd> (<kbd>contra</kbd> here means the opposite direction)</li>
<li>Invariant: neither covariant nor contravariant</li>
<li>Bivariant: both covariant and contravariant</li>
</ul>
<p>When do we find variance useful? Perhaps not too surprisingly, variance is a key ingredient whenever multiple dispatch come into action. Based on the Liskov substitution principle, the language runtime must figure out whether the object being passed is a subtype of the method argument before dispatching to the method.</p>
<p>Interestingly, variance is one thing that often diverges between different programming languages. Sometimes, there are historical reasons for this, and sometimes it depends on the target use cases for the language. In the next few sections, we will explore the topic from several angles. We will start with parametric types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parametric types are invariant</h1>
                </header>
            
            <article>
                
<p>For the purposes of illustration, we will consider a popular type hierarchy that is used by some of the OOP literature— the animal kingdom! Everyone loves <span>cats</span><span> and </span><span>dogs</span><span>. I have also included crocodiles here to explain related concepts:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d0d31151-e2ba-40a1-83ec-577dc147b3c3.png" style="width:26.58em;height:17.00em;"/></p>
<p>The corresponding code to build such a hierarchy is as follows:</p>
<pre>abstract type Vertebrate end<br/>abstract type Mammal &lt;: Vertebrate end<br/>abstract type Reptile &lt;: Vertebrate end<br/><br/>struct Cat &lt;: Mammal <br/>    name<br/>end<br/><br/>struct Dog &lt;: Mammal<br/>    name<br/>end<br/><br/>struct Crocodile &lt;: Reptile <br/>    name<br/>end</pre>
<p>For convenience, we can also define the <kbd>show</kbd> function for these new types:</p>
<pre>Base.show(io::IO, cat::Cat) = print(io, "Cat ", cat.name)<br/>Base.show(io::IO, dog::Dog) = print(io, "Dog ", dog.name)<br/>Base.show(io::IO, croc::Crocodile) = print(io, "Crocodile ", croc.name)</pre>
<p>Given such a type hierarchy, we can verify how subtypes are handled with the following <kbd>adopt</kbd> function. As nobody wants to adopt crocodiles (well, not me at least), we are restricting the function argument to subtypes of <kbd>Mammal</kbd> only:</p>
<pre>function adopt(m::Mammal)<br/>    println(m, " is now adopted.")<br/>    return m<br/>end</pre>
<p>As expected, we can adopt only cats and dogs, but not crocodiles:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/08975459-70fb-4a06-8959-06e12fc51f84.png" style="width:28.83em;height:10.08em;"/></p>
<p>What if we want to adopt many pets at the same time? Intuitively, we can just define a new function that takes an array of mammals, as follows:</p>
<pre>adopt(ms::Array{Mammal,1}) = "adopted " * string(ms)</pre>
<p class="mce-root">Unfortunately, it already failed our very first test for adopting Felix and Garfield:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/01812bf9-c675-4bed-824f-2e5a69590859.png" style="width:29.58em;height:5.17em;"/></p>
<p>What is going on? We know cats are mammals, so why would an array of cats not be passed to the method that takes an array of mammals? The answer is simple—parametric types are invariant. Here comes the very first surprise for people coming from an OOP background, for which parametric types are often covariant.</p>
<p>By invariance, even though <kbd>Cat</kbd> is a subtype of <kbd>Mammal</kbd>, we cannot say that <kbd>Array{Cat,1}</kbd> is a subtype of <kbd>Array{Mammal,1}</kbd>. In addition, an <kbd>Array{Mammal,1}</kbd><span> </span><span>actually represents a one-dimensional array of <kbd>Mammal</kbd> objects, for which each object can be any subtype of <kbd>Mammal</kbd>. As each concrete type may have different memory layout requirements, this array must store pointers rather than actual values. Another way to say this is that the objects are <em>boxed</em>.</span></p>
<p>In order to dispatch to this method, we must create an <span><kbd>Array{Mammal,1}</kbd>. This can be achieved by prefixing the array constructor with <kbd>Mammal</kbd>, as follows:</span></p>
<pre>adopt(Mammal[Cat("Felix"), Cat("Garfield")])</pre>
<p>In practice, this happens a lot more often when we have to handle an array of objects of the same type. In Julia, we can express such a homogeneous array using the type expression <kbd>Array{T,1} where T</kbd>. This means that we can define a new <kbd>adopt</kbd> method that can accept multiple mammals as long as they are the same kind:</p>
<pre>function adopt(ms::Array{T,1}) where {T &lt;: Mammal}<br/>    return "accepted same kind:" * string(ms)<br/>end</pre>
<p>Let's test the new <kbd>adopt</kbd> method now. The results are shown in the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc685976-7a59-424d-92c3-19f7172e0ca1.png" style="width:26.25em;height:9.00em;"/></p>
<p>As expected, the new <kbd>adopt</kbd> method was dispatched accordingly, depending on whether the array contains <kbd>Mammal</kbd> pointers or physical values of cats or dogs. </p>
<p>In Julia, the choice of making parametric types invariant is a conscious design decision for practical reasons. When an array contains concrete type objects, the memory can be allocated to store these objects in a very compact manner. On the other hand, when an array contains boxed objects, every reference to an element would involve dereferencing a pointer to find the object, and performance would suffer as a result.</p>
<p>There is indeed one place where Julia uses covariance, that is, method arguments. We will discuss these next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Method arguments are covariant</h1>
                </header>
            
            <article>
                
<p>It should be quite intuitive that method arguments are covariant because that is how multiple <span>dispatch work</span> today. Consider the following function:</p>
<pre>friend(m::Mammal, f::Mammal) = "$m and $f become friends."</pre>
<p>In Julia, method arguments are formally represented as a tuple. In the preceding example, the method argument is just <kbd>Tuple{Mammal,Mammal}</kbd>.</p>
<p>When we call this function with two arguments that have type <kbd>S</kbd> and <kbd>T</kbd> respectively, then it will only be dispatched if <kbd>S &lt;: Mammal</kbd> and <kbd>T &lt;: Mammal</kbd>. In this case, we should be able to pass any combination of mammals—dog/dog, dog/cat, cat/dog, and cat/cat. The following screenshot proves this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a9aeb3a9-4749-4f57-9803-ef6dd7eb3113.png" style="width:24.33em;height:12.00em;"/></p>
<p>Let's also check whether a crocodile can join the party:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0679c679-a85a-4ff3-a6e7-d24c44bf0e07.png" style="width:27.00em;height:2.58em;"/></p>
<p>As expected, <kbd>Tuple<span class="s1">{Cat</span><span class="s2">,Crocodile}</span></kbd><span class="s1"> is not a subtype of <kbd>Tuple{Mammal,Mammal}</kbd> since <kbd>Crocodile</kbd> is not a <kbd>Mammal</kbd>. </span></p>
<p>Next, let's move on to a more complex scenario. As we know, functions are first-class citizens in Julia. How do we determine whether a function is a subtype of another function during dispatch?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dissecting function types </h1>
                </header>
            
            <article>
                
<p>In Julia, functions are first class. This means that functions can be passed around as variables and can appear in method arguments. Since we have learned about the covariance property of method arguments, how do we handle the situation where functions are passed as arguments?</p>
<p>The best way to understand this is to see how functions are typically passed. Let's pick a simple example from Base:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9a999d78-16eb-42bc-8a5f-e2a539f5f27d.png" style="width:32.08em;height:9.50em;"/></p>
<p>The <kbd>all</kbd> function can be used to check whether a certain condition is evaluated as <kbd>true</kbd> for all elements in an array. To make it more flexible, it can accept a custom predicate function. For example, we can check whether all numbers are odd in an array as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4209a799-e7c9-4217-b5b7-1a398fb71426.png" style="width:17.83em;height:2.25em;"/></p>
<p>Although we know it was dispatched correctly, we can also confirm that the type of <kbd>isodd</kbd> is a subtype of <kbd>Function</kbd> as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4434e2fa-6ca2-498d-96cf-267eaa01f707.png" style="width:15.83em;height:2.50em;"/></p>
<p>It turns out that all Julia functions have their own unique type, displayed as <kbd>typeof(isodd)</kbd> in the following code, and they all have a supertype of <kbd>Function</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa1c951e-48d1-424e-ad85-ad844d47db9a.png" style="width:18.33em;height:8.75em;"/></p>
<p>Because the <kbd>all</kbd> method was defined to accept any <kbd>Function</kbd> objects, we can actually pass any function and Julia will gladly dispatch to the method. Unfortunately, this can potentially lead to undesirable results, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d6ff550d-00ed-4735-bbe0-918983883945.png" style="width:30.25em;height:5.83em;"/></p>
<p>We are getting an error here because the function being passed to <kbd>all</kbd> is supposed to take an element and return a Boolean value. Since <kbd>println</kbd> always returns <kbd>nothing</kbd>, the <kbd>all</kbd> function just raised an exception.</p>
<p>In the case that a stronger type is demanded, the specific function type can be enforced as such. Here is how we can create a safer <kbd>all</kbd> function:</p>
<pre>const SignFunctions = Union{typeof(isodd),typeof(iseven)};<br/>myall(f::SignFunctions, a::AbstractArray) = all(f, a);</pre>
<p>The <kbd>SignFunctions</kbd> constant is a union type that consists of only the types for the <kbd>isodd</kbd> and <kbd>iseven</kbd> functions. As such, the <kbd>myall</kbd> method will only be dispatched when the first argument is <kbd>isodd</kbd> or <kbd>iseven</kbd>; otherwise, a method error will be raised, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ee0ccdd-170d-4e0b-a259-be37bb21ef1a.png" style="width:30.67em;height:8.83em;"/></p>
<p>Of course, doing this severely limits the usefulness of the function. We must also enumerate all possible functions that may be passed, and that is not always feasible. So it seems that the means to handle function arguments is somewhat limited. </p>
<p>Coming back to the topic of variance, there is really nothing to talk about when <span>all functions are final and </span>there is only one supertype for all of them.</p>
<p>In practice, when we design software, we do care about the types of functions. As shown in the preceding example, the <kbd>all</kbd> function can only work with functions that take a single argument and return a Boolean value. That should be the interface contract. How do we enforce that contract, though? At the end of the day, we need to have a better understanding of functions and the contractual agreement between the caller and callee. The contract can be seen as a combination of method arguments and return types. Let's figure out whether there is a better way to handle this issue in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining the variance of the function type </h1>
                </header>
            
            <article>
                
<p>In this section, we will attempt to understand how to reason about function types. While Julia does not provide too much help in formalizing function types, it does not stop us from doing the analysis ourselves. In some strongly typed, static OOP languages, function types are more formally defined as the combination of method arguments and return type.</p>
<p>Suppose that a function takes three arguments and returns a single value. Then we can describe the function with the following notation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/20adb83e-9cde-434f-b3b8-cca09921e542.png" style="width:10.67em;height:1.25em;"/></p>
<p>Let's continue the animal kingdom example and define some new variables and functions, as follows:</p>
<pre>female_dogs = [Dog("Pinky"), Dog("Pinny"), Dog("Moonie")]<br/>female_cats = [Cat("Minnie"), Cat("Queenie"), Cat("Kittie")]<br/><br/>select(::Type{Dog}) = rand(female_dogs)<br/>select(::Type{Cat}) = rand(female_cats)</pre>
<p>Here, we have defined two arrays—one for female dogs and another for female cats. The <kbd>select</kbd> function can be used to randomly select a dog or cat. Next, let's consider the following function:</p>
<pre>match(m::Mammal) = select(typeof(m))</pre>
<p>The <kbd>match</kbd> function takes a <kbd>Mammal</kbd> and returns an object of the same type. Here's how it works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/636f421a-423d-4475-9149-328b536b2dae.png" style="width:15.17em;height:5.42em;"/></p>
<p>Given that the <kbd>match</kbd> function can only return <kbd>Dog</kbd> or <kbd>Cat</kbd>, we can reason the function type as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/23c279b7-77fd-4332-9e6d-763ad4ead096.png" style="width:14.92em;height:1.33em;"/></p>
<p>Suppose that we define two more functions, as follows:</p>
<pre># It's ok to kiss mammals :-)<br/>kiss(m::Mammal) = "$m kissed!"<br/><br/># Meet a partner<br/>function meet_partner(finder::Function, self::Mammal) <br/>    partner = finder(self)<br/>    kiss(partner)<br/>end</pre>
<p>The <kbd>meet_partner</kbd> function takes a <kbd>finder</kbd> function as the first argument. Then, it calls the <kbd>finder</kbd> function to find a partner and finally <kbd>kiss</kbd> the partner. By design, we are going to pass the <kbd>match</kbd> function that we defined in the preceding code. Let's see how it works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5cdec294-de8f-4039-abad-3fc372949b12.png" style="width:21.92em;height:2.92em;"/></p>
<p>So far, so good. From the perspective of the <kbd>meet_partner</kbd> function, it expects the <kbd>finder</kbd> function to accept a <kbd>Mammal</kbd> argument and returns a <kbd>Mammal</kbd> object. That is exactly how the <kbd>match</kbd> function was designed. Now, let's see if we can mess it up by defining a function that does not return a mammal:</p>
<pre>neighbor(m::Mammal) = Crocodile("Solomon")</pre>
<p>Although the <kbd>neighbor</kbd> function can take a mammal as an argument, it returns a crocodile, which is a reptile rather than a mammal. If we try to pass it to the <kbd>meet_partner</kbd> function, we are met with disaster:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc5086ca-29d5-48d9-85d4-a55d3de7b023.png" style="width:29.25em;height:4.50em;"/></p>
<p>What we have just proven is quite intuitive. As the return type of the <kbd>finder</kbd> function is expected to be a <kbd>Mammal</kbd>, any other <kbd>finder</kbd> function that returns any subtype of <kbd>Mammal</kbd> would also work. So the return type of function types is covariant. </p>
<p>Now, what about the arguments of function types? Again, the <kbd>meet_partner</kbd> function is expected to pass any mammal to the <kbd>finder</kbd> function. The <kbd>finder</kbd> function must be able to accept either a <kbd>dog</kbd> or <kbd>cat</kbd> object. It would not work if the <kbd>finder</kbd> function only takes a cat or dog. Let's see what happens if we have a more restrictive <kbd>finder</kbd> function:</p>
<pre>buddy(cat::Cat) = rand([Dog("Astro"), Dog("Goofy"), Cat("Lucifer")])</pre>
<p>Here, the <kbd>buddy</kbd> function takes a cat and returns a mammal. If we passed it to the <kbd>meet_partner</kbd> function, then it would not work when we want to find a partner for our dog <kbd>Chef</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4a9c5a6d-ae0e-4d50-87f6-32fca6864979.png" style="width:29.92em;height:8.42em;"/></p>
<p>So the arguments of function types are not covariant. Could it be contravariant? Well, to be contravariant, the <kbd>finder</kbd> function must accept a supertype of <kbd>Mammal</kbd>. In our animal kingdom, the only supertype is <kbd>Vertebrate</kbd>; however, <kbd>Vertebrate</kbd> is an abstract type and it cannot be constructed. If we instantiate any other concrete type that is a subtype of <kbd>Vertebrate</kbd>, it would not be a mammal (otherwise, it would be considered a mammal already). Therefore, function arguments are invariant.</p>
<p>Stated more formally, this looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/25775332-7f88-4142-be84-4d0791240019.png" style="width:28.25em;height:4.67em;"/></p>
<p>Function <kbd>g</kbd> is a subtype of function <kbd>f</kbd>, as long as <kbd>T</kbd> is <kbd>Mammal</kbd> and <kbd>S</kbd> is a subtype of <kbd>Mammal</kbd>. There is a saying about this: <em>"Be liberal in what you accept and conservative in what you produce."</em></p>
<p><span>While it is fun doing this kind of analysis, do we gain anything, given that the Julia runtime does not support function types as granular as those we have seen? It seems to be possible to simulate a type-checking effect on our own, which is the topic of the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing our own function type dispatch</h1>
                </header>
            
            <article>
                
<p>As we have seen earlier in this section, Julia creates a unique function type for every function, and they are all subtypes of the <kbd>Function</kbd> <span>abstract type.</span> We seem to be missing an opportunity for multiple <span>dispatch</span>. Taking the <kbd>all</kbd> function from <kbd>Base</kbd> as an example, it would be very nice if we could design a type that represents predicate functions rather than letting <kbd>all</kbd> fail miserably when an incompatible function is passed.</p>
<p>In order to work around this limitation, let's define a parametric type called <kbd>PredicateFunction</kbd> as follows:</p>
<pre>struct PredicateFunction{T,S}<br/>    f::Function<br/>end</pre>
<p>The <kbd>PredicateFunction</kbd> <span>parametric type</span> just wraps a function <kbd>f</kbd>. The type parameters <kbd>T</kbd> and <kbd>S</kbd> are used to represent the types of function arguments and return a type of <kbd>f</kbd> respectively. As an example, the <kbd>iseven</kbd> function can be wrapped as follows, because we know the function can take a number and return a Boolean value:</p>
<pre>PredicateFunction{Number,Bool}(iseven)</pre>
<p>Conveniently, since Julia supports callable structs, we can make it so that the <kbd>PredicateFunction</kbd> struct can be invoked as if it was a function itself. To enable this, we can define the following function:</p>
<pre>(pred::PredicateFunction{T,S})(x::T; kwargs...) where {T,S} = <br/>    pred.f(x; kwargs...)</pre>
<p>As you can see, this function merely forwards the call to the <kbd>pred.f</kbd><span> wrapped function.</span> Once it is defined, we can do some small experiments to see how it works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1f65f6b0-84cf-4ddf-bbf5-cdf415369319.png" style="width:23.67em;height:5.00em;"/></p>
<p>That looks pretty good. Let's define our own <em>safe</em> version of the <kbd>all</kbd> function as follows:</p>
<pre>function safe_all(pred::PredicateFunction{T,S}, a::AbstractArray) where <br/>        {T &lt;: Any, S &lt;: Bool}<br/>    all(pred, a)<br/>end</pre>
<p>The <kbd>safe_all</kbd> function takes a <kbd>PredicteFunction{T,S}</kbd> as the first argument, with the constraint that <kbd>T</kbd> is a subtype of <kbd>Any</kbd> and <kbd>S</kbd> is a subtype of <kbd>Bool</kbd>. It's exactly the function type signature we want for predicate functions. Knowing that <kbd>Number &lt;: Any</kbd> and <kbd>Bool &lt;: Bool</kbd>, we can definitely pass the <kbd>iseven</kbd> function to <kbd>safe_all</kbd>. Let's test it now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2b7aeac-02a3-426b-a30e-e4a187c0720f.png" style="width:29.17em;height:4.67em;"/></p>
<p><em>Bravo! </em>We have created a safe version of the <kbd>all</kbd> function. The first argument must be a predicate function that takes anything and returns a Boolean value. Rather than taking a generic <kbd>Function</kbd> argument, we can now enforce strict type matching and participate in multiple dispatch.</p>
<p>That is enough about variance. Next, we will move on and revisit the rules for the parametric method dispatch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parametric methods revisited</h1>
                </header>
            
            <article>
                
<p><span>The ability to dispatch to various methods based upon subtyping relationships is a key feature of the Julia language. </span>We initially introduced the concept of parametric methods in <a href="6c453014-3590-4a63-9d39-9bdd735185d5.xhtml">Chapter 3</a>, <em>Designing Functions and Interfaces</em>. In this section, we will go a little deeper and examine some subtle situations about how methods are selected for dispatch.</p>
<p>Let's start with the basics: how do we specify type variables for parametric methods?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying type variables</h1>
                </header>
            
            <article>
                
<p>When we define a parametric method, we use the <kbd>where</kbd> clause to introduce type variables. Let's go over a simple example:</p>
<pre>triple(x::Array{T,1}) where {T &lt;: Real} = 3x</pre>
<p>The <kbd>triple</kbd> function takes an <kbd>Array{T}</kbd>, where <kbd>T</kbd> is any subtype of <kbd>Real</kbd>. This code is very readable, and it is the format that most Julia developers choose to specify type parameters. So what could the value of <kbd>T</kbd> be? Could it be a concrete type, abstract type, or both?</p>
<p>To answer this question, we can test it out from the REPL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4b23463f-010e-4d58-870c-eea21f73d9ec.png" style="width:15.33em;height:12.08em;"/></p>
<p>So the method does get dispatched on both the abstract type (<kbd>Real</kbd>) and concrete type (<kbd>Int64</kbd>). It is worth mentioning that the <kbd>where</kbd> clause can also be placed right next to the method argument:</p>
<pre>triple(x::Array{T,1} where {T &lt;: Real}) = 3x</pre>
<p class="mce-root">From a functional perspective, it is the same as before, whether the <kbd>where</kbd> clause is placed inside or outside.</p>
<p class="mce-root">There are some subtle differences, however. When the <kbd>where</kbd> clause is placed outside, you gain two additional benefits:</p>
<ul>
<li>The type variable <kbd>T</kbd> is accessible inside the method body.</li>
<li>The type variable <kbd>T</kbd> can be used to enforce the same values if it is used for multiple method arguments.</li>
</ul>
<p>It turns out that the second point leads to an interesting feature in Julia's dispatch system. We will go over this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Matching type variables</h1>
                </header>
            
            <article>
                
<p>Whenever a type variable occurs more than once in a method signature, it is used to enforce the same type as determined across all positions where it occurs. Consider the following function:</p>
<pre>add(a::Array{T,1}, x::T) where {T &lt;: Real} = (T, a .+ x)</pre>
<p>The <kbd>add</kbd> function takes an <kbd>Array{T}</kbd> and a value of type <kbd>T</kbd>. It returns a tuple of <kbd>T</kbd> and the result of adding the value to the array. Intuitively, we want the type <kbd>T</kbd> to be consistent across both arguments. In other words, we would want the function to be specialized in each of the realizations of <kbd>T</kbd> when the function is called. Obviously, the function works great when the type agrees:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/425d6c47-b5ed-4bde-9c90-4703c762df47.png" style="width:16.50em;height:5.92em;"/></p>
<p>In the first case, <kbd>T</kbd> is determined to be <kbd>Int64</kbd>, and in the second case, <kbd>T</kbd> is determined to be <kbd>Float64</kbd>. Perhaps not too surprisingly, we may get a method error when the types do not match:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/13eb7095-6142-4e56-8a4b-7c0f52f4b414.png" style="width:36.58em;height:4.42em;"/></p>
<p>Since we said that <kbd>T</kbd> could be an abstract type, could we dispatch to this method, as <kbd>T</kbd> could be considered <kbd>Real</kbd>? The answer is no, because parametric types are <em>invariant</em>! An array of <kbd>Real</kbd> objects is not the same as an array of <kbd>Int64</kbd> values. More formally, <kbd>Array{Int}</kbd> is not a subtype of <kbd>Array{Real}</kbd>.</p>
<p>It gets a little more interesting when <kbd>T</kbd> is an abstract type in the array. Let's try this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/11d6d02b-b849-4917-b436-c1bec7a8b75d.png" style="width:20.33em;height:2.83em;"/></p>
<p>Here, <kbd>T</kbd> is unambiguously set to <kbd>Signed</kbd>, and because <kbd>Int8</kbd> is a subtype of <kbd>Signed</kbd>, the method is dispatched properly.</p>
<p>Next, we will look into another unique typing feature called the diagonal rule.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the diagonal rule</h1>
                </header>
            
            <article>
                
<p>As we learned earlier, it is a nice feature to be able to match type variables and keep them consistent across method arguments. In practice, there are situations where we want to be even more specific when determining the right type for each type variable.</p>
<p>Consider this function:</p>
<pre>diagonal(x::T, y::T) where {T &lt;: Number} = T</pre>
<p>The <kbd>diagonal</kbd> function takes two arguments with the same type, where the type <kbd>T</kbd> must be a subtype of <kbd>Number</kbd>. The type variable <kbd>T</kbd> is simply returned to the caller.</p>
<p>When <kbd>T</kbd> is concrete, it is easy to reason that the types are consistent. For example, we can pass a pair of <kbd>Int64</kbd> values or a pair of <kbd>Float64</kbd> values to the function and expect to see the respective concrete type returned:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cb4f34ea-85fb-44ff-b0e1-e30a14afc601.png" style="width:14.08em;height:5.67em;"/></p>
<p>Intuitively, we also expect this to fail when the types are not consistent:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/665bf3a1-62f1-4a40-b749-948d3f666838.png" style="width:36.08em;height:4.67em;"/></p>
<p>While it seems to work intuitively, we could have argued that the type variable <kbd>T</kbd> is an abstract type, such as <kbd>Real</kbd>. Since the value of <kbd>1</kbd> is <kbd>Int64</kbd> and <kbd>Int64</kbd> is a subtype of <kbd>Real</kbd>, and the value of <kbd>2.0</kbd> is <kbd>Float64</kbd> and <kbd>Float64</kbd> is a subtype of <kbd>Real</kbd>, shouldn't the method still get dispatched anyway? To make this point more clear, we can even annotate the argument as such when calling the function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4868de6b-d615-4a27-ab78-349d3f8e8586.png" style="width:36.25em;height:4.67em;"/></p>
<p>It turns out that Julia is designed to give us more intuitive behavior. It is also the very reason why the<strong> diagonal rule</strong> was introduced. The diagonal rule says that when a type variable occurs more than once in the covariant position (that is, the method arguments), then the type variable will be restricted to match with concrete types only. </p>
<p>In this case, the type variable <kbd>T</kbd> is considered a diagonal variable, so <kbd>T</kbd> must be a concrete type.</p>
<p>There is an exception to the diagonal rule, though. We will discuss this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An exception to the diagonal rule</h1>
                </header>
            
            <article>
                
<p>The diagonal rule<span> </span>says that when a type variable occurs more than once in the covariant position (that is, the method arguments), then the type variable will be restricted to match with concrete types only; however, there is an exception to that rule—when the type variable is unambiguously determined from an invariant position, then it is allowed to be an abstract type rather than a concrete type.</p>
<p>Consider this example:</p>
<pre>not_diagonal(A::Array{T,1}, x::T, y::T) where {T &lt;: Number} = T</pre>
<p>Unlike the <kbd>diagonal</kbd> function from the previous section, this one allows <kbd>T</kbd> to be abstract. We can prove it as such:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/49fbfd9a-7135-4306-8a5b-98c38072504c.png" style="width:22.92em;height:6.08em;"/></p>
<p>The reason is that <kbd>T</kbd> appears in the first argument in a parametric type. As we know that parametric types are invariant, we have already determined that <kbd>T</kbd> is <kbd>Signed</kbd>. Because <kbd>Int64</kbd> is a subtype of <kbd>Signed</kbd>, everything matched.</p>
<p>In the next section, we will go over the availability of type variables. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The availability of type variables</h1>
                </header>
            
            <article>
                
<p>An important feature of the parametric method is that the type variable specified in the <kbd>where</kbd> clause is also accessible from the method body. Contrary to what you might think, this is not always true. Here, we will present a case where the type variable is not available at runtime.</p>
<p>Consider the following functions:</p>
<pre>mytypes1(a::Array{T,1}, x::S) where {S &lt;: Number, T &lt;: S} = T<br/>mytypes2(a::Array{T,1}, x::S) where {S &lt;: Number, T &lt;: S} = S</pre>
<p>We can use the <kbd>mytypes1</kbd> and <kbd>mytypes2</kbd> functions to experiment with what type variables are derived by the Julia runtime. Let's start with the happy case:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4a2c4782-0e8c-4852-a4d4-9eadfcfa28bc.png" style="width:14.75em;height:5.58em;"/></p>
<p>However, the picture is not always rosy. In other situations, it may not work 100% of the time. Here's an example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec77e83f-612b-423b-bac8-5226a4d5e997.png" style="width:19.58em;height:5.67em;"/></p>
<p>Why is <kbd>S</kbd> not defined here? First of all, we already know that <kbd>T</kbd> is <kbd>Signed</kbd> because the parametric type is invariant. As part of the <kbd>where</kbd> clause, we also know that <kbd>T</kbd> is a subtype of <kbd>S</kbd>. As such, <kbd>S</kbd> could be <kbd>Integer</kbd>, <kbd>Real</kbd>, <kbd>Number</kbd>, or even <kbd>Any</kbd>. As there are too many possible answers, the Julia runtime decided not <span>to</span><span> </span><span>assign any value to</span> <kbd>S</kbd><span>.</span></p>
<p>The moral of the story is don't assume that a type variable is always defined and accessible from the method, especially for a more complex situation like this. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about various topics related to subtyping, variance, and <span>dispatch</span>. These concepts are the fundamental building blocks for creating larger, <span>more</span><span> </span><span>complex applications.</span></p>
<p>We first went over the topic of implementation inheritance and behavior subtyping and the differences between them. We reasoned that implementation inheritance is not a great design pattern because of various issues. We came to an understanding that Julia's type system is designed to avoid the flaws that we have seen in other programming languages.</p>
<p>Then, we reviewed different kinds of variance, which are nothing but ways to explain the subtyping relationship between parametric types. We walked through in great details how parametric types are invariant and method arguments are covariant. We <span>then</span><span> </span><span>went even further to discuss the variance of function types and how we can build our own data type that wraps a function for dispatch purpose.</span></p>
<p>Finally, we revisited parametric methods and looked at how type variables are specified and matched during dispatch. We learned about the diagonal rule, which is a key design feature in the Julia language that allows us to enforce type consistency across method arguments in an intuitive manner.</p>
<p>We are now finished with the chapter and the book. Thank you for reading it!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How is implementation inheritance different from behavior subtyping?</li>
<li>What are some major issues with implementation inheritance?</li>
<li>What is duck typing?</li>
<li>What is the variance of method arguments and why?</li>
<li>Why are parametric types invariant in Julia?</li>
<li>When does the diagonal rule apply?</li>
</ol>


            </article>

            
        </section>
    </body></html>