["```py\nMat image = imread(\"Test.png\");\nif(image.empty())\n {\n cout << \"image empty\";\n return 0;\n }\nint centerRow = (image.rows / 2) - 1;\n int centerCol = (image.cols / 2) - 1;\n Mat roi(image, Rect(centerCol - 1, centerRow - 1, 3, 3));\nroi = Scalar(0,0,255); // alter the pixels (make them red)\nimshow(\"image\", image);\n waitKey();\n```", "```py\nMat::row can be used to access a single row\n Mat::column can be used to access a single column\n```", "```py\nMat image = imread(\"Test.png\");\nif(image.empty())\n {\n cout << \"image empty\";\n return 0;\n }\nMat red(image.rows, image.cols, CV_8UC3, Scalar::all(0));\n Mat green(image.rows, image.cols, CV_8UC3, Scalar::all(0));\n Mat blue(image.rows, image.cols, CV_8UC3, Scalar::all(0));\nfor(int i=0; i<image.rows; i++)\n {\n for(int j=0; j<image.cols; j++)\n {\n blue.at<Vec3b>(i, j)[0] = image.at<Vec3b>(i, j)[0];\n green.at<Vec3b>(i, j)[1] = image.at<Vec3b>(i, j)[1];\n red.at<Vec3b>(i, j)[2] = image.at<Vec3b>(i, j)[2];\n }\n }\nimshow(\"Blue\", blue);\n imshow(\"Green\", green);\n imshow(\"Red\", red);\nwaitKey();\n```", "```py\nMat image = imread(\"Test.png\", IMREAD_GRAYSCALE);\nif(image.empty())\n {\n cout << \"image empty\";\n return 0;\n }\nint sum = 0;\nMatIterator_<uchar> it_begin = image.begin<uchar>();\n MatIterator_<uchar> it_end = image.end<uchar>();\n for( ; it_begin != it_end; it_begin++)\n {\n sum += (*it_begin);\n }\ndouble average = sum / (image.cols * image.rows);\ncout << \"Pixel count is \" << image.cols * image.rows << endl;\n cout << \"Average pixel value is \" << average << endl;\n```", "```py\nVideoCapture cam(0);\nif(!cam.isOpened())\n return -1;\nwhile(true)\n {\n Mat frame;\n cam >> frame;\n if(frame.empty())\n break;\nimshow(\"Camera\", frame);\n// stop camera if space is pressed\nchar key = waitKey(10);\nif(key == ' ')\n break;\nif(key == 's')\n imwrite(\"d:/snapshot.png\", frame);\n }\ncam.release();\n```", "```py\ngemm(image1, image2, 1.0, noArray(), 1.0, result);\n```", "```py\nVec3b val = image.at<Vec3b>(borderInterpolate(50,\n                               image.rows,\n                               cv::BORDER_REFLECT_101),\n                            borderInterpolate(-10,\n                               image.cols,\n                               cv::BORDER_WRAP));\n```", "```py\nMat m(10, 10, CV_32F);\nsetIdentity(m, Scalar(0.25));\n```", "```py\nMat image = imread(\"Test.png\");\n\nMat lut(1, 256, CV_8UC1);\n\nfor(int i=0; i<256; i++)\n{\n  lut.at<uchar>(0, i) = 255 - i;\n}\n\nMat result;\nLUT(image, lut, result);\n```", "```py\nnormalize(image, result, 200, 255, CV_MINMAX); // brighten\nnormalize(image, result, 0, 50, CV_MINMAX); // darken\n```", "```py\nvector<Mat> channels;\nsplit(image, channels);\nchannels[0] = Scalar::all(0);\nmerge(channels, result);\n```", "```py\nline(image,\n Point(0,0),\n Point(image.cols-1,image.rows-1),\n Scalar(0,0,255),\n 3);\nline(image,\n Point(0,image.rows-1),\n Point(image.cols-1,0),\n Scalar(0,0,255),\n 3);\n```", "```py\nMat image;\n int ksize = 3;\n string window = \"Image\";\n string trackbar = \"ksize\";\nvoid onChange(int ksize, void*)\n {\n if(ksize %2 == 1)\n {\n medianBlur(image,\n image,\n ksize);\n imshow(window, image);\n }\n }\nint main()\n {\n image = imread(\"Test.png\");\n namedWindow(window);\n createTrackbar(trackbar, window, &ksize, 99, onChange);\n setTrackbarMin(trackbar, window, 3);\n setTrackbarMax(trackbar, window, 99);\n onChange(3, NULL);\n waitKey();\n }\n```", "```py\nint ksize = 7;\n morphologyEx(image,\n result,\n MORPH_GRADIENT,\n getStructuringElement(MORPH_RECT,\n Size(ksize,ksize)));\n```", "```py\nMat imageGray;\n cvtColor(image,\n imageGray,\n COLOR_BGR2GRAY);\nthreshold(imageGray,\n result,\n 100,\n 255,\n THRESH_BINARY_INV);\n```", "```py\nMat mapX(image.size(), CV_32FC1);\n Mat mapY(image.size(), CV_32FC1);\n for(int i=0; i<image.rows; i++)\n for(int j=0; j<image.cols; j++)\n {\n mapX.at<float>(i,j) = j*2.0;\n mapY.at<float>(i,j) = i*2.0;\n }\n InterpolationFlags interpolation = INTER_LANCZOS4;\n BorderTypes borderMode = BORDER_DEFAULT;\n remap(image,\n result,\n mapX,\n mapY,\n interpolation,\n borderMode);\n```", "```py\nMat userColor(256, 1, CV_8UC3);\n for(int i=0; i<=255; i++)\n userColor.at<Vec3b>(i,0) = Vec3b(i, i, i);\n applyColorMap(image,\n result,\n userColor);\n```", "```py\nMat userColor(256, 1, CV_8UC3);\n for(int i=0; i<=255; i++)\n userColor.at<Vec3b>(i,0) = Vec3b(255-i, 255-i, 255-i);\n applyColorMap(image,\n result,\n userColor);\n```", "```py\nint bins = 25; // optional\n int nimages = 1;\n int channels[] = {1};\n Mat mask;\n int dims = 1;\n int histSize[] = { bins };\n float range[] = {0, 100};\n const float* ranges[] = { range };\n Mat histogram;\n calcHist(&image,\n nimages,\n channels,\n mask,\n histogram,\n dims,\n histSize,\n ranges);\n```", "```py\nint bins = 4;\n float rangeGS[] = {0, 256};\n const float* ranges[] = { rangeGS };\n int channels[] = {0};\n Mat histogram(bins, 1, CV_32FC1, Scalar(0.0));\n histogram.at<float>(0, 0) = 255.0;\n calcBackProject(&imageGray,\n 1,\n channels,\n histogram,\n backProj,\n ranges);\n```", "```py\nint bins = 4;\n float rangeGS[] = {0, 256};\n const float* ranges[] = { rangeGS };\n int channels[] = {0};\n Mat histogram(bins, 1, CV_32FC1, Scalar(0.0));\n histogram.at<float>(1, 0) = 255.0;\n histogram.at<float>(2, 0) = 255.0;\n calcBackProject(&imageGray,\n 1,\n channels,\n histogram,\n backProj,\n ranges);\n```", "```py\nconst int bins = 360;\n int hueOffset = 35;\n Mat histogram(bins, 1, CV_32FC1);\n for(int i=0; i<bins; i++)\n {\n histogram.at<float>(i, 0) =\n (i < hueOffset) || (i > bins - hueOffset) ? 255.0 : 0.0;\n }\ndouble maxVal = 255.0;\nint gW = 800, gH = 100;\n Mat theGraph(gH, gW, CV_8UC3, Scalar::all(0));\nMat colors(1, bins, CV_8UC3);\n for(int i=0; i<bins; i++)\n {\n colors.at<Vec3b>(i) =\n Vec3b(saturate_cast<uchar>(\n (i+1)*180.0/bins), 255, 255);\n }\n cvtColor(colors, colors, COLOR_HSV2BGR);\n Point p1(0,0), p2(0,theGraph.rows-1);\n for(int i=0; i<bins; i++)\n {\n float value = histogram.at<float>(i,0);\n value = maxVal - value; // invert\n value = value / maxVal * theGraph.rows; // scale\n p1.y = value;\n p2.x = float(i+1) * float(theGraph.cols) / float(bins);\n rectangle(theGraph,\n p1,\n p2,\n Scalar(colors.at<Vec3b>(i)),\n CV_FILLED);\n p1.x = p2.x;\n }\n```", "```py\nfloat integral = 0.0;\n for(int i=0; i<bins; i++)\n {\n integral += histogram.at<float>(i, 0);\n }\n```", "```py\nMat channels[3], equalized[3];\n split(image, channels);\nequalizeHist(channels[0], equalized[0]);\n equalizeHist(channels[1], equalized[1]);\n equalizeHist(channels[2], equalized[2]);\nMat output;\n cv::merge(equalized, 3, output);\n```", "```py\nconst int RETRY_COUNT = 10;\n int retries = RETRY_COUNT;\nwhile(true)\n {\nMat frame;\n cam >> frame;\n if(frame.empty())\n {\n if(--retries < 0)\n break;\n else\n continue;\n }\n else\n {\n retries = RETRY_COUNT;\n }\n// rest of the process\n }\n```", "```py\nTermCriteria criteria(TermCriteria::MAX_ITER\n + TermCriteria::EPS,\n 10,\n 0.5);\nmeanShift(backProject,\n srchWnd,\n criteria);\n```", "```py\nHaving the following function:\n void visualizeHue(Mat hue)\n {\n int bins = 36;\n int histSize[] = {bins};\n int nimages = 1;\n int dims = 1;\n int channels[] = {0};\n float rangeHue[] = {0, 180};\n const float* ranges[] = {rangeHue};\n bool uniform = true;\n bool accumulate = false;\n Mat histogram, mask;\ncalcHist(&hue,\n nimages,\n channels,\n mask,\n histogram,\n dims,\n histSize,\n ranges,\n uniform,\n accumulate);\ndouble maxVal;\n minMaxLoc(histogram,\n 0,\n &maxVal,\n 0,\n 0);\nint gW = 800, gH = 100;\n Mat theGraph(gH, gW, CV_8UC3, Scalar::all(0));\nMat colors(1, bins, CV_8UC3);\n for(int i=0; i<bins; i++)\n {\n colors.at<Vec3b>(i) =\n Vec3b(saturate_cast<uchar>(\n (i+1)*180.0/bins), 255, 255);\n }\n cvtColor(colors, colors, COLOR_HSV2BGR);\n Point p1(0,0), p2(0,theGraph.rows-1);\n for(int i=0; i<bins; i++)\n {\n float value = histogram.at<float>(i,0);\n value = maxVal - value; // invert\n value = value / maxVal * theGraph.rows; // scale\n p1.y = value;\n p2.x = float(i+1) * float(theGraph.cols) / float(bins);\n rectangle(theGraph,\n p1,\n p2,\n Scalar(colors.at<Vec3b>(i)),\n CV_FILLED);\n p1.x = p2.x;\n }\nimshow(\"Graph\", theGraph);\n }\n```", "```py\nCamShift(backProject,\n srchWnd,\n criteria);\nvisualizeHue(Mat(hue, srchWnd));\n```", "```py\nsetIdentity(kalman.processNoiseCov,\n Scalar::all(1.0));\n```", "```py\nint fillHeight = 0;\nvoid onMouse(int, int, int y, int, void*)\n {\n fillHeight = y;\n }\nint main()\n {\n KalmanFilter kalman(2,1);\nMat_<float> tm(2, 2); // transition matrix\n tm << 1,0,\n 0,1;\nkalman.transitionMatrix = tm;\n Mat_<float> h(1,1);\n h.at<float>(0) = 0;\nkalman.statePre.at<float>(0) = 0; // init x\n kalman.statePre.at<float>(1) = 0; // init x'\nsetIdentity(kalman.measurementMatrix);\nsetIdentity(kalman.processNoiseCov,\n Scalar::all(0.001));\nstring window = \"Canvas\";\n namedWindow(window);\n setMouseCallback(window, onMouse);\nwhile(waitKey(10) < 0)\n {\n // empty canvas\n Mat canvas(500, 500, CV_8UC3, Scalar(255, 255, 255));\nh(0) = fillHeight;\nMat estimation = kalman.correct(h);\nfloat estH = estimation.at<float>(0);\nrectangle(canvas,\n Rect(0,0,canvas.cols, estH),\n Scalar(0),\n FILLED);\nimshow(window, canvas);\nkalman.predict();\n }\n return 0;\n}\n```", "```py\nPtr<BackgroundSubtractorMOG2> bgs =\n createBackgroundSubtractorMOG2(500, // hist\n 16, // thresh\n false // no shadows\n );\n```", "```py\nVideoCapture cam(0);\n if(!cam.isOpened())\n return -1;\nPtr<BackgroundSubtractorKNN> bgs =\n createBackgroundSubtractorKNN();\nwhile(true)\n {\nMat frame;\n cam >> frame;\n if(frame.empty())\n break;\nMat mask;\n bgs->apply(frame,\n mask);\nbitwise_not(mask, mask);\nMat bg;\n bitwise_and(frame, frame, bg, mask);\nimshow(\"bg\", bg);\nint key = waitKey(10);\n if(key == 27) // escape key\n break;\n }\ncam.release();\n\n```", "```py\nresize(templ, templ, Size(), 2.0, 2.0);\n matchTemplate(image, templ, TM_CCOEFF_NORMED);\n```", "```py\nrotate(templ, templ, ROTATE_90_CLOCKWISE);\n matchTemplate(image, templ, TM_CCOEFF_NORMED);\n```", "```py\nMat image = imread(\"Test.png\");\n Ptr<GFTTDetector> detector =\n GFTTDetector::create(500,\n 0.01,\n 1,\n 3,\n true);\nvector<KeyPoint> keypoints;\n detector->detect(image, keypoints);\ndrawKeypoints(image,\n keypoints,\n image);\n```", "```py\nMat image = imread(\"Test.png\");\n cvtColor(image, image, COLOR_BGR2GRAY);\n vector<Vec3f> circles;\n HoughCircles(image,\n circles,\n HOUGH_GRADIENT,\n 2,\n image.rows/4);\n for(int i=0; i<circles.size(); i++)\n {\n Point center(cvRound(circles[i][0]),\n cvRound(circles[i][1]));\n int radius = cvRound(circles[i][2]);\ncircle( image, center, radius, Scalar(0,0,255));\n }\n```", "```py\nMat image = imread(\"Test.png\");\n Mat imgGray;\n cvtColor(image, imgGray, COLOR_BGR2GRAY);\ndouble threshold1 = 100.0;\n double threshold2 = 200.0;\n int apertureSize = 3;\n bool L2gradient = false;\n Mat edges;\n Canny(image,\n edges,\n threshold1,\n threshold2,\n apertureSize,\n L2gradient);\nvector<vector<Point> > contours;\n int mode = CV_RETR_TREE;\n int method = CV_CHAIN_APPROX_TC89_KCOS;\n findContours(edges,\n contours,\n mode,\n method);\nMat result(image.size(), CV_8UC3, Scalar::all(0));\n for( int i = 0; i< contours.size(); i++ )\n {\n if(isContourConvex(contours[i]))\n {\n drawContours(result,\n contours,\n i,\n Scalar(0, 255, 0),\n 2);\n }\n }\n```", "```py\nMat object = imread(\"Object.png\");\n Mat scene = imread(\"Scene.png\");\nPtr<ORB> orb = ORB::create();\n vector<KeyPoint> objKPs, scnKPs;\n Mat objDesc, scnDesc;\n orb->detectAndCompute(object,\n Mat(),\n objKPs,\n objDesc);\n orb->detectAndCompute(scene,\n Mat(),\n scnKPs,\n scnDesc);\nPtr<BFMatcher> matcher = BFMatcher::create();\nvector<DMatch> matches;\n matcher->match(objDesc, scnDesc, matches);\nMat result;\n drawMatches(object,\n objKPs,\n scene,\n scnKPs,\n matches,\n result);\n imshow(\"image\", result);\n```", "```py\ndouble freq = getTickFrequency();\n double countBefore = getTickCount();\n// your code goes here ..\ndouble countAfter = getTickCount();\n cout << \"Duration: \" <<\n (countAfter - countBefore) / freq << \" seconds\";\n```", "```py\nsvm->setKernel(SVM::LINEAR);\n```", "```py\nsvm->setKernel(SVM::INTER);\n```", "```py\nHOGDescriptor hog;\nhog.winSize = Size(128, 128);\nvector<float> tempDesc;\nhog.compute(Mat(hog.winSize, CV_8UC3),\n       tempDesc);\nint descriptorSize = tempDesc.size();\n\n```", "```py\nann->train(trainData, UPDATE_WEIGHTS);\n```", "```py\nopencv_createsamples -vec samples.vec -img sign.png -bg bg.txt    \n  -num 1000 -w 24 -h 32\n```", "```py\nopencv_traincascade -data classifier -vec samples.vec\n  -bg bg.txt -numPos 1000 -numNeg 1000 -w 24 -h 32\n   -featureType LBP\n```"]