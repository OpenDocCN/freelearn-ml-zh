["```py\n        private void GenerateMap( )\n         {\n             Random rand = new Random( (int) DateTime.Now.Ticks );\n\n             // create coordinates array\n             map = new double[citiesCount, 2];\n\n             for ( int i = 0; i < citiesCount; i++ )\n             {\n                 map[i, 0] = rand.Next( 1001 );\n                 map[i, 1] = rand.Next( 1001 );\n             }\n\n             // set the map\n             mapControl.UpdateDataSeries( \"map\", map );\n             // erase path if it is\n             mapControl.UpdateDataSeries( \"path\", null );\n         }\n```", "```py\n            Neuron.RandRange = new Range( 0, 1000 );\n             DistanceNetwork network = new DistanceNetwork( 2, neurons );\n             ElasticNetworkLearning    trainer = new ElasticNetworkLearning(\n network );\n             double    fixedLearningRate = learningRate / 20;\n             double    driftingLearningRate = fixedLearningRate * 19;\n             double[,] path = new double[neurons + 1, 2];\n             double[] input = new double[2];\n             int i = 0;\n\n             while ( !needToStop )\n             {\n                 trainer.LearningRate = driftingLearningRate * ( iterations - i ) / iterations + fixedLearningRate;\n                 trainer.LearningRadius = learningRadius * ( iterations - i ) / iterations;\n\n                 int currentCity = rand.Next( citiesCount );\n                 input[0] = map[currentCity, 0];\n                 input[1] = map[currentCity, 1];\n\n                 trainer.Run( input );\n\n                 for ( int j = 0; j < neurons; j++ )\n                 {\n                     path[j, 0] = network.Layers[0].Neurons[j].Weights[0];\n                     path[j, 1] = network.Layers[0].Neurons[j].Weights[1];\n                 }\n                 path[neurons, 0] = network.Layers[0].Neurons[0].Weights[0];\n                 path[neurons, 1] = network.Layers[0].Neurons[0].Weights[1];\n\n                 chart?.UpdateDataSeries( \"path\", path );\n                 i++;\n\n                 SetText( currentIterationBox, i.ToString( ) );\n\n                 if ( i >= iterations )\n                     break;\n            }\n```", "```py\n// create fitness function\n TSPFitnessFunction fitnessFunction = new TSPFitnessFunction( map );\n // create population\n Population population = new Population( populationSize,\n     ( greedyCrossover ) ? new TSPChromosome( map ) : new PermutationChromosome( citiesCount ),\n     fitnessFunction,\n     ( selectionMethod == 0 ) ? (ISelectionMethod) new EliteSelection( ) :\n     ( selectionMethod == 1 ) ? (ISelectionMethod) new RankSelection( ) :\n     (ISelectionMethod) new RouletteWheelSelection( ));\n```", "```py\ndouble[,] path = new double[citiesCount + 1, 2];\n```", "```py\n                // run one epoch of genetic algorithm\n                 RILogManager.Default?.SendDebug(\"Running Epoch \" + i);\n                 population.RunEpoch( );\n```", "```py\nushort[] bestValue = ((PermutationChromosome) population.BestChromosome).Value;\n```", "```py\nfor ( int j = 0; j < citiesCount; j++ )\n                 {\n                     path[j, 0] = map[bestValue[j], 0];\n                     path[j, 1] = map[bestValue[j], 1];\n                 }\n                 path[citiesCount, 0] = map[bestValue[0], 0];\n                 path[citiesCount, 1] = map[bestValue[0], 1];\n```", "```py\nmapControl.UpdateDataSeries( \"path\", path );\n```", "```py\n            // create fitness function\n             TSPFitnessFunction fitnessFunction = new TSPFitnessFunction( map );\n             // create population\n             Population population = new Population( populationSize,\n                 ( greedyCrossover ) ? new TSPChromosome( map ) : new PermutationChromosome( citiesCount ),\n                 fitnessFunction, ( selectionMethod == 0 ) ? new EliteSelection( )\n                 : ( selectionMethod == 1 ) ? new RankSelection( ) :\n                 (ISelectionMethod) new RouletteWheelSelection( ));\n             // iterations\n             int i = 1;\n\n             // path\n             double[,] path = new double[citiesCount + 1, 2];\n\n             // loop\n             while ( !needToStop )\n             {\n                 // run one epoch of genetic algorithm\n                 RILogManager.Default?.SendDebug(\"Running Epoch \" + i);\n                 population.RunEpoch( );\n\n                 // display current path\n                 ushort[] bestValue = ((PermutationChromosome) population.BestChromosome).Value;\n\n                 for ( int j = 0; j < citiesCount; j++ )\n                 {\n                     path[j, 0] = map[bestValue[j], 0];\n                     path[j, 1] = map[bestValue[j], 1];\n                 }\n                 path[citiesCount, 0] = map[bestValue[0], 0];\n                 path[citiesCount, 1] = map[bestValue[0], 1];\n\n                 mapControl.UpdateDataSeries( \"path\", path );\n\n```", "```py\n                 // set current iteration's info\n                 SetText( currentIterationBox, i.ToString( ) );\n                 SetText( pathLengthBox, fitnessFunction.PathLength( population.BestChromosome ).ToString( ) );\n\n                 // increase current iteration\n                 i++;\n\n                 //\n                 if ( ( iterations != 0 ) && ( i > iterations ) )\n                     break;\n             }\n```", "```py\nforeach (var neuron in network.Layers.SelectMany(layer => layer?.Neurons).Where(neuron => neuron != null))\n {\n                 neuron.RandGenerator = new UniformContinuousDistribution(new Range(0, 1000));\n }\n```", "```py\n            ElasticNetworkLearning trainer = new ElasticNetworkLearning(network);\n```", "```py\n            double fixedLearningRate = learningRate / 20;\n             double driftingLearningRate = fixedLearningRate * 19;\n```", "```py\nwhile (!needToStop)\n             {\n                 // update learning speed & radius\n                 trainer.LearningRate = driftingLearningRate * (iterations - i) / iterations + fixedLearningRate;\n                 trainer.LearningRadius = learningRadius * (iterations - i) / iterations;\n\n                 // set network input\n                 int currentCity = rand.Next(citiesCount);\n                 input[0] = map[currentCity, 0];\n                 input[1] = map[currentCity, 1];\n\n                 // run one training iteration\n                 trainer.Run(input);\n\n                 // show current path\n                 for (int j = 0; j < neurons; j++)\n                 {\n                     path[j, 0] = network.Layers[0].Neurons[j].Weights[0];\n                     path[j, 1] = network.Layers[0].Neurons[j].Weights[1];\n                 }\n                 path[neurons, 0] = network.Layers[0].Neurons[0].Weights[0];\n                 path[neurons, 1] = network.Layers[0].Neurons[0].Weights[1];\n\n                 chart.UpdateDataSeries(\"path\", path);\n\n                 i++;\n\n                 SetText(currentIterationBox, i.ToString());\n\n                 if (i >= iterations)\n                     break;\n             }\n```", "```py\npublic double Run( double[] input )\n         {\n             double error = 0.0;\n\n             // compute the network\n             network.Compute( input );\n             int winner = network.GetWinner( );\n\n             // get layer of the network\n             Layer layer = network.Layers[0];\n\n             // walk through all neurons of the layer\n             for ( int j = 0; j < layer.Neurons.Length; j++ )\n             {\n                 Neuron neuron = layer.Neurons[j];\n\n                 // update factor\n                 double factor = Math.Exp( -distance[Math.Abs( j - winner )] / squaredRadius2 );\n\n                 // update weights of the neuron\n                 for ( int i = 0; i < neuron.Weights.Length; i++ )\n                 {\n                     // calculate the error\n                     double e = ( input[i] - neuron.Weights[i] ) * factor;\n                     error += Math.Abs( e );\n                     // update weight\n                     neuron.Weights[i] += e * learningRate;\n                 }\n             }\n             return error;\n         }\n```", "```py\npublic virtual double[] Compute( double[] input )\n         {\n             // local variable to avoid mutlithread conflicts\n             double[] output = input;\n\n             // compute each layer\n             for ( int i = 0; i < layers.Length; i++ )\n             {\n                 output = layers[i].Compute( output );\n             }\n\n             // assign output property as well (works correctly for single threaded usage)\n             this.output = output;\n\n             return output;\n         }\n```", "```py\npublic int GetWinner( )\n         {\n             // find the MIN value\n             double min = output[0];\n             int    minIndex = 0;\n\n             for ( int i = 1; i < output.Length; i++ )\n             {\n                 if ( output[i] < min )\n                 {\n                     // found new MIN value\n                     min = output[i];\n                     minIndex = i;\n                 }\n             }\n\n             return minIndex;\n         }\n```"]