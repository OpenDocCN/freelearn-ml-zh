["```py\n# decimal average interpolated trend #days\n# date (season corr)\n1958 3 1958.208 315.71 315.71 314.62 -1\n1958 4 1958.292 317.45 317.45 315.29 -1\n1958 5 1958.375 317.50 317.50 314.71 -1\n1958 6 1958.458 -99.99 317.10 314.85 -1\n1958 7 1958.542 315.86 315.86 314.98 -1\n1958 8 1958.625 314.93 314.93 315.94 -1\n\n```", "```py\nfunc download() io.Reader {\n  client, err := ftp.Dial(\"aftp.cmdl.noaa.gov:21\")\n  dieIfErr(err)\n  dieIfErr(client.Login(\"anonymous\", \"anonymous\"))\n  reader, err := client.Retr(\"products/trends/co2/co2_mm_mlo.txt\")\n  dieIfErr(err)\n  return reader\n}\n```", "```py\nfunc parse(l loader) (dates []string, co2s []float64) {\n  s := bufio.NewScanner(l())\n  for s.Scan() {\n    row := s.Text()\n    if strings.HasPrefix(row, \"#\") {\n      continue\n    }\n    fields := strings.Fields(row)\n    dates = append(dates, fields[2])\n    co2, err := strconv.ParseFloat(fields[4], 64)\n    dieIfErr(err)\n    co2s = append(co2s, co2)\n  }\n  return\n}\n```", "```py\ntype loader func() io.Reader\n```", "```py\nfunc readFromFile() io.Reader {\n  reader, err := os.Open(\"data.txt\")\n  dieIfErr(err)\n  return reader\n}\n```", "```py\n2018.5\n```", "```py\n// parseDecimalDate takes a string in format of a decimal date\n// \"2018.05\" and converts it into a date.\n//\nfunc parseDecimalDate(a string, loc *time.Location) (time.Time, error) {\n  split := strings.Split(a, \".\")\n  if len(split) != 2 {\n    return time.Time{}, errors.Errorf(\"Unable to split %q into a year followed by a decimal\", a)\n  }\n  year, err := strconv.Atoi(split[0])\n  if err != nil {\n    return time.Time{}, err\n  }\n  dec, err := strconv.ParseFloat(\"0.\"+split[1], 64) // bugs can happen if you forget to add \"0.\"\n  if err != nil {\n    return time.Time{}, err\n  }\n\n  // handle leap years\n  var days float64 = 365\n  if year%400 == 0 || year%4 == 0 && year%100 != 0 {\n    days = 366\n  }\n\n  start := time.Date(year, time.January, 1, 0, 0, 0, 0, loc)\n  daysIntoYear := int(dec * days)\n  retVal := start.AddDate(0, 0, daysIntoYear)\n  return retVal, nil\n}\n```", "```py\nfunc newTSPlot(xs []time.Time, ys []float64, seriesName string) *plot.Plot {\n  p, err := plot.New()\n  dieIfErr(err)\n  xys := make(plotter.XYs, len(ys))\n  for i := range ys {\n    xys[i].X = float64(xs[i].Unix())\n    xys[i].Y = ys[i]\n  }\n  l, err := plotter.NewLine(xys)\n  dieIfErr(err)\n  l.LineStyle.Color = color.RGBA{A: 255} // black\n  p.Add(l)\n  p.Legend.Add(seriesName, l)\n  p.Legend.TextStyle.Font = defaultFont\n\n  // dieIfErr(plotutil.AddLines(p, seriesName, xys))\n  p.X.Tick.Marker = plot.TimeTicks{Format: \"2006-01-01\"}\n  p.Y.Label.TextStyle.Font = defaultFont\n  p.X.Label.TextStyle.Font = defaultFont\n  p.X.Tick.Label.Font = defaultFont\n  p.Y.Tick.Label.Font = defaultFont\n  p.Title.Font = defaultFont\n  p.Title.Font.Size = 16\n\n  return p\n}\n```", "```py\nl.LineStyle.Color = color.RGBA{A: 255}\n```", "```py\nvar defaultFont vg.Font\n\nfunc init() {\n  font, err := truetype.Parse(gomono.TTF)\n  if err != nil {\n    panic(err)\n  }\n  vg.AddFont(\"gomono\", font)\n  defaultFont, err = vg.MakeFont(\"gomono\", 12)\n  if err != nil {\n    panic(err)\n  }\n}\n```", "```py\n  p.Title.Font = defaultFont\n  p.Title.Font.Size = 16\n```", "```py\nfunc main() {\n  dateStrings, co2s := parse(readFromFile)\n  dates := parseDates(dateStrings)\n  plt := newTSPlot(dates, co2s, \"CO2 Level\")\n  plt.X.Label.Text = \"Time\"\n  plt.Y.Label.Text = \"CO2 in the atmosphere (ppm)\"\n  plt.Title.Text = \"CO2 in the atmosphere (ppm) over time\\nTaken over the Mauna-Loa observatory\"\n  dieIfErr(plt.Save(25*vg.Centimeter, 25*vg.Centimeter, \"Moana-Loa.png\"))\n}\n```", "```py\n| X | Y |\n |:--:|:--|\n | -1 | 1 |\n | -0.9 | 0.81 |\n | -0.8 | 0.64 |\n | -0.7 | 0.49 |\n | -0.6 | 0.36 |\n | -0.5 | 0.25 |\n | -0.4 | 0.16 |\n | -0.3 | 0.09 |\n | -0.2 | 0.04 |\n | -0.1 | 0.01 |\n | 0 | 0 |\n | 0.1 | 0.01 |\n | 0.2 | 0.04 |\n | 0.3 | 0.09 |\n | 0.4 | 0.16 |\n | 0.5 | 0.25 |\n | 0.6 | 0.36 |\n | 0.7 | 0.49 |\n | 0.8 | 0.64 |\n | 0.9 | 0.81 |\n```", "```py\n| X | Y | m | c\n |:--:|:--:|:--:|:--:|\n | -0.9 | 0.81 | -1.8 | -0.803333333333333 |\n | -0.8 | 0.64 | -1.6 | -0.633333333333334 |\n | -0.7 | 0.49 | -1.4 | -0.483333333333334 |\n | -0.6 | 0.36 | -1.2 | -0.353333333333333 |\n | -0.5 | 0.25 | -1 | -0.243333333333333 |\n | -0.4 | 0.16 | -0.8 | -0.153333333333333 |\n | -0.3 | 0.09 | -0.6 | -0.083333333333333 |\n | -0.2 | 0.04 | -0.4 | -0.033333333333333 |\n | -0.1 | 0.01 | -0.2 | -0.003333333333333 |\n | 0 | 0 | -2.71050543121376E-17 | 0.006666666666667 |\n | 0.1 | 0.01 | 0.2 | -0.003333333333333 |\n | 0.2 | 0.04 | 0.4 | -0.033333333333333 |\n | 0.3 | 0.09 | 0.6 | -0.083333333333333 |\n | 0.4 | 0.16 | 0.8 | -0.153333333333333 |\n | 0.5 | 0.25 | 1 | -0.243333333333333 |\n | 0.6 | 0.36 | 1.2 | -0.353333333333333 |\n | 0.7 | 0.49 | 1.4 | -0.483333333333334 |\n | 0.8 | 0.64 | 1.6 | -0.633333333333333 |\n | 0.9 | 0.81 | 1.8 | -0.803333333333333 |\n```", "```py\n// +build sidenote\n\npackage main\n\nimport (\n  \"image/color\"\n\n  \"github.com/golang/freetype/truetype\"\n  \"golang.org/x/image/font/gofont/gomono\"\n  \"gonum.org/v1/plot\"\n  \"gonum.org/v1/plot/plotter\"\n  \"gonum.org/v1/plot/vg\"\n  \"gonum.org/v1/plot/vg/draw\"\n)\n\nvar defaultFont vg.Font\n\nfunc init() {\n  font, err := truetype.Parse(gomono.TTF)\n  if err != nil {\n    panic(err)\n  }\n  vg.AddFont(\"gomono\", font)\n  defaultFont, err = vg.MakeFont(\"gomono\", 12)\n  if err != nil {\n    panic(err)\n  }\n}\n\nvar table = []struct {\n  x, m, c float64\n}{\n  {-0.9, -1.8, -0.803333333333333},\n  {-0.8, -1.6, -0.633333333333334},\n  {-0.7, -1.4, -0.483333333333334},\n  {-0.6, -1.2, -0.353333333333333},\n  {-0.5, -1, -0.243333333333333},\n  {-0.4, -0.8, -0.153333333333333},\n  {-0.3, -0.6, -0.083333333333333},\n  {-0.2, -0.4, -0.033333333333333},\n  {-0.1, -0.2, -0.003333333333333},\n  {0, -2.71050543121376E-17, 0.006666666666667},\n  {0.1, 0.2, -0.003333333333333},\n  {0.2, 0.4, -0.033333333333333},\n  {0.3, 0.6, -0.083333333333333},\n  {0.4, 0.8, -0.153333333333333},\n  {0.5, 1, -0.243333333333333},\n  {0.6, 1.2, -0.353333333333333},\n  {0.7, 1.4, -0.483333333333334},\n  {0.8, 1.6, -0.633333333333333},\n  {0.9, 1.8, -0.803333333333333},\n}\n\ntype estimates []struct{ x, m, c float64 }\n\nfunc (es estimates) Plot(c draw.Canvas, p *plot.Plot) {\n  trX, trY := p.Transforms(&c)\n  lineStyle := plotter.DefaultLineStyle\n  lineStyle.Dashes = []vg.Length{vg.Points(2), vg.Points(2)}\n  lineStyle.Color = color.RGBA{A: 255}\n  for i, e := range es {\n    if i == 0 || i == len(es)-1 {\n      continue\n    }\n    strokeStartX := es[i-1].x\n    strokeStartY := e.m*strokeStartX + e.c\n    strokeEndX := es[i+1].x\n    strokeEndY := e.m*strokeEndX + e.c\n    x1 := trX(strokeStartX)\n    y1 := trY(strokeStartY)\n    x2 := trX(strokeEndX)\n    y2 := trY(strokeEndY)\n    x := trX(e.x)\n    y := trY(e.x*e.m + e.c)\n\n    c.DrawGlyph(plotter.DefaultGlyphStyle, vg.Point{X: x, Y: y})\n    c.StrokeLine2(lineStyle, x1, y1, x2, y2)\n  }\n}\n\nfunc main() {\n  p, err := plot.New()\n  if err != nil {\n    panic(err)\n  }\n  p.Title.Text = \"X^2 Function and Its Estimates\"\n  p.X.Label.Text = \"X\"\n  p.Y.Label.Text = \"Y\"\n  p.X.Min = -1.1\n  p.X.Max = 1.1\n  p.Y.Min = -0.1\n  p.Y.Max = 1.1\n  p.Y.Label.TextStyle.Font = defaultFont\n  p.X.Label.TextStyle.Font = defaultFont\n  p.X.Tick.Label.Font = defaultFont\n  p.Y.Tick.Label.Font = defaultFont\n  p.Title.Font = defaultFont\n  p.Title.Font.Size = 16\n```", "```py\n  // Original function\n  original := plotter.NewFunction(func(x float64) float64 { return x * x })\n  original.Color = color.RGBA{A: 16}\n  original.Width = 10\n  p.Add(original)\n\n  // Plot estimates\n  est := estimates(table)\n  p.Add(est)\n\n  if err := p.Save(25*vg.Centimeter, 25*vg.Centimeter, \"functions.png\"); err != nil {\n    panic(err)\n  }\n}\n```", "```py\nfunc main() {\n  dateStrings, co2s := parse(readFromFile)\n  dates := parseDates(dateStrings)\n  plt := newTSPlot(dates, co2s, \"CO2 Level\")\n  plt.X.Label.Text = \"Time\"\n  plt.Y.Label.Text = \"CO2 in the atmosphere (ppm)\"\n  plt.Title.Text = \"CO2 in the atmosphere (ppm) over time\\nTaken over the Mauna-Loa observatory\"\n  dieIfErr(plt.Save(25*vg.Centimeter, 25*vg.Centimeter, \"Moana-Loa.png\"))\n\n  decomposed := stl.Decompose(co2s, 12, 84, stl.Additive(), stl.WithIter(1))\n  dieIfErr(decomposed.Err)\n  plts := plotDecomposed(dates, decomposed)\n  writeToPng(plts, \"decomposed.png\", 25, 25)\n}\n```", "```py\ndecomposed := stl.Decompose(co2s, 12, 84, stl.Additive(), stl.WithIter(1))\n```", "```py\nlies := stl.Decompose(co2s, 60, 84, stl.Additive(), stl.WithIter(1))\ndieIfErr(lies.Err)\nplts2 := plotDecomposed(dates, lies)\nwriteToPng(plts2, \"CO2 in the atmosphere (ppm), decomposed (Liar Edition)\", \"lies.png\", 25, 25)\n```", "```py\ntype Result struct {\n  Data []float64\n  Trend []float64\n  Seasonal []float64\n  Resid []float64\n  Err error\n}\n```", "```py\ntype residChart struct {\n  plotter.XYs\n  draw.LineStyle\n}\n\nfunc (r *residChart) Plot(c draw.Canvas, p *plot.Plot) {\n  xmin, xmax, ymin, ymax := r.DataRange()\n  p.Y.Min = ymin\n  p.Y.Max = ymax\n  p.X.Min = xmin\n  p.X.Max = xmax\n\n  trX, trY := p.Transforms(&c)\n  zero := trY(0)\n  lineStyle := r.LineStyle\n  for _, xy := range r.XYs {\n    x := trX(xy.X)\n    y := trY(xy.Y)\n    c.StrokeLine2(lineStyle, x, zero, x, y)\n  }\n}\n\nfunc (r *residChart) DataRange() (xmin, xmax, ymin, ymax float64) {\n  xmin = math.Inf(1)\n  xmax = math.Inf(-1)\n  ymin = math.Inf(1)\n  ymax = math.Inf(-1)\n  for _, xy := range r.XYs {\n    xmin = math.Min(xmin, xy.X)\n    xmax = math.Max(xmax, xy.X)\n    ymin = math.Min(ymin, xy.Y)\n    ymax = math.Max(ymax, xy.Y)\n  }\n  return\n}\n```", "```py\ntype Plotter interface {\n Plot(draw.Canvas, *Plot)\n}\n```", "```py\n  trX, trY := p.Transforms(&c)\n  zero := trY(0)\n  lineStyle := r.LineStyle\n  for _, xy := range r.XYs {\n    x := trX(xy.X)\n    y := trY(xy.Y)\n    c.StrokeLine2(lineStyle, x, zero, x, y)\n  }\n```", "```py\nfunc newResidPlot(xs []time.Time, ys []float64) *plot.Plot {\n  p, err := plot.New()\n  dieIfErr(err)\n  xys := make(plotter.XYs, len(ys))\n  for i := range ys {\n    xys[i].X = float64(xs[i].Unix())\n    xys[i].Y = ys[i]\n  }\n  r := &residChart{XYs: xys, LineStyle: plotter.DefaultLineStyle}\n  r.LineStyle.Color = color.RGBA{A: 255}\n  p.Add(r)\n  p.Legend.Add(\"Residuals\", r)\n\n  p.Legend.TextStyle.Font = defaultFont\n  p.X.Tick.Marker = plot.TimeTicks{Format: \"2006-01-01\"}\n  p.Y.Label.TextStyle.Font = defaultFont\n  p.X.Label.TextStyle.Font = defaultFont\n  p.X.Tick.Label.Font = defaultFont\n  p.Y.Tick.Label.Font = defaultFont\n  p.Title.Font.Size = 16\n  return p\n}\n```", "```py\nfunc (r *residChart) Thumbnail(c *draw.Canvas) {\n  y := c.Center().Y\n  c.StrokeLine2(r.LineStyle, c.Min.X, y, c.Max.X, y)\n}\n```", "```py\nfunc writeToPng(a interface{}, title, filename string, width, height vg.Length) {\n  switch at := a.(type) {\n  case *plot.Plot:\n    dieIfErr(at.Save(width*vg.Centimeter, height*vg.Centimeter, filename))\n    return\n  case [][]*plot.Plot:\n    rows := len(at)\n    cols := len(at[0])\n    t := draw.Tiles{\n      Rows: rows,\n      Cols: cols,\n    }\n    img := vgimg.New(width*vg.Centimeter, height*vg.Centimeter)\n    dc := draw.New(img)\n\n    if title != \"\" {\n      at[0][0].Title.Text = title\n    }\n\n    canvases := plot.Align(at, t, dc)\n    for i := 0; i < t.Rows; i++ {\n      for j := 0; j < t.Cols; j++ {\n        at[i][j].Draw(canvases[i][j])\n      }\n    }\n\n    w, err := os.Create(filename)\n    dieIfErr(err)\n\n    png := vgimg.PngCanvas{Canvas: img}\n    _, err = png.WriteTo(w)\n    dieIfErr(err)\n    return\n  }\n  panic(\"Unreachable\")\n}\n```", "```py\nfunc plotDecomposed(xs []time.Time, a stl.Result) [][]*plot.Plot {\n  plots := make([][]*plot.Plot, 4)\n  plots[0] = []*plot.Plot{newTSPlot(xs, a.Data, \"Data\")}\n  plots[1] = []*plot.Plot{newTSPlot(xs, a.Trend, \"Trend\")}\n  plots[2] = []*plot.Plot{newTSPlot(xs, a.Seasonal, \"Seasonal\")}\n  plots[3] = []*plot.Plot{newResidPlot(xs, a.Resid, \"Residuals\")}\n\n  return plots\n}\n```", "```py\n  t := draw.Tiles{\n      Rows: rows,\n      Cols: cols,\n  }\n```", "```py\n    img := vgimg.New(width*vg.Centimeter, height*vg.Centimeter)\n    dc := draw.New(img)\n```", "```py\n    for i := 0; i < t.Rows; i++ {\n      for j := 0; j < t.Cols; j++ {\n        at[i][j].Draw(canvases[i][j])\n      }\n    }\n```", "```py\nfunc hw(a stl.Result, periodicity, forward int, alpha, beta, gamma float64) []float64 {\n  level := make([]float64, len(a.Data))\n  trend := make([]float64, len(a.Trend))\n  seasonal := make([]float64, len(a.Seasonal))\n  forecast := make([]float64, len(a.Data)+forward)\n  copy(seasonal, a.Seasonal)\n\n  for i := range a.Data {\n    if i == 0 {\n      continue\n    }\n    level[i] = alpha*a.Data[i] + (1-alpha)*(level[i-1]+trend[i-1])\n    trend[i] = beta*(level[i]-level[i-1]) + (1-beta)*(trend[i-1])\n    if i-periodicity < 0 {\n      continue\n    }\n    seasonal[i] = gamma*(a.Data[i]-level[i-1]-trend[i-1]) + (1-gamma)*(seasonal[i-periodicity])\n  }\n\n  hplus := ((periodicity - 1) % forward) + 1\n  for i := 0; i+forward < len(forecast); i++ {\n    forecast[i+forward] = level[i] + float64(forward)*trend[i] + seasonal[i-periodicity+hplus]\n  }\n  copy(forecast, a.Data)\n\n  return forecast\n}\n```", "```py\nfunc forecastTime(dates []time.Time, forwards int) []time.Time {\n  retVal := append(dates, make([]time.Time, forwards)...)\n  lastDate := dates[len(dates)-1]\n  for i := len(dates); i < len(retVal); i++ {\n    retVal[i] = lastDate.AddDate(0, 1, 0)\n    lastDate = retVal[i]\n  }\n  return retVal\n}\n```", "```py\n  fwd := 120\n  forecast := hw(decomposed, 12, fwd, 0.1, 0.05, 0.1)\n  datesplus := forecastTime(dates, fwd)\n  forecastPlot := newTSPlot(datesplus, forecast, \"\")\n  maxY := math.Inf(-1)\n  minY := math.Inf(1)\n  for i := range forecast {\n    if forecast[i] > maxY {\n      maxY = forecast[i]\n    }\n    if forecast[i] < minY {\n      minY = forecast[i]\n    }\n  }\n  // extend the range a little\n  minY--\n  maxY++\n  maxX := float64(datesplus[len(datesplus)-1].Unix())\n  minX := float64(datesplus[len(dates)-1].Unix())\n\n  shadePoly := plotter.XYs{\n    {X: minX, Y: minY},\n    {X: maxX, Y: minY},\n    {X: maxX, Y: maxY},\n    {X: minX, Y: maxY},\n  }\n  poly, err := plotter.NewPolygon(shadePoly)\n  dieIfErr(err)\n  poly.Color = color.RGBA{A: 16}\n  poly.LineStyle.Color = color.RGBA{}\n  forecastPlot.Add(poly)\n\n  writeToPng(forecastPlot, \"Forecasted CO2 levels\\n(10 years)\", \"forecast.png\", 25, 25)\n```"]