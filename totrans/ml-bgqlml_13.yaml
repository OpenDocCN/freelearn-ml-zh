- en: '*Chapter 10*: Predicting Boolean Values Using XGBoost'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用 XGBoost 预测布尔值'
- en: '**eXtreme Gradient Boosting** (**XGBoost**) is one of the most powerful **machine
    learning** (**ML**) libraries that data scientists can leverage to solve complex
    use cases in an efficient and flexible way. It started as a research project,
    and the first version was released in 2014\. The popularity of this ML library
    grew very quickly, thanks to its capabilities and portability. In fact, it was
    used in important Kaggle ML contests and is now available for different programming
    languages and on different operating systems.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**极端梯度提升**（**XGBoost**）是数据科学家可以利用来解决复杂用例的最强大的机器学习（ML）库之一。它最初是一个研究项目，第一个版本于2014年发布。由于其功能和可移植性，这个机器学习库的受欢迎程度迅速增长。实际上，它被用于重要的
    Kaggle 机器学习竞赛，并且现在可用于不同的编程语言和不同的操作系统。'
- en: This library can be used to tackle different ML problems and is specifically
    designed for structured data. XGBoost was also recently released for BigQuery
    ML. Thanks to this technique, BigQuery users are allowed to implement classification
    and regression ML models using this library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库可以用来解决不同的机器学习（ML）问题，并且专门为结构化数据设计。XGBoost 也最近被发布用于 BigQuery ML。多亏了这项技术，BigQuery
    用户现在可以使用这个库实现分类和回归机器学习模型。
- en: In this chapter, we'll see all the stages necessary to implement a XGBoost classification
    model to classify New York City trees into different species according to their
    characteristics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到实现 XGBoost 分类模型的所有必要阶段，以便根据其特征将纽约市的树木分类到不同的物种。
- en: 'Using the BigQuery ML SQL dialect, we''ll go through the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 BigQuery ML SQL 语法，我们将探讨以下主题：
- en: Introducing the business scenario
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍业务场景
- en: Discovering the XGBoost Boosted Tree classification model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现 XGBoost 增强树分类模型
- en: Exploring and understanding the dataset
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和理解数据集
- en: Training the XGBoost classification model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练 XGBoost 分类模型
- en: Evaluating the XGBoost classification model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估 XGBoost 分类模型
- en: Using the XGBoost classification model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XGBoost 分类模型
- en: Drawing business conclusions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制商业结论
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires you to have access to a web browser and to be able to
    leverage the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您能够访问网络浏览器，并能够利用以下资源：
- en: A **Google Cloud Platform** (**GCP**) account to access the Google Cloud Console
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **Google Cloud Platform**（**GCP**）账户以访问 Google Cloud 控制台
- en: A GCP project to host the BigQuery datasets
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 GCP 项目来托管 BigQuery 数据集
- en: Now that we're ready in terms of the technical requirements, let's dive into
    the analysis and development of our BigQuery ML XGBoost classification model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经满足了技术要求，让我们深入分析和开发我们的 BigQuery ML XGBoost 分类模型。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3ujnzH3](https://bit.ly/3ujnzH3)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/3ujnzH3](https://bit.ly/3ujnzH3)
- en: Introducing the business scenario
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍业务场景
- en: In this section, we'll introduce the business scenario that will be tackled
    with the XGBoost classification algorithm.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍将使用 XGBoost 分类算法解决的业务场景。
- en: The business scenario is very similar to the use case presented and used in
    [*Chapter 6*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088), *Classifying Trees
    with Multiclass Logistic Regression*. In this chapter, we'll use the same dataset
    but will apply a more advanced ML algorithm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 业务场景与在第6章中介绍和使用的用例非常相似，*使用多类逻辑回归对树木进行分类*。在本章中，我们将使用相同的数据集，但将应用更先进的机器学习算法。
- en: We can summarize and remember that the goal of the ML model is to automatically
    classify the trees of New York City into different species according to their
    characteristics, such as their position, their size, and their health status.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结并记住，机器学习模型的目标是自动根据纽约市树木的特征，如位置、大小和健康状况，将它们分类到不同的物种。
- en: As we've done in [*Chapter 9*](B16722_09_Final_ASB_ePub.xhtml#_idTextAnchor133),
    *Suggesting the Right Product by Using Matrix Factorization*, we can focus our
    attention only on the five most common species of trees present in the city.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第9章*](B16722_09_Final_ASB_ePub.xhtml#_idTextAnchor133)中做的，*通过矩阵分解建议合适的产品*，我们可以只关注城市中存在的五种最常见的树木物种。
- en: Now that we've explained and understood the business scenario, let's take a
    look at the ML technique that we can use to automatically classify trees according
    to their features.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释并理解了业务场景，让我们看看我们可以用来根据特征自动分类树木的机器学习技术。
- en: Discovering the XGBoost Boosted Tree classification model
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现XGBoost提升树分类模型
- en: In this section, we'll learn what the **XGBoost Boosted Trees** classification
    model is, and we'll understand which classification use cases can be tackled with
    this ML algorithm.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解XGBoost提升树分类模型是什么，以及我们将理解哪些分类用例可以使用这个机器学习算法来解决。
- en: XGBoost is an open source library that provides a portable gradient boosting
    framework for different languages. The XGBoost library is available for different
    programming languages such as C++, Java, Python, R, and Scala, and can work on
    different operating systems. XGBoost is used to deal with supervised learning
    use cases, where we use labeled training data to predict target variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: XGBoost是一个开源库，为不同的语言提供了一个可移植的梯度提升框架。XGBoost库适用于不同的编程语言，如C++、Java、Python、R和Scala，并且可以在不同的操作系统上运行。XGBoost用于处理监督学习用例，其中我们使用标记的训练数据来预测目标变量。
- en: XGBoost's popularity has grown in the ML community over the years because it
    has often been the choice of many winning teams during ML competitions, such as
    the *Kaggle - High Energy Physics meets Machine Learning award* in 2016.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: XGBoost在机器学习社区中的普及度逐年增长，因为它经常是许多在机器学习竞赛中获胜团队的选项，例如2016年的*Kaggle - 高能物理与机器学习奖*。
- en: The classification capabilities of **XGBoost Boosted Trees** are based on the
    usage of multiple decision trees that classify data to enable predictions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: XGBoost提升树的分类能力基于使用多个决策树来分类数据，从而实现预测。
- en: 'In the following diagram, you can see a simple representation of a decision
    tree that classifies animals:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图表中，你可以看到一个简单的表示用于分类动物的决策树：
- en: '![](img/B16722_10_001.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16722_10_001.jpg)'
- en: Figure 10.1 – Representation of a decision tree
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 决策树的表示
- en: 'XGBoost classification models can answer the same questions addressed by multiclass
    logistic regression, such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: XGBoost分类模型可以回答与多类逻辑回归相同的问题，例如以下问题：
- en: Is the comment of my customer *neutral*, *positive*, or *negative*?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的客户的评论是*中立*、*正面*还是*负面*？
- en: Does my customer belong to the *gold*, *silver*, or *bronze* level?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的客户属于*金*、*银*还是*铜*级别？
- en: Is the probability of churn of a specific customer *high*, *medium*, or *low*?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定客户的流失概率是*高*、*中*还是*低*？
- en: Does the image recognition algorithm identify a *cat*, a *dog*, a *mouse*, or
    a *cow*?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像识别算法识别的是*猫*、*狗*、*老鼠*还是*牛*？
- en: In our business scenario, we can classify New York City trees into five different
    species by leveraging the XGBoost Boosted Tree classification model. In fact,
    we're interested in predicting the species according to the characteristics of
    each tree.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的业务场景中，我们可以利用XGBoost提升树分类模型将纽约市的树木分为五种不同的物种。实际上，我们对根据每棵树的特征预测物种感兴趣。
- en: During the training phase of a XGBoost algorithm, the ML model tries to find
    the best values to assign to each tree in order to minimize the final error metric.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在XGBoost算法的训练阶段，机器学习模型试图找到为每棵树分配的最佳值，以最小化最终的误差指标。
- en: After the training, we'll compare the results of this model with the outcomes
    that we got in [*Chapter 6*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088),
    *Classifying Trees with Multiclass Logistic Regression*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，我们将比较这个模型的结果与我们之前在[*第6章*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088)，“使用多类逻辑回归分类树木”中得到的成果。
- en: Now that we've learned the basics of the XGBoost Boosted Tree algorithm, it's
    time to take a look at the dataset that we'll use to build our ML model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了XGBoost提升树算法的基础知识，是时候看看我们将用于构建我们的机器学习模型的数据集了。
- en: Exploring and understanding the dataset
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和理解数据集
- en: In this section, we'll analyze and prepare the dataset for our use case. We'll
    start with some data quality checks, and then we'll segment the data into training,
    evaluation, and test tables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析和准备用于我们用例的数据集。我们将从一些数据质量检查开始，然后我们将数据分割成训练、评估和测试表。
- en: Since the dataset has already been used in [*Chapter 6*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088),
    *Classifying Trees with Multiclass Logistic Regression*, we will not start the
    analysis from the beginning. Instead, we'll focus on the most relevant queries
    for our business scenario.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据集已经在[*第6章*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088)，*使用多类逻辑回归对树木进行分类*中使用过，因此我们不会从开始分析。相反，我们将专注于我们业务场景中最相关的查询。
- en: Checking the data quality
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查数据质量
- en: 'To start our exploration of the data and to carry out data quality checks,
    we need to do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的数据探索并进行数据质量检查，我们需要执行以下操作：
- en: Log in to our Google Cloud Console and access the **BigQuery** **User Interface**
    (**UI**) from the navigation menu.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录我们的Google Cloud控制台，并通过导航菜单访问**BigQuery** **用户界面**（**UI**）。
- en: Create a new dataset under the project that we created in [*Chapter 2*](B16722_02_Final_ASB_ePub.xhtml#_idTextAnchor039),
    *Setting Up Your GCP and BigQuery Environment*. For this use case, we'll create
    a `10_nyc_trees_xgboost` dataset with the default options.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[*第2章*](B16722_02_Final_ASB_ePub.xhtml#_idTextAnchor039)，*设置您的GCP和BigQuery环境*中创建的项目下创建一个新的数据集。对于此用例，我们将创建一个名为`10_nyc_trees_xgboost`的数据集，并使用默认选项。
- en: 'First of all, let''s check if all the records contain a valid value in the
    `spc_latin` field by executing the following query:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过执行以下查询来检查所有记录在`spc_latin`字段中是否包含有效的值：
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see from the following screenshot, there are `spc_latin` column.
    These records will be filtered out during the training stage:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如以下屏幕截图所示，存在`spc_latin`列。这些记录将在训练阶段被过滤掉：
- en: '![Figure 10.2 – The query result shows that some records should be filtered
    out'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.2 – 查询结果显示应过滤掉一些记录'
- en: '](img/B16722_10_002.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16722_10_002.jpg)'
- en: Figure 10.2 – The query result shows that some records should be filtered out
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.2 – 查询结果显示应过滤掉一些记录
- en: After this first check, we need to verify if any potential feature is characterized
    by `NULL` values. Let's run the following `COUNT` of three records due to the
    presence of `NULL` values in the `sidewalk` and `health` fields. Despite the low
    number, we'll filter out these records in the following queries, to use only meaningful
    records.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此第一次检查之后，我们需要验证是否有任何潜在的特征由`NULL`值表示。由于`sidewalk`和`health`字段中存在`NULL`值，我们将运行以下`COUNT`查询以检查三条记录。尽管数量很少，我们将在以下查询中过滤掉这些记录，以仅使用有意义的记录。
- en: 'Then, we can extract the most common five tree species from the BigQuery public
    dataset. Let''s execute the following query:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以从BigQuery公共数据集中提取最常见的五种树种。让我们执行以下查询：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The query calculates `total` as the number of records for each `spc_latin` field.
    An `ORDER BY` clause is used to sort the results from the largest to the smallest
    values of the `total` field. Then, a `LIMIT 5` clause is used to return only the
    first five records.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询将`total`计算为每个`spc_latin`字段记录的数量。使用`ORDER BY`子句按`total`字段从大到小的值排序结果。然后，使用`LIMIT
    5`子句仅返回前五条记录。
- en: 'In the following screenshot, you can see the results of the query, which show
    the five species most frequently present in the dataset:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您可以查看查询结果，该结果显示了数据集中最常见的五种树种：
- en: '![Figure 10.3 – The most frequent tree species in the dataset'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.3 – 数据集中最常见的树种'
- en: '](img/B16722_10_003.jpg)'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16722_10_003.jpg)'
- en: Figure 10.3 – The most frequent tree species in the dataset
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.3 – 数据集中最常见的树种
- en: 'In order to materialize these five species into a table, let''s execute the
    following code to create a `` `10_nyc_trees_xgboost.top5_species` `` table:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将这些五种树种实体化到表中，让我们执行以下代码来创建一个名为`10_nyc_trees_xgboost.top5_species`的表：
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only difference with the query executed in the previous *Step 5* is represented
    by the use of `CREATE OR REPLACE TABLE` keywords that are leveraged to materialize
    the results of the query into the new table.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之前*第5步*中执行的查询的唯一区别在于使用了`CREATE OR REPLACE TABLE`关键字，这些关键字被用来将查询的结果实体化到新表中。
- en: In this section, we've analyzed the data quality of the BigQuery public dataset.
    Now, let's start segmenting it into three different tables for the training, evaluation,
    and classification stages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经分析了BigQuery公共数据集的数据质量。现在，让我们开始将其分割成三个不同的表，用于训练、评估和分类阶段。
- en: Segmenting the dataset
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割数据集
- en: 'Before implementing our XGBoost classification model, let''s segment our dataset
    according to the main stages of the ML development life cycle: training, evaluation,
    and use. In order to randomly divide the records into three different tables,
    we''ll use a `MOD` function on the `tree_id` numerical field. Follow these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现我们的XGBoost分类模型之前，让我们根据机器学习开发生命周期的主要阶段来分割我们的数据集：训练、评估和使用。为了将记录随机分成三个不同的表格，我们将在`tree_id`数值字段上使用`MOD`函数。按照以下步骤操作：
- en: 'First of all, let''s create a table that will contain the training dataset.
    To do this, we execute the following SQL statement:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个包含训练数据集的表格。为此，我们执行以下SQL语句：
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The query creates a `` `10_nyc_trees_xgboost.training_table` `` table with all
    the columns available in the original dataset, through a `SELECT *` statement.
    It applies all the filters necessary to get not empty values for the `spc_latin`
    label and for all the other features.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询创建了一个包含原始数据集中所有列的`10_nyc_trees_xgboost.training_table`表格，通过`SELECT *`语句应用了所有必要的过滤器，以获取`spc_latin`标签和所有其他特征的空值。
- en: Using an `IN` clause, `training_table` will contain only the records related
    to the most five common species that we've identified in the dataset.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`IN`子句，`training_table`将只包含与数据集中我们已识别的前五种最常见的物种相关的记录。
- en: The last line of the query, with the `MOD(tree_id,11)<=8` clause, allows us
    to pick up only 80% of the records from the entire dataset. `MOD` stands for *modulo*
    and returns the remainder of the division of `tree_id` by 11\. With the less than
    or equal operator (`<=`), we're approximately extracting 80% of the entire dataset.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询的最后一条语句，带有`MOD(tree_id,11)<=8`子句，使我们能够从整个数据集中仅选择80%的记录。`MOD`代表*模*，返回`tree_id`除以11的余数。通过使用小于或等于运算符（`<=`），我们大约提取了整个数据集的80%。
- en: 'With a similar approach, we can create a  `` `10_nyc_trees_xgboost.evaluation_table`
    `` table that will be used for the evaluation of our ML model. Let''s execute
    the following `CREATE TABLE` statement:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采用类似的方法，我们可以创建一个名为`10_nyc_trees_xgboost.evaluation_table`的表格，该表格将用于评估我们的机器学习模型。让我们执行以下`CREATE
    TABLE`语句：
- en: '[PRE4]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In contrast to when we created the training table, for the `evaluation_table`
    table we're picking up only 10% of the records from the entire dataset, by applying
    a `MOD(tree_id,11)=9` filter.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与我们创建训练表时的情况相反，对于`evaluation_table`表，我们通过应用`MOD(tree_id,11)=9`过滤器，仅从整个数据集中选择10%的记录。
- en: 'Finally, we''ll execute the following SQL statement in order to create a ``
    `10_nyc_trees_xgboost.classification_table` `` table that will be used to apply
    our XGBoost classification model:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将执行以下SQL语句以创建一个名为`10_nyc_trees_xgboost.classification_table`的表格，该表格将用于应用我们的XGBoost分类模型：
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This new table is very similar to the previous ones, but thanks to the `MOD`
    function will contain the remaining 10% of the dataset.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新表格与之前的表格非常相似，但多亏了`MOD`函数，它将包含数据集剩余的10%。
- en: In this section, we've analyzed the dataset that contains information about
    trees in New York City, applied some data quality checks to exclude empty values,
    and segmented the dataset, focusing on the five most common species. Now that
    we've completed the preparatory steps, it's time to move on and start the training
    of our BigQuery ML model.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了包含纽约市树木信息的数据集，对数据进行了一些数据质量检查以排除空值，并分割了数据集，重点关注最常见的五种物种。现在我们已经完成了准备工作，是时候继续前进并开始训练我们的BigQuery
    ML模型了。
- en: Training the XGBoost classification model
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练XGBoost分类模型
- en: 'Now that we''ve segmented the dataset into multiple tables to support the different
    stages of the ML model life cycle, let''s focus on the training of our XGBoost
    classification model. Follow these steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据集分割成多个表格以支持机器学习模型生命周期的不同阶段，让我们专注于训练我们的XGBoost分类模型。按照以下步骤操作：
- en: 'Let''s start with training our first ML model, `xgboost_classification_model_version_1`,
    as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从训练我们的第一个机器学习模型`xgboost_classification_model_version_1`开始，如下所示：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this BigQuery ML statement, we can see `CREATE OR REPLACE MODEL` keywords
    used to start the training of the model. These keywords are followed by the identifier
    of the ML model.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个BigQuery ML语句中，我们可以看到使用`CREATE OR REPLACE MODEL`关键字来启动模型的训练。这些关键字后面跟着机器学习模型的标识符。
- en: After the identifier, we can notice an `OPTIONS` clause. For the `MODEL_TYPE`,
    we've chosen a `BOOSTED_TREE_CLASSIFIER` option, which allows us to build a XGBoost
    classification model. The `BOOSTER_TYPE = 'GBTREE'` clause is considered a default
    option to train XGBoost boosted tree models.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to limit the complexity of training and the resource consumption, we've
    chosen to train only one tree in parallel with a `NUM_PARALLEL_TREE = 1` clause,
    and to stop the training after `50` iterations using `MAX_ITERATIONS`.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A `HIST` parameter is suggested for large datasets in the XGBoost documentation,
    and an `EARLY_STOP = FALSE` clause is used to prevent the training phase being
    stopped after the first iteration.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last option, `AUTO_CLASS_WEIGHTS=TRUE`, is used to balance the weights—
    in the case of an unbalanced dataset—with some tree species that can occur more
    frequently than others.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This first version of the model tries to predict the species of each tree, leveraging
    only the `zip_city` code where the tree is planted and the diameter of the tree,
    `tree_dbh`.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the end of the training, we can access the ML model from the BigQuery navigation
    menu to have a look at the performance of the model. Selecting the **Evaluation**
    tab, we can see the **ROC AUC** value. In this case, the value is **0.7775**,
    as we can see in the following screenshot:![Figure 10.4 – The Evaluation metrics
    of the XGBoost classification model
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16722_10_004.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.4 – The Evaluation metrics of the XGBoost classification model
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same **Evaluation** tab, we can also visualize the confusion matrix,
    which shows how many times the predicted value is equal to the actual one, as
    illustrated in the following screenshot:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The Evaluation tab shows the confusion matrix for the XGBoost
    classification model'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16722_10_005.jpg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.5 – The Evaluation tab shows the confusion matrix for the XGBoost
    classification model
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try to improve our ML model by adding features that can be useful to
    classify the trees into different species. Let''s train the second version of
    our BigQuery ML model by running the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compared to the first attempt of the previous *Step 1*, we've included additional
    features. In fact, we've added to the features the name of the borough contained
    in the `boroname` field and the `nta_name` field, which provides more specific
    information related to the position of the tree in the city.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the execution of the SQL statement, let's access the **Evaluation** tab
    of the new model to see if we're improving its performance. Taking a look at the
    **ROC AUC** value of **0.80**, we can see a slight increase in the performance
    of our model compared to the first version.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we''ll try to add to our ML model other features related to the health
    of the tree and also to the intrusiveness of its roots, which can damage adjacent
    sidewalks, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compared to the previous ML model, the `xgboost_classification_model_version_3`
    model includes a `health` field, which describes the health status of our tree,
    and a `sidewalk` field, which is used to specify if the roots of tree are damaging
    adjacent sidewalks.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之前的 ML 模型相比，`xgboost_classification_model_version_3` 模型包含一个 `health` 字段，用于描述我们树木的健康状况，以及一个
    `sidewalk` 字段，用于指定树木的根是否损坏相邻的人行道。
- en: Looking at the performances of our last ML model in the **Evaluation** tab of
    the BigQuery UI, we can notice that we've achieved another increase in terms of
    the **ROC AUC**, with a value of **0.8121**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 BigQuery UI 的 **评估** 选项卡中查看我们最后 ML 模型的性能，我们可以注意到我们在 **ROC AUC** 方面又取得了提高，值为
    **0.8121**。
- en: In this section, we've created different ML models by trying to use different
    features in our dataset. In the next steps, we'll use the model with the highest
    `xgboost_classification_model_version_3`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过尝试在我们的数据集中使用不同的特征创建了不同的 ML 模型。在接下来的步骤中，我们将使用具有最高 `xgboost_classification_model_version_3`
    的模型。
- en: Now, let's start the evaluation stage of the XGBoost classification model on
    the evaluation dataset.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始在评估数据集上对 XGBoost 分类模型进行评估阶段。
- en: Evaluating the XGBoost classification model
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估 XGBoost 分类模型
- en: To evaluate our BigQuery ML model, we'll use a `ML.EVALUATE` function and the
    table that we've expressly created as an evaluation dataset.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估我们的 BigQuery ML 模型，我们将使用 `ML.EVALUATE` 函数以及我们专门创建的作为评估数据集的表格。
- en: 'The following query will tell us if the model is suffering from overfitting
    or is able to also perform well on new data:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询将告诉我们模型是否过度拟合，或者是否也能在新数据上表现良好：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `SELECT` statement extracts the `roc_auc` value returned by the `ML.EVALUATE`
    function and also provides a clear description of the quality of the model that
    starts from `'POOR'` and can achieve an `'EXCELLENT'` grade, passing through some
    intermediate stages such as `'NEEDS IMPROVEMENTS'` and `'GOOD'`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 语句提取了 `ML.EVALUATE` 函数返回的 `roc_auc` 值，并提供了对模型质量的清晰描述，从 `''POOR''`
    开始，可以达到 `''EXCELLENT''` 等级，经过一些中间阶段，如 `''NEEDS IMPROVEMENTS''` 和 `''GOOD''`。'
- en: 'Executing the query, we can see that the score is **VERY GOOD**, as illustrated
    in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询，我们可以看到分数是 **非常好**，如下面的截图所示：
- en: '![Figure 10.6 – The evaluation stage returns VERY GOOD for the quality of our
    BigQuery ML model'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – 评估阶段为我们的 BigQuery ML 模型的质量返回了“非常好”]'
- en: '](img/B16722_10_006.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16722_10_006.jpg](img/B16722_10_006.jpg)'
- en: Figure 10.6 – The evaluation stage returns VERY GOOD for the quality of our
    BigQuery ML model
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 评估阶段为我们的 BigQuery ML 模型的质量返回了“非常好”
- en: Now that we've evaluated our ML model, let's see how we can apply it to other
    records to get a classification of the trees.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经评估了我们的 ML 模型，让我们看看我们如何将其应用于其他记录以获得树木的分类。
- en: Using the XGBoost classification model
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XGBoost 分类模型
- en: In this section, we'll use the ML model to classify the trees into five different
    species according to their characteristics.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 ML 模型根据树木的特征将树木分类到五种不同的物种。
- en: 'To test our BigQuery ML model, we''ll use a `ML.PREDICT` function on the `classification_table`
    table, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的 BigQuery ML 模型，我们将在 `classification_table` 表上使用 `ML.PREDICT` 函数，如下所示：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The query is composed of a `SELECT` statement that extracts the `tree_id` value,
    the actual species of the tree, the probability of each predicted species, and
    the predicted species.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 查询由一个 `SELECT` 语句组成，该语句提取 `tree_id` 值、树木的实际物种、每个预测物种的概率以及预测物种。
- en: 'In the following screenshot, you can see the result of the query execution:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，你可以看到查询执行的结果：
- en: '![Figure 10.7 – The output of the query shows the actual and predicted labels'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – 查询输出显示了实际标签和预测标签]'
- en: with the related probabilities
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与相关的概率
- en: '](img/B16722_10_007.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16722_10_007.jpg](img/B16722_10_007.jpg)'
- en: Figure 10.7 – The output of the query shows the actual and predicted labels
    with the related probabilities
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 查询输出显示了实际标签和预测标签以及相关的概率
- en: In the two rows presented in the preceding screenshot, the trees with identifiers
    **283502** and **226929** are well classified into the **Acer platanoides** species,
    with a confidence of 61%.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面截图显示的两行中，标识为 **283502** 和 **226929** 的树木被很好地分类到 **Acer platanoides** 物种，置信度为
    61%。
- en: Now that we've tested our BigQuery ML model, let's make some final considerations
    by comparing the results of the XGBoost classification model with the outcome
    of the logistic regression used in [*Chapter 6*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088),
    *Classifying Trees with Multiclass Logistic Regression*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Drawing business conclusions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use our ML model, and we'll understand how many times
    the BigQuery ML model is able to classify the trees well in the `classification_table`
    table.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the following query to calculate how many times the predicted
    species is congruent with the actual one:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To calculate this value, we've introduced a `WHERE` clause by filtering only
    the rows where the predicted value is equal to the actual one.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following screenshot, the `SELECT COUNT` returns a value
    of **14277** records:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – The output of the query shows how many times the classification'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: model predicts the right species
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16722_10_008.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – The output of the query shows how many times the classification
    model predicts the right species
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Out of a total of 27,182 rows stored in the `classification_table` table, we
    can say that our model classifies the trees into the right species in 52.52% of
    cases.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, the results of the XGBoost classification model are
    compared with the results obtained by the multiclass logistic regression, applied
    in [*Chapter 6*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088), *Classifying
    Trees with Multiclass Logistic Regression*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 10.9 – Comparison of the XGBoost classification model and multiclass
    logistic regression'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16722_10_009.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Comparison of the XGBoost classification model and multiclass
    logistic regression
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the preceding table, we can say that to classify the New York City
    trees into the most common five species, the XGBoost classification model is able
    to achieve better results when compared to the multiclass logistic regression
    model.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've implemented a XGBoost classification model. We've remembered
    the business scenario that was already used in [*Chapter 6*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088),
    *Classifying Trees with Multiclass Logistic Regression*, based on the need to
    automatically classify New York City trees. After that, we've learned the basics
    of the XGBoost boosted tree classification model.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to build an effective model, we performed data quality checks and
    then segmented the dataset according to our needs into three tables: one to host
    training data, a second one for the evaluation stage, and a last one to apply
    our classification model.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: During the training phase of the BigQuery ML model, we've constantly improved
    the performance of the ML model, using ROC AUC as a **key performance indicator**
    (**KPI**).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: After that, we've evaluated the best ML model on a new set of records to avoid
    any overfitting, becoming more confident about the good quality of our XGBoost
    classification model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们评估了最佳 ML 模型在新的记录集上的表现，以避免任何过拟合，从而对我们 XGBoost 分类模型的高质量更加有信心。
- en: Finally, we've applied our BigQuery ML model to the last subset of records to
    classify the trees into species, according to their characteristics. We've discovered
    that our ML model is able to correctly classify the trees in 52.52% of cases.
    Then, we've also compared the performance of the XGBoost model with the multiclass
    logistic regression training we did in [*Chapter 6*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088),
    *Classifying Trees with Multiclass Logistic Regression* and noticed that XGBoost
    exceeded the multiclass logistic regression training's performance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的 BigQuery ML 模型应用于最后一批记录，根据它们的特征将树木分类到物种中。我们发现我们的 ML 模型在 52.52% 的情况下能够正确分类树木。然后，我们还比较了
    XGBoost 模型的性能与我们在 [*第 6 章*](B16722_06_Final_ASB_ePub.xhtml#_idTextAnchor088) 中进行的多元逻辑回归训练，即
    *使用多元逻辑回归分类树木*，并注意到 XGBoost 的性能超过了多元逻辑回归训练。
- en: In the next chapter, we'll learn about advanced **deep neural networks** (**DNNs**),
    leveraging BigQuery SQL syntax.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于高级 **深度神经网络**（**DNNs**），利用 BigQuery SQL 语法。
- en: Further resources
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步资源
- en: '**NYC Street Tree Census public dataset**: [https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census](https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纽约市街道树木普查公共数据集**：[https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census](https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census)'
- en: '**XGBoost home page**: [https://xgboost.ai/](https://xgboost.ai/)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XGBoost 主页**：[https://xgboost.ai/](https://xgboost.ai/)'
- en: '**XGBoost documentation**: [https://xgboost.readthedocs.io/en/latest/index.html](https://xgboost.readthedocs.io/en/latest/index.html)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XGBoost 文档**：[https://xgboost.readthedocs.io/en/latest/index.html](https://xgboost.readthedocs.io/en/latest/index.html)'
- en: '`CREATE MODEL` **statement for Boosted Tree models**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create-boosted-tree](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create-boosted-tree)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE MODEL` **语句用于提升树模型**：[https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create-boosted-tree](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create-boosted-tree)'
- en: '`ML.EVALUATE` **function**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ML.EVALUATE` **函数**：[https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate)'
- en: '`ML.PREDICT` **function**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ML.PREDICT` **函数**：[https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict)'
