- en: Chapter 12. Augmented Reality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 增强现实
- en: In this chapter, you are going to learn about augmented reality and how you
    can use it to build cool applications. We will discuss pose estimation and plane
    tracking. You will learn how to map the coordinates from 2D to 3D, and how we
    can overlay graphics on top of a live video.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习关于增强现实以及如何使用它来构建酷炫应用的知识。我们将讨论姿态估计和平面跟踪。你将学习如何将坐标从二维映射到三维，以及我们如何可以在实时视频上叠加图形。
- en: 'By the end of this chapter, you will know:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道：
- en: What is the premise of augmented reality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强现实的前提是什么
- en: What is pose estimation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姿态估计是什么
- en: How to track a planar object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何跟踪平面对象
- en: How to map coordinates from 3D to 2D
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将坐标从三维映射到二维
- en: How to overlay graphics on top of a video in real time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在实时视频上叠加图形
- en: What is the premise of augmented reality?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强现实的前提是什么？
- en: Before we jump into all the fun stuff, let's understand what augmented reality
    means. You would have probably seen the term "augmented reality" being used in
    a variety of contexts. So, we should understand the premise of augmented reality
    before we start discussing the implementation details. Augmented Reality refers
    to the superposition of computer-generated input such as imagery, sounds, graphics,
    and text on top of the real world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入所有有趣的内容之前，让我们先了解什么是增强现实。你可能已经在各种背景下看到过“增强现实”这个术语被使用。因此，在我们开始讨论实现细节之前，我们应该理解增强现实的前提。增强现实指的是计算机生成的输入，如图像、声音、图形和文本，叠加在现实世界之上的叠加。
- en: Augmented reality tries to blur the line between what's real and what's computer-generated
    by seamlessly merging the information and enhancing what we see and feel. It is
    actually closely related to a concept called mediated reality where a computer
    modifies our view of the reality. As a result of this, the technology works by
    enhancing our current perception of reality. Now the challenge here is to make
    it look seamless to the user. It's easy to just overlay something on top of the
    input video, but we need to make it look like it is part of the video. The user
    should feel that the computer-generated input is closely following the real world.
    This is what we want to achieve when we build an augmented reality system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 增强现实试图通过无缝融合信息和增强我们所看到和感受到的内容，来模糊现实与计算机生成内容之间的界限。实际上，它与一个称为中介现实的概念密切相关，其中计算机修改了我们对现实的看法。因此，这项技术通过增强我们对现实的当前感知来工作。现在的挑战是让用户感觉它看起来是无缝的。仅仅在输入视频上叠加一些东西很容易，但我们需要让它看起来像是视频的一部分。用户应该感觉到计算机生成的输入紧密跟随现实世界。这就是我们构建增强现实系统时想要实现的目标。
- en: Computer vision research in this context explores how we can apply computer-generated
    imagery to live video streams so that we can enhance the perception of the real
    world. Augmented reality technology has a wide variety of applications including,
    but not limited to, head-mounted displays, automobiles, data visualization, gaming,
    construction, and so on. Now that we have powerful smartphones and smarter machines,
    we can build high-end augmented reality applications with ease.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，计算机视觉研究探索了如何将计算机生成的图像应用于实时视频流，以便我们可以增强对现实世界的感知。增强现实技术有各种各样的应用，包括但不限于头戴式显示器、汽车、数据可视化、游戏、建筑等等。现在我们有了强大的智能手机和更智能的机器，我们可以轻松构建高端增强现实应用。
- en: What does an augmented reality system look like?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强现实系统看起来是什么样的？
- en: 'Let''s consider the following figure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图示：
- en: '![What does an augmented reality system look like?](img/B04554_12_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![增强现实系统看起来是什么样的？](img/B04554_12_01.jpg)'
- en: As we can see here, the camera captures the real world video to get the reference
    point. The graphics system generates the virtual objects that need to be overlaid
    on top of the video. Now the video-merging block is where all the magic happens.
    This block should be smart enough to understand how to overlay the virtual objects
    on top of the real world in the best way possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，摄像头捕捉现实世界的视频以获取参考点。图形系统生成需要叠加到视频上的虚拟对象。现在，视频合并块是所有魔法发生的地方。这个块应该足够智能，能够理解如何以最佳方式将虚拟对象叠加到现实世界之上。
- en: Geometric transformations for augmented reality
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强现实中的几何变换
- en: The outcome of augmented reality is amazing, but there are a lot of mathematical
    things going on underneath. Augmented reality utilizes a lot of geometric transformations
    and the associated mathematical functions to make sure everything looks seamless.
    When talking about a live video for augmented reality, we need to precisely register
    the virtual objects on top of the real world. To understand it better, let's think
    of it as an alignment of two cameras—the real one through which we see the world,
    and the virtual one that projects the computer generated graphical objects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 增强现实的结果令人惊叹，但下面有很多数学运算在进行。增强现实利用了很多几何变换和相关的数学函数来确保一切看起来无缝。当我们谈论增强现实的实时视频时，我们需要精确地注册虚拟物体在现实世界之上的位置。为了更好地理解，让我们把它想象成两个摄像机的对齐——一个是真实的，通过它我们看到世界，另一个是虚拟的，它投射出计算机生成的图形物体。
- en: 'In order to build an augmented reality system, the following geometric transformations
    need to be established:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个增强现实系统，需要建立以下几何变换：
- en: '**Object-to-scene**: This transformation refers to transforming the 3D coordinates
    of a virtual object and expressing them in the coordinate frame of our real-world
    scene. This ensures that we are positioning the virtual object in the right location.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象到场景**：这种变换指的是将虚拟对象的3D坐标转换，并在我们现实世界的场景坐标系中表达它们。这确保了我们将虚拟物体定位在正确的位置。'
- en: '**Scene-to-camera**: This transformation refers to the pose of the camera in
    the real world. By "pose", we mean the orientation and location of the camera.
    We need to estimate the point of view of the camera so that we know how to overlay
    the virtual object.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景到摄像机**：这种变换指的是摄像机在现实世界中的姿态。通过“姿态”，我们指的是摄像机的方向和位置。我们需要估计摄像机的视角，以便我们知道如何叠加虚拟物体。'
- en: '**Camera-to-image**: This refers to the calibration parameters of the camera.
    This defines how we can project a 3D object onto a 2D image plane. This is the
    image that we will actually see in the end.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摄像机到图像**：这指的是摄像机的校准参数。这定义了我们可以如何将3D物体投影到2D图像平面上。这是我们最终将看到的图像。'
- en: 'Consider the following image:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图像：
- en: '![Geometric transformations for augmented reality](img/B04554_12_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![增强现实中的几何变换](img/B04554_12_02.jpg)'
- en: 'As we can see here, the car is trying to fit into the scene but it looks very
    artificial. If we don''t convert the coordinates in the right way, it looks unnatural.
    This is what we were talking about in the object-to-scene transformation! Once
    we transform the 3D coordinates of the virtual object into the coordinate frame
    of the real world, we need to estimate the pose of the camera:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这辆车试图适应场景，但它看起来非常不自然。如果我们不能正确转换坐标，它看起来就不自然。这就是我们之前所说的对象到场景变换！一旦我们将虚拟物体的3D坐标转换到现实世界的坐标系中，我们需要估计摄像机的姿态：
- en: '![Geometric transformations for augmented reality](img/B04554_12_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![增强现实中的几何变换](img/B04554_12_03.jpg)'
- en: We need to understand the position and rotation of the camera because that's
    what the user will see. Once we estimate the camera pose, we are ready to put
    this 3D scene on a 2D image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解摄像机的位置和旋转，因为这就是用户将看到的。一旦我们估计出摄像机的姿态，我们就可以将这个3D场景放置到2D图像上。
- en: '![Geometric transformations for augmented reality](img/B04554_12_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![增强现实中的几何变换](img/B04554_12_04.jpg)'
- en: Once we have these transformations, we can build the complete system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些变换，我们就可以构建完整的系统。
- en: What is pose estimation?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是姿态估计？
- en: Before we proceed, we need to understand how to estimate the camera pose. This
    is a very critical step in an augmented reality system and we need to get it right
    if we want our experience to be seamless. In the world of augmented reality, we
    overlay graphics on top of an object in real time. In order to do that, we need
    to know the location and orientation of the camera, and we need to do it quickly.
    This is where pose estimation becomes very important. If you don't track the pose
    correctly, the overlaid graphics will not look natural.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要了解如何估计摄像机的姿态。这是增强现实系统中的一个非常关键的步骤，如果我们想要我们的体验无缝，我们必须做对。在增强现实的世界里，我们实时地在物体上叠加图形。为了做到这一点，我们需要知道摄像机的位置和方向，而且我们需要快速做到。这就是姿态估计变得非常重要的地方。如果你不能正确跟踪姿态，叠加的图形看起来就不会自然。
- en: 'Consider the following image:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图像：
- en: '![What is pose estimation?](img/B04554_12_05.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![什么是姿态估计？](img/B04554_12_05.jpg)'
- en: 'The arrow line represents that the surface is normal. Let''s say the object
    changes its orientation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头线表示表面是法线。假设物体改变了其方向：
- en: '![What is pose estimation?](img/B04554_12_06.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![什么是姿态估计？](img/B04554_12_06.jpg)'
- en: Now even though the location is the same, the orientation has changed. We need
    to have this information so that the overlaid graphics looks natural. We need
    to make sure that it's aligned to this orientation as well as position.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尽管位置相同，但方向已经改变。我们需要这个信息，以便叠加的图形看起来自然。我们需要确保它与此方向以及位置对齐。
- en: How to track planar objects?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何追踪平面物体？
- en: 'Now that you understand what pose estimation is, let''s see how you can use
    it to track planar objects. Let''s consider the following planar object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了姿态估计是什么，让我们看看你如何可以使用它来追踪平面物体。让我们考虑以下平面物体：
- en: '![How to track planar objects?](img/B04554_12_07.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_07.jpg)'
- en: 'Now if we extract feature points from this image, we will see something like
    this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们从这个图像中提取特征点，我们会看到类似这样的东西：
- en: '![How to track planar objects?](img/B04554_12_08.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_08.jpg)'
- en: 'Let''s tilt the cardboard:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们倾斜纸板：
- en: '![How to track planar objects?](img/B04554_12_09.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_09.jpg)'
- en: 'As we can see, the cardboard is tilted in this image. Now if we want to make
    sure our virtual object is overlaid on top of this surface, we need to gather
    this planar tilt information. One way to do this is by using the relative positions
    of those feature points. If we extract the feature points from the preceding image,
    it will look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这个图像中纸板是倾斜的。现在如果我们想确保我们的虚拟物体叠加在这个表面上，我们需要收集这个平面倾斜信息。一种方法是通过使用那些特征点的相对位置。如果我们从前面的图像中提取特征点，它将看起来像这样：
- en: '![How to track planar objects?](img/B04554_12_10.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_10.jpg)'
- en: As you can see, the feature points got closer horizontally on the far end of
    the plane as compared to the ones on the near end.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，特征点在平面的远端水平上比近端更靠近。
- en: '![How to track planar objects?](img/B04554_12_11.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_11.jpg)'
- en: So we can utilize this information to extract the orientation information from
    the image. If you remember, we discussed perspective transformation in detail
    when we were discussing geometric transformations as well as panoramic imaging.
    All we need to do is use those two sets of points and extract the homography matrix.
    This homography matrix will tell us how the cardboard turned.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以利用这些信息从图像中提取方向信息。如果你还记得，我们在讨论几何变换以及全景成像时详细讨论了透视变换。我们所需做的只是使用这两组点并提取单应性矩阵。这个单应性矩阵将告诉我们纸板是如何转动的。
- en: 'Consider the following image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图像：
- en: '![How to track planar objects?](img/B04554_12_12.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_12.jpg)'
- en: We start by selecting the region of interest.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择感兴趣的区域。
- en: '![How to track planar objects?](img/B04554_12_13.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_13.jpg)'
- en: We then extract feature points from this region of interest. Since we are tracking
    planar objects, the algorithm assumes that this region of interest is a plane.
    That was obvious, but it's better to state it explicitly! So make sure you have
    a cardboard in your hand when you select this region of interest. Also, it'll
    be better if the cardboard has a bunch of patterns and distinctive points so that
    it's easy to detect and track the feature points on it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后从感兴趣的区域提取特征点。由于我们正在追踪平面物体，算法假设这个感兴趣的区域是一个平面。这是显而易见的，但最好明确地说明！所以当你选择这个感兴趣的区域时，确保你手里有一张纸板。此外，如果纸板上有许多模式和独特的点，那么检测和追踪其上的特征点会更容易。
- en: 'Let the tracking begin! We''ll move the cardboard around to see what happens:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让追踪开始！我们将移动纸板来观察会发生什么：
- en: '![How to track planar objects?](img/B04554_12_14.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_14.jpg)'
- en: 'As you can see, the feature points are being tracked inside the region of interest.
    Let''s tilt it and see what happens:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，特征点在感兴趣区域内被追踪。让我们倾斜它并看看会发生什么：
- en: '![How to track planar objects?](img/B04554_12_15.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何追踪平面物体？](img/B04554_12_15.jpg)'
- en: Looks like the feature points are being tracked properly. As we can see, the
    overlaid rectangle is changing its orientation according to the surface of the
    cardboard.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来特征点被正确追踪。正如我们所见，叠加的矩形根据纸板的表面改变其方向。
- en: 'Here is the code to do it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完成这个任务的代码：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What happened inside the code?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码内部发生了什么？
- en: To start with, we have a `PoseEstimator` class that does all the heavy lifting
    here. We need something to detect the features in the image and something to match
    the features between successive images. So we use the ORB feature detector and
    the Flann feature matcher. As we can see, we initialize the class with these parameters
    in the constructor.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个`PoseEstimator`类，它在这里做了所有繁重的工作。我们需要某种东西来检测图像中的特征，以及某种东西来匹配连续图像之间的特征。因此，我们使用了ORB特征检测器和Flann特征匹配器。正如我们所见，我们在构造函数中用这些参数初始化了类。
- en: Whenever we select a region of interest, we call the `add_target` method to
    add that to our list of tracking targets. This method just extracts the features
    from that region of interest and stores in one of the class variables. Now that
    we have a target, we are ready to track it!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们选择一个感兴趣的区域时，我们就调用`add_target`方法将其添加到我们的跟踪目标列表中。这个方法只是从感兴趣的区域中提取特征并存储在类的一个变量中。现在我们有了目标，我们就可以准备跟踪它了！
- en: The `track_target` method handles all the tracking. We take the current frame
    and extract all the keypoints. However, we are not really interested in all the
    keypoints in the current frame of the video. We just want the keypoints that belong
    to our target object. So now, our job is to find the closest keypoints in the
    current frame.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`track_target`方法处理所有的跟踪。我们取当前帧并提取所有的关键点。然而，我们并不真正对视频当前帧中的所有关键点感兴趣。我们只想找到属于我们的目标物体的关键点。所以现在，我们的任务是找到当前帧中最接近的关键点。'
- en: We now have a set of keypoints in the current frame and we have another set
    of keypoints from our target object in the previous frame. The next step is to
    extract the homography matrix from these matching points. This homography matrix
    tells us how to transform the overlaid rectangle so that it's aligned with the
    cardboard surface. We just need to take this homography matrix and apply it to
    the overlaid rectangle to obtain the new positions of all its points.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了当前帧中的一组关键点，我们还从前一帧的目标物体中得到了另一组关键点。下一步是从这些匹配点中提取单应性矩阵。这个单应性矩阵告诉我们如何变换叠加的矩形，使其与纸板表面对齐。我们只需要将这个单应性矩阵应用到叠加的矩形上，以获得所有点的新的位置。
- en: How to augment our reality?
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何增强我们的现实？
- en: Now that we know how to track planar objects, let's see how to overlay 3D objects
    on top of the real world. The objects are 3D but the video on our screen is 2D.
    So the first step here is to understand how to map those 3D objects to 2D surfaces
    so that it looks realistic. We just need to project those 3D points onto planar
    surfaces.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何跟踪平面物体，让我们看看如何将3D物体叠加到现实世界之上。这些物体是3D的，但屏幕上的视频是2D的。所以这里的第一个步骤是理解如何将这些3D物体映射到2D表面上，使其看起来更真实。我们只需要将这些3D点投影到平面表面上。
- en: Mapping coordinates from 3D to 2D
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从3D到2D的坐标映射
- en: 'Once we estimate the pose, we project the points from the 3D to the 2D. Consider
    the following image:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们估计了姿态，我们就将点从3D投影到2D。考虑以下图像：
- en: '![Mapping coordinates from 3D to 2D](img/B04554_12_16.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![从3D到2D的坐标映射](img/B04554_12_16.jpg)'
- en: 'As we can see here, the TV remote control is a 3D object but we are seeing
    it on a 2D plane. Now if we move it around, it will look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里看到的，电视遥控器是一个3D物体，但我们看到的是它在2D平面上。现在如果我们移动它，它看起来会是这样：
- en: '![Mapping coordinates from 3D to 2D](img/B04554_12_17.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![从3D到2D的坐标映射](img/B04554_12_17.jpg)'
- en: This 3D object is still on a 2D plane. The object has moved to a different location
    and the distance from the camera has changed as well. How do we compute these
    coordinates? We need a mechanism to map this 3D object onto the 2D surface. This
    is where the 3D to 2D projection becomes really important.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个3D物体仍然在2D平面上。物体移动到了不同的位置，并且与摄像机的距离也发生了变化。我们如何计算这些坐标？我们需要一个机制将这个3D物体映射到2D表面上。这就是3D到2D投影变得非常重要的地方。
- en: We just need to estimate the initial camera pose to start with. Now, let's assume
    that the intrinsic parameters of the camera are already known. So we can just
    use the `solvePnP` function in OpenCV to estimate the camera's pose. This function
    is used to estimate the object's pose using a set of points. You can read more
    about it at [http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool
    solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix,
    InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess,
    int flags)](http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool%20solvePnP(InputArray%20objectPoints,%20InputArray%20imagePoints,%20InputArray%20cameraMatrix,%20InputArray%20distCoeffs,%20OutputArray%20rvec,%20OutputArray%20tvec,%20bool%20useExtrinsicGuess,%20int%20flags)).
    Once we do this, we need to project these points onto 2D. We use the OpenCV function
    `projectPoints` to do this. This function calculates the projections of those
    3D points onto the 2D plane.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要估计初始相机姿态来开始。现在，假设相机的内在参数已经知道。因此，我们可以直接使用 OpenCV 中的 `solvePnP` 函数来估计相机的姿态。这个函数用于使用一组点来估计物体的姿态。你可以在[http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool
    solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix,
    InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess,
    int flags)](http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool%20solvePnP(InputArray%20objectPoints,%20InputArray%20imagePoints,%20InputArray%20cameraMatrix,%20InputArray%20distCoeffs,%20OutputArray%20rvec,%20OutputArray%20tvec,%20bool%20useExtrinsicGuess,%20int%20flags))中了解更多信息。一旦我们这样做，我们需要将这些点投影到2D平面上。我们使用
    OpenCV 函数 `projectPoints` 来完成这个任务。这个函数计算那些3D点在2D平面上的投影。
- en: How to overlay 3D objects on a video?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在视频中叠加3D对象？
- en: 'Now that we have all the different blocks, we are ready to build the final
    system. Let''s say we want to overlay a pyramid on top of our cardboard as shown
    here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有不同的模块，我们准备构建最终的系统。假设我们想在纸箱上叠加一个金字塔，就像这里展示的那样：
- en: '![How to overlay 3D objects on a video?](img/B04554_12_18.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![如何在视频中叠加3D对象？](img/B04554_12_18.jpg)'
- en: 'Let''s tilt the cardboard to see what happens:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们倾斜纸箱来看看会发生什么：
- en: '![How to overlay 3D objects on a video?](img/B04554_12_19.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![如何在视频中叠加3D对象？](img/B04554_12_19.jpg)'
- en: 'Looks like the pyramid is following the surface. Let''s add a second target:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来金字塔正在跟随表面。让我们添加第二个目标：
- en: '![How to overlay 3D objects on a video?](img/B04554_12_20.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何在视频中叠加3D对象？](img/B04554_12_20.jpg)'
- en: 'You can keep adding more targets and all those pyramids will be tracked nicely.
    Let''s see how to do this using OpenCV Python. Make sure to save the previous
    file as `pose_estimation.py` because we will be importing a couple of classes
    from there:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续添加更多目标，所有这些金字塔都将被很好地跟踪。让我们看看如何使用 OpenCV Python 来实现这一点。确保将之前的文件保存为 `pose_estimation.py`，因为我们将从那里导入几个类：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's look at the code
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们看看代码
- en: The class `Tracker` is used to perform all the computations here. We initialize
    the class with the pyramid structure that is defined using edges and vertices.
    The logic that we use to track the surface is the same as we discussed earlier
    because we are using the same class. We just need to use `solvePnP` and `projectPoints`
    to map the 3D pyramid to the 2D surface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tracker` 类用于执行这里的所有计算。我们使用通过边和顶点定义的金字塔结构初始化该类。我们用于跟踪表面的逻辑与之前讨论的相同，因为我们使用的是同一个类。我们只需要使用
    `solvePnP` 和 `projectPoints` 来将3D金字塔映射到2D表面上。'
- en: Let's add some movements
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们添加一些动作
- en: 'Now that we know how to add a virtual pyramid, let''s see if we can add some
    movements. Let''s see how we can dynamically change the height of the pyramid.
    When you start, the pyramid will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何添加一个虚拟金字塔，让我们看看是否可以添加一些动作。让我们看看如何动态地改变金字塔的高度。当你开始时，金字塔看起来会是这样：
- en: '![Let''s add some movements](img/B04554_12_21.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![让我们添加一些动作](img/B04554_12_21.jpg)'
- en: 'If you wait for some time, the pyramid gets taller and it will look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待一段时间，金字塔会变高，看起来会是这样：
- en: '![Let''s add some movements](img/B04554_12_22.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![让我们添加一些动作](img/B04554_12_22.jpg)'
- en: 'Let''s see how to do it in OpenCV Python. Inside the augmented reality code
    that we just discussed, add the following snippet at the end of the `__init__`
    method in the `Tracker` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 OpenCV Python 中实现它。在我们刚刚讨论的增强现实代码中，在 `Tracker` 类的 `__init__` 方法末尾添加以下片段：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have the structure, we need to add the code to dynamically change
    the height. Replace the `overlay_graphics()` method with the following method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了结构，我们需要添加代码来动态地改变高度。用以下方法替换 `overlay_graphics()` 方法：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we know how to change the height, let''s go ahead and make the pyramid
    dance for us. We can make the tip of the pyramid oscillate in a nice periodic
    fashion. So when you start, it will look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何改变高度，让我们继续让金字塔为我们跳舞。我们可以让金字塔的尖端以优雅的周期性方式振荡。所以当你开始时，它将看起来像这样：
- en: '![Let''s add some movements](img/B04554_12_23.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![让我们添加一些动作](img/B04554_12_23.jpg)'
- en: 'If you wait for some time, it will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待一段时间，它将看起来像这样：
- en: '![Let''s add some movements](img/B04554_12_24.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![让我们添加一些动作](img/B04554_12_24.jpg)'
- en: You can look at `augmented_reality_motion.py` for the implementation details.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看`augmented_reality_motion.py`以了解实现细节。
- en: 'In our next experiment, we will make the whole pyramid move around the region
    of interest. We can make it move in any way we want. Let''s start by adding linear
    diagonal movement around our selected region of interest. When you start, it will
    look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个实验中，我们将使整个金字塔围绕感兴趣的区域移动。我们可以让它以任何我们想要的方式移动。让我们先从在所选感兴趣区域添加线性对角线运动开始。当你开始时，它将看起来像这样：
- en: '![Let''s add some movements](img/B04554_12_25.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![让我们添加一些动作](img/B04554_12_25.jpg)'
- en: 'After some time, it will look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，它将看起来像这样：
- en: '![Let''s add some movements](img/B04554_12_26.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![让我们添加一些动作](img/B04554_12_26.jpg)'
- en: 'Refer to `augmented_reality_dancing.py` to see how to change the `overlay_graphics()`
    method to make it dance. Let''s see if we can make the pyramid go around in circles
    around our region of interest. When you start, it will look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 参考到`augmented_reality_dancing.py`来了解如何更改`overlay_graphics()`方法以使其跳舞。让我们看看我们能否让金字塔围绕我们的感兴趣区域旋转。当你开始时，它将看起来像这样：
- en: '![Let''s add some movements](img/B04554_12_27.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![让我们添加一些动作](img/B04554_12_27.jpg)'
- en: 'After some time, it will move to a new position:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，它将移动到新的位置：
- en: '![Let''s add some movements](img/B04554_12_28.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![让我们添加一些动作](img/B04554_12_28.jpg)'
- en: You can refer to `augmented_reality_circular_motion.py` to see how to make this
    happen. You can make it do anything you want. You just need to come up with the
    right mathematical formula and the pyramid will literally dance to your tune!
    You can also try out other virtual objects to see what you can with it. There
    are a lot of things you can do with a lot of different objects. These examples
    provide a good reference point, on top of which you can build many interesting
    augmented reality applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考`augmented_reality_circular_motion.py`来了解如何实现这一点。你可以让它做任何你想做的事情。你只需要想出正确的数学公式，金字塔就会真的按照你的旋律跳舞！你还可以尝试其他虚拟物体，看看你能用它做什么。你可以用很多不同的物体做很多事情。这些例子提供了一个很好的参考点，在此基础上，你可以构建许多有趣的增强现实应用。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the premise of augmented reality and understood
    what an augmented reality system looks like. We discussed the geometric transformations
    required for augmented reality. You learned how to use those transformations to
    estimate the camera pose. You learned how to track planar objects. We discussed
    how we can add virtual objects on top of the real world. You learned how to modify
    the virtual objects in different ways to add cool effects. Remember that the world
    of computer vision is filled with endless possibilities! This book is designed
    to teach you the necessary skills to get started on a wide variety of projects.
    Now it's up to you and your imagination to use the skills you have acquired here
    to build something unique and interesting.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了增强现实的前提，并了解了增强现实系统看起来是什么样子。我们讨论了增强现实所需的几何变换。你学习了如何使用这些变换来估计相机姿态。你学习了如何跟踪平面物体。我们讨论了如何在现实世界之上添加虚拟物体。你学习了如何以不同的方式修改虚拟物体以添加酷炫效果。记住，计算机视觉的世界充满了无限的可能性！这本书旨在教你开始各种项目所需的必要技能。现在，取决于你和你自己的想象力，使用你在这里获得的技能来构建一些独特且有趣的东西。
