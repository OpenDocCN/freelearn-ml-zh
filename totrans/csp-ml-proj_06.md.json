["```py\n// 1\\. Missing CustomerID Values\necommerceDF\n    .Columns[new string[] { \"CustomerID\", \"InvoiceNo\", \"StockCode\", \"Quantity\", \"UnitPrice\", \"Country\" }]\n    .GetRowsAt(new int[] { 1440, 1441, 1442, 1443, 1444, 1445, 1446 })\n    .Print();\nConsole.WriteLine(\"\\n\\n* # of values in CustomerID column: {0}\", ecommerceDF[\"CustomerID\"].ValueCount);\n\n// Drop missing values\necommerceDF = ecommerceDF\n    .Columns[new string[] { \"CustomerID\", \"Description\", \"Quantity\", \"UnitPrice\", \"Country\" }]\n    .DropSparseRows();\n\n// Per-Transaction Purchase Amount = Quantity * UnitPrice\necommerceDF.AddColumn(\"Amount\", ecommerceDF[\"Quantity\"] * ecommerceDF[\"UnitPrice\"]);\n\nConsole.WriteLine(\"\\n\\n* Shape (After dropping missing values): {0}, {1}\\n\", ecommerceDF.RowCount, ecommerceDF.ColumnCount);\nConsole.WriteLine(\"* After dropping missing values and unnecessary columns:\");\necommerceDF.GetRowsAt(new int[] { 0, 1, 2, 3, 4 }).Print();\n// Export Data\necommerceDF.SaveCsv(Path.Combine(dataDirPath, \"data-clean.csv\"));\n```", "```py\n// 2\\. Number of transactions by country\nvar numTransactionsByCountry = ecommerceDF\n    .AggregateRowsBy<string, int>(\n        new string[] { \"Country\" },\n        new string[] { \"CustomerID\" },\n        x => x.ValueCount\n    ).SortRows(\"CustomerID\");\n\nvar top5 = numTransactionsByCountry\n    .GetRowsAt(new int[] {\n        numTransactionsByCountry.RowCount-1, numTransactionsByCountry.RowCount-2,\n        numTransactionsByCountry.RowCount-3, numTransactionsByCountry.RowCount-4,\n        numTransactionsByCountry.RowCount-5 });\ntop5.Print();\n\nvar topTransactionByCountryBarChart = DataBarBox.Show(\n    top5.GetColumn<string>(\"Country\").Values.ToArray().Select(x => x.Equals(\"United Kingdom\") ? \"UK\" : x),\n    top5[\"CustomerID\"].Values.ToArray()\n);\ntopTransactionByCountryBarChart.SetTitle(\n    \"Top 5 Countries with the most number of transactions\"\n );\nAggregateRowsBy method in the Deedle data frame to group the records by country and count the total number of transactions for each country. Then, we sort the resulting data frame using the SortRows method and take the top five countries. When you run this code, you will see the following bar chart:\n```", "```py\n// 3\\. Per-Transaction Quantity Distributions\nConsole.WriteLine(\"\\n\\n-- Per-Transaction Order Quantity Distribution-- \");\ndouble[] quantiles = Accord.Statistics.Measures.Quantiles(\n    ecommerceDF[\"Quantity\"].ValuesAll.ToArray(),\n    new double[] { 0, 0.25, 0.5, 0.75, 1.0 }\n);\nConsole.WriteLine(\n    \"Min: \\t\\t\\t{0:0.00}\\nQ1 (25% Percentile): \\t{1:0.00}\\nQ2 (Median): \\t\\t{2:0.00}\\nQ3 (75% Percentile): \\t{3:0.00}\\nMax: \\t\\t\\t{4:0.00}\",\n    quantiles[0], quantiles[1], quantiles[2], quantiles[3], quantiles[4]\n);\n\nConsole.WriteLine(\"\\n\\n-- Per-Transaction Purchase-Order Quantity Distribution-- \");\nquantiles = Accord.Statistics.Measures.Quantiles(\n    ecommerceDF[\"Quantity\"].Where(x => x.Value >= 0).ValuesAll.ToArray(),\n    new double[] { 0, 0.25, 0.5, 0.75, 1.0 }\n);\nConsole.WriteLine(\n    \"Min: \\t\\t\\t{0:0.00}\\nQ1 (25% Percentile): \\t{1:0.00}\\nQ2 (Median): \\t\\t{2:0.00}\\nQ3 (75% Percentile): \\t{3:0.00}\\nMax: \\t\\t\\t{4:0.00}\",\n    quantiles[0], quantiles[1], quantiles[2], quantiles[3], quantiles[4]\n);\n\nConsole.WriteLine(\"\\n\\n-- Per-Transaction Cancel-Order Quantity Distribution-- \");\nquantiles = Accord.Statistics.Measures.Quantiles(\n    ecommerceDF[\"Quantity\"].Where(x => x.Value < 0).ValuesAll.ToArray(),\n    new double[] { 0, 0.25, 0.5, 0.75, 1.0 }\n);\nConsole.WriteLine(\n    \"Min: \\t\\t\\t{0:0.00}\\nQ1 (25% Percentile): \\t{1:0.00}\\nQ2 (Median): \\t\\t{2:0.00}\\nQ3 (75% Percentile): \\t{3:0.00}\\nMax: \\t\\t\\t{4:0.00}\",\n    quantiles[0], quantiles[1], quantiles[2], quantiles[3], quantiles[4]\n);\n```", "```py\n// Filtering out cancel orders to get purchase orders only\necommerceDF[\"Quantity\"].Where(x => x.Value >= 0)\n// Filtering out purchase orders to get cancel orders only\necommerceDF[\"Quantity\"].Where(x => x.Value < 0)\n```", "```py\n// 4\\. Per-Transaction Unit Price Distributions\nConsole.WriteLine(\"\\n\\n-- Per-Transaction Unit Price Distribution-- \");\nquantiles = Accord.Statistics.Measures.Quantiles(\n    ecommerceDF[\"UnitPrice\"].ValuesAll.ToArray(),\n    new double[] { 0, 0.25, 0.5, 0.75, 1.0 }\n);\nConsole.WriteLine(\n    \"Min: \\t\\t\\t{0:0.00}\\nQ1 (25% Percentile): \\t{1:0.00}\\nQ2 (Median): \\t\\t{2:0.00}\\nQ3 (75% Percentile): \\t{3:0.00}\\nMax: \\t\\t\\t{4:0.00}\",\n    quantiles[0], quantiles[1], quantiles[2], quantiles[3], quantiles[4]\n);\n```", "```py\n// 5\\. Per-Transaction Purchase Price Distributions\nConsole.WriteLine(\"\\n\\n-- Per-Transaction Total Amount Distribution-- \");\nquantiles = Accord.Statistics.Measures.Quantiles(\n    ecommerceDF[\"Amount\"].ValuesAll.ToArray(),\n    new double[] { 0, 0.25, 0.5, 0.75, 1.0 }\n);\nConsole.WriteLine(\n    \"Min: \\t\\t\\t{0:0.00}\\nQ1 (25% Percentile): \\t{1:0.00}\\nQ2 (Median): \\t\\t{2:0.00}\\nQ3 (75% Percentile): \\t{3:0.00}\\nMax: \\t\\t\\t{4:0.00}\",\n    quantiles[0], quantiles[1], quantiles[2], quantiles[3], quantiles[4]\n);\n\nConsole.WriteLine(\"\\n\\n-- Per-Transaction Purchase-Order Total Amount Distribution-- \");\nquantiles = Accord.Statistics.Measures.Quantiles(\n    ecommerceDF[\"Amount\"].Where(x => x.Value >= 0).ValuesAll.ToArray(),\n    new double[] { 0, 0.25, 0.5, 0.75, 1.0 }\n);\nConsole.WriteLine(\n    \"Min: \\t\\t\\t{0:0.00}\\nQ1 (25% Percentile): \\t{1:0.00}\\nQ2 (Median): \\t\\t{2:0.00}\\nQ3 (75% Percentile): \\t{3:0.00}\\nMax: \\t\\t\\t{4:0.00}\",\n    quantiles[0], quantiles[1], quantiles[2], quantiles[3], quantiles[4]\n);\n\nConsole.WriteLine(\"\\n\\n-- Per-Transaction Cancel-Order Total Amount Distribution-- \");\nquantiles = Accord.Statistics.Measures.Quantiles(\n    ecommerceDF[\"Amount\"].Where(x => x.Value < 0).ValuesAll.ToArray(),\n    new double[] { 0, 0.25, 0.5, 0.75, 1.0 }\n);\nConsole.WriteLine(\n    \"Min: \\t\\t\\t{0:0.00}\\nQ1 (25% Percentile): \\t{1:0.00}\\nQ2 (Median): \\t\\t{2:0.00}\\nQ3 (75% Percentile): \\t{3:0.00}\\nMax: \\t\\t\\t{4:0.00}\",\n    quantiles[0], quantiles[1], quantiles[2], quantiles[3], quantiles[4]\n);\n```", "```py\n// 6\\. # of Purchase vs. Cancelled Transactions\nvar purchaseVSCancelBarChart = DataBarBox.Show(\n    new string[] { \"Purchase\", \"Cancel\" },\n    new double[] {\n        ecommerceDF[\"Quantity\"].Where(x => x.Value >= 0).ValueCount ,\n        ecommerceDF[\"Quantity\"].Where(x => x.Value < 0).ValueCount\n    }\n);\npurchaseVSCancelBarChart.SetTitle(\n    \"Purchase vs. Cancel\"\n );\n```", "```py\n// 1\\. Net Revenue per Customer\nvar revPerCustomerDF = ecommerceDF.AggregateRowsBy<double, double>(\n    new string[] { \"CustomerID\" },\n    new string[] { \"Amount\" },\n    x => x.Sum()\n);\n// 2\\. # of Total Transactions per Customer\nvar numTransactionsPerCustomerDF = ecommerceDF.AggregateRowsBy<double, double>(\n    new string[] { \"CustomerID\" },\n    new string[] { \"Quantity\" },\n    x => x.ValueCount\n);\n// 3\\. # of Cancelled Transactions per Customer\nvar numCancelledPerCustomerDF = ecommerceDF.AggregateRowsBy<double, double>(\n    new string[] { \"CustomerID\" },\n    new string[] { \"Quantity\" },\n    x => x.Select(y => y.Value >= 0 ? 0.0 : 1.0).Sum()\n);\n// 4\\. Average UnitPrice per Customer\nvar avgUnitPricePerCustomerDF = ecommerceDF.AggregateRowsBy<double, double>(\n    new string[] { \"CustomerID\" },\n    new string[] { \"UnitPrice\" },\n    x => x.Sum() / x.ValueCount\n);\n// 5\\. Average Quantity per Customer\nvar avgQuantityPerCustomerDF = ecommerceDF.AggregateRowsBy<double, double>(\n    new string[] { \"CustomerID\" },\n    new string[] { \"Quantity\" },\n    x => x.Sum() / x.ValueCount\n);\n```", "```py\n// Aggregate all results\nvar featuresDF = Frame.CreateEmpty<int, string>();\nfeaturesDF.AddColumn(\"CustomerID\", revPerCustomerDF.GetColumn<double>(\"CustomerID\"));\nfeaturesDF.AddColumn(\"Description\", ecommerceDF.GetColumn<string>(\"Description\"));\nfeaturesDF.AddColumn(\"NetRevenue\", revPerCustomerDF.GetColumn<double>(\"Amount\"));\nfeaturesDF.AddColumn(\"NumTransactions\", numTransactionsPerCustomerDF.GetColumn<double>(\"Quantity\"));\nfeaturesDF.AddColumn(\"NumCancelled\", numCancelledPerCustomerDF.GetColumn<double>(\"Quantity\"));\nfeaturesDF.AddColumn(\"AvgUnitPrice\", avgUnitPricePerCustomerDF.GetColumn<double>(\"UnitPrice\"));\nfeaturesDF.AddColumn(\"AvgQuantity\", avgQuantityPerCustomerDF.GetColumn<double>(\"Quantity\"));\nfeaturesDF.AddColumn(\"PercentageCancelled\", featuresDF[\"NumCancelled\"] / featuresDF[\"NumTransactions\"]);\n\nConsole.WriteLine(\"\\n\\n* Feature Set:\");\nfeaturesDF.Print();\nPercentageCancelled, while we were appending those aggregated features to the new data frame. The PercentageCancelled feature simply holds information about how many of the transactions or orders were cancelled.\n```", "```py\nprivate static void PrintQuartiles(Frame<int, string> df, string colname)\n{\n    Console.WriteLine(\"\\n\\n-- {0} Distribution-- \", colname);\n    double[] quantiles = Accord.Statistics.Measures.Quantiles(\n        df[colname].ValuesAll.ToArray(),\n        new double[] { 0, 0.25, 0.5, 0.75, 1.0 }\n    );\n    Console.WriteLine(\n        \"Min: \\t\\t\\t{0:0.00}\\nQ1 (25% Percentile): \\t{1:0.00}\\nQ2 (Median): \\t\\t{2:0.00}\\nQ3 (75% Percentile): \\t{3:0.00}\\nMax: \\t\\t\\t{4:0.00}\",\n        quantiles[0], quantiles[1], quantiles[2], quantiles[3], quantiles[4]\n    );\n}\nquartiles for the features we just created:\n```", "```py\n// NetRevenue feature distribution\nPrintQuartiles(featuresDF, \"NetRevenue\");\n// NumTransactions feature distribution\nPrintQuartiles(featuresDF, \"NumTransactions\");\n// AvgUnitPrice feature distribution\nPrintQuartiles(featuresDF, \"AvgUnitPrice\");\n// AvgQuantity feature distribution\nPrintQuartiles(featuresDF, \"AvgQuantity\");\n// PercentageCancelled feature distribution\nPrintQuartiles(featuresDF, \"PercentageCancelled\");\n```", "```py\n// 1\\. Drop Customers with Negative NetRevenue\nfeaturesDF = featuresDF.Rows[\n    featuresDF[\"NetRevenue\"].Where(x => x.Value >= 0.0).Keys\n];\n// 2\\. Drop Customers with Negative AvgQuantity\nfeaturesDF = featuresDF.Rows[\n    featuresDF[\"AvgQuantity\"].Where(x => x.Value >= 0.0).Keys\n];\n// 3\\. Drop Customers who have more cancel orders than purchase orders\nfeaturesDF = featuresDF.Rows[\n    featuresDF[\"PercentageCancelled\"].Where(x => x.Value < 0.5).Keys\n];\n```", "```py\n// Create Percentile Features\nfeaturesDF.AddColumn(\n    \"NetRevenuePercentile\",\n    featuresDF[\"NetRevenue\"].Select(\n        x => StatsFunctions.PercentileRank(featuresDF[\"NetRevenue\"].Values.ToArray(), x.Value)\n    )\n);\nfeaturesDF.AddColumn(\n    \"NumTransactionsPercentile\",\n    featuresDF[\"NumTransactions\"].Select(\n        x => StatsFunctions.PercentileRank(featuresDF[\"NumTransactions\"].Values.ToArray(), x.Value)\n    )\n);\nfeaturesDF.AddColumn(\n    \"AvgUnitPricePercentile\",\n    featuresDF[\"AvgUnitPrice\"].Select(\n        x => StatsFunctions.PercentileRank(featuresDF[\"AvgUnitPrice\"].Values.ToArray(), x.Value)\n    )\n);\nfeaturesDF.AddColumn(\n    \"AvgQuantityPercentile\",\n    featuresDF[\"AvgQuantity\"].Select(\n        x => StatsFunctions.PercentileRank(featuresDF[\"AvgQuantity\"].Values.ToArray(), x.Value)\n    )\n);\nfeaturesDF.AddColumn(\n    \"PercentageCancelledPercentile\",\n    featuresDF[\"PercentageCancelled\"].Select(\n        x => StatsFunctions.PercentileRank(featuresDF[\"PercentageCancelled\"].Values.ToArray(), x.Value)\n    )\n);\nConsole.WriteLine(\"\\n\\n\\n* Percentile Features:\");\nfeaturesDF.Columns[\n    new string[] { \"NetRevenue\", \"NetRevenuePercentile\", \"NumTransactions\", \"NumTransactionsPercentile\" }\n].Print();\nStatsFunctions.PercentileRank method, which is part of the CenterSpace.NMath.Stats package. You can easily install this package using the following command in the Package Manager console:\n```", "```py\nInstall-Package CenterSpace.NMath.Stats\n```", "```py\nstring[] features = new string[] { \"NetRevenuePercentile\", \"AvgUnitPricePercentile\", \"AvgQuantityPercentile\" };\nConsole.WriteLine(\"* Features: {0}\\n\\n\", String.Join(\", \", features));\n\nvar normalizedDf = Frame.CreateEmpty<int, string>();\nvar average = ecommerceDF.Columns[features].Sum() / ecommerceDF.RowCount;\nforeach(string feature in features)\n{\n    normalizedDf.AddColumn(feature, (ecommerceDF[feature] - average[feature]) / ecommerceDF[feature].StdDev());\n}\n```", "```py\nint[] numClusters = new int[] { 4, 5, 6, 7, 8 };\nList<string> clusterNames = new List<string>();\nList<double> silhouetteScores = new List<double>();\nfor(int i = 0; i < numClusters.Length; i++)\n{\n    KMeans kmeans = new KMeans(numClusters[i]);\n    KMeansClusterCollection clusters = kmeans.Learn(sampleSet);\n    int[] labels = clusters.Decide(sampleSet);\n\n    string colname = String.Format(\"Cluster-{0}\", numClusters[i]);\n    clusterNames.Add(colname);\n\n    normalizedDf.AddColumn(colname, labels);\n    ecommerceDF.AddColumn(colname, labels);\n\n    Console.WriteLine(\"\\n\\n\\n##################### {0} ###########################\", colname);\n\n    Console.WriteLine(\"\\n\\n* Centroids for {0} clusters:\", numClusters[i]);\n\n    PrintCentroidsInfo(clusters.Centroids, features);\n    Console.WriteLine(\"\\n\");\n\n    VisualizeClusters(normalizedDf, colname, \"NetRevenuePercentile\", \"AvgUnitPricePercentile\");\n    VisualizeClusters(normalizedDf, colname, \"AvgUnitPricePercentile\", \"AvgQuantityPercentile\");\n    VisualizeClusters(normalizedDf, colname, \"NetRevenuePercentile\", \"AvgQuantityPercentile\");\n\n    for (int j = 0; j < numClusters[i]; j++)\n    {\n        GetTopNItemsPerCluster(ecommerceDF, j, colname);\n    }\n\n    double silhouetteScore = CalculateSilhouetteScore(normalizedDf, features, numClusters[i], colname);\n    Console.WriteLine(\"\\n\\n* Silhouette Score: {0}\", silhouetteScore.ToString(\"0.0000\"));\n\n    silhouetteScores.Add(silhouetteScore);\n    Console.WriteLine(\"\\n\\n##############################################################\\n\\n\\n\");\n}\n4, 5, 6, 7, and 8 clusters. We can instantiate a k-means clustering algorithm object using the KMeans class in the Accord.NET framework. Using the Learn method, we can train a k-means clustering model with the feature set we have. Then, we can use the Decide method to get the cluster labels for each record.\n```", "```py\nprivate static double CalculateSilhouetteScore(Frame<int, string> df, string[] features, int numCluster, string clusterColname)\n{\n    double[][] data = BuildJaggedArray(df.Columns[features].ToArray2D<double>(), df.RowCount, features.Length);\n\n    double total = 0.0;\n    for(int i = 0; i < df.RowCount; i++)\n    {\n        double sameClusterAverageDistance = 0.0;\n        double differentClusterDistance = 1000000.0;\n\n        double[] point = df.Columns[features].GetRowAt<double>(i).Values.ToArray();\n        double cluster = df[clusterColname].GetAt(i);\n\n        for(int j = 0; j < numCluster; j++)\n        {\n            double averageDistance = CalculateAverageDistance(df, features, clusterColname, j, point);\n\n            if (cluster == j)\n            {\n                sameClusterAverageDistance = averageDistance;\n            } else\n            {\n                differentClusterDistance = Math.Min(averageDistance, differentClusterDistance);\n            }\n        }\n\n        total += (differentClusterDistance - sameClusterAverageDistance) / Math.Max(sameClusterAverageDistance, differentClusterDistance);\n    }\n\n    return total / df.RowCount;\n}\n```", "```py\nprivate static double CalculateAverageDistance(Frame<int, string> df, string[] features, string clusterColname, int cluster, double[] point)\n{\n    var clusterDF = df.Rows[\n        df[clusterColname].Where(x => (int)x.Value == cluster).Keys\n    ];\n    double[][] clusterData = BuildJaggedArray(\n        clusterDF.Columns[features].ToArray2D<double>(),\n        clusterDF.RowCount,\n        features.Length\n    );\n\n    double averageDistance = 0.0;\n    for (int i = 0; i < clusterData.Length; i++)\n    {\n        averageDistance += Math.Sqrt(\n            point.Select((x, j) => Math.Pow(x - clusterData[i][j], 2)).Sum()\n        );\n    }\n    averageDistance /= (float)clusterData.Length;\n\n    return averageDistance;\n}\n```"]