- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Distributions of Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分布
- en: In this chapter, we will cover the essential aspects of data and distributions.
    We will start by covering the types of data and distributions of data. Having
    covered the essential measurements of distributions, we will describe the normal
    distribution and its important properties, including the central limit theorem.
    Finally, we will cover resampling methods such as permutations and transformation
    methods such as log transformations. This chapter covers the foundational knowledge
    necessary to begin statistical modeling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖数据和分布的基本方面。我们将从介绍数据类型和数据分布开始。在介绍分布的基本度量后，我们将描述正态分布及其重要特性，包括中心极限定理。最后，我们将涵盖重采样方法，如排列，以及变换方法，如对数变换。本章涵盖了开始统计建模所需的基础知识。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据类型
- en: Measuring and describing distributions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量和描述分布
- en: The normal distribution and the central limit theorem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正态分布和中心极限定理
- en: Bootstrapping
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自举
- en: Permutations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排列
- en: Transformations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will make use of Python 3.8.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用Python 3.8。
- en: The code for this chapter can be found here – [https://github.com/PacktPublishing/Building-Statistical-Models-in-Python](https://github.com/PacktPublishing/Building-Statistical-Models-in-Python)
    – in the `ch2` folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到 – [https://github.com/PacktPublishing/Building-Statistical-Models-in-Python](https://github.com/PacktPublishing/Building-Statistical-Models-in-Python)
    – 在`ch2`文件夹中。
- en: 'Please set up a virtual environment or Anaconda environment with the following
    packages installed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请设置一个虚拟环境或Anaconda环境，并安装以下包：
- en: '`numpy==1.23.0`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy==1.23.0`'
- en: '`scipy==1.8.1`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scipy==1.8.1`'
- en: '`matplotlib==3.5.2`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matplotlib==3.5.2`'
- en: '`pandas==1.4.2`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas==1.4.2`'
- en: '`statsmodels==0.13.2`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statsmodels==0.13.2`'
- en: Understanding data types
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据类型
- en: 'Before discussing data distributions, it would be useful to understand the
    types of data. Understanding data types is critical because the type of data determines
    what kind of analysis can be used since the type of data determines what operations
    can be used with the data (this will become clearer through the examples in this
    chapter). There are four distinct types of data:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论数据分布之前，了解数据类型会有所帮助。理解数据类型至关重要，因为数据类型决定了可以使用哪些分析，因为数据类型决定了可以使用哪些操作来处理数据（这将在本章的示例中变得更加清晰）。有四种不同的数据类型：
- en: Nominal data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名义数据
- en: Ordinal data
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序数数据
- en: Interval data
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区间数据
- en: Ratio data
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比率数据
- en: These types of data can also be grouped into two sets. The first two types of
    data (nominal and ordinal) are **qualitative data**, generally non-numeric categories.
    The last two types of data (interval and ratio) are **quantitative data**, generally
    numeric values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的数据也可以分为两组。前两种数据类型（名义和序数）是**定性数据**，通常是非数字类别。最后两种数据类型（区间和比率）是**定量数据**，通常是数值。
- en: Let’s start with nominal data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从名义数据开始。
- en: Nominal data
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名义数据
- en: 'Nominal data is data labeled with distinct groupings. As an example, take machines
    in a sign factory. It is common for factories to source machines from different
    suppliers, which would also have different model numbers. For example, the example
    factory may have 3 of **Model A** and 5 of **Model B** (see *Figure 2**.1*). The
    machines would make up a set of nominal data where **Model A** and **Model B**
    are the distinct group labels. With nominal data, there is only one operation
    that can be performed: equality. Each member of a group is equal while members
    from different groups are unequal. In our factory example, a **Model A** machine
    would be equal to another **Model A** machine while a **Model B** machine would
    be unequal to a **Model** **A** machine.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 名义数据是对具有不同分组进行标记的数据。例如，考虑一个标志工厂中的机器。工厂通常从不同的供应商那里采购机器，这也会有不同的型号号。例如，示例工厂可能有3台**型号A**和5台**型号B**（见*图2.1*）。机器将构成一组名义数据，其中**型号A**和**型号B**是不同的分组标签。对于名义数据，只有一个操作可以执行：相等。组内的每个成员都是相等的，而来自不同组的成员是不相等的。在我们的工厂示例中，一台**型号A**机器将等于另一台**型号A**机器，而一台**型号B**机器将不等于一台**型号A**机器。
- en: '![Figure 2.1 – Two groups of machines in a factory](img/B18945_02_001.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 工厂中的两组机器](img/B18945_02_001.jpg)'
- en: Figure 2.1 – Two groups of machines in a factory
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 工厂中的两组机器
- en: 'As we can see, with this type of data, we can only group items together under
    labels. With the next type of data, we will introduce a new feature: order.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用这种类型的数据，我们只能在标签下将项目分组。在下一类型的数据中，我们将介绍一个新特性：顺序。
- en: Ordinal data
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序数数据
- en: 'The next type of data is like nominal data but exhibits an order. The data
    can be labeled into distinct groups and the groups can be ordered. We call this
    type of data ordinal data. Continuing with the factory example, let’s suppose
    that there is a **Model C** machine, and **Model C** is supplied by the same vendor
    as **Model B**. However, **Model C** is the high-performance version, which generates
    higher output. In this case, **Model B** and **Model C** are ordinal data because
    **Model B** is a lower-output machine, and **Model C** is a higher-output machine,
    which creates a natural order. For instance, we can put the model labels in ascending
    order of performance: **Model B**, **Model C**. University education levels are
    another example of ordinal data with the levels BS, MS, and PhD. As mentioned,
    the new operation for this type of data is ordering, meaning the data can be sorted.
    Thus, ordinal data supports order and equality. While this type of data can be
    ordered in ascending or descending order, we cannot add or subtract the data,
    meaning **Model B** + **Model C** is not a meaningful statement. The next type
    of data we will discuss will support addition and subtraction.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种类型的数据类似于名义数据，但表现出顺序。数据可以被标记成不同的组，并且这些组可以排序。我们称这种类型的数据为序数数据。继续以工厂为例，假设有一个**Model
    C**型号的机器，**Model C**与**Model B**由相同的供应商提供。然而，**Model C**是高性能版本，产生更高的输出。在这种情况下，**Model
    B**和**Model C**是序数数据，因为**Model B**是低输出机器，而**Model C**是高输出机器，这创造了一个自然顺序。例如，我们可以按性能的升序排列模型标签：**Model
    B**，**Model C**。大学教育水平也是序数数据的另一个例子，有BS、MS和PhD等级。如前所述，这种类型数据的新操作是排序，意味着数据可以被排序。因此，序数数据支持排序和相等性。虽然这种类型的数据可以按升序或降序排序，但我们不能对数据进行加减运算，这意味着**Model
    B** + **Model C**不是一个有意义的陈述。我们将讨论的下一类型数据将支持加减运算。
- en: Interval data
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区间数据
- en: The next type of data, interval data, is used to describe data that exists on
    an interval scale but does not have a clear definition of zero. This means the
    difference between two data points is meaningful. Take the Celsius temperature
    scale, for example. The data points are numeric, and the data points are evenly
    spaced at an interval (for example, 20 and 40 are both 10 degrees away from 30).
    In this example of the temperature scale, the definition of 0 is arbitrary. For
    Celsius, 0 happens to be set at water’s freezing point, but this is an arbitrary
    choice made by the designers of the scale. So, the interval data type supports
    equality, ordering, and addition/subtraction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种类型的数据，区间数据，用于描述存在于区间尺度上的数据，但没有明确的零点定义。这意味着两个数据点之间的差异是有意义的。以摄氏温度尺度为例。数据点是数值的，并且数据点在区间内均匀分布（例如，20和40都距离30有10度）。在这个温度尺度的例子中，0的定义是任意的。对于摄氏度来说，0恰好被设定在水的冰点，但这是尺度设计者做出的一个任意选择。因此，区间数据类型支持相等性、排序和加减运算。
- en: Ratio data
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比例数据
- en: The final data type is ratio data. Like interval data, ratio data is ordered
    numeric data, but unlike interval data, ratio data has an absolute 0\. Absolute
    0 means that if the value of a ratio-type variable is zero, none of that variable
    exists or is present. For example, consider wait times for rides at an amusement
    park. If no one is in line for the ride, the wait time is 0; new guests can ride
    the amusement ride immediately. There is no meaningful negative measurement for
    wait times. A wait time of 0 is the absolute minimum value. Ratio data also supports
    meaningful multiplication/division, making ratio data the type of data with the
    most supported operations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种数据类型是比例数据。与区间数据一样，比例数据是有序的数值数据，但与区间数据不同，比例数据有一个绝对零点。绝对零点意味着如果一个比例类型变量的值为零，那么该变量不存在或不存在。例如，考虑游乐园的等待时间。如果没有人在等待游乐设施，等待时间就是0；新客人可以立即乘坐游乐设施。等待时间没有有意义的负值。0是绝对最小值。比例数据也支持有意义的乘除运算，这使得比例数据成为支持操作最多的数据类型。
- en: Visualizing data types
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型的可视化
- en: Data visualization is a critical step for understanding distributions and identifying
    properties of data. In this chapter (and throughout this book), we will utilize
    `matplotlib` for visualizing data. While other Python libraries can be used for
    visualizing data, `matplotlib` is the de facto standard plotting library for Python.
    In this section, we will begin using `matplotlib` to visualize the four types
    of data discussed previously.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化是理解分布和识别数据属性的关键步骤。在本章（以及整本书中），我们将使用`matplotlib`来可视化数据。虽然可以使用其他Python库进行数据可视化，但`matplotlib`是Python事实上的标准绘图库。在本节中，我们将开始使用`matplotlib`来可视化之前讨论的四种类型的数据。
- en: Plotting qualitative data types
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制定性数据类型
- en: Since the first two types of data are categorical, we will use a bar chart to
    visualize these distributions of data. Example bar charts are shown in *Figure
    2**.2*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两种数据类型是分类的，我们将使用柱状图来可视化这些数据的分布。示例柱状图显示在图2.2中。
- en: '![Figure 2.2 – Nominal data in a bar chart (left) and ordinal data in a bar
    chart (right)](img/B18945_02_002.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 柱状图中的名义数据（左侧）和有序数据（右侧）](img/B18945_02_002.jpg)'
- en: Figure 2.2 – Nominal data in a bar chart (left) and ordinal data in a bar chart
    (right)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 柱状图中的名义数据（左侧）和有序数据（右侧）
- en: The left bar chart in *Figure 2**.2* shows the distribution of the **Model A**
    machines and **Model B** machines given in the factory example. The right bar
    chart shows an example distribution of the education levels of a team of engineers.
    Note that in the education level bar chart, the *x*-axis labels are ordered from
    the lowest level of education to the highest level of education.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2左侧的柱状图显示了工厂示例中给出的**模型A**机器和**模型B**机器的分布。右侧的柱状图显示了工程师团队的教育水平分布示例。请注意，在教育水平柱状图中，*x*轴标签按教育水平从低到高排序。
- en: The code used to generate *Figure 2**.2* is shown next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 生成图2.2所使用的代码如下所示。
- en: The code has three main parts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有三个主要部分。
- en: '**The** **library imports**:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库导入**：'
- en: In this case, we are only importing `pyplot` from `matplotlib`, which is canonically
    imported as `plt`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只从`matplotlib`中导入`pyplot`，它通常以`plt`的形式导入。
- en: '**The code for** **data creation**:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建数据的代码**：'
- en: 'After the `import` statement, there are a few statements to create the data
    we will plot. The data for the first plot is stored in two Python lists: `label`
    and `counts`, which contain the machine labels and the number of machines, respectively.
    It’s worth noting that each of these two lists contains the same number of elements
    (two elements). The education data is stored similarly. While in this example,
    we are using simple example data, in later chapters, we will have additional steps
    for retrieving and formatting data.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`import`语句之后，有一些语句用于创建我们将要绘制的图形所需的数据。第一个图形的数据存储在两个Python列表中：`label`和`counts`，分别包含机器标签和机器数量。值得注意的是，这两个列表包含相同数量的元素（两个元素）。教育数据以类似的方式存储。虽然在这个例子中，我们使用的是简单的示例数据，但在后面的章节中，我们将有额外的步骤来检索和格式化数据。
- en: '**The code for plotting** **the data**:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘制数据的代码**：'
- en: 'The final step is plotting the data. Since we are plotting two sets of data
    in this example, we use the `subplots` method, which will create a grid of plots.
    The first two arguments to `subplots` are the number of rows and the number of
    columns for the grid of figures. In our case, the number of rows is `1` and the
    number of columns is `2`. The `subplots` method returns two objects; the figure,
    `fig`, and the axes, `ax`. The first returned object, `fig`, has high-level controls
    over the figure, such as saving the figure, showing the figure in a new window,
    and many others. The second object, `ax`, will either be an individual axis object
    or an array of axis objects. In our case, `ax` is an array of axes objects – since
    our grid has two plots, indexing into `ax` gives us the axes object. We use the
    `bar` method of an axes object to create a bar chart. The `bar` method has two
    required arguments. The first required argument is the list of labels. The second
    argument is the bar heights that correspond to each label, which is why the two
    lists must have the same length. The other three methods, `set_title`, `set_ylabel`,
    and `set_xlabel`, set the values for the corresponding plot attributes: `title`,
    `ylabel`, and `x-label`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是绘制数据。由于在这个例子中我们要绘制两组数据，我们使用 `subplots` 方法，这将创建一个图表网格。`subplots` 方法的两个参数是网格中图表的行数和列数。在我们的情况下，行数是
    `1`，列数是 `2`。`subplots` 方法返回两个对象；图，`fig`，和坐标轴，`ax`。返回的第一个对象，`fig`，对图有高级控制，例如保存图、在新窗口中显示图等。第二个对象，`ax`，将是一个单独的坐标轴对象或坐标轴对象的数组。在我们的情况下，`ax`
    是坐标轴对象的数组——因为我们的网格有两个图表，对 `ax` 进行索引给我们坐标轴对象。我们使用坐标轴对象的 `bar` 方法创建柱状图。`bar` 方法有两个必需的参数。第一个必需的参数是标签列表。第二个参数是与每个标签对应的柱高，这就是为什么两个列表必须有相同长度。其他三个方法，`set_title`、`set_ylabel`
    和 `set_xlabel`，设置相应图表属性的值：`title`、`ylabel` 和 `x-label`。
- en: 'Finally, the figure is created using `fig.show()`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `fig.show()` 创建图：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now let’s look at how to plot data from the other two data types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看如何绘制其他两种数据类型的数据。
- en: Plotting quantitative data types
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制定量数据类型
- en: Since the last two data types are numeric, we will use a histogram to visualize
    the distributions. Two example histograms are shown in *Figure 2**.3*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最后两种数据类型是数值型的，我们将使用直方图来可视化分布。*图 2.3* 中显示了两个示例直方图。
- en: '![Figure 2.3 – Nominal data in a bar chart (left) and ordinal data in a bar
    chart (right)](img/B18945_02_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 柱状图中的名义数据（左侧）和有序数据（右侧）](img/B18945_02_003.jpg)'
- en: Figure 2.3 – Nominal data in a bar chart (left) and ordinal data in a bar chart
    (right)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 柱状图中的名义数据（左侧）和有序数据（右侧）
- en: The left histogram is synthetic wait time data (ratio data) that might represent
    wait times at an amusement park. The right histogram is temperature data (interval
    data) for the Dallas-Fort Worth area during April and May of 2022 (pulled from
    [https://www.iweathernet.com/texas-dfw-weather-records](https://www.iweathernet.com/texas-dfw-weather-records)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的直方图是合成等待时间数据（比率数据），可能代表游乐园的等待时间。右侧的直方图是 2022 年 4 月和 5 月达拉斯-沃斯堡地区的温度数据（来自
    [https://www.iweathernet.com/texas-dfw-weather-records](https://www.iweathernet.com/texas-dfw-weather-records))。
- en: The code used to generate *Figure 2**.3* is shown next. Again, the code has
    three main parts, the library imports, the code for data creation, and the code
    for plotting the data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 *图 2.3* 所使用的代码如下。同样，代码有三个主要部分，库导入、数据创建代码和绘图代码。
- en: Like in the previous example, `matplotlib` is imported as `plt`. In this example,
    we also import a function from `scipy`; however, this function is only used for
    generating sample data to work with and we will not discuss it at length here.
    For our purposes, just think of `skewnorm` as producing an array of numbers. This
    code block is very similar to the previous code block.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，`matplotlib` 被导入为 `plt`。在这个例子中，我们还从 `scipy` 中导入了一个函数；然而，这个函数仅用于生成用于工作的样本数据，我们不会在这里详细讨论它。对于我们的目的，只需将
    `skewnorm` 视为一个生成数字数组的函数即可。这个代码块与前面的代码块非常相似。
- en: 'The main difference is the method used for plotting the data, `hist`, which
    creates a histogram. The `hist` method has one required argument, which is the
    sequence of numbers to plot in the histogram. The second argument used in this
    example is `bins`, which effectively controls the granularity of the histogram
    – granularity increases with more bins. The bin count of a histogram can be adjusted
    for the desired visual effect and is generally set experimentally for the data
    plotted:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于用于绘制数据的图表方法，`hist`，它创建直方图。`hist`方法有一个必需的参数，即要在直方图中绘制的数字序列。本例中使用的第二个参数是`bins`，它实际上控制了直方图的粒度
    – 粒度随着更多的bins而增加。直方图的bin计数可以根据所需的视觉效果进行调整，通常通过实验设置来绘制数据：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this section, we had a glimpse into how varied data and distributions can
    appear. Since distributions of data appear in many shapes and sizes in the wild,
    it is useful to have methods for describing distributions. In the next section,
    we will discuss the measurements available for distributions, how those measurements
    are performed, and the types of data that can be measured.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要了解了数据和分布的多样性。由于数据分布在外部世界中以许多形状和大小出现，因此拥有描述分布的方法是有用的。在下一节中，我们将讨论可用于分布的测量方法，这些测量的执行方式以及可以测量的数据类型。
- en: Measuring and describing distributions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量和描述分布
- en: 'The distributions of data found in the wild come in many shapes and sizes.
    This section will discuss how distributions are measured and which measurements
    apply to the four types of data. These measurements will provide methods to compare
    and contrast different distributions. The measurements discussed in this section
    can be broken into the following categories:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外发现的数据分布形状和大小各异。本节将讨论如何测量分布以及哪些测量适用于四种类型的数据。这些测量将提供比较和对比不同分布的方法。本节讨论的测量可以划分为以下类别：
- en: Central tendency
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心趋势
- en: Variability
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异性
- en: Shape
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状
- en: These measurements are called **descriptive statistics**. The descriptive statistics
    discussed in this section are commonly used in statistical summaries of data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测量被称为**描述性统计**。本节中讨论的描述性统计在数据统计摘要中常用。
- en: Measuring central tendency
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量中心趋势
- en: 'There are three types of measurement of central tendency:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 中心趋势的测量有三种类型：
- en: Mode
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: Median
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中位数
- en: Mean
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值
- en: Let’s discuss each one of them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论它们。
- en: Mode
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式
- en: The first measurement of central tendency we will discuss is the mode. The mode
    of a dataset is simply the most commonly occurring instance. Using the machines
    in the factory as an example (see *Figure 2**.1*), the mode of the dataset would
    be model B. In the example, there are 3 of model A and 5 of model B, therefore,
    making model B the most common – the mode.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论的中心趋势测量是模式。数据集的模式简单地说是最常见的实例。以工厂中的机器为例（见*图2.1*），数据集的模式将是型号B。在例子中，有3台型号A和5台型号B，因此，使型号B成为最常见的
    – 模式。
- en: 'A dataset can be one of the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以是以下之一：
- en: Unimodal – having one mode
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单模态 – 具有一个模式
- en: Multimodal – having more than one mode
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多模态 – 具有多个模式
- en: In the preceding example, the data is unimodal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，数据是单模态的。
- en: 'Using the factory example again, let’s imagine that there are 3 of **Model
    A**, 5 of **Model B**, and 5 of **Model D** (a new model). Then, the dataset will
    have two modes: **Model B** and **Model D**, as shown in *Figure 2**.4*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用工厂的例子，让我们想象有3台**型号A**，5台**型号B**和5台**型号D**（一种新型号）。那么，数据集将有两个模式：**型号B**和**型号D**，如图*图2.4*所示。
- en: '![Figure 2.4 – Multimodel distribution of machines in a factory](img/B18945_02_004.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 工厂中机器的多模态分布](img/B18945_02_004.jpg)'
- en: Figure 2.4 – Multimodel distribution of machines in a factory
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 工厂中机器的多模态分布
- en: Therefore, this dataset is multimodal.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个数据集是多模态的。
- en: Mode and Data Types
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 模式和数据类型
- en: These examples of modes have used nominal data, but all four types of data support
    the mode because all four data types support the equality operation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式的例子使用了名义数据，但所有四种数据类型都支持模式，因为所有四种数据类型都支持等价操作。
- en: While the mode refers to the most common instance, in multimodal cases of continuous
    data, the term mode is often used in a less strict sense. For example, the distribution
    in *Figure 2**.5* would commonly be referred to as multimodal even though the
    peaks of the distribution are not the same magnitude. However, with nominal and
    ordinal data, it is more common to use the stricter definition of *most common*
    when referring to the modality of a distribution.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“众数”指的是最常见的实例，但在连续数据的多个峰值的多元情况下，术语“众数”通常被用来表示一个不那么严格的概念。例如，*图 2.5* 中的分布通常被称为多峰分布，尽管分布的峰值大小并不相同。然而，在名义数据和有序数据中，当提到分布的模态时，更常见的是使用更严格的“最常见”的定义。
- en: '![Figure 2.5 – A multimodal distribution of data](img/image_00_005.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 数据的多峰分布](img/image_00_005.jpg)'
- en: Figure 2.5 – A multimodal distribution of data
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 数据的多峰分布
- en: 'Now, we will look at how to calculate the mode with code using `scipy`. The
    `scipy` library contains functions for calculating descriptive statistics in the
    `stats` module. In this example, we import `mode` from `scipy.stats` and calculate
    the mode of the following numbers, `1, 2, 3, 4, 4, 4,` `5, 5`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何使用 `scipy` 代码计算众数。`scipy` 库包含 `stats` 模块中的描述性统计函数。在这个例子中，我们从 `scipy.stats`
    导入 `mode` 并计算以下数字的众数，`1, 2, 3, 4, 4, 4, 5, 5`：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `mode` function returns a `mode` object containing `mode` and `count` members.
    Unsurprisingly, the `mode` and `count` members contain the modes of the dataset
    and the number of times the modes appear, respectively. Note that `mode` and `count`
    members are indexable (like lists) because a dataset can contain multiple modes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode` 函数返回一个包含 `mode` 和 `count` 成员的 `mode` 对象。不出所料，`mode` 和 `count` 成员分别包含数据集的众数和众数出现的次数。请注意，`mode`
    和 `count` 成员是可索引的（就像列表一样），因为数据集可以包含多个众数。'
- en: Median
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中位数
- en: The next measure of the center is the median. The median is the middle value
    occurring when the values are arranged in an order.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 中心测量的下一个指标是中位数。中位数是在将数值按顺序排列时出现的中间值。
- en: Median and Data Types
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数和数据类型
- en: This measure can be performed on ordinal data, interval data, and ratio data,
    but not on nominal data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测量可以在有序数据、区间数据和比率数据上执行，但不能在名义数据上执行。
- en: We will discuss two cases here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论两种情况。
- en: Finding the median when the number of instances is odd
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当实例数量为奇数时寻找中位数
- en: Finding the median of some numeric data is shown in *Figure 2**.6*. The data
    is sorted, then the median is identified.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 2.6* 中显示了某些数值数据的中位数。数据被排序后，中位数被识别。
- en: '![Figure 2.6 – Identifying the median with an odd number of instances](img/B18945_02_006.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 使用奇数个实例识别中位数](img/B18945_02_006.jpg)'
- en: Figure 2.6 – Identifying the median with an odd number of instances
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 使用奇数个实例识别中位数
- en: In the preceding example, the instances are odd in number (7 instances), which
    have a center value. However, if the number of instances had been even, it would
    not have been possible to just take the middle number after sorting the values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，实例数量为奇数（7个实例），有一个中心值。然而，如果实例数量是偶数，在排序值之后，就不能简单地取中间的数字了。
- en: Finding the median when the number of instances is even
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当实例数量为偶数时寻找中位数
- en: When there are an even number of instances, the average of the two middle-most
    values is taken. Unlike the mode, there is no concept of multiple medians for
    the same series of data. An example with an even number of instances (8 instances)
    is shown in *Figure 2**.7*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例数量为偶数时，取两个中间值的最小值。与众数不同，对于同一系列数据，没有多个中位数的概念。一个具有偶数个实例（8个实例）的例子在 *图 2.7* 中显示。
- en: '![Figure 2.7 – Identifying the median with an even number of instances](img/B18945_02_007.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 使用偶数个实例识别中位数](img/B18945_02_007.jpg)'
- en: Figure 2.7 – Identifying the median with an even number of instances
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 使用偶数个实例识别中位数
- en: 'Now, let’s see how to calculate the median of a dataset with `numpy`. Like
    `scipy`, `numpy` contains functions for calculating descriptive statistics. We
    will calculate the median for the eight numbers listed in the preceding example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `numpy` 计算数据集的中位数。与 `scipy` 一样，`numpy` 包含用于计算描述性统计的函数。我们将计算前面例子中列出的八个数字的中位数：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result of the median calculation is 87, as expected. Note that the `median`
    function returns a single value, in contrast to the `mode` function in the previous
    code example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中位数的结果是 87，正如预期的那样。请注意，`median` 函数返回一个单一值，与前面代码示例中的 `mode` 函数不同。
- en: Mean
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平均值
- en: 'The next center measure is the mean, which is commonly referred to as the average.
    The mean is defined by the following equation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个中心度量是均值，通常被称为平均值。均值由以下方程定义：
- en: _ x  =  ∑ i=0 n  x i _ N
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: _ x  =  ∑ i=0 n  x i _ N
- en: Let me explain the equation in words. To calculate the mean, we must add all
    the values together, then divide the sum by the number of values. Please refer
    to the following example. The 7 numbers are first added together, which brings
    the total sum to 593\. This sum is then divided by the number of instances, resulting
    in a value of 84.7.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我用文字解释一下这个方程。要计算均值，我们必须将所有值相加，然后将总和除以值的数量。请参考以下示例。首先将7个数字相加，总和达到593。然后将这个总和除以实例数量，得到84.7的值。
- en: '![Figure 2.8 – Finding the mean](img/B18945_02_008.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 寻找均值](img/B18945_02_008.jpg)'
- en: Figure 2.8 – Finding the mean
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 寻找均值
- en: Note that the mean and the median of these values (84.7 and 86, respectively)
    are not the same value. In general, the mean and median will not be the same value,
    but there are special cases where the mean and median will converge.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些值的均值和中位数（分别为84.7和86）并不相同。一般来说，均值和中位数不会是相同的值，但存在一些特殊情况，均值和中位数会收敛。
- en: Mean and Data Types
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 均值和数据类型
- en: As for the supported data types, the mean is valid for interval and ratio data
    since the values are added together.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 至于支持的数据类型，均值适用于区间和比率数据，因为值是可以相加的。
- en: 'Now, we will look at how to calculate the mean with `numpy`. The following
    code example shows the calculation of the mean for the values in the previous
    example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何使用`numpy`计算均值。以下代码示例显示了之前示例中值的均值的计算：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Like the `median` function, the `mean` function returns a single number.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与`median`函数一样，`mean`函数返回一个单一的数字。
- en: Before concluding this section on center measures, it is worth discussing the
    use of the mean and median in various situations. As mentioned previously, the
    median and mean will, in general, be different values. This is an effect driven
    by the shape of the distribution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束关于中心度量的这一节之前，讨论均值和中位数在各种情况下的使用是值得的。如前所述，中位数和均值通常会是不同的值。这是由分布的形状驱动的效应。
- en: Shape impacts on Mean and Median
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 形状对均值和中位数的影响
- en: If the distribution is symmetric, the mean and median will tend to converge.
    However, if the distribution is not symmetric, the mean and median will diverge.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分布是对称的，均值和中位数往往会收敛。然而，如果分布不是对称的，均值和中位数会发散。
- en: The degree to which the measures diverge is driven by how asymmetric the distribution
    is. Four example distributions are given in *Figure 2**.6* to show this effect.
    Distributions 1 and 2 show the mean pulled toward a higher value than the median.
    The mean is pulled toward values with a larger absolute value. This is an important
    effect of the mean to be aware of when a dataset contains (or may contain) **outlier
    values** (often called outliers or influential points), which will tend to pull
    the mean in their direction. Unlike the mean, the median is not affected by outliers
    if outliers account for a smaller percentage of the data. Outliers will be discussed
    further in the *Measuring* *variability* section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 度量之间的差异程度由分布的不对称性驱动。*图2.6*给出了四个示例分布来展示这一效果。分布1和2显示均值被拉向比中位数更高的值。均值会被拉向绝对值更大的值。当数据集包含（或可能包含）**异常值**（通常称为异常值或影响点）时，这是一个均值的重要影响，这些异常值会倾向于将其拉向它们的方向。与均值不同，如果异常值占数据比例较小，中位数不会受到异常值的影响。异常值将在*测量变异性*部分进一步讨论。
- en: '![Figure 2.9 – Two asymmetric distributions and two symmetric distributions](img/B18945_02_009.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 两个不对称分布和两个对称分布](img/B18945_02_009.jpg)'
- en: Figure 2.9 – Two asymmetric distributions and two symmetric distributions
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 两个不对称分布和两个对称分布
- en: The next category of measurements for distributions is measures of variability.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 分布的下一个测量类别是变异性度量。
- en: Measuring variability
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量变异性
- en: 'By variability, we essentially mean how wide a distribution is. The measurements
    in this category are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过变异性，我们本质上是指分布的宽度。这一类别的测量如下：
- en: Range
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: Quartile ranges
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四分位距
- en: Tukey fences
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tukey fences
- en: Variance
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方差
- en: Let’s discuss each of them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每一个。
- en: Range
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围
- en: The range is simply the difference between the maximum value and the minimum
    value in the distribution. Like the mean, the range will be affected by outliers
    since it depends on the max and min values. However, there is another variability
    method that, like the median, is robust to the presence of outliers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是分布中最大值和最小值之间的差值。像均值一样，范围会受到异常值的影响，因为它依赖于最大值和最小值。然而，还有一种变异方法，就像中位数一样，对异常值的存在具有鲁棒性。
- en: 'Let’s take a look at calculating a range with code with `numpy`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用代码和 `numpy` 来计算一个范围：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While `numpy` does not have a range function, the range can be calculated using
    the `min` and `max` functions provided by `numpy`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `numpy` 没有范围函数，但可以使用 `numpy` 提供的 `min` 和 `max` 函数来计算范围。
- en: Quartile ranges
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四分位距
- en: 'The next measures of variability are determined by sorting the data and then
    dividing the data into four equal sections. The boundaries of the four sections
    are the quartiles, which are called the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变异度量是通过排序数据然后将数据分成四个相等的部分来确定的。四个部分的边界是四分位数，它们被称为以下：
- en: The lower quartile (Q1)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下四分位数（Q1）
- en: The middle quartile (Q2)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间四分位数（Q2）
- en: The upper quartile (Q3)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上四分位数（Q3）
- en: An example of quartiles is shown as follows. Like the median, quartiles are
    robust to outliers so long as the outliers are a small percentage of the dataset.
    Note that the middle quartile is, in fact, the median. An adjusted range measurement
    that is less sensitive to outliers than the normal range discussed in the *Range*
    section is the middle quartile, the **interquartile range** (**IQR**). The IQR
    is the difference between the upper and lower quartiles (Q3 - Q1). While this
    range is less sensitive to outliers, it only contains 50% of the data. Thus, making
    the interquartile range likely to be *less representative of the total variation*
    of the data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个四分位数的例子。像中位数一样，只要异常值占数据集的比例很小，四分位数对异常值就具有鲁棒性。请注意，中间四分位数实际上就是中位数。一种对异常值比
    *范围* 部分中讨论的正常范围更不敏感的调整范围测量方法是中间四分位数，即 **四分位距**（**IQR**）。IQR 是上四分位数（Q3）和下四分位数（Q1）之间的差值。虽然这个范围对异常值不太敏感，但它只包含
    50% 的数据。因此，四分位距很可能是不太能代表数据总变异的。
- en: '![Figure 2.10 – Q1, Q2, and Q3](img/B18945_02_010.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – Q1, Q2 和 Q3](img/B18945_02_010.jpg)'
- en: Figure 2.10 – Q1, Q2, and Q3
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – Q1, Q2 和 Q3
- en: 'We can calculate the quartiles and IQR range using `numpy` and `scipy`. In
    the following code example, we use the `quantiles` function to calculate the quartiles.
    We will not discuss `quantiles` here, other than to mention that `quantiles` are
    a generalization where the data can be split into any number of equal parts. Since
    we are splitting the data into four equal parts for quartiles, the `quantiles`
    values used for the calculation are 0.25, 0.5, and 0.75\. Quartiles Q1 and Q3
    could then be used to calculate the IQR. However, we could also use the `iqr`
    function from `scipy` to make the calculation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `numpy` 和 `scipy` 来计算四分位数和 IQR 范围。在下面的代码示例中，我们使用 `quantiles` 函数来计算四分位数。我们在这里不会讨论
    `quantiles`，除了提到 `quantiles` 是一种泛化，其中数据可以被分成任何数量的相等部分。由于我们是将数据分成四个相等的部分来计算四分位数，所以用于计算的
    `quantiles` 值是 0.25、0.5 和 0.75。然后可以使用 Q1 和 Q3 来计算 IQR。但是，我们也可以使用 `scipy` 中的 `iqr`
    函数来进行计算：
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the use of the `method` and `interpolation` keyword arguments in the `quantiles`
    function and the `iqr` function, respectively. Several options can be used for
    these keyword arguments, which will lead to different results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `quantiles` 函数和 `iqr` 函数中 `method` 和 `interpolation` 关键字参数的使用。可以对这些关键字参数使用几种选项，这将导致不同的结果。
- en: 'Quartiles are often visualized with a boxplot. The following *Figure 2**.11*
    shows the main parts of a boxplot. A boxplot is made up of two main parts:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 四分位数通常用箱线图来可视化。以下 *图 2**.11 展示了箱线图的主要部分。箱线图由两个主要部分组成：
- en: The box
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱体
- en: The whiskers
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 须线
- en: The box part represents 50% of the data that is contained by the IQR. The whiskers
    are drawn starting from the edge of the boxes to a length of k * IQR, where k
    is commonly chosen to be 1.5\. Any values beyond the whiskers are considered outliers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 箱体部分代表包含在 IQR 内的 50% 的数据。须线从箱体的边缘延伸到长度为 k * IQR，其中 k 通常选择为 1.5。任何超出须线的值都被认为是异常值。
- en: '![Figure 2.11 – Parts of a box and whisker plot](img/B18945_02_011.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 箱线和须图的部分](img/B18945_02_011.jpg)'
- en: Figure 2.11 – Parts of a box and whisker plot
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 箱线和须图的部分
- en: '*Figure 2**.12* shows how histograms and boxplots visualize the variability
    of a symmetric and asymmetric distribution. Notice how the boxplot of the asymmetric
    data is compressed on the left and expanded on the right, while the other boxplot
    is clearly symmetric. While a boxplot is useful for visualizing the symmetry of
    the data and the presence of outliers, the modality of the distribution would
    not be evident.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.12*展示了直方图和箱线图如何可视化对称和非对称分布的变异。注意非对称数据的箱线图在左侧被压缩，在右侧被扩展，而另一个箱线图则明显对称。虽然箱线图有助于可视化数据的对称性和异常值的存在，但分布的模态可能不会明显。'
- en: '![Figure 2.12 – Comparison of boxplots and histograms for asymmetric and symmetric
    distributions](img/B18945_02_012.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 对称和非对称分布的箱线图和直方图比较](img/B18945_02_012.jpg)'
- en: Figure 2.12 – Comparison of boxplots and histograms for asymmetric and symmetric
    distributions
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 对称和非对称分布的箱线图和直方图比较
- en: When exploring, it is common to use multiple visualizations since each type
    of visualization has its own advantages and disadvantages. It is common to use
    multiple visualizations since each type of visualization has its own advantages
    and disadvantages.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索时，通常使用多种可视化方式，因为每种类型的可视化都有其自身的优势和劣势。通常使用多种可视化方式，因为每种类型的可视化都有其自身的优势和劣势。
- en: Tukey fences
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tukey fences
- en: 'In the last few sections on measurements, the concept of outliers has appeared
    a few times. Outliers are values that are atypical compared to the main distribution,
    or anomalous values. While there are methods for classifying data points as outliers,
    there is no generally robust method for classifying data points as outliers. Defining
    outliers typically should be informed by the use case of the data analysis, as
    there will be different factors to consider based on the application domain. However,
    it is worth mentioning the common technique shown in the boxplot example called
    Tukey fences. The lower and upper Tukey fences are based on the IQR and defined
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几节关于测量的内容中，异常值的概念出现了几次。异常值是与主要分布相比不典型或异常的值。虽然有一些方法可以将数据点分类为异常值，但没有一种通用的方法可以用来分类数据点为异常值。定义异常值通常应该根据数据分析的使用情况进行，因为根据应用领域会有不同的因素需要考虑。然而，值得提及的是，在箱线图示例中展示的常见技术，称为Tukey
    fences。下限和上限Tukey fences基于四分位数间距（IQR）并定义如下：
- en: 'Lower fence : Q1 − k(IQR)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下限围栏：Q1 − k(IQR)
- en: 'Upper fence : Q3 + k(IQR)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上限围栏：Q3 + k(IQR)
- en: As mentioned earlier, k is often chosen to be 1.5 as a default value, but there
    may be a more appropriate value for a given application domain.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，k通常被选为默认值1.5，但针对特定应用领域可能有一个更合适的值。
- en: 'Now let’s take a look at how to calculate Tukey fences with `numpy` and `scipy`.
    This code example will build upon the previous example since there is no function
    to calculate the fences directly. We will again calculate the quartiles and the
    IQR with `numpy` and `scipy`. Then, we apply these operations to the values listed
    in the preceding equations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如何使用`numpy`和`scipy`计算Tukey fences。这个代码示例将基于前面的示例，因为没有直接计算围栏的函数。我们再次使用`numpy`和`scipy`计算四分位数和四分位数间距（IQR）。然后，我们将这些操作应用于前面方程中列出的值：
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, we used both `numpy` and `scipy`; however, the `scipy` calculation
    could be replaced with `Q3-Q1` as mentioned previously.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`numpy`和`scipy`；然而，如前所述，`scipy`的计算可以用`Q3-Q1`来替换。
- en: Variance
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方差
- en: 'The last measure of variability that will be covered in this section is variance.
    Variance is a measure of dispersion that can be understood as how *spread out*
    the numbers are from the average value. The formula for variance, denoted S 2,
    is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中将要介绍的最后一个变异度量是方差。方差是衡量离散程度的度量，可以理解为数值与平均值之间的*分散程度*。方差的公式，用S 2表示，如下所示：
- en: S 2 =  ∑ (x i −  _ x ) 2 _ N − 1
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: S 2 =  ∑ (x i −  _ x ) 2 _ N − 1
- en: 'In this equation, the term (x i −  _ x ) is considered the deviation from the
    mean, which leads to another measure that is closely related to variance – the
    standard deviation, which is the square root of variance. The formula for standard
    deviation, denoted σ, is given here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，项（x i −  _ x ）被认为是与平均值的偏差，这导致另一个与方差密切相关的度量——标准差，它是方差的平方根。标准差的公式，用σ表示，如下给出：
- en: σ = √ _ S 2  = √ ___________  ∑ (x i −  _ x ) 2 _ N − 1
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: σ = √ _ S 2  = √ ___________  ∑ (x i −  _ x ) 2 _ N − 1
- en: In general, a wider distribution will have a larger variance and a larger standard
    deviation, but these values are not as easy to interpret as a range or IQR. These
    concepts will be covered more in detail in the next section, in the context of
    the normal distribution, which will provide clearer intuition for what these values
    measure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，分布范围越宽，其方差和标准差也会越大，但这些值不如范围或四分位距（IQR）那样容易解释。这些概念将在下一节中更详细地介绍，在正态分布的背景下，这将提供对这些值所测量的更清晰的直观理解。
- en: 'Again, these values will be calculated with code using `numpy`. The functions
    for variance and standard deviation are `var` and `std`, respectively:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这些值将通过代码使用`numpy`进行计算。方差和标准差的函数分别是`var`和`std`：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Measuring shape
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量形状
- en: 'The next type of measure has to do with the shapes of distributions. They are
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种类型的测量与分布的形状有关。具体如下：
- en: Skewness
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏度
- en: Kurtosis
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏度
- en: Let’s discuss each of them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论它们。
- en: Skewness
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏度
- en: The first measurement is skewness. Put simply, skewness is measurement asymmetry
    [*1*]. An example of skewed distributions is shown in *Figure 2**.13*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项测量是偏度。简单来说，偏度是测量不对称性[*1*]。*图2.13*展示了偏斜分布的例子。
- en: 'There are two types of skewed distributions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种类型的偏斜分布：
- en: Left-skewed
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左偏斜
- en: Right-skewed
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右偏斜
- en: A distribution is skewed in the direction of the dominant tail, meaning that
    a distribution with a dominant tail to the right is right-skewed and a distribution
    with a dominant tail to the left is left-skewed (as shown in *Figure 2**.13*).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 分布在主导尾的方向上偏斜，意味着具有右侧主导尾的分布是右偏斜的，而具有左侧主导尾的分布是左偏斜的（如*图2.13*所示）。
- en: '![Figure 2.13 – Distributions demonstrating skewness](img/B18945_02_013.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 展示偏度的分布](img/B18945_02_013.jpg)'
- en: Figure 2.13 – Distributions demonstrating skewness
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 展示偏度的分布
- en: 'The formula for skewness will not be shown here since it can be calculated
    trivially with modern software packages. The output of the skewness calculation
    can be used to determine the skewness and the direction of the skew. If the skewness
    value is 0 or near 0, the distribution does not exhibit strong skewness. If the
    skewness is positive, the distribution is right-skewed, and if the skewness value
    is negative, the distribution is left-skewed. The larger the absolute value of
    the skewness value, the more the distribution exhibits skewness. An example of
    how to calculate skewness with `scipy` is shown in the following code example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代软件包可以轻易计算，因此此处不会展示偏度的公式。偏度计算的结果可以用来确定偏度和偏斜的方向。如果偏度值为0或接近0，则分布没有表现出强烈的偏斜。如果偏度值为正，则分布是右偏斜的；如果偏度值为负，则分布是左偏斜的。偏度值的绝对值越大，分布的偏斜程度越明显。以下代码示例展示了如何使用`scipy`计算偏度：
- en: '[PRE9]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The other shape measurement covered in this section is kurtosis.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中涵盖的另一种形状测量是峰度。
- en: Kurtosis
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏度
- en: Kurtosis is a measurement of how heavy or light the tail of a distribution is
    relative to the normal distribution [*2*]. While the normal distribution has not
    been covered in depth yet, the idea of kurtosis can still be discussed. A light-tailed
    distribution means that more of the data is near or around the mode of the distribution.
    In contrast, a heavy-tailed distribution means that more of the data is at the
    edges of the distribution than near the mode. A light-tailed distribution, a normal
    distribution, and a heavy-tailed distribution are shown in *Figure 2**.14*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 峰度是衡量分布尾部相对于正态分布的轻重程度[*2*]。虽然正态分布尚未深入探讨，但峰度的概念仍然可以讨论。轻尾分布意味着更多的数据接近或围绕分布的众数。相反，重尾分布意味着比接近众数的数据，更多的数据位于分布的边缘。*图2.14*展示了轻尾分布、正态分布和重尾分布。
- en: '![Figure 2.14 – Distributions demonstrating tailedness with reference to a
    normal distribution](img/image_00_014.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 以正态分布为参考的尾部分布](img/image_00_014.jpg)'
- en: Figure 2.14 – Distributions demonstrating tailedness with reference to a normal
    distribution
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.14 – 以正态分布为参考的尾部分布*'
- en: 'The formula for kurtosis will not be shown here since it can be calculated
    trivially with modern software packages. If the kurtosis value is 0 or near 0,
    the distribution does not exhibit kurtosis. If the kurtosis value is negative,
    the distribution exhibits light-tailedness, and if the kurtosis value is positive,
    the distribution exhibits heavy-tailedness. An example of how to calculate kurtosis
    with `scipy` is shown in the following code example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代软件包可以轻易地计算出来，这里将不展示峰度的公式。如果峰度值为0或接近0，则分布不显示峰度。如果峰度值为负，则分布显示轻尾性；如果峰度值为正，则分布显示重尾性。以下代码示例展示了如何使用`scipy`计算峰度：
- en: '[PRE10]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this section, we walked through the common descriptive statistics that are
    used for measuring and describing distributions of data. These measurements provide
    a common language for describing and comparing distributions. The concepts discussed
    in this chapter are fundamental to many of the concepts discussed in future chapters.
    In the next section, we will discuss the normal distribution and describe the
    normal distribution using these measurements.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了用于测量和描述数据分布的常见描述性统计方法。这些测量提供了描述和比较分布的共同语言。本章讨论的概念是未来章节中许多概念的基础。在下一节中，我们将讨论正态分布，并使用这些测量来描述正态分布。
- en: The normal distribution and central limit theorem
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正态分布和中心极限定理
- en: 'When discussing the normal distribution, we refer to the bell-shaped, **standard
    normal distribution**, which is formally synonymous with the **Gaussian distribution**,
    named after Carl Friedrich Gauss, an 18th- and 19th-century mathematician and
    physicist who – among other things – contributed to the concepts of approximation,
    and, in 1795, invented the method of least squares and the normal distribution,
    which is commonly used in statistical modeling techniques, such as least squares
    regression [*3*]. The standard normal distribution, also referred to as a **parametric**
    distribution, is characterized by a symmetrical distribution with a probability
    of data point dispersion consistent around the mean – that is, the data appears
    near the mean more frequently than data farther away. Since the location data
    dispersed within this distribution follows the laws of probability, we can call
    this a **standard normal probability distribution**. As an aside, a distribution
    in statistics that is not a probability distribution is generated through non-probability
    sampling based on non-random selection, whereas a probability distribution is
    based on random sampling. Both probability-based and non-probability-based distributions
    can have a standard normal distribution. The standard normal distribution exhibits
    neither skew nor kurtosis. It has equal variance throughout and frequently occurs
    in nature. The **Empirical Rule** is used to describe this distribution as having
    three pertinent standard deviations centered around the mean, **μ**. There are
    two distinct assumptions about this distribution:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论正态分布时，我们指的是钟形的标准正态分布，它正式同义于**高斯分布**，以18世纪和19世纪的数学家和物理学家卡尔·弗里德里希·高斯的名字命名。高斯在许多方面做出了贡献，包括近似概念，并在1795年发明了最小二乘法和正态分布，这些在统计建模技术（如最小二乘回归）中常用[*3*]。标准正态分布也被称为**参数分布**，其特征是分布对称，数据点分散的概率在均值周围一致——也就是说，数据出现在均值附近比出现在远离均值的频率更高。由于这个分布中的位置数据遵循概率定律，我们可以称之为**标准正态概率分布**。顺便提一下，在统计学中，不是概率分布的分布是通过基于非随机选择的非概率抽样生成的，而概率分布是基于随机抽样生成的。基于概率和非概率的分布都可以有标准正态分布。标准正态分布既不偏斜也不显示峰度。它在整个分布中具有相同的方差，并且在自然界中经常出现。**经验法则**用于描述这个分布具有围绕均值**μ**的三个相关的标准差。关于这个分布有两个不同的假设：
- en: The first, second, and third standard deviations contain 68%, 95%, and 99.7%
    of the measurements dispersed, respectively
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一、第二和第三标准差分别包含68%、95%和99.7%的测量值。
- en: The mean, median, and mode are all equal to each other
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值、中位数和众数都相等
- en: '![Figure 2.15 – The standard normal distribution](img/B18945_02_015.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – 标准正态分布](img/B18945_02_015.jpg)'
- en: Figure 2.15 – The standard normal distribution
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 标准正态分布
- en: 'Two common forms of a normal distribution are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布的两种常见形式如下：
- en: The probability density distribution
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率密度分布
- en: The cumulative density distribution
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累积密度分布
- en: As mentioned before, the probability density distribution is based on random
    sampling, whereas the cumulative density distribution is based on accumulated
    data, which is not necessarily random.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，概率密度分布基于随机抽样，而累积密度分布基于累积数据，这些数据不一定随机。
- en: 'The two-tailed probability density function of the standard normal distribution
    is this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 标准正态分布的双尾概率密度函数如下：
- en: f(x) =  e −(x−μ) 2 _ 2 σ 2  _ σ √ _ 2π
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: f(x) =  e −(x−μ) 2 _ 2 σ 2  _ σ √ _ 2π
- en: 'The left-tailed cumulative function of the standard normal distribution is
    this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 标准正态分布的左尾累积函数如下：
- en: f(x) =  ∫ −∞ x e −x 2 _  2 _ √ _ 2π
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: f(x) =  ∫ −∞ x e −x 2 _  2 _ √ _ 2π
- en: With respect to statistical modeling, the normal distribution represents balance
    and symmetry. This is important when building statistical models as many models
    assume normal distribution and are not robust to many deviations from that assumption,
    as they are built around a mean. Consequently, if variables in such a model are
    not normally distributed, the model’s errors will be increased and inconsistent,
    thus diminishing the model’s stability. When considering multiple variables in
    a statistical model, their interaction is more easily approximated when both are
    normally distributed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计建模方面，正态分布代表着平衡和对称。这在构建统计模型时非常重要，因为许多模型都假设正态分布，并且对许多偏离该假设的情况不稳健，因为它们是围绕平均值构建的。因此，如果此类模型中的变量不是正态分布的，模型的误差将会增加且不一致，从而降低模型稳定性。当考虑统计模型中的多个变量时，如果两者都是正态分布的，它们的相互作用更容易被近似。
- en: In the following *Figure 2**.16*, in the left plot, variables X and Y interact
    with each other and create a centralized dispersion around a mean. In this case,
    modeling Y using X with a mean line or linear distance can be done reasonably
    well. However, if the two variables’ distributions were skewed, as in the plot
    on the right, this would result in non-constant variance between the two, resulting
    in an unequal distribution of errors and unreliable output.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 *图2**.16* 中，左边的图中，变量X和Y相互作用并在平均值周围形成集中分散。在这种情况下，使用X和均值线或线性距离对Y进行建模可以做得相当好。然而，如果两个变量的分布是偏斜的，如右边的图所示，这会导致两个变量之间的方差不是常数，从而导致误差分布不均，输出不可靠。
- en: '![Figure 2.16 – Bivariate normal (left) and skewed (right) distributions](img/B18945_02_16.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16 – 双变量正态分布（左）和偏斜分布（右）](img/B18945_02_16.jpg)'
- en: Figure 2.16 – Bivariate normal (left) and skewed (right) distributions
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – 双变量正态分布（左）和偏斜分布（右）
- en: In the case of linear classification and regression models, this will mean some
    results are better than others while some will likely be very bad. This can be
    difficult to assess at times using basic model metrics and requires deeper model
    analysis to prevent trusting what could end up being misleading results. Furthermore,
    deployment into a production environment would be very risky. More on this will
    be discussed in [*Chapter 6*](B18945_06.xhtml#_idTextAnchor104).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性分类和回归模型的情况下，这意味着一些结果会比其他结果更好，而一些结果可能会非常糟糕。有时使用基本的模型指标很难评估这一点，需要更深入地分析模型以防止相信可能最终会误导的结果。此外，部署到生产环境将非常危险。关于这一点将在
    [*第6章*](B18945_06.xhtml#_idTextAnchor104) 中进一步讨论。
- en: The Central Limit Theorem
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中心极限定理
- en: When sampling data, it is common to encounter the issue of non-normal data.
    This may be for multiple reasons, such as the population not having a normal distribution
    or the sample being misrepresentative of the population. The Central Limit Theorem,
    which is important in statistical inference, postulates that if random samples
    of *n* observations are taken from a population that has a specific mean, μ, and
    **standard deviation**, **σ**, the sampling distribution constructed from the
    means of the randomly selected sub-sample distributions will approximate a normal
    distribution having roughly the same mean, μ, and standard deviation, calculated
    as √ _ ∑ (x i − μ) 2 _ N  , as the population. The next section will use bootstrapping
    to demonstrate the Central Limit Theorem in action. A later section discussing
    transformations will provide techniques for reshaping data distributions that
    do not conform to normal distributions so that tools requiring normal distributions
    can still be effectively applied.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在采样数据时，经常会遇到非正态数据的问题。这可能是由于多个原因造成的，例如总体没有正态分布或者样本不能代表总体。中心极限定理，在统计推断中非常重要，它假设如果从具有特定均值μ和**标准差**σ的总体中随机抽取n个观察值的样本，那么从随机选择的子样本分布的均值构建的抽样分布将接近一个具有大致相同的均值μ和标准差σ的正态分布，计算公式为√ _ ∑
    (x i − μ) 2 _ N  ，与总体相同。下一节将使用自助法来展示中心极限定理的实际应用。在后面的章节中，将讨论变换技术，提供重塑不符合正态分布的数据分布的方法，以便仍然可以有效地应用需要正态分布的工具。
- en: Bootstrapping
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自助法
- en: 'Bootstrapping is a method of resampling that uses random sampling – typically
    with replacement – to generate statistical estimates about a population by resampling
    from subsets of the sampled distribution, such as the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 自助法是一种重采样方法，它使用随机抽样——通常是放回抽样——通过从样本分布的子集中重采样来生成关于总体的统计估计，如下所示：
- en: Confidence intervals
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信区间
- en: Standard error
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准误
- en: Correlation coefficients (Pearson’s correlation)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关系数（皮尔逊相关系数）
- en: The idea is that repeatedly sampling different random subsets of a sample distribution
    and taking the average each time, given enough repeats, will begin to approximate
    the true population using each subsample’s average. This follows directly the
    concept of the Central Limit Theorem, which to be restated, asserts that sampling
    means begins to approximate normal sampling distributions, centered around the
    original distribution’s mean, as sample sizes and counts increase. Bootstrapping
    is useful when a limited quantity of samples exists in a distribution relative
    to the amount needed for a specific test, but inference is needed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，通过重复采样样本分布的不同随机子集并每次取平均值，给定足够的重复次数，将开始使用每个子样本的平均值来近似真实的总体。这直接遵循中心极限定理的概念，即重申，采样均值开始近似围绕原始分布均值的正态采样分布，随着样本量和计数增加。当分布中样本数量相对于特定测试所需的样本量有限时，自助法很有用，但需要进行推断。
- en: As discussed in [*Chapter 1*](B18945_01.xhtml#_idTextAnchor015), *Sampling and
    Generalization*, constraints such as time and expense are common reasons for obtaining
    samples rather than populations. Because the underlying concept of bootstrapping
    is to make assumptions about the population using samples, it is not beneficial
    to apply this technique to populations as the true statistical parameters – such
    as the percentiles and variance – of a population are known. Regarding sample
    preparation, the balance of attributes in the sample should represent the true
    approximation of the population. Otherwise, the results will likely be misleading.
    For example, if the population of species within a zoo is a split of 40% reptiles
    and 60% mammals and we want to bootstrap their longevity to identify the confidence
    intervals for their lifespans, it would be necessary to ensure the dataset to
    which bootstrapping was applied contained a split of 40% reptiles and 60% mammals;
    a split of 15% reptiles and 85% mammals, for example, would lead to misleading
    results. In other words, the sample stratification should be balanced in proportion
    to the population.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第一章*](B18945_01.xhtml#_idTextAnchor015)中所述，*采样与泛化*，时间和费用等限制是获取样本而不是总体的常见原因。因为自助法的基本概念是使用样本对总体进行假设，所以当总体的真实统计参数（如百分位数和方差）已知时，将此技术应用于总体并不有利。至于样本制备，样本中属性的平衡应代表总体的真实近似。否则，结果可能会误导。例如，如果动物园中物种的总体是40%的爬行动物和60%的哺乳动物，而我们想通过自助法来估计它们的寿命并确定其置信区间，那么必须确保应用于自助法的数据集包含40%的爬行动物和60%的哺乳动物的分布；例如，15%的爬行动物和85%的哺乳动物的分布会导致误导性结果。换句话说，样本分层应与总体的比例相平衡。
- en: Confidence intervals
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 置信区间
- en: 'As mentioned before, one useful application of bootstrapping is to create confidence
    intervals around sparsely defined or limited datasets – that is to say, datasets
    with a wide range of values without many samples. Consider an example of bootstrapping
    to perform a hypothesis test using a 95% confidence interval using the `"Duncan"`
    dataset in `statsmodels`, which contains incomes by profession, type, education,
    and prestige. While this is the full dataset, consider this dataset a sample since
    the sampling method is not mentioned and it is not likely to consider all incomes
    for all workers of every profession and type. To obtain the dataset, we first
    load the `matplotlib`, `statsmodels`, `pandas`, and `numpy` libraries. We then
    download the dataset and store it as a `pandas` DataFrame in the `df_duncan` variable.
    Following this, we recode the “`prof"`, `"wc"`, and `"bc"` types as `"professional"`,
    `"white-collar"`, and `"blue collar"`, respectively. Finally, we create two separate
    `pandas` DataFrames; one for professional job types and another for blue-collar
    job types, as these are the two subsets we will analyze using bootstrapping:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，自助法的一个有用应用是围绕稀疏定义或有限的数据集创建置信区间——也就是说，具有广泛值范围但没有许多样本的数据集。考虑一个使用`statsmodels`中的`"Duncan"`数据集进行假设检验的例子，该数据集包含按职业、类型、教育和声望划分的收入。虽然这是一个完整的数据集，但考虑到采样方法未提及，并且不太可能考虑所有职业和类型的所有工人的所有收入，我们可以将此数据集视为样本。为了获取数据集，我们首先加载`matplotlib`、`statsmodels`、`pandas`和`numpy`库。然后我们下载数据集并将其存储在`pandas`
    DataFrame的`df_duncan`变量中。在此之后，我们将“`prof"`、“`wc"`和“`bc"`类型分别重新编码为“`professional"`、“`white-collar"`和“`blue
    collar"`。最后，我们创建了两个独立的`pandas` DataFrame；一个用于专业工作类型，另一个用于蓝领工作类型，因为这是我们打算使用自助法分析的两组子集：
- en: '[PRE11]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Figure 2.17 – Table displaying the first five rows of the statsmodels Duncan
    data](img/B18945_02_017.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17 – 显示statsmodels Duncan数据的前五行表格](img/B18945_02_017.jpg)'
- en: Figure 2.17 – Table displaying the first five rows of the statsmodels Duncan
    data
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – 显示statsmodels Duncan数据的前五行表格
- en: We then build a set of plotting functions, as seen next. In `plot_distributions()`,
    we denote `p=5`, meaning the p-value will be significant at a significance level
    of 0.05 (1.00 - 0.05 = 0.95, hence, 95% confidence). We then divide this value
    by 2 since this will be a two-sided test, meaning we want to know the full interval
    rather than just one bound (discussed in [*Chapter 1*](B18945_01.xhtml#_idTextAnchor015)
    as a representative test statistic). Regarding the plots, we visualize the data
    using histograms (the `hist()` function) in `matplotlib` and then plot the 95%
    sampling confidence intervals using the `axvline()` functions, which we build
    using the `numpy` function `percentile()`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了一组绘图函数，如接下来所示。在 `plot_distributions()` 中，我们表示 `p=5`，这意味着在显著性水平为 0.05（1.00
    - 0.05 = 0.95，因此，95% 置信度）时，p 值将是显著的。然后我们将此值除以 2，因为这将是一个双尾测试，意味着我们想要知道整个区间而不是仅仅一个边界（在
    [*第一章*](B18945_01.xhtml#_idTextAnchor015) 中作为代表性统计量的讨论）。至于绘图，我们使用 `matplotlib`
    中的直方图（`hist()` 函数）可视化数据，然后使用我们用 `numpy` 函数 `percentile()` 构建的 `axvline()` 函数绘制
    95% 的抽样置信区间。
- en: Percentile in Bootstrapping
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 自助抽样中的百分位数
- en: When applied to the original data, the percentile is only that, but when applied
    to the bootstrapped sampling distribution, it is the confidence interval.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于原始数据时，百分位数只是那样，但当应用于自助抽样分布时，它就是置信区间。
- en: 'To state the confidence interval simply, a 95% confidence interval means that
    for every 100 sample means taken, 95 of them will fall within this interval. In
    the `numpy` `percentile()` function, we use `p=5` to support that 1-p is the confidence
    level, where *p* is the level of significance (think *p-value*, where any value
    at or lower than *p* is significant). Since the test is two-tailed, we divide
    *p* by 2 and split 2.5 in the left tail and 2.5 in the right since we have a symmetrical,
    standard normal distribution. The `subplot(2,1,...)` code creates two rows and
    one column. Axis 0 of the figure is used for professional incomes and axis 1 is
    used for blue-collar incomes:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要简单地说明置信区间，95% 置信区间意味着在取出的每个 100 个样本均值中，有 95 个将落在该区间内。在 `numpy` 的 `percentile()`
    函数中，我们使用 `p=5` 来支持 1-p 是置信水平，其中 *p* 是显著性水平（想想 *p-value*，其中任何等于或低于 *p* 的值都是显著的）。由于测试是双尾的，我们将
    *p* 除以 2，并在左尾和右尾各分割 2.5，因为我们有一个对称的标准正态分布。`subplot(2,1,...)` 代码创建了两行一列。图形的轴 0 用于专业收入，轴
    1 用于蓝领收入：
- en: '[PRE12]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the original dataset, there are 18 income data points for `professional`
    job types and 21 data points for `blue-collar` job types. The 95% confidence interval
    for the professional job type ranges from 29.50 to 79.15 with an average of 60.06\.
    That interval ranges from 7.00 to 64.00 for blue-collar job types with a mean
    of 23.76\. Based on *Figure 2**.18*, there is a reasonable overlap between the
    income differences, which causes the overlapping confidence intervals. Consequently,
    it would be reasonable to assume there is no statistically significant difference
    in incomes between blue-collar and professional job types. However, this dataset
    has a very limited volume of samples:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始数据集中，有 18 个 `professional` 职业类型的收入数据点和 21 个 `blue-collar` 职业类型的收入数据点。专业职业类型的
    95% 置信区间从 29.50 到 79.15，平均值为 60.06。该区间对于蓝领职业类型从 7.00 到 64.00，平均值为 23.76。根据 *图
    2*.18，收入差异之间存在合理的重叠，这导致了重叠的置信区间。因此，可以合理地假设蓝领和专业人士之间的收入没有统计学上的显著差异。然而，这个数据集的样本量非常有限：
- en: '[PRE13]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Figure 2.18 – Original data distributions with 95th percentile lines](img/B18945_02_018.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 带有 95% 百分位数线的原始数据分布](img/B18945_02_018.jpg)'
- en: Figure 2.18 – Original data distributions with 95th percentile lines
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 带有 95% 百分位数线的原始数据分布
- en: In the following code, using `pandas`’ `.sample()` function, we randomly resample
    50% (`frac=0.5`) of the income values from each distribution 1,000 times and calculate
    a new mean each time, appending it to the Python lists ending with `_bootstrap_means`.
    Using those lists, we derive new 95% confidence intervals. *Figure 2**.19* shows,
    with respect to the standard deviations and income values in the dataset, the
    new sample distributions using the average of each resampled subset. The `replace=True`
    argument allows for resampling the same record multiple times (in the event that
    should randomly occur), which is a requirement of bootstrapping.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，使用 `pandas` 的 `.sample()` 函数，我们随机重新抽取每个分布中50%（`frac=0.5`）的收入值1,000次，并每次计算一个新的均值，将其附加到以
    `_bootstrap_means` 结尾的Python列表中。使用这些列表，我们推导出新的95%置信区间。*图2**.19* 显示，与数据集中的标准差和收入值相比，使用每个重新抽样的子集的平均值的新样本分布。`replace=True`
    参数允许多次重新抽样相同的记录（在随机发生的情况下），这是bootstrap的要求。
- en: 'After performing the bootstrapping procedure, we can see income has started
    to distribute in a roughly standard normal, Gaussian form. Notably, from this
    experiment, the confidence intervals no longer overlap. The implication of the
    separation of the confidence intervals between the professional and blue-collar
    groups is that with a 95% level of confidence, it can be shown there is a statistically
    significant difference between the incomes of the two job types. The confidence
    interval for the professional income levels is now 48.66 to 69.89 with a mean
    of 60.04, and for blue-collar, 14.60 to 35.90 with a mean of 23.69:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行bootstrap过程之后，我们可以看到收入已经开始以大致标准正态、高斯形式分布。值得注意的是，从这个实验中，置信区间不再重叠。专业和蓝领群体之间置信区间分离的含义是，在95%的置信水平下，可以证明两种工作类型的收入之间存在统计学上的显著差异。专业收入水平的置信区间现在是48.66到69.89，平均值为60.04，而蓝领的置信区间是14.60到35.90，平均值为23.69：
- en: '[PRE14]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Figure 2.19 – Distributions of the 95% confidence interval for 1,000 bootstrapped
    sampling means](img/B18945_02_019.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19 – 1,000次bootstrap抽样的1,000个样本均值的95%置信区间分布](img/B18945_02_019.jpg)'
- en: Figure 2.19 – Distributions of the 95% confidence interval for 1,000 bootstrapped
    sampling means
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 – 1,000次bootstrap抽样的1,000个样本均值的95%置信区间分布
- en: Here, you can notice the distribution more closely clusters around the mean
    with tighter confidence intervals.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以注意到分布更紧密地聚集在平均值周围，置信区间更紧密。
- en: As mentioned before, bootstrapping can be used to obtain different statistical
    parameters of the distribution beyond the confidence intervals.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，bootstrap可以用来获得分布的除置信区间之外的不同统计参数。
- en: Standard error
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准误差
- en: 'Another commonly used metric is the standard error,  σ _ √ _ n . We can calculate
    this using the last variables, `p``rofessional_bootstrap_means`, and `blue_collar_bootstrap_means`,
    as these contain the new distributions of means obtained through the bootstrapping
    process. We can also see that standard error – calculated by dividing the standard
    deviation by the square root of the number of samples (or in our case, `n_replicas`,
    representing the count of averages obtained from each random re-subsample) – decreases
    as the volume resamples increases. We use the following code to calculate the
    standard error of the professional and blue-collar type income bootstrapped means.
    The following table, *Figure 2**.20*, shows that the standard error reduces as
    *n* increases:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的指标是标准误差，σ √ n。我们可以使用最后几个变量，`p`rofessional\_bootstrap\_means 和 `blue\_collar\_bootstrap\_means`
    来计算这个值，因为这些变量包含了通过bootstrap过程获得的新均值分布。我们还可以看到，标准误差——通过将标准差除以样本数量的平方根（在我们的情况下，`n\_replicas`，代表从每个随机重新抽样的样本中获得的平均值数量）——随着重新抽样的体积增加而减小。我们使用以下代码来计算专业和蓝领类型收入bootstrap均值的标准误差。下表，*图2**.20*
    显示，随着 *n* 的增加，标准误差降低：
- en: '[PRE15]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| **n** | **Professional** **Standard Error** | **Blue-Collar** **Standard
    Error** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **n** | **专业** **标准误差** | **蓝领** **标准误差** |'
- en: '| 10 replicas | 0.93 | 2.09 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 10个副本 | 0.93 | 2.09 |'
- en: '| 10,000 replicas | 0.03 | 0.04 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 10,000个副本 | 0.03 | 0.04 |'
- en: Figure 2.20 – Table of standard errors for n = 10 and n = 10,000 bootstrap replicas
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 – n = 10 和 n = 10,000 bootstrap副本的标准误差表
- en: Another use case for bootstrapping is Pearson’s correlation, which we will discuss
    in the following section.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap的另一个用例是皮尔逊相关系数，我们将在下一节讨论。
- en: Correlation coefficients (Pearson’s correlation)
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关系数（皮尔逊相关）
- en: Typically, this is difficult to find using a small sample size since correlation
    depends on the covariance of two variables. As the variables overlap more significantly,
    their correlation is higher. However, if the overlap is the result of a small
    sample size or sampling error, this correlation may be representative. *Figure
    2**.21* shows a table of correlation at different counts of bootstrap subsamples.
    As the distributions form more native distinctions, the correlation diminishes
    from a small positive correlation to an amount approximating zero.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用小样本量很难找到，因为相关性取决于两个变量的协方差。随着变量重叠得更加显著，它们的相关性就越高。然而，如果重叠是样本量小或抽样误差的结果，这种相关性可能是有代表性的。*图2.21*显示了不同引导子样本计数的相关性表。随着分布形成更多的原生区分，相关性从小的正相关减少到接近零的量。
- en: 'To test correlation on a sample of 10 records from the original dataset, see
    the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试来自原始数据集的10个记录样本的相关性，请参阅以下内容：
- en: '[PRE16]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To test correlation on samples of bootstrapped means:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试引导平均值样本的相关性：
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| **n** | **Pearson’s** **Correlation Coefficient** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **n** | **Pearson** **相关系数** |'
- en: '| 10 samples from original data | 0.32 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据中的10个样本 | 0.32 |'
- en: '| 10 replicas | 0.22 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 10个副本 | 0.22 |'
- en: '| 10,000 replicas | -0.003 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 10,000个副本 | -0.003 |'
- en: Figure 2.21 – Table of Pearson’s correlation coefficients alongside the original
    samples
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – Pearson相关系数表与原始样本并排
- en: It is common to run around 1,000 to 10,000 bootstrap replicas. However, this
    depends on the type of data being bootstrapped. For example, if bootstrapping
    data from a human genome sequence dataset, it may be useful to bootstrap a sample
    10 million times, but if bootstrapping a simple dataset, it may be useful to bootstrap
    1,000 times or less. Ultimately, the researcher should perform a visual inspection
    of the distributions of the means to determine whether the results appear logical
    compared to what is expected. As common with statistics, it is best to have some
    domain knowledge or subject-matter expertise to help validate findings, as this
    will likely be the best for deciding bootstrap replication counts.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，运行大约1,000到10,000个引导副本是很常见的。然而，这取决于正在引导的数据类型。例如，如果从人类基因组序列数据集中引导数据，引导样本1亿次可能是有用的，但如果引导一个简单的数据集，引导1,000次或更少可能是有用的。最终，研究人员应进行视觉检查平均值的分布，以确定结果与预期相比是否合理。与统计学一样，最好有一些领域知识或专业知识来帮助验证发现，因为这可能是决定引导复制次数的最佳方法。
- en: Bootstrapping is also used in machine learning, where it underlies the concept
    of **bootstrap aggregation**, also called **bagging**, a process that combines
    outputs of predictive models built upon bootstrap subsample distributions. **Random
    Forest** is one popular algorithm that performs this operation. The purpose of
    bootstrapping in bagging algorithms is to preserve the low-bias behavior of non-parametric
    (more to be discussed on this in later chapters) classification, but also reduce
    variance, thus using bootstrapping as a way to minimize the significance of the
    bias-variance trade-off in modeling errors.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 引导程序（Bootstrapping）也应用于机器学习，它是**自助聚合**（bootstrap aggregation）概念的基础，也称为**Bagging**，这是一个结合基于自助子样本分布构建的预测模型输出的过程。**随机森林**（Random
    Forest）是执行此操作的一种流行算法。在Bagging算法中，引导程序的目的在于保持非参数（将在后续章节中进一步讨论）分类的低偏差行为，同时减少方差，因此将引导程序作为一种最小化建模误差中偏差-方差权衡重要性的方法。
- en: In the following section, we will consider another non-parametric test called
    permutation testing using resampling data.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将考虑另一种非参数测试，即使用重采样数据的排列测试。
- en: Permutations
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排列
- en: Before jumping into this testing analysis, we will review some basic knowledge
    of permutations and combinations.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳入这个测试分析之前，我们将回顾一些排列组合的基本知识。
- en: Permutations and combinations
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排列和组合
- en: Permutations and combinations are two mathematical techniques for taking a set
    of objects to create subsets from a population but in two different ways. The
    order of objects matters in permutations but does not matter in combinations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 排列和组合是两种数学技术，用于从一组对象中创建子集，但以两种不同的方式。在排列中，对象的顺序很重要，而在组合中则不重要。
- en: In order to understand these concepts easily, we will consider two examples.
    There are 10 people at an evening party. The organizer of the party wants to give
    3 prizes of $1,000, $500, and $200 randomly to 3 people. The question is *how
    many ways are there to distribute the prizes?* Another example is that the organizer
    will give 3 equal prizes of $500 to 3 people out of 10 at the party. The organizer
    really does not care which prize is given to whom among the 3 selected people.
    Huy, Paul, and Stuart are our winners in these two examples but, in the first
    example, different situations may play out, for instance, if Paul wins the $200
    prize, $500 prize, or $1,000 prize.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松理解这些概念，我们将考虑两个例子。晚会上有10个人。派对的组织者想要随机给3个人颁发价值1000美元、500美元和200美元的奖品。问题是*有多少种分配奖品的方式？*另一个例子是，组织者将从派对的10个人中选出3个人，每人颁发价值500美元的等额奖品。组织者并不关心这3个被选中的人中谁得到哪个奖品。在两个例子中，胡伊、保罗和斯图尔特是我们的获奖者，但在第一个例子中，可能会有不同的结果，例如，如果保罗赢得200美元的奖品、500美元的奖品或1000美元的奖品。
- en: '| **$****1,000** | **$****500** | **$****200** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **$****1,000** | **$****500** | **$****200** |'
- en: '| Huy | Paul | Stuart |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 胡伊 | 保罗 | 斯图尔特 |'
- en: '| Paul | Huy | Stuart |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 保罗 | 胡伊 | 斯图尔特 |'
- en: '| Paul | Stuart | Huy |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 保罗 | 斯图尔特 | 胡伊 |'
- en: '| Huy | Stuart | Paul |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 胡伊 | 斯图尔特 | 保罗 |'
- en: '| Stuart | Huy | Paul |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 斯图尔特 | 胡伊 | 保罗 |'
- en: '| Stuart | Paul | Huy |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 斯图尔特 | 保罗 | 胡伊 |'
- en: Figure 2.22 – Table of distributed prizes given to Huy, Paul, and Stuart
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 – 分配给胡伊、保罗和斯图尔特的奖品分布表
- en: However, in the second example, because the 3 prizes have the same value of
    $500, the order of prize arrangements does not matter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第二个例子中，由于3个奖品的价值相同，为500美元，奖品排列的顺序并不重要。
- en: 'Let us take a closer look at these two permutations and combinations examples.
    The first example is a permutation example. Since the pool has 10 people, we have
    10 possibilities in choosing one person from the pool to give the $1,000 prize.
    If this person is chosen to win the $1,000 prize, then there are only 9 possibilities
    in choosing another person to give the $500 prize, and finally, we have 8 possibilities
    in choosing a person from the pool to give the $200 prize. Then, we have 10*9*8
    = 720 ways to distribute the prizes. The mathematical formula for the permutations
    is this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这两个排列组合的例子。第一个例子是一个排列例子。由于有10个人，我们有10种可能性从这10个人中选择一个人来颁发1000美元的奖品。如果这个人被选中赢得1000美元的奖品，那么选择另一个人颁发500美元的奖品就只剩下9种可能性，最后，我们有8种可能性从这10个人中选择一个人来颁发200美元的奖品。然后，我们有10*9*8
    = 720种分配奖品的方式。排列的数学公式如下：
- en: P(n, r) =  n ! _ (n − r) !
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: P(n, r) = n! / (n-r)!
- en: 'Here, P(n, r) is the number of permutations, n is the total number of objects
    in a set, and r is the number of objects that can be chosen from the set. In this
    example, n = 10 and r = 3 so then we see this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，P(n, r)是排列的数量，n是集合中的总对象数，r是从集合中选择的对象数。在这个例子中，n = 10且r = 3，所以我们看到：
- en: P(10,3) =  10 ! _ (10 − 3) ! = 10*9 * 8*7 * 6*5 * 4*3 * 2*1  ____________  7*6
    * 5*4 * 3*2 * 1  = 10*9 * 8 = 720
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: P(10,3) = 10! / (10-3)! = 10*9 * 8*7 * 6*5 * 4*3 * 2*1 / 7*6 * 5*4 * 3*2 * 1
    = 10*9 * 8 = 720
- en: There are 720 ways to select 3 people from the 10 people at the party to whom
    to distribute the 3 prizes of $1,000, $500, and $200.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 从晚会上10个人中选出3个人来分配价值1000美元、500美元和200美元的3个奖品，共有720种选择方式。
- en: 'In Python, there is a package called `itertools` to help us to find permutations
    directly. Readers can check out the following link – [https://docs.python.org/3/library/itertools.xhtml](https://docs.python.org/3/library/itertools.xhtml)
    – for more information related to this package. We need to import this package
    into the Python environment for permutations:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一个名为`itertools`的包可以帮助我们直接找到排列。读者可以查看以下链接 – [https://docs.python.org/3/library/itertools.xhtml](https://docs.python.org/3/library/itertools.xhtml)
    – 获取有关此包的更多信息。我们需要将此包导入Python环境以进行排列：
- en: '[PRE18]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding Python code, we created a list, `people`, containing 10 people,
    `P1` to `P10`, and then use the `permutations` function from `itertools` to get
    all the ways to distribute the prizes. This method takes a list of 10 people as
    input and returns an object list of tuples containing all the possibilities in
    choosing 3 people from this pool of 10 people to whom to distribute the prizes
    of $1,000, $500, and $200\. Because there are 720 ways to distribute the prizes,
    here we will just print the 10 first ways that the Python code produced:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Python 代码中，我们创建了一个包含 10 个人的列表 `people`，分别是 `P1` 到 `P10`，然后使用 `itertools`
    中的 `permutations` 函数来获取所有分配奖项的方式。这种方法接受一个包含 10 个人的列表作为输入，并返回一个包含所有可能性的元组列表，即从这
    10 个人中选择 3 个人来分配 1,000 美元、500 美元和 200 美元的奖项。因为共有 720 种分配奖项的方式，这里我们只打印 Python 代码生成的
    10 种第一种方式：
- en: '[PRE19]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the preceding code is the 10 first ways to distribute the prizes:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出是分配奖项的 10 种第一种方式：
- en: '`[(''P1'', ''P2'', ''P3''), (''P1'', ''P2'', ''P4''), (''P1'', ''P2'', ''P5''),
    (''P1'', ''P2'', ''P6''), (''P1'', ''``P2'', ''P7'')]`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(''P1'', ''P2'', ''P3''), (''P1'', ''P2'', ''P4''), (''P1'', ''P2'', ''P5''),
    (''P1'', ''P2'', ''P6''), (''P1'', ''``P2'', ''P7'')]`'
- en: 'If we have 10 different gifts, each person who participates in the party can
    take one gift home. How many ways are there to distribute these gifts? There are
    3,628,800 ways. That is a really big number! The reader can check with the following
    code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有 10 件不同的礼物，每个参加派对的人都可以带一件礼物回家。有多少种分配这些礼物的方式？共有 3,628,800 种方式。这是一个非常大的数字！读者可以用以下代码进行验证：
- en: '[PRE20]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Going back to the second example, because the 3 prizes have the same value
    of $500, the order of the 3 selected people does not matter. Then, if the 3 selected
    people are Huy, Paul, and Stuart, as in *Figure 2**.22*, there are 6 ways to distribute
    the prizes in the first example. Then, there is only 1 way to distribute the same
    amount of $500 to Huy, Paul, and Stuart. The mathematical formula of combinations
    is this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第二个例子，因为 3 个奖项的价值都是 500 美元，所以 3 个被选中的人的顺序并不重要。那么，如果选中的 3 个人是 Huy、Paul 和 Stuart，如
    *图 2**.22* 所示，在第一个例子中分配奖项的方式有 6 种。然后，将相同数量的 500 美元分配给 Huy、Paul 和 Stuart 的方式只有
    1 种。组合的数学公式如下：
- en: C(n, r) =  n ! _ r !(n − r) !
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: C(n, r) = n! / (r! * (n - r)!)
- en: Here, C(n, r) is the number of combinations, n is the total number of objects
    in a set, and r is the number of objects that can be chosen from the set. Similarly,
    we can calculate that there are
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，C(n, r) 表示组合数，n 是集合中对象的总数，r 是可以从集合中选择的对象数量。同样，我们可以计算出有
- en: 10 ! _ 3 !(10 − 3) !  =  10.9 . 8 _ 1.2 . 3  =  720 _ 6  = 120
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 10! / (3! * (10 - 3)!) = 10 * 9 * 8 / (1 * 2 * 3) = 720 / 6 = 120
- en: ways to distribute 3 prizes of $500.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 分配 3 个价值 500 美元的奖项的方式。
- en: 'In Python, we also use the `itertools` package but, instead of the `permutations`
    function, we import the `combinations` function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们同样使用 `itertools` 包，但不是使用 `permutations` 函数，而是导入 `combinations`
    函数：
- en: '[PRE21]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Permutation testing
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排列测试
- en: Permutation testing is a non-parametric test that does not make the required
    assumption of normally distributed data. Both bootstrapping and permutations are
    useful for resampling techniques but best for different uses, one for estimating
    statistical parameters (bootstrapping) and another for hypothesis testing. Permutation
    testing is used to test the null hypothesis between two samples generated from
    the same population. It has different names such as **exact testing**, **randomization
    testing**, and **re-randomization testing**.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 排列测试是一种非参数测试，它不要求数据呈正态分布。自助法和排列法都适用于重采样技术，但适用于不同的用途，一个用于估计统计参数（自助法），另一个用于假设检验。排列测试用于测试来自同一总体生成的两个样本之间的零假设。它有不同的名称，如
    **精确测试**、**随机化测试**和**重新随机化测试**。
- en: 'First, we go to see a simple example for better understanding before implementing
    the code in Python. We suppose that there are 2 groups of people, one group representing
    children (A) and another group representing people over 40 years old (B) as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 Python 代码之前，我们先来看一个简单的例子，以便更好地理解。我们假设有两组人，一组代表儿童（A），另一组代表 40 岁以上的人（B），如下所示：
- en: '`A` = [3,5,4] and `B` = [43,41,56,78,54]'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` = [3,5,4] 和 `B` = [43,41,56,78,54]'
- en: The mean difference in age between the two samples A and B is
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 样本 A 和 B 之间年龄的平均差异是
- en: 43 + 41 + 56 + 78 + 54  ________________ 5  −  3 + 5 + 4 _ 3  = 50.4
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 43 + 41 + 56 + 78 + 54  __________________ 5 - 3 + 5 + 4 * 3 = 50.4
- en: 'We merge A and B into a single set, denoted as P as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 A 和 B 合并成一个单一集合，记为 P，如下所示：
- en: '`P =` [3,5, 4,43,41,56,78,54].'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`P =` [3,5, 4,43,41,56,78,54].'
- en: 'Then, we take a permutation of P, for example, the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们取P的一个排列，例如以下内容：
- en: '`P_new = [3,54, 78, 41, 4, 43,` `5, 56]`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`P_new = [3,54, 78, 41, 4, 43, 5, 56]`'
- en: 'Next, we redivide `P_new` into 2 subsets called `A_new` and `B_new`, which
    have the same size as A and B, respectively:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`P_new`重新划分为两个子集，分别称为`A_new`和`B_new`，它们的大小分别与A和B相同：
- en: '`A_new` = [3,54,78] and `B_new` = [41,4,43,5,56]'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`A_new` = [3,54,78] 和 `B_new` = [41,4,43,5,56]'
- en: 'Then, the mean difference in age between `A_new` and `B_new` is 15.2, which
    is lower than the original mean difference in age between A and B (50.4). In other
    words, the permutated `P_new` does not contribute to the p-value. We can observe
    that only one permutation drawn from all possible permutations of P is greater
    than or equal to the original mean difference itself, P. Now we will implement
    the code in Python:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`A_new`和`B_new`之间的年龄均值差异为15.2，这低于A和B之间的原始年龄均值差异（50.4）。换句话说，排列后的`P_new`对p值没有贡献。我们可以观察到，从P的所有可能排列中抽取的只有一个排列的均值差异大于或等于原始的均值差异P。现在我们将代码实现于Python中：
- en: '[PRE22]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding Python code, A and B are two samples and we want to know whether
    they are from the same larger population; `n_ter` is the number of iterations
    that we want to perform; here, 1,000 is the default number of iterations.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的Python代码中，A和B是两个样本，我们想知道它们是否来自同一个更大的总体；`n_ter`是我们想要执行的迭代次数；这里，1,000是默认的迭代次数。
- en: 'Let’s perform permutation testing for the two groups of people in the example
    with 10,000 iterations:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以10,000次迭代对示例中的两组人员进行置换检验：
- en: '[PRE23]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The p-value obtained is 0.98\. That means that we fail to reject the null hypothesis,
    or there is not enough evidence to confirm that samples A and B are from the same
    larger population.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的p值为0.98。这意味着我们未能拒绝零假设，或者说没有足够的证据来确认样本A和B来自同一个更大的总体。
- en: Next, we will explore an important and necessary step in many statistical tests
    requiring the normal distribution assumption.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨许多需要正态分布假设的统计测试中的一个重要且必要的步骤。
- en: Transformations
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: 'In this section, we will consider three transformations:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑三种转换：
- en: Log transformation
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数转换
- en: Square root transformation
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方根转换
- en: Cube root transformation
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立方根转换
- en: 'First, we will import the `numpy` package to create a random sample drawn from
    a Beta distribution. The documentation on Beta distributions can be found here:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入`numpy`包以创建一个从Beta分布中抽取的随机样本。Beta分布的文档可以在这里找到：
- en: '[https://numpy.org/doc/stable/reference/random/generated/numpy.random.beta.xhtml](https://numpy.org/doc/stable/reference/random/generated/numpy.random.beta.xhtml)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://numpy.org/doc/stable/reference/random/generated/numpy.random.beta.xhtml](https://numpy.org/doc/stable/reference/random/generated/numpy.random.beta.xhtml)'
- en: 'The sample, `df`, has 10,000 values. We also use `matplotlib.pyplot` to create
    different histogram plots. Second, we transform the original data by using a log
    transformation, square root transformation, and cube root transformation, and
    we draw four histograms:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 样本`df`有10,000个值。我们还使用`matplotlib.pyplot`创建不同的直方图。其次，我们通过使用对数转换、平方根转换和立方根转换来转换原始数据，并绘制四个直方图：
- en: '[PRE24]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the output of the code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为代码的输出：
- en: '![Figure 2.23 – Histograms of the original and transformed data](img/B18945_02_023.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图2.23 – 原始数据和转换数据的直方图](img/B18945_02_023.jpg)'
- en: Figure 2.23 – Histograms of the original and transformed data
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 – 原始数据和转换数据的直方图
- en: Using transformation, we can see the transformed histograms are more normally
    distributed than the original one. It seems that the best transformation in this
    example is cube root transformation. With real-world data, it is important to
    determine whether a transformation is needed, and, if so, which transformation
    should be used.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转换，我们可以看到转换后的直方图比原始直方图更接近正态分布。似乎在这个例子中，最佳转换是立方根转换。在现实世界的数据中，确定是否需要转换以及应该使用哪种转换非常重要。
- en: Other data transformation methods, for example, finding duplicate data, dealing
    with missing values, and feature scaling will be discussed in hands-on, real-world
    use cases in Python in the following chapters.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数据转换方法，例如查找重复数据、处理缺失值和特征缩放，将在以下章节的Python实际应用案例中讨论。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the first section of this chapter, we learned about types of data and how
    to visualize these types of data. Then, we covered how to describe and measure
    attributes of data distribution. We learned about the standard normal distribution,
    why it’s important, and how the central limit theorem is applied in practice by
    demonstrating bootstrapping. We also learned how bootstrapping can make use of
    non-normally distributed data to test hypotheses using confidence intervals. Next,
    we covered mathematical knowledge as permutations and combinations and introduced
    permutation testing as another non-parametric test in addition to bootstrapping.
    We finished the chapter with different data transformation methods that are useful
    in many situations when performing statistical tests requiring normally distributed
    data.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一节中，我们学习了数据的类型以及如何可视化这些类型的数据。然后，我们介绍了如何描述和测量数据分布的属性。我们学习了标准正态分布，为什么它很重要，以及通过展示自助法来展示中心极限定理在实践中的应用。我们还学习了如何利用自助法利用非正态分布的数据，通过置信区间来测试假设。接下来，我们介绍了排列组合等数学知识，并介绍了排列测试作为自助法之外的另一种非参数检验。我们以在执行需要正态分布数据的统计测试的许多情况下有用的不同数据转换方法结束本章。
- en: In the next chapter, we will take a detailed look at hypothesis testing and
    discuss how to draw statistical conclusions from the results of the tests. We
    will also look at errors that can occur in statistical tests and how to select
    statistical power.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨假设检验，并讨论如何从测试结果中得出统计结论。我们还将探讨统计测试中可能出现的错误以及如何选择统计功效。
- en: References
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[*1*] Skewness – [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35b.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35b.htm)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*1*] 偏度 – [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35b.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35b.htm)'
- en: '[*2*] Kurtosis – [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35b.htm#:~:text=Kurtosis%20is%20a%20measure%20of,would%20be%20the%20extreme%20case](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35b.htm#:~:text=Kurtosis%20is%20a%20measure%20of,would%20be%20the%20extreme%20case).'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*2*] 峰度 – [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35b.htm#:~:text=峰度%20是%20一个%20衡量,%20会是%20极端情况](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35b.htm#:~:text=峰度%20是%20一个%20衡量,%20会是%20极端情况).'
- en: '[*3*] Normal Distribution – *C.F. GAUSS AND THE METHOD OF LEAST SQUARES*, *ŚLĄSKI
    PRZEGLĄD STATYSTYCZNY Silesian Statistical Review*, Nr 12(18), O. Sheynin, Sep.
    1999'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*3*] 正态分布 – *C.F. 高斯和最小二乘法*，*ŚLĄSKI PRZEGLĄD STATYSTYCZNY 西里西亚统计评论*，第12(18)期，O.
    Sheynin，1999年9月'
