- en: Using TensorFlow with ML.NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TensorFlow与ML.NET
- en: In this chapter, we will be using a pre-trained TensorFlow model, specifically
    the Inception model, and we’ll integrate the model into a **Windows Presentation
    Foundation** (**WPF**) application. We will be taking the pre-trained model and
    applying transfer learning, by adding some pictures of food and bodies of water.
    After the transfer learning has been performed, we then allow the user to select
    their own images. By the end of the chapter, you should have a firm grasp of what
    it takes to integrate a TensorFlow model into your ML.NET application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用预训练的TensorFlow模型，特别是Inception模型，并将其集成到**Windows Presentation Foundation**（WPF）应用程序中。我们将使用预训练的模型并应用迁移学习，通过添加一些食物和水的图片。在迁移学习完成后，我们允许用户选择他们自己的图片。到本章结束时，你应该对将TensorFlow模型集成到你的ML.NET应用程序中所需的内容有一个牢固的掌握。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Breaking down Google's Inception model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆解谷歌的Inception模型
- en: Creating the image classification desktop application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像分类桌面应用程序
- en: Exploring additional production application enhancements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索额外的生产应用程序增强功能
- en: Breaking down Google's Inception model
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆解谷歌的Inception模型
- en: Google's Inception model ([https://github.com/google/inception](https://github.com/google/inception))
    has been trained on millions of images to help with one of the growing questions
    in our society—what is in my image? The type of applications wanting to answer
    this question range from matching faces, automatically detecting weapons or unwanted
    objects, sports branding in game pictures (such as the brand of sneakers), and
    image archivers that provide users with the support they need to search without
    manual tags, to name just a few.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的Inception模型([https://github.com/google/inception](https://github.com/google/inception))已经在数百万张图像上进行了训练，以帮助解决我们社会中日益增长的问题之一——我的图像中有什么？想要回答这个问题的应用程序类型范围很广，从匹配人脸、自动检测武器或不希望的对象、游戏图片中的运动品牌（如运动鞋品牌），到为用户提供无需手动标签即可搜索的支持的图像归档器，仅举几例。
- en: This type of question is typically answered with **object recognition**. An
    application of object recognition that you might already be familiar with is **optical**
    **character** **recognition** (**OCR**). OCR is when an image of characters can
    be interpreted as text, such as what is found in Microsoft's OneNote Handwriting
    to Text feature, or in a toll booth that reads license plates. The particular
    application of object recognition that we will be looking into specifically is
    called **image classification**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这类问题通常用**物体识别**来回答。你可能已经熟悉的一种物体识别应用是**光学字符识别**（OCR）。OCR是指字符图像可以被解释为文本，例如在微软的OneNote手写笔迹到文本功能中，或在读取车牌的收费站中。我们将特别关注的物体识别的特定应用称为**图像分类**。
- en: The Inception model helps with this problem by using deep learning to classify
    images. The model was trained in a supervised approach on millions of images,
    with the output being a neural network. The advantage of this approach is that
    the pre-built model can be enhanced with a smaller subset of images, which is
    what we will be doing in the next section of this chapter. This approach of adding
    additional data and labels is called **transfer** **learning**. This approach
    can also be helpful when creating customer-specific models.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Inception模型通过使用深度学习来分类图像来帮助解决这个问题。该模型在数百万张图像上以监督方法进行了训练，输出是一个神经网络。这种方法的优点是，预构建的模型可以通过添加较小子集的图像来增强，这就是我们在本章下一节将要做的。这种添加额外数据和标签的方法称为**迁移学习**。当创建特定于客户模型的时，这种方法也可能很有帮助。
- en: Think of it like creating a branch from your master branch in GitHub; you might
    want to just add one class or modify one element without having to re-create the
    entire code base. In regards to models, take for instance, an image classifier
    for automobiles. Let us assume that you obtain millions of images covering US
    and foreign cars, trucks, vans, and more. A new customer comes to you requesting
    you to create a model to help monitor vehicles entering a government facility.
    The previous model should not be thrown away and won't need to be fully retrained,
    simply adding more commercial (or maybe military) vehicles with labels would be
    needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下就像在GitHub的master分支中创建一个分支；你可能只想添加一个类或修改一个元素，而不必重新创建整个代码库。至于模型，以汽车图像分类器为例。假设你获得了数百万张涵盖美国和外国汽车、卡车、面包车等图片。一位新客户来找你，要求你创建一个模型来帮助监控进入政府设施的车辆。之前的模型不应该被丢弃，也不需要完全重新训练，只需添加更多带有标签的商业（或可能是军事）车辆即可。
- en: For a larger and more in-depth deep dive into Google's image classification,
    a good resource is their developer documentation, which can be found from [https://developers.google.com/machine-learning/practica/image-classification/](https://developers.google.com/machine-learning/practica/image-classification/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更深入地了解Google的图像分类，一个很好的资源是他们的开发者文档，可以在[https://developers.google.com/machine-learning/practica/image-classification/](https://developers.google.com/machine-learning/practica/image-classification/)找到。
- en: Creating the WPF image classification application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建WPF图像分类应用程序
- en: As mentioned earlier, the application that we will be creating is an image classification
    application, specifically allowing the user to select an image and determine whether
    it is either food or water. This is achieved through the aforementioned and included,
    pre-trained TensorFlow Inception model. The first time that the application is
    run, the ML.NET version of the model is trained with the images and the `tags.tsv`
    file (to be reviewed in the next section).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将要创建的应用程序是一个图像分类应用程序，具体允许用户选择一张图片并确定它是食物还是水。这是通过上述和包含的预训练TensorFlow Inception模型实现的。当应用程序第一次运行时，ML.NET版本的模型使用图片和`tags.tsv`文件（将在下一节中讨论）进行训练。
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter12](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter12)[.](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，完成的项目代码、样本数据集和项目文件可以在此处下载：[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter12](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter12)[.](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10)
- en: Exploring the project architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目架构
- en: In this chapter, we will dive into a WPF desktop application. As mentioned in
    the first section of this chapter, we will be using the WPF framework to create
    our application. You might be asking, why not a UWP application such as the browser
    application that we created in [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*? The reasoning, at least at the time of writing, is that
    TensorFlow support, specifically for image classification, is not fully supported
    in a UWP application. Perhaps, in future versions of ML.NET, this will be added.
    For other non-image-based applications, you may be able to use TensorFlow in a
    UWP application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨一个WPF桌面应用程序。正如本章第一部分所提到的，我们将使用WPF框架来创建我们的应用程序。你可能会问，为什么不使用UWP应用程序，比如我们在[第10章](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml)中创建的浏览器应用程序？至少在撰写本文时，原因在于TensorFlow在UWP应用程序中，特别是对于图像分类，并不完全受支持。也许在ML.NET的未来版本中，这将被添加。对于其他非图像类应用程序，你可能在UWP应用程序中使用TensorFlow。
- en: Those who have done WPF development previously, and are looking closely, will
    notice that the project utilizes .NET Core 3.1\. In .NET Core 3.0, Microsoft added
    support for WPF and WinForms, therefore, you are no longer tied to the Windows-only
    .NET Framework for GUI development. Instead, this support is added through the
    `Microsoft.WindowsDesktop.App.WPF` NuGet package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那些之前进行过WPF开发并且仔细观察的人会注意到，该项目使用了.NET Core 3.1。在.NET Core 3.0中，Microsoft添加了对WPF和WinForms的支持，因此，你不再仅限于Windows的.NET
    Framework进行GUI开发。相反，这种支持是通过`Microsoft.WindowsDesktop.App.WPF` NuGet包添加的。
- en: 'For this example, we will be using the `Microsoft.ML` (1.3.1) NuGet package—in
    addition to several additional NuGet packages—to be able to utilize TensorFlow
    within our .NET application. These include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`Microsoft.ML` (1.3.1) NuGet包——以及几个额外的NuGet包——以便在我们的.NET应用程序中利用TensorFlow。以下包括以下内容：
- en: '`Microsoft.ML.ImageAnalytics` (1.3.1)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.ML.ImageAnalytics` (1.3.1)'
- en: '`Microsoft.ML.TensorFlow` (1.3.1)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.ML.TensorFlow` (1.3.1)'
- en: '`SciSharp.TensorFlow.Redist` (1.14.0)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SciSharp.TensorFlow.Redist` (1.14.0)'
- en: By the time you are reading this, there may very well be newer versions of the
    packages and they should work, however, the versions that were noted above are
    the ones that we are going to use in this deep dive, and what is available in
    the GitHub repository.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到你阅读这个的时候，可能已经有这些包的新版本，它们应该可以工作，然而，上面提到的版本是我们将在这次深入研究中使用，以及GitHub仓库中可用的版本。
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the solution. Due to the TensorFlow support being much more particular
    about project types and CPU targets, we have gone back to a single project, as
    opposed to the three-project architecture that was used in the previous several
    chapters:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您将找到解决方案的Visual Studio Solution Explorer视图。由于TensorFlow对项目类型和CPU目标的要求更为严格，我们回到了一个单一的项目，而不是在前面几章中使用过的三个项目架构：
- en: '![](img/26d6470c-1bff-4a86-b49e-2c37a72775a9.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26d6470c-1bff-4a86-b49e-2c37a72775a9.png)'
- en: 'The `tags.tsv` file (found in the `assets\images` folder in the code repository)
    contains eight rows, which map the included images to the preclassification:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags.tsv`文件（位于代码仓库中的`assets\images`文件夹中）包含八行，这些行将包含的图像映射到预分类：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you want to experiment with your own classification, delete the included
    images, copy your images, and update the `tags.tsv` file with the label. I should
    note, all of the images that are included were taken by me on various vacations
    to California—feel free to use them as you wish.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试自己的分类，请删除包含的图像，复制你的图像，并更新`tags.tsv`文件以包含标签。我应该注意的是，所有包含的图像都是我在各种加州度假时拍摄的——请随意使用。
- en: The files in the `assets/inception` folder contain all of the Google pre-trained
    files (and license file).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`assets/inception`文件夹中的文件包含所有Google预训练文件（以及许可文件）。'
- en: Diving into the WPF image classification application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入WPF图像分类应用程序
- en: As discussed in the opening section, our desktop application is a WPF application.
    For the scope of this example, as found in [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*, we are using standard approaches for handling the application
    architecture by following the **Model-View-ViewModel** (**MVVM**) design pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如在开头部分所述，我们的桌面应用程序是一个WPF应用程序。在本例的范围内，如[第10章](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml)中所述，使用ML.NET与UWP，我们通过遵循**模型-视图-视图模型**（**MVVM**）设计模式来使用标准方法处理应用程序架构。
- en: 'The files that we will be diving into in this section are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将深入研究的文件如下：
- en: '`MainWindowViewModel`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainWindowViewModel`'
- en: '`MainWindow.xaml`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml`'
- en: '`MainWindow.xaml.cs`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml.cs`'
- en: '`BaseML`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseML`'
- en: '`ImageDataInputItem`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageDataInputItem`'
- en: '`ImageDataPredictionItem`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageDataPredictionItem`'
- en: '`ImageClassificationPredictor`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageClassificationPredictor`'
- en: The rest of the files inside the WPF project were untouched from the default
    Visual Studio .NET Core 3.1 WPF application template; for example, the `App.xaml`
    and `AssemblyInfo.cs` files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: WPF项目中的其余文件都未从默认的Visual Studio .NET Core 3.1 WPF应用程序模板中进行修改；例如，`App.xaml`和`AssemblyInfo.cs`文件。
- en: The MainWindowViewModel class
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MainWindowViewModel`类'
- en: 'The purpose of the `MainWindowViewModel` class is to contain our business logic
    and control the view, as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindowViewModel`类的目的是包含我们的业务逻辑并控制视图，如下所示：'
- en: 'The first thing we do is instantiate our previously discussed `ImageClassificationPredictor` class,
    so that it can be used to run predictions:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先实例化之前讨论过的`ImageClassificationPredictor`类，以便它可以用于运行预测：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next block of code handles the power of MVVM for the classification string,
    and also stores the selected image. For each of these properties, we call `OnPropertyChanged`
    upon a change in values, which triggers the binding of the View to refresh for
    any field that is bound to these properties:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个代码块处理了MVVM对分类字符串的强大功能，并存储选定的图像。对于这些属性中的每一个，当值发生变化时，我们调用`OnPropertyChanged`，这触发了视图与这些属性绑定的任何字段的绑定刷新：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we define the `Initialize` method, which calls the predictor''s `Initialize`
    method. The method will return a tuple, which indicates whether the model can''t
    be loaded or whether it is not found, along with the exception (if thrown):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `Initialize` 方法，它调用预测器的 `Initialize` 方法。该方法将返回一个元组，表示模型无法加载或找不到，以及异常（如果抛出）：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we handle what happens when the user clicks the Select Image button.
    This method opens a dialog box prompting the user to select an image. If the user
    cancels the dialog, the method returns. Otherwise, we call the two helper methods
    to load the image into memory and classify the image:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们处理用户点击选择图片按钮时会发生什么。该方法打开一个对话框，提示用户选择一个图片。如果用户取消对话框，则方法返回。否则，我们调用两个辅助方法将图片加载到内存中并对图片进行分类：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `LoadImageBytes` method takes the filename and loads the image into our
    MVVM-based `ImageSource` property so, after selection, the image control is automatically
    updated to a view of the selected image:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoadImageBytes` 方法接受文件名并将图片加载到我们的基于 MVVM 的 `ImageSource` 属性中，因此选择后，图片控件会自动更新为所选图片的视图：'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And lastly, the `Classify` method takes the path and passes it into the `Predictor`
    class. Upon returning the prediction, the classification and confidence are built
    into our MVVM `ImageClassification` property, therefore, the UI is updated automatically:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`Classify` 方法接受路径并将其传递给 `Predictor` 类。在返回预测后，分类和置信度将集成到我们的 MVVM `ImageClassification`
    属性中，因此 UI 会自动更新：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The last element of the `MainWindowViewModel` class is the same `OnPropertyChanged`
    method that we defined in [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*, which allows the MVVM magic to happen. With our `ViewModel`
    class defined, let us move on to the `MainWindow` XAML file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindowViewModel` 类的最后一个元素是我们之前在第 10 章 *使用 ML.NET 与 UWP* 中定义的相同的 `OnPropertyChanged`
    方法，它允许 MVVM 魔法发生。定义了我们的 `ViewModel` 类后，让我们继续到 `MainWindow` XAML 文件。'
- en: The MainWindow.xaml class
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml` 类'
- en: As discussed in the *Breaking down UWP architecture *section of [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),* Using
    ML.NET with UWP*, when describing the development, XAML markup is used to define
    your user interface. For the scope of this application, our UI is relatively simple:  `Button`,
    `Image Control`, and `TextBlock`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第 10 章 *分解 UWP 架构* 部分的 *使用 ML.NET 与 UWP* 节中所述，当描述开发时，XAML 标记用于定义用户界面。对于本应用程序的范围，我们的
    UI 相对简单：`Button`、`Image Control` 和 `TextBlock`。
- en: 'We will look at the code now:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看代码：
- en: 'The first thing that we define is our grid. In XAML, a grid is a container
    similar to a `<div>` in web development. We then define our rows. Similar to Bootstrap
    (but easier to understand in my opinion), is the pre-definition of the height
    of each row. Setting a row to `Auto` will auto-size the height to the content''s
    height, while an asterisk translates to using all remaining height based on the
    main container''s height:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义的是我们的网格。在 XAML 中，网格是一个类似于网络开发中的 `<div>` 的容器。然后我们定义我们的行。与 Bootstrap 类似（但在我看来更容易理解），是预先定义每行的高度。将行设置为
    `Auto` 将自动调整高度以适应内容的高度，而星号则表示根据主容器的高度使用所有剩余的高度：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We first define our `Button` object, which will trigger the aforementioned
    `SelectFile` method in our `ViewModel` class:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义我们的 `Button` 对象，它将在我们的 `ViewModel` 类中触发上述的 `SelectFile` 方法：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then define our `Image` control, which is bound to our previously reviewed
    `SelectedImageSource` property that is found in our `ViewModel` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着定义我们的 `Image` 控件，它绑定到我们之前审查过的 `SelectedImageSource` 属性，该属性位于我们的 `ViewModel`
    类中：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then add the `TextBlock` control that will display our classification:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着添加将显示我们分类的 `TextBlock` 控件：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the XAML aspect of our View defined, let us now dive into the code behind
    of the `MainWindow` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了视图的 XAML 方面之后，现在让我们深入了解 `MainWindow` 类的代码部分。
- en: The MainWindow.xaml.cs file
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml.cs` 文件'
- en: 'The `MainWindow.xaml.cs` file contains the code behind the XAML view, which
    is discussed here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml.cs` 文件包含 XAML 视图的代码，相关内容在此讨论：'
- en: 'The first thing that we define is a wrapper property around the `DataContext`
    property, which is built into the base `Window` class:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义的是围绕 `DataContext` 属性的包装属性，该属性是基 `Window` 类中内置的：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we define the constructor for `MainWindow`, in order to initialize the
    `DataContext` property to our `MainWindowViewModel` object. If the initialization
    fails, we do not want the application to continue. In addition, we need to let
    the user know why it failed, using a `MessageBox` object:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`MainWindow`的构造函数，以便将`DataContext`属性初始化为我们的`MainWindowViewModel`对象。如果初始化失败，我们不希望应用程序继续运行。此外，我们需要使用`MessageBox`对象让用户知道为什么它失败了：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, we call the ViewModel''s `SelectFile` method to handle the image selection
    and classification:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用ViewModel的`SelectFile`方法来处理图像选择和分类：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the code behind of the `MainWindow` class behind us, that concludes the
    WPF component. Let us now focus on the machine learning part of the example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成了`MainWindow`类的代码之后，这就完成了WPF组件。现在让我们专注于示例中的机器学习部分。
- en: The BaseML class
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础ML类
- en: 'The `BaseML` class, as used in most of the previous examples, exposes a base
    class for our ML.NET classes. In the case of this example, we actually streamlined
    the class due to the nature of using a pre-trained model. The class now simply
    initializes the `MLContext` property:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseML`类，在大多数之前的示例中都被使用，暴露了我们的ML.NET类的基础类。在这个示例中，由于使用了预训练模型，我们实际上简化了类。现在这个类只是初始化了`MLContext`属性：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the streamlined `BaseML` class reviewed, let us dive into the `ImageDataInputItem`
    class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了简化的`BaseML`类之后，让我们深入到`ImageDataInputItem`类。
- en: The ImageDataInputItem class
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像数据输入项类
- en: 'The `ImageDataInputItem` class contains our class to pass into the model; the
    essential property is the `ImagePath` property:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageDataInputItem`类包含了传递给模型的类；基本属性是`ImagePath`属性：'
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While smaller than most of our input classes, the Inception model only requires
    the two properties. Now, let us dive into the output class that is called `ImageDataPredictionItem`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管比我们的大多数输入类小，Inception模型只需要两个属性。现在，让我们深入到被称为`ImageDataPredictionItem`的输出类。
- en: The ImageDataPredictionItem class
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像数据预测项类
- en: 'The `ImageDataPredictionItem` class contains the prediction response, including
    the confidence of the predicted value string (to contain `Water` or `Food` in
    the case of the included images):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageDataPredictionItem`类包含了预测响应，包括预测值字符串的置信度（在包含的图像中包含`Water`或`Food`）：'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Much like the input class, the output class has only two properties, similar
    to previous examples. With the input and output classes behind us, let us dive
    into the `ImageClassificationPredictor` class, which uses these classes for transfer
    learning and predictions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入类类似，输出类也只有两个属性，类似于之前的示例。在处理完输入和输出类之后，让我们深入到使用这些类进行迁移学习和预测的`ImageClassificationPredictor`类。
- en: The ImageClassificationPredictor class
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像分类预测器类
- en: 'The `ImageClassificationPredictor` class contains all of the code that is needed
    to load and predict against the Inception TensorFlow model:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageClassificationPredictor`类包含了加载和针对Inception TensorFlow模型进行预测所需的所有代码：'
- en: 'First, we need to define several helper variables to access the images and
    `.tsv` files:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义几个辅助变量来访问图像和`.tsv`文件：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we define the settings that the pre-trained Inception model needs:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义预训练的Inception模型所需的设置：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we create our `Predict` method and overload that simply takes the image
    file path. Like in previous examples, we create `PredictionEngine` with a call
    to our `MLContext` object, passing in our input class (`ImageDataInputItem`) and
    our output class (`ImageDataPredictionItem`), and then calling the `Predict` method
    to get our model prediction:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的`Predict`方法，并重载它，它简单地接受图像文件路径。像之前的示例一样，我们通过调用我们的`MLContext`对象创建`PredictionEngine`，传入我们的输入类（`ImageDataInputItem`）和输出类（`ImageDataPredictionItem`），然后调用`Predict`方法来获取我们的模型预测：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '4\. Finally, we initialize and extend our pre-trained model with our own samples:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用自己的样本初始化并扩展我们的预训练模型：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the full code, please refer to the following GitHub repository link: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/blob/master/chapter12/chapter12.wpf/ML/ImageClassificationPredictor.cs](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/blob/master/chapter12/chapter12.wpf/ML/ImageClassificationPredictor.cs).
    With the `Initialize` method completed, that concludes the code deep dive. Let
    us now run the application!'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整代码，请参阅以下GitHub仓库链接：[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/blob/master/chapter12/chapter12.wpf/ML/ImageClassificationPredictor.cs](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/blob/master/chapter12/chapter12.wpf/ML/ImageClassificationPredictor.cs)。完成
    `Initialize` 方法后，代码深入探讨就结束了。现在让我们运行应用程序！
- en: Running the image classification application
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行图像分类应用程序
- en: 'Since we are using a pre-trained model, we can just run the application from
    Visual Studio. Upon running the application, you will be presented with a mostly
    empty window:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是预训练模型，因此可以直接从Visual Studio运行应用程序。运行应用程序后，您将看到一个几乎为空窗口：
- en: '![](img/6f1449c0-2b5e-4219-a885-954599f1646e.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f1449c0-2b5e-4219-a885-954599f1646e.png)'
- en: 'Clicking on the Select Image File button and then selecting an image file will
    trigger the model to run. In my case, I selected a picture from a recent vacation
    to Germany, which came back with a 98.84% confidence score:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“选择图像文件”按钮并选择一个图像文件将触发模型运行。在我的情况下，我选择了一张最近去德国度假的照片，置信度得分为98.84%：
- en: '![](img/4a2c3d00-de73-40ec-8779-590ab092c4c1.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a2c3d00-de73-40ec-8779-590ab092c4c1.png)'
- en: Feel free to try various files on your machine to see the confidence score and
    classification—if you start noticing issues, add more samples to the images folder
    and `tags.tsv` file, as noted in the earlier section. Be sure to delete the `chapter12.mdl`
    file prior to making these changes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试您机器上的各种文件以查看置信度得分和分类——如果您开始注意到问题，请按照前面章节所述，向图像文件夹和 `tags.tsv` 文件中添加更多样本。在做出这些更改之前，请务必删除
    `chapter12.mdl` 文件。
- en: Additional ideas for improvements
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进建议的额外想法
- en: Now that we have completed our deep dive, there are a couple of additional elements
    that could possibly further enhance the application. A few ideas are discussed
    here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了深入探讨，还有一些额外的元素可能会进一步增强应用程序。这里讨论了一些想法。
- en: Self-training based on the end user's input
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于最终用户输入的自训练
- en: One of the advantages, as noted in the opening section of this chapter, is the
    ability to utilize transfer learning in dynamic applications. Unlike previous
    example applications that have been reviewed in this book, this application could
    actually allow the end user to select a series (or folder) of images, and with
    a few code changes, build the new `.tsv` file and train a new model. For a web
    application or commercial product, this would provide a high value and would also
    reduce the burden on you to, for instance, obtain images of every type—a daunting,
    and more than likely futile, goal.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，其中一个优点是能够在动态应用中利用迁移学习。与本书中已审查的先前示例应用不同，此应用实际上允许最终用户选择一系列（或文件夹）图像，并且只需进行少量代码更改，就可以构建新的
    `.tsv` 文件并训练新的模型。对于Web应用或商业产品，这将提供很高的价值，同时也会减轻您获取各种类型图像的负担——这是一个令人畏惧的、很可能徒劳的目标。
- en: Logging
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: As mentioned in the *Logging* section of [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*, having a desktop application has its pros and cons. The
    biggest con necessitating the need for logging is that your desktop application
    could be installed on any number of configurations of Windows 7 to Windows 10,
    with an almost unlimited number of permutations. As mentioned previously, logging
    by utilizing NLog ([https://nlog-project.org/](https://nlog-project.org/)) or
    a similar open source project is highly recommended, coupled with a remote logging
    solution such as Loggly, so that you can get error data from your user's machines.
    Given the GDPR and recent CCPA, we need to ensure that the data that is leaving
    the end user's machines is conveyed and that these logs do not include personal
    data (or actual images uploaded to a remote server via the logging mechanism).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如第10章中提到的[使用ML.NET与UWP](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml)的*日志记录*部分所述，桌面应用程序有其优点和缺点。最大的缺点是需要日志记录，因为您的桌面应用程序可以安装在从Windows
    7到Windows 10的任何配置上，几乎有无限多的排列组合。如前所述，强烈建议使用NLog ([https://nlog-project.org/](https://nlog-project.org/))或类似的开源项目进行日志记录，并结合远程日志解决方案，如Loggly，以便从用户的机器上获取错误数据。鉴于GDPR和最近的CCPA，我们需要确保离开最终用户机器的数据得到传达，并且这些日志不包含个人数据（或通过日志记录机制上传到远程服务器的实际图像）。
- en: Utilizing a database
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库
- en: 'Similar to the performance optimization suggestion in [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*, if a user selects the same image more than once, especially
    if this application was being used in a kiosk or converted to a web application,
    the performance advantages of storing the classification could be fairly significant.
    A quick and easy method for achieving this could be to perform a SHA256 of the
    image, and check that hash against a database. Depending on the number of users
    and if they are going to be concurrent, I would suggest one of two options:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与第10章中性能优化建议[使用ML.NET与UWP](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml)类似，如果用户多次选择相同的图像，尤其是在这个应用程序被用于自助终端或转换为Web应用程序的情况下，存储分类的性能优势可能相当显著。实现这一点的快速简单方法可能是对图像执行SHA256哈希，并检查该哈希值与数据库。根据用户数量以及他们是否将并发，我建议两种选择之一：
- en: If the users are going one at a time and the application is going to remain
    a WPF application, using the previously mentioned lightweight database—LiteDB
    ([http://www.litedb.org/](http://www.litedb.org/))—would be recommended.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户逐个使用，并且应用程序将保持为WPF应用程序，那么推荐使用之前提到的轻量级数据库——LiteDB ([http://www.litedb.org/](http://www.litedb.org/))。
- en: If you are launching a large web application using a production, then MongoDB
    or a horizontally scalable database, such as Microsoft's CosmosDB would be recommended
    in order to ensure that the database lookups wouldn't be slower than simply re-performing
    the model prediction.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用生产环境启动大型Web应用程序，那么为了确保数据库查找不会比重新执行模型预测慢，建议使用MongoDB或水平可扩展的数据库，如微软的CosmosDB。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we have deep-dived into what goes into creating
    a WPF application using a pre-trained TensorFlow model. We also reviewed and looked
    closely into Google's image classification Inception model. In addition, we learned
    how to take that model and integrate it in order to perform image classification
    on user-selected images. Lastly, we also discussed some ways to further enhance
    the example application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们深入探讨了如何使用预训练的TensorFlow模型创建一个WPF应用程序。我们还回顾并仔细研究了谷歌的图像分类Inception模型。此外，我们学习了如何将这个模型集成到应用程序中，以便对用户选择的图像进行图像分类。最后，我们还讨论了一些进一步改进示例应用程序的方法。
- en: In the next and last chapter, we will focus on using a pre-trained ONNX model
    in a WPF application for object detection.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将专注于在WPF应用程序中使用预训练的ONNX模型进行目标检测。
