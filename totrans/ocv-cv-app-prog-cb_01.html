<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;Playing with Images"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Playing with Images</h1></div></div></div><p class="calibre8">In this chapter, we will get you started with the <code class="email">OpenCV</code> library. You will learn how to perform the following tasks:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Installing the OpenCV library</li><li class="listitem">Loading, displaying, and saving images</li><li class="listitem">Exploring the cv::Mat data structure</li><li class="listitem">Defining regions of interest</li></ul></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Playing with Images">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">This chapter will teach you the basic elements of OpenCV and will show you how to accomplish the most fundamental image processing tasks: reading, displaying, and saving images. However, before you can start with OpenCV, you need to install the library. This is a simple process that is explained in the first recipe of this chapter.</p><p class="calibre8">All your computer vision applications will involve the processing of images. This is why the most fundamental tool that OpenCV offers you is a data structure to handle images and matrices. It is a powerful data structure, with many useful attributes and methods. It also incorporates an advanced memory management model that greatly facilitates the development of applications. The last two recipes of this chapter will teach you how to use this important data structure of OpenCV.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Installing the OpenCV library"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Installing the OpenCV library</h1></div></div></div><p class="calibre8">OpenCV is<a id="id0" class="calibre1"/> an<a id="id1" class="calibre1"/> open source library for developing computer vision applications that run on Windows, Linux, Android, and Mac OS. It can be used in both academic and commercial applications under a BSD license that allows you to freely use, distribute, and adapt it. This recipe will show you how to install the library on your machine.</p></div>

<div class="book" title="Installing the OpenCV library">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec07" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">When you visit the<a id="id2" class="calibre1"/> OpenCV official website at <a class="calibre1" href="http://opencv.org/">http://opencv.org/</a>, you will find the latest release of the library, the online documentation, and many other useful resources on OpenCV.</p></div></div>

<div class="book" title="Installing the OpenCV library">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">From the<a id="id3" class="calibre1"/> OpenCV website, go to the <span class="strong"><strong class="calibre2">DOWNLOADS</strong></span> page that corresponds to the platform of your choice (Unix/Windows or Android). From there, you will be able to download the OpenCV package. You will then need to uncompress it, normally under a directory with a name that corresponds to the library version (for example, in Windows, you can save the uncompressed directory under <code class="email">C:\OpenCV2.4.9</code>). Once this is done, you will find a collection of files and directories that constitute the library at the chosen location. Notably, you will find the <code class="email">sources</code> directory here, which contains all the source files. (Yes, it is open source!) However, in order to complete the installation of the library and have it ready for use, you need to undertake an additional step: generating the binary files of the library for the environment of your choice. This is indeed the point where you have to make a decision on the target platform that you will use to create your OpenCV applications. Which operating system should you use? Windows or Linux? Which compiler should you use? Microsoft VS2013 or MinGW? 32-bit or 64-bit? The <span class="strong"><strong class="calibre2">Integrated Development Environment </strong></span>(<span class="strong"><strong class="calibre2">IDE</strong></span>)<a id="id4" class="calibre1"/> that you will use in your project development will also guide you to make these choices.</p><p class="calibre8">Note that if you are working under Windows with Visual Studio, the executable installation package will, most probably, not only install the library sources, but also install all of the precompiled binaries needed to build your applications. Check for the <code class="email">build</code> directory; it should contain the <code class="email">x64</code> and <code class="email">x86</code> subdirectories (corresponding to the 64-bit and 32-bit versions). Within these subdirectories, you should find directories such as <code class="email">vc10</code>, <code class="email">vc11</code>, and <code class="email">vc12</code>; these contain the binaries for the different versions of MS Visual Studio. In that case, you are ready to start using OpenCV. Therefore, you can skip the compilation step described in this recipe, unless you want a customized build with specific options.</p><p class="calibre8">To complete the installation process and build the OpenCV binaries, you need to use the <span class="strong"><strong class="calibre2">CMake</strong></span> tool, available <a id="id5" class="calibre1"/>at <a class="calibre1" href="http://cmake.org">http://cmake.org</a>. CMake <a id="id6" class="calibre1"/>is another open source software tool designed to control the compilation process of a software system using platform-independent configuration files. It generates the required <span class="strong"><strong class="calibre2">makefiles</strong></span><a id="id7" class="calibre1"/> or <span class="strong"><strong class="calibre2">workspaces</strong></span><a id="id8" class="calibre1"/> needed for compiling a software library in your environment. Therefore, you need to download and install CMake. You can then run it using the command line, but it is easier to use CMake with its GUI (<code class="email">cmake-gui</code>). In the latter case, all you need to do is specify the folder containing the OpenCV library source and the one that will contain the binaries. You need to click on <span class="strong"><strong class="calibre2">Configure</strong></span> in order to select the compiler of your choice and then click on <span class="strong"><strong class="calibre2">Configure</strong></span> again.</p><div class="mediaobject"><img src="../images/00002.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">You are <a id="id9" class="calibre1"/>now ready to generate your project files by clicking on the <span class="strong"><strong class="calibre2">Generate</strong></span> button. These files will allow you to compile the library. This is the last step of the installation process, which will make the library ready to be used under your development environment. For example, if you have selected Visual Studio, then all you need to do is to open the top-level solution file that CMake has created for you (most probably, the <code class="email">OpenCV.sln</code> file). You then issue the <code class="email">Build Solution</code> command in Visual Studio. To get both a <code class="email">Release</code> and a <code class="email">Debug</code> build, you will have to repeat the compilation process twice, one for each configuration. The <code class="email">bin</code> directory that is created contains the dynamic library files that your executable will call at runtime. Make sure to set your system <code class="email">PATH</code> environment variable from the control panel such that your operating system can find the <code class="email">dll</code> files when you run your applications.</p><div class="mediaobject"><img src="../images/00003.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In Linux environments, you will use the generated makefiles by running your <code class="email">make</code> utility command. To <a id="id10" class="calibre1"/>complete the installation of all the directories, you also have to run a <code class="email">Build INSTALL</code> or <code class="email">sudo make INSTALL</code> command.</p><p class="calibre8">However, before you build the libraries, make sure to check what the OpenCV installer has installed for you; the built library that you are looking for might already be there, which will save you the compilation step. If you wish to use Qt as your IDE, the <span class="strong"><em class="calibre9">There's more...</em></span> section of this recipe describes an alternative way to compile the OpenCV project.</p></div></div>

<div class="book" title="Installing the OpenCV library">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec09" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Since Version 2.2, the <a id="id11" class="calibre1"/>OpenCV library is divided into several modules. These modules are built-in library files located in the <code class="email">lib</code> directory. Some of the commonly-used modules are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <a id="id12" class="calibre1"/><code class="email">opencv_core</code> module<a id="id13" class="calibre1"/> that contains the core functionalities of the library, in particular, basic data structures and arithmetic functions</li><li class="listitem">The <a id="id14" class="calibre1"/><code class="email">opencv_imgproc</code> module<a id="id15" class="calibre1"/> that contains the main image processing functions</li><li class="listitem">The <a id="id16" class="calibre1"/><code class="email">opencv_highgui</code> module<a id="id17" class="calibre1"/> that contains the image and video reading and writing functions along with some user interface functions</li><li class="listitem">The <a id="id18" class="calibre1"/><code class="email">opencv_features2d</code> module<a id="id19" class="calibre1"/> that contains the feature point detectors and descriptors and the feature point matching framework</li><li class="listitem">The <a id="id20" class="calibre1"/><code class="email">opencv_calib3d</code> module<a id="id21" class="calibre1"/> that contains the camera calibration, two-view geometry estimation, and stereo functions</li><li class="listitem">The <a id="id22" class="calibre1"/><code class="email">opencv_video</code> module<a id="id23" class="calibre1"/> that contains the motion estimation, feature tracking, and foreground extraction functions and classes</li><li class="listitem">The <a id="id24" class="calibre1"/><code class="email">opencv_objdetect</code> module<a id="id25" class="calibre1"/> that contains the object detection functions such as the face and people detectors</li></ul></div><p class="calibre8">The library also includes other utility modules that contain machine learning functions (<code class="email">opencv_ml</code>), computational geometry algorithms (<code class="email">opencv_flann</code>), contributed code (<code class="email">opencv_contrib</code>), obsolete code (<code class="email">opencv_legacy</code>), and gpu-accelerated code (<code class="email">opencv_gpu</code>). You will also find other specialized libraries that implement higher-level functions, such as <code class="email">opencv_photo</code> for computational photography and <code class="email">opencv_stitching</code> for image-stitching algorithms. There is also a library module, called <code class="email">opencv_nonfree</code>, which contains functions that have a potential limitation in use. When you compile your application, you will have to link your program with the libraries that contain the OpenCV functions you are using. Most likely, these will be the first three functions of the list given previously plus some of the others depending on the scope of your application.</p><p class="calibre8">All these modules have a header file associated with them (located in the <code class="email">include</code> directory). A typical OpenCV C++ code will, therefore, start by including the required modules. For example (and this is the suggested declaration style):</p><div class="informalexample"><pre class="programlisting">#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip01" class="calibre1"/>Tip</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Downloading the example code</strong></span>
</p><p class="calibre8">You can download the example code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre8">You might see an OpenCV code starting with the following command:</p><div class="informalexample"><pre class="programlisting">#include "cv.h"</pre></div><p class="calibre8">This is because it uses the old style, before the library was restructured into modules. Finally, note that OpenCV will be restructured in the future; so, if you download a more recent version than 2.4, you will probably not see the same module subdivision.</p></div></div>

<div class="book" title="Installing the OpenCV library">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec10" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">The <a id="id26" class="calibre1"/>OpenCV website at <a class="calibre1" href="http://opencv.org/">http://opencv.org/</a> contains detailed instructions on how to install the library. It also contains a complete online documentation<a id="id27" class="calibre1"/> that includes several tutorials on the different components of the library.</p><div class="book" title="Using Qt for OpenCV developments"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Using Qt for OpenCV developments</h3></div></div></div><p class="calibre8">Qt is<a id="id28" class="calibre1"/> a <a id="id29" class="calibre1"/>cross-platform IDE for C++ applications developed as an open source project. It is offered under the LPGL open source license as well as under a commercial (and paid) license for the development of proprietary projects. It is composed of two separate elements: a cross-platform IDE called<a id="id30" class="calibre1"/> Qt creator and a set of Qt class libraries and development tools. Using Qt to develop C++ applications has the following <a id="id31" class="calibre1"/>benefits:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It is an open source initiative developed by the Qt community, which gives you access to the source code of the different Qt components</li><li class="listitem">It is a cross-platform IDE, meaning that you can develop applications that can run on different operating systems, such as Windows, Linux, Mac OS X, and so on</li><li class="listitem">It includes a complete and cross-platform GUI library that follows an effective object-oriented and event-driven model</li><li class="listitem">Qt also includes several cross-platform libraries that help you to develop multimedia, graphics, databases, multithreading, web applications, and many other interesting building blocks useful for designing advanced applications</li></ul></div><p class="calibre8">You can download <a id="id32" class="calibre1"/>Qt from <a class="calibre1" href="http://qt-project.org/">http://qt-project.org/</a>. When you install it, you will be offered the choice of different compilers. Under Windows, MinGW is an excellent alternative to the Visual Studio compilers.</p><p class="calibre8">Compiling the OpenCV library with Qt is particularly easy because it can read CMake files. Once OpenCV and CMake have been installed, simply select <span class="strong"><strong class="calibre2">Open File</strong></span> or <span class="strong"><strong class="calibre2">Project...</strong></span> from the Qt menu and open the <code class="email">CMakeLists.txt</code> file that you will find under the <code class="email">sources</code> directory of OpenCV. This will create an OpenCV project that you build using the <code class="email">Build Project</code> Qt command.</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Using Qt for OpenCV developments" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">You might get a<a id="id33" class="calibre1"/> few warnings, but these are without consequences.</p></div><div class="book" title="The OpenCV developer site"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>The OpenCV developer site</h3></div></div></div><p class="calibre8">OpenCV is <a id="id34" class="calibre1"/>an open source project that welcomes user contributions. You can access the developer site at <a class="calibre1" href="http://code.opencv.org">http://code.opencv.org</a>. Among other things, you can access the currently developed version of OpenCV. The community uses Git as their version control system. You then have to use it to check out the latest version of OpenCV. Git is also a free and open source software system; it is probably the best tool you can use to manage your own source code. You can download it from <a class="calibre1" href="http://git-scm.com/">http://git-scm.com/</a>.</p></div></div></div>

<div class="book" title="Installing the OpenCV library">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec11" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">My website (<a class="calibre1" href="http://www.laganiere.name">www.laganiere.name</a>) also presents step-by-step instructions on how to install the latest versions of the OpenCV library</li><li class="listitem">The <span class="strong"><em class="calibre9">There's more...</em></span> section of the next recipe explains how to create an OpenCV project with Qt</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Loading, displaying, and saving images"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Loading, displaying, and saving images</h1></div></div></div><p class="calibre8">It is now time <a id="id35" class="calibre1"/>to run your first OpenCV application. Since OpenCV is about processing images, this task will show you how to perform the most fundamental operations needed in the development of imaging applications. These are loading an input image from a file, displaying an image on a window, applying a processing function, and storing an output image on a disk.</p></div>

<div class="book" title="Loading, displaying, and saving images">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec12" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Using your favorite IDE (for example, MS Visual Studio or Qt), create a new console application with a <code class="email">main</code> function that is ready to be filled.</p></div></div>

<div class="book" title="Loading, displaying, and saving images">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec13" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">The first thing to do is to include the header files, declaring the classes and functions you will use. Here, we simply <a id="id36" class="calibre1"/>want to display an image, so we need the core library that <a id="id37" class="calibre1"/>declares the image data structure and the <code class="email">highgui</code> header file that contains all the graphical interface functions:</p><div class="informalexample"><pre class="programlisting">#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;</pre></div><p class="calibre8">Our main function starts by declaring a variable that will hold the image. Under OpenCV 2, define an object of the <code class="email">cv::Mat</code> class:</p><div class="informalexample"><pre class="programlisting">cv::Mat image; // create an empty image</pre></div><p class="calibre8">This definition creates an image of the size <code class="email">0 x 0</code>. This can be confirmed by accessing the <code class="email">cv::Mat</code> size attributes:</p><div class="informalexample"><pre class="programlisting">std::cout &lt;&lt; "This image is " &lt;&lt; image.rows &lt;&lt; " x " 
          &lt;&lt; image.cols &lt;&lt; std::endl;</pre></div><p class="calibre8">Next, a simple call to the reading function will read an image from the file, decode it, and allocate the memory:</p><div class="informalexample"><pre class="programlisting">image=  cv::imread("puppy.bmp"); // read an input image</pre></div><p class="calibre8">You are now ready to use this image. However, you should first check whether the image has been correctly read (an error will occur if the file is not found, if the file is corrupted, or if it is not in a recognizable format). The validity of the image is tested using the following code:</p><div class="informalexample"><pre class="programlisting">if (image.empty()) {  // error handling
   // no image has been created…
   // possibly display an error message
   // and quit the application 
   …
}</pre></div><p class="calibre8">The <code class="email">empty</code> method<a id="id38" class="calibre1"/> returns <code class="email">true</code> if no image data has been allocated.</p><p class="calibre8">The first <a id="id39" class="calibre1"/>thing you might want to do with this image is to display it. You can do this using the functions <a id="id40" class="calibre1"/>of the <code class="email">highgui</code> module. Start by <a id="id41" class="calibre1"/>declaring the window on which you want to display the images, and then specify the image to be shown on this special window:</p><div class="informalexample"><pre class="programlisting">// define the window (optional)
cv::namedWindow("Original Image");
// show the image 
cv::imshow("Original Image", image);</pre></div><p class="calibre8">As you can see, the window is identified by a name. You can reuse this window to display another image later, or you can create multiple windows with different names. When you run this application, you will see an image window as follows:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Now, you would normally apply some processing to the image. OpenCV offers a wide selection of processing functions, and several of them are explored in this book. Let's start with a very simple one that flips an image horizontally. Several image transformations in OpenCV can be performed <a id="id42" class="calibre1"/>
<span class="strong"><strong class="calibre2">in-place</strong></span>, meaning that the transformation is applied <a id="id43" class="calibre1"/>directly <a id="id44" class="calibre1"/>on the input image (no new image is created). This is <a id="id45" class="calibre1"/>the case of the flipping method. However, we can always create another matrix to hold the output result, and that is what we will do:</p><div class="informalexample"><pre class="programlisting">cv::Mat result; // we create another empty image
cv::flip(image,result,1); // positive for horizontal
                          // 0 for vertical,                     
                          // negative for both</pre></div><p class="calibre8">The result is displayed on another window:</p><div class="informalexample"><pre class="programlisting">cv::namedWindow("Output Image"); // the output window
cv::imshow("Output Image", result);</pre></div><p class="calibre8">Since it is a console window that will terminate when it reaches the end of the <code class="email">main</code> function, we add an extra <code class="email">highgui</code> function to wait for a user key before ending the program:</p><div class="informalexample"><pre class="programlisting">cv::waitKey(0); // 0 to indefinitely wait for a key pressed
                // specifying a positive value will wait for
                // the given amount of msec</pre></div><p class="calibre8">You can then see that the output image is displayed on a distinct window, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Finally, you will <a id="id46" class="calibre1"/>probably want to save the processed image on your disk. This is done using the following <code class="email">highgui</code> function:</p><div class="informalexample"><pre class="programlisting">cv::imwrite("output.bmp", result); // save result</pre></div><p class="calibre8">The file <a id="id47" class="calibre1"/>extension <a id="id48" class="calibre1"/>determines which codec will be used to save the image. Other popular supported image formats are JPG, TIFF, and PNG.</p></div></div>

<div class="book" title="Loading, displaying, and saving images">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec14" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">All classes and functions in the C++ API of OpenCV are defined within the <code class="email">cv</code> namespace. You have two ways to access them. First, precede the <code class="email">main</code> function's definition with the following declaration:</p><div class="informalexample"><pre class="programlisting">using namespace cv;</pre></div><p class="calibre8">Alternatively, prefix all OpenCV class and function names with the namespace specification, that is, <code class="email">cv::</code>, as we will do so in this book. The use of this prefix makes the OpenCV classes and functions easier to identify.</p><p class="calibre8">The <code class="email">highgui</code> module<a id="id49" class="calibre1"/> contains a set of functions that allow you to easily visualize and interact with your images. When you load an image with the <code class="email">imread</code> function, you also have the option to read it as a gray-level image. This is very advantageous since several computer vision algorithms require gray-level images. Converting an input color image on the fly as you read it will save you time and minimize your memory usage. This can be done as follows:</p><div class="informalexample"><pre class="programlisting">// read the input image as a gray-scale image
image=  cv::imread("puppy.bmp", CV_LOAD_IMAGE_GRAYSCALE);</pre></div><p class="calibre8">This will produce an image made of unsigned bytes (<code class="email">unsigned char</code> in C++) that OpenCV designates with the <code class="email">CV_8U</code> defined constant. Alternatively, it is sometimes necessary to read an image as a 3-channel color image even if it has been saved as a gray-level image. This can be achieved by calling the <code class="email">imread</code> function with a positive second argument:</p><div class="informalexample"><pre class="programlisting">// read the input image as a 3-channel color image
image=  cv::imread("puppy.bmp", CV_LOAD_IMAGE_COLOR);</pre></div><p class="calibre8">This time, an image made of 3 bytes per pixel will be created, designated as <code class="email">CV_8UC3</code> in OpenCV. Of course, if your input image has been saved as a gray-level image, all three channels will contain the same value. Finally, if you wish to read the image in the format in which it has been saved, then simply input a negative value as the second argument. The number of channels in an image can be checked by using the <code class="email">channels</code> method:</p><div class="informalexample"><pre class="programlisting">std::cout &lt;&lt; "This image has " 
          &lt;&lt; image.channels() &lt;&lt; " channel(s)";</pre></div><p class="calibre8">Pay attention when you open an image with <code class="email">imread</code> without specifying a full path (as we did here). In that case, the default directory will be used. When you run your application from the console, this directory is obviously the one of your executable file. However, if you run the <a id="id50" class="calibre1"/>application directly from your IDE, the default directory will most often be the one that contains your project file. Consequently, make sure that your input image file is located in the right directory.</p><p class="calibre8">When you <a id="id51" class="calibre1"/>use <code class="email">imshow</code> to display an image made up of integers (designated as <code class="email">CV_16U</code> for 16-bit unsigned integers, or as <code class="email">CV_32S</code> for 32-bit signed integers), the pixel values <a id="id52" class="calibre1"/>of this image will be divided by 256 first, in an attempt to make it displayable with 256 gray shades. Similarly, an image made of floating points will be displayed by assuming a range of possible values between 0.0 (displayed as black) and 1.0 (displayed as white). Values outside this defined range are displayed in white (for values above 1.0) or black (for values below 1.0).</p><p class="calibre8">The <code class="email">highgui</code> module<a id="id53" class="calibre1"/> is very useful to build quick prototypal applications. When you are ready to produce a finalized version of your application, you will probably want to use the GUI module offered by your IDE in order to build an application with a more professional look.</p><p class="calibre8">Here, our application uses both input and output images. As an exercise, you should rewrite this simple program such that it takes advantage of the function's in-place processing, that is, by not declaring the output image and writing it instead:</p><div class="informalexample"><pre class="programlisting">cv::flip(image,image,1); // in-place processing</pre></div></div></div>

<div class="book" title="Loading, displaying, and saving images">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec15" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">The <code class="email">highgui</code> module<a id="id54" class="calibre1"/> contains a rich set of functions that help you to interact with your images. Using these, your applications can react to mouse or key events. You can also draw shapes and write text on images.</p><div class="book" title="Clicking on images"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>Clicking on images</h3></div></div></div><p class="calibre8">You can program <a id="id55" class="calibre1"/>your mouse to perform specific operations when it is over one of the image windows you created. This is done by defining an appropriate <span class="strong"><strong class="calibre2">callback</strong></span> function. A callback function<a id="id56" class="calibre1"/> is a function that you do not explicitly call but which is called by your application in response to specific events (here, the events that concern the mouse interacting with an image window). To be recognized by applications, callback functions need to have a specific signature and must be registered. In the case of the mouse event handler, the callback function must have the following signature:</p><div class="informalexample"><pre class="programlisting">void onMouse( int event, int x, int y, int flags, void* param);</pre></div><p class="calibre8">The first parameter is an integer that is used to specify which type of mouse event has triggered the call to the callback function. The other two parameters are simply the pixel coordinates of the mouse location when the event occurred. The flags are used to determine which button was pressed when the mouse event was triggered. Finally, the last parameter is used to send an extra parameter to the function in the form of a pointer to any object. This callback function can be registered in the application through the following call:</p><div class="informalexample"><pre class="programlisting">cv::setMouseCallback("Original Image", onMouse, 
                     reinterpret_cast&lt;void*&gt;(&amp;image));</pre></div><p class="calibre8">In this example, the <code class="email">onMouse</code> function is associated with the image window called <span class="strong"><strong class="calibre2">Original Image</strong></span>, and the address of the displayed image is passed as an extra parameter to the function. Now, if we define the <code class="email">onMouse</code> callback function as shown in the following code, then each time the mouse is clicked, the value of the corresponding pixel will be displayed on the console (here, we assume that it is a gray-level image):</p><div class="informalexample"><pre class="programlisting">void onMouse( int event, int x, int y, int flags, void* param)  {

  cv::Mat *im= reinterpret_cast&lt;cv::Mat*&gt;(param);

  switch (event) {  // dispatch the event

    case CV_EVENT_LBUTTONDOWN: // left mouse button down event

      // display pixel value at (x,y)
      std::cout &lt;&lt; "at (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ") value is: " 
        &lt;&lt; static_cast&lt;int&gt;(
                  im-&gt;at&lt;uchar&gt;(cv::Point(x,y))) &lt;&lt; std::endl;
      break;
  }
}</pre></div><p class="calibre8">Note that in order <a id="id57" class="calibre1"/>to obtain the pixel value at <code class="email">(x,y)</code>, we used the <code class="email">at</code> method of the <code class="email">cv::Mat</code> object here; this has been discussed in <a class="calibre1" title="Chapter 2. Manipulating Pixels" href="part0019_split_000.html#page">Chapter 2</a>, <span class="strong"><em class="calibre9">Manipulating Pixels</em></span>. Other possible events that can be received by the mouse event callback function include <code class="email">CV_EVENT_MOUSEMOVE, CV_EVENT_LBUTTONUP</code>, <code class="email">CV_EVENT_RBUTTONDOWN</code>, and <code class="email">CV_EVENT_RBUTTONUP</code>.</p></div><div class="book" title="Drawing on images"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec04" class="calibre1"/>Drawing on images</h3></div></div></div><p class="calibre8">OpenCV also<a id="id58" class="calibre1"/> offers a few functions to draw shapes and write text on images. The examples of basic shape-drawing functions are <code class="email">circle</code>, <code class="email">ellipse</code>, <code class="email">line</code>, and <code class="email">rectangle</code>. The following is an example of how to use the <code class="email">circle</code> function:</p><div class="informalexample"><pre class="programlisting">cv::circle(image,             // destination image 
        cv::Point(155,110),   // center coordinate
        65,                   // radius  
        0,                    // color (here black)
        3);                   // thickness</pre></div><p class="calibre8">The <code class="email">cv::Point</code> structure<a id="id59" class="calibre1"/> is often used in OpenCV methods and functions to specify a pixel coordinate. Note that here we assume that the drawing is done on a gray-level image; this is why the color is specified with a single integer. In the next recipe, you will learn how to specify a color value in the case of color images that use the <code class="email">cv::Scalar</code> structure. It is also possible to write text on an image. This can be done as follows:</p><div class="informalexample"><pre class="programlisting">cv::putText(image,                  // destination image
        "This is a dog.",           // text
        cv::Point(40,200),          // text position
        cv::FONT_HERSHEY_PLAIN,     // font type
        2.0,                        // font scale
        255,                        // text color (here white)
        2);                         // text thickness</pre></div><p class="calibre8">Calling these two functions on our test image will then result in the following screenshot:</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Drawing on images" class="calibre10"/></div><p class="calibre11"> </p></div><div class="book" title="Running the example with Qt"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec05" class="calibre1"/>Running the example with Qt</h3></div></div></div><p class="calibre8">If you wish to use Qt to <a id="id60" class="calibre1"/>run your OpenCV applications, you <a id="id61" class="calibre1"/>will need to create project files. For the example of this recipe, here is how the project file (<code class="email">loadDisplaySave.pro</code>) will look:</p><div class="informalexample"><pre class="programlisting">QT       += core
QT       -= gui

TARGET = loadDisplaySave
CONFIG   += console
CONFIG   -= app_bundle

TEMPLATE = app

SOURCES += loadDisplaySave.cpp
INCLUDEPATH += C:\OpenCV2.4.9\build\include
LIBS += -LC:\OpenCV2.4.9\build\x86\MinGWqt32\lib \
-lopencv_core249 \
-lopencv_imgproc249 \
-lopencv_highgui249</pre></div><p class="calibre8">This file shows you where to find the <code class="email">include and library</code> files. It also lists the library modules that are used by the example. Make sure to use the library binaries compatible with the compiler that Qt is using. Note that if you download the source code of the examples of this book, you will find the <code class="email">CMakeLists</code> files that you can open with Qt (or CMake) in order to create the associated projects.</p></div></div></div>

<div class="book" title="Loading, displaying, and saving images">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec16" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">cv::Mat</code> class is the data structure that is used to hold your images (and obviously, other matrix data). This data structure is at the core of all OpenCV classes and functions; the next recipe offers a detailed explanation of this data structure.</li><li class="listitem">You can download the source code of the examples of this book from <a class="calibre1" href="https://github.com/laganiere/">https://github.com/laganiere/</a>.</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Exploring the cv::Mat data structure"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Exploring the cv::Mat data structure</h1></div></div></div><p class="calibre8">In the previous recipe, you <a id="id62" class="calibre1"/>were introduced to the <code class="email">cv::Mat</code> data structure. As mentioned, this is a key element of the library. It is used to manipulate images and matrices (in fact, an image is a matrix from a computational and mathematical point of view). Since you will be using this data structure extensively in your application developments, it is imperative that you become familiar with it. Notably, you will learn in this recipe that this data structure incorporates an elegant memory management mechanism, allowing efficient usage.</p></div>

<div class="book" title="Exploring the cv::Mat data structure">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec17" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Let's write the following test program that will allow us to test the different properties of the <code class="email">cv::Mat</code> data structure:</p><div class="informalexample"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;

// test function that creates an image
cv::Mat function() {
   // create image
   cv::Mat ima(500,500,CV_8U,50);
   // return it
   return ima;
}

int main() {
  // define image windows
  cv::namedWindow("Image 1"); 
  cv::namedWindow("Image 2"); 
  cv::namedWindow("Image 3"); 
  cv::namedWindow("Image 4"); 
  cv::namedWindow("Image 5"); 
  cv::namedWindow("Image"); 

  // create a new image made of 240 rows and 320 columns
  cv::Mat image1(240,320,CV_8U,100);

  cv::imshow("Image", image1); // show the image
  cv::waitKey(0); // wait for a key pressed

  // re-allocate a new image
  image1.create(200,200,CV_8U);
  image1= 200;

  cv::imshow("Image", image1); // show the image
  cv::waitKey(0); // wait for a key pressed

  // create a red color image
  // channel order is BGR
  cv::Mat image2(240,320,CV_8UC3,cv::Scalar(0,0,255));

  // or:
  // cv::Mat image2(cv::Size(320,240),CV_8UC3);
  // image2= cv::Scalar(0,0,255);

  cv::imshow("Image", image2); // show the image
  cv::waitKey(0); // wait for a key pressed

  // read an image
  cv::Mat image3=  cv::imread("puppy.bmp"); 

  // all these images point to the same data block
  cv::Mat image4(image3);
  image1= image3;

  // these images are new copies of the source image
  image3.copyTo(image2);
  cv::Mat image5= image3.clone();

  // transform the image for testing
  cv::flip(image3,image3,1); 

  // check which images have been affected by the processing
  cv::imshow("Image 3", image3); 
  cv::imshow("Image 1", image1); 
  cv::imshow("Image 2", image2); 
  cv::imshow("Image 4", image4); 
  cv::imshow("Image 5", image5); 
  cv::waitKey(0); // wait for a key pressed


  // get a gray-level image from a function
  cv::Mat gray= function();

  cv::imshow("Image", gray); // show the image
  cv::waitKey(0); // wait for a key pressed

  // read the image in gray scale
  image1= cv::imread("puppy.bmp", CV_LOAD_IMAGE_GRAYSCALE); 
  image1.convertTo(image2,CV_32F,1/255.0,0.0);

  cv::imshow("Image", image2); // show the image
  cv::waitKey(0); // wait for a key pressed

  return 0;
}</pre></div><p class="calibre8">Run this program <a id="id63" class="calibre1"/>and take a look at the following images produced:</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Exploring the cv::Mat data structure">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec18" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The <code class="email">cv::Mat</code> data structure <a id="id64" class="calibre1"/>is essentially made up of two parts: a header and a data block. The header contains all the information associated with the matrix (size, number of channels, data type, and so on). The previous recipe showed you how to access some of the attributes of this structure contained in its header (for example, by using <code class="email">cols</code>, <code class="email">rows</code>, or <code class="email">channels</code>). The data block holds all the pixel values of an image. The header contains a pointer variable that points to this data block; it is the <code class="email">data</code> attribute. An important property of the <code class="email">cv::Mat</code> data structure is the fact that the memory block is only copied when explicitly requested for. Indeed, most operations will simply copy the <code class="email">cv::Mat</code> header such that multiple objects will point to the same data block at the same time. This memory management model makes your applications more efficient while avoiding memory leaks, but its consequences have to be understood. The examples of this recipe illustrate this fact.</p><p class="calibre8">By default, the <code class="email">cv::Mat</code> objects have a zero size when they are created, but you can also specify an initial size as follows:</p><div class="informalexample"><pre class="programlisting">// create a new image made of 240 rows and 320 columns
cv::Mat image1(240,320,CV_8U,100);</pre></div><p class="calibre8">In this case, you also need to specify the type of each matrix element; <code class="email">CV_8U</code> here, which corresponds to 1-byte pixel images. The letter <code class="email">U</code> means it is unsigned. You can also declare signed numbers by using the letter <code class="email">S</code>. For a color image, you would specify three channels (<code class="email">CV_8UC3</code>). You can also declare integers (signed or unsigned) of size 16 and 32 (for example, <code class="email">CV_16SC3</code>). You also have access to 32-bit and 64-bit floating-point numbers (for example, <code class="email">CV_32F</code>).</p><p class="calibre8">Each element of an image (or a matrix) can be composed of more than one value (for example, the three channels of a color image); therefore, OpenCV has introduced a simple data structure that is used when pixel values are passed to functions. It is the <code class="email">cv::Scalar</code> structure, which is generally used to hold one value or three values. For example, to create a color image initialized with red pixels, you will write the following code:</p><div class="informalexample"><pre class="programlisting">// create a red color image
// channel order is BGR
cv::Mat image2(240,320,CV_8UC3,cv::Scalar(0,0,255));</pre></div><p class="calibre8">Similarly, the <a id="id65" class="calibre1"/>initialization of the gray-level image could also have been done using this structure by writing <code class="email">cv::Scalar(100)</code>.</p><p class="calibre8">The image size also often needs to be passed to functions. We have already mentioned that the <code class="email">cols</code> and <code class="email">rows</code> attributes can be used to get the dimensions of a <code class="email">cv::Mat</code> instance. The size information can also be provided through the <code class="email">cv::Size</code> structure that simply contains the height and width of the matrix. The <code class="email">size()</code> method allows you to obtain the current matrix size. This is the format that is used in many methods where a matrix size must be specified.</p><p class="calibre8">For example, an image could be created as follows:</p><div class="informalexample"><pre class="programlisting">// create a non-initialized color image 
cv::Mat image2(cv::Size(320,240),CV_8UC3);</pre></div><p class="calibre8">The data block of an image can always be allocated or re-allocated using the <code class="email">create</code> method. When an image has been previously allocated, its old content is de-allocated first. For reasons of efficiency, if the new proposed size and type matches the already existing size and type, then no new memory allocation is performed:</p><div class="informalexample"><pre class="programlisting">// re-allocate a new image
// (only if size or type are different)
image1.create(200,200,CV_8U);</pre></div><p class="calibre8">When no more references point to a given <code class="email">cv::Mat</code> object, the allocated memory is automatically released. This is very convenient because it avoids the common memory leak problems often associated with dynamic memory allocation in C++. This is a key mechanism in OpenCV 2 that is accomplished by having the <code class="email">cv::Mat</code> class implement reference counting and shallow copy. Therefore, when an image is assigned to another one, the image data (that is, the pixels) is not copied; both the images will point to the same memory block. This also applies to images passed by value or returned by value. A reference count is kept such that the memory will be released only when all the references to the image will be destructed or assigned to another image:</p><div class="informalexample"><pre class="programlisting">// all these images point to the same data block
cv::Mat image4(image3);
image1= image3;</pre></div><p class="calibre8">Any transformation applied to one of the preceding images will also affect the other images. If you wish <a id="id66" class="calibre1"/>to create a deep copy of the content of an image, use the <code class="email">copyTo</code> method. In that case, the <code class="email">create</code> method is called on the destination image. Another method that produces a copy of an image is the <code class="email">clone</code> method, which creates a new identical image as follows:</p><div class="informalexample"><pre class="programlisting">// these images are new copies of the source image
image3.copyTo(image2);
cv::Mat image5= image3.clone();</pre></div><p class="calibre8">If you need to copy an image into another image that does not necessarily have the same data type, you have to use the <code class="email">convertTo</code> method:</p><div class="informalexample"><pre class="programlisting">// convert the image into a floating point image [0,1]
image1.convertTo(image2,CV_32F,1/255.0,0.0);</pre></div><p class="calibre8">In this example, the source image is copied into a floating-point image. The method includes two optional parameters: a scaling factor and an offset. Note that both the images must, however, have the same number of channels.</p><p class="calibre8">The allocation model for the <code class="email">cv::Mat</code> objects also allows you to safely write functions (or class methods) that return an image:</p><div class="informalexample"><pre class="programlisting">cv::Mat function() {

   // create image
   cv::Mat ima(240,320,CV_8U,cv::Scalar(100));
   // return it
   return ima;
}</pre></div><p class="calibre8">We can also call this function from our <code class="email">main</code> function as follows:</p><div class="informalexample"><pre class="programlisting">   // get a gray-level image
   cv::Mat gray= function();</pre></div><p class="calibre8">If we do this, then the <code class="email">gray</code> variable will now hold the image created by the function without extra memory allocation. Indeed, as we explained, only a shallow copy of the image will be transferred from the returned <code class="email">cv::Mat</code> instance to the <code class="email">gray</code> image. When the <code class="email">ima</code> local variable goes out of scope, this variable is de-allocated, but since the associated reference counter indicates that its internal image data is being referred to by another instance (that is, the <code class="email">gray</code> variable), its memory block is not released.</p><p class="calibre8">It's worth noting that in the case of classes, you should be careful and not return image class attributes. Here is an example of an error-prone implementation:</p><div class="informalexample"><pre class="programlisting">class Test {
   // image attribute
   cv::Mat ima;
  public:
     // constructor creating a gray-level image
     Test() : ima(240,320,CV_8U,cv::Scalar(100)) {}

     // method return a class attribute, not a good idea...
     cv::Mat method() { return ima; }
};</pre></div><p class="calibre8">Here, if a function <a id="id67" class="calibre1"/>calls the method of this class, it obtains a shallow copy of the image attributes. If later this copy is modified, the <code class="email">class</code> attribute will also be surreptitiously modified, which can affect the subsequent behavior of the class (and vice versa). To avoid these kinds of errors, you should instead return a clone of the attribute.</p></div></div>

<div class="book" title="Exploring the cv::Mat data structure">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec19" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">When you are manipulating the <code class="email">cv::Mat</code> class, you will discover that OpenCV also includes several other related classes. It will be important for you to become familiar with them.</p><div class="book" title="The input and output arrays"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec06" class="calibre1"/>The input and output arrays</h3></div></div></div><p class="calibre8">If you look at <a id="id68" class="calibre1"/>the OpenCV documentation, you will see that many methods and functions accept parameters of the <a id="id69" class="calibre1"/>
<code class="email">cv::InputArray</code> type as the input. This type is a simple proxy class introduced to generalize the concept of arrays in OpenCV, and thus avoid<a id="id70" class="calibre1"/> the duplication of several versions of the same method or function with different input parameter types. It basically means that you can supply a <code class="email">cv::Mat</code> object or other compatible types as an argument. This class is just an interface, so you should never declare it explicitly in your code. It is interesting to know that <code class="email">cv::InputArray</code> can also be constructed from the popular <code class="email">std::vector</code> class. This means that such objects can be used as the input to OpenCV methods and functions (as long as it makes sense to do so). Other compatible types are the <code class="email">cv::Scalar</code> and the <code class="email">cv::Vec</code>; this later structure will be presented in the next chapter. There is also a <code class="email">cv::OutputArray</code><a id="id71" class="calibre1"/> proxy class that is used to designate the arrays returned by some methods or functions.</p></div><div class="book" title="The old IplImage structure"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec07" class="calibre1"/>The old IplImage structure</h3></div></div></div><p class="calibre8">With <a id="id72" class="calibre1"/>Version 2 of OpenCV, a new C++ interface has been introduced. Previously, C-like functions and structures were used (and can still be used). In particular, images were manipulated using the <code class="email">IplImage</code> structure. This structure <a id="id73" class="calibre1"/>was inherited from the<a id="id74" class="calibre1"/> <span class="strong"><strong class="calibre2">IPL</strong></span> library (that is, the <span class="strong"><strong class="calibre2">Intel Image Processing</strong></span> library), now integrated with the<a id="id75" class="calibre1"/> <span class="strong"><strong class="calibre2">IPP</strong></span> library (the <span class="strong"><strong class="calibre2">Intel Integrated Performance Primitive</strong></span> library). If you use the code and libraries that have been created with the old C interface, you might need to manipulate those <code class="email">IplImage</code> structures. Fortunately, there is a convenient way to convert an <code class="email">IplImage</code> structure into<a id="id76" class="calibre1"/> a <code class="email">cv::Mat</code> object, which is shown in the following code:</p><div class="informalexample"><pre class="programlisting">IplImage* iplImage = cvLoadImage("puppy.bmp");
cv::Mat image(iplImage,false);</pre></div><p class="calibre8">The <code class="email">cvLoadImage</code> function<a id="id77" class="calibre1"/> is the C-interface function to load images. The second parameter in the constructor of the <code class="email">cv::Mat</code> object indicates that the data will not be copied (set this to <code class="email">true</code> if you want a new copy; <code class="email">false</code> is the default value, so it could have been omitted), that is, both <code class="email">IplImage</code> and <code class="email">image</code> will share the same image data. Here, you need to be careful to not create dangling pointers. For this reason, it is safer to encapsulate the <code class="email">IplImage</code> pointer in the reference-counting pointer class provided by OpenCV 2:</p><div class="informalexample"><pre class="programlisting">cv::Ptr&lt;IplImage&gt; iplImage = cvLoadImage("puppy.bmp");</pre></div><p class="calibre8">Otherwise, if you need to de-allocate the memory pointed out by your <code class="email">IplImage</code> structure, you need to do it explicitly:</p><div class="informalexample"><pre class="programlisting">cvReleaseImage(&amp;iplImage);</pre></div><p class="calibre8">Remember that <a id="id78" class="calibre1"/>you should avoid using this deprecated data structure. Instead, always use the <code class="email">cv::Mat</code> data structure.</p></div></div></div>

<div class="book" title="Exploring the cv::Mat data structure">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec20" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The complete OpenCV documentation can be found at <a class="calibre1" href="http://docs.opencv.org/">http://docs.opencv.org/</a></li><li class="listitem"><a class="calibre1" title="Chapter 2. Manipulating Pixels" href="part0019_split_000.html#page">Chapter 2</a>, <span class="strong"><em class="calibre9">Manipulating Pixels</em></span>, will show you how to efficiently access and modify the pixel values of an image represented by the <code class="email">cv::Mat</code> class</li><li class="listitem">The next recipe, which will explain how to define a region of interest inside an image</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Defining regions of interest"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Defining regions of interest</h1></div></div></div><p class="calibre8">Sometimes, a <a id="id79" class="calibre1"/>processing function needs to be applied only to a portion <a id="id80" class="calibre1"/>of an image. OpenCV incorporates an elegant and simple mechanism to define a subregion in an image and manipulate it as a regular image. This recipe will teach you how to define a region of interest inside an image.</p></div>

<div class="book" title="Defining regions of interest">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec21" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Suppose we want to copy a small image onto a larger one. For example, let's say we want to insert the following small logo in our test image:</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">To do this, a <span class="strong"><strong class="calibre2">Region Of Interest</strong></span> (<span class="strong"><strong class="calibre2">ROI</strong></span>) can be defined over which the copy operation can be applied. As we will see, the position of the ROI will determine where the logo will be inserted in the image.</p></div></div>

<div class="book" title="Defining regions of interest">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec22" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">The first step <a id="id81" class="calibre1"/>consists<a id="id82" class="calibre1"/> of defining the ROI. Once defined, the ROI can be manipulated as a regular <code class="email">cv::Mat</code> instance. The key is that the ROI is indeed a <code class="email">cv::Mat</code> object that points to the same data buffer as its parent image and has a header that specifies the coordinates of the ROI. Inserting the logo would then be accomplished as follows:</p><div class="informalexample"><pre class="programlisting">  // define image ROI at image bottom-right
  cv::Mat imageROI(image, 
              cv::Rect(image.cols-logo.cols, //ROI coordinates
                       image.rows-logo.rows,
                       logo.cols,logo.rows));// ROI size

  // insert logo
  logo.copyTo(imageROI);</pre></div><p class="calibre8">Here, <code class="email">image</code> is the destination image, and <code class="email">logo</code> is the logo image (of a smaller size). The following image is then obtained by executing the previous code:</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Defining regions of interest">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec23" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">One way to <a id="id83" class="calibre1"/>define an ROI is to use a <code class="email">cv::Rect</code> instance. As the name indicates, it <a id="id84" class="calibre1"/>describes a rectangular region by specifying the position of the upper-left corner (the first two parameters of the constructor) and the size of the rectangle (the width and height are given in the last two parameters). In our example, we used the size of the image and the size of the logo in order to determine the position where the logo would cover the bottom-right corner of the image. Obviously, the ROI should always be completely inside the parent image.</p><p class="calibre8">The ROI can also be described using row and column ranges. A range is a continuous sequence from a start index to an end index (excluding both). The <a id="id85" class="calibre1"/>
<code class="email">cv::Range</code> structure is used to represent this concept. Therefore, an ROI can be defined from two ranges; in our example, the ROI could have been equivalently defined as follows:</p><div class="informalexample"><pre class="programlisting">imageROI= image(cv::Range(image.rows-logo.rows,image.rows), 
                cv::Range(image.cols-logo.cols,image.cols));</pre></div><p class="calibre8">In this case, the <code class="email">operator()</code> function of <code class="email">cv ::Mat</code> returns another <code class="email">cv::Mat</code> instance that can then be used in subsequent calls. Any transformation of the ROI will affect the original image in the corresponding area because the image and the ROI share the same image data. Since the definition of an ROI does not include the copying of data, it is executed in a constant amount of time, no matter the size of the ROI.</p><p class="calibre8">If you want to define an ROI made of some lines of an image, the following call can be used:</p><div class="informalexample"><pre class="programlisting">cv::Mat imageROI= image.rowRange(start,end);</pre></div><p class="calibre8">Similarly, for an ROI made of some image columns, the following can be used:</p><div class="informalexample"><pre class="programlisting">cv::Mat imageROI= image.colRange(start,end);</pre></div></div></div>

<div class="book" title="Defining regions of interest">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec24" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">The OpenCV methods and functions include many optional parameters that are not discussed in the recipes of this book. When you wish to use a function for the first time, you should always take the time to look at the documentation to learn more about the possible options that this function offers. One very common option is the possibility to define image masks.</p><div class="book" title="Using image masks"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec08" class="calibre1"/>Using image masks</h3></div></div></div><p class="calibre8">Some <a id="id86" class="calibre1"/>OpenCV operations allow you to define a mask that will limit the applicability of a given function or method, which is normally supposed to operate on all the image pixels. A mask is an 8-bit image that should be nonzero at all locations where you want an operation to be applied. At the pixel locations that correspond to the zero values of the mask, the image is untouched. For example, the <code class="email">copyTo</code> method can be called with a mask. We can use it here to copy only the white portion of the<a id="id87" class="calibre1"/> logo shown previously, as follows:</p><div class="informalexample"><pre class="programlisting">// define image ROI at image bottom-right
imageROI= image(cv::Rect(image.cols-logo.cols,
                         image.rows-logo.rows,
                       logo.cols,logo.rows));
// use the logo as a mask (must be gray-level)
cv::Mat mask(logo);

// insert by copying only at locations of non-zero mask
logo.copyTo(imageROI,mask);</pre></div><p class="calibre8">The following image is obtained by executing the previous code:</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Using image masks" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The background of our logo was black (therefore, it had the value 0); therefore, it was easy to use it as both the copied image and the mask. Of course, you can define the mask of your choice in your application; most OpenCV pixel-based operations give you the opportunity to use masks.</p></div></div></div>

<div class="book" title="Defining regions of interest">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec25" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">row</code> and <code class="email">col</code> methods that will be used in the <span class="strong"><em class="calibre9">Scanning an image with neighbor access</em></span> recipe of <a class="calibre1" title="Chapter 2. Manipulating Pixels" href="part0019_split_000.html#page">Chapter 2</a>, <span class="strong"><em class="calibre9">Manipulating Pixels</em></span>. These are a special case of the <code class="email">rowRange</code> and <code class="email">colRange</code> methods in which the start and end indexes are equal in order to define a single-line or single-column ROI.</li></ul></div></div></div></body></html>