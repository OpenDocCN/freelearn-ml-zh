["```py\nimport sys\n\nimport cv2\nimport numpy as np\n\n# Draw vertical seam on top of the image\ndef overlay_vertical_seam(img, seam):\n    img_seam_overlay = np.copy(img) x\n\n    # Extract the list of points from the seam\n    x_coords, y_coords = np.transpose([(i,int(j)) for i,j in enumerate(seam)])\n\n    # Draw a green line on the image using the list of points\n    img_seam_overlay[x_coords, y_coords] = (0,255,0)\n    return img_seam_overlay\n\n# Compute the energy matrix from the input image\ndef compute_energy_matrix(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    # Compute X derivative of the image\n    sobel_x = cv2.Sobel(gray,cv2.CV_64F,1,0,ksize=3)\n\n    # Compute Y derivative of the image\n    sobel_y = cv2.Sobel(gray,cv2.CV_64F,0,1,ksize=3)\n\n    abs_sobel_x = cv2.convertScaleAbs(sobel_x)\n    abs_sobel_y = cv2.convertScaleAbs(sobel_y)\n\n    # Return weighted summation of the two images i.e. 0.5*X + 0.5*Y\n    return cv2.addWeighted(abs_sobel_x, 0.5, abs_sobel_y, 0.5, 0)\n\n# Find vertical seam in the input image\ndef find_vertical_seam(img, energy):\n    rows, cols = img.shape[:2]\n\n    # Initialize the seam vector with 0 for each element\n    seam = np.zeros(img.shape[0])\n\n    # Initialize distance and edge matrices\n    dist_to = np.zeros(img.shape[:2]) + sys.maxint\n    dist_to[0,:] = np.zeros(img.shape[1])\n    edge_to = np.zeros(img.shape[:2])\n\n    # Dynamic programming; iterate using double loop and compute the paths efficiently\n    for row in xrange(rows-1):\n        for col in xrange(cols):\n            if col != 0:\n                if dist_to[row+1, col-1] > dist_to[row, col] + energy[row+1, col-1]:\n                    dist_to[row+1, col-1] = dist_to[row, col] + energy[row+1, col-1]\n                    edge_to[row+1, col-1] = 1\n\n            if dist_to[row+1, col] > dist_to[row, col] + energy[row+1, col]:\n                dist_to[row+1, col] = dist_to[row, col] + energy[row+1, col]\n                edge_to[row+1, col] = 0\n\n            if col != cols-1:\n                if dist_to[row+1, col+1] > dist_to[row, col] + energy[row+1, col+1]:\n                    dist_to[row+1, col+1] = dist_to[row, col] + energy[row+1, col+1]\n                    edge_to[row+1, col+1] = -1\n\n    # Retracing the path\n    seam[rows-1] = np.argmin(dist_to[rows-1, :])\n    for i in (x for x in reversed(xrange(rows)) if x > 0):\n        seam[i-1] = seam[i] + edge_to[i, int(seam[i])]\n\n    return seam\n\n# Remove the input vertical seam from the image\ndef remove_vertical_seam(img, seam):\n    rows, cols = img.shape[:2]\n\n    # To delete a point, move every point after it one step towards the left\n    for row in xrange(rows):\n        for col in xrange(int(seam[row]), cols-1):\n            img[row, col] = img[row, col+1]\n\n    # Discard the last column to create the final output image\n    img = img[:, 0:cols-1]\n    return img\n\nif __name__=='__main__':\n    # Make sure the size of the input image is reasonable.\n    # Large images take a lot of time to be processed.\n    # Recommended size is 640x480.\n    img_input = cv2.imread(sys.argv[1])\n\n    # Use a small number to get started. Once you get an\n    # idea of the processing time, you can use a bigger number.\n    # To get started, you can set it to 20.\n    num_seams = int(sys.argv[2])\n\n    img = np.copy(img_input)\n    img_overlay_seam = np.copy(img_input)\n    energy = compute_energy_matrix(img)\n\n    for i in xrange(num_seams):\n        seam = find_vertical_seam(img, energy)\n        img_overlay_seam = overlay_vertical_seam(img_overlay_seam, seam)\n        img = remove_vertical_seam(img, seam)\n        energy = compute_energy_matrix(img)\n        print 'Number of seams removed =', i+1\n\n    cv2.imshow('Input', img_input)\n    cv2.imshow('Seams', img_overlay_seam)\n    cv2.imshow('Output', img)\n    cv2.waitKey()\n```", "```py\nimport sys\n\nimport cv2\nimport numpy as np\n\n# Compute the energy matrix from the input image\ndef compute_energy_matrix(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    sobel_x = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)\n    sobel_y = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)\n    abs_sobel_x = cv2.convertScaleAbs(sobel_x)\n    abs_sobel_y = cv2.convertScaleAbs(sobel_y)\n    return cv2.addWeighted(abs_sobel_x, 0.5, abs_sobel_y, 0.5, 0)\n\n# Find the vertical seam\ndef find_vertical_seam(img, energy):\n    rows, cols = img.shape[:2]\n\n    # Initialize the seam vector with 0 for each element\n    seam = np.zeros(img.shape[0])\n\n    # Initialize distance and edge matrices\n    dist_to = np.zeros(img.shape[:2]) + sys.maxint\n    dist_to[0,:] = np.zeros(img.shape[1])\n    edge_to = np.zeros(img.shape[:2])\n\n    # Dynamic programming; iterate using double loop and compute\n    #the paths efficiently\n    for row in xrange(rows-1):\n        for col in xrange(cols):\n            if col != 0:\n                if dist_to[row+1, col-1] > dist_to[row, col] + energy[row+1, col-1]:\n                    dist_to[row+1, col-1] = dist_to[row, col] + energy[row+1, col-1]\n                    edge_to[row+1, col-1] = 1\n\n            if dist_to[row+1, col] > dist_to[row, col] + energy[row+1, col]:\n                dist_to[row+1, col] = dist_to[row, col] + energy[row+1, col]\n                edge_to[row+1, col] = 0\n\n            if col != cols-1:\n                if dist_to[row+1, col+1] > dist_to[row, col] + energy[row+1, col+1]:\n                    dist_to[row+1, col+1] = dist_to[row, col] + energy[row+1, col+1]\n                    edge_to[row+1, col+1] = -1\n\n    # Retracing the path\n    seam[rows-1] = np.argmin(dist_to[rows-1, :])\n    for i in (x for x in reversed(xrange(rows)) if x > 0):\n        seam[i-1] = seam[i] + edge_to[i, int(seam[i])]\n\n    return seam\n\n# Add a vertical seam to the image\ndef add_vertical_seam(img, seam, num_iter):\n    seam = seam + num_iter\n    rows, cols = img.shape[:2]\n    zero_col_mat = np.zeros((rows,1,3), dtype=np.uint8)\n    img_extended = np.hstack((img, zero_col_mat))\n\n    for row in xrange(rows):\n        for col in xrange(cols, int(seam[row]), -1):\n            img_extended[row, col] = img[row, col-1]\n\n        # To insert a value between two columns, take the average # value of the neighbors. It looks smooth this way and we # can avoid unwanted artifacts.\n        for i in range(3):\n            v1 = img_extended[row, int(seam[row])-1, i]\n            v2 = img_extended[row, int(seam[row])+1, i]\n            img_extended[row, int(seam[row]), i] = (int(v1)+int(v2))/2\n\n    return img_extended\n\n# Remove vertical seam from the image\ndef remove_vertical_seam(img, seam):\n    rows, cols = img.shape[:2]\n    for row in xrange(rows):\n        for col in xrange(int(seam[row]), cols-1):\n            img[row, col] = img[row, col+1]\n\n    img = img[:, 0:cols-1]\n    return img\n\nif __name__=='__main__':\n    img_input = cv2.imread(sys.argv[1])\n    num_seams = int(sys.argv[2])\n    img = np.copy(img_input)\n    img_output = np.copy(img_input)\n    energy = compute_energy_matrix(img)\n\n    for i in xrange(num_seams):\n        seam = find_vertical_seam(img, energy)\n        img = remove_vertical_seam(img, seam)\n        img_output = add_vertical_seam(img_output, seam, i)\n        energy = compute_energy_matrix(img)\n        print 'Number of seams added =', i+1\n\n    cv2.imshow('Input', img_input)\n    cv2.imshow('Output', img_output)\n    cv2.waitKey()\n```", "```py\nimport sys\n\nimport cv2\nimport numpy as np\n\n# Draw rectangle on top of the input image\ndef draw_rectangle(event, x, y, flags, params):\n    global x_init, y_init, drawing, top_left_pt, bottom_right_pt, img_orig\n\n    # Detecting a mouse click\n    if event == cv2.EVENT_LBUTTONDOWN:\n        drawing = True\n        x_init, y_init = x, y\n\n    # Detecting mouse movement\n    elif event == cv2.EVENT_MOUSEMOVE:\n        if drawing:\n            top_left_pt, bottom_right_pt = (x_init,y_init), (x,y)\n            img[y_init:y, x_init:x] = 255 - img_orig[y_init:y, x_init:x]\n            cv2.rectangle(img, top_left_pt, bottom_right_pt, (0,255,0), 2)\n\n    # Detecting the mouse button up event\n    elif event == cv2.EVENT_LBUTTONUP:\n        drawing = False\n        top_left_pt, bottom_right_pt = (x_init,y_init), (x,y)\n\n        # Create the \"negative\" film effect for the selected # region\n        img[y_init:y, x_init:x] = 255 - img[y_init:y, x_init:x]\n\n        # Draw rectangle around the selected region\n        cv2.rectangle(img, top_left_pt, bottom_right_pt, (0,255,0), 2)\n        rect_final = (x_init, y_init, x-x_init, y-y_init)\n\n        # Remove the object in the selected region\n        remove_object(img_orig, rect_final)\n\n# Computing the energy matrix using modified algorithm\ndef compute_energy_matrix_modified(img, rect_roi):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    # Compute the X derivative\n    sobel_x = cv2.Sobel(gray,cv2.CV_64F,1,0,ksize=3)\n\n    # Compute the Y derivative\n    sobel_y = cv2.Sobel(gray,cv2.CV_64F,0,1,ksize=3)\n    abs_sobel_x = cv2.convertScaleAbs(sobel_x)\n    abs_sobel_y = cv2.convertScaleAbs(sobel_y)\n\n    # Compute weighted summation i.e. 0.5*X + 0.5*Y\n    energy_matrix = cv2.addWeighted(abs_sobel_x, 0.5, abs_sobel_y, 0.5, 0)\n    x,y,w,h = rect_roi\n\n    # We want the seams to pass through this region, so make sure the energy values in this region are set to 0\n    energy_matrix[y:y+h, x:x+w] = 0\n\n    return energy_matrix\n\n# Compute energy matrix\ndef compute_energy_matrix(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    # Compute X derivative\n    sobel_x = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)\n\n    # Compute Y derivative\n    sobel_y = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)\n    abs_sobel_x = cv2.convertScaleAbs(sobel_x)\n    abs_sobel_y = cv2.convertScaleAbs(sobel_y)\n\n    # Return weighted summation i.e. 0.5*X + 0.5*Y\n    return cv2.addWeighted(abs_sobel_x, 0.5, abs_sobel_y, 0.5, 0)\n\n# Find the vertical seam\ndef find_vertical_seam(img, energy):\n    rows, cols = img.shape[:2]\n\n    # Initialize the seam vector\n    seam = np.zeros(img.shape[0])\n\n    # Initialize the distance and edge matrices\n    dist_to = np.zeros(img.shape[:2]) + sys.maxint\n    dist_to[0,:] = np.zeros(img.shape[1])\n    edge_to = np.zeros(img.shape[:2])\n\n    # Dynamic programming; using double loop to compute the paths\n    for row in xrange(rows-1):\n        for col in xrange(cols):\n            if col != 0:\n                if dist_to[row+1, col-1] > dist_to[row, col] + energy[row+1, col-1]:\n                    dist_to[row+1, col-1] = dist_to[row, col] + energy[row+1, col-1]\n                    edge_to[row+1, col-1] = 1\n\n            if dist_to[row+1, col] > dist_to[row, col] + energy[row+1, col]:\n                dist_to[row+1, col] = dist_to[row, col] + energy[row+1, col]\n                edge_to[row+1, col] = 0\n\n            if col != cols-1:\n                if dist_to[row+1, col+1] > dist_to[row, col] + energy[row+1, col+1]:\n                    dist_to[row+1, col+1] = dist_to[row, col] + energy[row+1, col+1]\n                    edge_to[row+1, col+1] = -1\n\n    # Retracing the path\n    seam[rows-1] = np.argmin(dist_to[rows-1, :])\n    for i in (x for x in reversed(xrange(rows)) if x > 0):\n        seam[i-1] = seam[i] + edge_to[i, int(seam[i])]\n\n    return seam\n\n# Add vertical seam to the input image\ndef add_vertical_seam(img, seam, num_iter):\n    seam = seam + num_iter\n    rows, cols = img.shape[:2]\n    zero_col_mat = np.zeros((rows,1,3), dtype=np.uint8)\n    img_extended = np.hstack((img, zero_col_mat))\n\n    for row in xrange(rows):\n        for col in xrange(cols, int(seam[row]), -1):\n            img_extended[row, col] = img[row, col-1]\n\n        # To insert a value between two columns, take the average # value of the neighbors. It looks smooth this way and we # can avoid unwanted artifacts.\n        for i in range(3):\n            v1 = img_extended[row, int(seam[row])-1, i]\n            v2 = img_extended[row, int(seam[row])+1, i]\n            img_extended[row, int(seam[row]), i] = (int(v1)+int(v2))/2\n\n    return img_extended\n\n# Remove vertical seam\ndef remove_vertical_seam(img, seam):\n    rows, cols = img.shape[:2]\n    for row in xrange(rows):\n        for col in xrange(int(seam[row]), cols-1):\n            img[row, col] = img[row, col+1]\n\n    img = img[:, 0:cols-1]\n    return img\n\n# Remove the object from the input region of interest\ndef remove_object(img, rect_roi):\n    num_seams = rect_roi[2] + 10\n    energy = compute_energy_matrix_modified(img, rect_roi)\n\n    # Start a loop and remove one seam at a time\n    for i in xrange(num_seams):\n        # Find the vertical seam that can be removed\n        seam = find_vertical_seam(img, energy)\n\n        # Remove that vertical seam\n        img = remove_vertical_seam(img, seam)\n        x,y,w,h = rect_roi\n\n        # Compute energy matrix after removing the seam\n        energy = compute_energy_matrix_modified(img, (x,y,w-i,h))\n        print 'Number of seams removed =', i+1\n\n    img_output = np.copy(img)\n\n    # Fill up the region with surrounding values so that the size # of the image remains unchanged\n    for i in xrange(num_seams):\n        seam = find_vertical_seam(img, energy)\n        img = remove_vertical_seam(img, seam)\n        img_output = add_vertical_seam(img_output, seam, i)\n        energy = compute_energy_matrix(img)\n        print 'Number of seams added =', i+1\n\n    cv2.imshow('Input', img_input)\n    cv2.imshow('Output', img_output)\n    cv2.waitKey()\n\nif __name__=='__main__':\n    img_input = cv2.imread(sys.argv[1])\n\n    drawing = False\n    img = np.copy(img_input)\n    img_orig = np.copy(img_input)\n\n    cv2.namedWindow('Input')\n    cv2.setMouseCallback('Input', draw_rectangle)\n\n    while True:\n        cv2.imshow('Input', img)\n        c = cv2.waitKey(10)\n        if c == 27:\n            break\n\n    cv2.destroyAllWindows()\n```"]