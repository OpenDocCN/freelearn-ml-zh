- en: Chapter 8. Machine Learning Examples Applicable to Businesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this chapter is to show you how machine learning helps in solving
    a business problem. Most of the techniques have already been explored in the previous
    chapter, so the pace of this chapter is fast. The techniques are about unsupervised
    and supervised learning. Unsupervised algorithms extract hidden structures from
    data and supervised techniques forecast an attribute. This chapter solves a business
    challenge using techniques belonging to the two branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the machine learning approach to a business problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segment the customer base of a bank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the target of a marketing campaign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the technique performing better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Portuguese banking institution launches a phone call marketing campaign. The
    institution has limited resources, so it needs to choose the target clients. Starting
    from the data about a past campaign, we can give some support to the company using
    machine learning techniques. The data shows personal details of the clients and
    information about previous marketing campaigns. The target of machine learning
    algorithms is to identify the clients that are more likely to subscribe. Starting
    from the data, the algorithms need to understand how to use new clients' data
    to predict how likely each of them will subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: Data overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data consists of approximately more than 2,500 clients affected by a marketing
    campaign consisting of one or more phone calls. We have some details about the
    clients and we know who subscribed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each row of the table corresponds to a client and there is a column displaying
    the output that is `yes` if the client subscribed and `no` otherwise. The other
    columns are features describing the clients and they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Personal details**: This incudes details such as age, job, marital status,
    education, credit default, average yearly balance, housing, and personal loan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication with the company**: This incudes details such as contact type,
    last contact month and weekday, last call duration, and number of contacts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Previous campaigns**: This incudes details such as number of days before
    the previous campaign, number of past contacts, and past outcomes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a sample of the table. The `y` column displays the attribute to predict
    `yes` if the client subscribed and `no` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '| Age | Job | Marital status | ... | Contact | … | y |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 30 | services | married |   | cellular |   | no |'
  prefs: []
  type: TYPE_TB
- en: '| 33 | management | single |   | telephone |   | yes |'
  prefs: []
  type: TYPE_TB
- en: '| 41 | blue-collar | single |   | unknown |   | no |'
  prefs: []
  type: TYPE_TB
- en: '| 35 | self-employed | married |   | telephone |   | no |'
  prefs: []
  type: TYPE_TB
- en: 'The data is stored in `bank.csv` and we can load them into R building a data
    table. The `sep='';''` field specifies that the fields in the file are separated
    by a semicolon, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `duration` feature displays the number of seconds in the final call. The
    target of our analysis is to define which clients to call and we cannot know the
    duration before contacting the client. In addition, after knowing a call duration,
    we already know whether the client has subscribed or not, so it is pointless to
    use this attribute to predict the outcome. For these reasons, we removed the `duration`
    feature, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to explore the data in order to understand the context.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we quickly explore and transform the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `y` output is categoric and the possible outcomes are `yes` and `no` and
    our target is to visualize the proportions. For this purpose, we can build a pie
    chart using these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Count how many clients subscribed and how many didn''t using `table`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the percentage of clients subscribing and not subscribing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build a function determining the percentages starting from the proportions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the percentages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look at the help of `barplot` that is the R function building bar charts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the barplot input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the barplot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The plot obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the output](img/7740OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Only 12 percent of the clients subscribed, so the output values are not equally
    distributed. The next step is to explore all the data.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring and transforming features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the output, we can build some charts to explore the features. Let''s
    first take a look at them using `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The features belong to two data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Categoric**: This data type stores features in the factor format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numeric**: This data type stores features in the integer format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The charts for the categoric features are different from the numeric ones,
    so we need to split the features in two groups. We can define a vector containing
    the categoric features and another vector for the numeric features by using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define each column class using `lapply`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the `y` column containing the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the categoric features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the numeric features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similar to the output, we can build a pie chart for each of the nine categoric
    features. In order to avoid having too many charts, we can put three pies in the
    same chart. The R function is `par` and it allows a grid of charts to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The input that we need is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mfcol`: This is a vector containing the number of columns and rows. For each
    feature, we build a chart with the pie and one with its legend. We put the pie
    charts on the bottom row and the legends on the top. Then, we have two rows and
    three columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mar`: This is a vector defining the plot margins:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can build the histograms using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps inside the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the pie chart input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new plot with the legend consisting of the feature names matched with
    their color. We add the feature name as the legend title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the histogram that will be displayed on the bottom row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We built three charts containing three categoric features each. Let''s take
    a look at the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring and transforming features](img/7740OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `job` attribute has different levels and some of them have a significant
    number of clients. Then, we can define a dummy variable for each relevant job
    and ignore the others. In order to identify the most relevant jobs, we determine
    the percentage of people belonging to each level. Then, we set a threshold and
    ignore all levels whose percentage is below the threshold. In this case, the threshold
    is 0.08, that is, 8 percent. After defining the new dummy columns, we remove `job`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `marital`, defining the marital status, has three levels out of which
    `divorced` and `single` have a smaller, although significant, slice. We can define
    two dummy variables defining the three levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With regard to `education`, more than half of the clients received a secondary
    education, so we can assume that the 4 percent of `unknown` are `secondary`. Then,
    we have three attributes and we can define two dummy variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring and transforming features](img/7740OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **default**, **housing**, and **loan** attributes have two different levels,
    so they can be converted into numerical form using `as.numeric`. In order to have
    `0` if the attribute was `no` and `1` if the attribute was `yes`, we subtract
    `1`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring and transforming features](img/7740OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, **contact** has three options out of which one is **unknown**. All the
    options have a significant slice, so we can define two dummy variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert `month` into a numeric variable in which January corresponds
    to `1` and December to `12`. The feature values are the month names abbreviated
    without a capital letter, for example, `jan` for `January`. In order to define
    the numeric feature, we define a vector whose first element is `jan`, second element
    is `feb`, and so on. Then, using `which`, we can identify the corresponding element
    of the vector. For instance, `apr` is the fourth element of the vector, so using
    `which` we obtain `4`. In order to build the vector with the ordered month names,
    we use `month.abb` containing the abbreviated month names and `tolower` to uncapitalize
    the first letter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In `poutcome`, `success` and `failure` have a small portion of the clients.
    However, they are very relevant, so we define two dummy variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We converted all the categoric features into the numeric format. The next step
    is to explore the numeric features and transform them if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six numeric features and we can build a plot about each of them.
    The chart is a histogram showing how the values of the feature are distributed.
    In order to visualize all the figures in the same charts, we can put them in a
    3 x 2 grid using `par`. The arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mfrow`: Similar to `mfcol`, it defines a grid of figures. The difference is
    just the order in which we add the figures to the grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mar`: We set the margins to their default, that is, `c(5, 4, 4, 2) + 0.1`,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can build the histograms using `hist`. The input is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x`: This is the vector with the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main`: This is the plot title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xlab`: This is the label under the x-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use `hist` directly inside the data table square brackets. In order
    to build all the charts in one step, we use a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring and transforming features](img/7740OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, **age** and **day** are evenly distributed across their possible values,
    so they don't require any treatment. The remaining features are concentrated in
    the small values, so we need to transform them. The function that we use to define
    the transformed feature is the logarithm and it allows us to have more spreaded
    values. The logarithm works on features having values greater than 0, so we need
    to remove the negative values from the feature.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid zeros, add `1` to the feature before computing the logarithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly with the data description, `pdays` is equal to `-1` if the institution
    has not contacted the client before. In order to identify the clients contacted
    for the first time, we can define a new dummy variable that is `1` if `pdays`
    is equal to `-1`. Then, we replace all the negative values with `0`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `balance` feature represents the past balance and we can define a dummy
    variable that is `1`, if the balance is negative. Then, we replace the negative
    balances with `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can compute the logarithm to all the features. Since the input of a
    logarithm must be positive and some features are equal to `0`, we add `1` to each
    feature before computing the logarithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We have converted all the features into the numeric format. Now, we can take
    a look at the new features table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The only column that is not numeric or integer is the output `y`. We can convert
    it into the numeric format and change its name to output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We loaded and cleaned the data. Now we are ready to build the machine learning
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Clustering the clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to address the next marketing campaign, we need to identify the clients
    that are more likely to subscribe. Since it's hard to evaluate the clients one
    by one, we can determine homogeneous groups of clients and identify the most promising
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the past data, we cluster the clients on the basis of their personal
    details. Then, given a new client, we identify the most similar group and associate
    the new client to it. We don't have information about the customer behavior of
    the new clients, so clustering is based on the personal attributes only.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different techniques performing clustering and in this section we
    use a relevant algorithm that is hierarchical clustering. A parameter of hierarchical
    clustering is linkage, which is the way of computing the distance between two
    groups. The main options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single linkage**: This is the minimum distance between an object of the first
    group and an object of the second group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete linkage**: This is the maximum distance between an object of the
    first group and an object of the second group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Average linkage**: This is the average distance between an object of the
    first group and an object of the second group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we choose the average linkage and this choice comes from testing
    the three options.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define `dtPers` containing the personal features only, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can apply hierarchical clustering and the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the dissimilarity matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the hierarchical clustering model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Visualize the dendrogram. The `par` method defines the plot layout that in
    this case contains just one chart and `plot` contains an argument improving the
    appearance. The `labels` and `hang` features avoid having a messy chart in the
    bottom and the other arguments specify the plot title and the axis labels, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clustering the clients](img/7740OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can identify three clusters cutting the dendrogram around the height of
    **40**. There is also another option that is cutting the dendrogram at a lower
    level (around 18), identifying seven clusters. We can explore both the options
    and visualize the two splits on the dendrogram using `rect.hclust`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clustering the clients](img/7740OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to identify the most successful cluster, we can display the proportion
    of clients that subscribed using a pie chart putting as its title the number of
    clients in the cluster. Let''s see the chart for the three clusters of the first
    split. The steps to build the pie charts are similar to the steps we performed
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a data table containing the output attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add two columns defining clusters to the data table. Each column corresponds
    to a different number of clusters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the plot layout with one row and three columns. The `oma` argument defines
    the outer margins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using commands similar to the data exploration, build three histograms showing
    the percentage of clients subscribing or not to each cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the title of the charts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clustering the clients](img/7740OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first and second clusters contain the majority of clients and the campaign
    hasn't been particularly successful on them. The third cluster is smaller and
    a significantly higher percentage of its clients subscribed. Then, we can start
    the marketing campaign targeting new clients similar to the third cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same R commands, we can visualize the same charts for the seven clusters
    identified by the second split, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the plot layout with two rows and four columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the histograms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the title of the charts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clustering the clients](img/7740OS_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first three clusters contain most of the clients and the marketing campaign
    hasn't been particularly effective on them. The fourth and fifth cluster has a
    significantly higher percentage of clients subscribing. The last two clusters
    are very successful although they are very small. The marketing campaign will
    start addressing all the new clients similar to the last two clusters and it will
    target a part of the clients of clusters four and five.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, using clustering, we identified small groups of customers upon
    which the campaign has been very successful. However, most of the customers belong
    to a big cluster about which we don't have enough information. The reason is that
    the campaign is successful on a few customers with specific features.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The past marketing campaign targeted part of the customer base. Among other
    1,000 clients, how do we identify the 100 that are keener to subscribe? We can
    build a model that learns from the data and estimates which clients are more similar
    to the ones that subscribed in the previous campaign. For each client, the model
    estimates a score that is higher if the client is more likely to subscribe. There
    are different machine learning models determining the scores and we use two well-performing
    techniques, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logistic regression**: This is a variation of the linear regression to predict
    a binary output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random forest**: This is an ensemble based on a decision tree that works
    well in presence of many features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, we need to choose one out of the two techniques. There are cross-validation
    methods that allow us to estimate model accuracy (see [Chapter 6](ch06.html "Chapter 6. Step
    3 – Validating the Results"), *Step 3 – Validating the Results*). Starting from
    that, we can measure the accuracy of both the options and pick the one performing
    better.
  prefs: []
  type: TYPE_NORMAL
- en: After choosing the most proper machine learning algorithm, we can optimize it
    using cross validation. However, in order to avoid overcomplicating the model
    building, we don't perform any feature selection or parameter optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps to build and evaluate the models:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `randomForest` package containing the random forest algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the formula defining the output and the variable names. The formula
    is in the format `output ~ feature1 + feature2 + ...`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the table containing all the testing sets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the number of iterations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the training and the test datasets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select a subset from the test set in such a way that we have the same number
    of `output == 0` and `output == 1`. First, we split `dtTest` in two parts (`dtTest0`
    and `dtTest1`) on the basis of the output and we count the number of rows of each
    part (`n0` and `n1`). Then, as `dtTest0` has more rows, we randomly select `n1`
    rows. In the end, we redefine `dtTest` binding `dtTest0` and `dtTest1`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the random forest model using `randomForest`. The formula argument defines
    the relationship between variables and the data argument defines the training
    dataset. In order to avoid overcomplicating the model, all the other parameters
    are left as their defaults:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the logistic regression model using `glm`, which is a function used to
    build **Generalized Linear Models** (**GLM**). GLMs are a generalization of the
    linear regression and they allow to define a link function that connects the linear
    predictor with the outputs. The input is the same as the random forest, with the
    addition of `family = binomial(logit)` defining that the regression is logistic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Predict the output of the random forest. The function is `predict` and its
    main arguments are `object` defining the model and `newdata` defining the test
    set, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Predict the output of the logistic regression, using `predict` similar to the
    random forest. The other argument is `type=''response''` and it is necessary in
    the case of the logistic regression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the new test set to `dtTestBinded`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'End the `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We built `dtTestBinded` containing the `output` column that defines which clients
    subscribed and the scores estimated by the models. Comparing the scores with the
    real output, we can validate the model performances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to explore `dtTestBinded`, we can build a chart showing how the scores
    of the non-subscribing clients are distributed. Then, we add the distribution
    of the subscribing clients to the chart and compare them. In this way, we can
    see the difference between the scores of the two groups. Since we use the same
    chart for the random forest and for the logistic regression, we define a function
    building the chart by following the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function and its input that includes the data table and the name
    of the score column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute the distribution density for the clients that didn''t subscribe. With
    `output == 0`, we extract the clients not subscribing, and using `density`, we
    define a `density` object. The adjust parameter defines the smoothing bandwidth
    that is a parameter of the way we build the curve starting from the data. The
    bandwidth can be interpreted as the level of detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute the distribution density for the clients that subscribed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the colors in the chart using `rgb`. The colors are transparent red
    and transparent blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the plot with the density of the clients not subscribing. Here, `polygon`
    is a function that adds the area to the chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the clients that subscribed to the chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the legend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'End the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use `plotDistributions` on the random forest output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predicting the output](img/7740OS_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The x-axis represents the score and the y-axis represents the density that is
    proportional to the number of clients that subscribed for similar scores. Since
    we don't have a client for each possible score, assuming a level of detail of
    0.01, the density curve is smoothed in the sense that the density of each score
    is the average between the data with a similar score.
  prefs: []
  type: TYPE_NORMAL
- en: The red and blue areas represent the non-subscribing and subscribing clients
    respectively. As can be easily noticed, the violet area comes from the overlapping
    of the two curves. For each score, we can identify which density is higher. If
    the highest curve is red, the client will be more likely to subscribe, and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: For the random forest, most of the non-subscribing client scores are between
    `0` and `0.2` and the density peak is around `0.05`. The subscribing clients have
    a more spread score, although higher, and their peak is around `0.1`. The two
    distributions overlap a lot, so it's not easy to identify which clients will subscribe
    starting from their scores. However, if the marketing campaign targets all customers
    with a score higher than 0.3, they will likely belong to the blue cluster. In
    conclusion, using random forest, we are able to identify a small set of customers
    that will subscribe very likely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a comparison, we can build the same chart about the logistic
    regression output, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predicting the output](img/7740OS_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the logistic regression, the two distributions overlap a bit, but they clearly
    cover two different regions and their peaks are very distant. The clients whose
    score is higher than 0.8 will very likely subscribe, so we can choose a small
    set of clients. We are also able to identify a bigger set of clients that will
    likely subscribe, if we choose the ones that scored above 0.5 or 0.6.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the logistic regression seems to have performed better. However,
    the distribution charts are good to just explore the performance and don't provide
    with a clear evaluation. The next step is to define how to evaluate the model
    using an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The validation index that we will use is the AUC and it depends on another
    chart that is the **Receiver Operating Characteristic** (**ROC**). After building
    the classification model, we define a threshold and assume that the customers
    with a score above the threshold will subscribe. The ROC shows the model accuracy
    depending on the threshold. The curve dimensions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**True positive rate**: This index shows out of the subscribing customers,
    which percentage has a score above the threshold. This index should be as high
    as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False positive rate**: This index shows out of the non-subscribing customers,
    which percentage has a score above the threshold. This index should be as low
    as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Area Under Curve** (**AUC**) is the area under the ROC. Given a random
    client that subscribed and another random client that did not subscribe, the AUC
    represents the probability that the score of the client that subscribed is higher
    than the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a function that builds the chart and computes the AUC index:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `ROCR` package containing the function used to cross validate the
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function and its input that includes the data table and the name
    of the score column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a prediction object that is the starting point to build the ROC chart.
    The function is `prediction` and it is provided by the `ROCR` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the ROC chart. The function provided by the `ROCR` package is `performance`
    and it allows you to evaluate the prediction in different ways. In this case,
    we want to build a chart with the `true` and `false` positive rates, so the input
    is **true positive rate** (**tpr**) and **false positive rate** (**fpr**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute the AUC index using `performance`. The input is `auc` and it defines
    that we are computing the AUC index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the AUC index as the function output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `plotPerformance`, we can build the chart about the random forest and
    we compute the `auc` index that we store in `aucRf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predicting the output](img/7740OS_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As anticipated, the chart displays the tpr and the fpr respectively. When the
    threshold is `1`, no clients have a rate higher than it, so there are no positives
    (clients that are predicted to subscribe). In this situation, we are in the top-right
    corner and both the indices are equal to 100 percent. As the threshold decreases,
    we have more positive customers, so tpr and fpr decrease. In the end, when the
    threshold is `0`, tpr and fpr are equal to `0` and we are in the bottom-left corner.
    In an ideal situation, tpr is equal to `1` and fpr is equal to `0` (top-left corner).
    Then, the closest the curve is to the top-left corner, the better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the random forest, we build the chart and compute the AUC index
    for the logistic regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The histogram obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predicting the output](img/7740OS_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The chart for the logistic regression is similar to the one for the random forest.
    Looking at the details, we can notice that the curve in the bottom-left is steeper
    and at the top-right it is less steep, so the area under the curve, defining the
    AUC, is higher.
  prefs: []
  type: TYPE_NORMAL
- en: The cross validation contains a random component, so the AUC indices might vary
    a bit. Setting `nIter = 100`, the last time I executed the script the AUC was
    around 73 percent for the random forest and around the 79 percent for the logistic
    regression. We can conclude that the logistic regression performed better, so
    we should use it to build the model.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to build a model that provides a score for the
    customers. This algorithm allows the company to identify the customers that are
    more likely to subscribe and it is also possible to estimate its accuracy. A continuation
    of this chapter would be selecting a feature subset and optimizing the parameters
    in order to achieve better performances.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to explore and transform the data related to
    a business problem. You used a clustering technique to segment the customer base
    of a bank and a supervised learning technique to identify a score ranking the
    clients. After building the machine learning model, you were able to cross validate
    it visualizing the ROC curve and computing the AUC index. In this way, you have
    been able to choose the most proper technique.
  prefs: []
  type: TYPE_NORMAL
- en: This book showed how machine learning models can solve business problems. Rather
    than just a tutorial, the book is a path showing the importance of machine learning,
    how to develop a solution, and how to solve a business problem using the techniques.
    I hope that the book has transmitted not only the machine learning concepts, but
    also the passion for a field that is at the same time valuable and fascinating.
    I'd like to thank you for following this path. I hope it is just the start of
    a wonderful journey.
  prefs: []
  type: TYPE_NORMAL
- en: Please don't hesitate to contact me if you have any queries.
  prefs: []
  type: TYPE_NORMAL
