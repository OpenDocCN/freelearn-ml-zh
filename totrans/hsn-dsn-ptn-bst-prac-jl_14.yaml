- en: Traditional Object-Oriented Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have already learned about the many design patterns that we need
    to know in order to be an effective Julia programmer. The cases presented in the
    previous chapters included various problems that we can solve by writing *idiomatic*
    Julia code. Some might ask, after all these years, I have learned and adapted
    to the **object-oriented programming** (**OOP**) paradigm; how do I apply the
    same concepts in Julia? The general answer is, you won't solve the problem the
    same way. The solution written in Julia will look different, reflecting a different
    programming paradigm. Nevertheless, it is still an interesting exercise to think
    about how to adopt some of the OOP techniques in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover all 23 design patterns from the classic **Gang
    of Four** (**GoF**) *Design Patterns* book. We will keep the tradition and organize
    the topics in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have an idea of how each of these patterns
    may be applied in Julia, as compared to an OOP approach.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Creational** patterns refer to the various ways of constructing and instantiating
    objects. Since OOP groups data and behavior together, and since a class may inherit
    the structure and behavior from an ancestor class, there are additional levels
    of complexity involved when building a large-scale system. By design, Julia has
    already gotten rid of many issues by not allowing fields to be declared in abstract
    types and not allowing creating new subtypes from concrete types. Nevertheless,
    some of these patterns could be helpful in certain situations.'
  prefs: []
  type: TYPE_NORMAL
- en: The creational patterns include the factory method, abstract factory, singleton,
    builder, and prototype patterns. We shall discuss them in detail in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of the **factory method** pattern is to provide a single interface
    to create different types of objects that conform to an interface while hiding
    the actual implementation from the client. This abstraction decouples the client
    from the underlying implementation of the feature provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a program might need to format some numbers in the output. In
    Julia, we might want to use the `Printf` package to format numbers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/164d6264-cef6-4276-9c1a-54d6e23f4a19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perhaps we do not want to couple with the `Printf` package because we want
    to switch and use a different formatting package in the future. In order to make
    the application more flexible, we can design an interface where numbers can be
    formatted according to their types. The following interface is described in the
    doc string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `format` function takes a `formatter` and a numeric value, `x`, and returns
    a formatted string. The `Formatter` type is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the factory methods basically create singleton types for dispatch purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The default implementation may look like the following, utilizing the `Printf`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting everything in a `FactoryExample` module, we can run the following testing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8eadb69d-fa16-4659-81a7-1372fd4fe911.png)'
  prefs: []
  type: TYPE_IMG
- en: Should we ever want to change the formatter in the future, we just need to provide
    a new implementation with format functions defined for the numeric types that
    we want to support. This is handy when we have a lot of number-formatting code
    lying around. The switch to a different formatter involves literally two lines
    of code changes (in this example).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the abstract factory pattern next.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **abstract factory** pattern is used for creating objects via a set of factory
    methods, which are abstracted away from the concrete implementation. The abstract
    factory pattern can be viewed as a factory of factories.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can explore the example of building a multiplatform GUI library that supports
    Microsoft Windows and macOS. As we want to develop code that is cross-platform,
    we can leverage this design pattern. This design is described in the following
    UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9e33f83-3b44-4b67-9eca-0e1b6290dd37.png)'
  prefs: []
  type: TYPE_IMG
- en: In a nutshell, we have presented two types of GUI objects here: `Button` and
    `Label`. The concept is the same for both Microsoft Windows and macOS platforms.
    The client does not care how these objects are instantiated; instead, it asks
    an abstract factory `GUIFactory` to return factories (either `MacOSFactory` or
    `WindowsFactory`) that support multiple factory methods for creating platform-dependent
    GUI objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Julia implementation can simply be modeled with the appropriate abstract
    and concrete types. Let''s start at the OS level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We intended to use `MacOS` and `Windows` as singleton types for dispatch purposes
    later. For now, let''s continue and define the abstract types `Button` and `Label`
    as follows. Additionally, we have defined `show` methods for each type respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We do need to provide concrete implementation for these GUI objects. Let''s
    define them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of simplicity, we just hold on to a text string, whether it''s
    a button or a label. As factory methods are platform-dependent, we can leverage
    the OS trait and multiple dispatch to call the right `make_button` or `make_label`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For testing, we have hardcoded the `current_os` function to return `MacOS()`.
    In reality, this function should return either `MacOS()` or `Windows()` by examining
    whatever system variable is appropriate to identify the platform. Finally, we
    need to implement the specific functions for each platform as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our simple test just involves calling the `make_button` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6f09e64-b683-4b9e-a297-21f9303a31f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Using multiple dispatch, we can easily extend to new platforms or new GUI objects
    by simply defining new functions for the specific OS.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **singleton** pattern is used to create a single instance of an object and
    reuse it from anywhere. A singleton object is typically constructed when the application
    starts, or it can be created lazily on the first use of the object. An interesting
    requirement for the singleton pattern arises for multithreaded applications because
    the instantiation of the singleton object must happen only once. It can be a challenge
    if the object creation function is called lazily from many threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to create a singleton called `AppKey` that is used for
    encryption in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we may be tempted to use a global variable. Given that we have learned
    about the performance impact of global variables, we can apply the global constant
    pattern that we learned in [Chapter 6](c8cedc0d-716d-46c4-8768-ae0084a10bf9.xhtml),
    *Performance Patterns*. Essentially, a `Ref` object is created as a placeholder,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `appkey` global constant is first created without being assigned with any
    value, but then it can be updated when the singleton is instantiated. The construction
    of singleton can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code works fine as long as there is a single thread. If we test it with
    multiple threads, then the `isassigned` check is problematic. For example, two
    threads might check whether the key is assigned at the same time, and both threads
    might think that the singleton object needs to be instantiated. In this case,
    we end up constructing the singleton twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can demonstrate the problem below. Let''s start the Julia REPL with four
    threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/491e40c8-86df-42c0-88c7-40e95b266b74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can run the testing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe8831ec-3da2-423c-8be6-ebc6d3e51e95.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the singleton being constructed twice here.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we solve this problem? We can use a lock to synchronize the singleton
    construction logic. Let''s first create another global constant to hold the lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the lock, we can modify the `construct` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d29c23e-2456-47fb-82f8-8f8c5a9f5cee.png)'
  prefs: []
  type: TYPE_IMG
- en: We must first acquire the lock before checking whether `appkey[]` is already
    assigned. When we are done constructing the singleton (or skipping it, if it has
    already been created), we release the lock. Note that we have wrapped the critical
    section of the code in a `try` block, and we placed the `unlock` function in the
    `finally` block. This is done to ensure that the lock is released regardless of
    whether the construction of the singleton is successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new test shows that the singleton is constructed only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1ac22bd-96d0-46b2-afa1-2aa38cef4392.png)'
  prefs: []
  type: TYPE_IMG
- en: The singleton pattern is useful when we need to hold on to a single object.
    Practical use cases include database connections or other references to external
    resources. Next, we will take a look at the builder pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **builder** pattern is used to build a complex object by incrementally building
    simpler parts of it. We can imagine that a factory assembly line would work in
    a similar fashion. In that case, a product is assembled step-by-step with more
    and more parts, and at the end of the assembly line, the product is finished and
    ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'One benefit of this pattern is that the builder code looks like a linear data
    flow and is easier for some people to read. In Julia, we may want to write something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, this is the exact functional pipe pattern described in [Chapter
    9](6682bca1-9221-46fa-84f2-f5379fd4d01b.xhtml), *Miscellaneous Patterns*. For
    this example, we can develop higher-order functions for building each part (such
    as the wheels, engine, and chassis). The following code illustrates how to create
    a curry (higher-order) function for creating wheels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `add` function just returns an anonymous function that takes a `Car` object
    as input and returns an enhanced `Car` object. Likewise, we can develop similar
    functions for the `Engine` and `Chassis` types. Once these functions are ready,
    we can build a car by simply chaining these function calls together.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the prototype pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **prototype** pattern is used to create new objects by cloning fields from
    an existing object, or the prototype object. The idea is that some objects are
    difficult or time-consuming to construct, so it would be useful to make a copy
    of the object and call it a new one by making small modifications.
  prefs: []
  type: TYPE_NORMAL
- en: As Julia keeps data and logic separate, making copies of objects is really the
    same as duplicating the content. That sounds easy, but we should not overlook
    the difference between a shallow copy and a deep copy.
  prefs: []
  type: TYPE_NORMAL
- en: A **shallow copy** of an object is merely an object with all the fields copied
    from another object. A **deep copy** of an object is created by recursively going
    into the fields of the object and copying their underlying fields as well. As
    such, a shallow copy may not be desirable because some data can be shared with
    the original object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s consider the following struct definitions for a
    bank account example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose that we have an array of `Customer` objects that are returned
    from this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sample_customer` function returns an array of two customers. For testing
    purposes, let''s build a test harness to update the balance for the first customer
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we exercise the test harness with built-in `copy` and `deepcopy` functions,
    we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/736a8fe8-a14f-4f8a-a7a6-32972342531a.png)'
  prefs: []
  type: TYPE_IMG
- en: Unexpectedly, we got the wrong result in the `orig` output since we should be
    adding $500 to the new customer. Why do we have the same balance for both the
    original customer record and the new customer record instead? This is because
    a shallow copy was made from the customer array when the `copy` function was used.
    When this happens, the customer records are essentially shared between the original
    array and the new array. This means that mutating the new record also affected
    the original record.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the result, only the new copy of the customer record was
    changed. This is because the `deepcopy` function was used. By definition, the
    prototype pattern requires making changes to the copy. It is probably safer to
    make a deep copy should this pattern be applied.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered all five creational patterns. These patterns allow us to build
    new objects in an effective manner.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to cover a set of behavioral design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Behavioral** patterns refer to how objects are designed to collaborate and
    communicate with each other. There are 11 GoF patterns from the OOP paradigm.
    We will cover all of them here with some interesting hands-on examples.'
  prefs: []
  type: TYPE_NORMAL
- en: The chain-of-responsibility pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **chain-of-responsibility** (**CoR**) pattern is used to process the request
    using a chain of request handlers, whereas each handler has its own distinct and
    independent responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is quite common in many applications. For example, web servers
    usually handle HTTP requests using so-called middleware. Each piece of middleware
    is responsible for performing a specific task—for example, authenticating requests,
    maintaining cookies, validating requests, and performing business logic. A specific
    requirement about the CoR pattern is that any part of the chain can be broken
    at any time, resulting in an early exit of the process. In the preceding web server
    example, the authentication middleware may have decided that the user has not
    been authenticated, and that therefore, the user should be redirected to a separate
    website for login. This means that the rest of the middleware is skipped unless
    the user gets past the authentication step.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we design something like this in Julia? Let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A `DepositRequest` object contains an amount that a customer wants to deposit
    in their account. Our marketing department wants us to provide a thank-you note
    to the customer if the deposit amount is greater than $100,000\. To process such
    a request, we have designed three functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What is the responsibility of these functions?
  prefs: []
  type: TYPE_NORMAL
- en: The `update_account_handler` function is responsible for updating the account
    with the new deposit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `send_gift_handler` function is responsible for sending a thank-you note to
    the customer for a large deposit amount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `notify_customer` function is responsible for informing the customer after
    the deposit is made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions also return an enum value, either `CONTINUE` or `HANDLED`, to
    indicate whether the request should be passed on to the next handler when the
    current one is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be quite clear that these functions run in a specific order. In particular,
    the `notify_customer` function should run at the end of the transaction. For that
    reason, we can establish an array of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also have a function to execute these handlers in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As part of this design, the loop will end immediately if any handler returns
    a value of `HANDLED`. Our test code for testing the function of sending the thank-you
    note to a premier customer is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the test gives us this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d1b30b8-f33a-43ad-a73c-f416ea37ba4e.png)'
  prefs: []
  type: TYPE_IMG
- en: I will leave it as an exercise for you to build another function in this chain
    to perform an early exit. But for now, let's move on to the next pattern—the mediator
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The mediator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **mediator** pattern is used to facilitate communication between different
    components in an application. This is done in such a way that individual components
    are decoupled from each other. In most applications, changes in one component
    can affect another. Sometimes, there are also cascading effects. A mediator can
    take the responsibility of getting notified when one component is changed, and
    it can notify other components about the event so that further downstream updates
    can be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can consider the use case of a **graphical user interface**
    (**GUI**). Suppose that we have a screen that contains three fields for our favorite
    banking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amount**: Current balance in the account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interest Rate**: Current interest rate expressed as a percentage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interest Amount**: Interest amount. This is a read-only field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do they interact with each other? If the amount is changed, then the interest
    amount needs to be updated. Likewise, if the interest rate is changed, then the
    interest amount needs to be updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To model the GUI, we can define the following types for the individual GUI
    objects onscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Widget` is an abstract type and it can be used as the supertype for all
    GUI objects. This application only needs text fields, so we just define a `TextField`
    widget. A text field is identified by an `id`, and it contains a `value`. In order
    to extract and update the value in the text field widget, we can define functions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that the `get_number` function gets the
    value from the text field widget and returns it as a floating-point number. The
    `set_number` function populates the text field widget with the provided numeric
    value. Now, we also need to create the application, so we conveniently define
    a struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, we will implement a `notify` function to simulate an event
    that is sent to the text field widget after the user enters a value. In reality,
    the GUI platform typically performs that function. Let''s call it `on_change_event`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `on_change_event` function does nothing else but communicate to the mediator
    (the app) that something has just happened to this widget. As for the app itself,
    here''s how it handles the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it simply checks whether the widget that is being updated is
    either the Amount or Interest Rate field. If so, it calculates a new interest
    amount and populates the Interest Amount field with the new value. Let''s do a
    quick test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test` function displays the initial state of the application, updates
    the amount field, and displays the new state. For the sake of brevity, the source
    code for the `print_current_state` function is not shown here, but is available
    on the book''s GitHub site. The output of the test program is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1a05a91-0844-43d8-980b-b0e034b98f79.png)'
  prefs: []
  type: TYPE_IMG
- en: The benefit of using the 2 mediator pattern is that every object can focus on
    its own responsibility and not worry about the downstream impact. A central mediator
    takes on the responsibility of organizing activities and handling events and communications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we shall look at the memento pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The memento pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **memento** pattern is a state management technique that you can use to
    restore your work to a previous state when needed. A common example is the Undo
    function of a word processor application. After making 10 changes, we can always
    undo the prior operations and return to the original state before those 10 changes
    were made. Similarly, an application may remember the most recently opened files
    and provide a menu of choices so that the user can quickly reopen a previously
    opened file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the memento pattern in Julia is quite simple. We can just store
    previous states in an array and when making a change, we can push the new state
    to the array. When we want to undo our actions, we restore the previous state
    by popping from the array. To illustrate this idea, let''s consider the case of
    a blog post-editing application. We can define the data types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a `Blog` object contains an array of `Post` objects. By convention,
    the last element in the array is the current version of the blog post. If there
    were five posts in the array, then it means that four changes have been made so
    far. Creating a new blog is as easy, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By default, a new blog object contains just one version. As the user makes changes,
    the array will grow. For convenience, we can provide a `version_count` function
    that returns the number of revisions that the user has made so far.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain the current post, we can simply take the last element of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we have to update the blog, we must push the new version to the array.
    Here is the function that we use to update the blog with a new title or content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update!` function takes a `Blog` object, and optionally it can take either
    an updated `title`, `content`, or both. Basically, it creates a new `Post` object
    and pushes it into the `posts` array. Undoing is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test it with the following `test` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e64c8f77-35a7-4be7-bef1-698e54eef529.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it is quite easy to implement the memento pattern. We will cover
    the observer pattern next.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **observer** pattern is useful for registering observers to an object so
    that all state changes in that object trigger the sending of notifications to
    the observers. In a language that supports first-class functions—for example,
    Julia—such functionality can be implemented easily by maintaining a list of functions
    that can be called before or after the state changes of an object. Sometimes,
    these functions are called **hooks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the observer pattern in Julia may consist of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `setproperty!` function of an object to monitor state changes and
    notify observers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maintain a dictionary that can be used to look up the functions to call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this demonstration, we will bring up the bank account example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the data structure for maintaining observers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have chosen to use `IdDict` instead of the regular `Dict` object. `IdDict`
    is a special type that uses Julia''s internal object ID as the key of the dictionary.
    To register observers, we provide the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s extend the `setproperty!` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This new `setproperty!` function not only updates the field for the object,
    but also calls the observer functions with both the previous state and the current
    state after the field has been updated. For testing purposes, we will create an
    observer function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `test` function is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the test program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/479fc6b7-8505-4e00-a245-3fa245d02132.png)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can see that the `test_observer_func` function was called
    every time a property is updated. The observer pattern is an easy thing to develop.
    Next, we will look at the state pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The state pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **state** pattern is used in situations where an object behaves differently
    depending on its internal state. A networking service is a great example. A typical
    implementation for a network-based service is to listen to a specific port number.
    When a remote process connects to the service, it establishes a connection, and
    they use it to communicate with each other until the end of the session. When a
    network service is currently in a listening state, it should allow a new connection
    to be opened; however, no data transmission should be allowed until after the
    connection is opened. Then, after the connection is opened, we should be able
    to send data. By contrast, we should not allow any data to be sent through the
    network connection if the connection is already closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Julia, we can possibly implement the state pattern using multiple dispatch.
    Let''s first define the following types that are meaningful for network connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have leveraged the singleton type pattern. As for the network connection
    itself, we can define the type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s develop a `send` function, which is used to send a message via
    a connection. In our implementation, the `send` function does not do anything
    else except gather the current state of the connection and forward the call to
    a state-specific `send` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recognize this as the Holy Trait pattern. For unit testing, we can
    develop a `test` function for creating a new `Connection` with the specified message
    and sending a message to the `Connection` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the testing code simply runs the `test` function three times, once for
    each possible state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the `test` function, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee36e51a-a962-4c80-8f2a-5d9702d14489.png)'
  prefs: []
  type: TYPE_IMG
- en: Only the third message was sent successfully, because the connection was in
    the `ESTABLISHED` state. Now, let's take a look at the strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **strategy** pattern enables clients to select the best algorithm to use
    at runtime. Instead of coupling the client with predefined algorithms, the client
    can be configured with a specific algorithm (strategy) when necessary. In addition,
    sometimes the choice of algorithm cannot be determined ahead of time because the
    decision may depend on the input data, the environment, or something else.
  prefs: []
  type: TYPE_NORMAL
- en: In Julia, we can solve the problem using multiple dispatch. Let's consider the
    case of a Fibonacci sequence generator. As we learned from [Chapter 6](c8cedc0d-716d-46c4-8768-ae0084a10bf9.xhtml),
    *Performance Patterns*, the calculation of the *n*^(th) Fibonacci number can be
    tricky when we implement it recursively, so our first algorithm (strategy) may
    be memoization. In addition, we can also solve the same problem using an iterative
    algorithm without using any recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to support both memoization and iterative algorithms, let''s create
    some new types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Algo` abstract type is the supertype for all Fibonacci algorithms. At
    the moment, we only have two algorithms to choose from: `Memoized` or `Iterative`.
    Now, we can define the memoized version of the `fib` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A memoized function `_fib` is first defined. Then a wrapper function `fib` is
    defined, taking a `Memoized` object as the first argument. The corresponding iterative
    algorithm can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How the algorithm actually works is unimportant in this discussion. As the first
    argument is an `Iterative` object, we know that this function will be dispatched
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the client''s perspective, it can choose either the memoized version or
    the iterative function, depending on what it needs. As the memoized version runs
    at O(1) speed, it should be faster when `n` is large; however, for a small value
    of `n`, the iterative version would work better. We can call the `fib` function
    in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Should the client choose to implement an algorithm-selection process, it can
    be done easily, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The successful test result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7bc2d48-581e-4c49-9e04-cc6ca69166be.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, implementing the strategy pattern is quite easy. *The unreasonable
    effectiveness of multiple dispatch has come to rescue again!* Next, we will go
    over another behavioral pattern called the template method.
  prefs: []
  type: TYPE_NORMAL
- en: The template method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **template method** pattern is used to create a well-defined process that
    can use different kinds of algorithms or operations. As a template, it can be
    customized with whatever algorithm or functions the client requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will explore how the template method pattern can be utilized in a
    **machine learning** (**ML**) pipeline use case. For those who are unfamiliar
    with ML pipelines, here is a simplified version of what a data scientist might
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d9dc286-6d1e-49f8-84a2-da3a420205a0.png)'
  prefs: []
  type: TYPE_IMG
- en: A dataset is first split into two separate datasets for training and testing
    purposes. The training dataset is fed into a process that fits the data into a
    statistical model. Then, the `validate` function uses the model to predict the
    response (also called the target) variable in the test set. Finally, it compares
    the predicted values against the actual values and determines how accurate the
    model is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have the pipeline already set up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of brevity, the specific functions, `split_data`, `fit`, and `validate`,
    are not shown here; you can look them up on this book''s GitHub site if you wish.
    However, the pipeline concept is demonstrated in the preceding logic. Let''s take
    a quick spin at predicting Boston house prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec34e4dc-c307-4190-9ba5-50be22ef7411.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the response variable is `:MedV`, and we will build a statistic
    model based on `:Rm`, `:Tax`, and `:Crim`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boston housing dataset contains data collected by the U.S. Census Service
    concerning housing in the area of Boston, Massachusetts. It is used extensively
    by much statistical analysis educational literature. The variables that we used
    in this example are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MedV`: Median value of owner-occupied homes in $1,000''s'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rm`: Average number of rooms per dwelling'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tax`: Full-value property tax rate per $10,000'
  prefs: []
  type: TYPE_NORMAL
- en: '`Crim`: Per capita crime rate by town'
  prefs: []
  type: TYPE_NORMAL
- en: The accuracy of the model is captured in the `rmse` variable (meaning the root
    mean squared error). The default implementation uses linear regression as the
    fitting function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the template method pattern, we should allow the client to plug
    in any part of the process. For that reason, we can modify the function with keyword
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added three keyword arguments: `fit`, `split_data`, and `validate`.
    The function is named as `run2` to avoid confusion here, so the client should
    be able to customize any one of them by passing in a custom function. To illustrate
    how it works, let''s create a new `fit` function that uses the **generalized linear
    model** (**GLM**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have customized the fitting function, we can rerun the program
    by passing it via the `fit` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01ae2558-eab6-4997-834c-0a5055df949c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the client can customize the pipeline easily by just passing
    in functions. This is possible because Julia supports first-class functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review a few other traditional behavioral patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Command, interpreter, iterator, and visitor patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **command**, **interpreter**, and **visitor** patterns are grouped in this
    section only because we have already covered their use cases earlier in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The **command** pattern is used to parameterize actions that are to be performed.
    In [Chapter 9](6682bca1-9221-46fa-84f2-f5379fd4d01b.xhtml), *Miscellaneous Patterns*,
    in the *Singleton type dispatch pattern* section, we explored a use case where
    the GUI invokes different commands and reacts to specific actions that the user
    has requested. By defining singleton types, we can leverage Julia's multiple dispatch
    mechanism to execute the proper function. We can extend this to new commands by simply adding
    new functions that take new singleton types.
  prefs: []
  type: TYPE_NORMAL
- en: The **interpreter** pattern is used to model an abstract syntax tree for a particular
    domain model. As it turns out, we have already done this in [Chapter 7](08f064fb-f7c5-4078-a9c9-5e70d42f336a.xhtml), *Maintainability
    Patterns*, in the *Domain-specific language* section. Every Julia expression can
    be modeled as an abstract syntax tree without any additional work, and so we can
    develop a DSL using regular metaprogramming facilities, such as macros and generated
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The **iterator** pattern is used to iterate over a collection of objects using
    a standard protocol. In Julia, there is already an officially established iteration
    interface that can be implemented by any collection framework. As long as an `iterate`
    function is defined for a custom object, the elements in the object can be iterated
    as part of any looping construct. More information can be found from the official
    Julia reference manual.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the **visitor** pattern is used to extend functionalities of an existing
    class in the OOP paradigm. In Julia, adding new functions to an existing system
    can be done easily via an extension of generic functions. For example, there are
    many array-like data structure packages in the Julia ecosystem, such as `OffsetArrays`,
    `StridedArrays`, and `NamedArrays`. All of these are extensions to the existing
    `AbstractArray` framework.
  prefs: []
  type: TYPE_NORMAL
- en: We are now finished with behavioral patterns. Let's move on and take a look
    at the last group—structural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Structural design** patterns are used to compose objects together to make
    bigger things. As you continue developing a system and adding functionalities,
    its size and complexity grows. Not only do we want to integrate components with
    each other, but at the same time, we also want to reuse components as much as
    possible. By learning the structural patterns described in this section, we have
    a template to follow when we encounter similar situations in our projects.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will review the traditional object-oriented patterns, including
    the adapter, bridge, composite, decorator, facade, flyweight, and proxy patterns.
    Let's start with the adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **adapter** pattern is used to make one object work with another. Say that
    we need to integrate two subsystems, but they cannot talk to each other because
    the interface requirements are not met. In real life, you may have encountered
    a situation where traveling to a different country is troublesome because the
    power plugs are not the same. To solve this problem, you would probably bring
    a universal power adapter, which acts as an intermediary to make your device work
    with foreign electrical outlets. Similarly, different software can be made to
    fit with each other by the use of adapters.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the interface for working with a subsystem is clear, then creating
    an adapter can be a straightforward task. In Julia, we can use the Delegation
    pattern to wrap an object and provide additional functionalities that conform
    to the required interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we are using a library that performs a computation and returns
    a linked list. A linked list is a convenient data structure that supports very
    fast inserts at O(1) speed. Now, say that we want to pass the data to another
    subsystem that requires us to conform to an `AbstractArray` interface. In this
    case, we cannot just pass the linked list as it does not fit!
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we solve this problem? First, let me introduce the `LinkedList` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae49982c-b878-4825-a109-91336b9e71b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a fairly standard design for a doubly-linked list. Each node contains
    a data value, but also maintains a reference to the node before and after. The
    typical usage of such a linked list is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/252a3142-77ea-4c16-8a2f-4433fba8ebe2.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, we can traverse the linked list by using the `prev` and `next` functions.
    The reason why we need to call `next(LL)` when inserting the value of `3` is because
    we want to insert it after the second node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because using a linked list does not implement the `AbstractArray` interface,
    we cannot really reference any element by index, nor can we figure out the number
    of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5634213c-ffb6-468d-835a-c1d6929df4a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we can build a wrapper (or so-called adapter) that conforms to
    the `AbstractArray` interface. First, let''s create a new type and make it a subtype
    of `AbstractArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As we only need to support a single-dimension array, we have defined the supertype
    to be `AbstractArray{T,1}`. The underlying data is just a reference to the linked
    list `Node` object. In order to conform to the `AbstractArray` interface, we should
    implement the `Base.size` and `Base.getindex` functions. Here''s what the `size`
    function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The function simply determines the length of the array by traversing the linked
    list using the `next` function. To support indexing elements, we can define the
    `getindex` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all we need to do for the wrapper. Let''s give it a spin now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51fccc19-1d3f-476a-8383-e64f36bda2d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have an indexable array on top of the linked list, we can pass it
    to any library that expects arrays as input.
  prefs: []
  type: TYPE_NORMAL
- en: In the situation where mutation is required for the array, we can just implement
    the `Base.setindex!` function as well. Alternatively, we can physically convert
    the linked list into an array. An array has the performance characteristic of
    fast indexing at O(1), while being relatively slow for inserts.
  prefs: []
  type: TYPE_NORMAL
- en: Using an adapter allows us to make components talk to each other more easily.
    Next, we will discuss the composite pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The composite pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **composite** pattern is used to model objects that can be grouped together
    and yet be treated the same as individual objects. This is not an uncommon case—for
    example, in a drawing application, we might be able to draw different kinds of
    shapes, such as circles, rectangles, and triangles. Every shape has a position
    and size so we can determine where they are located on screen as well as how large
    they are. When we group several shapes together, we can still determine the position
    and size of the large, grouped object. Additionally, resize, rotate, and other
    transformation functions can be applied to individual shape objects as well as
    grouped objects.
  prefs: []
  type: TYPE_NORMAL
- en: A similar situation happens with portfolio management. I have a retirement investment
    account that is composed of multiple mutual funds. Each mutual fund may either
    invest in stocks, bonds, or both. Then, some funds may also invest in other mutual
    funds. From an accounting perspective, we can always determine the market value
    of a stock, a bond, a fund of stocks, a fund of bonds, and a fund of funds. In
    Julia, we can tackle this problem by just implementing a `market_value` function
    for different types of instruments, whether it is a stock, a bond, or a fund.
    Let's take a look at some code now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have the following type defined for stock/bond holdings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Holding` type contains a trading symbol, quantity, and current price.
    We can define a portfolio as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'A portfolio is identified by a symbol, a name, an array of holdings, and an
    array of `subportfolios`. For testing, we can create a sample portfolio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure is visualized more clearly from an indented output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/318f5457-0580-432d-96e1-bec526076030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we want to support the ability to calculate the market value at any level,
    we just need to define the `market_value` function for each type. The simplest
    one is for holdings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The market value is nothing but quantity multiplied by price. The calculation
    of market value for a portfolio is just a little more involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `mapreduce` function to calculate the market values of individual
    stocks (or `subportfolios`) and sum them up. As a portfolio may include multiple
    holdings and multiple `subportfolios`, we need to perform the calculation for
    both and add them together. As each subportfolio is also a `portfolio` object,
    this code naturally recurses deeper into sub-`subportfolios`, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing fancy about composites. Because Julia supports generic functions,
    we can just provide an implementation for individual objects as well as grouped
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the flyweight pattern next.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **flyweight** pattern is used to handle a large number of fine-grained objects
    efficiently by sharing memory for similar/same objects.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this involves handling strings. In the field of data science,
    we frequently need to read and analyze a large amount of data that is represented
    in a tabular format. In many cases, certain columns may contain a large number
    of strings that are just repeated values. For example, a population survey might
    have a column stating gender, and so it will contain either `Male` or `Female`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike some other programming languages, strings are not interned in Julia.
    This means that 10 copies of the word `Male` are going to be stored repeatedly,
    occupying 10 times the memory space that is used by a single string of `Male`.
    We can see this effect easily from the REPL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/380fa56c-5edf-47fb-89af-8bb638e64e52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, storing 100,000 copies of a `Male` string occupies roughly 800 KB of memory.
    That is quite a waste of memory. A common way to solve this problem is to maintain
    a pooled array. Rather than storing 100,000 strings, we can just encode the data
    and store 100,000 bytes instead so that `0x01` corresponds to male and `0x00`
    corresponds to female. We can reduce the memory footprint eightfold by using `s` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b8c5d49-5f72-4ff0-b14b-be32938fbc6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may wonder why there are 40 extra bytes being reported. Those 40 bytes
    are actually used by the array container. Now, given that the gender column is
    binary in this case, we can actually squeeze it further by storing bits instead
    of bytes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b4e3d6b-c79f-461d-a2df-aa7add823836.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, we reduce the memory usage approximately eightfold (by going from 1
    byte to 1 bit) by using `BitArray` to store the gender values. This is an aggressive
    optimization of memory usage. But we still need to store the `Male` and `Female` strings somewhere,
    right? This is an easy task because we know they can be tracked in any data structure,
    such as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b91455c-34a6-49fb-b3f3-c759ba626a25.png)'
  prefs: []
  type: TYPE_IMG
- en: To summarize, we are now capable of storing 100,000 gender values in 12,568
    + 370 = 12,938 bytes of memory. Compared to the original dumb way of storing strings
    directly, we have saved more than 98% of memory consumption! How did we achieve
    such a huge saving? Because all records share the same two strings. The only data
    that we have to maintain is an array of references to those strings.
  prefs: []
  type: TYPE_NORMAL
- en: So, that is the concept of the flyweight pattern. The same trick is used over
    and over again in many places. For example, the `CSV.jl` package uses a package
    called `CategoricalArrays`, which provides essentially the same kind of memory
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over the last few traditional patterns—bridge, decorator, and
    facade.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge, decorator, and facade patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me explain how the bridge, decorator, and facade patterns work. At this
    point, we will not provide any more code samples for these patterns, only because
    they are relatively easy to implement, as you are already equipped with many ideas
    from prior design pattern sections. Perhaps not too surprisingly, the same tricks
    that you have learned so far—delegation, singleton type, multiple dispatch, first-class
    functions, abstract types, and interfaces—are the same ones that you can use to
    tackle any type of problem.
  prefs: []
  type: TYPE_NORMAL
- en: The **bridge** pattern is used to decouple an abstraction from its implementation
    so that it can evolve independently. In Julia, we can build a hierarchy of abstract
    types for which implementers can develop software that conforms to those interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Julia's numeric types are good examples of how such a system can be designed.
    There are many abstract types available, such as `Integer`, `AbstractFloat`, and
    `Real`. Then, there are concrete implementations, such as `Int` and `Float64`,
    provided by the `Base` package. The abstraction is designed in such a way that
    people can provide an alternative implementation of numbers. For example, the
    `SaferInteger` packages provide a safer implementation for integers that avoids
    numerical overflow.
  prefs: []
  type: TYPE_NORMAL
- en: The **decorator** pattern is also simple to implement. It can be used to enhance
    an existing object with new functionalities, hence the term *decorator*. Suppose
    that we have bought a third-party library, but we are not totally satisfied with
    the functionalities. Using the decorator pattern, we can add value by wrapping
    the existing library with new functions.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done naturally using the Delegation pattern. By wrapping an existing
    type with a new type, we can reuse existing functionalities by delegating to the
    underlying object. Then, we can add new functions to the new type to gain new
    capabilities. We see this pattern used over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: The **facade** pattern is used to encapsulate complex subsystems and provide
    a simplified interface for clients. How do we do that in Julia? By now, we should
    have seen this pattern over and over again; all we need to do is create a new
    type and provide a simple API that operates on the new type. We can use the Delegation
    pattern to forward requests to other enclosed types.
  prefs: []
  type: TYPE_NORMAL
- en: We have now looked at all traditional object-oriented patterns. You might have
    noticed that many of the use cases can be solved with the standard Julia features
    and patterns described in this book. This is not a coincidence—it is just that
    easy to deal with complex problems in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone over the traditional object-oriented design patterns
    extensively. We started with the humble belief that the same patterns in object-oriented
    programming often need to be applied in Julia programming.
  prefs: []
  type: TYPE_NORMAL
- en: We started reviewing creational design patterns, which include the factory method,
    abstract factory, singleton, builder, and prototype patterns. These patterns involve
    various techniques for creating objects. When it comes to Julia, we can mostly
    solve these problems using abstract types, interfaces, and multiple dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also spent a considerable amount of effort looking at behavioral design
    patterns. These patterns are made to handle collaboration and communication between
    components in an application. We looked at 11 patterns: chain of responsibility,
    mediator, memento, observer, state, strategy, template method, command, interpreter,
    iterator, and visitor. These patterns can be implemented in Julia using traits,
    interfaces, multiple dispatch, and first-class functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed several structural design patterns. These patterns are
    used to construct bigger components by reusing existing ones. This includes the
    adapter, composite, flyweight, bridge, decorator, and facade patterns. In Julia,
    they can be handled with abstract types, interfaces, and the delegation design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you are convinced that building software does not need to be difficult.
    Just because OOP made us believe that we need all of this complexity to design
    software, it does not mean that we have to do the same in Julia. The solutions
    to the problems that are presented in this chapter mostly require the basic software
    design skills and patterns that you found in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get into a more advanced topic regarding data types
    and dispatch. *Get ready to rock!*
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What technique can we use to implement the abstract factory pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we prevent a singleton from being initialized multiple times in a multithreaded
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Julia feature is essential to implementing the observer pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we customize an operation using the template method pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we make an adapter to implement a target interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of the flyweight pattern and what strategy can we use to
    achieve it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Julia feature can we use to implement the strategy pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
