- en: Traditional Object-Oriented Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统面向对象模式
- en: By now, we have already learned about the many design patterns that we need
    to know in order to be an effective Julia programmer. The cases presented in the
    previous chapters included various problems that we can solve by writing *idiomatic*
    Julia code. Some might ask, after all these years, I have learned and adapted
    to the **object-oriented programming** (**OOP**) paradigm; how do I apply the
    same concepts in Julia? The general answer is, you won't solve the problem the
    same way. The solution written in Julia will look different, reflecting a different
    programming paradigm. Nevertheless, it is still an interesting exercise to think
    about how to adopt some of the OOP techniques in Julia.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了成为一名有效的Julia程序员所需了解的许多设计模式。前几章中提出的案例包括了我们可以通过编写*惯用*的Julia代码解决的问题。有些人可能会问，经过这么多年，我已经学习和适应了**面向对象编程**（**OOP**）范式；我如何在Julia中应用同样的概念？一般的回答是，你不会以同样的方式解决问题。用Julia编写的解决方案将看起来不同，反映了不同的编程范式。尽管如此，思考如何在Julia中采用一些OOP技术仍然是一个有趣的练习。
- en: 'In this chapter, we will cover all 23 design patterns from the classic **Gang
    of Four** (**GoF**) *Design Patterns* book. We will keep the tradition and organize
    the topics in the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖经典《**四人帮**》（**GoF**）《*设计模式*》书中所有的23种设计模式。我们将保持传统，以下章节中组织主题：
- en: Creational patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型模式
- en: Behavioral patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为模式
- en: Structural patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构模式
- en: By the end of this chapter, you will have an idea of how each of these patterns
    may be applied in Julia, as compared to an OOP approach.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解这些模式如何在Julia中应用，与面向对象方法相比。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter11).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源代码位于[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter11)。
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在Julia 1.3.0环境中进行了测试。
- en: Creational patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型模式
- en: '**Creational** patterns refer to the various ways of constructing and instantiating
    objects. Since OOP groups data and behavior together, and since a class may inherit
    the structure and behavior from an ancestor class, there are additional levels
    of complexity involved when building a large-scale system. By design, Julia has
    already gotten rid of many issues by not allowing fields to be declared in abstract
    types and not allowing creating new subtypes from concrete types. Nevertheless,
    some of these patterns could be helpful in certain situations.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建型**模式指的是构建和实例化对象的各种方式。由于OOP将数据和操作组合在一起，并且由于一个类可能从祖先类继承结构和行为，因此在构建大型系统时涉及额外的复杂性。设计上，Julia已经通过不允许在抽象类型中声明字段和不允许从具体类型创建新子类型来解决了许多问题。尽管如此，在某些情况下，这些模式可能有所帮助。'
- en: The creational patterns include the factory method, abstract factory, singleton,
    builder, and prototype patterns. We shall discuss them in detail in the following
    sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式包括工厂方法、抽象工厂、单例、建造者和原型模式。我们将在以下章节中详细讨论它们。
- en: The factory method pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The idea of the **factory method** pattern is to provide a single interface
    to create different types of objects that conform to an interface while hiding
    the actual implementation from the client. This abstraction decouples the client
    from the underlying implementation of the feature provider.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂方法**模式的想法是提供一个单一接口来创建符合接口的不同类型的对象，同时隐藏实际实现细节。这种抽象将客户端与功能提供者的底层实现解耦。'
- en: 'For example, a program might need to format some numbers in the output. In
    Julia, we might want to use the `Printf` package to format numbers, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个程序可能需要在输出中格式化一些数字。在Julia中，我们可能想使用`Printf`包来格式化数字，如下所示：
- en: '![](img/164d6264-cef6-4276-9c1a-54d6e23f4a19.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/164d6264-cef6-4276-9c1a-54d6e23f4a19.png)'
- en: 'Perhaps we do not want to couple with the `Printf` package because we want
    to switch and use a different formatting package in the future. In order to make
    the application more flexible, we can design an interface where numbers can be
    formatted according to their types. The following interface is described in the
    doc string:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们不想与 `Printf` 包耦合，因为我们希望在将来能够切换并使用不同的格式化包。为了使应用程序更加灵活，我们可以设计一个接口，其中数字可以根据它们的类型进行格式化。以下接口在文档字符串中描述：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `format` function takes a `formatter` and a numeric value, `x`, and returns
    a formatted string. The `Formatter` type is defined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 函数接受一个 `formatter` 和一个数值 `x`，并返回一个格式化的字符串。`Formatter` 类型定义如下：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, the factory methods basically create singleton types for dispatch purposes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，工厂方法基本上创建用于调度的单例类型：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The default implementation may look like the following, utilizing the `Printf`
    package:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现可能如下所示，利用 `Printf` 包：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Putting everything in a `FactoryExample` module, we can run the following testing
    code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放入 `FactoryExample` 模块中，我们可以运行以下测试代码：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/8eadb69d-fa16-4659-81a7-1372fd4fe911.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8eadb69d-fa16-4659-81a7-1372fd4fe911.png)'
- en: Should we ever want to change the formatter in the future, we just need to provide
    a new implementation with format functions defined for the numeric types that
    we want to support. This is handy when we have a lot of number-formatting code
    lying around. The switch to a different formatter involves literally two lines
    of code changes (in this example).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们未来想要更改格式化器，我们只需提供一个新实现，其中定义了我们要支持的数值类型的格式化函数。当我们有很多数字格式化代码时，这很有用。切换到不同的格式化器实际上只需要两行代码的改变（在这个例子中）。
- en: Let's look at the abstract factory pattern next.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看抽象工厂模式。
- en: The abstract factory pattern
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The **abstract factory** pattern is used for creating objects via a set of factory
    methods, which are abstracted away from the concrete implementation. The abstract
    factory pattern can be viewed as a factory of factories.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象工厂**模式用于通过一组工厂方法创建对象，这些方法从具体实现中抽象出来。抽象工厂模式可以看作是工厂的工厂。'
- en: 'We can explore the example of building a multiplatform GUI library that supports
    Microsoft Windows and macOS. As we want to develop code that is cross-platform,
    we can leverage this design pattern. This design is described in the following
    UML diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以探索构建一个支持 Microsoft Windows 和 macOS 的多平台 GUI 库的例子。由于我们想要开发跨平台的代码，我们可以利用这个设计模式。这种设计在以下
    UML 图中描述：
- en: '![](img/b9e33f83-3b44-4b67-9eca-0e1b6290dd37.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9e33f83-3b44-4b67-9eca-0e1b6290dd37.png)'
- en: In a nutshell, we have presented two types of GUI objects here: `Button` and
    `Label`. The concept is the same for both Microsoft Windows and macOS platforms.
    The client does not care how these objects are instantiated; instead, it asks
    an abstract factory `GUIFactory` to return factories (either `MacOSFactory` or
    `WindowsFactory`) that support multiple factory methods for creating platform-dependent
    GUI objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们在这里展示了两种类型的 GUI 对象：`Button` 和 `Label`。对于 Microsoft Windows 和 macOS 平台，概念是相同的。客户端不关心这些对象是如何实例化的；相反，它要求一个抽象工厂
    `GUIFactory` 返回支持多个工厂方法的工厂（即 `MacOSFactory` 或 `WindowsFactory`），以创建平台相关的 GUI 对象。
- en: 'The Julia implementation can simply be modeled with the appropriate abstract
    and concrete types. Let''s start at the OS level:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的实现可以通过适当的抽象和具体类型简单地建模。让我们从操作系统级别开始：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We intended to use `MacOS` and `Windows` as singleton types for dispatch purposes
    later. For now, let''s continue and define the abstract types `Button` and `Label`
    as follows. Additionally, we have defined `show` methods for each type respectively:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原本打算使用 `MacOS` 和 `Windows` 作为后续调度目的的单例类型。现在，让我们继续并定义抽象类型 `Button` 和 `Label`，如下所示。此外，我们分别为每种类型定义了
    `show` 方法：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We do need to provide concrete implementation for these GUI objects. Let''s
    define them now:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要为这些 GUI 对象提供具体实现。现在让我们定义它们：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the sake of simplicity, we just hold on to a text string, whether it''s
    a button or a label. As factory methods are platform-dependent, we can leverage
    the OS trait and multiple dispatch to call the right `make_button` or `make_label`
    functions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们只保留一个文本字符串，无论是按钮还是标签。由于工厂方法是平台相关的，我们可以利用 OS 特性和多重分派来调用正确的 `make_button`
    或 `make_label` 函数：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For testing, we have hardcoded the `current_os` function to return `MacOS()`.
    In reality, this function should return either `MacOS()` or `Windows()` by examining
    whatever system variable is appropriate to identify the platform. Finally, we
    need to implement the specific functions for each platform as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们硬编码了`current_os`函数以返回`MacOS()`。实际上，这个函数应该通过检查适当的系统变量来返回`MacOS()`或`Windows()`以识别平台。最后，我们需要按如下方式实现每个平台的具体函数：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our simple test just involves calling the `make_button` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的测试只是调用`make_button`函数：
- en: '![](img/c6f09e64-b683-4b9e-a297-21f9303a31f0.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6f09e64-b683-4b9e-a297-21f9303a31f0.png)'
- en: Using multiple dispatch, we can easily extend to new platforms or new GUI objects
    by simply defining new functions for the specific OS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多态，我们可以轻松扩展到新的平台或新的GUI对象，只需为特定的操作系统定义新函数即可。
- en: Next, we will look into the singleton pattern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨单例模式。
- en: The singleton pattern
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The **singleton** pattern is used to create a single instance of an object and
    reuse it from anywhere. A singleton object is typically constructed when the application
    starts, or it can be created lazily on the first use of the object. An interesting
    requirement for the singleton pattern arises for multithreaded applications because
    the instantiation of the singleton object must happen only once. It can be a challenge
    if the object creation function is called lazily from many threads.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式用于创建对象的单个实例并在任何地方重用它。单例对象通常在应用程序启动时构建，或者可以在对象首次使用时懒加载创建。对于多线程应用程序，单例模式有一个有趣的要求，即单例对象的实例化只能发生一次。如果对象创建函数从多个线程中懒加载，这可能会成为一个挑战。
- en: 'Suppose that we want to create a singleton called `AppKey` that is used for
    encryption in the application:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个名为`AppKey`的单例，该单例用于应用程序中的加密：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Initially, we may be tempted to use a global variable. Given that we have learned
    about the performance impact of global variables, we can apply the global constant
    pattern that we learned in [Chapter 6](c8cedc0d-716d-46c4-8768-ae0084a10bf9.xhtml),
    *Performance Patterns*. Essentially, a `Ref` object is created as a placeholder,
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们可能会倾向于使用全局变量。鉴于我们已经了解了全局变量的性能影响，我们可以应用在[第6章](c8cedc0d-716d-46c4-8768-ae0084a10bf9.xhtml)“性能模式”中学到的全局常量模式。本质上，创建了一个`Ref`对象作为占位符，如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `appkey` global constant is first created without being assigned with any
    value, but then it can be updated when the singleton is instantiated. The construction
    of singleton can be done as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`appkey`全局常量最初创建时没有分配任何值，但随后可以在单例实例化时更新。单例的构建可以按如下方式进行：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code works fine as long as there is a single thread. If we test it with
    multiple threads, then the `isassigned` check is problematic. For example, two
    threads might check whether the key is assigned at the same time, and both threads
    might think that the singleton object needs to be instantiated. In this case,
    we end up constructing the singleton twice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个线程时，此代码运行正常。如果我们用多个线程测试它，那么`isassigned`检查就成问题了。例如，两个线程可能会同时检查密钥是否已分配，并且两个线程都可能会认为需要实例化单例对象。在这种情况下，我们最终会构建单例两次。
- en: 'The testing code is shown as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can demonstrate the problem below. Let''s start the Julia REPL with four
    threads:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以演示以下问题。让我们用四个线程启动Julia REPL：
- en: '![](img/491e40c8-86df-42c0-88c7-40e95b266b74.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/491e40c8-86df-42c0-88c7-40e95b266b74.png)'
- en: 'Then, we can run the testing code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行测试代码：
- en: '![](img/fe8831ec-3da2-423c-8be6-ebc6d3e51e95.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe8831ec-3da2-423c-8be6-ebc6d3e51e95.png)'
- en: As you can see, the singleton being constructed twice here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里的单例被构建了两次。
- en: 'So how do we solve this problem? We can use a lock to synchronize the singleton
    construction logic. Let''s first create another global constant to hold the lock:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何解决这个问题呢？我们可以使用锁来同步单例构造逻辑。让我们首先创建另一个全局常量来持有锁：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To use the lock, we can modify the `construct` function as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用锁，我们可以按如下方式修改`construct`函数：
- en: '![](img/9d29c23e-2456-47fb-82f8-8f8c5a9f5cee.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d29c23e-2456-47fb-82f8-8f8c5a9f5cee.png)'
- en: We must first acquire the lock before checking whether `appkey[]` is already
    assigned. When we are done constructing the singleton (or skipping it, if it has
    already been created), we release the lock. Note that we have wrapped the critical
    section of the code in a `try` block, and we placed the `unlock` function in the
    `finally` block. This is done to ensure that the lock is released regardless of
    whether the construction of the singleton is successful or not.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查`appkey[]`是否已经被分配之前，我们必须首先获取锁。当我们完成单例对象的构建（或者如果它已经被创建，则跳过它）后，我们释放锁。请注意，我们将代码的关键部分包裹在一个`try`块中，并将`unlock`函数放在`finally`块中。这样做是为了确保无论单例对象的构建是否成功，锁都会被释放。
- en: 'Our new test shows that the singleton is constructed only once:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新测试显示单例对象只被构建一次：
- en: '![](img/b1ac22bd-96d0-46b2-afa1-2aa38cef4392.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1ac22bd-96d0-46b2-afa1-2aa38cef4392.png)'
- en: The singleton pattern is useful when we need to hold on to a single object.
    Practical use cases include database connections or other references to external
    resources. Next, we will take a look at the builder pattern.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要保持一个单一对象时，单例模式很有用。实际的应用场景包括数据库连接或其他外部资源的引用。接下来，我们将探讨建造者模式。
- en: The builder pattern
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者模式
- en: The **builder** pattern is used to build a complex object by incrementally building
    simpler parts of it. We can imagine that a factory assembly line would work in
    a similar fashion. In that case, a product is assembled step-by-step with more
    and more parts, and at the end of the assembly line, the product is finished and
    ready to go.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**建造者模式**用于通过逐步构建更简单的部分来构建复杂对象。我们可以想象工厂装配线将以类似的方式工作。在这种情况下，产品将逐步组装，越来越多地添加部件，并在装配线末端，产品完成并准备好。'
- en: 'One benefit of this pattern is that the builder code looks like a linear data
    flow and is easier for some people to read. In Julia, we may want to write something
    like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的优点之一是建造者代码看起来像线性数据流，对于某些人来说更容易阅读。在Julia中，我们可能想要编写如下内容：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Essentially, this is the exact functional pipe pattern described in [Chapter
    9](6682bca1-9221-46fa-84f2-f5379fd4d01b.xhtml), *Miscellaneous Patterns*. For
    this example, we can develop higher-order functions for building each part (such
    as the wheels, engine, and chassis). The following code illustrates how to create
    a curry (higher-order) function for creating wheels:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这正是[第9章](6682bca1-9221-46fa-84f2-f5379fd4d01b.xhtml)中描述的精确功能管道模式，*杂项模式*。对于这个例子，我们可以为构建每个部分（如轮子、引擎和底盘）开发高阶函数。以下代码演示了如何创建一个用于创建轮子的curry（高阶）函数：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `add` function just returns an anonymous function that takes a `Car` object
    as input and returns an enhanced `Car` object. Likewise, we can develop similar
    functions for the `Engine` and `Chassis` types. Once these functions are ready,
    we can build a car by simply chaining these function calls together.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`函数只是返回一个匿名函数，该函数接受一个`Car`对象作为输入并返回一个增强的`Car`对象。同样，我们可以为`Engine`和`Chassis`类型开发类似的功能。一旦这些函数准备就绪，我们只需通过链式调用这些函数来构建一辆车。'
- en: Next, we will discuss the prototype pattern.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论原型模式。
- en: The prototype pattern
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: The **prototype** pattern is used to create new objects by cloning fields from
    an existing object, or the prototype object. The idea is that some objects are
    difficult or time-consuming to construct, so it would be useful to make a copy
    of the object and call it a new one by making small modifications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**原型模式**通过从现有对象或原型对象克隆字段来创建新对象。其理念是，某些对象难以构建或构建耗时，因此制作一个对象的副本并进行少量修改将其称为新对象会很有用。'
- en: As Julia keeps data and logic separate, making copies of objects is really the
    same as duplicating the content. That sounds easy, but we should not overlook
    the difference between a shallow copy and a deep copy.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Julia将数据和逻辑分开，复制对象实际上等同于复制内容。这听起来很简单，但我们不应忽视浅拷贝和深拷贝之间的区别。
- en: A **shallow copy** of an object is merely an object with all the fields copied
    from another object. A **deep copy** of an object is created by recursively going
    into the fields of the object and copying their underlying fields as well. As
    such, a shallow copy may not be desirable because some data can be shared with
    the original object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的**浅拷贝**仅仅是一个从另一个对象复制所有字段的简单对象。对象的**深拷贝**是通过递归进入对象的字段并复制它们的底层字段来创建的。因此，浅拷贝可能不是理想的选择，因为某些数据可能与原始对象共享。
- en: 'To illustrate this, let''s consider the following struct definitions for a
    bank account example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们考虑以下银行账户示例的结构定义：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, suppose that we have an array of `Customer` objects that are returned
    from this function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个从该函数返回的`Customer`对象数组：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `sample_customer` function returns an array of two customers. For testing
    purposes, let''s build a test harness to update the balance for the first customer
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample_customer`函数返回两个客户的数组。为了测试目的，让我们构建一个测试框架来更新第一个客户的余额，如下所示：'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we exercise the test harness with built-in `copy` and `deepcopy` functions,
    we get the following results:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用内置的`copy`和`deepcopy`函数对测试框架进行练习，我们会得到以下结果：
- en: '![](img/736a8fe8-a14f-4f8a-a7a6-32972342531a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/736a8fe8-a14f-4f8a-a7a6-32972342531a.png)'
- en: Unexpectedly, we got the wrong result in the `orig` output since we should be
    adding $500 to the new customer. Why do we have the same balance for both the
    original customer record and the new customer record instead? This is because
    a shallow copy was made from the customer array when the `copy` function was used.
    When this happens, the customer records are essentially shared between the original
    array and the new array. This means that mutating the new record also affected
    the original record.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 意外地，我们在`orig`输出中得到了错误的结果，因为我们本应该给新客户增加$500。为什么原始客户记录和新客户记录的余额相同呢？这是因为当使用`copy`函数时，从客户数组中创建了一个浅拷贝。当这种情况发生时，客户记录在原始数组和新数组之间实际上是共享的。这意味着修改新记录也会影响原始记录。
- en: In the second part of the result, only the new copy of the customer record was
    changed. This is because the `deepcopy` function was used. By definition, the
    prototype pattern requires making changes to the copy. It is probably safer to
    make a deep copy should this pattern be applied.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果的第二部分中，只有客户记录的新副本被更改。这是因为使用了`deepcopy`函数。根据定义，原型模式要求对副本进行修改。如果应用此模式，进行深拷贝可能更安全。
- en: We have covered all five creational patterns. These patterns allow us to build
    new objects in an effective manner.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了所有五个创建型模式。这些模式允许我们以有效的方式构建新对象。
- en: Next, we're going to cover a set of behavioral design patterns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一组行为设计模式。
- en: Behavioral patterns
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: '**Behavioral** patterns refer to how objects are designed to collaborate and
    communicate with each other. There are 11 GoF patterns from the OOP paradigm.
    We will cover all of them here with some interesting hands-on examples.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为**模式指的是对象如何被设计来相互协作和通信。从面向对象范式中有11个GoF模式。我们将在这里通过一些有趣的动手示例涵盖所有这些模式。'
- en: The chain-of-responsibility pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链模式
- en: The **chain-of-responsibility** (**CoR**) pattern is used to process the request
    using a chain of request handlers, whereas each handler has its own distinct and
    independent responsibility.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**责任链**（**CoR**）模式用于使用请求处理链来处理请求，其中每个处理程序都有自己的独特和独立的责任。'
- en: This pattern is quite common in many applications. For example, web servers
    usually handle HTTP requests using so-called middleware. Each piece of middleware
    is responsible for performing a specific task—for example, authenticating requests,
    maintaining cookies, validating requests, and performing business logic. A specific
    requirement about the CoR pattern is that any part of the chain can be broken
    at any time, resulting in an early exit of the process. In the preceding web server
    example, the authentication middleware may have decided that the user has not
    been authenticated, and that therefore, the user should be redirected to a separate
    website for login. This means that the rest of the middleware is skipped unless
    the user gets past the authentication step.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在许多应用中都很常见。例如，Web服务器通常使用所谓的中间件来处理HTTP请求。每个中间件部分负责执行特定的任务——例如，验证请求、维护cookie、验证请求和执行业务逻辑。关于责任链模式的一个特定要求是，链的任何部分都可以在任何时候被打破，从而导致过程的早期退出。在前面的Web服务器示例中，认证中间件可能已经决定用户未通过认证，因此用户应该被重定向到另一个网站进行登录。这意味着除非用户通过了认证步骤，否则将跳过其余的中间件。
- en: 'How do we design something like this in Julia? Let''s look at a simple example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Julia中设计这样的东西？让我们看看一个简单的例子：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A `DepositRequest` object contains an amount that a customer wants to deposit
    in their account. Our marketing department wants us to provide a thank-you note
    to the customer if the deposit amount is greater than $100,000\. To process such
    a request, we have designed three functions, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`DepositRequest`对象包含客户想要存入其账户的金额。我们的营销部门希望我们如果存款金额超过$100,000，就向客户提供感谢信。为了处理此类请求，我们设计了三个函数，如下所示：'
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What is the responsibility of these functions?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的职责是什么？
- en: The `update_account_handler` function is responsible for updating the account
    with the new deposit.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_account_handler`函数负责使用新的存款更新账户。'
- en: The `send_gift_handler` function is responsible for sending a thank-you note to
    the customer for a large deposit amount.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send_gift_handler`函数负责向客户发送感谢信，以感谢其大额存款。'
- en: The `notify_customer` function is responsible for informing the customer after
    the deposit is made.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_customer`函数负责在存款完成后通知客户。'
- en: These functions also return an enum value, either `CONTINUE` or `HANDLED`, to
    indicate whether the request should be passed on to the next handler when the
    current one is finished.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数也返回一个枚举值，要么是`CONTINUE`，要么是`HANDLED`，以指示在当前处理程序完成后是否应将请求传递给下一个处理程序。
- en: 'It should be quite clear that these functions run in a specific order. In particular,
    the `notify_customer` function should run at the end of the transaction. For that
    reason, we can establish an array of functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很清楚，这些函数以特定的顺序运行。特别是，`notify_customer`函数应在交易结束时运行。因此，我们可以建立一个函数数组：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also have a function to execute these handlers in order:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有一个函数来按顺序执行这些处理程序：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As part of this design, the loop will end immediately if any handler returns
    a value of `HANDLED`. Our test code for testing the function of sending the thank-you
    note to a premier customer is shown as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个设计的一部分，如果任何处理程序返回`HANDLED`值，循环将立即结束。我们用于测试向VIP客户发送感谢信功能的测试代码如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running the test gives us this result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试给出以下结果：
- en: '![](img/5d1b30b8-f33a-43ad-a73c-f416ea37ba4e.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d1b30b8-f33a-43ad-a73c-f416ea37ba4e.png)'
- en: I will leave it as an exercise for you to build another function in this chain
    to perform an early exit. But for now, let's move on to the next pattern—the mediator
    pattern.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个任务留给你，在链中构建另一个函数以执行早期退出。但到目前为止，让我们继续到下一个模式——中介者模式。
- en: The mediator pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者模式
- en: The **mediator** pattern is used to facilitate communication between different
    components in an application. This is done in such a way that individual components
    are decoupled from each other. In most applications, changes in one component
    can affect another. Sometimes, there are also cascading effects. A mediator can
    take the responsibility of getting notified when one component is changed, and
    it can notify other components about the event so that further downstream updates
    can be made.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**中介者模式**用于促进应用程序中不同组件之间的通信。这样做的方式是使各个组件相互解耦。在大多数应用程序中，一个组件的变化可能会影响另一个组件。有时，也会有级联效应。中介者可以承担在组件发生变化时被通知的责任，并且它可以通知其他组件关于该事件的详细信息，以便进行进一步的下游更新。'
- en: 'As an example, we can consider the use case of a **graphical user interface**
    (**GUI**). Suppose that we have a screen that contains three fields for our favorite
    banking application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以考虑**图形用户界面**（**GUI**）的使用案例。假设我们有一个屏幕，其中包含三个字段，用于我们的最喜欢的银行应用程序：
- en: '**Amount**: Current balance in the account.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金额**：账户中的当前余额。'
- en: '**Interest Rate**: Current interest rate expressed as a percentage.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利率**：以百分比表示的当前利率。'
- en: '**Interest Amount**: Interest amount. This is a read-only field.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利息金额**：利息金额。这是一个只读字段。'
- en: How do they interact with each other? If the amount is changed, then the interest
    amount needs to be updated. Likewise, if the interest rate is changed, then the
    interest amount needs to be updated as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是如何相互作用的？如果金额发生变化，那么利息金额需要更新。同样，如果利率发生变化，那么利息金额也需要更新。
- en: 'To model the GUI, we can define the following types for the individual GUI
    objects onscreen:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟GUI，我们可以为屏幕上的单个GUI对象定义以下类型：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Widget` is an abstract type and it can be used as the supertype for all
    GUI objects. This application only needs text fields, so we just define a `TextField`
    widget. A text field is identified by an `id`, and it contains a `value`. In order
    to extract and update the value in the text field widget, we can define functions
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget` 是一个抽象类型，它可以作为所有 GUI 对象的超类型。这个应用程序只需要文本字段，所以我们只定义了一个 `TextField` 小部件。文本字段通过
    `id` 来标识，并包含一个 `value`。为了从文本字段小部件中提取和更新值，我们可以定义如下函数：'
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'From the preceding code, we can see that the `get_number` function gets the
    value from the text field widget and returns it as a floating-point number. The
    `set_number` function populates the text field widget with the provided numeric
    value. Now, we also need to create the application, so we conveniently define
    a struct as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到 `get_number` 函数从文本字段小部件中获取值，并将其作为浮点数返回。`set_number` 函数使用提供的数值填充文本字段小部件。现在，我们还需要创建应用程序，所以我们方便地定义了一个结构体如下：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For this example, we will implement a `notify` function to simulate an event
    that is sent to the text field widget after the user enters a value. In reality,
    the GUI platform typically performs that function. Let''s call it `on_change_event`,
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将实现一个 `notify` 函数来模拟用户输入值后发送到文本字段小部件的事件。在现实中，GUI 平台通常会执行这个功能。让我们称它为
    `on_change_event`，如下所示：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `on_change_event` function does nothing else but communicate to the mediator
    (the app) that something has just happened to this widget. As for the app itself,
    here''s how it handles the notification:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_change_event` 函数除了向中介（应用程序）传达这个小部件刚刚发生了某些事情之外，没有做其他任何事情。至于应用程序本身，以下是它处理通知的方式：'
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, it simply checks whether the widget that is being updated is
    either the Amount or Interest Rate field. If so, it calculates a new interest
    amount and populates the Interest Amount field with the new value. Let''s do a
    quick test:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只是检查正在更新的小部件是否是金额或利率字段。如果是，它计算新的利息金额，并用新值填充利息金额字段。让我们快速测试一下：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `test` function displays the initial state of the application, updates
    the amount field, and displays the new state. For the sake of brevity, the source
    code for the `print_current_state` function is not shown here, but is available
    on the book''s GitHub site. The output of the test program is shown as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 函数显示应用程序的初始状态，更新金额字段，并显示新状态。为了简洁起见，这里没有显示 `print_current_state` 函数的源代码，但可以在本书的
    GitHub 网站上找到。测试程序的输出如下所示：'
- en: '![](img/a1a05a91-0844-43d8-980b-b0e034b98f79.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1a05a91-0844-43d8-980b-b0e034b98f79.png)'
- en: The benefit of using the 2 mediator pattern is that every object can focus on
    its own responsibility and not worry about the downstream impact. A central mediator
    takes on the responsibility of organizing activities and handling events and communications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 2 中介模式的优点是每个对象都可以专注于自己的职责，而不用担心下游的影响。一个中心的中介承担组织活动和处理事件以及通信的责任。
- en: Next, we shall look at the memento pattern.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨备忘录模式。
- en: The memento pattern
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录模式
- en: The **memento** pattern is a state management technique that you can use to
    restore your work to a previous state when needed. A common example is the Undo
    function of a word processor application. After making 10 changes, we can always
    undo the prior operations and return to the original state before those 10 changes
    were made. Similarly, an application may remember the most recently opened files
    and provide a menu of choices so that the user can quickly reopen a previously
    opened file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录模式是一种状态管理技术，您可以在需要时将工作恢复到先前的状态。一个常见的例子是文字处理应用程序的撤销功能。在做出 10 次更改后，我们总是可以撤销先前的操作，并返回到这
    10 次更改之前的原始状态。同样，一个应用程序可能会记住最近打开的文件，并提供一个选择菜单，以便用户可以快速重新打开之前打开的文件。
- en: 'Implementing the memento pattern in Julia is quite simple. We can just store
    previous states in an array and when making a change, we can push the new state
    to the array. When we want to undo our actions, we restore the previous state
    by popping from the array. To illustrate this idea, let''s consider the case of
    a blog post-editing application. We can define the data types as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中实现备忘录模式非常简单。我们只需将先前状态存储在数组中，在做出更改时，我们可以将新状态推送到数组中。当我们想要撤销操作时，我们可以通过从数组中弹出来恢复先前的状态。为了说明这个想法，让我们考虑一个博客文章编辑应用程序的案例。我们可以定义数据类型如下：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, a `Blog` object contains an array of `Post` objects. By convention,
    the last element in the array is the current version of the blog post. If there
    were five posts in the array, then it means that four changes have been made so
    far. Creating a new blog is as easy, as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个`Blog`对象包含一个`Post`对象的数组。按照惯例，数组中的最后一个元素是博客文章的当前版本。如果数组中有五个帖子，那么这意味着已经进行了四次更改。创建一个新的博客就像以下代码所示：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By default, a new blog object contains just one version. As the user makes changes,
    the array will grow. For convenience, we can provide a `version_count` function
    that returns the number of revisions that the user has made so far.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一个新的博客对象只包含一个版本。随着用户进行更改，数组将增长。为了方便，我们可以提供一个`version_count`函数，该函数返回用户迄今为止所做的修订次数。
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To obtain the current post, we can simply take the last element of the array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前帖子，我们可以简单地取数组的最后一个元素：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, when we have to update the blog, we must push the new version to the array.
    Here is the function that we use to update the blog with a new title or content:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们需要更新博客时，我们必须将新版本推送到数组中。以下是用来用新标题或内容更新博客的函数：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `update!` function takes a `Blog` object, and optionally it can take either
    an updated `title`, `content`, or both. Basically, it creates a new `Post` object
    and pushes it into the `posts` array. Undoing is done as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`update!`函数接受一个`Blog`对象，并且可以可选地接受更新后的`title`、`content`或两者。基本上，它创建一个新的`Post`对象并将其推入`posts`数组。撤销操作如下：'
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can test it with the following `test` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下`test`函数来测试它：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is shown as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/e64c8f77-35a7-4be7-bef1-698e54eef529.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e64c8f77-35a7-4be7-bef1-698e54eef529.png)'
- en: As you can see, it is quite easy to implement the memento pattern. We will cover
    the observer pattern next.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实现备忘录模式相当简单。我们将在下一节介绍观察者模式。
- en: The observer pattern
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The **observer** pattern is useful for registering observers to an object so
    that all state changes in that object trigger the sending of notifications to
    the observers. In a language that supports first-class functions—for example,
    Julia—such functionality can be implemented easily by maintaining a list of functions
    that can be called before or after the state changes of an object. Sometimes,
    these functions are called **hooks**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者**模式对于将观察者注册到对象中非常有用，以便在该对象中所有状态变化都会触发向观察者发送通知。在支持一等函数的语言中——例如，Julia——可以通过维护一个在对象状态变化前后可以调用的函数列表来轻松实现此类功能。有时，这些函数被称为**钩子**。'
- en: 'The implementation of the observer pattern in Julia may consist of two parts:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中观察者模式的实现可能包括两个部分：
- en: Extend the `setproperty!` function of an object to monitor state changes and
    notify observers.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展对象的`setproperty!`函数以监控状态变化并通知观察者。
- en: Maintain a dictionary that can be used to look up the functions to call.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 维护一个可以用来查找要调用的函数的字典。
- en: 'For this demonstration, we will bring up the bank account example again:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们将再次使用银行账户示例：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the data structure for maintaining observers:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是维护观察者的数据结构：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we have chosen to use `IdDict` instead of the regular `Dict` object. `IdDict`
    is a special type that uses Julia''s internal object ID as the key of the dictionary.
    To register observers, we provide the following function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择使用`IdDict`而不是常规的`Dict`对象。`IdDict`是一种特殊类型，它使用Julia的内部对象ID作为字典的键。为了注册观察者，我们提供了以下函数：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s extend the `setproperty!` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们扩展`setproperty!`函数：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This new `setproperty!` function not only updates the field for the object,
    but also calls the observer functions with both the previous state and the current
    state after the field has been updated. For testing purposes, we will create an
    observer function as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`setproperty!`函数不仅更新了对象的字段，而且在字段更新后还调用观察者函数，传递了前一个状态和当前状态。为了测试目的，我们将创建一个观察者函数如下：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our `test` function is written as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`test`函数编写如下：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When running the test program, we get the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试程序时，我们得到以下输出：
- en: '![](img/479fc6b7-8505-4e00-a245-3fa245d02132.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/479fc6b7-8505-4e00-a245-3fa245d02132.png)'
- en: From the output, we can see that the `test_observer_func` function was called
    every time a property is updated. The observer pattern is an easy thing to develop.
    Next, we will look at the state pattern.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到每次属性更新时都会调用`test_observer_func`函数。观察者模式是一个容易开发的东西。接下来，我们将探讨状态模式。
- en: The state pattern
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式
- en: The **state** pattern is used in situations where an object behaves differently
    depending on its internal state. A networking service is a great example. A typical
    implementation for a network-based service is to listen to a specific port number.
    When a remote process connects to the service, it establishes a connection, and
    they use it to communicate with each other until the end of the session. When a
    network service is currently in a listening state, it should allow a new connection
    to be opened; however, no data transmission should be allowed until after the
    connection is opened. Then, after the connection is opened, we should be able
    to send data. By contrast, we should not allow any data to be sent through the
    network connection if the connection is already closed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态模式**用于对象根据其内部状态表现出不同行为的情况。网络服务是一个很好的例子。一个基于网络服务的典型实现是监听特定的端口号。当远程进程连接到服务时，它会建立连接，并且它们使用它进行通信，直到会话结束。当网络服务当前处于监听状态时，它应该允许打开新的连接；然而，在连接打开之前不应允许任何数据传输。然后，在连接打开后，我们应该能够发送数据。相比之下，如果连接已经关闭，则不应允许通过网络连接发送任何数据。'
- en: 'In Julia, we can possibly implement the state pattern using multiple dispatch.
    Let''s first define the following types that are meaningful for network connections:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，我们可以使用多重分派来实现状态模式。让我们首先定义以下对网络连接有意义的类型：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we have leveraged the singleton type pattern. As for the network connection
    itself, we can define the type as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了单例类型模式。至于网络连接本身，我们可以定义类型如下：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s develop a `send` function, which is used to send a message via
    a connection. In our implementation, the `send` function does not do anything
    else except gather the current state of the connection and forward the call to
    a state-specific `send` function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发一个`send`函数，它用于通过连接发送消息。在我们的实现中，`send`函数除了收集连接的当前状态并将调用转发到特定状态`send`函数之外，不做任何事情：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You may recognize this as the Holy Trait pattern. For unit testing, we can
    develop a `test` function for creating a new `Connection` with the specified message
    and sending a message to the `Connection` object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认识这是神圣的特质模式。对于单元测试，我们可以为创建具有指定消息的新`Connection`和向`Connection`对象发送消息开发一个`test`函数：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, the testing code simply runs the `test` function three times, once for
    each possible state:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试代码简单地运行了三次`test`函数，每次对应一个可能的状态：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When running the `test` function, we get the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`test`函数时，我们得到以下输出：
- en: '![](img/ee36e51a-a962-4c80-8f2a-5d9702d14489.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee36e51a-a962-4c80-8f2a-5d9702d14489.png)'
- en: Only the third message was sent successfully, because the connection was in
    the `ESTABLISHED` state. Now, let's take a look at the strategy pattern.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 只有第三条消息成功发送，因为连接处于`ESTABLISHED`状态。现在，让我们看看策略模式。
- en: The strategy pattern
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**策略模式**'
- en: The **strategy** pattern enables clients to select the best algorithm to use
    at runtime. Instead of coupling the client with predefined algorithms, the client
    can be configured with a specific algorithm (strategy) when necessary. In addition,
    sometimes the choice of algorithm cannot be determined ahead of time because the
    decision may depend on the input data, the environment, or something else.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略模式**允许客户端在运行时选择最佳的算法。而不是将客户端与预定义的算法耦合，当需要时，客户端可以配置为特定的算法（策略）。此外，有时算法的选择不能提前确定，因为决策可能取决于输入数据、环境或其他因素。'
- en: In Julia, we can solve the problem using multiple dispatch. Let's consider the
    case of a Fibonacci sequence generator. As we learned from [Chapter 6](c8cedc0d-716d-46c4-8768-ae0084a10bf9.xhtml),
    *Performance Patterns*, the calculation of the *n*^(th) Fibonacci number can be
    tricky when we implement it recursively, so our first algorithm (strategy) may
    be memoization. In addition, we can also solve the same problem using an iterative
    algorithm without using any recursion.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，我们可以使用多重分派来解决这个问题。让我们考虑斐波那契数列生成器的例子。正如我们从[第6章](c8cedc0d-716d-46c4-8768-ae0084a10bf9.xhtml)，“性能模式”中学到的，当我们递归实现时，计算第*n*个斐波那契数可能很棘手，因此我们的第一个算法（策略）可能是记忆化。此外，我们还可以使用不使用任何递归的迭代算法来解决这个问题。
- en: 'In order to support both memoization and iterative algorithms, let''s create
    some new types as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持记忆化和迭代算法，让我们创建以下一些新类型：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `Algo` abstract type is the supertype for all Fibonacci algorithms. At
    the moment, we only have two algorithms to choose from: `Memoized` or `Iterative`.
    Now, we can define the memoized version of the `fib` function as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Algo` 抽象类型是所有斐波那契算法的超类型。目前，我们只有两种算法可供选择：`Memoized` 或 `Iterative`。现在，我们可以定义
    `fib` 函数的备忘录版本如下：'
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A memoized function `_fib` is first defined. Then a wrapper function `fib` is
    defined, taking a `Memoized` object as the first argument. The corresponding iterative
    algorithm can be implemented as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义一个备忘录函数 `_fib`。然后定义一个包装函数 `fib`，它将 `Memoized` 对象作为第一个参数。相应的迭代算法可以如下实现：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How the algorithm actually works is unimportant in this discussion. As the first
    argument is an `Iterative` object, we know that this function will be dispatched
    accordingly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次讨论中，算法的实际工作方式并不重要。由于第一个参数是 `Iterative` 对象，我们知道这个函数将被相应地调度。
- en: 'From the client''s perspective, it can choose either the memoized version or
    the iterative function, depending on what it needs. As the memoized version runs
    at O(1) speed, it should be faster when `n` is large; however, for a small value
    of `n`, the iterative version would work better. We can call the `fib` function
    in one of the following ways:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，它可以选择备忘录版本或迭代函数，具体取决于其需求。由于备忘录版本以 O(1) 的速度运行，当 `n` 较大时应该更快；然而，对于 `n`
    的较小值，迭代版本会更好。我们可以以下列方式调用 `fib` 函数：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Should the client choose to implement an algorithm-selection process, it can
    be done easily, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端选择实现算法选择过程，可以很容易地做到，如下所示：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The successful test result is shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的测试结果如下所示：
- en: '![](img/a7bc2d48-581e-4c49-9e04-cc6ca69166be.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7bc2d48-581e-4c49-9e04-cc6ca69166be.png)'
- en: As you can see, implementing the strategy pattern is quite easy. *The unreasonable
    effectiveness of multiple dispatch has come to rescue again!* Next, we will go
    over another behavioral pattern called the template method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实现策略模式相当简单。*多分派的不合理有效性再次拯救了！* 接下来，我们将讨论另一个称为模板方法的行性行为模式。
- en: The template method pattern
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法模式
- en: The **template method** pattern is used to create a well-defined process that
    can use different kinds of algorithms or operations. As a template, it can be
    customized with whatever algorithm or functions the client requires.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式用于创建一个定义良好的过程，可以使用不同类型的算法或操作。作为一个模板，它可以根据客户端的需求定制任何算法或函数。
- en: 'Here, we will explore how the template method pattern can be utilized in a
    **machine learning** (**ML**) pipeline use case. For those who are unfamiliar
    with ML pipelines, here is a simplified version of what a data scientist might
    do:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨如何在机器学习（ML）管道用例中利用模板方法模式。对于那些不熟悉 ML 管道的人来说，以下是数据科学家可能采取的简化版本：
- en: '![](img/8d9dc286-6d1e-49f8-84a2-da3a420205a0.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d9dc286-6d1e-49f8-84a2-da3a420205a0.png)'
- en: A dataset is first split into two separate datasets for training and testing
    purposes. The training dataset is fed into a process that fits the data into a
    statistical model. Then, the `validate` function uses the model to predict the
    response (also called the target) variable in the test set. Finally, it compares
    the predicted values against the actual values and determines how accurate the
    model is.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将数据集分成两个单独的数据集，用于训练和测试。训练数据集被输入到一个过程中，将数据拟合到统计模型中。然后，`validate` 函数使用该模型来预测测试集（也称为目标）变量中的响应变量。最后，它将预测值与实际值进行比较，以确定模型的准确性。
- en: 'Let''s say we have the pipeline already set up as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经将管道设置为如下所示：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For the sake of brevity, the specific functions, `split_data`, `fit`, and `validate`,
    are not shown here; you can look them up on this book''s GitHub site if you wish.
    However, the pipeline concept is demonstrated in the preceding logic. Let''s take
    a quick spin at predicting Boston house prices:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，具体的函数 `split_data`、`fit` 和 `validate` 在这里没有展示；如果您想查看它们，可以在本书的 GitHub
    网站上查找。然而，管道概念在前面的逻辑中得到了演示。让我们快速尝试预测波士顿房价：
- en: '![](img/ec34e4dc-c307-4190-9ba5-50be22ef7411.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec34e4dc-c307-4190-9ba5-50be22ef7411.png)'
- en: In this example, the response variable is `:MedV`, and we will build a statistic
    model based on `:Rm`, `:Tax`, and `:Crim`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，响应变量是 `:MedV`，我们将基于 `:Rm`、`:Tax` 和 `:Crim` 建立一个统计模型。
- en: 'The Boston housing dataset contains data collected by the U.S. Census Service
    concerning housing in the area of Boston, Massachusetts. It is used extensively
    by much statistical analysis educational literature. The variables that we used
    in this example are:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 波士顿住房数据集包含美国人口普查局收集的有关马萨诸塞州波士顿地区住房的数据。它在大量统计分析教育文献中被广泛使用。我们在这个例子中使用到的变量有：
- en: '`MedV`: Median value of owner-occupied homes in $1,000''s'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`MedV`: 房主自住房屋的中位数（单位：千美元）'
- en: '`Rm`: Average number of rooms per dwelling'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rm`: 每套住宅的平均房间数'
- en: '`Tax`: Full-value property tax rate per $10,000'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tax`: 每$10,000的完整价值财产税率'
- en: '`Crim`: Per capita crime rate by town'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crim`: 每镇的人均犯罪率'
- en: The accuracy of the model is captured in the `rmse` variable (meaning the root
    mean squared error). The default implementation uses linear regression as the
    fitting function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的准确性由`rmse`变量（表示均方根误差）捕捉。默认实现使用线性回归作为拟合函数。
- en: 'To implement the template method pattern, we should allow the client to plug
    in any part of the process. For that reason, we can modify the function with keyword
    arguments:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现模板方法模式，我们应该允许客户端插入过程的任何部分。因此，我们可以通过关键字参数修改函数：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, we have added three keyword arguments: `fit`, `split_data`, and `validate`.
    The function is named as `run2` to avoid confusion here, so the client should
    be able to customize any one of them by passing in a custom function. To illustrate
    how it works, let''s create a new `fit` function that uses the **generalized linear
    model** (**GLM**):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了三个关键字参数：`fit`、`split_data`和`validate`。函数被命名为`run2`以避免混淆，因此客户端应该能够通过传递自定义函数来自定义任何一个参数。为了说明它是如何工作的，让我们创建一个新的`fit`函数，该函数使用**广义线性模型**（**GLM**）：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that we have customized the fitting function, we can rerun the program
    by passing it via the `fit` keyword argument:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经自定义了拟合函数，我们可以通过传递`fit`关键字参数来重新运行程序：
- en: '![](img/01ae2558-eab6-4997-834c-0a5055df949c.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01ae2558-eab6-4997-834c-0a5055df949c.png)'
- en: As you can see, the client can customize the pipeline easily by just passing
    in functions. This is possible because Julia supports first-class functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，客户端可以通过传递函数来轻松自定义管道。这是可能的，因为Julia支持一等函数。
- en: In the next section, we will review a few other traditional behavioral patterns.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾一些其他传统的行为模式。
- en: Command, interpreter, iterator, and visitor patterns
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令、解释器、迭代器和访问者模式
- en: The **command**, **interpreter**, and **visitor** patterns are grouped in this
    section only because we have already covered their use cases earlier in this book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**、**解释器**和**访问者**模式被归入本节，仅仅是因为我们已经在本书的早期部分讨论了它们的使用案例。'
- en: The **command** pattern is used to parameterize actions that are to be performed.
    In [Chapter 9](6682bca1-9221-46fa-84f2-f5379fd4d01b.xhtml), *Miscellaneous Patterns*,
    in the *Singleton type dispatch pattern* section, we explored a use case where
    the GUI invokes different commands and reacts to specific actions that the user
    has requested. By defining singleton types, we can leverage Julia's multiple dispatch
    mechanism to execute the proper function. We can extend this to new commands by simply adding
    new functions that take new singleton types.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**模式用于参数化将要执行的操作。在第9章*杂项模式*部分中的*单例类型分派模式*部分，我们探讨了GUI调用不同命令并响应用户请求的特定操作的使用案例。通过定义单例类型，我们可以利用Julia的多分派机制来执行适当的函数。我们可以通过简单地添加接受新单例类型的新函数来扩展到新的命令。'
- en: The **interpreter** pattern is used to model an abstract syntax tree for a particular
    domain model. As it turns out, we have already done this in [Chapter 7](08f064fb-f7c5-4078-a9c9-5e70d42f336a.xhtml), *Maintainability
    Patterns*, in the *Domain-specific language* section. Every Julia expression can
    be modeled as an abstract syntax tree without any additional work, and so we can
    develop a DSL using regular metaprogramming facilities, such as macros and generated
    functions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释器**模式用于为特定领域模型建模抽象语法树。结果证明，我们已经在第7章中这样做过，即*可维护性模式*部分中的*领域特定语言*部分。每个Julia表达式都可以被建模为抽象语法树，而无需任何额外的工作，因此我们可以使用常规元编程设施（如宏和生成函数）来开发领域特定语言（DSL）。'
- en: The **iterator** pattern is used to iterate over a collection of objects using
    a standard protocol. In Julia, there is already an officially established iteration
    interface that can be implemented by any collection framework. As long as an `iterate`
    function is defined for a custom object, the elements in the object can be iterated
    as part of any looping construct. More information can be found from the official
    Julia reference manual.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**模式用于使用标准协议遍历一组对象。在Julia中，已经有一个官方建立的迭代接口，任何集合框架都可以实现。只要为自定义对象定义了一个`iterate`函数，对象中的元素就可以作为任何循环结构的一部分进行迭代。更多信息可以在官方Julia参考手册中找到。'
- en: Finally, the **visitor** pattern is used to extend functionalities of an existing
    class in the OOP paradigm. In Julia, adding new functions to an existing system
    can be done easily via an extension of generic functions. For example, there are
    many array-like data structure packages in the Julia ecosystem, such as `OffsetArrays`,
    `StridedArrays`, and `NamedArrays`. All of these are extensions to the existing
    `AbstractArray` framework.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**访问者**模式用于在面向对象范式中扩展现有类的功能。在Julia中，通过泛型函数的扩展，可以轻松地向现有系统添加新功能。例如，Julia生态系统中有许多类似数组的包，如`OffsetArrays`、`StridedArrays`和`NamedArrays`。所有这些都是对现有的`AbstractArray`框架的扩展。
- en: We are now finished with behavioral patterns. Let's move on and take a look
    at the last group—structural patterns.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了行为模式。让我们继续前进，看看最后一组——结构模式。
- en: Structural patterns
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构模式
- en: '**Structural design** patterns are used to compose objects together to make
    bigger things. As you continue developing a system and adding functionalities,
    its size and complexity grows. Not only do we want to integrate components with
    each other, but at the same time, we also want to reuse components as much as
    possible. By learning the structural patterns described in this section, we have
    a template to follow when we encounter similar situations in our projects.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构设计**模式用于将对象组合在一起以形成更大的东西。随着你继续开发系统并添加功能，其大小和复杂性也在增长。我们不仅想要将组件集成在一起，同时我们也希望尽可能多地重用组件。通过学习本节中描述的结构模式，我们在项目中遇到类似情况时有一个遵循的模板。'
- en: In this section, we will review the traditional object-oriented patterns, including
    the adapter, bridge, composite, decorator, facade, flyweight, and proxy patterns.
    Let's start with the adapter pattern.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾传统的面向对象模式，包括适配器、桥接、组合、装饰器、外观、享元和代理模式。让我们从适配器模式开始。
- en: The adapter pattern
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The **adapter** pattern is used to make one object work with another. Say that
    we need to integrate two subsystems, but they cannot talk to each other because
    the interface requirements are not met. In real life, you may have encountered
    a situation where traveling to a different country is troublesome because the
    power plugs are not the same. To solve this problem, you would probably bring
    a universal power adapter, which acts as an intermediary to make your device work
    with foreign electrical outlets. Similarly, different software can be made to
    fit with each other by the use of adapters.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器**模式用于使一个对象与另一个对象协同工作。比如说，我们需要集成两个子系统，但它们不能相互通信，因为接口要求没有得到满足。在现实生活中，你可能遇到过去不同国家旅行麻烦的情况，因为电源插头不同。为了解决这个问题，你可能需要带一个通用电源适配器，它作为中介使你的设备能够与外国的电源插座工作。同样，通过使用适配器，不同的软件可以被制作成相互兼容。'
- en: As long as the interface for working with a subsystem is clear, then creating
    an adapter can be a straightforward task. In Julia, we can use the Delegation
    pattern to wrap an object and provide additional functionalities that conform
    to the required interface.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 只要与子系统交互的接口是清晰的，那么创建适配器就可以是一个直接的任务。在Julia中，我们可以使用委托模式来包装一个对象，并提供符合所需接口的附加功能。
- en: Let's imagine that we are using a library that performs a computation and returns
    a linked list. A linked list is a convenient data structure that supports very
    fast inserts at O(1) speed. Now, say that we want to pass the data to another
    subsystem that requires us to conform to an `AbstractArray` interface. In this
    case, we cannot just pass the linked list as it does not fit!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们正在使用一个执行计算并返回链表的库。链表是一个方便的数据结构，它支持非常快的O(1)速度的插入。现在，假设我们想要将数据传递给另一个需要我们符合`AbstractArray`接口的子系统。在这种情况下，我们不能直接传递链表，因为它不合适！
- en: 'How do we solve this problem? First, let me introduce the `LinkedList` implementation:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？首先，让我介绍一下`LinkedList`的实现：
- en: '![](img/ae49982c-b878-4825-a109-91336b9e71b5.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae49982c-b878-4825-a109-91336b9e71b5.png)'
- en: 'This is a fairly standard design for a doubly-linked list. Each node contains
    a data value, but also maintains a reference to the node before and after. The
    typical usage of such a linked list is shown as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当标准的双向链表设计。每个节点包含一个数据值，同时也维护对前一个和后一个节点的引用。这种链表的典型用法如下所示：
- en: '![](img/252a3142-77ea-4c16-8a2f-4433fba8ebe2.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/252a3142-77ea-4c16-8a2f-4433fba8ebe2.png)'
- en: In general, we can traverse the linked list by using the `prev` and `next` functions.
    The reason why we need to call `next(LL)` when inserting the value of `3` is because
    we want to insert it after the second node.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以通过使用`prev`和`next`函数来遍历链表。当我们插入`3`的值时需要调用`next(LL)`的原因是我们希望将其插入到第二个节点之后。
- en: 'Because using a linked list does not implement the `AbstractArray` interface,
    we cannot really reference any element by index, nor can we figure out the number
    of elements:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用链表没有实现`AbstractArray`接口，我们实际上无法通过索引引用任何元素，也无法确定元素的数量：
- en: '![](img/5634213c-ffb6-468d-835a-c1d6929df4a7.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5634213c-ffb6-468d-835a-c1d6929df4a7.png)'
- en: 'In this case, we can build a wrapper (or so-called adapter) that conforms to
    the `AbstractArray` interface. First, let''s create a new type and make it a subtype
    of `AbstractArray`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以构建一个符合`AbstractArray`接口的包装器（或称为适配器）。首先，让我们创建一个新的类型，并使其成为`AbstractArray`的子类型：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As we only need to support a single-dimension array, we have defined the supertype
    to be `AbstractArray{T,1}`. The underlying data is just a reference to the linked
    list `Node` object. In order to conform to the `AbstractArray` interface, we should
    implement the `Base.size` and `Base.getindex` functions. Here''s what the `size`
    function looks like:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要支持单维数组，我们已将超类型定义为`AbstractArray{T,1}`。底层数据只是对链表`Node`对象的引用。为了符合`AbstractArray`接口，我们应该实现`Base.size`和`Base.getindex`函数。下面是`size`函数的样子：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The function simply determines the length of the array by traversing the linked
    list using the `next` function. To support indexing elements, we can define the
    `getindex` function as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过使用`next`函数遍历链表来确定数组的长度。为了支持索引元素，我们可以定义`getindex`函数如下：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'That is all we need to do for the wrapper. Let''s give it a spin now:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要为包装器做的所有事情。现在让我们试运行一下：
- en: '![](img/51fccc19-1d3f-476a-8383-e64f36bda2d8.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51fccc19-1d3f-476a-8383-e64f36bda2d8.png)'
- en: Now that we have an indexable array on top of the linked list, we can pass it
    to any library that expects arrays as input.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在链表之上有了可索引的数组，我们可以将其传递给任何期望数组作为输入的库。
- en: In the situation where mutation is required for the array, we can just implement
    the `Base.setindex!` function as well. Alternatively, we can physically convert
    the linked list into an array. An array has the performance characteristic of
    fast indexing at O(1), while being relatively slow for inserts.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要数组变动的情形下，我们只需实现`Base.setindex!`函数即可。或者，我们可以将链表物理地转换为数组。数组具有O(1)快速索引的性能特征，但在插入时相对较慢。
- en: Using an adapter allows us to make components talk to each other more easily.
    Next, we will discuss the composite pattern.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器使我们更容易使组件相互通信。接下来，我们将讨论组合模式。
- en: The composite pattern
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: The **composite** pattern is used to model objects that can be grouped together
    and yet be treated the same as individual objects. This is not an uncommon case—for
    example, in a drawing application, we might be able to draw different kinds of
    shapes, such as circles, rectangles, and triangles. Every shape has a position
    and size so we can determine where they are located on screen as well as how large
    they are. When we group several shapes together, we can still determine the position
    and size of the large, grouped object. Additionally, resize, rotate, and other
    transformation functions can be applied to individual shape objects as well as
    grouped objects.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**模式用于模拟可以组合在一起同时又能像单个对象一样被处理的对象。这种情况并不少见——例如，在一个绘图应用程序中，我们可能能够绘制不同类型的形状，如圆形、矩形和三角形。每个形状都有一个位置和大小，因此我们可以确定它们在屏幕上的位置以及它们的大小。当我们把几个形状组合在一起时，我们仍然可以确定组合后的大对象的位姿。此外，还可以对单个形状对象以及组合对象应用调整大小、旋转和其他变换功能。'
- en: A similar situation happens with portfolio management. I have a retirement investment
    account that is composed of multiple mutual funds. Each mutual fund may either
    invest in stocks, bonds, or both. Then, some funds may also invest in other mutual
    funds. From an accounting perspective, we can always determine the market value
    of a stock, a bond, a fund of stocks, a fund of bonds, and a fund of funds. In
    Julia, we can tackle this problem by just implementing a `market_value` function
    for different types of instruments, whether it is a stock, a bond, or a fund.
    Let's take a look at some code now.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在投资组合管理中也会出现类似的情况。我有一个由多个共同基金组成的退休投资账户。每个共同基金可能投资于股票、债券或两者兼有。然后，一些基金也可能投资于其他共同基金。从会计角度来看，我们可以始终确定股票、债券、股票基金、债券基金和基金组合的市场价值。在Julia中，我们可以通过为不同类型的工具实现`market_value`函数来解决这个问题，无论是股票、债券还是基金。现在让我们看看一些代码。
- en: 'Let''s say we have the following type defined for stock/bond holdings:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为股票/债券持仓定义了以下类型：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `Holding` type contains a trading symbol, quantity, and current price.
    We can define a portfolio as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Holding`类型包含交易符号、数量和当前价格。我们可以定义投资组合如下：'
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A portfolio is identified by a symbol, a name, an array of holdings, and an
    array of `subportfolios`. For testing, we can create a sample portfolio:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 投资组合由一个符号、一个名称、一个持仓数组和一个`subportfolios`数组来标识。为了测试，我们可以创建一个示例投资组合：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The structure is visualized more clearly from an indented output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 从缩进输出的结构中可以更清楚地可视化：
- en: '![](img/318f5457-0580-432d-96e1-bec526076030.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/318f5457-0580-432d-96e1-bec526076030.png)'
- en: 'As we want to support the ability to calculate the market value at any level,
    we just need to define the `market_value` function for each type. The simplest
    one is for holdings:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望支持在任何级别计算市场价值的能力，我们只需要为每种类型定义`market_value`函数。最简单的一个是对于持仓：
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The market value is nothing but quantity multiplied by price. The calculation
    of market value for a portfolio is just a little more involved:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 市场价值不过是数量乘以价格。计算投资组合的市场价值稍微复杂一些：
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we use the `mapreduce` function to calculate the market values of individual
    stocks (or `subportfolios`) and sum them up. As a portfolio may include multiple
    holdings and multiple `subportfolios`, we need to perform the calculation for
    both and add them together. As each subportfolio is also a `portfolio` object,
    this code naturally recurses deeper into sub-`subportfolios`, and so forth.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`mapreduce`函数来计算单个股票（或`subportfolios`）的市场价值，并将它们加起来。由于一个投资组合可能包含多个持仓和多个`subportfolios`，我们需要对两者都进行计算并将它们相加。由于每个子投资组合也是一个`portfolio`对象，这段代码自然会递归地深入到子-`subportfolios`，依此类推。
- en: There is nothing fancy about composites. Because Julia supports generic functions,
    we can just provide an implementation for individual objects as well as grouped
    objects.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 复合体并没有什么特别之处。因为Julia支持泛型函数，所以我们可以为单个对象以及分组对象提供实现。
- en: We will discuss the flyweight pattern next.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论飞点模式。
- en: The flyweight pattern
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞点模式
- en: The **flyweight** pattern is used to handle a large number of fine-grained objects
    efficiently by sharing memory for similar/same objects.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**飞点模式**用于通过共享相似/相同对象的内存来有效地处理大量细粒度对象。'
- en: A good example of this involves handling strings. In the field of data science,
    we frequently need to read and analyze a large amount of data that is represented
    in a tabular format. In many cases, certain columns may contain a large number
    of strings that are just repeated values. For example, a population survey might
    have a column stating gender, and so it will contain either `Male` or `Female`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 处理字符串的一个很好的例子涉及字符串。在数据科学领域，我们经常需要读取和分析以表格格式表示的大量数据。在许多情况下，某些列可能包含大量重复的字符串。例如，人口普查调查可能有一个表示性别的列，因此它将包含`Male`或`Female`。
- en: 'Unlike some other programming languages, strings are not interned in Julia.
    This means that 10 copies of the word `Male` are going to be stored repeatedly,
    occupying 10 times the memory space that is used by a single string of `Male`.
    We can see this effect easily from the REPL, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些编程语言不同，Julia中的字符串不会被内部化。这意味着`Male`这个词的10个副本将被反复存储，占用10倍于单个`Male`字符串的内存空间。我们可以很容易地从REPL中看到这个效果，如下所示：
- en: '![](img/380fa56c-5edf-47fb-89af-8bb638e64e52.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/380fa56c-5edf-47fb-89af-8bb638e64e52.png)'
- en: 'So, storing 100,000 copies of a `Male` string occupies roughly 800 KB of memory.
    That is quite a waste of memory. A common way to solve this problem is to maintain
    a pooled array. Rather than storing 100,000 strings, we can just encode the data
    and store 100,000 bytes instead so that `0x01` corresponds to male and `0x00`
    corresponds to female. We can reduce the memory footprint eightfold by using `s` as
    follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b8c5d49-5f72-4ff0-b14b-be32938fbc6a.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: 'You may wonder why there are 40 extra bytes being reported. Those 40 bytes
    are actually used by the array container. Now, given that the gender column is
    binary in this case, we can actually squeeze it further by storing bits instead
    of bytes, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b4e3d6b-c79f-461d-a2df-aa7add823836.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: 'Again, we reduce the memory usage approximately eightfold (by going from 1
    byte to 1 bit) by using `BitArray` to store the gender values. This is an aggressive
    optimization of memory usage. But we still need to store the `Male` and `Female` strings somewhere,
    right? This is an easy task because we know they can be tracked in any data structure,
    such as a dictionary:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b91455c-34a6-49fb-b3f3-c759ba626a25.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: To summarize, we are now capable of storing 100,000 gender values in 12,568
    + 370 = 12,938 bytes of memory. Compared to the original dumb way of storing strings
    directly, we have saved more than 98% of memory consumption! How did we achieve
    such a huge saving? Because all records share the same two strings. The only data
    that we have to maintain is an array of references to those strings.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: So, that is the concept of the flyweight pattern. The same trick is used over
    and over again in many places. For example, the `CSV.jl` package uses a package
    called `CategoricalArrays`, which provides essentially the same kind of memory
    optimization.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over the last few traditional patterns—bridge, decorator, and
    facade.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Bridge, decorator, and facade patterns
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me explain how the bridge, decorator, and facade patterns work. At this
    point, we will not provide any more code samples for these patterns, only because
    they are relatively easy to implement, as you are already equipped with many ideas
    from prior design pattern sections. Perhaps not too surprisingly, the same tricks
    that you have learned so far—delegation, singleton type, multiple dispatch, first-class
    functions, abstract types, and interfaces—are the same ones that you can use to
    tackle any type of problem.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The **bridge** pattern is used to decouple an abstraction from its implementation
    so that it can evolve independently. In Julia, we can build a hierarchy of abstract
    types for which implementers can develop software that conforms to those interfaces.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Julia's numeric types are good examples of how such a system can be designed.
    There are many abstract types available, such as `Integer`, `AbstractFloat`, and
    `Real`. Then, there are concrete implementations, such as `Int` and `Float64`,
    provided by the `Base` package. The abstraction is designed in such a way that
    people can provide an alternative implementation of numbers. For example, the
    `SaferInteger` packages provide a safer implementation for integers that avoids
    numerical overflow.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的数值类型是这样一个系统如何设计的良好例子。有许多抽象类型可供选择，例如`Integer`、`AbstractFloat`和`Real`。然后，还有由`Base`包提供的具体实现，如`Int`和`Float64`。这种抽象设计得如此之好，以至于人们可以提供数字的替代实现。例如，`SaferInteger`包为整数提供了一个更安全的实现，避免了数值溢出。
- en: The **decorator** pattern is also simple to implement. It can be used to enhance
    an existing object with new functionalities, hence the term *decorator*. Suppose
    that we have bought a third-party library, but we are not totally satisfied with
    the functionalities. Using the decorator pattern, we can add value by wrapping
    the existing library with new functions.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器**模式也易于实现。它可以用来增强现有对象的新功能，因此得名*装饰器*。假设我们购买了一个第三方库，但我们并不完全满意其功能。使用装饰器模式，我们可以通过用新函数包装现有库来增加价值。'
- en: This can be done naturally using the Delegation pattern. By wrapping an existing
    type with a new type, we can reuse existing functionalities by delegating to the
    underlying object. Then, we can add new functions to the new type to gain new
    capabilities. We see this pattern used over and over again.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过委托模式自然地完成。通过用新类型包装现有类型，我们可以通过委托到基础对象来重用现有功能。然后，我们可以在新类型中添加新函数以获得新能力。我们看到这个模式被反复使用。
- en: The **facade** pattern is used to encapsulate complex subsystems and provide
    a simplified interface for clients. How do we do that in Julia? By now, we should
    have seen this pattern over and over again; all we need to do is create a new
    type and provide a simple API that operates on the new type. We can use the Delegation
    pattern to forward requests to other enclosed types.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**外观**模式用于封装复杂的子系统，并为客户端提供一个简化的接口。在Julia中我们如何做到这一点？到目前为止，我们应该已经一次又一次地看到了这个模式；我们所需做的只是创建一个新的类型，并提供一个简单的API来操作这个新类型。我们可以使用委托模式将请求转发到其他封装的类型。'
- en: We have now looked at all traditional object-oriented patterns. You might have
    noticed that many of the use cases can be solved with the standard Julia features
    and patterns described in this book. This is not a coincidence—it is just that
    easy to deal with complex problems in Julia.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审视了所有传统的面向对象模式。你可能已经注意到，许多用例可以用这本书中描述的标准Julia特性和模式来解决。这不是巧合——这只是处理Julia中的复杂问题如此简单。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone over the traditional object-oriented design patterns
    extensively. We started with the humble belief that the same patterns in object-oriented
    programming often need to be applied in Julia programming.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们广泛地讨论了传统的面向对象设计模式。我们从这样一个谦卑的信念开始，即面向对象编程中的相同模式通常需要在Julia编程中应用。
- en: We started reviewing creational design patterns, which include the factory method,
    abstract factory, singleton, builder, and prototype patterns. These patterns involve
    various techniques for creating objects. When it comes to Julia, we can mostly
    solve these problems using abstract types, interfaces, and multiple dispatch.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始回顾创建型设计模式，包括工厂方法、抽象工厂、单例、建造者和原型模式。这些模式涉及创建对象的各种技术。当涉及到Julia时，我们可以主要使用抽象类型、接口和多重分派来解决这些问题。
- en: 'We also spent a considerable amount of effort looking at behavioral design
    patterns. These patterns are made to handle collaboration and communication between
    components in an application. We looked at 11 patterns: chain of responsibility,
    mediator, memento, observer, state, strategy, template method, command, interpreter,
    iterator, and visitor. These patterns can be implemented in Julia using traits,
    interfaces, multiple dispatch, and first-class functions.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还投入了大量精力研究行为设计模式。这些模式旨在处理应用程序组件之间的协作和通信。我们研究了11个模式：责任链、中介者、备忘录、观察者、状态、策略、模板方法、命令、解释器、迭代器和访问者。这些模式可以使用特性、接口、多重分派和一等函数在Julia中实现。
- en: Finally, we reviewed several structural design patterns. These patterns are
    used to construct bigger components by reusing existing ones. This includes the
    adapter, composite, flyweight, bridge, decorator, and facade patterns. In Julia,
    they can be handled with abstract types, interfaces, and the delegation design
    pattern.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: I hope you are convinced that building software does not need to be difficult.
    Just because OOP made us believe that we need all of this complexity to design
    software, it does not mean that we have to do the same in Julia. The solutions
    to the problems that are presented in this chapter mostly require the basic software
    design skills and patterns that you found in this book.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get into a more advanced topic regarding data types
    and dispatch. *Get ready to rock!*
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What technique can we use to implement the abstract factory pattern?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we prevent a singleton from being initialized multiple times in a multithreaded
    application?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Julia feature is essential to implementing the observer pattern?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we customize an operation using the template method pattern?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we make an adapter to implement a target interface?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of the flyweight pattern and what strategy can we use to
    achieve it?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Julia feature can we use to implement the strategy pattern?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
