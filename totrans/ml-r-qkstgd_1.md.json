["```pyr\n*   Text mixed with simple text formatting\n\nR code chunks allow for the execution of code and display the results in the same notebook. To execute a chunk, click the run button within the chunk or place the cursor inside it and press *Ctrl* + *Shift* + *Enter*. If you wish to insert a chunk button on the toolbar, press *Ctrl* + *Alt* + *I*.\n\nWhile saving the current notebook, a code and output file in HTML format will be generated and will be saved with the notebook. To see what the HTML file looks like, you can either click the Preview button or you can use the shortcut *Ctrl* + *Shift* + *K*. You can find and download all the code of this book as a R Notebook, where you can execute all the code without writing it directly.\n\n# Objects, special cases, and basic operators in R\n\nBy now, you will have figured out that R is an object-oriented language. All our variables, data, and functions will be stored in the active memory of the computer as **objects**. These objects can be modified using different operators or functions. An object in R has two attributes, namely, mode and length.\n\nMode includes the basic type of elements and has four options:\n\n*   **Numeric**: These are decimal numbers\n*   **Character**: Represents sequences of string values\n*   **Complex**: Combination of real and imaginary numbers, for example, *x+ai*\n*   **Logical**: Either true (`1`) or false (`0`)\n\nLength means the number of elements in an object.\n\nIn most cases, we need not care whether or not the elements of a numerical object are integers, reals, or even complexes. Calculations will be carried out internally as numbers of double precision, real, or complex, depending on the case. To work with complex numbers, we must indicate explicitly the complex part.\n\nIn case an element or value is unavailable, we assign `NA`, a special value. Usually, operations with `NA` elements result in `NA` unless we are using some functions that can treat missing values in some way or omit them. Sometimes, calculations can lead to answers with a positive or negative infinite value (represented by R as `Inf` or `-Inf`, respectively). On the other hand, certain calculations lead to expressions that are not numbers represented by R as **NaN** (short for **not a number**).\n\n# Working with objects\n\nYou can create an object using the `<-` operator:\n\n```", "```py\n\nIn the preceding code, an object called `n` is created. A value of `10` has been assigned to this object. The assignment can also be made using the `assign()` function, although this isn't very common.\n\nOnce the object has been created, it is possible to perform operations on it, like in any other programming language:\n\n```", "```py\n\nThese are some examples of basic operations.\n\nLet's create our variables:\n\n```", "```py\n\nNow, we can carry out some basic operations:\n\n*   Sum of variables:\n\n```", "```py\n\n*   Subtraction of variables:\n\n```", "```py\n\n*   Multiplication of variables:\n\n```", "```py\n\n*   Division of variables:\n\n```", "```py\n\n*   Power of variables:\n\n```", "```py\n\nLikewise in R, there are defined constants that are widely used, such as the following ones:\n\n*   The `pi` (![](img/1c55b6c3-6e8a-4301-8712-eeb3045f364c.png)) number :\n\n```", "```py\n\n*   Exponential function:\n\n```", "```py\n\nThere are also functions for working with numbers, such as the following:\n\n*   Sign (positive or negative of a number):\n\n```", "```py\n\n*   Finding the maximum value:\n\n```", "```py\n\n*   Finding the minimum value:\n\n```", "```py\n\n*   Factorial of a number:\n\n```", "```py\n\n*   Square root function:\n\n```", "```py\n\nIt is also possible to assign the result of previous operations to another object. For example, the sum of variables `x` and `y` is assigned to an object named `z`:\n\n```", "```py\n\nAs shown previously, these functions apply if the variables are numbers, but there are also other operators to work with strings:\n\n```", "```py\n\nThe main logical operators are summarized in the following table:\n\n| **Operator** | **Description** |\n| < | Less than |\n| <= | Less than or equal to |\n| > | Greater than |\n| >= | Greater than or equal to |\n| == | Equal to |\n| != | Not equal to |\n| !x | Not *x* |\n| x | *y* |\n| x & y | *x* and *y* |\n| isTRUE(x) | Test if *x* is TRUE |\n\n# Working with vectors\n\nA **vector** is one of the basic data structures in R. It contains only similar elements, like strings and numbers, and it can have data types such as logical, double, integer, complex, character, or raw. Let's see how vectors work.\n\nLet's create some vectors by using `c()`:\n\n```", "```py\n\nOn mixing different objects with vector elements, there is a transformation of the elements so that they belong to the same class:\n\n```", "```py\n\nWhen we apply commands and functions to a vector variable, they are also applied to every element in the vector:\n\n```", "```py\n\nYou can use the `:` operator if you wish to create a vector of consecutive numbers:\n\n```", "```py\n\nDo you need to create more complex vectors? Then use the `seq()` function. You can create vectors as complex as number of points in an interval or even to find out the step size that we might need in machine learning:\n\n```", "```py\n\nThe `rep()` function is used to repeat the value of *x*, *n* number of times:\n\n```", "```py\n\n# Vector indexing\n\nElements of a vector can be arranged in several haphazard ways, which can make it difficult to access them when needed. Hence, indexing makes it easier to access the elements.\n\nYou can have any type of index vectors, from logical, integer, and character.\n\nVector of integers starting from 1 can be used to specify elements in a vector, and it is also possible to use negative values.\n\nLet's see some examples of indexing:\n\n*   Returns the *n*th element of *x*:\n\n```", "```py\n\n*   Returns all *x* values except the *n*th element:\n\n```", "```py\n\n*   Returns values between *a* and *b*:\n\n```", "```py\n\n*   Returns items that are greater than *a* and less than *b*:\n\n```", "```py\n\nMoreover, you can even use a logical vector. In this case, either `TRUE` or `FALSE` will be returned if an element is present at that position:\n\n```", "```py\n\n# Functions on vectors\n\nIn addition to the functions and operators that we've seen for numerical values, there are some specific functions for vectors, such as the following:\n\n*   Sum of the elements present in a vector:\n\n```", "```py\n\n*   Product of elements in a vector:\n\n```", "```py\n\n*   Length of a vector:\n\n```", "```py\n\n*   Modifying a vector using the `<-` operator:\n\n```", "```py\n\n# Factor\n\nA vector of strings of a character is known as a **factor**. It is used to represent categorical data, and may also include the different levels of the categorical variable. Factors are created with the `factor` command:\n\n```", "```py\n\n# Factor levels\n\n**Levels** are possible values that a variable can take. Suppose the original value of 1 is repeated; it will appear only once in the levels.\n\nFactors can either be numeric or character variables, but levels of a factor can only be characters.\n\nLet's run the `level` command:\n\n```", "```py\n\nAs you can see, `1`, `4`, `7`, `8`, and `9` are the possible levels that the level `r` can have.\n\nThe `exclude` parameter allows you to exclude levels of a custom factor:\n\n```", "```py\n\nFinally, let's find out if our factor values are ordered or unordered:\n\n```", "```py\n\n# Strings\n\nAny value that is written in single or double quotes will be considered a **string**:\n\n```", "```py\n\nWhen I say single quotes are allowed, please know that even if you specify the string in single quotes, R will always store them as double quotes.\n\n# String functions\n\nLet's see how we can transform or convert strings using R.\n\nThe most relevant string examples are as follows:\n\n*   To know the number of characters in a string:\n\n```", "```py\n\n*   To return the substring of *x*, originating at a particular character in *x*:\n\n```", "```py\n\n*   To return the substring of *x* originating at one character located at *n* and ending at another character located at a place, *m*:\n\n```", "```py\n\n*   To divide the string *x* into a list of sub chains using the delimiter as a separator:\n\n```", "```py\n\n*   To check if the given pattern is in the string, and in that case returns true (or `1`):\n\n```", "```py\n\n*   To look for the first occurrence of a pattern in a string:\n\n```", "```py\n\n*   To convert the string into lowercase:\n\n```", "```py\n\n*   To convert the string into capital letters:\n\n```", "```py\n\n*   To replace the first occurrence of the pattern by the given value with a string:\n\n```", "```py\n\n*   To replace the occurrences of the pattern with the given value with a string:\n\n```", "```py\n\n*   To return the string as elements of the given array, separated by the given separator using `paste(string,array, sep=“Separator”)`:\n\n```", "```py\n\n# Matrices\n\nYou might know that a standard matrix has a two-dimensional, rectangular layout. Matrices in R are no different than a standard matrix.\n\n# Representing matrices\n\nTo represent a matrix of *n* elements with *r* rows and *c* columns, the `matrix` command is used:\n\n```", "```py\n\n# Creating matrices\n\nA matrix can be created by rows instead of by columns, which is done by using the `byrow` parameter, as follows:\n\n```", "```py\n\nWith the `dimnames` parameter, column names can be added to the matrix:\n\n```", "```py\n\nThere are three more alternatives to creating matrices:\n\n```", "```py\n\n# Accessing elements in a matrix\n\nYou can access the elements in a matrix in a similar way to how you accessed elements of a vector using indexing. However, the elements here would be the index number of rows and columns.\n\nHere a some examples of accessing elements:\n\n*   If you want to access the element at a second column and first row:\n\n```", "```py\n\n*   Similarly, accessing the element at the second column and second row:\n\n```", "```py\n\n*   Accessing the elements in only the second row:\n\n```", "```py\n\n*   Accessing only the first column:\n\n```", "```py\n\n# Matrix functions\n\nFurthermore, there are specific functions for matrices:\n\n*   The following function extracts the diagonal as a vector:\n\n```", "```py\n\n*   Returns the dimensions of a matrix:\n\n```", "```py\n\n*   Returns the sum of columns of a matrix:\n\n```", "```py\n\n*   Returns the sum of rows of a matrix:\n\n```", "```py\n\n*   The transpose of a matrix can be obtained using the following code:\n\n```", "```py\n\n*   Returns the determinant of a matrix:\n\n```", "```py\n\n*   The auto-values and auto-vectors of a matrix are obtained using the following code:\n\n```", "```py\n\n# Lists\n\nIf objects are arranged in an orderly manner, which makes them components, they are known as **lists**.\n\n# Creating lists\n\nWe can create a list using `list()` or by concatenating other lists:\n\n```", "```py\n\nComponents will always be referred to by their referring numbers as they are ordered and numbered.\n\n# Accessing components and elements in a list\n\nTo access each component in a list, a double bracket should be used:\n\n```", "```py\n\nHowever, it is possible to access each element of a list as well:\n\n```", "```py\n\n# Data frames\n\nData frames are special lists that can also store tabular values. However, there is a constraint on the length of elements in the lists: they all have to be of a similar length. You can consider every element in the list as columns, and their lengths can be considered as rows.\n\nJust like lists, a data frame can have objects belonging to different classes in a column; this was not allowed in matrices.\n\nLet's quickly create a data frame using the `data.frame()` function:\n\n```", "```py\n\nYou can see the headers of a table as `a`, `b`, and `c`; they are the column names. Every line of the table represents a row, starting with the name of each row.\n\n# Accessing elements in data frames\n\nIt is possible to access each cell in the table.\n\nTo do this, you should specify the coordinates of the desired cell. Coordinates begin within the position of the row and end with the position of the column:\n\n```", "```py\n\nWe can even use the row and column names instead of numeric values:\n\n```", "```py\n\nSome packages contain datasets that can be loaded to the workspace, for example, the `iris` dataset:\n\n```", "```py\n\n# Functions of data frames\n\nSome functions can be used on data frames:\n\n*   To find out the number of columns in a data frame:\n\n```", "```py\n\n*   To obtain the number of rows:\n\n```", "```py\n\n*   To print the first `10` rows of data:\n\n```", "```py\n\n*   Print the last `5` rows of the `iris` dataset:\n\n```", "```py\n\n*   Finally, general information of the entire dataset is obtained using `str()`:\n\n```", "```py\n\nAlthough there are a lot of operations to work with data frames, such as merging, combining, or slicing, we won't go any deeper for now. We will be using data frames in further chapters, and shall cover more operations later.\n\n# Importing or exporting data\n\nIn R, there are several functions for reading and writing data from many sources and formats. Importing data into R is quite simple.\n\nThe most common files to import into R are Excel or text files. Nevertheless, in R, it is also possible to read files in SPSS, SYSTAT, or SAS formats, among others.\n\nIn the case of Stata and SYSTAT files, I would recommend the use of the `foreign` package.\n\nLet's install and load the `foreign` package:\n\n```", "```py\n\nWe can use the `Hmisc` package for SPSS, and SAS for ease and functionality:\n\n```", "```py\n\nLet's see some examples of importing data:\n\n*   Import a comma delimited text file. The first rows will have the variable names, and the comma is used as a separator:\n\n```", "```py\n\n*   To read an Excel file, you can either simply export it to a comma delimited file and then import it or use the `xlsx` package. Make sure that the first row comprises column names that are nothing but variables.\n*   Let's read an Excel worksheet from a workbook, `myexcel.xlsx`:\n\n```", "```py\n\n*   Now, we will read a concrete Excel sheet in an Excel file:\n\n```", "```py\n\n*   Reading from the `systat` format:\n\n```", "```py\n\n*   Reading from the SPSS format:\n    1.  First, the file should be saved from SPSS in a transport format:\n\n```", "```py\n\n*   2.  Then, the file can be imported into R with the `Hmisc` package:\n\n```", "```py\n\n*   To import a file from SAS, again, the dataset should be converted in SAS:\n\n```", "```py\n\n*   Reading from the Stata format:\n\n```", "```py\n\nHence, we have seen how easy it is to read data from different file formats. Let's see how simple exporting data is.\n\nThere are analogous functions to export data from R to other formats. For SAS, SPSS, and Stata, the `foreign` package can be used. For Excel, you will need the `xlsx` package.\n\nHere are a few exporting examples:\n\n*   We can export data to a tab delimited text file like this:\n\n```", "```py\n\n*   We can export to an Excel spreadsheet like this:\n\n```", "```py\n\n*   We can export to SPSS like this:\n\n```", "```py\n\n*   We can export to SAS like this:\n\n```", "```py\n\n*   We can export to Stata like this:\n\n```", "```py\n\n# Working with functions\n\nFunctions are the core of R, and they are useful to structure and modularize code. We have already seen some functions in the preceding section. These functions can be considered built-in functions that are available on the basis of R or where we install some packages.\n\nOn the other hand, we can define and create our own functions based on different operations and computations we want to perform on the data. We will create functions in R using the `function()` directive, and these functions will be stored as objects in R.\n\nHere is what the structure of a function in R looks like:\n\n```", "```py\n\nThe objects specified under a function as local to that function and the resulting objects can have any data type. We can even pass these functions as arguments for other functions.\n\nFunctions in R support nesting, which means that we can define a function within a function and the code will work just fine.\n\nThe resulting value of a function is known as the last expression evaluated on execution.\n\nOnce a function is defined, we can use that function using its name and passing the required arguments.\n\nLet's create a function named `squaredNum`, which calculates the square value of a number:\n\n```", "```py\n\nNow, we can calculate the square of any number using the function that we just created:\n\n```", "```py\n\nAs we move on in this book, we will see how important such user-defined functions are.\n\n# Controlling code flow\n\nR has a set of control structures that organize the flow of execution of a program, depending on the conditions of the environment. Here are the most important ones:\n\n*   `If`/`else`: This can test a condition and execute it accordingly\n*   `for`: Executes a loop that repeats for a certain number of times, as defined in the code\n*   `while`: This evaluates a condition and executes only until the condition is true\n*   `repeat`: Executes a loop an infinite number of times\n*   `break`: Used to interrupt the execution of a loop\n*   `next`: Used to jump through similar iterations to decrease the number of iterations and time taken to get the output from the loop\n*   `return`: Abandons a function\n\nThe structure of `if else` is as `if (test_expression) { statement }`.\n\nHere, if the `test_expression` returns true, the `statement` will execute; otherwise, it won't.\n\nAn additional `else` condition can be added like `if (test_expression) { statement1 } else { statement2 }`.\n\nIn this case, the `else` condition is executed only if `test_expression` returns false.\n\nLet's see how this works. We will evaluate an `if` expression like so:\n\n```", "```py\n\nSince `x` takes a value higher than `3`, then the `y` value should be modified to take a value of `10`:\n\n```", "```py\n\nIf there are more than two `if` statements, the `else` expression is transformed into `else if` like this `if ( test_expression1) { statement1 } else if ( test_expression2) { statement2 } else if ( test_expression3) { statement3 } else { statement4 }`.\n\nThe `for` command takes an iterator variable and assigns its successive values of a sequence or vector. It is usually used to iterate on the elements of an object, such as vector lists.\n\nAn easy example is as follows, where the `i` variable takes different values from `1` to `10` and prints them. Then, the loop finishes:\n\n```", "```py\n\nAdditionally, loops can be nested in the same code:\n\n```", "```py\n\nThe `while` command is used to create loops until a specific condition is met. Let's look at an example:\n\n```", "```py\n\nHere, values of `x` are printed, while `x` takes higher values than `1` and less than `20`. While loops start by testing the value of a condition, if true, the body of the loop is executed. After it has been executed, it will test the condition again, and keep on testing it until the result is false.\n\nThe `repeat` and `break` commands are related. The `repeat` command starts an infinite loop, so the only way out of it is through the `break` instruction:\n\n```", "```py\n\nWe can use the `break` statement inside for and while loops to stop the iterations of the loop and control the flow.\n\nFinally, the `next` command can be used to skip some iterations without getting them terminated. When the R parser reads `next`, it terminates the current iteration and moves on to another new iteration.\n\nLet's look at an example of `next`, where 20 iterations are skipped:\n\n```", "```py\n\nBefore we start the next chapters of this book, it is recommended to practice these codes. Take your time and think about the code and how to use it. In the upcoming chapters, you will see a lot of code and new functions. Don't be concerned if you don't understand all of them. It is more important to have an understanding of the entire process to develop a predictive model and all the things you can do with R.\n\nI have tried to make all of the code accessible, and it is possible to replicate all the tables and results provided in this book. Just enjoy understanding the process and reuse all the code you need in your own applications.\n\n# All about R packages\n\nPackages in R are a collection of functions and datasets that are developed by the community.\n\n# Installing packages\n\nAlthough R contains several functions in its basic installation, we will need to install additional packages to add new R functionalities. For example, with R it is possible to visualize data using the `plot` function. Nevertheless, we could install the `ggplot2` package to obtain more pretty plots.\n\nA package mainly includes R code (not always just R code), documentation with explanations about the package and functions inside it, examples, and even datasets.\n\nPackages are placed on different repositories where you can install them.\n\nTwo of the most popular repositories for R packages are as follows:\n\n*   **CRAN**: The official repository, maintained by the R community around the world. All of the packages that are published on this repository should meet quality standards.\n*   **GitHub**: This repository is not specific for R packages, but many of the packages have open source projects located in them. Unlike CRAN, there is no review process when a package is published.\n\nTo install a package from CRAN, use the `install.packages()` command. For example, the `ggplot2` package can be installed using the following command:\n\n```", "```py\n\nTo install packages from repositories other than CRAN, I would recommend using the `devtools` package:\n\n```", "```py\n\nThis package simplifies the process of installing packages from different repositories. With this package, some functions are available, depending on the repository you want to download a package from.\n\nFor example, use `install_cran` to download a package from CRAN or `install_github()` to download it from GitHub.\n\nAfter the package has been downloaded and installed, we'll load it into our current R session using the `library` function. It is important to load packages so that we can use these new functions in our R session:\n\n```"]