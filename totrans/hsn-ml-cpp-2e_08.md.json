["```py\n    using DataType = float;\n    // using Eigen::ColMajor is Eigen restriction - todense method always returns\n    // matrices in ColMajor order\n    using Matrix = Eigen::Matrix<DataType,\n                                 Eigen::Dynamic,\n                                 Eigen::Dynamic,\n                                 Eigen::ColMajor>;\n    using SparseMatrix =\n        Eigen::SparseMatrix<DataType, Eigen::ColMajor>;\n    using DiagonalMatrix =\n        Eigen::DiagonalMatrix<DataType,\n                              Eigen::Dynamic,\n                              Eigen::Dynamic>;\n    ```", "```py\n    SparseMatrix ratings_matrix; // user-item ratings\n    SparseMatrix p; // binary variables\n    std::vector<std::string> movie_titles;\n    ```", "```py\n    auto movies_file = root_path / \"movies.csv\";\n    auto movies = LoadMovies(movies_file);\n    auto ratings_file = root_path / \"ratings.csv\";\n    auto ratings = LoadRatings(ratings_file);\n    ```", "```py\n    ratings_matrix.resize(\n      static_cast<Eigen::Index>(ratings.size()),\n      static_cast<Eigen::Index>(movies.size()));\n    ratings_matrix.setZero();\n    p.resize(ratings_matrix.rows(), ratings_matrix.cols());\n    p.setZero();\n    movie_titles.resize(movies.size());\n    ```", "```py\n    Eigen::Index user_idx = 0;\n    for (auto& r : ratings) {\n      for (auto& m : r.second) {\n        auto mi = movies.find(m.first);\n        Eigen::Index movie_idx =\n            std::distance(movies.begin(), mi);\n        movie_titles[static_cast<size_t>(movie_idx)] =\n            mi->second;\n        ratings_matrix.insert(user_idx, movie_idx) =\n            static_cast<DataType>(m.second);\n        p.insert(user_idx, movie_idx) = 1.0;\n      }\n      ++user_idx;\n    }\n    ratings_matrix.makeCompressed();\n    ```", "```py\n    auto m = ratings_matrix.rows();\n    auto n = ratings_matrix.cols();\n    Eigen::Index n_factors = 100;\n    auto y = InitializeMatrix(n, n_factors);\n    auto x = InitializeMatrix(m, n_factors);\n    y matrix corresponds to user preferences, while the x matrix corresponds to the item parameters. We’ve also defined the number of factors we’ll be interested in after decomposition. These matrices are initialized with random values and normalized. Such an approach is used to speed up algorithm convergence. This can be seen in the following code snippet:\n    ```", "```py\n    Matrix InitializeMatrix(Eigen::Index rows,\n                            Eigen::Index cols) {\n      Matrix mat = Matrix::Random(rows, cols).array().abs();\n      auto row_sums = mat.rowwise().sum();\n      mat.array().colwise() /= row_sums.array();\n      return mat;\n    }\n    ```", "```py\n    DataType reg_lambda = 0.1f;\n    SparseMatrix reg = (reg_lambda * Matrix::Identity(\n                        n_factors, n_factors)).sparseView();\n    // Define diagonal identity terms\n    SparseMatrix user_diag = -1 * Matrix::Identity(\n                                 n, n).sparseView();\n    SparseMatrix item_diag = -1 * Matrix::Identity(\n                                 m, m).sparseView();\n    ```", "```py\n    std::vector<DiagonalMatrix> user_weights(\n        static_cast<size_t>(m));\n    std::vector<DiagonalMatrix> item_weights(\n        static_cast<size_t>(n));\n    {\n      Matrix weights(ratings_matrix);\n      weights.array() *= alpha;\n      weights.array() += 1;\n      for (Eigen::Index i = 0; i < m; ++i) {\n        user_weights[static_cast<size_t>(i)] =\n            weights.row(i).asDiagonal();\n      }\n      for (Eigen::Index i = 0; i < n; ++i) {\n        item_weights[static_cast<size_t>(i)] =\n            weights.col(i).asDiagonal();\n      }\n    }\n    ```", "```py\n    size_t n_iterations = 5;\n    for (size_t k = 0; k < n_iterations; ++k) {\n      auto yt = y.transpose();\n      auto yty = yt * y;\n      ...\n          // update item parameters\n          ... auto xt = x.transpose();\n      auto xtx = xt * x;\n      ...\n          // update users preferences\n          ... auto w_mse = CalculateWeightedMse(\n              x, y, p, ratings_matrix, alpha);\n    }\n    ```", "```py\n    #pragma omp parallel\n    {\n      Matrix diff;\n      Matrix ytcuy;\n      Matrix a, b, update_y;\n      #pragma omp for private(diff, ytcuy, a, b, update_y)\n      for (size_t i = 0; i < static_cast<size_t>(m); ++i) {\n        diff = user_diag;\n        diff += user_weights[i];\n        ytcuy = yty + yt * diff * y;\n        auto p_val =\n            p.row(static_cast<Eigen::Index>(i)).transpose();\n        a = ytcuy + reg;\n        b = yt * user_weights[i] * p_val;\n        update_y = a.colPivHouseholderQr().solve(b);\n        x.row(static_cast<Eigen::Index>(i)) =\n            update_y.transpose();\n      }\n    }\n    ```", "```py\n    #pragma omp parallel\n    {\n      Matrix diff;\n      Matrix xtcux;\n      Matrix a, b, update_x;\n      #pragma omp for private(diff, xtcux, a, b, update_x)\n      for (size_t i = 0; i < static_cast<size_t>(n); ++i) {\n        diff = item_diag;\n        diff += item_weights[i];\n        xtcux = xtx + xt * diff * x;\n        auto p_val = p.col(static_cast<Eigen::Index>(i));\n        a = xtcux + reg;\n        b = xt * item_weights[i] * p_val;\n        update_x = a.colPivHouseholderQr().solve(b);\n        y.row(static_cast<Eigen::Index>(i)) =\n            update_x.transpose();\n      }\n    }\n    ```", "```py\n    Matrix RatingsPredictions(const Matrix& x, const Matrix& y) {\n            return x * y.transpose();\n    }\n    ```", "```py\n    DataType CalculateWeightedMse(const Matrix& x,\n                                  const Matrix& y,\n                                  const SparseMatrix& p,\n                                  const SparseMatrix& ratings_matrix,\n                                  DataType alpha) {\n    Matrix c(ratings_matrix);\n      c.array() *= alpha;\n      c.array() += 1.0;\n      Matrix diff(p - RatingsPredictions(x, y));\n      diff = diff.array().pow(2.f);\n      Matrix weighted_diff = c.array() * diff.array();\n      return weighted_diff.array().mean();\n    }\n    ```", "```py\nvoid PrintRecommendations(\n    const Matrix& ratings_matrix,\n    const Matrix& ratings_matrix_pred,\n    const std::vector<std::string>& movie_titles) {\n  // collect recommendations\n  auto n = ratings_matrix.cols();\n  std::vector<std::string> liked;\n  std::vector<std::string> recommended;\n  for (Eigen::Index u = 0; u < 5; ++u) {\n    for (Eigen::Index i = 0; i < n; ++i) {\n      DataType orig_value = ratings_matrix(u, i);\n      if (orig_value >= 3.f) {\n        liked.push_back(\n            movie_titles[static_cast<size_t>(i)]);\n      }\n      DataType pred_value = ratings_matrix_pred(u, i);\n      if (pred_value >= 0.8f && orig_value < 1.f) {\n        recommended.push_back(\n            movie_titles[static_cast<size_t>(i)]);\n      }\n    }\n    // print recommendations\n    std::cout << \"\\nUser \" << u << \" liked :\";\n    for (auto& l : liked) {\n      std::cout << l << \"; \";\n    }\n    std::cout << \"\\nUser \" << u << \" recommended :\";\n    for (auto& r : recommended) {\n      std::cout << r << \"; \";\n    }\n    std::cout << std::endl;\n    liked.clear();\n    recommended.clear();\n  }\n}\n```", "```py\nPrintRecommendations(ratings_matrix,\n                     RatingsPredictions(x, y),\n                     movie_titles);\n```", "```py\narma::SpMat<DataType> ratings_matrix(ratings.size(),\n                                     movies.size());\nstd::vector<std::string> movie_titles;\n{\n  // fill matrix with data\n  movie_titles.resize(movies.size());\n  size_t user_idx = 0;\n  for (auto& r : ratings) {\n    for (auto& m : r.second) {\n      auto mi = movies.find(m.first);\n      auto movie_idx = std::distance(movies.begin(), mi);\n      movie_titles[static_cast<size_t>(movie_idx)] =\n          mi->second;\n      ratings_matrix(user_idx, movie_idx) =\n          static_cast<DataType>(m.second);\n    }\n    ++user_idx;\n  }\n}\n```", "```py\ndistance(X.col(i), X.col(j)) = distance(W H.col(i), W H.col(j))\n\n```", "```py\n// factorization rank\nsize_t n_factors = 100;\nsize_t neighborhood = 50;\nmlpack::NMFPolicy decomposition_policy;\n// stopping criterions\nsize_t max_iterations = 20;\ndouble min_residue = 1e-3;\nmlpack::CFType cf(ratings_matrix,\n                  decomposition_policy,\n                  neighborhood,\n                  n_factors,\n                  max_iterations,\n                  min_residue);\n```", "```py\narma::Mat<size_t> recommendations;\n// Get 5 recommendations for specified users.\narma::Col<size_t> users;\nusers << 1 << 2 << 3;\ncf.GetRecommendations(5, recommendations, users);\nfor (size_t u = 0; u < recommendations.n_cols; ++u) {\n  std::cout << \"User \" << users(u) <<\" recommendations are: \";\n\n  for (size_t i = 0; i < recommendations.n_rows; ++i) {\n    std::cout << movie_titles[recommendations(i, u)] << \";\";\n  }\n  std::cout << std::endl;\n}\n```"]