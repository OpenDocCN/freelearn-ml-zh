<html><head></head><body>
		<div class="Content" id="_idContainer009">
			<h1 id="_idParaDest-17"><em class="italics"><a id="_idTextAnchor018"/>Chapter 1</em></h1>
		</div>
		<div class="Content" id="_idContainer010">
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>Introduction to Clustering Methods</h1>
		</div>
		<div class="Content" id="_idContainer011">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Describe the uses of clustering</li>
				<li class="bullets">Perform the k-means algorithm using built-in R libraries</li>
				<li class="bullets">Perform the k-medoids algorithm using built-in R libraries</li>
				<li class="bullets">Determine the optimum number of clusters</li>
			</ul>
			<p>In this chapter, we will have a look at the concept of clustering and some basic clustering algorithms.</p>
		</div>
		<div class="Content" id="_idContainer047">
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>Introduction</h2>
			<p><a id="_idTextAnchor021"/>The 21st century is the digital century, where every person on every rung of the economic ladder is using digital devices and producing data in digital format at an unprecedented rate. 90% of data generated in the last 10 years was generated in the last 2 years. This is an exponential rate of growth, where the amount of data is increasing by 10 times every 2 years. This trend is expected to continue for the foreseeable future:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer012">
					<img alt="Figure 1.1: Increase in data year on year&#13;&#10;" src="image/C12628_01_01.jpg"/>
				</div>
			</div>
			<h6>F<a id="_idTextAnchor022"/>igure 1.1: The increase in digital data year on year</h6>
			<p><a id="_idTextAnchor023"/>But this data is not just stored in hard drives; it's being used to make lives better. For example, Google uses the data it has to serve you better results, and Netflix uses the data it has to serve you better movie recommendations. In fact, their decision to make their hit show <em class="italics">House of Cards</em> was based on analytics. IBM is using the medical data it has to create an artificially intelligent doctor and to detect cancerous tumors from x-ray images.</p>
			<p>T<a id="_idTextAnchor024"/>o process this amount of data with computers and come up with relevant results, a particular class of algorithms is used. These algorithms are collectively known as machine learning algorithms. Machine learning is divided into two parts, depending on the type of data that is being used: one is called <strong class="bold">supervised</strong> learning and the other is called <strong class="bold">unsupervised learning</strong>.</p>
			<p>S<a id="_idTextAnchor025"/>upervised learning is done when we get labeled data. For example, say we get 1,000 images of x-rays from a hospital that are labeled as normal or fractured. We can use this data to train a machine learning model to predict whether an x-ray image shows a fractured bone or not.</p>
			<p>U<a id="_idTextAnchor026"/>nsupervised learning is when we just have raw data and are expected to come up with insights without any labels. We have the ability to understand the data and recognize patterns in it without explicitly being told what patterns to identify. By the end of this book, you're going to be aware of all of the major types of unsupervised learning algorithms. In this book, we're going to be using the R programming language for demonstration, but the algorithms are the same for all languages. </p>
			<p>In this chapter, we're going to study the most basic type of unsupervised learning, <strong class="bold">clustering</strong>. At first, we're going to study what clustering is, its types, and how to create clusters with any type of dataset. Then we're going to study how each type of clustering works, looking at their advantages and disadvantages. At the end, we're going to learn when to use which type of clustering.</p>
			<h2 id="_idParaDest-20">I<a id="_idTextAnchor027"/>ntroduction to Clustering </h2>
			<p>Clustering is a set of methods or algorithms that are used to find natural groupings according to predefined properties of variables in a dataset. The Merriam-Webster dictionary defines a cluster as "a number of similar things that occur together." Clustering in unsupervised learning is exactly what it means in the traditional sense. For example, how do you identify a bunch of grapes from far away? You have an intuitive sense without looking closely at the bunch whether the grapes are connected to each other or not. Clustering is just like that. An example of clustering is presented here:</p>
			<h6>  </h6>
			<div>
				<div class="IMG---Figure" id="_idContainer013">
					<img alt="Figure 1.2: Representation of two clusters in a dataset&#13;&#10;" src="image/C12628_01_02.jpg"/>
				</div>
			</div>
			<h6>Figure 1.2: A representation of two clusters in a dataset</h6>
			<p>In the preceding graph, the data points have two properties: cholesterol and blood pressure. The data points are classified into two clusters, or two bunches, according to the <strong class="bold">Euclidean</strong> distance between them. One cluster contains people who are clearly at high risk of heart disease and the other cluster contains people who are at low risk of heart disease. There can be more than two clusters, too, as in the following example:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer014">
					<img alt="Figure 1.3: Representation of three clusters in a dataset&#13;&#10;" src="image/C12628_01_03.jpg"/>
				</div>
			</div>
			<h6>Figure 1.3: A representation of three clusters in a dataset</h6>
			<p>In the preceding graph, there are three clusters. One additional group of people has high blood pressure but with low cholesterol. This group may or may not have a risk of heart disease. In further sections, clustering will be illustrated on real datasets in which the x and y coordinates denote actual quantities. </p>
			<h3 id="_idParaDest-21">Use<a id="_idTextAnchor028"/>s of Clustering</h3>
			<p>Like all methods of unsupervised learning, clustering is mostly used when we don't have labeled data – data with predefined classes – for training our models. Clustering uses various properties, such as Euclidean distance and <strong class="bold">Manhattan</strong> <strong class="bold">distance</strong>, to find patterns in the data and classify them according to similarities in their properties without having any labels for training. So, clustering has many use cases in fields where labeled data is unavailable or we want to find patterns that are not defined by labels. </p>
			<p>The following are some applications of clustering:</p>
			<ul>
				<li><strong class="bold">Exploratory data analysis</strong>: When we have unlabeled data, we often do clustering to explore the underlying structure and categories of the dataset. For example, a retail store might want to explore how many different segments of customers they have, based on purchase history.</li>
				<li><strong class="bold">Generating training data</strong>: Sometimes, after processing unlabeled data with clustering methods, it can be labeled for further training with supervised learning algorithms. For example, two different classes that are unlabeled might form two entirely different clusters, and using their clusters, we can label data for further supervised learning algorithms that are more efficient in real-time classification than our unsupervised learning algorithms.</li>
				<li><strong class="bold">Recommender systems</strong>: With the help of clustering, we can find the properties of similar items and use these properties to make recommendations. For example, an e-commerce website, after finding customers in the same clusters, can recommend items to customers in that cluster based upon the items bought by other customers in that cluster.</li>
				<li><strong class="bold">Natural language processing</strong>: Clustering can be used for the grouping of similar words, texts, articles, or tweets, without labeled data. For example, you might want to group articles on the same topic automatically.</li>
				<li><strong class="bold">Anomaly detection</strong>: You can use clustering to find outliers. We're going to learn about this in <em class="italics">Chapter 6</em>, <em class="italics">Anomaly Detection</em>. Anomaly detection can also be used in cases where we have unbalanced classes in data, such as in the case of the detection of fraudulent credit card transactions.</li>
			</ul>
			<h2 id="_idParaDest-22">Int<a id="_idTextAnchor029"/>roduction to the Iris Dataset</h2>
			<p>In this chapter, we're going to use the Iris flowers dataset in exercises to learn how to classify three species of Iris flowers (Versicolor, Setosa, and Virginica) without using labels. This dataset is built-in to R and is very good for learning about the implementation of clustering techniques.</p>
			<p>Note that in our exercise dataset, we have final labels for the flowers. We're going to compare clustering results with those labels. We choose this dataset just to demonstrate that the results of clustering make sense. In the case of datasets such as the wholesale customer dataset (covered later in the book), where we don't have final labels, the results of clustering cannot be objectively verified and therefore might lead to misguided conclusions. That's the kind of use case where clustering is used in real life when we don't have final labels for the dataset. This point will be clearer once you have done both the exercises and activities.</p>
			<h3 id="_idParaDest-23">Exe<a id="_idTextAnchor030"/>rcise 1: Exploring the Iris Dataset</h3>
			<p>In <a id="_idTextAnchor031"/>this exercise, we're going to learn how to use the Iris dataset in R. Assuming you already have R installed in your system, let's proceed:</p>
			<ol>
				<li>Loa<a id="_idTextAnchor032"/>d the Iris dataset into a variable as follows:<p class="snippet">iri<a id="_idTextAnchor033"/>s_data&lt;-iris</p></li>
				<li>Now<a id="_idTextAnchor034"/> that our Iris data is in the <strong class="inline">iris_data</strong> variable, we can have a look at its first few rows by using the <strong class="inline">head</strong> function in R:<p class="snippet">hea<a id="_idTextAnchor035"/>d(iris_data)</p><p>The<a id="_idTextAnchor036"/> output is as follows:</p><div class="IMG---Figure" id="_idContainer015"><img alt="Figure 1.4: First six rows of the Iris dataset&#13;&#10;" src="image/C12628_01_04.jpg"/></div></li>
			</ol>
			<h6> </h6>
			<h6>F<a id="_idTextAnchor037"/>igure 1.4: The first six rows of the Iris dataset</h6>
			<p>We c<a id="_idTextAnchor038"/>an see our dataset has five columns. We're mostly going to use two columns for ease of visualization in plots of two dimensions. </p>
			<h3 id="_idParaDest-24">Type<a id="_idTextAnchor039"/>s of Clustering</h3>
			<p>As stated previously, clustering algorithms find natural groupings in data. There are many ways in which we can find natural groupings in data. The following are the methods that we're going to study in this chapter:</p>
			<ul>
				<li>k-means clustering</li>
				<li>k-medoids clustering</li>
			</ul>
			<p>Once the concepts related to the basic types of clustering are clear, we will have a look at other types of clustering, which are as follows:</p>
			<ul>
				<li>k-modes</li>
				<li>Density-based clustering</li>
				<li>Agglomerative hierarchical clustering</li>
				<li>Divisive clustering </li>
			</ul>
			<h2 id="_idParaDest-25">Intr<a id="_idTextAnchor040"/>oduction to k-means Clustering</h2>
			<p>K-means clustering is one of the most basic types of unsupervised learning algorithm. This algorithm finds natural groupings in accordance with a predefined similarity or distance measure. The distance measure can be any of the following:</p>
			<ul>
				<li>Euclidean distance</li>
				<li>Manhattan distance</li>
				<li>Cosine distance</li>
				<li>Hamming distance</li>
			</ul>
			<p>To understand what a distance measure does, take the example of a bunch of pens. You have 12 pens. Six of them are blue, and six red. Six of them are ball point pens and six are ink pens. If you were to use ink color as a similarity measure, then six blue pens and six red pens will be in different clusters. The six blue pens can be ink or ball point here; there's no restriction on that. But if you were to use the type of pen as the similarity measure, then the six ink pens and six ball point pens would be in different clusters. Now it doesn't matter whether the pens in each cluster are of the same color or not.</p>
			<h3 id="_idParaDest-26">Eucl<a id="_idTextAnchor041"/>idean Distance</h3>
			<p>Euclidean distance is the straight-line distance between any two points. Calculation of this distance in two dimensions can be thought of an extension of the Pythagorean theorem, which you might have studied in school. But Euclidean distance can be calculated between two points in any n-dimensional space, not just a two-dimensional space. The Euclidean distance between any two points is the square root of the sum of squares of differences between the coordinates. An example of the calculation of Euclidean distance is presented here:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 1.5: Representation of Euclidean distance calculation&#13;&#10;" src="image/C12628_01_05.jpg"/>
				</div>
			</div>
			<h6>Figure 1.5: Representation of Euclidean distance calculation</h6>
			<p>In k-means clustering, Euclidean distance is used. One disadvantage of using Euclidean distance is that it loses its meaning when the dimensionality of data is very high. This is related to a phenomenon known as the curse of dimensionality. When datasets possess many dimensions, they can be harder to work with, since distances between all points can become extremely high, and the distances are difficult to interpret and visualize. </p>
			<p>So, when the dimensionality of data is very high, either we reduce its dimensions with principal component analysis, which we're going to study in <em class="italics">Chapter 4</em>, <em class="italics">Dimension Reduction</em>, or we use cosine similarity.</p>
			<h3 id="_idParaDest-27">Manha<a id="_idTextAnchor042"/>ttan Distance</h3>
			<p>By definition, Manhattan distance is the distance between two points measured along a right angle to the axes:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 1.6: Representation of Manhattan distance &#13;&#10;" src="image/C12628_01_06.jpg"/>
				</div>
			</div>
			<h6>Figure 1.6: Representation of Manhattan distance </h6>
			<p>The length of the diagonal line is the Euclidean distance between the two points. Manhattan distance is simply the sum of the absolute value of the differences between two coordinates. So, the main difference between Euclidean distance and Manhattan distance is that with Euclidean distance, we square the distances between coordinates and then take the root of the sum, but in Manhattan distance, we directly take the sum of the absolute value of the differences between coordinates.</p>
			<h3 id="_idParaDest-28"><a id="_idTextAnchor043"/>Cosine Distance</h3>
			<p>Cosine similarity between any two points is defined as the cosine of the angle between any two points with the origin as its vertex. It can be calculated by dividing the dot product of any two vectors by the product of the magnitudes of the vectors:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 1.7: Representation of cosine similarity and cosine distance&#13;&#10;" src="image/C12628_01_07.jpg"/>
				</div>
			</div>
			<h6>Figure 1.7: Representation of cosine similarity and cosine distance</h6>
			<p>Cosine distance is defined as (1-cosine similarity).</p>
			<p>Cosine distance varies from 0 to 2, whereas cosine similarity varies between -1 to 1. Always remember that cosine similarity is one minus the value of of the cosine distance.</p>
			<h3 id="_idParaDest-29">The Hamming<a id="_idTextAnchor044"/> Distance</h3>
			<p>The Ham<a id="_idTextAnchor045"/>ming distance is a special type of distance that is used for categorical variables. Given two points of equal dimensions, the Hamming distance is defined as the number of coordinates differing from one another. For example, let's take two points, (0, 1, 1) and (0, 1, 0). Only one value, which is the last value, is different between these two variables. As such, the Hamming distance between them is 1:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 1.8: Representation of the Hamming distance&#13;&#10;" src="image/C12628_01_08.jpg"/>
				</div>
			</div>
			<h6>Figure 1.8: Representation of the Hamming distance</h6>
			<h3 id="_idParaDest-30">k-means <a id="_idTextAnchor046"/>Clustering Algorithm</h3>
			<p>K-means clustering is used to find clusters in a dataset of similar points when we have unlabeled data. In this chapter, we're going to use the Iris flowers dataset. This dataset contains information about the length and breadth of sepals and petals of flowers of different species. With the help of unsupervised learning, we're going to learn how to differentiate between them without knowing which properties belong to which species. The following is the scatter plot of our dataset:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer020">
					<img alt="Figure 1.9: Scatter plot of the Iris flowers dataset&#13;&#10;" src="image/C12628_01_09.jpg"/>
				</div>
			</div>
			<h6>Figure 1.9: A scatter plot of the Iris flowers dataset</h6>
			<p>This is the scatter plot of two variables of the Iris flower dataset: sepal length and sepal width.</p>
			<p>If we were to identify the clusters in the preceding dataset according to the distance between the points, we would choose clusters that look like bunches of grapes hanging from a tree. You can see that there are two major bunches (one in the top left and the other being the remaining points). The k-means algorithm identifies these "bunches" of grapes.</p>
			<p>The following figure shows the same scatter plot, but with the three different species of Iris shown in different colors. These species are taken from the 'species' column of the original dataset, and are as follows: Iris setosa (shown in green), Iris versicolor (shown in red), and Iris virginica (shown in blue). We're going to see whether we can determine these species by forming our own classifications using clustering:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 1.10: Scatter plot showing different species of Iris flowers dataset&#13;&#10;" src="image/C12628_01_10.jpg"/>
				</div>
			</div>
			<h6>Figure 1.10: A scatter plot showing different species of Iris flowers dataset</h6>
			<p>Here is a photo of Iris setosa, which is represented in green in the preceding scatter plot:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer022">
					<img alt="Figure 1.11: Iris setosa &#13;&#10;" src="image/C12628_01_11.jpg"/>
				</div>
			</div>
			<h6>Figure 1.11: Iris setosa </h6>
			<p>The following is a photo of Iris versicolor, which is represented in red in the preceding scatter plot:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer023">
					<img alt="Figure 1.12: Iris versicolor&#13;&#10;" src="image/C12628_01_12.jpg"/>
				</div>
			</div>
			<h6>Figure 1.12: Iris versicolor</h6>
			<p>Here is a photo of Iris virginica, which is represented in blue in the preceding scatter plot:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 1.13: Iris virginica &#13;&#10;" src="image/C12628_01_13.jpg"/>
				</div>
			</div>
			<h6>Figure 1.13: Iris virginica </h6>
			<h3 id="_idParaDest-31">Steps to Impl<a id="_idTextAnchor047"/>ement k-means Clustering</h3>
			<p>As we saw in the scatter plot in figure 1.9, each data point represents a flower. We're going to find clusters that will identify these species. To do this type of clustering, we're going to use k-means clustering, where k is the number of clusters we want. The following are the steps to perform k-means clustering, which, for simplicity of understanding, we're going to demonstrate with two clusters. We will build up to using three clusters later, in order to try and match the actual species groupings:</p>
			<ol>
				<li value="1">Choose any two random coordinates, k1 and k2, on the scatter plot as initial cluster centers.</li>
				<li>Calculate the distance of each data point in the scatter plot from coordinates k1 and k2.</li>
				<li>Assign each data point to a cluster based on whether it is closer to k1 or k2</li>
				<li>Find the mean coordinates of all points in each cluster and update the values of k1 and k2 to those coordinates respectively.</li>
				<li>Start again from <em class="italics">Step 2</em> until the coordinates of k1 and k2 stop moving significantly, or after a certain pre-determined number of iterations of the process.</li>
			</ol>
			<p>We're going to demonstrate the preceding algorithm with graphs and code.</p>
			<h3 id="_idParaDest-32">Exercise 2: I<a id="_idTextAnchor048"/>mplementing k-means Clustering on the Iris Dataset</h3>
			<p>In this exerc<a id="_idTextAnchor049"/>ise, we will implement k-means clustering step by step:</p>
			<ol>
				<li value="1">Load the built-in Iris dataset in the <strong class="inline">iris_data</strong> variable:<p class="snippet">iris_data&lt;-iris</p></li>
				<li>Set the color for different species for representation on the scatter plot. This will help us see how the three different species are split between our initial two groupings:<p class="snippet">iris_data$t_color='red'</p><p class="snippet">iris_data$t_color[which(iris_data$Species=='setosa')]&lt;-'green'</p><p class="snippet">iris_data$t_color[which(iris_data$Species=='virginica')]&lt;-'blue'</p></li>
				<li>Choose any two random clusters' centers to start with:<p class="snippet">k1&lt;-c(7,3)</p><p class="snippet">k2&lt;-c(5,3)</p><h4>Note </h4><p class="callout">You can try changing the points and see how it affects the final clusters.</p></li>
				<li>Plot the scatter plot along with the centers you chose in the previous step. Pass the length and width of the sepals of the iris flowers, along with the color, to the <strong class="inline">plot</strong> function in the first line, and then pass x and y coordinates of both the centers to the <strong class="inline">points()</strong> function. Here, <strong class="inline">pch</strong> is for selecting the type of representation of the center of the clusters – in this case, 4 is a cross and 5 is a diamond:<p class="snippet">plot(iris_data$Sepal.Length,iris_data$Sepal.Width,col=iris_data$t_color)</p><p class="snippet">points(k1[1],k1[2],pch=4)</p><p class="snippet">points(k2[1],k2[2],pch=5)</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer025"><img alt="Figure 1.14: Scatter plot of the chosen cluster centers&#13;&#10;" src="image/C12628_01_14.jpg"/></div><h6>Figure 1.14: A scatter plot of the chosen cluster centers</h6></li>
				<li>Choose the number of iterations you want. The number of iterations should be such that the centers stop changing significantly after each iteration. In our case, six iterations are sufficient:<p class="snippet">number_of_steps&lt;-6</p></li>
				<li>Initialize the variable that will keep track of the number of iterations in the loop:<p class="snippet">n&lt;-1</p></li>
				<li>Start the <strong class="inline">while</strong> loop to find the final cluster centers:<p class="snippet">while(n&lt;number_of_steps)</p><p class="snippet"><strong class="inline">{</strong></p></li>
				<li>Calculate the distance of each point from the current cluster centers, which is <em class="italics">Step 2</em> in the algorithm. We're calculating the Euclidean distance here using the <strong class="inline">sqrt</strong> function:<p class="snippet">  iris_data$distance_to_clust1 &lt;- sqrt((iris_data$Sepal.Length-k1[1])^2+(iris_data$Sepal.Width-k1[2])^2)</p><p class="snippet">  iris_data$distance_to_clust2 &lt;- sqrt((iris_data$Sepal.Length-k2[1])^2+(iris_data$Sepal.Width-k2[2])^2)</p></li>
				<li>Assign each point to the cluster whose center it is closest to, which is <em class="italics">Step 3</em> of the algorithm:<p class="snippet">  iris_data$clust_1 &lt;- 1*(iris_data$distance_to_clust1&lt;=iris_data$distance_to_clust2)</p><p class="snippet">  iris_data$clust_2 &lt;- 1*(iris_data$distance_to_clust1&gt;iris_data$distance_to_clust2) </p></li>
				<li>Calculate new cluster centers by calculating the mean <strong class="inline">x</strong> and <strong class="inline">y</strong> coordinates of the point in each cluster (<em class="italics">step 4</em> in the algorithm) with the <strong class="inline">mean()</strong> function in R:<p class="snippet">  k1[1]&lt;-mean(iris_data$Sepal.Length[which(iris_data$clust_1==1)])</p><p class="snippet">  k1[2]&lt;-mean(iris_data$Sepal.Width[which(iris_data$clust_1==1)])</p><p class="snippet">  k2[1]&lt;-mean(iris_data$Sepal.Length[which(iris_data$clust_2==1)])</p><p class="snippet">  k2[2]&lt;-mean(iris_data$Sepal.Width[which(iris_data$clust_2==1)])</p></li>
				<li>Update the variable that is keeping the count of iterations for us to effectively carry out <em class="italics">step 5</em> of the algorithm:<p class="snippet">  n=n+1</p><p class="snippet">}</p></li>
				<li>Now we're going to overwrite the species colors with new colors to demonstrate the two clusters. So, there will only be two colors on our next scatter plot – one color for cluster 1, and one color for cluster 2:<p class="snippet">iris_data$color='red'</p><p class="snippet">iris_data$color[which(iris_data$clust_2==1)]&lt;-'blue'</p></li>
				<li>Plot the new scatter plot, which contains clusters along with cluster centers:<p class="snippet">plot(iris_data$Sepal.Length,iris_data$Sepal.Width,col=iris_data$color)</p><p class="snippet">points(k1[1],k1[2],pch=4)</p><p class="snippet">points(k2[1],k2[2],pch=5)</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 1.15: Scatter plot representing each cluster with a different color&#13;&#10;" src="image/C12628_01_15.jpg"/>
				</div>
			</div>
			<h6>Figure 1.15: A scatter plot representing each cluster with a different color</h6>
			<p>Notice how setosa (which used to be green) has been grouped in the left cluster, while most of the virginica flowers (which were blue) have been grouped into the right cluster. The versicolor flowers (which were red) have been split between the two new clusters.</p>
			<p>You have successfully implemented the k-means clustering algorithm to identify two groups of flowers based on their sepal size. Notice how the position of centers has changed after running the algorithm. </p>
			<p>In the following activity, we are going to increase the number of clusters to three to see whether we can group the flowers correctly into their three different species.</p>
			<h3 id="_idParaDest-33">Activity 1: k-m<a id="_idTextAnchor050"/>eans Clustering with Three Clusters</h3>
			<p>Write an R program to perform k-means clustering on the Iris dataset using three clusters. In this activity, we're going to perform the following steps:</p>
			<ol>
				<li value="1">Choose any three random coordinates, k1, k2, and k3, on the plot as centers.</li>
				<li>Calculate the distance of each data point from k1, k2, and k3.</li>
				<li>Classify each point by the cluster whose center it is closest to.</li>
				<li>Find the mean coordinates of all points in the respective clusters and update the values of k1, k2, and k3 to those values.</li>
				<li>Start again from <em class="italics">Step 2</em> until the coordinates of k1, k2, and k3 stop moving significantly, or after 10 iterations of the process.</li>
			</ol>
			<p>The outcome of <a id="_idTextAnchor051"/>this activity will be a chart with three clusters, as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 1.16: Expected scatter plot for the given cluster centers&#13;&#10;" src="image/C12628_01_16.jpg"/>
				</div>
			</div>
			<h6>Figure 1.16: The expected scatter plot for the given cluster centers</h6>
			<p>You can compare your chart to Figure 1.10 to see how well the clusters match the actual species classifications.</p>
			<h4>Note</h4>
			<p class="callout">The solutio<a id="_idTextAnchor052"/>n for this activity can be found on page 198.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor053"/>Introduction to k-means Clustering with Built-In Functions</h2>
			<p>In this section, we're going to use some built-in libraries of R to perform k-means clustering instead of writing custom code, which is lengthy and prone to bugs and errors. Using pre-built libraries instead of writing our own code has other advantages, too:</p>
			<ul>
				<li>Library functions are computationally efficient, as thousands of man hours have gone into the development of those functions.</li>
				<li>Library functions are almost bug-free as they've been tested by thousands of people in almost all practically-usable scenarios.</li>
				<li>Using libraries saves time, as you don't have to invest time in writing your own code.</li>
			</ul>
			<h3 id="_idParaDest-35">k-means Clusteri<a id="_idTextAnchor054"/>ng with Three Clusters</h3>
			<p>In the previous activity, we performed k-means clustering with three clusters by writing our own code. In this section, we're going to achieve a similar result with the help of pre-built R libraries.</p>
			<p>At first, we're going to start with a distribution of three types of flowers in our dataset, as represented in the following graph:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer028">
					<img alt="Figure 1.17: Graph representing three species of iris in three colors&#13;&#10;" src="image/C12628_01_17.jpg"/>
				</div>
			</div>
			<h6>Figure 1.17: A graph representing three species of iris in three colors</h6>
			<p>In the preceding plot, setosa is represented in blue, virginica in gray, and versicolor in pink.</p>
			<p>With this dataset, we're going to perform k-means clustering and see whether the built-in algorithm is able to find a pattern on its own to classify these three species of iris using their sepal sizes. This time, we're going to use just four lines of code.</p>
			<h3 id="_idParaDest-36"><a id="_idTextAnchor055"/>Exercise 3: k-means Clustering with R Libraries</h3>
			<p>In this exercise, we're going to learn to do k-means clustering in a much easier way with the pre-built libraries of R. By completing this exercise, you will be able to divide the three species of Iris into three separate clusters:</p>
			<ol>
				<li value="1">We put the first two columns of the iris dataset, sepal length and sepal width, in the <strong class="inline">iris_data</strong> variable:<p class="snippet">iris_data&lt;-iris[,1:2]</p></li>
				<li>We find the k-means cluster centers and the cluster to which each point belongs, and store it all in the <strong class="inline">km.res</strong> variable. Here, in the <strong class="inline">kmeans</strong>, function we enter the dataset as the first parameter, and the number of clusters we want as the second parameter:<p class="snippet">km.res&lt;-kmeans(iris_data,3)</p><h4>Note</h4><p class="callout">The k-means function has many input variables, which can be altered to get different final outputs. You can find out more about them here in the documentation at <a href="https://www.rdocumentation.org/packages/stats/versions/3.5.1/topics/kmeans">https://www.rdocumentation.org/packages/stats/versions/3.5.1/topics/kmeans</a>.</p></li>
				<li>Install the <strong class="inline">factoextra</strong> library as follows:<p class="snippet">install.packages('factoextra')</p></li>
				<li>We import the <strong class="inline">factoextra</strong> library for visualization of the clusters we just created. <strong class="inline">Factoextra</strong> is an R package that is used for plotting multivariate data:<p class="snippet">library("factoextra") </p></li>
				<li>Generate the plot of the clusters. Here, we need to enter the results of k-means as the first parameter. In <strong class="inline">data</strong>, we need to enter the data on which clustering was done. In <strong class="inline">pallete</strong>, we're selecting the type of the geometry of points, and in <strong class="inline">ggtheme</strong>, we're selecting the theme of the output plot:<p class="snippet">fviz_cluster(km.res, data = iris_data,palette = "jco",ggtheme = theme_minimal())</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="Figure 1.18: Three species of Iris have been clustered into three clusters&#13;&#10;" src="image/C12628_01_18.jpg"/>
				</div>
			</div>
			<h6>Figure 1.18: Three species of Iris have been clustered into three clusters</h6>
			<p>Here, if you compare Figure 1.18 to Figure 1.17, you will see that we have classified all three species almost correctly. The clusters we've generated don't exactly match the species shown in figure 1.18, but we've come very close considering the limitations of only using sepal length and width to classify them.</p>
			<p>You can see from this example that clustering would've been a very useful way of categorizing the irises if we didn't already know their species. You will come across many examples of datasets where you don't have labeled categories, but are able to use clustering to form your own groupings.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor056"/>Introduction to Market Segmentation</h2>
			<p>Market segmentatio<a id="_idTextAnchor057"/>n is dividing customers into different segments based on common characteristics. The following are the uses of customer segmentation:</p>
			<ul>
				<li>Increasing custome<a id="_idTextAnchor058"/>r conversion and retention</li>
				<li>Developing new pro<a id="_idTextAnchor059"/>ducts for a particular segment by identifying it and its needs</li>
				<li>Improving brand co<a id="_idTextAnchor060"/>mmunication with a particular segment</li>
				<li>Identifying gaps i<a id="_idTextAnchor061"/>n marketing strategy and making new marketing strategies to increase sales</li>
			</ul>
			<h3 id="_idParaDest-38"><a id="_idTextAnchor062"/>Exercise 4: Exploring the Wholesale Customer Dataset</h3>
			<p>In this exercise, we will have a look at the data in the wholesale customer dataset.</p>
			<h4>Note</h4>
			<p class="callout">For all the exercises and activities where we are importing an external CSV or image files, go to <strong class="bold">RStudio</strong>-&gt; <strong class="bold">Session</strong>-&gt; <strong class="bold">Set Working Directory</strong>-&gt; <strong class="bold">To Source File Location</strong>. You can see in the console that the path is set automatically.</p>
			<ol>
				<li value="1">To download the CSV file, go to <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Exercise04/wholesale_customers_data.csv">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Exercise04/wholesale_customers_data.csv</a>. Click on <strong class="inline">wholesale_customers_data.csv</strong>.<h4>Note</h4><p class="callout">This dataset is taken from the UCI Machine Learning Repository. You can find the dataset at <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/00292/">https://archive.ics.uci.edu/ml/machine-learning-databases/00292/</a>. We have downloaded the file and saved it at <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Exercise04/wholesale_customers_data.csv. ">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Exercise04/wholesale_customers_data.csv.</a></p></li>
				<li>Save it to the folder in which you have installed R. Now, to load it in R, use the following function:<p class="snippet">ws&lt;-read.csv("wholesale_customers_data.csv")</p></li>
				<li>Now we may have a look at the different columns and rows in this dataset by using the following function in R:<p class="snippet">head(ws)</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="Figure 1.19: Columns of the wholesale customer dataset&#13;&#10;" src="image/C12628_01_19.jpg"/>
				</div>
			</div>
			<h6>Figure 1.19: Columns of the wholesale customer dataset</h6>
			<p>These six rows show the first six rows of annual spending in monetary units by category of product.</p>
			<h3 id="_idParaDest-39">Activity 2: Custome<a id="_idTextAnchor063"/>r Segmentation with k-means </h3>
			<p>For this activity, we're going to use the wholesale customer dataset from the UCI Machine Learning Repository. It's available at: <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity02/wholesale_customers_data.csv">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity02/wholesale_customers_data.csv</a>. We're going to identify customers belonging to different market segments who like to spend on different types of goods with clustering. Try k-means clustering for values of k from 2 to 6. </p>
			<h4>Note</h4>
			<p class="callout">This dataset is taken from the UCI Machine Learning Repository. You can find the dataset at <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/00292/">https://archive.ics.uci.edu/ml/machine-learning-databases/00292/</a>. We have downloaded the file and saved it at <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity02/wholesale_customers_data.csv. ">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity02/wholesale_customers_data.csv.</a></p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Read data downloaded from the UCI Machine Learning Repository into a variable. The data can be found at: <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity02/wholesale_customers_data.csv">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity02/wholesale_customers_data.csv</a>.</li>
				<li>Select only two columns, Grocery and Frozen, for easy visualization of clusters.</li>
				<li>As in <em class="italics">Step 2</em> of <em class="italics">Exercise 4</em>, <em class="italics">Exploring the Wholesale Customer Dataset</em>, change the value for the number of clusters to 2 and generate the cluster centers.</li>
				<li>Plot the graph as in <em class="italics">Step 4</em> in <em class="italics">Exercise 4</em>, <em class="italics">Exploring the Wholesale Customer Dataset</em>. </li>
				<li>Save the graph you generate.</li>
				<li>Repeat <em class="italics">Steps 3</em>, <em class="italics">4</em>, and <em class="italics">5</em> by changing value for the number of clusters to 3, 4, 5, and 6.</li>
				<li>Decide which value for the number of clusters best classifies the dataset.</li>
			</ol>
			<p>The output will be chart of six clusters as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="Figure 1.20: Expected chart for six clusters&#13;&#10;" src="image/C12628_01_20.jpg"/>
				</div>
			</div>
			<h6>Figure 1.20: The expected chart for six clusters</h6>
			<h4>Note</h4>
			<p class="callout">The solution for this activity can be found on page 201.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor064"/>Introduction to k-medoids Clustering</h2>
			<p>k-medoids is another type of clustering algorithm that can be used to find natural groupings in a dataset. k-medoids clustering is very similar to k-means clustering, except for a few differences. The k-medoids clustering algorithm has a slightly different optimization function than k-means. In this section, we're going to study k-medoids clustering.</p>
			<h3 id="_idParaDest-41">The k-medoids Cluste<a id="_idTextAnchor065"/>ring Algorithm</h3>
			<p>There are many different types of algorithms to perform k-medoids clustering, the simplest and most efficient of which is <strong class="bold">Partitioning Around Medoids</strong>, or PAM for short. In PAM, we do the following steps to find cluster centers:</p>
			<ol>
				<li value="1">Choose k data points from the scatter plot as starting points for cluster centers.</li>
				<li>Calculate their distance from all the points in the scatter plot.</li>
				<li>Classify each point into the cluster whose center it is closest to.</li>
				<li>Select a new point in each cluster that minimizes the sum of distances of all points in that cluster from itself.</li>
				<li>Repeat <em class="italics">Step 2</em> until the centers stop changing.</li>
			</ol>
			<p>You can see that the PAM algorithm is identical to the k-means clustering algorithm, except for <em class="italics">Step 1</em> and <em class="italics">Step 4</em>. For most practical purposes, k-medoids clustering gives almost identical results to k-means clustering. But in some special cases where we have outliers in a dataset, k-medoids clustering is preferred as it's more robust to outliers. More about when to use which type of clustering and their differences will be studied in later sections.</p>
			<h3 id="_idParaDest-42">k-medoids Clustering<a id="_idTextAnchor066"/> Code</h3>
			<p>In this section, we're going to use the same Iris flowers dataset that we used in the last two sections and compare to see whether the results are visibly different from the ones we got last time. Instead of writing code to perform each step of the k-medoids algorithm, we're directly going to use libraries of R to do PAM clustering.</p>
			<h3 id="_idParaDest-43">Exercise 5: Implemen<a id="_idTextAnchor067"/>ting k-medoid Clustering</h3>
			<p>In this exercise, we<a id="_idTextAnchor068"/>'re going to perform k-medoids with R's pre-built libraries:</p>
			<ol>
				<li value="1">Store the first two columns of the iris dataset in the <strong class="inline">iris_data</strong> variable:<p class="snippet">iris_data&lt;-iris[,1:2]</p></li>
				<li>Install the <strong class="inline">cluster</strong> package:<p class="snippet">install.packages("cluster")</p></li>
				<li>Import the <strong class="inline">cluster</strong> package:<p class="snippet">library("cluster")</p></li>
				<li>Store the PAM clustering results in the <strong class="inline">km.res</strong> variable:<p class="snippet">km&lt;-pam(iris_data,3)</p></li>
				<li>Import the <strong class="inline">factoextra</strong> library:<p class="snippet">library("factoextra")</p></li>
				<li>Plot the PAM clustering results in a graph:<p class="snippet">fviz_cluster(km, data = iris_data,palette = "jco",ggtheme = theme_minimal())</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 1.21: Results of k-medoids clustering&#13;&#10;" src="image/C12628_01_21.jpg"/>
				</div>
			</div>
			<h6>Figure 1.21: Results of k-medoids clustering</h6>
			<p>The results of k-medoids clustering are not very different from those of the k-means clustering we did in the previous section.</p>
			<p>So, we can see that the preceding PAM algorithm classifies our dataset into three clusters that are similar to the clusters we got with k-means clustering. If we plot the results of both types of clustering side by side, we can clearly see how similar they are:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 1.22: k-medoids clustering versus k-means clustering results&#13;&#10;" src="image/C12628_01_22.jpg"/>
				</div>
			</div>
			<h6>Figure 1.22: The results of k-medoids clustering versus k-means clustering</h6>
			<p>In the preceding graphs, observe how the centers of both k-means and k-medoids clustering are so close to each other, but centers for k-medoids clustering are directly overlapping on points already in the data while the centers for k-means clustering are not.</p>
			<h3 id="_idParaDest-44">k-means Clustering ver<a id="_idTextAnchor069"/>sus k-medoids Clustering</h3>
			<p>Now that we've studied both k-means and k-medoids clustering, which are almost identical to each other, we're going to study the differences between them and when to use which type of clustering:</p>
			<ul>
				<li>Computational complexity: Of the two methods, k-medoids clustering is computationally more expensive. When our dataset is too large (&gt;10,000 points) and we want to save computation time, we'll prefer k-means clustering over k-medoids clustering.<h4>Note</h4><p class="callout">Whether your dataset is large or not is entirely dependent on the computation power available. As computation gets cheaper over time, what is considered a large dataset will change in the future.</p></li>
				<li>Presence of outliers: k-means clustering is more sensitive to outliers than k-medoids. Cluster center positions can shift significantly due to the presence of outliers in the dataset, so we use k-medoids clustering when we have to build clusters resilient to outliers.</li>
				<li>Cluster centers: Both the k-means and k-medoids algorithms find cluster centers in different ways. The center of a k-medoids cluster is always a data point in the dataset. The center of a k-means cluster does not need to be a data point in the dataset.</li>
			</ul>
			<h3 id="_idParaDest-45">Activity 3: Performing<a id="_idTextAnchor070"/> Customer Segmentation with k-medoids Clustering</h3>
			<p>Use the Wholesale customer dataset to perform both k-means and k-medoids clustering, and then compare the results. Read the data downloaded from the UCI machine learning repository into a variable. The data can be found at <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Data/wholesale_customers_data.csv">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Data/wholesale_customers_data.csv</a>.</p>
			<h4>Note</h4>
			<p class="callout">This dataset is taken from the UCI Machine Learning Repository. You can find the dataset at <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/00292/">https://archive.ics.uci.edu/ml/machine-learning-databases/00292/</a>. We have downloaded the file and saved it at <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity03/wholesale_customers_data.csv. ">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity03/wholesale_customers_data.csv.</a></p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Select only two columns, Grocery and Frozen, for easy two-dimensional visualization of clusters.</li>
				<li>Use k-medoids clustering to plot a graph showing four clusters for this data. </li>
				<li>Use k-means clustering to plot a four-cluster graph.</li>
				<li>Compare the two graphs to comment on how the results of the two methods differ.</li>
			</ol>
			<p>The outcome will be a k-means plot of the clusters as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer034">
					<img alt="Figure 1.23: Expected k-means plot of the cluster&#13;&#10;" src="image/C12628_01_23.jpg"/>
				</div>
			</div>
			<h6>Figure 1.23: The expected k-means plot of the cluster</h6>
			<h4>Note</h4>
			<p class="callout">The solution for this activity can be found on page 206.</p>
			<h3 id="_idParaDest-46">Deciding the Optimal Nu<a id="_idTextAnchor071"/>mber of Clusters</h3>
			<p>Until now, we've been working on the iris flowers dataset, in which we know how many categories of flowers there are, and we chose to divide our dataset into three clusters based on this knowledge. But in unsupervised learning, our primary task is to work with data about which we don't have any information, such as how many natural clusters or categories there are in a dataset. Also, clustering can be a form of exploratory data analysis too, in which case, you won't have much information about the data. And sometimes, when the data has more than two dimensions, it becomes hard to visualize and find out the number of clusters manually. So, how do we find the optimal number of clusters in these scenarios? In this section, we're going to learn techniques to get the optimal value of the number of clusters.</p>
			<h3 id="_idParaDest-47">Types of Clustering Met<a id="_idTextAnchor072"/>rics</h3>
			<p>There is more than one way of determining the optimal number of clusters in unsupervised learning. The following are the ones that we're going to study in this chapter:</p>
			<ul>
				<li>The Silhouette score</li>
				<li>The Elbow method / WSS</li>
				<li>The Gap statistic</li>
			</ul>
			<h3 id="_idParaDest-48"><a id="_idTextAnchor073"/>Silhouette Score</h3>
			<p>The silhouette score or average silhouette score calculation is used to quantify the quality of clusters achieved by a clustering algorithm. Let's take a point, a, in a cluster, x:</p>
			<ol>
				<li value="1">Calculate the average distance between point a and all the points in cluster x (denoted by <strong class="bold">dxa</strong>):<div class="IMG---Figure" id="_idContainer035"><img alt="Figure 1.24: Calculating the average distance between point a and all the points of cluster x&#13;&#10;" src="image/C12628_01_24.jpg"/></div><h6>Figure 1.24: Calculating the average distance between point a and all the points of cluster x</h6></li>
				<li>Calculate the average distance between point a and all the points in another cluster nearest to a (<strong class="bold">dya</strong>):<div class="IMG---Figure" id="_idContainer036"><img alt="Figure 1.25: Calculating the average distance between point a and all the points near cluster x&#13;&#10;" src="image/C12628_01_25.jpg"/></div><h6>Figure 1.25: Calculating the average distance between point a and all the points near cluster x</h6></li>
				<li>Calculate the silhouette score for that point by dividing the difference of the result of <em class="italics">Step 1</em> from the result of <em class="italics">Step 2</em> by the max of the result of <em class="italics">Step 1</em> and <em class="italics">Step 2</em> ((dya-dxa)/max(dxa,dya)).</li>
				<li>Repeat the first three steps for all points in the cluster.</li>
				<li>After getting the silhouette score for every point in the cluster, the average of all those scores is the silhouette score of that cluster:<div class="IMG---Figure" id="_idContainer037"><img alt="Figure 1.26: Calculating the silhouette score&#13;&#10;" src="image/C12628_01_26.jpg"/></div><h6>Figure 1.26: Calculating the silhouette score</h6></li>
				<li>Repeat the preceding steps for all the clusters in the dataset.</li>
				<li>After getting the silhouette score for all the clusters in the dataset, the average of all those scores is the silhouette score of that dataset:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer038">
					<img alt="Figure 1.27: Calculating the average silhouette score&#13;&#10;" src="image/C12628_01_27.jpg"/>
				</div>
			</div>
			<h6>Figure 1.27: Calculating the average silhouette score</h6>
			<p>The silhouette score ranges between 1 and -1. If the silhouette score of a cluster is low (between 0 and -1), it means that the cluster is spread out or the distance between the points of that cluster is high. If the silhouette score of a cluster is high (close to 1), it means that the clusters are well defined and the distance between the points of a cluster is low and their distance from points of other clusters is high. So, the ideal silhouette score is near 1.</p>
			<p>Understanding the preceding algorithm is important for forming an understanding of silhouette scores, but it's not important for learning how to implement it. So, we're going to learn how to do silhouette analysis in R using some pre-built libraries.</p>
			<h3 id="_idParaDest-49">Exercise 6: Calculating the Sil<a id="_idTextAnchor074"/>houette Score</h3>
			<p>In this exercise, we're goi<a id="_idTextAnchor075"/>ng to learn how to calculate the silhouette score of a dataset with a fixed number of clusters:</p>
			<ol>
				<li value="1">Put the first two columns of the iris dataset, sepal length and sepal width, in the <strong class="inline">iris_data</strong> variable:<p class="snippet">iris_data&lt;-iris[,1:2]</p></li>
				<li>Import the <strong class="inline">cluster</strong> library to perform k-means clustering:<p class="snippet">library(cluster)</p></li>
				<li>Store the k-means clusters in the <strong class="inline">km.res</strong> variable:<p class="snippet">km.res&lt;-kmeans(iris_data,3)</p></li>
				<li>Store the pair-wise distance matrix for all data points in the <strong class="inline">pair_dis</strong> variable:<p class="snippet">pair_dis&lt;-daisy(iris_data)</p></li>
				<li><a id="_idTextAnchor076"/>Calculate the silhouette score for each point in the dataset:<p class="snippet">sc&lt;-silhouette(km.res$cluster, pair_dis)</p></li>
				<li>Plot the silhouette score plot:<p class="snippet">plot(sc,col=1:8,border=NA)</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer039">
					<img alt="Fig 1.28: The silhouette score for each point in every cluster is represented by a single bar&#13;&#10;" src="image/C12628_01_28.jpg"/>
				</div>
			</div>
			<h6>Fig 1.28: The silhouette score for each point in every cluster is represented by a single bar</h6>
			<p>The preceding plot gives the average silhouette score of the dataset as 0.45. It also shows the average silhouette score cluster-wise and point-wise. </p>
			<p>In the preceding exercise, we calculated the silhouette score for three clusters. But for deciding how many clusters to have, we'll have to calculate the silhouette score for multiple clusters in the dataset. In the next exercise, we're going to learn how to do this with the help of a library called <strong class="inline">factoextra</strong> in R.</p>
			<h3 id="_idParaDest-50">Exercise 7: Identifying the <a id="_idTextAnchor077"/>Optimum Number of Clusters</h3>
			<p>In this exercise, we're goin<a id="_idTextAnchor078"/>g to identify the optimal number of clusters by calculating the silhouette score on various values of k in one line of code with the help of an R library:</p>
			<ol>
				<li value="1">Put first two columns, sepal length and sepal width, of the  Iris data set in the <strong class="inline">iris_data</strong> variable:<p class="snippet">iris_data&lt;-iris[,1:2]</p></li>
				<li>Import the <strong class="inline">factoextra</strong> library:<p class="snippet">library("factoextra")</p></li>
				<li>Plot a graph of the silhouette score versus number of clusters (up to 20):<p class="snippet">fviz_nbclust(iris_data, kmeans, method = "silhouette",k.max=20)</p><h4>Note </h4><p class="callout">In the second argument, you may change k-means to k-medoids or any other type of clustering. The <strong class="inline">k.max</strong> variable is the max number of clusters up to which the score is to be calculated. In the method argument of the function, you can enter three types of clustering metrics to be included. All three of them are discussed in this chapter.</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Fig 1.29: Number of clusters versus average silhouette score&#13;&#10;" src="image/C12628_01_29.jpg"/>
				</div>
			</div>
			<h6>Fig 1.29: The number of clusters versus average silhouette score</h6>
			<p>From the preceding graph, you select a value of k that has the highest score; that is, 2. Two is the optimal number of clusters as per the silhouette score.</p>
			<h3 id="_idParaDest-51"><a id="_idTextAnchor079"/>WSS/Elbow Method</h3>
			<p>To identify a cluster in a dataset, we try to minimize the distance between points in a cluster, and the <strong class="bold">Within-Sum-of-Squares</strong> (WSS) method measures exactly that. The WSS score is the sum of the squares of the distances of all points within a cluster. In this method, we perform the following steps:</p>
			<ol>
				<li value="1">Calculate clusters by using different values of k.</li>
				<li>For every value of k, calculate WSS using the following formula:<div class="IMG---Figure" id="_idContainer041"><img alt="Figure 1.30: The formula to calculate WSS where p is the total number of dimensions of the data" src="image/C12628_01_30.jpg"/></div><h6>Figure 1.30: The formula to calculate WSS where p is the total number of dimensions of the data</h6><p>This formula is illustrated here:</p><div class="IMG---Figure" id="_idContainer042"><img alt="Figure 1.31: Distances relative to two points, but WSS measures sums of all distances relative to all points within every cluster" src="image/C12628_01_31.jpg"/></div><h6>Figure 1.31: Illustration of WSS score</h6><h4>Note</h4><p class="callout">Figure 1.31 illustrates WSS relative to two points, but in reality WSS measures sums of all distances relative to all points. within every cluster.</p></li>
				<li>Plot number of clusters k versus WSS score.</li>
				<li>Identify the k value after which the WSS score doesn't decrease significantly and choose this k as the ideal number of clusters. This point is also known as the elbow of the graph, hence the name "<strong class="bold">elbow method</strong>". </li>
			</ol>
			<p>In the following exercise, we're going to learn how to identify the ideal number of clusters with the help of the <strong class="inline">factoextra</strong> library.</p>
			<h3 id="_idParaDest-52">Exercise 8: Using WSS to Determ<a id="_idTextAnchor080"/>ine the Number of Clusters</h3>
			<p>In this exercise, we will see how we can use WSS to determine the number of clusters. Perform the following steps.</p>
			<ol>
				<li value="1">Put the first two columns, sepal length and sepal width, of the Iris data set in the <strong class="inline">iris_data</strong> variable:<p class="snippet">iris_data&lt;-iris[,1:2]</p></li>
				<li>Import the <strong class="inline">factoextra</strong> library:<p class="snippet">library("factoextra")</p></li>
				<li>Plot a graph of WSS versus number of clusters (up to 20):<p class="snippet">fviz_nbclust(iris_data, kmeans, method = "wss", k.max=20)</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer043">
					<img alt="Fig 1.32: WSS versus number of clusters&#13;&#10;" src="image/C12628_01_32.jpg"/>
				</div>
			</div>
			<h6>Fig 1.32: WSS versus number of clusters</h6>
			<p>In the preceding graph, we can choose the elbow of the graph as k=3, as the value of WSS starts dropping more slowly after k=3. Choosing the elbow of the graph is always a subjective choice and there could be times where you could choose k=4 or k=2 instead of k=3, but with this graph, it's clear that k&gt;5 are inappropriate values for k as they are not the elbow of the graph, which is where the graph's slope changes sharply.</p>
			<h3 id="_idParaDest-53"><a id="_idTextAnchor081"/>The Gap Statistic</h3>
			<p>The Gap statistic is one of the most effective methods of finding the optimal number of clusters in a dataset. It is applicable to any type of clustering method. The Gap statistic is calculated by comparing the WSS value for the clusters generated on our observed dataset versus a reference dataset in which there are no apparent clusters. The reference dataset is a uniform distribution of data points between the minimum and maximum values of our dataset on which we want to calculate the Gap statistic. </p>
			<p>So, in short, the Gap statistic measures the WSS values for both observed and random datasets and finds the deviation of the observed dataset from the random dataset. To find the ideal number of clusters, we choose a value of k that gives us the maximum value of the Gap statistic. The mathematical details of how these deviations are measured are beyond the scope of this book. In the next exercise, we're going to learn how to calculate the Gap statistic with the help of the <strong class="inline">factoviz</strong> library.</p>
			<p>Here is a reference dataset:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer044">
					<img alt="Figure 1.33: Reference dataset&#13;&#10;" src="image/C12628_01_33.jpg"/>
				</div>
			</div>
			<h6>Figure 1.33: The reference dataset</h6>
			<p>The following is the observed dataset:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 1.34: Observed dataset&#13;&#10;" src="image/C12628_01_34.jpg"/>
				</div>
			</div>
			<h6>Figure 1.34: The observed dataset</h6>
			<h3 id="_idParaDest-54">Exercise 9: Calculating the Ideal <a id="_idTextAnchor082"/>Number of Clusters with the Gap Statistic</h3>
			<p>In this exercise, we will calculate the ideal number of clusters using the Gap statistic:</p>
			<ol>
				<li value="1">Put the first two columns, sepal length and sepal width, of the Iris data set in the <strong class="inline">iris_data</strong> variable as follows:<p class="snippet">iris_data&lt;-iris[,1:2]</p></li>
				<li>Import the <strong class="inline">factoextra</strong>  library as follows:<p class="snippet">library("factoextra")</p></li>
				<li>Plot the graph of Gap statistics versus number of clusters (up to 20):<p class="snippet">fviz_nbclust(iris_data, kmeans, method = "gap_stat",k.max=20)</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Fig 1.35: Gap statistic versus number of clusters&#13;&#10;" src="image/C12628_01_35.jpg"/>
				</div>
			</div>
			<h6>Fig 1.35: Gap statistics versus number of clusters</h6>
			<p>As we can see in the preceding graph, the highest value of the Gap statistic is for k=3. Hence, the ideal number of clusters in the iris dataset is three. Three is also the number of species in the dataset, indicating that the gap statistic has enabled us to reach a correct conclusion.</p>
			<h3 id="_idParaDest-55">Activity 4: Finding the Ideal Numbe<a id="_idTextAnchor083"/>r of Market Segments</h3>
			<p>Find the optimal number of clusters in the wholesale customers dataset with all three of the preceding methods:</p>
			<h4>Note</h4>
			<p class="callout">This dataset is taken from the UCI Machine Learning Repository. You can find the dataset at <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/00292/">https://archive.ics.uci.edu/ml/machine-learning-databases/00292/</a>. We have downloaded the file and saved it at <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity04/wholesale_customers_data.csv. ">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson01/Activity04/wholesale_customers_data.csv.</a></p>
			<ol>
				<li value="1">Load columns 5 to 6 of the wholesale customers dataset in a variable.</li>
				<li>Calculate the optimal number of clusters for k-means clustering with the silhouette score.</li>
				<li>Calculate the optimal number of clusters for k-means clustering with the WSS score.</li>
				<li>Calculate the optimal number of clusters for k-means clustering with the Gap statistic.</li>
			</ol>
			<p>The outcome will be three graphs representing the optimal number of clusters with the silhouette score, with the WSS score, and with the Gap statistic.</p>
			<h4>Note</h4>
			<p class="callout">The solution for this activity can be found on page 208.</p>
			<p>As we have seen, each method will give a different value for the optimal number of clusters. Sometimes, the results won't make sense, as you saw in the case of the Gap statistic, which gave the optimal number of clusters as one, which would mean that clustering shouldn't be done on this dataset and all data points should be in a single cluster. </p>
			<p>All the points in a given cluster will have similar properties. Interpretation of those properties is left to domain experts. And there's almost never a right answer for the right number of clusters in unsupervised learning.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor084"/>Summary</h2>
			<p>Congratulations! You have completed the first chapter of this book. If you've understood everything we've studied until now, you now know more about unsupervised learning than most people who claim to know data science. The k-means clustering algorithm is so fundamental to unsupervised learning that many people equate k-means clustering with unsupervised learning.</p>
			<p>In this chapter, you not only learned about k-means clustering and its uses, but also k-medoids clustering, along with various clustering metrics and their uses. So, now you have a top-tier understanding of k-means and k-medoid clustering algorithms. </p>
			<p>In the next chapter, we're going to have a look at some of the lesser-known clustering algorithms and their uses.</p>
		</div>
	</body></html>