<html><head></head><body>
		<div class="Content" id="_idContainer136">
			<p class="hidden">4</p>
		</div>
		<div class="Content" id="_idContainer137">
			<h1 id="_idParaDest-71"><a id="_idTextAnchor074"/>Creating a Chatbot with Natural Language</h1>
		</div>
		<div class="Content" id="_idContainer138">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will able to:</p>
			<ul>
				<li class="bullets">Define the basics of chatbots and chatbot design</li>
				<li class="bullets">Set up the Amazon Lex service</li>
				<li class="bullets">Create a custom chatbot to look up different share prices</li>
			</ul>
			<p>This chapter describes the designing of chatbot using Amazon Lex.</p>
		</div>
		<div class="Content" id="_idContainer189">
			<h2 id="_idParaDest-72"><a id="_idTextAnchor075"/>Introduction</h2>
			<p>In the last chapter, you learned how to extract and analyze common themes through topic modeling with <strong class="bold">Amazon Comprehend</strong>.</p>
			<p>In this chapter, you will learn how to build a chatbot using <strong class="bold">Amazon Lex</strong>. First, we'll talk about how to design a chatbot. Then, we will dive into exploring the Amazon Lex service by creating a sample chatbot. </p>
			<p>Next, we will create our own custom chatbot, which will query an for PIzza ordering. Finally, you will integrate, your chatbot with a text interface in order to interact with it.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor076"/>What is a Chatbot?</h2>
			<p>A <strong class="keyword">chatbot</strong> is an application that simulates intelligent conversations using rules and an AI inference. When interacting with the chatbot, the goal is to be able to hold a conversation with the user to the extent required in order to resolve customer queries or suggest a way to move forward from them. </p>
			<p>As in normal conversation, the means by which we interact with the Bot can be written text or speech. Often, the chatbots are integrated with messaging platforms, such as Slack, Facebook, Kik, WeChat, and so on. This can also be integrated with a custom web or mobile interface.</p>
			<p>It is easier, of course, to integrate within an existing messaging platform, since the user is likely to be familiar with the interface. Moreover, these platforms provide support to the chatbot developers with infrastructure and development tools.</p>
			<p>Some examples of chatbots include systems for ordering products, reporting, internal communication, and scheduling.</p>
			<h3 id="_idParaDest-74"><a id="_idTextAnchor077"/>The Business Case for Chatbots</h3>
			<p>Traditionally, we used to interact with computers by means of input devices, such as keyboards and mice. Today, computational power and efficiency has progressed to the point where we can have a conversation with a computer almost as naturally as interacting with other people. These conversations seem more human-like, due to the ability of the computer to add contextual information and keep track of and remember the context for a few separate interactions.</p>
			<p>It is no surprise, then, that the conversational interface is really catching on. One study by Gartner estimates that 30% of browsing done by users will turn out to be screen less in 2020. This is a huge number, considering all of the interactions between humans and computers.</p>
			<p>Another study done by BI Intelligence found that the number of global monthly active users for the top four messaging apps surpassed those for the top four social networks in the first quarter of 2015 and shows no signs of slowing down.</p>
			<p>Businesses cannot afford to ignore this trend, and are looking to reach users where they are found interacting (via text) the most: the messaging platforms such as Facebook, Skype, Slack, WhatsApp, and WeChat, and the list goes on and on. Messaging platforms make it easier for users to communicate, and chatbots make it easier for users to communicate what they want and to get it more quickly than interacting with other people.</p>
			<p>In this topic, you will learn about <strong class="bold">Natural Language Understanding</strong> <strong class="bold">(NLU)</strong>. Using this knowledge, you will first explore the AWS Lex service and build your first sample chatbot. As the next step, you will build a custom chatbot.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor078"/>What is Natural Language Understanding?</h2>
			<p>NLP is the general term for a set of technologies that deal with natural language. NLU is a focused subset of NLP that deals with actual conversational input. </p>
			<p>NLU is able to handle unstructured inputs and convert to a structured, machine understandable form. Words that the user enters are transformed into intents and entities, or Slots. The NLU chatbot is further able to infer intents and Slots from user input, which may be similar to – but not the same as – the examples it has been trained with.</p>
			<h3 id="_idParaDest-76"><a id="_idTextAnchor079"/>Core Concepts in a Nutshell</h3>
			<p>Before we can get started with building chatbots, you will need to understand some concepts first. We will now take a look at the technical meaning of the term chatbot and the names of the pieces which make up a chatbot and work together to deliver a conversational experience to the user.</p>
			<p><strong class="bold">Chatbot</strong></p>
			<p><a id="_idTextAnchor080"/>A chatbot, also known as a <strong class="inline">bot</strong>, is a piece of software that can converse using natural language with the user. The goal is for the user to believe that they can interact freely and naturally with the bot, almost as if speaking with another person.</p>
			<p><strong class="bold">Utterances</strong></p>
			<p>Things that the user says to the bot are called <strong class="bold">utterances</strong>. The bot regards the utterances from the user as input, and is able to parse them into machine-recognizable formats. Some examples of utterances are as follows:</p>
			<ul>
				<li>I'd like to see the dentist.</li>
				<li>Can you tell me what the weather is like today?</li>
			</ul>
			<p><strong class="bold">Intent</strong></p>
			<p>An <strong class="bold">intent</strong> represents an action that the user wants to perform, based on the content of their utterances. The bot infers the intent and supports it based on its internal set of business rules or application flow, with the result of either a change in its internal state or an action being performed. These also typically result in a response being provided to the user as feedback or information.</p>
			<p>So, from the preceding utterance examples, a bot might infer intents such as the following:</p>
			<ul>
				<li>I'd like to see the dentist =&gt; SeeDentist</li>
				<li>Can you tell me what the weather is like today? =&gt; GetWeather</li>
			</ul>
			<p>Inferring intent is a large part of what an NLU platform such as Lex does behind the scenes. A number of training examples, in the form of sentences that the user might provide,are fed to the platform, and a probabilistic model is built from these examples. This means that, in practice, the platform should be able to infer the correct intent from input which is similar to, but not necessarily a part of, the examples that the system was trained on.</p>
			<p><strong class="bold">Prompts</strong></p>
			<p>When the bot requires more information from the user or is unclear about an Intent, it can ask the user follow-up questions, in order to collect more data. These are called <strong class="bold">prompts</strong>. Prompts typically fill in Slot values that are required, although your application logic may attempt to fill in values which are optional as well if you desire.</p>
			<p><strong class="bold">Slot</strong></p>
			<p>A <strong class="keyword">Slot</strong> is a piece of information, or parameter, that is associated with an intent. The information can be provided within the initial user request, and Lex will be able to parse out the information and correctly assign it to the corresponding Slot correctly. If this information is not provided as a part of the request, then the bot should be able to prompt the user for the information separately. Slots may be optional or required.</p>
			<p>The type of information represented by a <strong class="bold">Slot</strong> is known as the Slot type. There are a number of built-in Slot types within Lex that represent common types of information, such as city or state. The following are a few examples of common Slot types that are built into Lex:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer139">
					<img alt="Figure 4.1: Table of Slot types built into Lex &#13;&#10;" src="image/IMG_29102018_171212_0.jpg"/>
				</div>
			</div>
			<h6>Figure 4.1: Table of Slot types built into Lex </h6>
			<p>Of course, this is just a very limited subset of examples. There are many more built-in types, as well as different types for different languages!</p>
			<h4>Note</h4>
			<p class="callout">You can refer to the following link to get a full list of built-in intents and Slots: <a href="">https://docs.aws.amazon.com/lex/latest/dg/howitworks-builtins.html</a> </p>
			<p>Most of the built-in intents and Slots are documented as part of the Alexa Skills Kit documentation, with some differences for Lex, which are documented at the preceding link. Make sure to keep the link bookmarked and refer to the page often, since Amazon keeps updating the service, and things may change.</p>
			<p>If the type of information that you would like your bot to handle is not represented by one of these built-in types, you can define your own, along with the actual values that the Slot is allowed to take. You will see how this works as part of our next  exercise.</p>
			<p><strong class="bold">Fulfillment</strong></p>
			<p>Note that the bot will not be able to proceed to the next step until it fills in all of the required Slot values! Naturally, this does not apply to Slot values that are optional.</p>
			<p>When all of the required Slots for an intent have been filled, Slot is then ready for fulfillment. At this stage, the bot is ready to execute the business logic required to fulfill the intent. Business logic may be any of the following actions:</p>
			<ul>
				<li>Change in internal state</li>
				<li>Running code internally</li>
				<li>Calling an internal or external service, to get information from it</li>
				<li>Calling an internal or external service to post information to it</li>
			</ul>
			<p>The fulfillment action can be performed with or without some feedback to the user, but as a matter of best practice, it is always better to err on the side of more feedback to the user, rather than less.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor081"/>Setting Up with Amazon Lex</h2>
			<h3 id="_idParaDest-78"><a id="_idTextAnchor082"/>Introduction</h3>
			<p>For this exercise, we will be creating a sample chatbot, which is an option provided with <strong class="bold">Amazon Lex</strong>. The goal here is to understand the various components of the sample chatbot and relate them to the previous topic, where you learned about Natural Language Understanding components. After this exercise, you should be able to navigate the Lex user interface and easily create intents, Slots, and Slot types easily for your next exercise, where you will build a custom chatbot based on your own business logic.</p>
			<h3 id="_idParaDest-79"><a id="_idTextAnchor083"/>Exercise 15: Creating a Sample Chatbot to Order Flowers</h3>
			<p>In this exercise, we will create and test the sample chatbot as a means to gain familiarity with the <strong class="bold">Amazon Lex</strong> console interface. The following are the steps for completion for creating a sample chatbot:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer140">
					<img alt="Figure 4.2: Sample chatbot interface&#13;&#10;" src="image/image0021.jpg"/>
				</div>
			</div>
			<h6>Figure 4.2: Sample chatbot interface</h6>
			<ol>
				<li>Let's first navigate to the <strong class="bold">Amazon Lex</strong> main screen. You can click on the Lex service link from the main AWS console screen or navigate directly to <a href="">https://console.aws.amazon.com/lex</a>.</li>
				<li>If this is your first time using Amazon Lex, you should see the following screen:<div class="IMG---Figure" id="_idContainer141"><img alt="Figure 4.3: Amazon Lex getting started screen&#13;&#10;" src="image/image0032.jpg"/></div><h6>Figure 4.3: Amazon Lex Getting Started screen</h6></li>
				<li>You can click on the <strong class="bold">Get Started</strong> button in order to proceed.<h4>Note</h4><p class="callout">In case you have already built a bot previously, you will be shown a different screen, where you can click on the <strong class="bold">Create</strong> button, instead:</p><div class="IMG---Figure" id="_idContainer142"><img alt="Figure 4.4: Bots create screen&#13;&#10;" src="image/image0041.jpg"/></div><h6>Figure 4.4: Bots create screen</h6></li>
				<li>You will then be presented a list of options for creating bots. This shows two options: <strong class="bold">CREATE YOUR OWN</strong> and <strong class="bold">TRY A SAMPLE</strong>.</li>
				<li>Now, choose the <strong class="bold">OrderFlowers</strong> option under the <strong class="bold">TRY A SAMPLE</strong> section:<div class="IMG---Figure" id="_idContainer143"><img alt="Figure 4.5: Selecting the Bot&#13;&#10;" src="image/image0052.jpg"/></div><h6>Figure 4.5: Selecting the bot</h6></li>
				<li>This will then present you with further options to be filled in. You can leave the bot name as the default, <strong class="inline">OrderFlowers</strong>, and select <strong class="bold">No</strong> for the <strong class="inline">COPPA</strong> option. You can leave the <strong class="inline">IAM </strong>role option as is. It will create a role automatically for the sample bot:<div class="IMG---Figure" id="_idContainer144"><img alt="Figure 4.6: IAM role and COPPA selection &#13;&#10;" src="image/image0061.jpg"/></div><h6>Figure 4.6: IAM role and COPPA selection </h6></li>
				<li>Click on the <strong class="bold">Create</strong> button to bring up the next screen and proceed to the next step.</li>
			</ol>
			<p><strong class="bold">Working with the Chatbot Editor</strong></p>
			<ol>
				<li value="1">On the <strong class="bold">Chatbot Editor</strong> screen, you can view the predefined <strong class="inline">Intents</strong>, <strong class="inline">Slots</strong>, <strong class="inline">Slot Types</strong>, and <strong class="inline">Sample utterances</strong>. You will see that there is a single <strong class="bold">Intent</strong>, named <strong class="inline">OrderFlowers</strong>:<div class="IMG---Figure" id="_idContainer145"><img alt="Figure 4.7: Chatbot editor screen&#13;&#10;" src="image/Image_Lesson4_007.jpg"/></div><h6>Figure 4.7: Chatbot editor screen</h6></li>
				<li>The sample utterances that are entered correspond to this Intent:<div class="IMG---Figure" id="_idContainer146"><img alt="Figure 4.8: Slots types screen&#13;&#10;" src="image/Image_Lesson4_008.jpg"/></div><h6>Figure 4.8: Slots types screen</h6></li>
				<li>There are also three Slots. Two of the Slots (<strong class="inline">PickupDate</strong> and <strong class="inline">PickupTime</strong>) take built-in types. The third one is a custom-defined Slot named <strong class="inline">FlowerType</strong>. Each Slot has a prompt associated with it, which is generated by the bot in order to get the information for the Slot.</li>
				<li>There is also a <strong class="inline">Slot type</strong> named <strong class="inline">FlowerTypes</strong>. These values are recognized for the <strong class="inline">FlowerType</strong> <strong class="inline">Slot</strong> when the user is prompted for the type of flower to be ordered:<div class="IMG---Figure" id="_idContainer147"><img alt="Figure 4.9: Slots types screen&#13;&#10;" src="image/Image_Lesson4_009.jpg"/></div><h6>Figure 4.9: Slots types screen</h6></li>
				<li>Click on the <strong class="inline">FlowerTypes</strong> link in order to bring up a dialog with the definitions of the Slot type and sample values. The following are the steps for selecting and editing the Slot type.<div class="IMG---Figure" id="_idContainer148"><img alt="Figure 4.10: Selection of flowers types&#13;&#10;" src="image/image0082.jpg"/></div><h6>Figure 4.10: Selecting FlowerTypes</h6><div class="IMG---Figure" id="_idContainer149"><img alt="Figure 4.11: Edit Slot type&#13;&#10;" src="image/image0092.jpg"/></div><h6>Figure 4.11: Edit Slot type</h6></li>
				<li>You can also click on the <strong class="bold">Error Handling</strong> link in the left area to show the prompts that the bot will show the user for clarification (<strong class="bold">Clarification Prompts</strong>) and the phrase used to terminate the interaction (<strong class="bold">Hang-up phrase</strong>) after the maximum number of retries has been attempted by the user:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer150">
					<img alt="Figure 4.12: Error handling" src="image/image0101.jpg"/>
				</div>
			</div>
			<h6>Figure 4.12: Error handling</h6>
			<p><strong class="bold">Testing the Chatbot</strong></p>
			<ol>
				<li value="1">You can test the chatbot in the Test bot area on the right-hand side of the screen. You may have to click on an arrow icon in order to expand it, if it is not already open:<div class="IMG---Figure" id="_idContainer151"><img alt="Figure 4.13: Test Bot screen&#13;&#10;" src="image/image0112.jpg"/></div><h6>Figure 4.13: Test bot screen</h6></li>
				<li>You can have a complete interaction, as shown in the following screenshots:<div class="IMG---Figure" id="_idContainer152"><img alt="Figure 4.14: Chatbot interaction screen&#13;&#10;" src="image/image0121.jpg"/></div><h6>Figure 4.14: Chatbot interaction screen</h6></li>
				<li>The following screenshot shows the conversation with the bot: <div class="IMG---Figure" id="_idContainer153"><img alt="Figure 4.15: Chatbot interaction screen&#13;&#10;" src="image/image0132.jpg"/></div><h6>Figure 4.15: Chatbot interaction screen</h6><p>When all the required <strong class="inline">Slots</strong> are filled, the <strong class="inline">intent</strong> is said to be ready for fulfillment. This means that all of the information required by the intent has been provided, and the application logic behind the chatbot can now handle the intent appropriately.</p></li>
				<li>Intent can be returned to the calling application in the form of a <strong class="inline">JSON</strong> object or a <strong class="inline">Lambda function</strong> that has been implemented in the <strong class="inline">AWS Lambda service.</strong> This can be called at this point, with the <strong class="inline">JSON</strong> information as a parameter passed to it. You will see how this works later:<div class="IMG---Figure" id="_idContainer154"><img alt="Figure 4.16: Summary view screen&#13;&#10;" src="image/image0141.jpg"/></div><h6>Figure 4.16: Summary view screen</h6></li>
				<li>As for the results displayed in the Dialog State pane, the first one shows a text representation of the state of the chatbot. This is the summary view which displays information such as the recognized intent, the Slot types, and the values that are now available from the Lex NLU system. </li>
				<li>The Dialog State is <strong class="inline">ReadyForFulfillment</strong>, which signifies that the intent is ready for fulfillment, as shown in the preceding screenshot:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer155">
					<img alt="Figure 4.17: dialogState&#13;&#10;" src="image/image0152.jpg"/>
				</div>
			</div>
			<h6>Figure 4.17: DialogState</h6>
			<p>In the detail view, the <strong class="inline">JSON</strong> object that would be returned to an application, which is interacting with the chatbot, is displayed. Using <strong class="inline">JSON</strong> is a structured way in which an application can retrieve information from and send information to the chatbot system in Lex. You can see that the information being provided here is the same as in the Summary view, except in the <strong class="inline">JSON</strong> format.</p>
			<h4>Note</h4>
			<p class="callout">The Lex JSON structure for intents, as well as formats for other resources, such as Slots and Slot types, are documented here: <a href="">https://docs.aws.amazon.com/lex/latest/dg/import-export-format.html</a>.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor084"/>Creating a Custom Chatbot</h2>
			<p>In this topic, we will create a custom chatbot to get stock market quotes, using <strong class="bold">Amazon Lex</strong>. The bot will listen to our utterances for a valid intent: <strong class="inline">GetQuote</strong>. This signals to the bot that we had, for example to get a stock market quote for a given stock ticker symbol, will reside in a Slot named <strong class="bold">ticker</strong>. The bot will then look up the quote for that ticker symbol from a freely available financial API named <strong class="bold">IEX</strong>, and will return the information to the user via a conversational response:</p>
			<h4>Note</h4>
			<p class="callout">A stock ticker symbol is the standard way in which stocks that are traded on an exchange, such as the New York Stock Exchange or NASDAQ are represented. A sequence of alphabetical letters represents the company's stock which is being traded.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer156">
					<img alt="" src="image/image0161.jpg"/>
				</div>
			</div>
			<h6>Figure 4.18: The chatbot's workflow</h6>
			<p>We can create a flowchart for this process, as shown in the following diagram. Let's go over it in some more detail:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer157">
					<img alt="Figure 4.19: Flowchart of the chatbot’s workflow&#13;&#10;" src="image/image0172.jpg"/>
				</div>
			</div>
			<h6>Figure 4.19: Flowchart of the chatbot's workflow</h6>
			<p><strong class="bold">Recognizing the Intent and Filling the Slot Value</strong></p>
			<p>As the first step, the bot waits for the user's input, in order to recognize a valid intent. When it extracts the <strong class="inline">GetQuote</strong> intent as the intent from an utterance posted by the user, it will then try to fill the required Slots. In our case, we have only one Slot of the <strong class="inline">StockTicker</strong> type (which is a custom Slot type). The bot will issue a prompt, asking the user to provide the value of the Slot and parse the utterance in response, in order to fill the Slot value.</p>
			<p>Valid Slots are those that the system recognizes. If the Slot value is not part of the list of allowed values, or if the system does not recognize what is entered for the Slot value, it is said to be <strong class="inline">invalid</strong>, or <strong class="inline">not valid</strong>.</p>
			<p>If the Slot value is not valid, it will go back to trying to fill the Slot (at least up to the number of times we have specified it should try before giving up and going back to the beginning). Once the bot has a Slot filled with a valid value, it then proceeds to fulfill the intent.</p>
			<p><strong class="bold">Fulfilling the Intent with a Lambda Function</strong></p>
			<p>While the default fulfilment action is to return the intent and Slot value to the user so that he/she can proceed to work with it within his/her own application, we will instead choose to set up a Lambda function on AWS, which can handle the intent and run the business logic required to fulfil it.</p>
			<p>At this point, the bot process running within Lex proceeds to call the Lambda function, which we have written and specified for fulfilment. </p>
			<p><strong class="inline">Lambda_function.Lambda_handler</strong></p>
			<p>When Lex calls out to the function for fulfilment, it sends a <strong class="inline">JSON</strong> payload containing various pieces of information about the sender, as well as the intent and Slot value. The <strong class="inline">Lambda_handler()</strong> method parses the intent and Slot parameter value from the <strong class="inline">JSON</strong>, and then dispatches another function call to the method, which gets the market quote value that we're looking for from the external API.</p>
			<p>Finally, the <strong class="inline">Lambda function</strong> also packages the response as another <strong class="inline">JSON</strong> string and returns it back to Lex. Lex parses the <strong class="inline">JSON</strong> response behind the scenes and presents the response message to the user.</p>
			<p>We will go through all of these elements in a lot more depth in the next two activities. In the first activity, we will set up the new chatbot, and in the second one, we will implement our Lambda handler function to return the actual value of the market price of the ticker symbol that the user asks the bot for back to him or her.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor085"/>A Bot Recognizing an Intent and Filling a Slot</h2>
			<p>In the next exercise, you will create a custom chatbot which recognizes the intent, named <strong class="inline">GetQuote,</strong> to get a market price quote for a given ticker symbol. The bot will prompt the user for the value of the ticker symbol which the user is interested in, until the Slot is filled. You will also learn how to state the intent and fill the Slot in the same utterance. The chatbot can be tested via a conversational interface.</p>
			<h3 id="_idParaDest-82"><a id="_idTextAnchor086"/>Exercise 16: Creating a Bot that will Recognize an Intent and Fill a Slot </h3>
			<p>In this exercise, we will create and test an Amazon Lex-based bot with a custom <strong class="inline">intent</strong> and <strong class="inline">Slot</strong>. The following are the steps for creating a bot with a custom intent and Slot:</p>
			<ol>
				<li value="1">The first step is to navigate to the <strong class="inline">Amazon Lex service</strong> within the <strong class="inline">AWS console</strong>, by clicking on the appropriate links within the AWS console, or navigating to <a href="">https://console.aws.amazon.com/lex</a>.</li>
				<li>The next step is to click on the <strong class="bold">Get Started</strong> button, in order to get to the <strong class="keyword">bot</strong> creation screen:<div class="IMG---Figure" id="_idContainer158"><img alt="Figure 4.20: Getting Started screen&#13;&#10;" src="image/image0181.jpg"/></div><h6>Figure 4.20: Getting Started screen</h6></li>
				<li>At this point, you can create a Custom bot by clicking on the <strong class="bold">Custom bot</strong> option button. This reveals the bot's details, which can be filled out, as shown in the following screenshot:<div class="IMG---Figure" id="_idContainer159"><img alt="Figure 4.21: Custom Bot option&#13;&#10;" src="image/image0192.jpg"/></div><h6>Figure 4.21: Custom bot option</h6></li>
				<li>The <strong class="keyword">bot</strong> name field can be set to <strong class="inline">MarketNanny</strong>. The Output voice field is set to <strong class="inline">None. This is only a text based application</strong>. This is because we will be interacting with the bot only with text in this section, and not with voice just yet.</li>
				<li>The session timeout can be set to the default of 5 min. The IAM role field displays the name of the IAM role, which is automatically created by Lex for use by bot applications.</li>
				<li>Finally, the <strong class="inline">COPPA</strong> field pertains to the <strong class="bold">Children's Online Privacy Protection Act</strong>, to which online applications must conform. Assuming that no children under 13 are present in the class, you can click on <strong class="bold">No</strong>. If, however, you are a student under 13 or intend to have someone under 13 use your chatbot, then you should click on the <strong class="bold">Yes</strong> option, instead.<h4>Note</h4><p class="callout">A law was passed in 1998 to protect the privacy of children under 13. It states that online sites may not collect personal information from users younger than 13 years old without parental consent, among other provisions. You can learn more about the COPPA act at <a href="">https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule</a>.</p></li>
				<li>Finally, clicking on the <strong class="bold">Create</strong> button will create the chatbot and bring you to the bot Editor screen. This screen will allow you to create and define an Intent for the bot, as well as a <strong class="inline">Slot</strong> with a custom <strong class="inline">Slot type</strong>.</li>
				<li>Click on the <strong class="bold">Create Intent</strong> button to bring up an <strong class="bold">Add</strong> Intent pop-up dialog window:<div class="IMG---Figure" id="_idContainer160"><img alt="Figure 4.22: MarketNanny Bot Editor&#13;&#10;" src="image/image0201.jpg"/></div><h6>Figure 4.22: MarketNanny bot Editor</h6></li>
				<li>Conversely, if you already have an intent defined, you can create a new one by clicking on the <strong class="bold">+</strong> sign next to the Intents heading in the left-hand side column on the screen.</li>
				<li>The Create <strong class="bold">Intent window</strong> offers a few options to add an intent to the bot. The Import intent link allows for importing an intent from a <strong class="inline">ZIP</strong> file containing one or more <strong class="inline">JSON</strong> files with intents in the Lex format.</li>
				<li>The search for existing intents allows you to reuse the intents that you may have defined or imported previously, as well as the built-in intents defined by <strong class="bold">Amazon Lex</strong>.</li>
				<li>You should just click on the <strong class="bold">Create</strong> intent link, however, to get to the following dialog box.</li>
				<li>In the <strong class="bold">Create</strong> intent dialog box, name your new intent <strong class="inline">GetQuote</strong>. The bot will recognize this intent when you let it know that you are interested in a market quote. Click on the <strong class="bold">Add </strong>button to complete this step:<div class="IMG---Figure" id="_idContainer161"><img alt="Figure 4.23: Create intent screen&#13;&#10;" src="image/image0212.jpg"/></div><h6>Figure 4.23: Create intent screen</h6></li>
				<li>You should be back at the Editor screen at this point, and you should see the <strong class="inline">GetQuote</strong> intent in the left toolbar portion of the screen. The Editor screen also contains a number of fields that are used to define and customize the new intent.</li>
				<li>The first thing to do is fill in some Sample utterances to train the <strong class="keyword">NLU</strong> system behind Lex to recognize the utterances you will provide to the bot as signaling the <strong class="inline">GetQuote</strong> intent:<div class="IMG---Figure" id="_idContainer162"><img alt="Figure 4.24: Creation of the Intent&#13;&#10;" src="image/image0221.jpg"/></div><h6>Figure 4.24: Creation of the Intent</h6></li>
				<li>After entering some sample utterances, you click on the <strong class="bold">Build</strong> button near the top of the page, in order to kick off the training process for the bot:<div class="IMG---Figure" id="_idContainer163"><img alt="Figure 4.25: Building the Bot&#13;&#10;" src="image/image0232.jpg"/></div><h6>Figure 4.25: Building the bot</h6></li>
				<li>There will be a follow-up dialog box with another <strong class="bold">Build</strong> button, which you should also click:<div class="IMG---Figure" id="_idContainer164"><img alt="Figure 4.26: Build confirmation &#13;&#10;" src="image/image0241.jpg"/></div><h6>Figure 4.26: Build confirmation </h6></li>
				<li>After this, you should wait until you see the successful build dialog, which might take a few seconds to a couple of minutes:<div class="IMG---Figure" id="_idContainer165"><img alt="Figure 4.27: Bot build is successful&#13;&#10;" src="image/image0252.jpg"/></div><h6>Figure 4.27: Bot build is successful</h6></li>
				<li>You can test your new intent within the bot in the <strong class="inline">Test bot</strong> pane, in the upper right-hand corner of the screen. <h4>Note</h4><p class="callout">If the Test bot pane is not visible, you may have to click on an arrow button in order to expand it and make it visible.</p></li>
				<li>Type utterances into the pane to verify that the bot is able to recognize the correct intent from the utterances:<div class="IMG---Figure" id="_idContainer166"><img alt="Figure 4.28: Test Bot &#13;&#10;" src="image/image026.jpg"/></div><h6>Figure 4.28: Test bot </h6></li>
				<li>You know that it has recognized the intent correctly when it returns the response: Intent <strong class="inline">GetQuote</strong> is <strong class="inline">ReadyForFulfillment</strong>. Feel free to experiment with different utterances, based on your sample utterances, in order to verify that the <strong class="keyword">NLU</strong> engine is working correctly.</li>
			</ol>
			<p>At this point, your bot does not do much, other than try to recognize the <strong class="inline">GetQuote</strong> intent and flag that it is ready for fulfillment. This is because we have not added any <strong class="inline">Slots</strong> to the <strong class="inline">intent</strong>.</p>
			<p><strong class="bold">Slot Addition</strong></p>
			<ol>
				<li value="1">Your next step will be to add a Slot, along with a custom Slot type for the Slot:<div class="IMG---Figure" id="_idContainer167"><img alt="Figure 4.29: Adding a Slot&#13;&#10;" src="image/image0273.jpg"/></div><h6>Figure 4.29: Adding a Slot</h6></li>
				<li>Add a <strong class="inline">Slot type</strong>. This can be done by pressing the <strong class="bold">+</strong> button next to Slot types in the left toolbar section of the Editor screen. This brings up an <strong class="bold">Add Slot type </strong>dialog box, where we can also choose to Import the Slot type as before with intents by using the Lex <strong class="inline">JSON</strong> structure. However, before, we will click on the <strong class="bold">Create</strong> Slot type link to create a <strong class="inline">new Slot</strong> type:<div class="IMG---Figure" id="_idContainer168"><img alt="Figure 4.30: Create Slot type" src="image/image0281.jpg"/></div><h6>Figure 4.30: Creating Slot type </h6></li>
				<li>In the <strong class="bold">Add</strong> <strong class="bold">Slot type</strong> dialog box that pops up, enter the Slot type name as <strong class="bold">StockTicker</strong>. This is the name of the Slot type that we are defining. Optionally, you can enter a description in the <strong class="inline">Description</strong> field and leave the <strong class="bold">Slot Resolution</strong> option as <strong class="inline">Expand Values</strong>.</li>
				<li>Under the <strong class="bold">Value</strong> field, enter a few <strong class="bold">stock ticker</strong> symbols, as shown in the following screenshot, to provide sample values for the <strong class="inline">StockTicker</strong> Slot type. You can add some of your own, as well, if you wish:<div class="IMG---Figure" id="_idContainer169"><img alt="Figure 4.31: Adding a Slot type" src="image/image0292.jpg"/></div><h6>Figure 4.31: Adding a Slot type</h6></li>
				<li>Finally, click on the <strong class="bold">Add</strong> Slot to intent button, in order to add the Slot type to the intent, and close the dialog.</li>
				<li>We could have also clicked on the <strong class="bold">Save</strong> Slot type button and added the Slot to the intent in a separate step, but using the button is the shortcut to accomplishing both actions in a single step.</li>
				<li>When you close the dialog box, you will find that Lex has added a new Slot entry, as well, under the Slots section. It is helpfully prefilled with the <strong class="inline">StockTicker</strong> Slot type, and you should change the name of the Slot to ticker, under the <strong class="bold">Name</strong> field for the entry. </li>
				<li>Click on the wheel under the <strong class="bold">Prompt</strong> field to expand it to a new dialog box:<div class="IMG---Figure" id="_idContainer170"><img alt="Figure 4.32: Editor dialog box" src="image/image0301.jpg"/></div><h6>Figure 4.32: Editor dialog box</h6></li>
				<li>The prompts editor dialog box (named ticker Prompts) allows entry of prompts for the <strong class="inline">Slot</strong>, which the bot will use to store the user <strong class="inline">inputs</strong> and corresponding sample <strong class="inline">utterances</strong> that the user would typically provide to the bot while the bot is trying to elicit the information from the user with the prompts.</li>
				<li>The placement of the Slot value within the corresponding utterances for the Slots is denoted by curly braces <strong class="inline">{}</strong> and the name of the Slot within the braces. In this case, since the Slot is named ticker, it is denoted by <strong class="inline">{ticker}</strong> within the sample utterances.</li>
				<li>Fill in the prompts (a single prompt is fine – if you add more prompts, the bot will use them randomly, for variety) in the Prompts section. </li>
				<li>Then, add some <strong class="inline">utterances</strong> to the Corresponding utterances section, denoting the placement of the Slot value, using the placeholder token <strong class="inline">{ticker}</strong> in each sample statement.</li>
				<li>Leave the Maximum number of retries field as the default value of two. This means that it will try to get the value for the Slot twice before signaling an <strong class="inline">error</strong>:<div class="IMG---Figure" id="_idContainer171"><img alt="Figure 4.33: Ticker prompt screen" src="image/image0312.jpg"/></div><h6>Figure 4.33: Ticker prompt screen</h6></li>
				<li>Finally, click on the <strong class="bold">Save</strong> button to save the Slot prompts and the corresponding utterances definitions.</li>
				<li>Finally, click on the <strong class="bold">Save</strong> Intent button at the bottom of the screen, then the <strong class="bold">Build</strong> button at the top of the screen, in order to kick off the training process with the new Slot and Slot type that we have defined, and wait for the completion dialog to display when the training is done:<div class="IMG---Figure" id="_idContainer172"><img alt="Figure 4.34: Saving the Intent" src="image/image0321.jpg"/></div><h6>Figure 4.34: Saving the Intent</h6></li>
				<li>Your updated intent is now ready to test in the <strong class="bold">Test bot </strong>pane:<div class="IMG---Figure" id="_idContainer173"><img alt="Figure 4.35: Updated intent test bot" src="image/image0332.jpg"/></div><h6>Figure 4.35: Updated intent test bot</h6></li>
				<li>At the end of the bot flow, when all of the information it requires is filled, it returns the intent in the same format as before. However, it follows this response line with another line, containing the name and value of the Slot parameter:<p class="snippet">ticker:GOOG</p></li>
				<li>This indicates that the ticker Slot has been filled with the value <strong class="inline">GOOG</strong>. So, that's great; our intent with Slot is working!</li>
				<li>While you're having fun playing around with the bot to verify that the intent and Slot are working as they should, why not try something a little bit different: enter some utterances that are not a part of the sample utterances that you previously entered to train the bot.</li>
				<li>Type <strong class="keyword">Can I get a market quote?</strong> as your initial utterance, and see if the bot can recognize the intent. Bear in mind that the sentence, though similar to the sample utterances, is not one of those utterances:<div class="IMG---Figure" id="_idContainer174"><img alt="Figure 4.36: Test bot screen" src="image/image0341.jpg"/></div><h6>Figure 4.36: Test bot screen</h6></li>
				<li>As you can see from the testing shown in the preceding screenshot, not only does Lex recognize the correct intent from an utterance it has not been trained on, but it also recognizes a new symbol which it has not seen before (ADP) correctly as the value for the ticker Slot.</li>
				<li>Now, let's try a conversational form of a corresponding utterance for the Slot prompt by inserting a random interjection as a part of the sentence, again using a new ticker symbol (<strong class="bold">VZ</strong>) that the bot has not previously trained on. Again, it is correctly processed and recognized:<div class="IMG---Figure" id="_idContainer175"><img alt="Figure 4.37: Test bot screen" src="image/image0352.jpg"/></div><h6>Figure 4.37: Test bot screen</h6></li>
				<li>Clearly, there is quite a bit of flexibility possible between training and real-world examples of conversational input with an NLU engine.</li>
			</ol>
			<h3 id="_idParaDest-83"><a id="_idTextAnchor087"/>Natural Language Understanding Engine</h3>
			<p>NLU demonstrates the advantage of using an NLU engine that has been trained on a huge set of conversational sentences and has formed a large inference model.</p>
			<p>It is able to connect sentences that are not the same as the ones it has specifically been trained on. In fact, they can be significantly different, but the model is large enough to infer that the semantic meanings are similar.</p>
			<p>There is one more trick that you can use to make it easier for the user to interact with your bot. You can fill the Slot value in the same utterance as the one which establishes intent. This can be accomplished by simply including the Slot placeholder token (<strong class="inline">{ticker}, </strong>in this case) in your sample utterances:</p>
			<ol>
				<li value="1">Add a new sample utterance to your <strong class="inline">GetQuote</strong> intent, as follows:<div class="IMG---Figure" id="_idContainer176"><img alt="Figure 4.38: GetQuote screen" src="image/image0361.jpg"/></div><h6>Figure 4.38: GetQuote screen</h6></li>
				<li>The <strong class="bold">ticker</strong> placeholder token denotes that that Slot may be filled directly within the initial utterance, and, in that case, a prompt doesn't need to be generated:<div class="IMG---Figure" id="_idContainer177"><img alt="Figure 4.39: Build screen for the bot" src="image/image0371.jpg"/></div><h6>Figure 4.39: Build screen for the bot</h6></li>
				<li>Click on the <strong class="bold">Build</strong> buttons to train your updated intent as before, and then test it in the Test bot pane, as follows:<div class="IMG---Figure" id="_idContainer178"><img alt="Figure 4.40: Test bot screen" src="image/image038.jpg"/></div><h6>Figure 4.40: Test bot screen</h6></li>
				<li>You can see that the intent is ready for fulfillment and that the Slot value is filled appropriately, in a single step.</li>
			</ol>
			<p>We have now gone through the process of defining a custom chatbot, complete with a custom intent, Slot type, and Slot, within Amazon Lex. Furthermore, we have trained and tested the bot to verify that it is able to classify the correct intent and correctly infer the Slot values from conversational input, to a high degree of accuracy. Finally, we added a shortcut method to fill in the Slot value directly in the initial utterance, by inserting the placeholder token for the Slot value in the sample utterance to train the NLU engine behind Lex.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor088"/>Lambda Function – Implementation of Business Logic</h2>
			<p>You can create AWS Lambda functions, so that you can run your code for your Amazon Lex bot. You can recongnize Lambda functions to boot up and validating the fulfillment, in your intent configuration. Without a Lambda function, your bot returns the intent information to the client application for fulfillment.</p>
			<p>In the next exercise, you will learn how to implement the business logic behind the bot as a Lambda function in AWS and call a real-world REST API to get information to return to the user from an external service.</p>
			<h3 id="_idParaDest-85"><a id="_idTextAnchor089"/>Exercise 17: Creating a Lambda Function to Handle Chatbot Fulfillment</h3>
			<p>In this exercise, we will handle chatbot fulfillment business logic with a <strong class="inline">Lambda function</strong> that is created and deployed on AWS. In the last exercise, we created a chatbot with a <strong class="inline">GetQuote</strong> intent and ticker Slot. In this exercise, we will implement the fulfillment business logic. The following are the steps for implementing business logic:</p>
			<ol>
				<li value="1">Navigate to the AWS Lambda screen via the AWS Console, or by navigating directly to: <a href="">https://console.aws.amazon.com/Lambda</a>.</li>
				<li>If you have never used Lambda before, you should be presented with a Welcome screen:<div class="IMG---Figure" id="_idContainer179"><img alt="Figure 4.41: AWS Lambda start up screen&#13;&#10;" src="image/image0391.jpg"/></div><h6>Figure 4.41: AWS Lambda start up screen</h6></li>
				<li>Click on the <strong class="bold">Create</strong> a function button, in order to get started.</li>
				<li>Select the <strong class="bold">Author from scratch</strong> option on the next page:<div class="IMG---Figure" id="_idContainer180"><img alt="Figure 4.42: Selecting an author&#13;&#10;" src="image/image040.jpg"/></div><h6>Figure 4.42: Selecting an author</h6></li>
				<li>For the runtime, choose <strong class="inline">Python 3.6</strong> from the drop-down menu as you will be implementing the handler in the Python language for this exercise. In the Name field, fill in <strong class="inline">marketNannyHandler</strong>:<div class="IMG---Figure" id="_idContainer181"><img alt="Figure 4.43: Filling in the values&#13;&#10;" src="image/image0411.jpg"/></div><h6>Figure 4.43: Filling in the values</h6></li>
				<li>For the Role field, choose <strong class="bold">Create</strong> new role from template(s) from the drop-down menu:<div class="IMG---Figure" id="_idContainer182"><img alt="Figure 4.44: Role selection screen" src="image/image042.jpg"/></div><h6>Figure 4.44: Role selection screen</h6></li>
				<li>Enter the name <strong class="inline">marketNannyProcessorRole</strong> in the Role name field. Then, click on the <strong class="bold">Create function</strong> button to create the Lambda function in AWS. You should see a confirmation screen, as follows:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer183">
					<img alt="Figure 4.45: Confirmation screen&#13;&#10;" src="image/image0431.jpg"/>
				</div>
			</div>
			<h6>Figure 4.45: Confirmation screen</h6>
			<h3 id="_idParaDest-86"><a id="_idTextAnchor090"/>Implementing the Lambda Function</h3>
			<p>Here, you will use the Lambda Function editor entirely in-line, which means that you can enter and modify the code directly, without having to upload any files to AWS. The code that you enter will be executed when the Lambda function is invoked:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer184">
					<img alt="Figure 4.46: Function code screen" src="image/image044.jpg"/>
				</div>
			</div>
			<h6>Figure 4.46: Function code screen</h6>
			<p>First, let's look at the structure of the Lambda function.</p>
			<p>When you created the function named <strong class="inline">marketNannyHandler</strong>, AWS created a folder with the same name, with a Python file named <strong class="inline">Lambda_function.py</strong> within the folder. This file contains a stub for the <strong class="inline">Lambda_handler</strong> function, which is the entry point of our Lambda function. The entry point takes two parameters as arguments:</p>
			<ul>
				<li>The event argument provides the value of the payload that is sent to the function from the calling process. It typically takes the form of a Python <strong class="inline">dict</strong> type, although it could also be one of <strong class="inline">list</strong>, <strong class="inline">str</strong>, <strong class="inline">int</strong>, <strong class="inline">float</strong>, or <strong class="inline">NoneType</strong>.</li>
				<li>The context argument is of the type <strong class="inline">LambdaContext </strong>and contains runtime information. You will not be using this parameter for this exercise.</li>
			</ul>
			<p>The return value of the function can be of any type that is serializable by <strong class="inline">JSON</strong>. This value gets returned to the calling application after serializing.</p>
			<h3 id="_idParaDest-87"><a id="_idTextAnchor091"/>Input Parameter Structure</h3>
			<p>Now, let's take a closer look at the structure of the event argument, which gets passed to the <strong class="inline">Lambda_handler function</strong>. If we are asking for a market quote with the ticker value <strong class="inline">GOOG</strong>, the <strong class="inline">JSON</strong> value of the intent section within the parameter will look as follows:</p>
			<p class="snippet">{</p>
			<p class="snippet">     …</p>
			<p class="snippet">    "currentIntent": </p>
			<p class="snippet">    {</p>
			<p class="snippet">        "name": "GetQuote", </p>
			<p class="snippet">        "Slots": </p>
			<p class="snippet">        {</p>
			<p class="snippet">            "ticker": "GOOG"</p>
			<p class="snippet">        },</p>
			<p class="snippet">     …</p>
			<p class="snippet">}</p>
			<p>The relevant values which we are interested in for processing are <strong class="inline">name</strong> and the single <strong class="inline">ticker</strong> value within the <strong class="inline">Slots</strong> section under <strong class="inline">currentIntent</strong>.</p>
			<p>Since our <strong class="inline">JSON</strong> input gets converted into a Python dictionary, we can obtain these values within the Lambda function simply, as follows:</p>
			<p class="snippet">event['currentIntent']['name']</p>
			<p class="snippet">event['currentIntent']['Slots']['ticker']</p>
			<h3 id="_idParaDest-88"><a id="_idTextAnchor092"/>Implementing the High-Level Handler Function</h3>
			<p>The first step in implementing our handler is identifying the intent name and calling the corresponding function that implements it. This code looks as follows:</p>
			<p class="snippet">def get_quote(request):<br/>    return "Quote handling logic goes here."</p>
			<p class="snippet">def Lambda_handler(event, context):<br/>    intent = event['currentIntent']['name']<br/>    if intent == 'GetQuote':<br/>        return get_quote(event)<br/>    return "Sorry, I'm not sure what you have in mind.  Please try again."</p>
			<p>This is complete enough to actually be tested against your chatbot at this point, if you so desire, but let's press on with the implementation. </p>
			<h3 id="_idParaDest-89"><a id="_idTextAnchor093"/>Implementing the Function to Retrieve the Market Quote</h3>
			<p>The next step will be to implement the <strong class="inline">get_quote</strong> function, which does the work of actually getting the market quote information and returning it to the calling handler function:</p>
			<p class="snippet">def get_quote(request):</p>
			<p class="snippet">    Slots = request['currentIntent']['Slots']</p>
			<p class="snippet">    ticker = Slots['ticker']</p>
			<p class="snippet">    price = call_quote_api(ticker)</p>
			<p>Note that we have named the parameter as request, so the event <strong class="inline">object</strong> that we send the function to is referred to as a request within this function. It contains the same value and structure, just renamed. Therefore, we can get the value of the ticker Slot, as mentioned previously, by getting the value of the item with the <strong class="inline">ticker</strong> key under by using the following code:</p>
			<p class="snippet">request['currentIntent']['Slots']</p>
			<p>We then call the <strong class="inline">call_quote_api()</strong> function to retrieve the value of the market quote for the value of the ticker item. We haven't implemented <strong class="inline">call_quote_api()</strong> yet, so let's do this next.</p>
			<p>We will implement the <strong class="inline">call_quote_api</strong> function, as follows:</p>
			<p class="snippet">import json</p>
			<p class="snippet">from urllib.request import urlopen</p>
			<p class="snippet">def call_quote_api(ticker):</p>
			<p class="snippet">    response = urlopen('https://api.iextrading.com/1.0/stock/{}/delayed-quote'.format(ticker))</p>
			<p class="snippet">    response = json.load(response)</p>
			<p class="snippet">    return response['delayedPrice']</p>
			<p>Where ticker is the value of the ticker parameter (in this specific example, it would be <strong class="inline">GOOG</strong>). We use the IEX API, which provides a static endpoint on the internet at <a href="">https://api.iextrading.com</a>, to retrieve a delayed quote, using the 1.0 version of their REST API.</p>
			<p>Since it is implemented as a simple <strong class="inline">GET</strong> request, with the ticker parameter embedded within the <strong class="inline">URL</strong>, and no other special header values such as the API key or user information, we can simply use the built-in <strong class="inline">urlopen</strong> method in the <strong class="inline">urllib.request</strong> module (which we will have to remember to import) to receive a response from the URL with the ticker embedded within it.</p>
			<p>Since the response is also in the <strong class="inline">JSON</strong> format, we need to import the <strong class="inline">json module</strong> and load the response using the <strong class="inline">json.load function</strong>. The only field we are interested in within the response is <strong class="inline">delayedPrice</strong>, so we return that as the return value from our function.</p>
			<h3 id="_idParaDest-90"><a id="_idTextAnchor094"/>Returning the Information to the Calling App (The Chatbot)</h3>
			<p>Now that we have the market quote value, we can return it to our calling application, which is the chatbot that we implemented. We have to do a couple of small things, however, to return this value. First, we need to format it as a conversational response, as in the following string:</p>
			<p class="snippet">message = 'The last price (delayed) of ticker {} was {}'.format(ticker, price)</p>
			<p>This should let the chatbot display the following message:</p>
			<p class="snippet">The last price (delayed) of ticker GOOG was 1107.32</p>
			<p>There is one final step, which is to construct an <strong class="bold">Amazon Lex</strong> <strong class="inline">JSON</strong> return format, containing our message and a couple of other items of information. We will use the helper function close to do this:</p>
			<p class="snippet">return close(message)</p>
			<p>Our close function takes a single parameter, which is the string that we wish to return to the chatbot (in this case, this is the value of the message variable). It generates a <strong class="inline">JSON</strong> wrapper around the content, which conforms to the structure, which our Lex-based bot is expecting and from which it can extract the content and deliver it to the user. The structure of the wrapper is not important at this stage, but if you are curious, you can look at the implementation of the close function.</p>
			<h3 id="_idParaDest-91"><a id="_idTextAnchor095"/>Connecting to the Chatbot</h3>
			<p>At this point, the only task remaining is to connect the Lambda function to the chatbot and test it:</p>
			<ol>
				<li value="1">To do so navigate back to the Amazon Lex dashboard and select the <strong class="inline">MarketNanny</strong> bot:<div class="IMG---Figure" id="_idContainer185"><img alt="Figure 4.47: Connecting to the bot " src="image/image0451.jpg"/></div><h6>Figure 4.47: Connecting to the bot </h6></li>
				<li>Then, scroll down to the Fulfillment section and select the AWS Lambda function option. Next, select the <strong class="inline">marketNannyHandler</strong> function from the Lambda function drop-down menu and leave Version or alias as the default value of <strong class="bold">Latest</strong>:<div class="IMG---Figure" id="_idContainer186"><img alt="Figure 4.48: Confirmation prompt" src="image/image046.jpg"/></div><h6>Figure 4.48: Confirmation prompt</h6></li>
				<li>Rebuild the intent by clicking on the <strong class="bold">Build</strong> buttons, and test the chatbot together with the Lambda handler in the Test Chatbot pane:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer187">
					<img alt="Figure 4.49: Chatbot updated" src="image/image0471.jpg"/>
				</div>
			</div>
			<h6>Figure 4.49: Chatbot updated</h6>
			<p>The following screenshot shows the interaction with bot for knowing the current price of AAPL:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer188">
					<img alt="Figure 4.50: Chatbot updated" src="image/image048.jpg"/>
				</div>
			</div>
			<h6>Figure 4.50: Chatbot updated</h6>
			<h3 id="_idParaDest-92"><a id="_idTextAnchor096"/>Activity 5: Creating a Custom Bot and Configuring the Bot</h3>
			<p>In this activity, we will create a custom bot for<a id="_idTextAnchor097"/> <strong class="inline">PizzaOrdering</strong>. A bot performs the automated task of ordering a pizza. An Amazon Lex bot is powered by <strong class="bold">Automatic Speech Recognition</strong> (<strong class="bold">ASR</strong>) and <strong class="bold">Natural Language Understanding</strong> (<strong class="bold">NLU</strong>) capabilities, the same technology that powers <strong class="bold">Amazon Alexa</strong>. For this, we will consider the following example: suppose that a user wants to order a pizza; a user might say, <strong class="bold">Can I order a pizza, please?</strong> or, <strong class="bold">I want to order a pizza</strong>. You can configure the intent so that Amazon Lex simply returns the information back to the client application, to perform the necessary fulfillment. To ensure that it happens correctly, you will need to navigate to the Amazon Lex services to create the custom bot:</p>
			<ol>
				<li value="1">Create a custom bot for <strong class="inline">Pizza Ordering</strong>.</li>
				<li>Create an Intent.</li>
				<li>Create a Slot type.</li>
				<li>Configure the Intent.</li>
				<li>Configure the bot.<h4>Note</h4><p class="callout">To refer to the detailed steps, go to the <em class="italics">Appendix A</em> at the end of this book on Page no. 217</p></li>
			</ol>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/>Summary</h2>
			<p>In this chapter, you learned about the basic chatbots and chatbot design. You also learned how to set up the Amazon Lex services, and  how to create a sample chatbot. Next, we looked at the Chatbot workflow. We then looked upon the flowchart of a Chatbot's workflow. Finally, we dove into creating a custom chatbot that shows share prices.</p>
			<p>In the next chapter, we will look at how to use speech with chatbots.</p>
		</div>
	</body></html>