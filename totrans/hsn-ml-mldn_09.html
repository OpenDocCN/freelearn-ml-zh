<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Matrix Factorization Model</h1>
                </header>
            
            <article>
                
<p>With<span> </span>anomaly detection models behind us, it is now time to dive into matrix factorization models. Matrix factorization is one of the newer additions to ML.NET, with a transform of the same name. In this chapter, we will dive into matrix factorization, as well as the various applications best suited to utilizing matrix factorization. In addition, we will build a new sample application to predict music recommendations based on the sample training data. Finally, we will explore how to evaluate a matrix factorization model with the properties that ML.NET exposes.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Breaking down matrix factorizations</li>
<li>Creating a matrix factorization application</li>
<li><span>Evaluating a matrix factorization</span><span> </span><span>model</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking down matrix factorizations</h1>
                </header>
            
            <article>
                
<p>As<span> </span>mentioned in<span> </span><a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">Chapter 1</a>, <em>Getting Started with Machine Learning and ML.NET</em>,<span> </span>matrix factorization, by definition, is an unsupervised learning algorithm. This means that the algorithm will train on data and build a matrix of patterns in user ratings, and during a prediction call, will attempt to find like ratings based on the data provided. In this section, we will dive into use cases for matrix factorization and have a look into the matrix factorization trainer in ML.NET.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use cases for matrix factorizations</h1>
                </header>
            
            <article>
                
<p>Matrix factorizations, as you might be starting to realize, have numerous applications where data is available, but the idea is to suggest other matches based on previously unselected data. Without needing to do manual spot-checking, matrix factorization algorithms train on this unselected data and determine patterns using a key-value pair combination. ML.NET provides various matrix factorization values to look at<span> </span>programmatically, inside of your application. We will review these values later<span> </span>on in this chapter, to better ensure the recommendation was not a false positive.</p>
<p>Some of the potential applications best suited for matrix factorization are:</p>
<ul>
<li>Music recommendations</li>
<li>Product recommendations</li>
<li>Movie recommendations</li>
<li>Book recommendations</li>
</ul>
<p>Effectively, anything where data can be traced back to a single user and then built upon as more data is entered can utilize matrix factorizations. This problem is called a <strong>cold start</strong> <strong>problem</strong>. Take, for instance, a new music platform geared toward helping you to find new bands to listen to. When you first reach the site and create a profile, there is no prior data available. You, as the end user, must tell the system what you like and don't like. <span>Due to the nature of the algorithm, matrix factorization is better suited to this application than the straight regression or binary classification algorithms we explored in </span>earlier chapters. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the matrix factorization trainer</h1>
                </header>
            
            <article>
                
<p>The matrix factorization trainer is the only traditional trainer found in ML.NET as of this writing. The matrix factorization trainer requires both normalization of the values and caching. In addition, to utilize matrix factorization in ML.NET, the <kbd>Microsoft.ML.Recommender</kbd><span> NuGet package is required if you are creating the project from scratch. The included sample from the GitHub repository includes this package.</span></p>
<p>Similar to other algorithms, normalization is required, but matrix factorization is unique. O<span>ther algorithms, as we have seen with binary classification or regression algorithms, have multiple values that can be normalized. In matrix factorization,</span> there are only three values involved: <kbd>Label</kbd>, <kbd>Row</kbd>, and <kbd>Column</kbd> values. The output is comprised of two properties: <kbd>Score </kbd>and <kbd>Label</kbd>. The <kbd>Score</kbd> value is of type <kbd>Float</kbd>, non-negative and unbounded.</p>
<p><span>It should be noted that in July 2018's ML.NET 0.3 update, field-aware factorization machines were added. However, this type of trainer offered only binary recommendations (such as either like or dislike), as opposed to matrix factorization, which supports floating-point values of any range. This provides considerably better flexibility in usage, such as getting more granular predictions. If, for instance, a matrix factorization recommendation on a scale from 0 to 100 returned 30, the recommendation engine would more than likely return a negative recommendation. With simply a binary response, the application—and thereby the end-user—is not shown how strong the recommendation is either way.</span></p>
<p>We will demonstrate this trainer in the sample application later, in the next section, by providing music recommendations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a matrix factorization application</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the application we will be creating is for music prediction. Given a UserID, MusicID, and a rating, the algorithm will use that data to create recommendations. As with other applications, this is not meant to power the next Spotifyesque machine learning product; however, it will show you how to use matrix factorization in ML.NET.</p>
<p>As with previous chapters, the completed project code, sample dataset, and project files can be downloaded here: <a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter07">https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter07</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the project architecture</h1>
                </header>
            
            <article>
                
<p>Building on the project architecture and code we created in previous chapters, the bulk of the changes are in the training of the model, as matrix factorization requires a fairly significant paradigm shift from what we have reviewed in previous chapters.</p>
<p>In the following screenshot, you will find the Visual Studio Solution Explorer view of the project. The new additions to the solution are the <kbd>MusicRating</kbd><strong> </strong>and <kbd>MusicPrediction</kbd><strong> </strong>files, which we will review later in this section:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-622 image-border" src="assets/d3568d52-b3fd-48a1-8630-72b8c1bebf0d.png" style="width:17.17em;height:28.17em;"/></p>
<p>The<span> </span><kbd>sampledata.csv</kbd> file contains 10 rows of random music ratings. Feel free to adjust the data to fit your own observations, or to adjust the trained model. Here is a snippet of the data:</p>
<div>
<pre>1,1000,4<br/>1,1001,3.5<br/>1,1002,1<br/>1,1003,2<br/>2,1000,1.5<br/>2,1001,2<br/>2,1002,4<br/>2,1003,4<br/>3,1000,1<br/>3,1001,3</pre></div>
<p>Each of these rows contains the value for the properties in the newly created <kbd>MusicRating</kbd><strong> </strong>class that we will review later on in this chapter.</p>
<p>In addition to this, we added the<span> </span><kbd>testdata.csv</kbd><span> </span>file that contains additional data points to test the newly trained model<span> </span>against and<span> </span>evaluate. Here is a snippet of the data inside of<span> </span><kbd>testdata.csv</kbd>:</p>
<pre>1,1000,4<br/>1,1001,3.5<br/>2,1002,1<br/>2,1003,2<br/>3,1000,1.5<br/>3,1001,2<br/>4,1002,4<br/>4,1003,4</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the code</h1>
                </header>
            
            <article>
                
<p>For this application, as noted in the previous section, we are building on top of the work<span> </span>completed in <a href="4e2ca910-b4a8-4f00-b8e4-5f2cf7ee5222.xhtml">Chapter<span> 6</span></a><span>, <em>Anomaly Detection Model</em></span>. For this deep dive, we are going to focus solely on the code that was changed for this application.</p>
<p>Classes that were changed or added are as follows:</p>
<ul>
<li><kbd>MusicRating</kbd></li>
<li><kbd>MusicPrediction</kbd></li>
<li><kbd>Predictor</kbd></li>
<li><kbd>Trainer</kbd></li>
<li><kbd>Constants</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The MusicRating class</h1>
                </header>
            
            <article>
                
<p>The <kbd>MusicRating</kbd><strong> </strong>class is the container class that contains the data to both predict and train our model. As described in previous chapters, the number in the <kbd>LoadColumn</kbd><span> </span>decorator maps to the index in the CSV files. As noted in the earlier section, matrix factorization in ML.NET requires the use of normalization, as shown in the following code block:</p>
<pre>using Microsoft.ML.Data;<br/><br/>namespace chapter07.ML.Objects<br/>{<br/>    public class MusicRating<br/>    {<br/>        [LoadColumn(0)]<br/>        public float UserID { get; set; }<br/><br/>        [LoadColumn(1)]<br/>        public float MovieID { get; set; }<br/><br/>        [LoadColumn(2)]<br/>        public float Label { get; set; }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The MusicPrediction class</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>MusicPrediction</kbd><strong> </strong>class contains the properties mapped to our prediction output. The <kbd>Score</kbd> contains the likelihood the prediction is accurate. We will review these values later on in this section, but for now, they can be seen in the following code block:</p>
<div>
<pre>namespace chapter07.ML.Objects<br/>{<br/>    public class MusicPrediction<br/>    {<br/>        public float Label { get; set; }<br/><br/>        public float Score { get; set; }<br/>    }<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Predictor class</h1>
                </header>
            
            <article>
                
<p>There are a couple of changes in this class to handle the music-prediction scenario, as follows:</p>
<ol>
<li>First,<span> we create our prediction engine with the <kbd>MusicRating</kbd><strong> </strong>and <kbd>MusicPrediction</kbd> types, like this:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">var predictionEngine = MlContext.Model.CreatePredictionEngine&lt;MusicRating, MusicPrediction&gt;(mlModel);</pre></div>
<ol start="2">
<li>Next, we read the input file into a string object, like this:</li>
</ol>
<div>
<pre style="padding-left: 60px">var json = File.ReadAllText(inputDataFile);</pre></div>
<p>               3. Next, we deserialize the string into an object of type <kbd>MusicRating</kbd>, like this:</p>
<pre style="padding-left: 60px" class="mce-root">var rating = JsonConvert.DeserializeObject&lt;MusicRating&gt;(json);</pre>
<ol start="3">
<li style="list-style-type: none">
<ol start="2"/>
</li>
<li>L<span>astly, we need to run the prediction, and then output the results of the model run, as follows</span><span>:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">var prediction = predictionEngine.Predict(rating);<br/><br/>Console.WriteLine(<br/>    $"Based on input:{System.Environment.NewLine}" +<br/>    $"Label: {rating.Label} | MusicID: {rating.MusicID} | UserID: {rating.UserID}{System.Environment.NewLine}" +<br/>    $"The music is {(prediction.Score &gt; Constants.SCORE_THRESHOLD ? "recommended" : "not recommended")}");</pre></div>
<p>With the transform only returning the three-element vector, the original row data is outputted to give context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Trainer class</h1>
                </header>
            
            <article>
                
<p>Inside the <kbd>Trainer</kbd> class, several modifications need to be made to support the matrix factorization. In many ways, a simplification is required due to the nature of only having three inputs:</p>
<ol>
<li>The first addition is the two constant variables for the variable encoding, shown in the following code block:</li>
</ol>
<div>
<pre style="padding-left: 60px">private const string UserIDEncoding = "UserIDEncoding";<br/>private const string MovieIDEncoding = "MovieIDEncoding";</pre></div>
<ol start="2">
<li>We then build the <kbd>MatrixFactorizationTrainer</kbd> options. The <kbd>Row</kbd> and <kbd>Column</kbd> properties are set to the column names previously defined. The <kbd>Quiet</kbd> flag displays additional model building information on every iteration, as illustrated in the following code block:</li>
</ol>
<div>
<pre style="padding-left: 60px">var options = new MatrixFactorizationTrainer.Options<br/>{<br/>    MatrixColumnIndexColumnName = UserIDEncoding,<br/>    MatrixRowIndexColumnName = MovieIDEncoding,<br/>    LabelColumnName = "Label",<br/>    NumberOfIterations = 20,<br/>    ApproximationRank = 10,<br/>    Quiet = false<br/>};</pre></div>
<ol start="3">
<li>We can then create the matrix factorization trainer, as follows:</li>
</ol>
<div>
<pre style="padding-left: 60px">var trainingPipeline = trainingDataView.Transformer.Append(MlContext.Recommendation().Trainers.MatrixFactorization(options));</pre></div>
<ol start="4">
<li>Now, we fit the model on the training data and save the model, as follows:</li>
</ol>
<pre style="padding-left: 60px">ITransformer trainedModel = trainingPipeLine.Fit(trainingDataView.DataView);<br/><br/>MlContext.Model.Save(trainedModel, trainingDataView.DataView.Schema, ModelPath);<br/><br/>Console.WriteLine($"Model saved to {ModelPath}{Environment.NewLine}");</pre>
<ol start="5">
<li>Lastly, we load the testing data and pass the data to the matrix factorization evaluator, like this:</li>
</ol>
<pre style="padding-left: 60px">var testingDataView = GetDataView(testingFileName, true);<br/><br/>var testSetTransform = trainedModel.Transform(testingDataView.DataView);<br/><br/>var modelMetrics = MlContext.Recommendation().Evaluate(testSetTransform);<br/><br/>Console.WriteLine($"matrix factorization Evaluation:{Environment.NewLine}{Environment.NewLine}" +<br/>                  $"Loss Function: {modelMetrics.LossFunction}{Environment.NewLine}" +<br/>                  $"Mean Absolute Error: {modelMetrics.MeanAbsoluteError}{Environment.NewLine}" +<br/>                  $"Mean Squared Error: {modelMetrics.MeanSquaredError}{Environment.NewLine}" +<br/>                  $"R Squared: {modelMetrics.RSquared}{Environment.NewLine}" +<br/>                  $"Root Mean Squared Error: {modelMetrics.RootMeanSquaredError}");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Constants class</h1>
                </header>
            
            <article>
                
<p><span>In addition, given the training only requires the training data, some modifications to the <kbd>Program</kbd> class need to be performed, as follows:</span></p>
<div>
<pre>namespace chapter07.Common<br/>{<br/>    public class Constants<br/>    {<br/>        public const string MODEL_FILENAME = "chapter7.mdl";<br/><br/>        public const float SCORE_THRESHOLD = 3.0f;<br/>    }<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p><span>To run the application, the process is nearly identical to Chapter 6's sample application, as follows:</span></p>
<ol>
<li>After preparing the data, we must then train the model by passing in the newly created<span> </span><kbd>sampledata.csv</kbd> file, like this:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS Debug\netcoreapp3.0&gt; .\chapter07.exe train ..\..\..\Data\sampledata.csv ..\..\..\Data\testdata.csv</strong><br/>iter tr_rmse obj<br/>   0 2.4172 9.6129e+01<br/>   1 1.9634 6.6078e+01<br/>   2 1.5140 4.2233e+01<br/>   3 1.3417 3.5027e+01<br/>   4 1.2860 3.2934e+01<br/>   5 1.1818 2.9107e+01<br/>   6 1.1414 2.7737e+01<br/>   7 1.0669 2.4966e+01<br/>   8 0.9819 2.2615e+01<br/>   9 0.9055 2.0387e+01<br/>  10 0.8656 1.9472e+01<br/>  11 0.7534 1.6725e+01<br/>  12 0.6862 1.5413e+01<br/>  13 0.6240 1.4311e+01<br/>  14 0.5621 1.3231e+01<br/>  15 0.5241 1.2795e+01<br/>  16 0.4863 1.2281e+01<br/>  17 0.4571 1.1938e+01</pre>
<pre style="padding-left: 60px">  18 0.4209 1.1532e+01<br/>  19 0.3975 1.1227e+01<br/><br/>Model saved to Debug\netcoreapp3.0\chapter7.mdl</pre></div>
<ol start="2">
<li>To run the model with this file, simply pass the<span> </span><kbd>testdata.csv</kbd> file<strong> </strong>mentioned earlier into the newly built application, and the predicted output will show the following:</li>
</ol>
<div>
<pre style="padding-left: 60px">matrix factorization Evaluation:<br/><br/>Loss Function: 0.140<br/>Mean Absolute Error: 0.279<br/>Mean Squared Error: 0.140<br/>R Squared: 0.922<br/>Root Mean Squared Error: 0.375</pre></div>
<p style="padding-left: 60px">Prior to running the prediction, create a JSON file in Notepad with the following text:</p>
<pre style="padding-left: 30px">{ "UserID": 10, "MusicID": 4, "Label": 3 }</pre>
<p style="padding-left: 60px">Then save the file to your output folder.</p>
<ol start="3">
<li>Then, run the prediction, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>PS Debug\netcoreapp3.0&gt; .\chapter07.exe predict input.json</strong><br/>Based on input:<br/>Label: 3 | MusicID: 4 | UserID: 10<br/>The music is not recommended</pre>
<p>Feel free to modify the values, and see how the prediction changes based on the dataset that the model was trained on. A few areas of experimentation from this point might be to:</p>
<ul>
<li>Change the hyperparameters mentioned in the <kbd>Trainer</kbd> class deep dive.</li>
<li>Add diversification and more data points to the training and test data.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating a matrix factorization model</h1>
                </header>
            
            <article>
                
<p>As discussed in previous chapters, evaluating a model is a critical part of the overall model-building process. A poorly trained model will only provide inaccurate predictions. Fortunately, ML.NET provides many popular attributes to calculate model accuracy based on a test set at the time of training, to give you an idea of how well your model will perform in a production environment. </p>
<p>As noted earlier in the sample application, for matrix factorization model evaluation in ML.NET, there are five properties that comprise the<span> </span><kbd>RegressionMetrics</kbd><strong> </strong>class object. Let us dive into the properties exposed in the <kbd>RegressionMetrics</kbd><strong> </strong>object here:</p>
<ul>
<li>Loss function</li>
<li><strong>Mean Squared Error</strong> (<strong>MSE</strong>)</li>
<li><strong>Mean Absolute Error</strong> (<strong>MAE</strong>)</li>
<li>R-squared </li>
<li><strong>Root Mean Squared Error</strong> (<strong>RMSE</strong>)</li>
</ul>
<p>In the next sections, we will break down how these values are calculated, and detail the ideal values to look for.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loss function</h1>
                </header>
            
            <article>
                
<p class="mce-root">This property uses the loss function set when the matrix factorization trainer was initialized. In the case of our matrix factorization example application, we used the default constructor, which defaults to the<span> </span><kbd>SquaredLossRegression</kbd><span> </span>class. </p>
<p>Other regression loss functions offered by ML.NET are:</p>
<ul>
<li>Squared-loss one class</li>
<li>Squared-loss regression</li>
</ul>
<p>The idea behind this property is to allow some flexibility when it comes to evaluating your model compared to the other four properties, which use fixed algorithms for evaluation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MSE</h1>
                </header>
            
            <article>
                
<p>MSE is defined as the measure of the average of the squares of the errors. To put this simply, take the plot shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-623 image-border" src="assets/f8a787c2-7855-4379-a5a3-8c40633dadf7.png" style="width:13.75em;height:13.75em;"/></p>
<p>The dots correlate to data points for our model, while the blue line is the prediction line. The distance between the red dots and the prediction line is the error. For MSE, the value is calculated based on these points and their distances to the line. From that value, the mean is calculated. For MSE, the smaller the value, the better the fitting, and the more accurate the predictions you will have with your model.</p>
<p>MSE is best used to evaluate models when outliers are critical to the prediction output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MAE</h1>
                </header>
            
            <article>
                
<p>MAE is similar to MSE, with the critical difference being that it sums the distances between the points and the prediction lines, as opposed to computing the mean. It should be noted that MAE does not take into account directions in calculating the sum. For instance, if you had two data points equal distance from the line, one above and the other below, in effect this would be balanced out with a positive and negative value. In machine learning, this is referred to as <strong>Mean Bias Error</strong> (<strong>MBE</strong>). However, ML.NET does not provide this as part of the<span> </span><kbd>RegressionMetrics</kbd><span> </span>class at the time of this writing.</p>
<p>MAE is best used to evaluate models when outliers are considered simply anomalies, and shouldn't be counted in evaluating a model's performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">R-squared </h1>
                </header>
            
            <article>
                
<p>R-squared, also called <strong>the coefficient of determination</strong>, is another method of representing how well the prediction compares to the test set. R-squared <span>is calculated by taking the difference between each predicted value and its corresponding actual value, squaring that difference, then summing the squares for each pair of points.</span> </p>
<p>R-squared values generally range between 0 and 1, represented as a floating-point value. A negative value can occur when the fitted model is evaluated to be worse than an average fit. However, a low number does not always reflect that the model is bad. Predictions, such as the one we looked at in this chapter, that are based on predicting human actions are often found to be under 50%. </p>
<p>Conversely, higher values aren't necessarily a sure sign of the model's performance, as this could be considered as overfitting of the model. This happens in cases when there are a lot of features fed to the model, thereby making the model more complex as compared to the model we built in the <em>Creating your first ML.NET application</em><span> section of</span> <a href="b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml">Chapter 2</a>, <em>Setting Up the ML.NET Environment</em>, as there is simply not enough diversity in the training and test sets. For example, if all of the employees were roughly the same values, and then the test set holdout was comprised of the same ranges of values, this would be considered overfitting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RMSE</h1>
                </header>
            
            <article>
                
<p>RMSE is arguably the easiest property to understand, given the previous methods. Take the plot shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-624 image-border" src="assets/39c169e9-4a2f-4798-9e73-7dea68e45fbc.png" style="width:16.92em;height:16.92em;"/></p>
<p>In the case of testing the model, as we did previously with the holdout set, the red dots are the actual values from the test set, while the blue dots are the predicted values. The<span> </span><span class="packt_screen">X </span>depicted is the distance between the predicted and actual values. RMSE simply takes a mean of all of those distances, squares that value, and then takes the square root. </p>
<p>A value under 180 is generally considered a good model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Over the course of this chapter, we have deep-dived into ML.NET's matrix factorization support. We have also created and trained our first matrix factorization application to predict music recommendations. Lastly, we also dove into how to evaluate a matrix factorization model and looked at the various properties that ML.NET exposes to achieve a proper evaluation of a matrix factorization model.</p>
<p>With this chapter coming to a close, we have also completed our initial investigation of the various models ML.NET provides. In the next chapter, we will be creating full applications, building on the knowledge garnered over the last few chapters, with the first being a full .NET Core application providing stock forecasting.</p>


            </article>

            
        </section>
    </body></html>