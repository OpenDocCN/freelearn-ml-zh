- en: Chapter 3. Recommendation Engines Explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0020.xhtml#aid-J2B82 "Chapter 2. Build Your First Recommendation
    Engine"), *Build Your First Recommendation Engine,* we learned how to build a
    basic recommender system using R. With introductions to various recommender systems
    in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Introduction to Recommendation
    Engines"), *Introduction to Recommendation Engines,* we have got a fair idea about
    what a recommender system is and why a recommender system is important in the
    current age of data explosion. In this chapter we will learn about various types
    of recommender systems in detail. This chapter explains Neighborhood similarity-based
    recommendations, personalized recommendation engines, model-based recommender
    systems, and hybrid recommendation engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the different subtypes of recommender system covered in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Neighborhood-based recommendation engines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-based collaborative filtering
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Item-based collaborative filtering
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Personalized recommendation engines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content-based recommendation engines
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Context-aware recommendation engines
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Model-based recommendation engines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ML-based recommendation engines
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Classification - SVM/KNN
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix Factorization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Singular value decomposition
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternating Least Squares
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid recommendation engines
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolution of recommendation engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, recommender systems have evolved, from basic nearest neighborhood
    methods to personalized recommenders to context-aware recommendations, from batch-mode
    recommendations to real-time recommendations, from basic heuristic approaches
    such as similarity calculation to more accurate, complex machine-learning approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In the early stages of these recommender systems, only user ratings on products
    were used for generating recommendations. At this time, researchers used only
    the available ratings information. They simply applied heuristic approaches such
    as similarity calculation using Euclidean distances, the Pearson coefficient,
    cosine similarity, and so on. These approaches were well received and surprisingly
    they perform quite well even today.
  prefs: []
  type: TYPE_NORMAL
- en: This first generation of recommendation engines is called collaborative filtering
    or neighborhood method recommenders. Though they perform very well, these recommenders
    come with their own set of limitations such as cold-start problems; that is to
    say, they failed to recommend products to new users with no rating information
    and recommend new products with no ratings to the users. Also these recommenders
    failed to handle scenarios where the data is very sparse, so user ratings on products
    are much less.
  prefs: []
  type: TYPE_NORMAL
- en: In order to overcome these limitations, new approaches have been developed.
    For example, in order to handle very large user-rating with high data sparsity,
    mathematical approaches such as Matrix Factorization and singular value decomposition
    methods have been used.
  prefs: []
  type: TYPE_NORMAL
- en: To handle the cold-start problem, new approaches such as content-based recommendation
    systems have been developed. These recommender systems opened the door to many
    more opportunities such as personalized recommenders systems, which enabled them
    to recommend products to each user on an individual level. In this approach, instead
    of rating information, user personal preferences and product features are considered.
  prefs: []
  type: TYPE_NORMAL
- en: '![Evolution of recommendation engines](img/image00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the beginning, similarity calculations were used in content-based recommenders,
    but with advancements in technology and infrastructure more advanced methods such
    as machine-learning models have replaced the heuristic methods. These new machine
    models have improved the accuracy of the recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Though content-based recommenders have solved many of the shortcomings of collaborative
    filtering, these have their own inherent shortcomings such as serendipity, that
    is to say not being able to recommend new items outside the user's preference
    scope, which collaborative filtering can do.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, researchers started combining different recommendation
    models to come up with hybrid recommendation models, which are much more powerful
    than any of the individual models.
  prefs: []
  type: TYPE_NORMAL
- en: With personal successful implementations of personalized recommendation engines,
    people started extending the personalization to other dimensions called contexts,
    such as the addition of location, time, group, and so on, and changed the set
    of recommendations with each context.
  prefs: []
  type: TYPE_NORMAL
- en: With advancements in technology such as big data ecosystems, in-memory analytic
    tools such as Apache Spark, and recommendations in real time, the capability of
    handling very large databases has become possible.
  prefs: []
  type: TYPE_NORMAL
- en: Currently we are moving into more personalization of aspects such as temporal
    dimension and ubiquitous ways of recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: In the technology aspect the recommendations are moving from machine-learning
    approaches to more advanced neural network deep-learning approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Nearest neighborhood-based recommendation engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, neighborhood-based recommender systems considers the
    preferences or likes of the user community or users of the neighborhood of an
    active user before making suggestions or recommendations to the active user. The
    idea for neighborhood-based recommenders is very simple: given the ratings of
    a user, find all the users similar to the active user who had similar preferences
    in the past and then make predictions regarding all unknown products that the
    active user has not rated but are being rated in their neighborhood:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nearest neighborhood-based recommendation engines](img/image00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While considering the preferences or tastes of neighbors, we first calculate
    how similar the other users are to the active user and then unrated items from
    the user community are recommended to the user following predictions. Here the
    active user is the person to whom the system is serving recommendations. Since
    similarity calculations are involved, these recommender systems are also called
    similarity-based recommender systems. Also, since preferences or tastes are considered
    collaboratively from a pool of users, these recommender systems are also called
    collaborative filtering recommender systems. In these types of systems, the main
    actors are the users, products, and user's preference information such as rating/ranking/liking
    towards the products.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image is an example from Amazon showing a neighborhood case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nearest neighborhood-based recommendation engines](img/image00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These heuristic-based methods are based on the following assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: People with similar preferences in the past have similar preferences in the
    future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People's preferences will remain stable and consistent in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The collaborative filtering systems come in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: User-based collaborative filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item-based collaborative filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These neighborhood methods are employed when we have only the users'' interaction
    data of the products, such as ratings, like/unlike, view/not. Unlike content-based
    recommendations, which will be explained in the next section, they do not consider
    any features of the products or personal preferences of the user for the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nearest neighborhood-based recommendation engines](img/image00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: User-based collaborative filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, the basic intuition behind user-based collaborative
    filtering systems is that people with similar tastes in the past will like similar
    items in future as well. For example, if user A and user B have very similar purchase
    histories and if user A buys a new book which user B has not yet seen then we
    can suggest this book to user B as they have similar tastes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try to understand user-based collaborative filtering with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem Statement:** Imagine we have a dataset used in [Chapter 2](part0020.xhtml#aid-J2B82
    "Chapter 2. Build Your First Recommendation Engine"), *Build Your First Recommendation
    Engine* containing the reviewers'' ratings given to movies on a movie review site.
    The task at hand is to recommend movies to the reviewers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User-based collaborative filtering](img/image00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we learn the recommendation approach, the first step is to analyze the
    data at hand. Let us analyze the data step-by-step as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of users who have interacted with the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A movie catalog of all the available movies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have individual users' ratings of movies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that each user has not rated all of the movies but only a few movies from
    the entire catalog.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to find similar users for an active user and then suggest
    new movies that this active user has not seen but similar users have seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be summarized in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the similarity between users using the rating information of the movies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each active user, consider the movies that are not rated by them but rated
    by other users. Predict the unknown ratings for the non-rated movies for the active
    user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the preceding tabular data, let us recommend new movies to our active user,
    Jack Mathews:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to look for similar users to Jack. We observe by looking at
    the dataset that Gene Seymour and Mick Lasalle are very similar to Jack Mathews.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The similarity between users is calculated based on the ratings given by users.
    The most common approaches for calculating the similarity are Euclidean distance
    and the Pearson correlation coefficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For now we choose Euclidean distance to find the similarity calculation given
    by the equation that follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![User-based collaborative filtering](img/image00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The intuition behind using Euclidean distance is that we represent users, movies,
    and ratings as points in a vector space with users on the *x* axis, movies on
    the *y* axis, and ratings as points in vector space. Now that we have projected
    our data into vector space, similarity or closeness between two points can be
    calculated using Euclidean distance, and the Pearson correlation coefficient.
    The detailed explanation for the similarity measures will be explained in [Chapter
    4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining Techniques Used in Recommendation
    Engines"), *Data Mining Techniques Used in Recommendation Engines*.
  prefs: []
  type: TYPE_NORMAL
- en: '![User-based collaborative filtering](img/image00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the previous equation we can calculate the similarity between all the
    reviewers as shown in the table. We observe from the table that our active user,
    Toby, is most similar to Lisa Rose.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a second step we predict the ratings for the unknown movie *Just My Luck*
    for Jack by calculating the weighted average of the ratings given by other reviewers
    for *Just My Luck* given in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rating for Jack for the *Just my Luck* movie is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(3*0.9285+1.5*0.944+3*0.755+2*0.327)/(0.8934051+0.3812464+0.9912407+0.9244735)=
    2.23*'
  prefs: []
  type: TYPE_NORMAL
- en: In the above equation, we have multiplied the similarity values of all reviewers
    with Jack by the ratings given by them to the *Just My Luck* movie and then summed
    all the values. This total sum is divided by the sum of similarity values to normalize
    the final rating. Similarly we can predict unknown movie ratings for all the reviews
    and then recommendations can be made.
  prefs: []
  type: TYPE_NORMAL
- en: Item-based collaborative filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In item-based collaborative filtering recommender systems, unlike user-based
    collaborative filtering, we use similarity between items instead of similarity
    between users. The basic intuition for item-based recommender systems is that
    if a user liked item A in the past they might like item B, which is similar to
    item A:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Item-based collaborative filtering](img/image00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In user-based collaborative filtering, there are a few downs sides:'
  prefs: []
  type: TYPE_NORMAL
- en: The system suffers with performance if the user ratings are very sparse, which
    is very common in the real world where users will rate only a few items from a
    large catalog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computing cost for calculating the similarity values for all the users is
    very high if the data is very large
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If user profiles or user inputs change quickly then we have to re-compute the
    similarity values that come with a high computational cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item-based recommendation engines handle these shortcomings by calculating similarity
    between items or products instead of calculating similarity between users, thereby
    reducing the computational cost. Since the item catalog doesn't change rapidly,
    we don't have to re-compute calculations very often.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with a user-based collaborative filtering approach there are two steps for
    an item-based collaborative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the similarity between items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Predicting the ratings for the non-rated item for an active user by making use
    of previous ratings given to other similar items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The most common similarity measure used for this approach is cosine similarity.
    Cosine similarity calculates the similarity between two n-dimensional vectors
    by the angle between them in the vector space. Cosine similarity is given by the
    following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Item-based collaborative filtering](img/image00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When applying cosine similarity to recommender systems, we consider the item
    column as the n-dimensional vector and the similarity between two items as the
    angle between them. The smaller the angle, the more similar the items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the previous dataset, if we want to predict the rating for
    Toby for the movie *Lady in the Water*, first we have to identify movies similar
    to *Lady in the Water*. Using the previous cosine equation we can calculate the
    similarity for all the items. The following table shows the similarity values
    for all the movies:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Item-based similarity is calculated only for co-rated items.
  prefs: []
  type: TYPE_NORMAL
- en: '![Item-based collaborative filtering](img/image00236.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding table, we see that *You, me and Dupree* is the most similar
    to *Lady in the Water (0.8897565)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now predict the rating for the *Lady in the Water* movie by calculating
    the weighted sum of ratings assigned to movies similar to *Lady in the Water*
    by Toby. That is to say, we take the similarity score of *Lady in the Water* for
    each movie rated by Toby, multiply it by the corresponding rating, and sum up
    all the scores for all the rated movies. This final sum is divided by the total
    sum of similarity scores of *Lady in the Water* given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rating for *Lady in the Water*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(0.795*4.5 + 0.814*4 + 0.889*1)/(0.795+0.814+0.889) = 3.09*'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly we can calculate ratings for all other users for movies using the
    preceding equation. In [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining
    Techniques Used in Recommendation Engines"), *Data Mining Techniques Used in Recommendation
    Engines*, we deal with other similarity metrics that can be used in item-based
    recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Easy to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither the content information of the products nor the users' profile information
    is required for building recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New items are recommended to users giving a surprise factor to the users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This approach is computationally expensive as all the user, product, and rating
    information is loaded into the memory for similarity calculations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach fails for new users where we do not have any information about
    the users. This problem is called the cold-start problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach performs very poorly if we have little data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we do not have content information about users or products, we cannot
    generate recommendations accurately based on rating information only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content-based recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw that the recommendations were generated by considering
    only the rating or interaction information of the products by the users, that
    is to say that suggesting new items for the active user is based on the ratings
    given to those new items by similar users to the active user.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the case of a person who has given a 4-star rating to a movie. In
    a collaborative filtering approach we only consider this rating information for
    generating recommendations. In real life, a person rates a movie based on the
    features or content of the movie such as its genre, actor, director, story, and
    screenplay. Also the person watches a movie based on their personal choices. When
    we are building a recommendation engine to target users at a personal level, the
    recommendations should not be based on the tastes of other similar people but
    should be based on the individual users' tastes and the contents of the products.
  prefs: []
  type: TYPE_NORMAL
- en: A recommendation that is targeted at a personalized level and that considers
    individual preferences and contents of the products for generating recommendations
    is called a content-based recommender system.
  prefs: []
  type: TYPE_NORMAL
- en: Another motivation for building content-based recommendation engines is that
    they solve the cold-start problem that new users face in the collaborative filtering
    approach. When a new user comes, based on the preferences of the person we can
    suggest new items that are similar to their tastes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building content-based recommender systems involves three main steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating content information for products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating a user profile and preferences with respect to the features of the
    products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generating recommendations and predicting a list of items that the user might
    like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Content-based recommender systems](img/image00237.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Item profile generation**: In this step, we extract the features that represent
    the product. Most commonly the content of the products is represented in the vector
    space model with product names as rows and features as columns. Usually the content
    of the products will either be structured data or unstructured data. Structured
    data will be obtained from the databases; unstructured features would include
    the reviews, tags, or textual properties associated in websites. In the item profile
    generation step, we have to extract relevant features and their relative importance
    score associated with the product.'
  prefs: []
  type: TYPE_NORMAL
- en: For generating the item profile we use the **term frequency inverse document
    frequency** (**tf-idf**) for calculating the feature relative importance associated
    with the item. Since we represent the item features in vector representation,
    we may use tf-idf, which will be explained in detail in [Chapter 4](part0029.xhtml#aid-RL0A2
    "Chapter 4. Data Mining Techniques Used in Recommendation Engines"), *Data Mining
    Techniques Used in Recommendation Engines*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try to better understand with an example. As we''ve already mentioned,
    for content-based recommendation engines, we require additional content information
    about Movies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content-based recommender systems](img/image00238.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we have to do is to create an item profile using tf-idf, by
    means of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a term frequency matrix containing the frequency count of each term
    in each document; that is to say, in our case, the presence of each genre in each
    movie. The number 1 represents the presence of the genre and 0 represents the
    absence of the genre:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content-based recommender systems](img/image00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to create inverse document frequency given by the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Idf = Log(total number of documents/document frequency)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the total number of documents is the number of movies, and the document
    frequency is the total number of times they have occurred in all the documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content-based recommender systems](img/image00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final step is to create a *tf-idf* matrix given by the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*tf*idf*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content-based recommender systems](img/image00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: User profile generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this step, we build the user profile or preference matrix matching the product
    content. In general we build the user profile or features that are in common with
    the product content as it makes more sense to compare both user and item profiles
    and calculate the similarity between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following dataset showing the viewed history of each user.
    If there is a value of 1 in the matrix cell, it means that the user has seen the
    movie. This information gives us their preference of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User profile generation](img/image00242.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding information, we will create a user profile that can be used
    to compare with the item profile; that is to say, we now create a user profile
    that contains the user preference of the item features, to genres, in our case.
    Dot product between the tf-idf and user preference matrix will give the user affinity
    for each of the genres, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dotProduct(Tf-idf, userPreference matrix)*'
  prefs: []
  type: TYPE_NORMAL
- en: '![User profile generation](img/image00243.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With user profiles and item profiles at hand, the next step would be to estimate
    the degree to which the user will prefer each of the items. We can now use cosine
    similarity to compute the user preference for each of the items. In our example,
    the cosine similarity between user and item profiles gives the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cosineSimilarity(userProfile,ItemProfile)*'
  prefs: []
  type: TYPE_NORMAL
- en: '![User profile generation](img/image00244.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding table we can conclude that the greater the cosine angle the
    more likely the user is to like a movie and hence it can be recommended to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have made the recommendations, let us take a step back from gathering
    user preference data. Usually there are two ways of capturing user data; these
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly ask the user for their preferences regarding the product's features,
    and store them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicitly capture the user interaction data on products such as browsing history,
    rating history, and purchase history, and build the user preferences to the product
    features. In [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining Techniques
    Used in Recommendation Engines"), *Data Mining Techniques Used in Recommendation
    Engines*, and [Chapter 5](part0037.xhtml#aid-1394Q1 "Chapter 5. Building Collaborative
    Filtering Recommendation Engines"), *Building Collaborative Filtering Recommendation
    Engines,* we build recommendation engines using explicit and implicit user activity
    examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The approach that we have followed until now for building a content-based recommendation
    system is based on similarity calculation. We may also apply supervised machine-learning
    approaches such as classification for predicting the most probable products the
    user might like.
  prefs: []
  type: TYPE_NORMAL
- en: Recommender systems using machine learning or any other mathematical, statistical
    models to generate recommendations are called model-based systems. In classification-based
    approaches which fall under model-based recommender systems, first we build a
    machine-learning model by using a user profile and item profile to predict if
    a user likes/dislikes an item. Supervised classification tasks such as logistic
    regression, KNN-classification methods, probabilistic methods, and so on, can
    be used. Model-based recommendation engines are discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Content-based recommender systems target at an individual level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations are generated using the user preferences alone rather than the
    user community as with collaborative filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These approaches can be employed in real time as the recommendation model doesn't
    need to load all the data for processing or generating recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy is high compared to collaborative approaches as they deal with the
    content of the products instead of rating information alone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cold-start problem can be easily handled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the system is more personalized the generated recommendations will become
    narrowed down to only user preferences when more user information comes into the
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, no new products that are not related to the user preferences will
    be shown to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will not be able to look at what is happening around them or what's
    trending
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context-aware recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years there has been an evolution in recommender systems from neighborhood
    approaches to personalized recommender systems that are targeted to individual
    users. These personalized recommender systems have become a huge success as this
    is useful at end user level, and for organizations these systems become catalysts
    to increase their business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though the personalized recommender systems were targeted at the individual
    user level and provided recommendations based on the personal preferences of the
    users, there was scope to refine the systems. For example, the same person in
    different places might have different requirements. Likewise, the same person
    has different requirements at different times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context-aware recommender systems](img/image00245.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our intelligent recommender systems should be evolved enough to cater to the
    needs of the users for different places, at different times. The recommender system
    should be robust enough to suggest cotton shirts to a person during summer and
    leather jackets during winter. Similarly, based on the time of day, suggesting
    good restaurants serving a person''s personal choice of breakfast or dinner would
    be very helpful. These kinds of recommender systems that consider location, time,
    mood, and so on, that defines the context of the user and suggests personalized
    recommendations, are called **context aware recommender systems**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context-aware recommender systems](img/image00246.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image illustrates a recommendation engine suggesting coffee in
    cold weather.
  prefs: []
  type: TYPE_NORMAL
- en: Context definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what exactly is context? In general, context represents the present state
    of the user. The context of a user can be anything such as place, time, day, season,
    mood, device, whether the user is alone, at the office, on vacation, with family,
    with friends, life events, and so on. Since people will have different needs in
    different contexts, the recommendation systems can capture the context information
    of the user and refine their suggestions accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a travel vacation system may consider season, place, and time as
    context for refining the suggestions; an e-commerce website can consider the life
    event and user purchases for context aware recommendations, and a food website
    may consider time of day and place information while recommending restaurants.
  prefs: []
  type: TYPE_NORMAL
- en: 'How are context aware systems designed? Until now we have considered recommendations
    as a two-dimensional problem, that is to say user preferences and item representations.
    With the inclusion of context as a new dimension we can build context aware recommendations
    as a three-dimensional problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recommendations = User x Item x Context*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context definition](img/image00247.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let us revisit the same example as we did in the content-based recommendations,
    where we considered the user profile and the item profile to generate the user
    ratings for each of the items based on user preferences by computing the similarity
    between the user profile and the item profile. Now, in context aware systems,
    we include context to generate the rankings for items with respect to user preference
    and context.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can assume our recommendation has captured the movie watching
    patterns of the user for a weekday, weekend, and holiday. From this context information,
    we extract the affinity of each user for the movie contents. For example, consider
    the following preferences for TOBY for each of the contexts for the movie contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context definition](img/image00248.jpeg)![Context definition](img/image00249.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us first create a user profile for TOBY for each of the contexts for all
    the movie content. A dot product between the context matrix and user profile matrix
    gives us the user profile for all the contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dotproduct(user profile, context matrix)* for TOBY:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context definition](img/image00250.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have now calculated the preference of TOBY for each context for the movie
    context. The next step would be to calculate the ranking of each movie for TOBY
    for all the contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cosine similarity (contextual movie content preference matrix, item profile):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context definition](img/image00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have the context level ranking for movies for TOBY, we can suggest movies based
    on the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding example, we understood that context-aware recommender systems
    are content-based recommenders with the inclusion of a new dimension called context.
    In context-aware systems, recommendations are generated in two steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a list of recommendations of the products for each user based on the
    user's preferences; that is, content-based recommendations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter out the recommendations that are specific to a current context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The most common approaches for building context-aware recommender systems are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Post-filtering approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-filtering approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-filtering approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the pre-filtering approach, context information is applied to the user profile
    and product content. This step will filter out all the non-relevant features,
    and final personalized recommendations are generated on the remaining feature
    set. Since the filtering of features is performed before generating personalized
    recommendations, these are called pre-filtering approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pre-filtering approaches](img/image00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Post-filtering approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In post-filtering approaches, firstly personalized recommendations are generated
    based on the user profile and the product catalogue, then the context information
    is applied to filter out the relevant products to the user for the current context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Post-filtering approaches](img/image00253.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Context aware systems are much more advanced than the personalized content-based
    recommenders as these systems will be constantly in sync with user movements and
    generate recommendations as per the current context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These systems have more of a real-time nature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serendipity or surprise factor, as with other personalized recommenders, will
    be missing in these types of recommendation as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collaborative filtering systems and content-based recommender systems are effective
    and cater to a wide range of needs. They have quite successful implementations
    but each independently has its own limitations. Research has started moving in
    the direction of combining both collaborative filtering and content-based recommendations.
    This new type of recommender system formed by combining collaborative filtering
    with content-based methods is called a hybrid recommender system.
  prefs: []
  type: TYPE_NORMAL
- en: The choice of combining the different recommendation approaches is up to the
    researcher or the person implementing the hybrid recommendation engine based on
    the problem statement and business needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common approaches followed for building a hybrid system are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Weighted method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cascade method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature combination method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature augmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meta-level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weighted method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this method the final recommendations would be the combination, mostly linear,
    of recommendation results of all the available recommendation engines. At the
    beginning of the deployment of this weighted hybrid recommendation engine, equal
    weights will be given to each of the results from available recommendation engines,
    and gradually the weights will be adjusted by evaluating the responses from the
    users to recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Mixed method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mixed method is applicable in places where we can mix results from all the
    available recommenders. These are mostly employed in places where it is not feasible
    to achieve a score for a product by all the available recommender systems because
    of data sparsity. Hence recommendations are generated independently and are mixed
    before being sent to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Cascade method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this approach, recommendations are generated using collaborative filtering.
    The content-based recommendation technique is applied and then final recommendations
    / a ranked list will be given as the output.
  prefs: []
  type: TYPE_NORMAL
- en: Feature combination method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The feature combination method, in which we combine the features of different
    recommender systems and final recommendation approach, is applied on the combined
    feature sets. In this technique, we combine both User-Item preference features
    extracted from content based recommender systems and, User-Item ratings information,
    and consider a new strategy to build Hybrid recommender systems.
  prefs: []
  type: TYPE_NORMAL
- en: '![Feature combination method](img/image00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Issues such as the cold-start problem and data sparsity can be handled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These systems are much more robust and scalable than any of the individual models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of methods leads to an improvement in accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-based recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now we have been focusing on neighborhood approaches which involve similarity
    calculations between users or products for collaborative filtering approaches
    or represent the user and item contents in a vector space model, and find similarity
    measures to identify items similar to the preferences of the users. The main objective
    of the similarity-based approaches is to calculate the weights of the preferences
    of users for the products or product content and then use these feature weights
    for recommending items.
  prefs: []
  type: TYPE_NORMAL
- en: These approaches have been very successful over the years and even today. But
    these approaches have their own limitations. Since entire data has to be loaded
    into the environment for similarity calculations, these approaches were also known
    as memory-based models. These memory-based models are very slow to respond in
    real-time scenarios when the amount of data is very large as all the data has
    to be loaded. Another limitation is that the weights calculated are not learned
    automatically as with machine-learning applications. The cold-start problem is
    another common limitation that memory-based or neighborhood-based methods suffer
    from.
  prefs: []
  type: TYPE_NORMAL
- en: In order to address these limitations, researchers started to apply more advanced
    methods to improve the performance of the recommendation engines such as probabilistic
    models, machine-learning models such as supervised and unsupervised models, and
    matrix approaches such as Matrix Factorization and single value decomposition.
    In the model-based approaches, using available historical data, a model is built
    with weights learned automatically. New predictions regarding the products will
    be made using the learned weights and then the final results ranked in a specific
    order before making recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Probabilistic approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a probabilistic approach, we build a probability model using the prior probabilities
    from the available data, and a ranked list of recommendations is generated by
    calculating the probability of liking/disliking of a product for each user. Most
    commonly the Naïve Bayes method is used in probabilistic approaches, which is
    a simple but powerful technique.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in content-based recommender systems, we can consider a recommendation
    problem as a machine-learning problem. Using historical user and product data,
    we can extract features and output classes and then build a machine learning model.
    A final ranked list of product recommendations is generated using the generated
    model. Many machine-learning approaches such as logistic regression, KNN classification,
    decision trees, SVM, clustering, and so on, can be used. These machine-learning
    approaches are applied for collaborative, content based, context aware, and hybrid
    recommender systems. In [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data
    Mining Techniques Used in Recommendation Engines"), *Data Mining Techniques Used
    in Recommendation Engines*, we learn in detail about each of the machine-learning
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In these approaches, we assume that the ratings or interaction information
    of users on products are simple matrices. On these matrices we apply mathematical
    approaches to predict the missing ratings for the users. The most commonly used
    approaches are the Matrix Factorization model and single valued decomposition
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mathematical approaches](img/image00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By applying matrix decomposition approaches we assume that we decompose the
    original rating matrix (R) into two new matrices (U, V) that represent the latent
    features of the users and movies.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematical terms, we can decompose a matrix into two low rank matrices.
    In the preceding example, matrix R is decomposed into matrices U and V. Now when
    we multiply back U and V we get the original matrix R approximately. This concept
    is used in recommendation engines for filling up the unknown ratings in the original
    rating matrix, and recommendations are then ranked and suggested to the users.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining Techniques Used
    in Recommendation Engines"), *Data Mining Techniques Used in Recommendation Engines*
    we discuss these two approaches in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Model-based recommendations are much more accurate than the heuristic-based
    approaches such as neighborhood methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In heuristic methods the weights of products / product content is more static,
    whereas in model-based recommendations, the weights are established through auto-learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model-based approach extracts many unseen patterns using data-driven approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about popular recommendation engine techniques
    such as collaborative filtering, content-based recommendations, context aware
    systems, hybrid recommendations, and model-based recommendation systems, with
    their advantages and disadvantages. There are different similarity methods such
    as cosine similarity, Euclidean distance, and the Pearson coefficient. Subcategories
    within each of the recommendations are also explained.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we learn about different data-mining techniques such as
    Neighborhood methods, machine learning methods used in recommendation engines,
    and their evaluation techniques such as RMSE and, Precision-Recall.
  prefs: []
  type: TYPE_NORMAL
