- en: Chapter 3. Recommendation Engines Explained
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 推荐引擎解析
- en: In [Chapter 2](part0020.xhtml#aid-J2B82 "Chapter 2. Build Your First Recommendation
    Engine"), *Build Your First Recommendation Engine,* we learned how to build a
    basic recommender system using R. With introductions to various recommender systems
    in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Introduction to Recommendation
    Engines"), *Introduction to Recommendation Engines,* we have got a fair idea about
    what a recommender system is and why a recommender system is important in the
    current age of data explosion. In this chapter we will learn about various types
    of recommender systems in detail. This chapter explains Neighborhood similarity-based
    recommendations, personalized recommendation engines, model-based recommender
    systems, and hybrid recommendation engines.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0020.xhtml#aid-J2B82 "第2章. 构建你的第一个推荐引擎")《构建你的第一个推荐引擎》中，我们学习了如何使用R构建基本的推荐系统。在[第1章](part0014.xhtml#aid-DB7S1
    "第1章. 推荐引擎简介")《推荐引擎简介》中介绍了各种推荐系统，我们已经对推荐系统是什么以及为什么在数据爆炸的当前时代推荐系统很重要有了相当的了解。在本章中，我们将详细了解各种类型的推荐系统。本章解释了基于邻域相似度的推荐、个性化推荐引擎、基于模型的推荐系统和混合推荐引擎。
- en: 'The following are the different subtypes of recommender system covered in this
    chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下不同子类型的推荐系统：
- en: 'Neighborhood-based recommendation engines:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于邻域的推荐引擎：
- en: User-based collaborative filtering
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤
- en: Item-based collaborative filtering
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤
- en: 'Personalized recommendation engines:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性化推荐引擎：
- en: Content-based recommendation engines
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的推荐引擎
- en: Context-aware recommendation engines
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文感知推荐引擎
- en: 'Model-based recommendation engines:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模型的推荐引擎：
- en: ML-based recommendation engines
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于机器学习的推荐引擎
- en: Classification - SVM/KNN
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类 - SVM/KNN
- en: Matrix Factorization
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵分解
- en: Singular value decomposition
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单值分解
- en: Alternating Least Squares
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交替最小二乘法
- en: Hybrid recommendation engines
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合推荐引擎
- en: Evolution of recommendation engines
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐引擎的演变
- en: Over the years, recommender systems have evolved, from basic nearest neighborhood
    methods to personalized recommenders to context-aware recommendations, from batch-mode
    recommendations to real-time recommendations, from basic heuristic approaches
    such as similarity calculation to more accurate, complex machine-learning approaches.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，推荐系统已经从基本的最近邻方法发展到个性化推荐，再到上下文感知推荐，从批量推荐到实时推荐，从基本的启发式方法，如相似度计算，到更精确、更复杂的机器学习方法。
- en: In the early stages of these recommender systems, only user ratings on products
    were used for generating recommendations. At this time, researchers used only
    the available ratings information. They simply applied heuristic approaches such
    as similarity calculation using Euclidean distances, the Pearson coefficient,
    cosine similarity, and so on. These approaches were well received and surprisingly
    they perform quite well even today.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些推荐系统的早期阶段，仅使用产品上的用户评分来生成推荐。在这个时候，研究人员只使用了可用的评分信息。他们简单地应用了启发式方法，如使用欧几里得距离、皮尔逊系数、余弦相似度等相似度计算方法。这些方法得到了良好的反响，并且令人惊讶的是，即使今天，它们的性能仍然相当不错。
- en: This first generation of recommendation engines is called collaborative filtering
    or neighborhood method recommenders. Though they perform very well, these recommenders
    come with their own set of limitations such as cold-start problems; that is to
    say, they failed to recommend products to new users with no rating information
    and recommend new products with no ratings to the users. Also these recommenders
    failed to handle scenarios where the data is very sparse, so user ratings on products
    are much less.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这一代推荐引擎被称为协同过滤或邻域方法推荐器。尽管它们表现非常出色，但这些推荐器也带来了一系列限制，例如冷启动问题；也就是说，它们未能向没有评分信息的新用户推荐产品，也未能向用户推荐没有评分的新产品。此外，这些推荐器还未能处理数据非常稀疏的场景，因此产品上的用户评分要少得多。
- en: In order to overcome these limitations, new approaches have been developed.
    For example, in order to handle very large user-rating with high data sparsity,
    mathematical approaches such as Matrix Factorization and singular value decomposition
    methods have been used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些限制，已经开发出新的方法。例如，为了处理具有高数据稀疏性的非常大的用户评分，已经使用了如矩阵分解和单值分解等数学方法。
- en: To handle the cold-start problem, new approaches such as content-based recommendation
    systems have been developed. These recommender systems opened the door to many
    more opportunities such as personalized recommenders systems, which enabled them
    to recommend products to each user on an individual level. In this approach, instead
    of rating information, user personal preferences and product features are considered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理冷启动问题，已经开发出新的方法，如基于内容的推荐系统。这些推荐系统为许多更多机会打开了大门，例如个性化推荐系统，这使得它们能够针对每个用户在个体层面上推荐产品。在这种方法中，不是考虑评分信息，而是考虑用户的个人偏好和产品特征。
- en: '![Evolution of recommendation engines](img/image00227.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![推荐引擎的演变](img/image00227.jpeg)'
- en: In the beginning, similarity calculations were used in content-based recommenders,
    but with advancements in technology and infrastructure more advanced methods such
    as machine-learning models have replaced the heuristic methods. These new machine
    models have improved the accuracy of the recommendations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初，基于内容的推荐者使用了相似度计算，但随着技术和基础设施的进步，更先进的方法，如机器学习模型，已经取代了启发式方法。这些新的机器模型提高了推荐的准确性。
- en: Though content-based recommenders have solved many of the shortcomings of collaborative
    filtering, these have their own inherent shortcomings such as serendipity, that
    is to say not being able to recommend new items outside the user's preference
    scope, which collaborative filtering can do.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于内容的推荐者解决了协同过滤的许多缺点，但它们也有自己的固有缺点，如偶然性，也就是说，无法推荐超出用户偏好范围的新项目，这是协同过滤可以做到的。
- en: To solve this problem, researchers started combining different recommendation
    models to come up with hybrid recommendation models, which are much more powerful
    than any of the individual models.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，研究人员开始结合不同的推荐模型，以提出混合推荐模型，这些模型比任何单个模型都要强大得多。
- en: With personal successful implementations of personalized recommendation engines,
    people started extending the personalization to other dimensions called contexts,
    such as the addition of location, time, group, and so on, and changed the set
    of recommendations with each context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着个性化推荐引擎的成功实施，人们开始将个性化扩展到其他维度，称为上下文，例如添加位置、时间、群体等，并针对每个上下文改变推荐集。
- en: With advancements in technology such as big data ecosystems, in-memory analytic
    tools such as Apache Spark, and recommendations in real time, the capability of
    handling very large databases has become possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着大数据生态系统、内存分析工具（如Apache Spark）和实时推荐等技术的进步，处理非常大的数据库的能力已成为可能。
- en: Currently we are moving into more personalization of aspects such as temporal
    dimension and ubiquitous ways of recommendation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在向更多个性化方面发展，如时间维度和无处不在的推荐方式。
- en: In the technology aspect the recommendations are moving from machine-learning
    approaches to more advanced neural network deep-learning approaches.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术方面，推荐系统的建议正从机器学习方法转向更高级的神经网络深度学习方法。
- en: Nearest neighborhood-based recommendation engines
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于最近邻的推荐引擎
- en: 'As the name suggests, neighborhood-based recommender systems considers the
    preferences or likes of the user community or users of the neighborhood of an
    active user before making suggestions or recommendations to the active user. The
    idea for neighborhood-based recommenders is very simple: given the ratings of
    a user, find all the users similar to the active user who had similar preferences
    in the past and then make predictions regarding all unknown products that the
    active user has not rated but are being rated in their neighborhood:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '正如其名所示，基于最近邻的推荐系统在向活跃用户做出建议或推荐之前，会考虑活跃用户社区或邻居用户的偏好或喜好。基于最近邻推荐者的想法非常简单：给定用户的评分，找到所有过去有相似偏好的与活跃用户相似的用户，然后对活跃用户尚未评分但在其邻居中被评分的所有未知产品做出预测： '
- en: '![Nearest neighborhood-based recommendation engines](img/image00228.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![基于最近邻的推荐引擎](img/image00228.jpeg)'
- en: While considering the preferences or tastes of neighbors, we first calculate
    how similar the other users are to the active user and then unrated items from
    the user community are recommended to the user following predictions. Here the
    active user is the person to whom the system is serving recommendations. Since
    similarity calculations are involved, these recommender systems are also called
    similarity-based recommender systems. Also, since preferences or tastes are considered
    collaboratively from a pool of users, these recommender systems are also called
    collaborative filtering recommender systems. In these types of systems, the main
    actors are the users, products, and user's preference information such as rating/ranking/liking
    towards the products.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑邻居的偏好或口味时，我们首先计算其他用户与活跃用户之间的相似度，然后根据预测向用户推荐用户社区中未评分的项目。在这里，活跃用户是系统提供推荐的人。由于涉及相似度计算，这些推荐系统也被称为基于相似度的推荐系统。此外，由于偏好或口味是从一组用户中协同考虑的，因此这些推荐系统也被称为协同过滤推荐系统。在这些类型的系统中，主要角色是用户、产品和用户的偏好信息，如对产品的评分/排名/喜欢。
- en: 'The following image is an example from Amazon showing a neighborhood case:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是亚马逊的一个示例，展示了邻域案例：
- en: '![Nearest neighborhood-based recommendation engines](img/image00229.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![基于最近邻推荐引擎](img/image00229.jpeg)'
- en: 'These heuristic-based methods are based on the following assumptions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基于启发式的方法基于以下假设：
- en: People with similar preferences in the past have similar preferences in the
    future
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去有相似偏好的用户在未来也会有相似偏好
- en: People's preferences will remain stable and consistent in the future
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们的偏好在未来将保持稳定和一致
- en: 'The collaborative filtering systems come in two flavors:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤系统分为两种类型：
- en: User-based collaborative filtering
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤
- en: Item-based collaborative filtering
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤
- en: 'These neighborhood methods are employed when we have only the users'' interaction
    data of the products, such as ratings, like/unlike, view/not. Unlike content-based
    recommendations, which will be explained in the next section, they do not consider
    any features of the products or personal preferences of the user for the products:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只有产品的用户交互数据（如评分、喜欢/不喜欢、查看/不查看）时，会采用这些邻域方法。与下一节将要解释的内容相关的基于内容的推荐不同，它们不考虑产品的任何特征或用户对产品的个人偏好：
- en: '![Nearest neighborhood-based recommendation engines](img/image00230.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![基于最近邻推荐引擎](img/image00230.jpeg)'
- en: User-based collaborative filtering
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤
- en: As previously mentioned, the basic intuition behind user-based collaborative
    filtering systems is that people with similar tastes in the past will like similar
    items in future as well. For example, if user A and user B have very similar purchase
    histories and if user A buys a new book which user B has not yet seen then we
    can suggest this book to user B as they have similar tastes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，基于用户的协同过滤系统背后的基本直觉是，过去有相似口味的用户将来也会喜欢相似的项目。例如，如果用户A和用户B有非常相似的购买历史，并且如果用户A购买了一本用户B尚未看过的书，那么我们可以向用户B推荐这本书，因为他们有相似的口味。
- en: 'Let us try to understand user-based collaborative filtering with an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来尝试理解基于用户的协同过滤：
- en: '**Problem Statement:** Imagine we have a dataset used in [Chapter 2](part0020.xhtml#aid-J2B82
    "Chapter 2. Build Your First Recommendation Engine"), *Build Your First Recommendation
    Engine* containing the reviewers'' ratings given to movies on a movie review site.
    The task at hand is to recommend movies to the reviewers:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题陈述**：想象我们有一个数据集，用于[第2章](part0020.xhtml#aid-J2B82 "第2章。构建你的第一个推荐引擎")“构建你的第一个推荐引擎”，其中包含电影评论网站上评论者对电影的评分。当前的任务是为评论者推荐电影：'
- en: '![User-based collaborative filtering](img/image00231.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![基于用户的协同过滤](img/image00231.jpeg)'
- en: 'Before we learn the recommendation approach, the first step is to analyze the
    data at hand. Let us analyze the data step-by-step as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习推荐方法之前，第一步是分析手头的资料。让我们按以下步骤逐步分析数据：
- en: A collection of users who have interacted with the application
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与应用程序互动的用户集合
- en: A movie catalog of all the available movies
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可用电影的目录
- en: We have individual users' ratings of movies
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有个人用户对电影的评分
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that each user has not rated all of the movies but only a few movies from
    the entire catalog.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个用户并没有对所有电影进行评分，而只是对整个目录中的一些电影进行了评分。
- en: The first step is to find similar users for an active user and then suggest
    new movies that this active user has not seen but similar users have seen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是找到活跃用户的相似用户，然后推荐该活跃用户尚未观看但相似用户已观看的新电影。
- en: 'This can be summarized in two steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以总结为两个步骤：
- en: Calculate the similarity between users using the rating information of the movies.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用电影的评分信息计算用户之间的相似度。
- en: For each active user, consider the movies that are not rated by them but rated
    by other users. Predict the unknown ratings for the non-rated movies for the active
    user.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个活跃用户，考虑那些他们未评分但其他用户已评分的电影。预测活跃用户对未评分电影的未知评分。
- en: 'In the preceding tabular data, let us recommend new movies to our active user,
    Jack Mathews:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格数据中，让我们为我们的活跃用户Jack Mathews推荐新电影：
- en: The first step is to look for similar users to Jack. We observe by looking at
    the dataset that Gene Seymour and Mick Lasalle are very similar to Jack Mathews.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是寻找与Jack相似的活跃用户。通过观察数据集，我们发现Gene Seymour和Mick Lasalle与Jack Mathews非常相似。
- en: The similarity between users is calculated based on the ratings given by users.
    The most common approaches for calculating the similarity are Euclidean distance
    and the Pearson correlation coefficient.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户之间的相似度是基于用户给出的评分计算的。计算相似度的最常见方法包括欧几里得距离和皮尔逊相关系数。
- en: 'For now we choose Euclidean distance to find the similarity calculation given
    by the equation that follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前我们选择使用以下方程给出的欧几里得距离来计算相似度：
- en: '![User-based collaborative filtering](img/image00232.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![基于用户的协同过滤](img/image00232.jpeg)'
- en: The intuition behind using Euclidean distance is that we represent users, movies,
    and ratings as points in a vector space with users on the *x* axis, movies on
    the *y* axis, and ratings as points in vector space. Now that we have projected
    our data into vector space, similarity or closeness between two points can be
    calculated using Euclidean distance, and the Pearson correlation coefficient.
    The detailed explanation for the similarity measures will be explained in [Chapter
    4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining Techniques Used in Recommendation
    Engines"), *Data Mining Techniques Used in Recommendation Engines*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用欧几里得距离背后的直觉是，我们将用户、电影和评分表示为向量空间中的点，用户位于*x*轴上，电影位于*y*轴上，评分作为向量空间中的点。现在我们已经将数据投影到向量空间中，可以使用欧几里得距离和皮尔逊相关系数来计算两点之间的相似度或接近度。相似度度量方法的详细解释将在[第4章](part0029.xhtml#aid-RL0A2
    "第4章。推荐引擎中使用的数据挖掘技术")，*推荐引擎中使用的数据挖掘技术*中解释。
- en: '![User-based collaborative filtering](img/image00233.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![基于用户的协同过滤](img/image00233.jpeg)'
- en: Using the previous equation we can calculate the similarity between all the
    reviewers as shown in the table. We observe from the table that our active user,
    Toby, is most similar to Lisa Rose.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的方程，我们可以计算所有评论者之间的相似度，如表所示。从表中我们可以观察到，我们的活跃用户Toby与Lisa Rose最为相似。
- en: 'As a second step we predict the ratings for the unknown movie *Just My Luck*
    for Jack by calculating the weighted average of the ratings given by other reviewers
    for *Just My Luck* given in the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二步，我们通过计算以下其他评论者对《Just My Luck》给出的评分的加权平均值来预测Jack对未知电影《Just My Luck》的评分：
- en: 'The rating for Jack for the *Just my Luck* movie is given by the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Jack 对电影《Just my Luck》的评分如下：
- en: '*(3*0.9285+1.5*0.944+3*0.755+2*0.327)/(0.8934051+0.3812464+0.9912407+0.9244735)=
    2.23*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*(3*0.9285+1.5*0.944+3*0.755+2*0.327)/(0.8934051+0.3812464+0.9912407+0.9244735)=
    2.23*'
- en: In the above equation, we have multiplied the similarity values of all reviewers
    with Jack by the ratings given by them to the *Just My Luck* movie and then summed
    all the values. This total sum is divided by the sum of similarity values to normalize
    the final rating. Similarly we can predict unknown movie ratings for all the reviews
    and then recommendations can be made.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方程中，我们将Jack与所有评论者的相似度值乘以他们对《Just My Luck》电影的评分，然后对所有值求和。这个总和除以相似度值的总和，以归一化最终的评分。同样，我们可以预测所有评论的未知电影评分，然后进行推荐。
- en: Item-based collaborative filtering
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于项目的协同过滤
- en: 'In item-based collaborative filtering recommender systems, unlike user-based
    collaborative filtering, we use similarity between items instead of similarity
    between users. The basic intuition for item-based recommender systems is that
    if a user liked item A in the past they might like item B, which is similar to
    item A:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于项目的协同过滤推荐系统中，与基于用户的协同过滤不同，我们使用项目之间的相似度而不是用户之间的相似度。基于项目的推荐系统的基本直觉是，如果用户过去喜欢项目A，他们可能会喜欢与项目A相似的项目B：
- en: '![Item-based collaborative filtering](img/image00234.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![基于项目的协同过滤](img/image00234.jpeg)'
- en: 'In user-based collaborative filtering, there are a few downs sides:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于用户的协同过滤中，存在一些缺点：
- en: The system suffers with performance if the user ratings are very sparse, which
    is very common in the real world where users will rate only a few items from a
    large catalog
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户评分非常稀疏，系统性能会受到影响，这在现实世界中非常常见，用户只会对大量目录中的少数项目进行评分。
- en: The computing cost for calculating the similarity values for all the users is
    very high if the data is very large
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据量很大，计算所有用户相似度值的计算成本非常高。
- en: If user profiles or user inputs change quickly then we have to re-compute the
    similarity values that come with a high computational cost
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户配置文件或用户输入快速变化，那么我们必须重新计算伴随高计算成本的相似度值。
- en: Item-based recommendation engines handle these shortcomings by calculating similarity
    between items or products instead of calculating similarity between users, thereby
    reducing the computational cost. Since the item catalog doesn't change rapidly,
    we don't have to re-compute calculations very often.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基于项目的推荐引擎通过计算项目或产品之间的相似度而不是计算用户之间的相似度来处理这些缺点，从而降低计算成本。由于项目目录变化不快，我们不必经常重新计算。
- en: 'As with a user-based collaborative filtering approach there are two steps for
    an item-based collaborative approach:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于用户的协同过滤方法一样，基于项目的协同方法有两个步骤：
- en: Calculating the similarity between items.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算项目之间的相似度。
- en: Predicting the ratings for the non-rated item for an active user by making use
    of previous ratings given to other similar items.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过利用对其他相似项目给出的先前评分来预测活跃用户的未评分项目的评分。
- en: 'The most common similarity measure used for this approach is cosine similarity.
    Cosine similarity calculates the similarity between two n-dimensional vectors
    by the angle between them in the vector space. Cosine similarity is given by the
    following equation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此方法的最常见的相似度度量是余弦相似度。余弦相似度通过向量空间中两个n维向量之间的角度来计算两个向量之间的相似度。余弦相似度由以下方程给出：
- en: '![Item-based collaborative filtering](img/image00235.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![基于项目的协同过滤](img/image00235.jpeg)'
- en: When applying cosine similarity to recommender systems, we consider the item
    column as the n-dimensional vector and the similarity between two items as the
    angle between them. The smaller the angle, the more similar the items.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当将余弦相似度应用于推荐系统时，我们将项目列视为n维向量，并将两个项目之间的相似度视为它们之间的角度。角度越小，项目越相似。
- en: 'For example, in the previous dataset, if we want to predict the rating for
    Toby for the movie *Lady in the Water*, first we have to identify movies similar
    to *Lady in the Water*. Using the previous cosine equation we can calculate the
    similarity for all the items. The following table shows the similarity values
    for all the movies:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在先前的数据集中，如果我们想预测Toby对电影《水之女》的评分，首先我们必须识别与《水之女》相似的电影。使用先前的余弦方程，我们可以计算所有项目的相似度。下表显示了所有电影的相似度值：
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Item-based similarity is calculated only for co-rated items.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 基于项目的相似度仅计算共同评分的项目。
- en: '![Item-based collaborative filtering](img/image00236.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![基于项目的协同过滤](img/image00236.jpeg)'
- en: From the preceding table, we see that *You, me and Dupree* is the most similar
    to *Lady in the Water (0.8897565)*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的表中，我们可以看到《你、我和杜普里》与《水之女》（0.8897565）最为相似。
- en: 'We now predict the rating for the *Lady in the Water* movie by calculating
    the weighted sum of ratings assigned to movies similar to *Lady in the Water*
    by Toby. That is to say, we take the similarity score of *Lady in the Water* for
    each movie rated by Toby, multiply it by the corresponding rating, and sum up
    all the scores for all the rated movies. This final sum is divided by the total
    sum of similarity scores of *Lady in the Water* given as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过计算Toby对与《水之女》相似的电影的评分的加权总和来预测《水之女》电影的评分。也就是说，我们取《水之女》对每个Toby评过分的电影的相似度得分，乘以相应的评分，然后将所有评分电影的所有得分加起来。这个最终的总和除以下列给出的《水之女》的相似度得分总和：
- en: 'Rating for *Lady in the Water*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 《水之女》评分：
- en: '*(0.795*4.5 + 0.814*4 + 0.889*1)/(0.795+0.814+0.889) = 3.09*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (0.795*4.5 + 0.814*4 + 0.889*1)/(0.795+0.814+0.889) = 3.09
- en: Similarly we can calculate ratings for all other users for movies using the
    preceding equation. In [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining
    Techniques Used in Recommendation Engines"), *Data Mining Techniques Used in Recommendation
    Engines*, we deal with other similarity metrics that can be used in item-based
    recommendations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用前面的方程式计算所有其他用户对电影的评分。在[第4章](part0029.xhtml#aid-RL0A2 "第4章。推荐引擎中使用的数据挖掘技术")《推荐引擎中使用的数据挖掘技术》中，我们讨论了可以用于基于项目的推荐的其他相似度度量。
- en: Advantages
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: Easy to implement
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易实现
- en: Neither the content information of the products nor the users' profile information
    is required for building recommendations
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建推荐时不需要产品的内容信息或用户的个人资料信息
- en: New items are recommended to users giving a surprise factor to the users
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户推荐新项目，给用户带来惊喜因素
- en: Disadvantages
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: This approach is computationally expensive as all the user, product, and rating
    information is loaded into the memory for similarity calculations.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法在计算上非常昂贵，因为所有用户、产品和评分信息都需要加载到内存中进行相似度计算。
- en: This approach fails for new users where we do not have any information about
    the users. This problem is called the cold-start problem.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法对于新用户无效，因为我们没有关于用户的任何信息。这个问题被称为冷启动问题。
- en: This approach performs very poorly if we have little data.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们数据很少，这种方法的表现非常差。
- en: Since we do not have content information about users or products, we cannot
    generate recommendations accurately based on rating information only.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们没有用户或产品的内容信息，我们无法仅基于评分信息准确生成推荐。
- en: Content-based recommender systems
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的推荐系统
- en: In the previous section, we saw that the recommendations were generated by considering
    only the rating or interaction information of the products by the users, that
    is to say that suggesting new items for the active user is based on the ratings
    given to those new items by similar users to the active user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到推荐是通过仅考虑用户对产品的评分或交互信息来生成的，也就是说，为活跃用户推荐新项目是基于活跃用户对那些新项目的评分。
- en: Let's take the case of a person who has given a 4-star rating to a movie. In
    a collaborative filtering approach we only consider this rating information for
    generating recommendations. In real life, a person rates a movie based on the
    features or content of the movie such as its genre, actor, director, story, and
    screenplay. Also the person watches a movie based on their personal choices. When
    we are building a recommendation engine to target users at a personal level, the
    recommendations should not be based on the tastes of other similar people but
    should be based on the individual users' tastes and the contents of the products.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个给电影评了4星的人为例。在协同过滤方法中，我们只考虑这个评分信息来生成推荐。在现实生活中，一个人是根据电影的特征或内容来评分的，比如它的类型、演员、导演、故事和剧本。此外，一个人是根据自己的个人选择来看电影的。当我们构建一个针对个人层面的推荐引擎时，推荐不应该基于其他类似人的口味，而应该基于个人用户的口味和产品的内容。
- en: A recommendation that is targeted at a personalized level and that considers
    individual preferences and contents of the products for generating recommendations
    is called a content-based recommender system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一种针对个性化水平且考虑个人偏好和产品内容的推荐称为基于内容的推荐系统。
- en: Another motivation for building content-based recommendation engines is that
    they solve the cold-start problem that new users face in the collaborative filtering
    approach. When a new user comes, based on the preferences of the person we can
    suggest new items that are similar to their tastes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 构建基于内容的推荐引擎的另一个动机是它们解决了协同过滤方法中新用户面临的新手问题。当一个新用户到来时，基于该人的偏好，我们可以建议一些与他们的口味相似的新项目。
- en: 'Building content-based recommender systems involves three main steps, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建基于内容的推荐系统涉及三个主要步骤，如下：
- en: Generating content information for products.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为产品生成内容信息。
- en: Generating a user profile and preferences with respect to the features of the
    products.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成用户配置文件和与产品特征相关的偏好。
- en: 'Generating recommendations and predicting a list of items that the user might
    like:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成推荐并预测用户可能喜欢的项目列表：
- en: '![Content-based recommender systems](img/image00237.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![基于内容的推荐系统](img/image00237.jpeg)'
- en: '**Item profile generation**: In this step, we extract the features that represent
    the product. Most commonly the content of the products is represented in the vector
    space model with product names as rows and features as columns. Usually the content
    of the products will either be structured data or unstructured data. Structured
    data will be obtained from the databases; unstructured features would include
    the reviews, tags, or textual properties associated in websites. In the item profile
    generation step, we have to extract relevant features and their relative importance
    score associated with the product.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目配置文件生成**：在这个步骤中，我们提取代表产品的特征。最常见的是，产品的内容以行表示产品名称，列表示特征的空间模型表示。通常，产品的内容将是结构化数据或非结构化数据。结构化数据将从数据库中获得；非结构化特征将包括网站中关联的评论、标签或文本属性。在项目配置文件生成步骤中，我们必须提取相关特征及其与产品相关的相对重要性分数。'
- en: For generating the item profile we use the **term frequency inverse document
    frequency** (**tf-idf**) for calculating the feature relative importance associated
    with the item. Since we represent the item features in vector representation,
    we may use tf-idf, which will be explained in detail in [Chapter 4](part0029.xhtml#aid-RL0A2
    "Chapter 4. Data Mining Techniques Used in Recommendation Engines"), *Data Mining
    Techniques Used in Recommendation Engines*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成项目配置文件，我们使用**词频逆文档频率**（**tf-idf**）来计算与项目相关的特征相对重要性。由于我们用向量表示来表示项目特征，我们可以使用tf-idf，这将在[第4章](part0029.xhtml#aid-RL0A2
    "第4章。推荐引擎中使用的数据挖掘技术")*推荐引擎中使用的数据挖掘技术*中详细解释。
- en: 'Let us try to better understand with an example. As we''ve already mentioned,
    for content-based recommendation engines, we require additional content information
    about Movies, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更好地理解。正如我们之前提到的，对于基于内容的推荐引擎，我们需要关于电影等额外内容信息，如下所示：
- en: '![Content-based recommender systems](img/image00238.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![基于内容的推荐系统](img/image00238.jpeg)'
- en: 'The first thing we have to do is to create an item profile using tf-idf, by
    means of the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是使用tf-idf创建一个项目配置文件，通过以下步骤：
- en: 'Create a term frequency matrix containing the frequency count of each term
    in each document; that is to say, in our case, the presence of each genre in each
    movie. The number 1 represents the presence of the genre and 0 represents the
    absence of the genre:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含每个文档中每个术语频率计数的术语频率矩阵；也就是说，在我们的案例中，每个电影中每个类别的存在情况。数字1代表类别的存在，0代表类别的缺失：
- en: '![Content-based recommender systems](img/image00239.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![基于内容的推荐系统](img/image00239.jpeg)'
- en: 'The next step is to create inverse document frequency given by the following
    formula:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建以下公式给出的逆文档频率：
- en: '*Idf = Log(total number of documents/document frequency)*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*Idf = Log(文档总数/文档频率)*'
- en: 'Here, the total number of documents is the number of movies, and the document
    frequency is the total number of times they have occurred in all the documents:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，文档总数是电影的数量，文档频率是它们在所有文档中出现的总次数：
- en: '![Content-based recommender systems](img/image00240.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![基于内容的推荐系统](img/image00240.jpeg)'
- en: 'The final step is to create a *tf-idf* matrix given by the following formula:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建以下公式给出的*tf-idf*矩阵：
- en: '*tf*idf*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*tf*idf*'
- en: '![Content-based recommender systems](img/image00241.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![基于内容的推荐系统](img/image00241.jpeg)'
- en: User profile generation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成用户配置文件
- en: In this step, we build the user profile or preference matrix matching the product
    content. In general we build the user profile or features that are in common with
    the product content as it makes more sense to compare both user and item profiles
    and calculate the similarity between them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们构建与产品内容相匹配的用户配置文件或偏好矩阵。一般来说，我们构建与产品内容共有的用户配置文件或特征，因为这样比较用户和项目配置文件并计算它们之间的相似度更有意义。
- en: 'Let''s consider the following dataset showing the viewed history of each user.
    If there is a value of 1 in the matrix cell, it means that the user has seen the
    movie. This information gives us their preference of movies:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下数据集，它显示了每个用户的观看历史。如果矩阵单元格中的值为1，则表示用户已经看过这部电影。这些信息给出了他们对电影的偏好：
- en: '![User profile generation](img/image00242.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![用户配置文件生成](img/image00242.jpeg)'
- en: 'From the preceding information, we will create a user profile that can be used
    to compare with the item profile; that is to say, we now create a user profile
    that contains the user preference of the item features, to genres, in our case.
    Dot product between the tf-idf and user preference matrix will give the user affinity
    for each of the genres, as shown in the following table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的信息中，我们将创建一个用户配置文件，可以与项目配置文件进行比较；也就是说，我们现在创建一个包含用户对项目特征偏好的用户配置文件，在我们的例子中是对类型的偏好。tf-idf和用户偏好矩阵的点积将给出每个类型的用户亲和度，如下表所示：
- en: '*dotProduct(Tf-idf, userPreference matrix)*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*dotProduct(Tf-idf, userPreference matrix)*'
- en: '![User profile generation](img/image00243.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![用户配置文件生成](img/image00243.jpeg)'
- en: 'With user profiles and item profiles at hand, the next step would be to estimate
    the degree to which the user will prefer each of the items. We can now use cosine
    similarity to compute the user preference for each of the items. In our example,
    the cosine similarity between user and item profiles gives the following results:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有用户配置文件和项目配置文件的情况下，下一步将是估计用户将更喜欢每个项目的程度。我们现在可以使用余弦相似度来计算每个项目的用户偏好。在我们的例子中，用户和项目配置文件之间的余弦相似度给出了以下结果：
- en: '*cosineSimilarity(userProfile,ItemProfile)*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*cosineSimilarity(userProfile,ItemProfile)*'
- en: '![User profile generation](img/image00244.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![用户配置文件生成](img/image00244.jpeg)'
- en: From the preceding table we can conclude that the greater the cosine angle the
    more likely the user is to like a movie and hence it can be recommended to the
    user.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表格中我们可以得出结论，余弦角度越大，用户越有可能喜欢一部电影，因此可以推荐给用户。
- en: 'Now that we have made the recommendations, let us take a step back from gathering
    user preference data. Usually there are two ways of capturing user data; these
    are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做出了推荐，让我们退一步，从收集用户偏好数据的角度来看。通常有两种方法来捕获用户数据；如下所述：
- en: Explicitly ask the user for their preferences regarding the product's features,
    and store them.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确询问用户对产品特征的偏好，并将它们存储起来。
- en: Implicitly capture the user interaction data on products such as browsing history,
    rating history, and purchase history, and build the user preferences to the product
    features. In [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining Techniques
    Used in Recommendation Engines"), *Data Mining Techniques Used in Recommendation
    Engines*, and [Chapter 5](part0037.xhtml#aid-1394Q1 "Chapter 5. Building Collaborative
    Filtering Recommendation Engines"), *Building Collaborative Filtering Recommendation
    Engines,* we build recommendation engines using explicit and implicit user activity
    examples.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式地捕获用户在产品上的交互数据，如浏览历史、评分历史和购买历史，并将用户偏好构建到产品特征中。在[第4章](part0029.xhtml#aid-RL0A2
    "第4章。推荐引擎中使用的数据挖掘技术")《推荐引擎中使用的数据挖掘技术》和[第5章](part0037.xhtml#aid-1394Q1 "第5章。构建协同过滤推荐引擎")《构建协同过滤推荐引擎》中，我们使用显式和隐式的用户活动示例构建推荐引擎。
- en: The approach that we have followed until now for building a content-based recommendation
    system is based on similarity calculation. We may also apply supervised machine-learning
    approaches such as classification for predicting the most probable products the
    user might like.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至今为止所采用的基于内容推荐系统构建的方法是基于相似度计算的。我们还可以应用诸如分类等监督机器学习方法来预测用户可能喜欢的最可能的产品。
- en: Recommender systems using machine learning or any other mathematical, statistical
    models to generate recommendations are called model-based systems. In classification-based
    approaches which fall under model-based recommender systems, first we build a
    machine-learning model by using a user profile and item profile to predict if
    a user likes/dislikes an item. Supervised classification tasks such as logistic
    regression, KNN-classification methods, probabilistic methods, and so on, can
    be used. Model-based recommendation engines are discussed in the next section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Content-based recommender systems target at an individual level
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations are generated using the user preferences alone rather than the
    user community as with collaborative filtering
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These approaches can be employed in real time as the recommendation model doesn't
    need to load all the data for processing or generating recommendations
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy is high compared to collaborative approaches as they deal with the
    content of the products instead of rating information alone
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cold-start problem can be easily handled
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the system is more personalized the generated recommendations will become
    narrowed down to only user preferences when more user information comes into the
    system
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, no new products that are not related to the user preferences will
    be shown to the user
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will not be able to look at what is happening around them or what's
    trending
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context-aware recommender systems
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years there has been an evolution in recommender systems from neighborhood
    approaches to personalized recommender systems that are targeted to individual
    users. These personalized recommender systems have become a huge success as this
    is useful at end user level, and for organizations these systems become catalysts
    to increase their business.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Though the personalized recommender systems were targeted at the individual
    user level and provided recommendations based on the personal preferences of the
    users, there was scope to refine the systems. For example, the same person in
    different places might have different requirements. Likewise, the same person
    has different requirements at different times:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Context-aware recommender systems](img/image00245.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Our intelligent recommender systems should be evolved enough to cater to the
    needs of the users for different places, at different times. The recommender system
    should be robust enough to suggest cotton shirts to a person during summer and
    leather jackets during winter. Similarly, based on the time of day, suggesting
    good restaurants serving a person''s personal choice of breakfast or dinner would
    be very helpful. These kinds of recommender systems that consider location, time,
    mood, and so on, that defines the context of the user and suggests personalized
    recommendations, are called **context aware recommender systems**:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Context-aware recommender systems](img/image00246.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: The preceding image illustrates a recommendation engine suggesting coffee in
    cold weather.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Context definition
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what exactly is context? In general, context represents the present state
    of the user. The context of a user can be anything such as place, time, day, season,
    mood, device, whether the user is alone, at the office, on vacation, with family,
    with friends, life events, and so on. Since people will have different needs in
    different contexts, the recommendation systems can capture the context information
    of the user and refine their suggestions accordingly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: For example, a travel vacation system may consider season, place, and time as
    context for refining the suggestions; an e-commerce website can consider the life
    event and user purchases for context aware recommendations, and a food website
    may consider time of day and place information while recommending restaurants.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'How are context aware systems designed? Until now we have considered recommendations
    as a two-dimensional problem, that is to say user preferences and item representations.
    With the inclusion of context as a new dimension we can build context aware recommendations
    as a three-dimensional problem:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '*Recommendations = User x Item x Context*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Context definition](img/image00247.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: Let us revisit the same example as we did in the content-based recommendations,
    where we considered the user profile and the item profile to generate the user
    ratings for each of the items based on user preferences by computing the similarity
    between the user profile and the item profile. Now, in context aware systems,
    we include context to generate the rankings for items with respect to user preference
    and context.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can assume our recommendation has captured the movie watching
    patterns of the user for a weekday, weekend, and holiday. From this context information,
    we extract the affinity of each user for the movie contents. For example, consider
    the following preferences for TOBY for each of the contexts for the movie contents:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Context definition](img/image00248.jpeg)![Context definition](img/image00249.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Let us first create a user profile for TOBY for each of the contexts for all
    the movie content. A dot product between the context matrix and user profile matrix
    gives us the user profile for all the contexts:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '*Dotproduct(user profile, context matrix)* for TOBY:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Context definition](img/image00250.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: We have now calculated the preference of TOBY for each context for the movie
    context. The next step would be to calculate the ranking of each movie for TOBY
    for all the contexts.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Cosine similarity (contextual movie content preference matrix, item profile):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Context definition](img/image00251.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Now we have the context level ranking for movies for TOBY, we can suggest movies based
    on the context.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding example, we understood that context-aware recommender systems
    are content-based recommenders with the inclusion of a new dimension called context.
    In context-aware systems, recommendations are generated in two steps, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Generate a list of recommendations of the products for each user based on the
    user's preferences; that is, content-based recommendations.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter out the recommendations that are specific to a current context.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The most common approaches for building context-aware recommender systems are as
    follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Post-filtering approaches
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-filtering approaches
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-filtering approaches
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the pre-filtering approach, context information is applied to the user profile
    and product content. This step will filter out all the non-relevant features,
    and final personalized recommendations are generated on the remaining feature
    set. Since the filtering of features is performed before generating personalized
    recommendations, these are called pre-filtering approaches:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Pre-filtering approaches](img/image00252.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Post-filtering approaches
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In post-filtering approaches, firstly personalized recommendations are generated
    based on the user profile and the product catalogue, then the context information
    is applied to filter out the relevant products to the user for the current context:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Post-filtering approaches](img/image00253.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: Advantages
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Context aware systems are much more advanced than the personalized content-based
    recommenders as these systems will be constantly in sync with user movements and
    generate recommendations as per the current context
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These systems have more of a real-time nature
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serendipity or surprise factor, as with other personalized recommenders, will
    be missing in these types of recommendation as well
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid recommender systems
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collaborative filtering systems and content-based recommender systems are effective
    and cater to a wide range of needs. They have quite successful implementations
    but each independently has its own limitations. Research has started moving in
    the direction of combining both collaborative filtering and content-based recommendations.
    This new type of recommender system formed by combining collaborative filtering
    with content-based methods is called a hybrid recommender system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The choice of combining the different recommendation approaches is up to the
    researcher or the person implementing the hybrid recommendation engine based on
    the problem statement and business needs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common approaches followed for building a hybrid system are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Weighted method
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed method
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching method
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cascade method
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature combination method
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature augmentation
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meta-level
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weighted method
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this method the final recommendations would be the combination, mostly linear,
    of recommendation results of all the available recommendation engines. At the
    beginning of the deployment of this weighted hybrid recommendation engine, equal
    weights will be given to each of the results from available recommendation engines,
    and gradually the weights will be adjusted by evaluating the responses from the
    users to recommendations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Mixed method
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mixed method is applicable in places where we can mix results from all the
    available recommenders. These are mostly employed in places where it is not feasible
    to achieve a score for a product by all the available recommender systems because
    of data sparsity. Hence recommendations are generated independently and are mixed
    before being sent to the user.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Cascade method
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this approach, recommendations are generated using collaborative filtering.
    The content-based recommendation technique is applied and then final recommendations
    / a ranked list will be given as the output.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Feature combination method
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The feature combination method, in which we combine the features of different
    recommender systems and final recommendation approach, is applied on the combined
    feature sets. In this technique, we combine both User-Item preference features
    extracted from content based recommender systems and, User-Item ratings information,
    and consider a new strategy to build Hybrid recommender systems.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Feature combination method](img/image00254.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Advantages
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Issues such as the cold-start problem and data sparsity can be handled
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These systems are much more robust and scalable than any of the individual models
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of methods leads to an improvement in accuracy
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-based recommender systems
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now we have been focusing on neighborhood approaches which involve similarity
    calculations between users or products for collaborative filtering approaches
    or represent the user and item contents in a vector space model, and find similarity
    measures to identify items similar to the preferences of the users. The main objective
    of the similarity-based approaches is to calculate the weights of the preferences
    of users for the products or product content and then use these feature weights
    for recommending items.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: These approaches have been very successful over the years and even today. But
    these approaches have their own limitations. Since entire data has to be loaded
    into the environment for similarity calculations, these approaches were also known
    as memory-based models. These memory-based models are very slow to respond in
    real-time scenarios when the amount of data is very large as all the data has
    to be loaded. Another limitation is that the weights calculated are not learned
    automatically as with machine-learning applications. The cold-start problem is
    another common limitation that memory-based or neighborhood-based methods suffer
    from.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In order to address these limitations, researchers started to apply more advanced
    methods to improve the performance of the recommendation engines such as probabilistic
    models, machine-learning models such as supervised and unsupervised models, and
    matrix approaches such as Matrix Factorization and single value decomposition.
    In the model-based approaches, using available historical data, a model is built
    with weights learned automatically. New predictions regarding the products will
    be made using the learned weights and then the final results ranked in a specific
    order before making recommendations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Probabilistic approaches
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a probabilistic approach, we build a probability model using the prior probabilities
    from the available data, and a ranked list of recommendations is generated by
    calculating the probability of liking/disliking of a product for each user. Most
    commonly the Naïve Bayes method is used in probabilistic approaches, which is
    a simple but powerful technique.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning approaches
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in content-based recommender systems, we can consider a recommendation
    problem as a machine-learning problem. Using historical user and product data,
    we can extract features and output classes and then build a machine learning model.
    A final ranked list of product recommendations is generated using the generated
    model. Many machine-learning approaches such as logistic regression, KNN classification,
    decision trees, SVM, clustering, and so on, can be used. These machine-learning
    approaches are applied for collaborative, content based, context aware, and hybrid
    recommender systems. In [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data
    Mining Techniques Used in Recommendation Engines"), *Data Mining Techniques Used
    in Recommendation Engines*, we learn in detail about each of the machine-learning
    approaches.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical approaches
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In these approaches, we assume that the ratings or interaction information
    of users on products are simple matrices. On these matrices we apply mathematical
    approaches to predict the missing ratings for the users. The most commonly used
    approaches are the Matrix Factorization model and single valued decomposition
    models:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Mathematical approaches](img/image00255.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: By applying matrix decomposition approaches we assume that we decompose the
    original rating matrix (R) into two new matrices (U, V) that represent the latent
    features of the users and movies.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In mathematical terms, we can decompose a matrix into two low rank matrices.
    In the preceding example, matrix R is decomposed into matrices U and V. Now when
    we multiply back U and V we get the original matrix R approximately. This concept
    is used in recommendation engines for filling up the unknown ratings in the original
    rating matrix, and recommendations are then ranked and suggested to the users.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining Techniques Used
    in Recommendation Engines"), *Data Mining Techniques Used in Recommendation Engines*
    we discuss these two approaches in more detail.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Model-based recommendations are much more accurate than the heuristic-based
    approaches such as neighborhood methods
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In heuristic methods the weights of products / product content is more static,
    whereas in model-based recommendations, the weights are established through auto-learning
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model-based approach extracts many unseen patterns using data-driven approaches
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about popular recommendation engine techniques
    such as collaborative filtering, content-based recommendations, context aware
    systems, hybrid recommendations, and model-based recommendation systems, with
    their advantages and disadvantages. There are different similarity methods such
    as cosine similarity, Euclidean distance, and the Pearson coefficient. Subcategories
    within each of the recommendations are also explained.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we learn about different data-mining techniques such as
    Neighborhood methods, machine learning methods used in recommendation engines,
    and their evaluation techniques such as RMSE and, Precision-Recall.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
