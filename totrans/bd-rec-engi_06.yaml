- en: Chapter 6. Building Personalized Recommendation Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation engines have been evolving very fast, with a lot of research
    also going into this field. Big multinational companies are investing huge amounts
    of money into this field. As mentioned earlier, right from the earlier models
    of recommendation engines such as collaborative filtering, these systems have
    been a huge success. With more and more revenues being generated through recommendation
    engines and more and more people using the Internet for their shopping needs,
    reading news, or for getting information related to health, business organizations
    have seen huge business in tapping this available user activities on the Internet.
    With the increase in the number of users of recommendation engines, and with more
    and more applications being powered by recommendation engines, users also started
    asking for personalized suggestions rather than community-based recommendations.
    This requirement of the user community was taken as the new challenge, and personalized
    recommendation engines have been built for providing suggestions at a personal
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all the industry domains are currently building recommendation engines
    that can recommend at personalized levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few personalized recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: Personalized news recommendations--Google News
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personalized health-care systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personalized travel recommendation systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personalized recommendations on Amazon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personalized movie recommendations on YouTube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the screenshot of personalized recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building Personalized Recommendation Engines](img/image00351.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the [Chapter 3](part0022.xhtml#aid-KVCC1 "Chapter 3. Recommendation Engines
    Explained"), *Recommendation Engines Explained*, we learned in detail about content-based
    recommender systems and context-aware recommender systems. In this chapter, we
    will recall these topics in brief and then move ahead to build content-based and
    context-aware recommender systems.
  prefs: []
  type: TYPE_NORMAL
- en: Personalized recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about two flavours of personalized recommenders:'
  prefs: []
  type: TYPE_NORMAL
- en: Content-based recommender systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context-aware recommender systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content-based recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building collaborative filtering is relatively easy. In the fifth chapter, we
    learned about building collaborative filtering recommender systems. While building
    those systems, we just considered the ratings given to a product and the information
    about whether a product is liked or not. With this minimal information, we built
    the systems. To many people's surprise, these systems performed very well. But
    these systems had their own limitations, such as the cold start problem explained
    in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Assume a case of a user, Nick, giving five-star rating to a movie, say *Titanic.*
    What could have made Nick give that rating? May be the story of the film, the
    actors in the movie, the background score, or the screenplay. These preferences
    for these features made Nick rate the movie. Wouldn't including this internal
    information of preferences for the product/features make more sense while building
    recommendations?
  prefs: []
  type: TYPE_NORMAL
- en: In collaborative filtering, the basic assumption is that people with similar
    taste in the past will have similar taste in the future. If we closely observe,
    this assumption may not apply in all cases. For example, if my neighbors have
    rated the thriller movie *The Exorcist highly*, that movie should not be suggested
    to me since I have a preference for romantic movies. I should instead get *Titanic,*
    which is of the romance genre, as a suggestion. I do not always have the same
    taste as my neighbors; I would be happy if I got suggestions solely based on my
    preferences and actions. Businesses have seen a lot of business opportunities
    in implementing these types of recommendations, known as personalized recommender
    systems, at an individual level.
  prefs: []
  type: TYPE_NORMAL
- en: Building a content-based recommendation system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In content-based recommender systems, we use the content information of both
    users and items while building recommendation engines. A typical content-based
    recommender system will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate user profiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate item profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the recommendation engine model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suggest the top N recommendations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We first generate user and item profiles from the available information. A profile
    typically contains preferences for the features of items and users (refer to [Chapter
    3](part0022.xhtml#aid-KVCC1 "Chapter 3. Recommendation Engines Explained"), *Recommendation
    Engines Explained* for details). Once the profiles are created, we choose a method
    to build the recommendation engine model. Many data-mining techniques such as
    classification, text similarity approaches such as *tf-idf* similarity, and Matrix
    factorization models can be applied for building content-based recommendation
    engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even employ multiple recommendation engine models and build hybrid recommendation
    engines to serve as content-based recommendations. A typical content recommender
    is depicted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a content-based recommendation system](img/image00352.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Content-based recommendation using R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start building a personalized recommendation engine in R. We choose the
    MovieLens dataset to build our system. In the previous section, we refreshed the
    concepts of content-based recommender systems. There are multiple ways we can
    build personalized recommenders; in this section, we will use the multiclass classification
    approach to build our basic content-based recommendation engine.
  prefs: []
  type: TYPE_NORMAL
- en: Using the classification approach, we are trying to build a model-based recommendation
    engine. Most recommender systems--either collaborative filtering or content-based--use
    neighbourhood methods to build the recommenders. Let's explore how we can use
    a supervised machine-learning approach to build the recommendation engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start writing the code, let''s discuss the steps for building the
    personalized recommender system. The following figure shows the order of steps
    we would be following to achieve our objective:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content-based recommendation using R](img/image00353.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step would always be to gather the data and pull it into the programming
    environment so that we may apply further steps. For our use case, we download
    the MovieLens dataset containing three sets of data, as defined next:'
  prefs: []
  type: TYPE_NORMAL
- en: Ratings data containing userID, itemID, rating, timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User data containing the user information, such as userID, age, gender, occupation,
    ZIP code, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movie data containing a certain movie's information, such as movieID, release
    date, URL, genre details, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second step would be preparing the data required to build the classification
    models. In this step, we extract the required features of the users and class
    labels to build the classification model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content-based recommendation using R](img/image00354.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For our example case, we define the ratings (1 to 5) given by the users as class
    labels, such as 1-3 rating as 0 and 4-5 rating as 1\. Thus, we will build a two-class
    classification model. Our model will predict the class label, given the input
    features for a given user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering why we are choosing binary classification instead of
    multiclass classification. The choice of model is left to the person building
    the recommender system; in our case, with the dataset we have chosen, binary class
    classification fits better than a multiclass classification. Readers are encouraged
    to try multiclass-classification for your understanding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We choose user demography and item features from user data and item data to
    form the features of our binary classification model. We extended the `User_item_rating`
    data by including features such as genre information for the movie rated by the
    user, user personal information such as age, gender, occupation, and so on. The
    final features and class labels can be seen in the preceding figure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third step will be to build the binary classification model. We will choose
    the RandomForest algorithm to build the class.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth and final step will be to generate the top-N recommendations for
    the users. For our example, we take a test user and predict the class labels for
    the movie that he has not rated earlier and send the top-N movies, which have
    higher probability ratings predicted by our classification model.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the choice of generating the top-N recommendations are left
    to the choice of the users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement the aforementioned steps using R. In this section, we will go
    through a step-by-step implementation of content-based recommendation using R.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this exercise, we use two MovieLens dataset files--one is a ratings file
    containing ratings given to 943 to 1682 movies on a scale of 1-5, and the second
    is an item dataset file containing content information, that is, information about
    the movie genre, movie name, movie ID, URLs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MovieLens dataset can be downloaded from following URL:[http://grouplens.org/datasets/movielens/](http://grouplens.org/datasets/movielens/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading ratings data into R environment using `read.csv()` function available
    in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code removes the last column from the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'See the first five lines of the data, we use `head()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See the columns of the rating data frame using `names()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the descriptions of the ratings function using `str()` function. All the
    results of the three mentioned functions are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dataset description](img/image00355.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code loads item data into the R environment using the `read.csv()`
    function available in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add columns to the data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we remove unwanted data; for this exercise we are keeping only the genre
    information only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00356.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The description of movies is given by `str(movies)`.The column names can be
    seen using `names(movies)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dataset description](img/image00357.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to create feature profiles of customers to build a classification
    model. We should extend the rating data frame containing userID, movieID, and
    rating with the movie properties, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we use `merge()` to perform a join function to merge
    ratings data with item data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00358.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see the columns names using `names()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dataset description](img/image00359.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we create the class labels for each record of the profile we just created.
    We shall create a binary class label for each of the ratings so that 1-3 ratings
    will be labelled as 0 and 4-5 ratings as 1\. The following code does this conversion
    for us. We use the `lapply()` function to reshape the ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code manages the conversion of numerical ratings to binary categorical
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we combine the newly created rating categorical rating variable - `nrat`
    - with the original rating data frame ratings using `cbind()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00360.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, we can observe the new rating binary class, `nrat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s observe the variables that will be going into the model building
    stage using the `apply()` function by applying `table()` to each column, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding results, we can observe that the number of zeroes is very
    high when compared to the number of 1s; so let''s remove this variable from our
    feature list. Also, let''s remove the rating variable, as we have created a new
    variable `nrat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall now standardize or center the data by using the `scale()` function
    available in R before we build the model as shown in the following code snippet.
    Standardizing will adjust data in different scales to common a scale. The scale
    function will apply centering by removing column means on the each of corresponding
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00362.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's get into building the model using the `randomForest` algorithm for
    binary classification. Before that, let's divide the data into training and test
    sets with an 80:20 split.
  prefs: []
  type: TYPE_NORMAL
- en: The following code will first create a randomize index object of all the data.
    Then we use this indexes to divide the train and test sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00363.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s build the model using `randomForest` algorithm from the library
    `randomForest`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following code snippet, we are converting the integer `nrat` variable
    to factor format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the details of the model build, fit, by just typing, `fit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dataset description](img/image00364.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous code snippet we have used the `randomforest()` method with default
    values. For random forests we have two parameters which can be tuned for optimal
    performance; **mtry** is number of samples at each tree split, **ntree** is number
    of decision trees to be grown. Using parameter tuning and cross-validation approaches,
    we should choose optimal parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the summary of the model using `summary()`, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dataset description](img/image00365.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see how the model performs on the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00366.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s evaluate the model using the Precision-Recall method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00367.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the preceding results, we are quite happy with a 60% precision rate and
    a 75% recall rate. Now we move ahead to generate the top-N recommendations to
    a user ID (943) by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a DataFrame containing all the movies not rated by the active user (user
    id: 943 in our case).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Dataset description](img/image00368.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Dataset description](img/image00369.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Build a profile for this active user DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Dataset description](img/image00370.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Predict ratings, sort and generate 10 recommendations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this step, we have when extending or improving finished building the content-based
    recommendation engine using a classification model. Before we move into the next
    section, I would like to make a clear point that the choice of the model and class
    label features is up to the reader to extend or improve the model.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, we should use cross-validation approach to choose optimal
    parameters so as to improve the model accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Content-based recommendation using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we built a model-based content recommendation engine
    using R. In this section, we will build content recommendations using another
    approach, using the Python `sklearn`, `NumPy`, and `pandas` packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall the steps for building a content-based system discussed in the
    beginning of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Item profile generation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User profile generation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recommendation engine model generation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generation of the top-N recommendations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this section, we shall learn in detail how to build content following the
    aforementioned steps using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of the approach is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content-based recommendation using Python](img/image00371.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Item profile creation**: In this step, we create a profile for each item
    using the content information we have about the items. The item profile is usually
    created using a widely-used information retrieval technique called tf-idf. In
    [Chapter 4](part0029.xhtml#aid-RL0A2 "Chapter 4. Data Mining Techniques Used in
    Recommendation Engines"), *Data Mining Techniques for Recommendation Engines*,
    we explained *tf-idf* in detail. To recap, the tf-idf value gives the relative
    importance of features with respect to all the items or documents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User profile creation**: In this step, we take the user activity dataset
    and preprocess the data into a proper format to create a user profile. We should
    remember that, in a content-based recommender system, the user profile is created
    with respect to the item content, that is, we have to extract or compute the preferences
    of the user for the item content or item features. Usually, a dot product between
    user activity and item profile gives us the user profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recommendation engine model generation**: Now that we have the user profile
    and item profile in hand, we will proceed to build a recommendation model. Computing
    a cosine similarity between the user profile and item profile gives us the affinity
    of the user to each of the items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generation of the top-N recommendations**: In the final step, we shall sort
    the user-item preferences based on the values calculated in the previous step
    and then suggest the top-N recommendations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we will proceed toward the implementation of the aforementioned steps in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will use the Anonymous Microsoft Web Dataset to build a
    content-based recommendation system. The objective of this section is to recommend
    websites to an active user, based on his previous web browsing history.
  prefs: []
  type: TYPE_NORMAL
- en: MS Web Dataset refers to the web logs of the website [www.microsoft.com](http://www.microsoft.com)
    accessed by 38,000 anonymous users. For each of the users, the dataset consists
    of lists about data of all the websites visited by the users in a time frame of
    one week.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset can be downloaded from the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://archive.ics.uci.edu/ml/datasets/Anonymous+Microsoft+Web+Data](https://archive.ics.uci.edu/ml/datasets/Anonymous+Microsoft+Web+Data)'
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, from now on, we will refer to the website areas
    with the term *items.* There are 5,000 users, and they are represented by sequential
    numbers between 10,001 and 15,000\. Items are represented by numbers between 1,000
    and 1,297, even if they are less than 298.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset is an unstructured text file. Each record contains several fields
    between two and six. The first field is a letter defining what the record contains.
    There are three main types of records, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute (A)**: This is the description of the website area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case (C)**: This is the case for each user, containing its ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vote (V)**: This is the vote lines for the case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first column case record is followed by the userID/caseID. The third column
    contains the user ID/vote given to the website area. The fourth column contains
    the description of the website area, and the fifth column consists of the URL
    of the website area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a small set of original data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dataset description](img/image00372.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our target is to suggest that each user explores some areas of the website that
    they haven't explored yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of packages we will be using for this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `read.csv()` function available in pandas package to read the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Dataset description](img/image00373.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see more sample data to have a much clearer idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dataset description](img/image00374.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can observe the following from the preceding figure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first column contains three types of values: **A**/**V**/**C**, where A
    represents case ID, **V** represents the user, and **C** represents the case IDs
    that the user has accessed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second column contains IDs to represent users and items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third column contains the description of website area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth contains the URL for the website area on the website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make an item profile, we use the rows containing **A** in the first column,
    and to create a user activity or dataset, we use the rows which don't contain
    **A** in the first column.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with profile generation.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed toward profile generation, we will have to format the user
    activity data; the following section explains how to create a user activity dataset.
  prefs: []
  type: TYPE_NORMAL
- en: User activity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will create a user-item rating matrix containing users
    as rows, items as columns, and the value as the cells. Here, the value is either
    `0` or `1`, indicating `1` if the user has accessed the web page, else `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we filter only records that don''t contain `"A"` in the first column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we assign then we remove unwanted columns from the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning names to the columns of `user_activity` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the sample `user_activity` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User activity](img/image00375.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the total unique `webid` in the dataset, see as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the unique users count, see following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the following code to create a user-item-rating matrix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we assign variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we get the last index of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The for loop code loops through each record and adds new columns(`''userid''`,
    `''webid''`) to `user_activity` data frame which shows `userid` and corresponding
    web activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![User activity](img/image00376.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we remove the unwanted rows from the preceding data frame, that is, we
    will be removing the rows containing `"C"` in the category column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![User activity](img/image00377.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We subset the columns, and remove the first two columns, which we no longer
    needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we sort the data by `webid`; this is to make sure that the rating matrix
    generation is in good format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a dense binary rating matrix containing user_item_rating
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the size of `webid` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add a new column, `''rating''` to the `user_activity` data frame which
    contains only 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use pivot to create binary rating matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a dense matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Item profile generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will be creating an item profile from the initial raw data
    (`raw_data`). To create item data, we will consider the data that contains `A`
    in the first column:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we filter all the records containing first column as `"A"`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we name the columns as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate `item` profile we only needed two columns so we slice the dataframe
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the dimensions of the items, the dataframe is given like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We observe that there are `294` unique `webid` in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the sample of the data, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![Item profile generation](img/image00378.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To check the count of unique `webid`, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also only those `webid` which are present in the `user_activity` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can use the following code check type of the object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also sort the data by `webid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''see what we have done till now, using the `head(5)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Item profile generation](img/image00379.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we shall create the item profile using the `tf-idf` functions available
    in the sklearn package. To generate `tf-idf`, we use the `TfidfVectorizer()`.
    The `fit_transform()` methods are in the `sklearn` package. The following code
    shows how we can create `tf-idf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the choice of the number of features to be included
    depends on the dataset, and the optimal number of features can be selected by
    the cross-validation approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![Item profile generation](img/image00380.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: User profile creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have item profile and user activity in hand; the dot product between
    these two matrices will create a new matrix with dimensions equal to `#` of users
    by `#` Item features.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the dot product between user activity and item profile, we use the
    `scipy` package methods such as `linalg`, dot available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code to compute the dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![User profile creation](img/image00381.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The final step in a recommendation engine model would be to compute the active
    user preferences for the items. For this, we do a cosine similarity between user
    profile and item profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the cosine calculations, we will be using the `sklearn` package.
    The following code will calculate the `cosine_similarity`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We calculate the cosine similarity between `userprofile` an item profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the results of the preceding calculation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User profile creation](img/image00382.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s format the preceding results calculated as binary data `(0,1)`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we convert the rating to binary format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we examine the final predictions of first three users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User profile creation](img/image00383.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Removing the zero values from the preceding results gives us the list of the
    probable items that can be recommended to the users:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For user `213` the recommended items are generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are generating recommendations for the active user
    `213`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User profile creation](img/image00384.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Context-aware recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next type of personalized recommender system that we will be learning here
    is context-aware recommender system. These recommender systems are next generation
    recommendations systems, which fall into the hyper-personalization category. It's
    natural that there won't be an end to the needs of humans. The more we get, the
    more we want. Though content-based recommender systems are efficient, targeted
    at an individual level, and consider the user's personal preferences alone while
    building recommendation engines, people wanted recommendation engines to be more
    personalized. For example, a person going on a trip alone may need a book to read
    whereas the same person may need beer if he is travelling with friends. Similarly,
    the same person might require diapers, medicines, snacks, and so on if he is going
    with his own family. People at different places at different times with different
    company have different needs. Our recommender systems should be robust enough
    to handle such scenarios. Such hyper personalized recommender systems, which cater
    to different recommendations to the same person based on his current context,
    are known as context-aware recommender systems.
  prefs: []
  type: TYPE_NORMAL
- en: Building a context-aware recommender systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building a context-aware recommender system is more like extending a content
    recommender system. Building a context-aware system typically involves adding
    the context dimension on top of content recommenders, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a context-aware recommender systems](img/image00385.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding figure, we can observe that context dimension is added on
    top of a content-based recommendation engine model, and then recommendations are
    generated. As we discussed in [Chapter 3](part0022.xhtml#aid-KVCC1 "Chapter 3. Recommendation
    Engines Explained"), *Recommendation Engines Explained*, there are two popular
    types of approaches for building context-aware recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-filtering approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-filtering approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will use post-filtering techniques to build context-aware
    recommender systems.
  prefs: []
  type: TYPE_NORMAL
- en: Context-aware recommendations using R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we built a content-based recommendation engine. In
    this section, we will extend the previous model to include context information
    and generate a context-aware recommendation engine.
  prefs: []
  type: TYPE_NORMAL
- en: The usual practice of building context-aware systems is to add a time dimension
    to the content-based recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context-aware recommendations using R](img/image00386.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try building context aware systems using R. The steps for building context-aware
    systems in R are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a context profile with respect to a user for item content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate recommendations for a context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to define the context that we will be including in our recommendations.
    In the previous section, we used the MovieLens dataset to build content-based
    recommendation engines. In the dataset, we have a time component, timestamp, in
    the rating data. We shall use this variable for our context-aware recommendation
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: We will extend the R code we used while building content-based recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We load the full MovieLens ratings dataset as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'See the sample data using `head()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the context](img/image00387.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We load movies dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add column names to the movies data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we remove unwanted columns from the data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![Defining the context](img/image00388.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We merge the Movies and Ratings datasets using `merge()` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![Defining the context](img/image00389.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The context that we want to introduce to our previous content-based recommendation
    is the hour of the day, that is, our recommendations will be made as per the time
    of the day. The set of recommendations for an active user will be different for
    each hour of the day. Usually, these changes in recommendations are due to the
    ordering of the recommendations as per the hour. We will see next how we achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating context profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following section, we shall write code to create context profile of the
    user. We chose the timestamp information available in the dataset and calculate
    the preference value for movie genres for each user for each hour of the day.
    This context profile information is used for generating context aware recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We extract timestamp from the ratings dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we convert it into a `POSIXlt` date object and using hour property to
    extract hour of the day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'See below for sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating context profile](img/image00390.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can append the hours back on to the ratings dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating context profile](img/image00391.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s start building a context profile for a user with the user ID 943:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract ratings information for the active user(943) and removing UserId, MovieId,
    Rating, Timestamp columns, as shown as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating context profile](img/image00392.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As a next step, we compute the columns of all the item features. This columnwise
    sum is used to compute the preferences for the item features for each hour of
    the day.
  prefs: []
  type: TYPE_NORMAL
- en: 'We compute the column wide sum of each column using `aggregate()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating context profile](img/image00393.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding figure, we can see the time preferences for each of the
    movie genres for the active user 943\. We can observe that during the ninth hour
    of the day, the user watches more movies, especially action/drama/comedy movies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can normalize the preceding data between 0-1 using following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating context profile](img/image00394.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Generating context-aware recommendations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have created the context profile for the active user, let's start
    generating context-aware recommendations for the user.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we shall reuse the recommend object built using R, which contains
    content recommendations for all the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the recommendations made to the user 943 using the content-based
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![Generating context-aware recommendations](img/image00395.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, to these content recommendations, we add our time or hour of the day dimension
    and then generate recommendations as per the current context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We merge recommendations and movies dataset using `merge()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![Generating context-aware recommendations](img/image00396.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With the preceding step, we have computed all the required matrices, user context
    profile (`UCP_Pref_SC`) and user content recommendations (`UCP_Pref_content`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to generate recommendations for the user at the ninth hour;
    we just need to perform an element wise multiplication of user content recommendations
    and the context row for the ninth hour of the day from the `UCP_pref_SC` object.
    This is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing element wise multiplication for the User content recommendations
    and the ninth hour context preferences for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The results can be seen as follows; we can observe that the preference for MovieId
    3 is 0.5 where as for MovieId 4 the preference is 2.8
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating context-aware recommendations](img/image00397.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create a dataframe object of the prediction object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add column names to the predictions object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we sort the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build content-based recommendation engines
    and context-aware recommendation engines using R and Python. We modelled content-based
    recommendation engines in two types--the classification model and the tf-idf model
    approaches using R and Python. To build context-aware recommendations, we simply
    did an element wise multiplication between content-based recommendations and context
    profile of the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be exploring Apache Spark, to build scalable, real-time
    recommendation engines.
  prefs: []
  type: TYPE_NORMAL
