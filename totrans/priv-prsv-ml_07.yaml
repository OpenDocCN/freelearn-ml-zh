- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Developing Applications with Differential Privacy Using Open Source Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开源框架开发具有差分隐私的应用程序
- en: In this chapter, we will explore open source frameworks (**PyDP**, **PipelineDP**,
    **tmlt-analytics**, **PySpark**, **diffprivlib**, **PyTorch**, and **Opacus**)
    used to develop machine learning, deep learning, and large-scale applications
    with the power of differential privacy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨用于开发具有差分隐私能力的机器学习、深度学习和大规模应用程序的开源框架（**PyDP**、**PipelineDP**、**tmlt-analytics**、**PySpark**、**diffprivlib**、**PyTorch**
    和 **Opacus**）。
- en: 'We will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: 'Open source frameworks for implementing differential privacy:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现差分隐私的开源框架：
- en: Introduction to the PyDP framework and its key features
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyDP 框架及其关键特性的介绍
- en: Examples and demonstrations of PyDP in action
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyDP 的应用示例和演示
- en: Developing a sample banking application with PyDP to showcase differential privacy
    techniques
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyDP 开发一个示例银行应用程序，以展示差分隐私技术
- en: 'Protecting against membership inference attacks:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止成员推理攻击：
- en: Understanding membership inference attacks and their potential risks
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解成员推理攻击及其潜在风险
- en: Techniques and strategies to safeguard against membership inference attacks
    when applying differential privacy
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用差分隐私时，防止成员推理攻击的技术和策略
- en: 'Applying differential privacy on large datasets to protect sensitive data:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型数据集上应用差分隐私以保护敏感数据：
- en: Leveraging the open source PipelineDP framework to apply differential privacy
    on large-scale datasets
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用开源的 PipelineDP 框架在大型数据集上应用差分隐私
- en: Leveraging the open source Tumult Analytics and PySpark frameworks to apply
    differential privacy on large datasets
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用开源的 Tumult Analytics 和 PySpark 框架在大型数据集上应用差分隐私
- en: 'Machine learning with differential privacy:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有差分隐私的机器学习：
- en: Running a fraud detection classification model on synthetic data using differential
    privacy
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用差分隐私在合成数据上运行欺诈检测分类模型
- en: A clustering example, applying differential privacy using IBM’s open source
    **diffprivlib** framework
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个聚类示例，应用差分隐私，使用 IBM 的开源 **diffprivlib** 框架
- en: 'Deep learning with differential privacy:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有差分隐私的深度学习：
- en: Implementing a fraud detection model using the PyTorch deep learning framework
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyTorch 深度学习框架实现欺诈检测模型
- en: Utilizing the open source PyTorch and Opacus frameworks to develop deep learning
    models for fraud detection with differential privacy
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用开源的 PyTorch 和 Opacus 框架开发具有差分隐私的欺诈检测深度学习模型
- en: Differential privacy machine learning frameworks
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差分隐私机器学习框架
- en: Limitations of differential privacy and some strategies to overcome them
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差分隐私的局限性以及一些克服策略
- en: Open source frameworks to implement differential privacy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现差分隐私的开源框架
- en: There are several open source frameworks available to implement differential
    privacy. We will go through the PyDP framework in detail in this section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个开源框架可用于实现差分隐私。在本节中，我们将详细介绍 PyDP 框架。
- en: Introduction to the PyDP framework and its key features
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyDP 框架及其关键特性的介绍
- en: Google has released an open source framework called differential privacy that
    facilitates the implementation of differential privacy. This framework offers
    support for both ε- and (ε, δ)-differentially private statistics. It includes
    various features such as the ability to introduce noise using Laplace and Gaussian
    mechanisms. Additionally, the framework provides support for aggregated differential
    privacy algorithms including sum, count, mean, variance, and standard deviation.
    The libraries within this framework are implemented in the C++, Java, and Go languages,
    and it also offers a **command-line interface** (**CLI**) to execute differential
    privacy SQL queries. For further information, you can visit the GitHub repository
    at [https://github.com/google/differential-privacy](https://github.com/google/differential-privacy).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Google 发布了一个名为差分隐私的开源框架，该框架简化了差分隐私的实施。此框架支持 ε- 和 (ε, δ)-差分隐私统计。它包括各种功能，例如使用拉普拉斯和高斯机制引入噪声的能力。此外，该框架还提供了对包括总和、计数、平均值、方差和标准差在内的聚合差分隐私算法的支持。此框架中的库是用
    C++、Java 和 Go 语言实现的，并且它还提供了一个 **命令行界面** (**CLI**) 来执行差分隐私 SQL 查询。有关更多信息，您可以访问
    GitHub 仓库 [https://github.com/google/differential-privacy](https://github.com/google/differential-privacy)。
- en: PyDP, developed by OpenMined in 2020, is another framework that implements Python
    wrapper functions for Google’s differential privacy tools. While PyDP is not an
    exhaustive implementation of Google’s differential privacy toolkit, it supports
    a subset of ε-differentially private algorithms from Google’s toolkit. These algorithms
    enable the generation of aggregate statistics over numeric datasets that contain
    private or sensitive information. You can find the PyDP framework at [https://github.com/OpenMined/PyDP](https://github.com/OpenMined/PyDP).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PyDP是由OpenMined于2020年开发的另一个框架，它实现了Google差分隐私工具的Python包装函数。虽然PyDP不是Google差分隐私工具包的完整实现，但它支持Google工具包中ε-差分隐私算法的一个子集。这些算法能够生成包含私人或敏感信息的数值数据集的聚合统计信息。您可以在[https://github.com/OpenMined/PyDP](https://github.com/OpenMined/PyDP)找到PyDP框架。
- en: Examples and demonstrations of PyDP in action
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyDP的实际应用示例和演示
- en: Installation of PyDP
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyDP的安装
- en: PyDP installation is done the same way as installing any other Python package.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: PyDP的安装方式与其他Python包的安装方式相同。
- en: 'For Python 3.x, use the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 3.x版本，请使用以下命令：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For earlier versions of Python, use this line:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python的早期版本，请使用以下行：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sample program to calculate the mean using PyDP
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PyDP计算平均值的示例程序
- en: 'PyDP supports the Laplacian noise mechanism and offers a range of aggregate
    functions such as sum, average, count, and more. When calculating the mean, PyDP
    requires the provision of bounds in the form of lower and upper values. To facilitate
    this, PyDP provides a class called `BoundedMean`, which offers the following constructors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: PyDP支持拉普拉斯噪声机制，并提供了一系列聚合函数，如求和、平均值、计数等。在计算平均值时，PyDP需要提供以下限和上限值形式表示的界限。为此，PyDP提供了一个名为`BoundedMean`的类，它提供了以下构造函数：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `BoundedMean` class in PyDP is used to calculate the differentially private
    mean of bounded data. It utilizes the epsilon and delta parameters to provide
    privacy guarantees. This class supports the Laplacian noise mechanism to add privacy-preserving
    noise to the mean calculation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PyDP中的`BoundedMean`类用于计算有界数据的差分隐私平均值。它利用epsilon和delta参数提供隐私保证。此类支持拉普拉斯噪声机制，向平均值计算中添加隐私保护噪声。
- en: 'Here is example code to demonstrate the bounded mean:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是演示有界平均值的示例代码：
- en: '*Source* *code: Sample_Mean_Using_PyDP.ipynb*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：Sample_Mean_Using_PyDP.ipynb'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Developing a sample banking application with PyDP to showcase differential privacy
    techniques
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PyDP开发一个示例银行应用程序以展示差分隐私技术
- en: 'In this application scenario, we take the example of a financial bank that
    aims to collaborate with merchants, companies, and other banks to launch a marketing
    campaign while safeguarding the sensitive personal information of its customers.
    Customers make purchases using their credit or debit cards in two different scenarios:
    offline transactions at merchant outlets, where the cards are physically swiped
    (known as card-present transactions), and online transactions, where card details
    such as the card number, name, expiry date, and CVV are entered (known as card-not-present
    transactions). The objective is to provide credit card transaction data to support
    the campaign without revealing individual customer details.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用场景中，我们以一家旨在与商家、公司和其他银行合作开展营销活动同时保护其客户敏感个人信息的金融银行为例。客户在两种不同场景下使用他们的信用卡或借记卡进行购买：在商家网点进行的线下交易，卡被物理刷过（称为卡面交易），以及在线交易，其中输入卡号、姓名、到期日期和CVV等卡详情（称为无卡交易）。目标是提供信用卡交易数据以支持活动，同时不泄露个人客户详情。
- en: To successfully launch marketing campaigns or loyalty programs, the bank needs
    to share certain transaction details such as the type of purchases, transaction
    volumes, and transaction values associated with specific locations. This information
    allows the bank to partner with interested banks/merchants, enabling the promotion
    of large-scale product sales and the delivery of benefits to customers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功启动营销活动或忠诚度计划，银行需要共享某些交易细节，例如购买类型、交易量和与特定位置相关的交易价值。这些信息使银行能够与感兴趣的银行/商家合作，从而促进大规模产品销售并向客户发放福利。
- en: In this context, we will synthetically generate a significant number of transactions
    using predefined business rules and calculate statistics such as count, average,
    and sum for each location. The intention is to share these aggregated statistics
    with the partnering companies without compromising customer privacy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此背景下，我们将使用预定义的业务规则合成大量交易，并计算每个位置的计数、平均值和总和等统计数据。目的是在不损害客户隐私的情况下，与合作伙伴公司共享这些汇总统计数据。
- en: There are two approaches to sharing these statistics. The first approach involves
    sharing the aggregates as they are, which may potentially reveal private information
    about individual customers. The second approach utilizes differential privacy
    to generate the aggregates, ensuring that they do not leak any sensitive customer
    information while preserving privacy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 共有两种方法来共享这些统计数据。第一种方法涉及直接共享汇总数据，这可能会泄露有关个别客户的私人信息。第二种方法利用差分隐私来生成汇总数据，确保在保护隐私的同时不泄露任何敏感客户信息。
- en: By applying differential privacy techniques, the bank can protect customer privacy
    by introducing carefully calibrated noise to the aggregated statistics. This noise
    ensures that the shared aggregates do not disclose specific individuals’ details
    while still providing valuable insights for the marketing campaign and loyalty
    program planning.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用差分隐私技术，银行可以通过向汇总统计数据引入精心校准的噪声来保护客户隐私。这种噪声确保共享的汇总数据不会披露特定个人的详细信息，同时仍为营销活动和忠诚度计划规划提供有价值的见解。
- en: By adopting differential privacy, the bank can strike a balance between data
    utility and privacy protection, allowing it to collaborate with companies and
    merchants while maintaining the confidentiality of customer information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用差分隐私，银行可以在数据效用和隐私保护之间取得平衡，使其能够在与公司和企业合作的同时保持客户信息的机密性。
- en: Let’s generate the synthetic datasets needed to develop this banking application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成开发此银行应用程序所需的合成数据集。
- en: 'The following is the customer data:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为客户数据：
- en: '![Figure 5.1 – Customer Dataset](img/B16573_05_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 客户数据集](img/B16573_05_01.jpg)'
- en: Figure 5.1 – Customer Dataset
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 客户数据集
- en: The dataset used in this context comprises various attributes, including the
    customer ID, the location represented as latitude and longitude coordinates, the
    number of transactions per day, and the average transaction amount. It is important
    to note that the actual credit card number, **Card Verification Value** (**CVV**)
    code, and the expiry date associated with each customer’s card are maintained
    in a separate table and are not shown in the provided dataset. Furthermore, these
    parameters are not utilized in generating the statistical information. In this
    particular example, the transactions generated pertain to card-present scenarios
    occurring at various merchant locations, using **point-of-sale** (**POS**) terminals
    to swipe the cards.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此背景下使用的数据集包括各种属性，包括客户 ID、表示为经纬度坐标的位置、每天的交易次数和平均交易金额。需要注意的是，与每个客户的卡关联的实际信用卡号、**卡验证值**（**CVV**）代码和到期日期保存在单独的表中，并且不在提供的数据集中显示。此外，这些参数在生成统计数据时并未使用。在此特定示例中，生成的交易涉及在各个商家位置发生的卡面交易场景，使用**销售点**（**POS**）终端刷卡。
- en: 'The following is the sample POS terminal data:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为样本 POS 终端数据：
- en: '![Figure 5.2 – Terminal Dataset](img/B16573_05_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 终端数据集](img/B16573_05_02.jpg)'
- en: Figure 5.2 – Terminal Dataset
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 终端数据集
- en: In this scenario, it is assumed that customers predominantly visit nearby merchant
    outlets for their day-to-day purchases, with the distance between the customer’s
    location and the merchant locations typically falling within a range of around
    5 miles.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，假设客户主要访问附近的商家门店进行日常购买，客户位置与商家位置之间的距离通常在约 5 英里范围内。
- en: To generate the transactions, the Euclidean distance between the customer’s
    location and the available merchant locations is calculated. Using this distance
    information, merchants are randomly selected from the nearby options. This approach
    ensures that the generated transactions reflect the realistic behavior of customers
    going to nearby merchants within a specific distance radius for their purchases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成交易，计算客户位置与可用商家位置之间的欧几里得距离。使用这些距离信息，从附近的选项中随机选择商家。这种方法确保生成的交易反映了客户在特定距离半径内前往附近商家购买的现实行为。
- en: 'The following is the transaction data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为交易数据：
- en: '![Figure 5.3 – Transaction Dataset](img/B16573_05_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 交易数据集](img/B16573_05_03.jpg)'
- en: Figure 5.3 – Transaction Dataset
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 交易数据集
- en: Let’s generate aggregates using differential privacy on this dataset so that
    it can then be shared with merchants/banks in order to design marketing campaigns
    and loyalty programs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用差分隐私在此数据集上生成聚合数据，以便随后与商家/银行共享，以便设计营销活动和忠诚度计划。
- en: '*Source* *code: Sample_Finance_App_DP.ipynb*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源* *代码：Sample_Finance_App_DP.ipynb*'
- en: '**# unzip the transactions.csv.zip file (provided in this book’s GitHub repo**
    **as transactions.csv).**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 解压transactions.csv.zip文件（本书GitHub仓库中提供** **作为transactions.csv）。**'
- en: '[https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/transactions.csv.zip](https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/transactions.csv.zip)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/transactions.csv.zip](https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/transactions.csv.zip)'
- en: 'Data loading:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加载：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Figure 5.4 – Sample transaction data](img/B16573_05_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 示例交易数据](img/B16573_05_04.jpg)'
- en: Figure 5.4 – Sample transaction data
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 示例交易数据
- en: 'In this section, we will generate differentially private aggregates for various
    scenarios. The focus will be on comparing the results obtained using traditional
    statistical methods with those achieved through differential privacy techniques.
    The following scenarios will be explored:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为各种场景生成不同的差分隐私聚合数据。重点将放在比较使用传统统计方法获得的结果与通过差分隐私技术实现的结果。以下场景将被探讨：
- en: Mean transaction amount for a given terminal
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定终端的平均交易金额
- en: Mean transaction amount for terminal IDs 1 to 100
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端ID 1至100的平均交易金额
- en: Number of customers who make purchases worth $25 or more via terminals 1 to
    100
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过终端1至100购买价值25美元或以上的客户数量
- en: Maximum transaction amount for a given terminal
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定终端的最大交易金额
- en: Sum of the transaction amounts for each terminal on a given day or month
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定日或月每个终端的交易金额总和
- en: Mean transaction amount for a given terminal
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定终端的平均交易金额
- en: 'In order to calculate the average transaction amount for a given day or month
    via a specific POS terminal, we can define the following methods. These methods
    will be used to compare the results obtained using traditional statistical methods
    with the aggregates generated through differential privacy techniques:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过特定的POS终端计算指定日或月的平均交易金额，我们可以定义以下方法。这些方法将用于比较使用传统统计方法获得的结果与通过差分隐私技术生成的聚合结果：
- en: '**Traditional average calculation**: We will implement a method that calculates
    the average transaction amount for a given day or month on a particular POS terminal
    using traditional statistical methods. This method will take as input the relevant
    transaction data, such as the transaction amounts and the date of the day or month
    of interest. The average will be computed by summing all the transaction amounts
    and dividing the sum by the total number of transactions on the specified day
    or month on the chosen POS terminal. The traditional average will serve as a baseline
    for comparison.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统平均计算**：我们将实现一种方法，使用传统统计方法计算特定POS终端在指定日或月的平均交易金额。此方法将输入相关的交易数据，例如交易金额和感兴趣的日或月日期。平均将通过将所有交易金额相加并除以所选POS终端在指定日或月上的总交易次数来计算。传统的平均数将作为比较的基准。'
- en: '**Differentially private average calculation**: We will develop a method that
    leverages differential privacy techniques to calculate the differentially private
    average transaction amount for a given day or month on the selected POS terminal.
    This method will take the same input as the traditional average calculation method.
    It will utilize differential privacy mechanisms, such as adding noise to the aggregated
    statistics, to protect the privacy of individual transactions while generating
    the average. The differentially private average will provide a privacy-preserving
    alternative to the traditional average. By utilizing these methods and comparing
    the results, we can assess the differences between the traditional average calculation
    and the average generated through differential privacy techniques.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差分隐私平均计算**：我们将开发一种利用差分隐私技术来计算选定 POS 终端给定一天或一个月的平均交易金额的方法。此方法将采用与传统平均计算方法相同的输入。它将利用差分隐私机制，如向汇总统计数据添加噪声，以保护个人交易的隐私，同时生成平均值。差分隐私平均将提供一种保护隐私的传统平均值的替代方案。通过使用这些方法并比较结果，我们可以评估传统平均计算与通过差分隐私技术生成的平均值的差异。'
- en: 'This analysis will demonstrate the impact of differential privacy on aggregate
    calculations and highlight the trade-off between accuracy and privacy preservation
    in generating average transaction amounts on a given day or month via a specific
    POS terminal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此分析将展示差分隐私对汇总计算的影响，并强调在特定 POS 终端通过一天或一个月生成平均交易金额时在准确性和隐私保护之间的权衡：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding calculation, we can see the average generated using the traditional
    method returns 56.22 whereas the differentially private version produces an average
    of 220.98 for POS terminal ID 1\. In this way, the private average helps not to
    disclose the actual average.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的计算中，我们可以看到使用传统方法生成的平均值为 56.22，而差分隐私版本为 POS 终端 ID 1 生成平均值为 220.98。这样，私有平均值有助于不泄露实际的平均值。
- en: Mean transaction amount for terminal IDs 1 to 100
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终端 ID 1 到 100 的平均交易金额
- en: 'Let’s generate the mean transaction amount for the terminals 1 to 100 and make
    use of the private mean function defined earlier:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成终端 1 到 100 的平均交易金额，并使用之前定义的私有平均函数：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Figure 5.5 – Actual Mean vs Privacy Mean](img/B16573_05_05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 实际平均值与隐私平均值](img/B16573_05_05.jpg)'
- en: Figure 5.5 – Actual Mean vs Privacy Mean
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 实际平均值与隐私平均值
- en: In the following sections, we will also generate the count and sum of transaction
    amounts for a given day or month on a specific POS terminal and compare the results
    obtained using traditional statistical methods with those generated through differential
    privacy techniques.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们还将生成特定 POS 终端在给定一天或一个月的交易金额的计数和总和，并将使用传统统计方法获得的结果与通过差分隐私技术生成的结果进行比较。
- en: Number of customers who make purchases worth $25 or more via terminals 1 to
    100
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过终端 1 到 100 进行购买价值 25 美元或以上的客户数量
- en: Next, we will implement a method that calculates the number of customers who
    made purchases of $25 or more on terminals 1 to 100.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实施一种计算终端 1 到 100 上进行 25 美元或以上购买的客户数量的方法。
- en: This method will take the transaction data as input, including the terminal
    number and the corresponding transaction amounts. It will iterate through the
    transactions for each terminal ID from 1 to 100 and count the number of customers
    whose transaction amounts exceed $25\. The count will provide an indication of
    the customer base that made higher-value purchases, helping to analyze the impact
    of differential privacy on identifying such customers. By utilizing this method,
    we can compare the results obtained using traditional statistical methods with
    the counts generated through differential privacy techniques.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将以交易数据作为输入，包括终端号和相应的交易金额。它将遍历每个终端 ID 从 1 到 100 的交易，并计算交易金额超过 25 美元的客户数量。这个计数将提供有关进行了高价值购买的客户基础的指示，有助于分析差分隐私对识别此类客户的影响。通过使用此方法，我们可以比较使用传统统计方法获得的结果与通过差分隐私技术生成的计数。
- en: 'This analysis will shed light on the differences between the approaches and
    demonstrate the effectiveness of differential privacy in identifying customers
    who made purchases worth more than $25 for terminals 1 to 100 while preserving
    individual privacy:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这项分析将揭示不同方法之间的差异，并展示差分隐私在识别终端 1 到 100 上进行了价值超过 25 美元购买的客户时的有效性，同时保护个人隐私：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure 5.6 – Actual transaction counts vs privacy added counts](img/B16573_05_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 实际交易次数与增加的隐私次数对比](img/B16573_05_06.jpg)'
- en: Figure 5.6 – Actual transaction counts vs privacy added counts
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 实际交易次数与增加的隐私次数对比
- en: By adopting this approach, we ensure that the actual count of customers who
    made purchases worth more than $25 is not revealed or shared with banks/merchants.
    Instead, we provide those parties with differentially private counts, thus preserving
    individual privacy while still offering valuable insights. This allows banks/merchants
    to launch loyalty programs based on the differentially private counts, tailoring
    their initiatives based on the available data. Thus, by employing differential
    privacy techniques, institutions can strike a balance between providing useful
    information for loyalty programs and safeguarding the sensitive details of individual
    customers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这种方法，我们确保不会泄露或与银行/商家共享实际购买价值超过 25 美元的客户数量。相反，我们向这些方提供差分隐私计数，从而在提供有价值的见解的同时保护个人隐私。这使得银行/商家可以根据差分隐私计数启动忠诚度计划，根据可用数据定制他们的倡议。因此，通过采用差分隐私技术，机构可以在为忠诚度计划提供有用信息和保护单个客户敏感细节之间取得平衡。
- en: Maximum transaction amount for a given terminal
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给定终端的最大交易金额
- en: 'Let’s define the functions to calculate the maximum transaction amount and
    the differentially private amount:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义计算最大交易金额和差分隐私金额的函数：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see in the preceding code, by employing differential privacy techniques,
    we can calculate an approximate maximum transaction amount for a given terminal
    while preserving the privacy of individual transactions. These values depend on
    the privacy budget. This example used 0.5 as the privacy budget. This allows us
    to share valuable aggregated information with banks/merchants without compromising
    the sensitive details of individual customers. In this example, the actual maximum
    transaction amount is 87\. With added noise based on the privacy budget (i.e.,
    0.5) the value becomes 167\. Thus, it may not be very useful in terms of utility.
    This illustrates the trade-off between privacy and utility. One needs to experiment
    with different privacy budgets to decide the best fit for the use case/application,
    deciding whether they want prioritize more privacy and less utility or more utility
    with less privacy.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，通过采用差分隐私技术，我们可以在保护单个交易隐私的同时，计算给定终端的大致最大交易金额。这些值取决于隐私预算。本例中使用了 0.5 作为隐私预算。这使我们能够在不泄露单个客户敏感细节的情况下，与银行/商家分享有价值的汇总信息。在本例中，实际的最大交易金额为
    87。根据隐私预算（即 0.5）添加的噪声，该值变为 167。因此，在效用方面可能不太有用。这说明了隐私与效用之间的权衡。需要通过实验不同的隐私预算来决定最适合用例/应用的方案，决定是更优先考虑隐私和较少的效用，还是更优先考虑效用和较少的隐私。
- en: Sum of the transaction amounts for each terminal on a given day or month
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个终端在给定日期或月份的交易金额总和
- en: 'Let’s define the functions to calculate the sum of the transaction amounts
    and the differentially private amounts:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义计算交易金额总和以及差分隐私金额总和的函数：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As an exercise, you can implement the `count` and `sum` functions for all POS
    terminals and compare the results obtained using traditional statistical methods
    with those generated through differential privacy techniques.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以实现所有 POS 终端上的 `count` 和 `sum` 函数，并将使用传统统计方法获得的结果与通过差分隐私技术生成的结果进行比较。
- en: Protecting against membership inference attacks
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御成员推理攻击
- en: '**Membership inference attacks** pose a significant threat to the privacy of
    individuals in machine learning systems. These attacks aim to determine whether
    a specific data point was part of the training dataset used to create a machine
    learning model, potentially exposing sensitive information about individuals.
    To mitigate the risk of such attacks, differential privacy techniques can be employed.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员推理攻击**对机器学习系统中个人的隐私构成重大威胁。这些攻击旨在确定特定数据点是否是用于创建机器学习模型的训练数据集的一部分，可能暴露有关个人的敏感信息。为了减轻此类攻击的风险，可以采用差分隐私技术。'
- en: 'To protect against membership inference attacks using differential privacy,
    several approaches can be adopted:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抵御使用差分隐私的成员推理攻击，可以采用以下几种方法：
- en: '**Noise addition**: During the training process, noise is added to the computations
    to introduce randomness and mask individual data points. This makes it challenging
    for attackers to identify whether a specific data point was used in the training.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪声添加**：在训练过程中，向计算中添加噪声以引入随机性和掩盖单个数据点。这使得攻击者难以识别特定数据点是否被用于训练。'
- en: '**Privacy budget management**: Differential privacy operates under a privacy
    budget that determines the maximum amount of privacy loss allowed. By carefully
    managing and allocating the privacy budget, the risk of membership inference attacks
    can be minimized.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私预算管理**：差分隐私在隐私预算下运行，该预算决定了允许的最大隐私损失量。通过仔细管理和分配隐私预算，可以最大限度地降低成员推断攻击的风险。'
- en: '**Generalization and aggregation**: Applying generalization and aggregation
    techniques helps in obfuscating individual data points. By grouping similar data
    points together, the information about any specific individual becomes less distinguishable.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泛化和聚合**：应用泛化和聚合技术有助于模糊单个数据点。通过将相似的数据点分组在一起，任何特定个人的信息变得不那么容易区分。'
- en: '**Perturbation mechanisms**: Utilizing perturbation mechanisms, such as adding
    noise to the model’s outputs or gradients, enhances privacy protection. These
    mechanisms make it more challenging for attackers to infer membership status accurately.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扰动机制**：利用扰动机制，例如向模型的输出或梯度添加噪声，可以增强隐私保护。这些机制使得攻击者更难以准确推断成员资格状态。'
- en: '**Adversarial training**: Incorporating adversarial training techniques helps
    in training models that are robust against membership inference attacks. This
    involves training the model against a sophisticated attacker who tries to distinguish
    the presence of specific data points.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对抗训练**：结合对抗训练技术有助于训练对成员推断攻击具有鲁棒性的模型。这涉及到训练模型以对抗一个复杂的攻击者，该攻击者试图区分特定数据点的存在。'
- en: By combining these strategies and adopting a privacy-by-design approach, machine
    learning systems can better protect against membership inference attacks. It is
    important to note that while differential privacy provides strong privacy guarantees,
    there might still be cases where additional privacy-preserving techniques or post-processing
    is necessary to address specific attack scenarios.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这些策略并采用隐私设计方法，机器学习系统可以更好地保护免受成员推断攻击。需要注意的是，虽然差分隐私提供了强大的隐私保证，但在某些情况下，可能还需要额外的隐私保护技术或后处理来应对特定的攻击场景。
- en: 'Following is an example to demonstrate this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例来演示这一点：
- en: Let’s generate two datasets that differ by exactly one record. We’ll create
    a copy of the original dataset and refer to it as the **redacted dataset**. In
    the redacted dataset, we’ll remove one record to create the difference.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成两个数据集，它们正好相差一条记录。我们将创建原始数据集的副本，并将其称为**红acted数据集**。在红acted数据集中，我们将删除一条记录以创建差异。
- en: 'Here’s how to proceed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何进行操作的说明：
- en: Start with the original dataset containing the desired records. This dataset
    represents the baseline or complete set of records.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从包含所需记录的原始数据集开始。这个数据集代表基线或完整的记录集。
- en: Create a copy of the original dataset and label it as **redact_dataset**. This
    dataset will closely resemble the original dataset but with one record removed.
    Choose any record from the redacted dataset and remove it to create the difference.
    In the example, the first record is removed.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建原始数据集的副本并将其标记为**redact_dataset**。这个数据集将非常接近原始数据集，但会删除一条记录。从红acted数据集中选择任何记录并将其删除以创建差异。在示例中，第一条记录被删除。
- en: By creating the redacted dataset as a modified version of the original dataset,
    specifically by removing one record, we establish a distinct dataset that differs
    from the original by only that single record.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将红acted数据集作为原始数据集的修改版本创建，特别是通过删除一条记录，我们建立了一个独特的数据集，该数据集与原始数据集的不同之处仅在于那条单一记录。
- en: Use the following source code to create a redacted one.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下源代码创建一个红acted版本。
- en: '*Source* *code: Sample_Finance_App_DP.ipynb*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：Sample_Finance_App_DP.ipynb'
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Figure 5.7 -  Sample transaction dataset](img/B16573_05_07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 - 示例交易数据集](img/B16573_05_07.jpg)'
- en: Figure 5.7 - Sample transaction dataset
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 - 示例交易数据集
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Figure 5.8 – Redact dataset](img/B16573_05_08.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 红act数据集](img/B16573_05_08.jpg)'
- en: Figure 5.8 – Redact dataset
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 红act数据集
- en: We have removed just one record (customer ID 2079) from the original dataset,
    who made a transaction of $36\. This was done to form the redacted dataset.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从原始数据集中删除了一条记录（客户ID 2079），该客户进行了36美元的交易。这是为了形成编辑后数据集。
- en: 'Let’s calculate the sum of transaction amounts from the original dataset and
    the redacted dataset to determine the difference. This difference will correspond
    to the exact transaction amount made by the customer with the ID 2079:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算原始数据集和编辑后数据集的交易金额总和，以确定差异。这个差异将对应于客户ID 2079实际进行的交易金额：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s apply differential privacy techniques to calculate the sum of transaction
    amounts from the original dataset and the redacted dataset. The difference between
    these two sums should not reveal the exact transaction amount made by the customer
    with ID 2079\. Here’s how you can approach this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用差分隐私技术来计算原始数据集和编辑后数据集的交易金额总和。这两个总和之间的差异不应揭示客户ID 2079实际进行的交易金额。以下是您可以采取的方法：
- en: 'Sum using differential privacy on the original dataset:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始数据集上使用差分隐私计算的总和：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sum using differential privacy on the redacted dataset:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑后数据集上使用差分隐私计算的总和：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Difference between the two datasets using differential privacy:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用差分隐私计算的两个数据集之间的差异：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, when calculating the sum of transaction amounts using differential
    privacy for both the original dataset and the redacted dataset, the difference
    between these two sums resulted in negative numbers. However, it is important
    to note that these negative values do not represent the actual transaction amount
    made by customer ID 2079.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，当使用差分隐私计算原始数据集和编辑后数据集的交易金额总和时，这两个总和之间的差异产生了负数。然而，重要的是要注意，这些负值并不代表客户ID 2079实际进行的交易金额。
- en: The negative values in the difference arise due to the inherent noise added
    during the differential privacy calculations. Differential privacy techniques
    introduce randomization to protect individual privacy, and this random noise can
    sometimes lead to negative perturbations in the aggregated results.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 差分隐私计算过程中引入的固有噪声导致差异值中出现负值。差分隐私技术通过引入随机化来保护个人隐私，而这种随机噪声有时会导致汇总结果中出现负扰动。
- en: Therefore, it is crucial to interpret these negative values correctly. They
    should not be considered as the actual transaction amount made by customer ID
    2079, but rather as an indication that the differential privacy mechanisms have
    successfully introduced noise to protect individual privacy while providing approximate
    aggregate results.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正确解释这些负值至关重要。它们不应被视为客户ID 2079实际进行的交易金额，而应被视为差分隐私机制成功引入噪声以保护个人隐私并提供了近似汇总结果的指示。
- en: It is essential to understand that differential privacy focuses on preserving
    privacy rather than exactness in the calculated results. The negative difference
    serves as a reminder of the privacy guarantees provided by differential privacy,
    ensuring that individual transaction details are safeguarded even in the presence
    of aggregate computations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点至关重要，即差分隐私侧重于保护隐私，而不是计算结果的精确性。负差异值作为差分隐私提供的隐私保证的提醒，确保即使在汇总计算的情况下，个人交易细节也得到了保护。
- en: Applying differential privacy to large datasets
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将差分隐私应用于大数据集
- en: In the previous examples, we focused on calculating differentially private aggregates
    (such as count, sum, and average) on smaller datasets, involving a single terminal
    or a limited number of terminals. However, in this section, we will explore how
    to generate differentially private aggregates on large datasets, including millions
    or even billions of records. Specifically, we will consider a use case involving
    a dataset of approximately 5 million credit card transactions across 1,000 point-of-sale
    terminals and 5,000 customers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们专注于在较小的数据集上计算差分隐私汇总（如计数、总和和平均值），这些数据集涉及单个终端或有限数量的终端。然而，在本节中，我们将探讨如何在包含数百万甚至数十亿条记录的大数据集上生成差分隐私汇总。具体来说，我们将考虑一个涉及约500万张信用卡交易数据集的用例，这些交易发生在1,000个销售终端和5,000名客户之间。
- en: Use case – generating differentially private aggregates on a large dataset
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 - 在大数据集上生成差分隐私汇总
- en: Let’s generate the dataset comprising credit card transactions recorded on a
    daily basis across 1,000 POS terminals. These transactions involve a total of
    5,000 customers, resulting in an extensive collection of approximately 5 million
    records.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成包含在1,000个POS终端上按日记录的信用卡交易的数据库。这些交易涉及总共5,000名客户，结果是一个大约5百万条记录的庞大集合。
- en: To calculate differentially private aggregates on such a large dataset, specialized
    techniques and frameworks are employed to handle the scale and complexity of the
    data. These techniques ensure that privacy is preserved while providing meaningful
    aggregate statistics.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算如此大数据集的差异隐私聚合，需要采用专门的技术和框架来处理数据的规模和复杂性。这些技术确保在提供有意义的聚合统计信息的同时保护隐私。
- en: By leveraging differential privacy on large datasets, organizations can extract
    valuable insights without compromising the privacy of individual customers. The
    generated differentially private aggregates enable data-driven decision-making
    and analysis while protecting sensitive information. It is worth noting that the
    methods and frameworks used to apply differential privacy on large datasets may
    vary depending on the specific requirements and available resources. Techniques
    such as data partitioning, parallel processing, and optimized algorithms play
    a crucial role in efficiently computing differentially private aggregates on such
    vast datasets.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在大数据集上利用差异隐私，组织可以在不损害单个客户隐私的情况下提取有价值的见解。生成的差异隐私聚合允许数据驱动的决策和分析，同时保护敏感信息。值得注意的是，用于在大数据集上应用差异隐私的方法和框架可能因具体要求和可用资源而异。数据分区、并行处理和优化算法等技术在大规模数据集上高效计算差异隐私聚合中起着至关重要的作用。
- en: 'By understanding how to generate differentially private aggregates on large
    datasets, organizations can derive actionable insights from their data while upholding
    the privacy of individuals involved in the transactions. The dataset is organized
    in a specific format, with each day’s transactions stored in separate files that
    include the date in the filename. To illustrate, let’s consider an example where
    the dataset corresponds to transactions on February 1, 2022\. The file for this
    day uses the following format:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解如何在大数据集上生成差异隐私聚合，组织可以从其数据中提取可操作的见解，同时维护交易涉及的个人的隐私。数据集按特定格式组织，每天的交易存储在包含日期的单独文件中。为了说明，让我们考虑一个示例，其中数据集对应于2022年2月1日的交易。该天的文件使用以下格式：
- en: 'Filename: `2022-02-01.csv`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名：`2022-02-01.csv`
- en: The filename consists of the specific date in the format `YYYY-MM-DD`. In this
    case, `2022-02-01` represents the date of the transactions contained in the file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名由特定日期按`YYYY-MM-DD`格式组成。在这种情况下，`2022-02-01`代表文件中包含的交易日期。
- en: The actual content of the file will be the transaction data for that specific
    day, including details such as customer ID, transaction amount, POS terminal ID,
    and any other relevant information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的实际内容将是该特定日期的交易数据，包括客户ID、交易金额、POS终端ID以及其他任何相关信息。
- en: This file format, where each day’s transactions are stored in separate files
    with the date included in the filename, helps in organizing and managing the dataset
    chronologically.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文件格式，其中每天的交易存储在单独的文件中，文件名包含日期，有助于按时间顺序组织和管理工作集。
- en: 'It enables easy retrieval and analysis of transaction data from specific dates,
    facilitating time-based analysis and reporting tasks:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它使得从特定日期检索和分析交易数据变得容易，从而便于基于时间的分析和报告任务：
- en: '| **TRANSACTION_ID** | **TX_DATETIME** | **CUSTOMER_ID** | **TERMINAL_ID**
    | **TX_AMOUNT** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **交易ID** | **交易时间** | **客户ID** | **终端ID** | **交易金额** |'
- en: '| 0 | 2023-02-01 00:43:37 | 901 | 8047 | 82 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2023-02-01 00:43:37 | 901 | 8047 | 82 |'
- en: '| 1 | 2023-02-01 01:20:13 | 2611 | 7777 | 15 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2023-02-01 01:20:13 | 2611 | 7777 | 15 |'
- en: '| 2 | 2023-02-01 01:22:52 | 4212 | 3336 | 53 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2023-02-01 01:22:52 | 4212 | 3336 | 53 |'
- en: '| 3 | 2023-02-01 01:26:40 | 1293 | 7432 | 59 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2023-02-01 01:26:40 | 1293 | 7432 | 59 |'
- en: '| 4 | 2023-02-01 01:52:23 | 2499 | 1024 | 25 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2023-02-01 01:52:23 | 2499 | 1024 | 25 |'
- en: '| 5 | 2023-02-01 02:11:03 | 2718 | 168 | 68 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2023-02-01 02:11:03 | 2718 | 168 | 68 |'
- en: '| 6 | 2023-02-01 02:11:56 | 2998 | 5513 | 80 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 2023-02-01 02:11:56 | 2998 | 5513 | 80 |'
- en: Table 5.1 – First few rows of transactions data
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – 交易数据的前几行
- en: '| **TRANSACTION_ID** | **TX_DATETIME** | **CUSTOMER_ID** | **TERMINAL_ID**
    | **TX_AMOUNT** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **交易ID** | **交易时间** | **客户ID** | **终端ID** | **交易金额** |'
- en: '| 24901 | 2023-02-02 01:34:52 | 4999 | 4536 | 43 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 24901 | 2023-02-02 01:34:52 | 4999 | 4536 | 43 |'
- en: '| 24902 | 2023-02-02 01:44:39 | 580 | 3511 | 29 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 24902 | 2023-02-02 01:44:39 | 580 | 3511 | 29 |'
- en: '| 24903 | 2023-02-02 01:48:04 | 3309 | 7661 | 50 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 24903 | 2023-02-02 01:48:04 | 3309 | 7661 | 50 |'
- en: '| 24904 | 2023-02-02 01:58:12 | 2919 | 5322 | 94 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 24904 | 2023-02-02 01:58:12 | 2919 | 5322 | 94 |'
- en: '| 24905 | 2023-02-02 02:07:07 | 3868 | 3217 | 97 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 24905 | 2023-02-02 02:07:07 | 3868 | 3217 | 97 |'
- en: '| 24906 | 2023-02-02 02:08:43 | 1822 | 489 | 15 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 24906 | 2023-02-02 02:08:43 | 1822 | 489 | 15 |'
- en: Table 5.2 – Last few rows of transactions data
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 – 交易数据的最后几行
- en: For our use case scenario, where the core exercise is to createdifferentially
    private aggregates , let’s assume that the system receives data covering several
    months, and the objective is to generate differentially private aggregates of
    transactions for each POS terminal.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例场景，核心练习是创建差分隐私聚合，让我们假设系统接收覆盖数月的数据，目标是为每个POS终端生成差分隐私聚合的交易数据。
- en: '| **POS Terminal** | **Differentially** **private aggregates** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '**POS终端** | **差分** **隐私聚合** |'
- en: '| --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|  | Count | Sum | Average |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  | 计数 | 总和 | 平均值 |'
- en: '| 1 |  |  |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  |  |  |'
- en: '| 2 |  |  |  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 2 |  |  |  |'
- en: '| 3 |  |  |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 3 |  |  |  |'
- en: '| 4 |  |  |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 4 |  |  |  |'
- en: '| .. |  |  |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| .. |  |  |  |'
- en: Table 5.3 – Differentially private aggregates
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.3 – 差分隐私聚合
- en: While the use of frameworks such as Pytorch, pandas, and PyDP can be effective
    for generating differentially private aggregates, it is true that processing large
    datasets using these methods alone may be time-consuming and not scalable. However,
    there are alternative approaches and tools available to address these challenges.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Pytorch、pandas和PyDP等框架可以有效地生成差分隐私聚合，但确实，仅使用这些方法处理大量数据可能耗时且不可扩展。然而，有其他方法和工具可供选择，以应对这些挑战。
- en: 'These approaches include the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法包括以下内容：
- en: '**Parallel processing**: We could utilize parallel processing techniques to
    distribute the computation across multiple processors or machines. This can significantly
    reduce the processing time and enable scalability when dealing with large datasets.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行处理**：我们可以利用并行处理技术将计算分布在多个处理器或机器上。这可以显著减少处理时间，并在处理大量数据时实现可扩展性。'
- en: '**Distributed computing**: We could employ distributed computing frameworks
    such as Apache Spark or Hadoop to handle big data processing. These frameworks
    provide distributed data processing capabilities, allowing for efficient processing
    of large-scale datasets.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式计算**：我们可以采用Apache Spark或Hadoop等分布式计算框架来处理大数据。这些框架提供了分布式数据处理能力，允许高效处理大规模数据集。'
- en: '**Cloud computing**: We could leverage cloud computing platforms such as **Amazon
    Web Services** (**AWS**) or **Google Cloud Platform** (**GCP**) to harness the
    power of scalable infrastructure. These platforms offer services such as Amazon
    EMR, Google Dataproc, or Azure HDInsight, which can handle large-scale data processing
    in a cost-effective and scalable manner.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云计算**：我们可以利用如**亚马逊网络服务**（**AWS**）或**谷歌云平台**（**GCP**）这样的云计算平台来利用可扩展基础设施的力量。这些平台提供如Amazon
    EMR、Google Dataproc或Azure HDInsight等服务，可以以成本效益和可扩展的方式处理大规模数据处理。'
- en: '**Optimized differential privacy libraries**: We could explore specialized
    differential privacy libraries, such as PipelineDP, TensorFlow Privacy, or Opacus,
    that are designed to provide efficient and scalable implementations of differential
    privacy algorithms. These libraries offer optimizations specific to privacy-preserving
    computations, enabling faster, more scalable processing.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化后的差分隐私库**：我们可以探索专门设计的差分隐私库，例如PipelineDP、TensorFlow Privacy或Opacus，这些库旨在提供高效且可扩展的差分隐私算法实现。这些库提供了针对隐私保护计算的优化，使得处理更快、更可扩展。'
- en: '**Data partitioning and pre-aggregation**: We could divide the data into manageable
    partitions and perform pre-aggregation to reduce the overall computational load.
    This approach can improve performance by minimizing the amount of data processed
    at each step.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分区和预聚合**：我们可以将数据划分为可管理的分区，并执行预聚合以减少整体计算负载。这种方法通过最小化每一步处理的数据量来提高性能。'
- en: By incorporating these approaches and tools, it is possible to overcome the
    challenges of processing large datasets when generating differentially private
    aggregates. These methods can significantly reduce the processing time and enhance
    scalability, enabling organizations to efficiently analyze and derive insights
    from their data while preserving privacy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这些方法和工具，可以在生成差分隐私聚合时克服处理大数据集的挑战。这些方法可以显著减少处理时间并提高可扩展性，使组织能够高效地分析和从其数据中提取见解，同时保护隐私。
- en: '**Here are some questions/designs** **to consider:**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下是一些需要考虑的问题/设计：**'
- en: How can you solve or generate DP aggregates on large datasets?
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在大数据集上解决或生成DP聚合？
- en: How can you partition the data? (i.e., partitioning based on a date or on a
    POS terminal)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何对数据进行分区？（例如，基于日期或基于POS终端的分区）
- en: How can you apply DP within a given partition?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在给定的分区内应用DP？
- en: How do you find out the maximum and minimum value bounds to cacluate the (clip)
    function
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何找出最大和最小值界限来计算（剪辑）函数
- en: Should we apply DP (bounds/sensitivity) for each data value in a partition to
    generate the DP aggregates? OR
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否应该在分区中的每个数据值上应用DP（界限/敏感性）以生成DP聚合？或者
- en: Should we generate statistical aggregates first and then apply DP within the
    partition?
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该先生成统计聚合，然后再在分区内应用DP吗？
- en: PipelineDP high-level architecture
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PipelineDP高级架构
- en: The PipelineDP framework is designed to address the questions and considerations
    mentioned earlier when generating differentially private aggregates for large
    datasets.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: PipelineDP框架旨在解决在生成大数据集的差分隐私聚合时提到的先前问题和考虑因素。
- en: PipelineDP ([https://pipelinedp.io](https://pipelinedp.io)) is an open source
    framework that supports generating differentially private aggregates on large
    datasets using open source frameworks such as Apache Spark and Apache Beam. The
    PipelineDP framework was developed by Google in collaboration with OpenMined.
    As of writing this book, the PipelineDP team has a disclaimer that this framework
    isn’t recommended for production deployments but is considered good enough for
    development mode and demonstration purposes to enhance your understanding.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: PipelineDP ([https://pipelinedp.io](https://pipelinedp.io)) 是一个开源框架，它支持使用开源框架（如Apache
    Spark和Apache Beam）在大数据集上生成差分隐私聚合。PipelineDP框架由Google与OpenMined合作开发。截至撰写本书时，PipelineDP团队声明此框架不建议用于生产部署，但被认为足够用于开发模式和演示目的，以增强你的理解。
- en: '![Figure 5.9 – PipelineDP architecture](img/B16573_05_09.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – PipelineDP架构](img/B16573_05_09.jpg)'
- en: Figure 5.9 – PipelineDP architecture
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – PipelineDP架构
- en: PipelineDP provides APIs in three modes (Apache Spark, Apache Beam, and local
    mode) and access to their corresponding implementations through the DP engine.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: PipelineDP提供三种模式的API（Apache Spark、Apache Beam和本地模式）以及通过DP引擎访问其相应实现的方式。
- en: 'Here are the key concepts used in PipelineDP:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是PipelineDP中使用的核心概念：
- en: '![Figure 5.10 – Example to show privacy unit, privacy-id, and partition keys
    for sample data](img/B16573_05_10.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 示例展示样本数据的隐私单元、隐私-id和分区键](img/B16573_05_10.jpg)'
- en: Figure 5.10 – Example to show privacy unit, privacy-id, and partition keys for
    sample data
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 示例展示样本数据的隐私单元、隐私-id和分区键
- en: '**Record** is an element in the input dataset in PipelineDP.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录**是PipelineDP中输入数据集中的元素。'
- en: '**Partition** is a subset of the data corresponding to a given value of the
    aggregation criterion. In our case, we want the results per POS terminal, so the
    partition will be **TERMINAL_D**.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区**是数据的一个子集，对应于聚合标准的给定值。在我们的案例中，我们想要每个POS终端的结果，因此分区将是**TERMINAL_D**。'
- en: '**Partition key** is the aggregation key corresponding to a partition. TERMINAL_D
    is the partition key in this example.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区键**是对应于分区的聚合键。在本例中，TERMINAL_D是分区键。'
- en: '**Privacy unit** is the entity that we want to protect with differential privacy.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私单元**是我们想要使用差分隐私保护的实体。'
- en: '**Privacy ID** is an identifier of a privacy unit. In our example, CUSTOMER_IDis
    the privacy ID.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私ID**是隐私单元的标识符。在我们的例子中，CUSTOMER_ID是隐私ID。'
- en: Now that we understand the high-level architecture and key concepts, let’s implement
    differential privacy on a large dataset using PipelineDP.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了高级架构和关键概念，让我们使用PipelineDP在大数据集上实现差分隐私。
- en: The following line of code installs the PipelineDP framework.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行安装PipelineDP框架。
- en: '[PRE17]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Source code :* *Large_Data_Sets-DP_PipelineDP.ipynb*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码：* *Large_Data_Sets-DP_PipelineDP.ipynb*'
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Figure 5.11 – Transactions data](img/B16573_05_11.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 交易数据](img/B16573_05_11.jpg)'
- en: Figure 5.11 – Transactions data
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 交易数据
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code will produce the differentially private counts (total number
    of customers) for each terminal:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将生成每个终端的不同隐私计数（客户总数）：
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now generate the actual counts and compare them with differential privacy ones:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在生成实际的计数并与差分隐私计数进行比较：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Figure 5.12 – Transactions aggregates](img/B16573_05_12.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 交易聚合](img/B16573_05_12.jpg)'
- en: Figure 5.12 – Transactions aggregates
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 交易聚合
- en: By utilizing the PipelineDP framework, we can address the challenges and considerations
    involved in generating differentially private aggregates for large datasets. It
    provides a comprehensive solution that combines scalability, privacy preservation,
    and accurate aggregation, allowing us to effectively leverage differential privacy
    techniques for large-scale data analysis.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 PipelineDP 框架，我们可以解决生成大型数据集的差分隐私聚合所涉及到的挑战和考虑因素。它提供了一个综合的解决方案，结合了可扩展性、隐私保护和精确聚合，使我们能够有效地利用差分隐私技术进行大规模数据分析。
- en: Tumult Analytics
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tumult Analytics
- en: Tumult Analytics is a robust and feature-rich Python library designed for performing
    aggregate queries on tabular data while ensuring the principles of differential
    privacy. The library offers an intuitive interface, making it accessible to users
    familiar with SQL or PySpark. It provides a wide range of aggregation functions,
    data transformation operators, and privacy definitions, ensuring versatility in
    analytical tasks. Developed and maintained by a team of experts in differential
    privacy, Tumult Analytics guarantees reliability and is even utilized in production
    environments by reputable institutions such as the U.S. Census Bureau. Powered
    by Spark, the library demonstrates excellent scalability, enabling efficient processing
    of large datasets. With its comprehensive functionality and emphasis on privacy
    preservation, Tumult Analytics is a valuable tool for data analysis with a focus
    on maintaining data privacy.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Tumult Analytics 是一个功能丰富且健壮的 Python 库，旨在执行表格数据的聚合查询，同时确保差分隐私的原则。该库提供了一个直观的界面，使得熟悉
    SQL 或 PySpark 的用户能够使用。它提供了一系列的聚合函数、数据转换操作符和隐私定义，确保在分析任务中的多功能性。由差分隐私领域的专家团队开发和维护，Tumult
    Analytics 保证可靠性，甚至被像美国人口普查局这样的知名机构在生产环境中使用。由 Spark 驱动，该库展示了卓越的可扩展性，能够高效处理大型数据集。凭借其全面的功能和对隐私保护的重视，Tumult
    Analytics 是一个专注于维护数据隐私的数据分析的有价值工具。
- en: 'The following is the citation for the Tumult Analytics open source framework:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 Tumult Analytics 开源框架的引用：
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Installation of Tumult Analytics
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tumult Analytics 安装
- en: To utilize Tumult Analytics, it is essential to have Python installed, as the
    library is built using Python. It is compatible with Python versions 3.7 to 3.10\.
    Additionally, since Tumult Analytics leverages PySpark for its computations, it
    is necessary to have Java 8 or 11 installed as well.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Tumult Analytics，必须安装 Python，因为该库是用 Python 构建的。它与 Python 版本 3.7 到 3.10 兼容。此外，由于
    Tumult Analytics 使用 PySpark 进行计算，因此还需要安装 Java 8 或 11。
- en: The following code installs the Tumult Analytics framework.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码安装 Tumult Analytics 框架。
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Key features of Tumult Analytics
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tumult Analytics 的关键特性
- en: 'Tumult Analytics provides classes and methods to build aggregates on large
    datasets using differential privacy. Some of the high-level classes are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Tumult Analytics 提供了类和方法，用于在大型数据集上使用差分隐私构建聚合。以下是一些高级类：
- en: '| **Class** | **Methods** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **方法** |'
- en: '| Session(tmlt.analytics.session) | The Session module offers a convenient
    interface for managing data sources and conducting differentially private queries
    on them. Creating a session is straightforward, with Session.from_dataframe()
    for a simple session involving a single private data source or Session.Builder
    for more complex scenarios involving multiple data sources. Once the session is
    set up, queries can be executed on the data using Session.evaluate(). When initializing
    instance type of Session , PrivcyBudget is specified to ensure that the queries
    performed on the private data do not exceed this allocated budget. By default,
    the Session instance enforces privacy protection at the row level. This means
    that the queries prevent any potential attacker from deducing whether individual
    rows have been added or removed from the private tables. However, this privacy
    guarantee applies only to the queries themselves and assumes that the private
    data is not utilized elsewhere in the computation process. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| Session(tmlt.analytics.session) | Session 模块提供了一个方便的接口来管理数据源并对它们执行差分隐私查询。创建会话很简单，使用
    Session.from_dataframe() 来创建一个涉及单个私有数据源的简单会话，或者使用 Session.Builder 来处理涉及多个数据源的更复杂场景。一旦会话设置完成，就可以使用
    Session.evaluate() 在数据上执行查询。当初始化 Session 的实例类型时，指定 PrivcyBudget 以确保在私有数据上执行的查询不超过此分配的预算。默认情况下，Session
    实例在行级别强制执行隐私保护。这意味着查询阻止任何潜在的攻击者推断出是否将单个行添加或从私有表中删除。然而，这个隐私保证仅适用于查询本身，并假设私有数据在计算过程中没有在其他地方使用。|'
- en: '| PureDPBudget(tmlt.analytics.privacy_budget ) | A privacy budget that provides
    pure differential privacy. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| PureDPBudget(tmlt.analytics.privacy_budget ) | 提供纯差分隐私的隐私预算。|'
- en: '| ApproxDPBudgettmlt.analytics.privacy_budget ) | A privacy budget that provides
    approximate differential privacy. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| ApproxDPBudgettmlt.analytics.privacy_budget ) | 提供近似差分隐私的隐私预算。|'
- en: '| QueryBuilder(tmlt.analytics.query_builder) | A high-level interface for specifying
    DP queries. The QueryBuilder class can apply transformations, such as joins or
    filters, as well as compute aggregations including counts, sums, and standard
    deviation. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| QueryBuilder(tmlt.analytics.query_builder) | 一个用于指定 DP 查询的高级接口。QueryBuilder
    类可以应用转换，如连接或过滤，以及计算包括计数、总和和标准差在内的聚合。|'
- en: '| KeySet(tmlt.analytics.keyset) | A KeySet specifies a list of values for one
    or more columns. Currently, KeySets are used as a simpler way to specify domains
    for `groupb``y` transformations. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| KeySet(tmlt.analytics.keyset) | KeySet 指定一个或多个列的值列表。目前，KeySets 被用作指定 `groupb``y`
    转换域的更简单方式。|'
- en: Table 5.4 – tmlt.analytics.session description
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.4 – tmlt.analytics.session 描述
- en: Example application with Tumult Analytics
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Tumult Analytics 的示例应用
- en: Let’s generate the aggregates using tmlt-analytics on the large dataset used
    in the previous section (i.e., our transaction data).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 tmlt-analytics 在上一节中使用的大型数据集（即我们的交易数据）上生成聚合数据。
- en: '*Source* *code: DP_Large_Data_Sets_TMLT.ipynb*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：DP_Large_Data_Sets_TMLT.ipynb'
- en: 'Let’s import the required Python packages as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式导入所需的 Python 包：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, initialize the Spark session:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化 Spark 会话：
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s load the dataset that contains information about credit card transactions.
    We get the data from the local directory and load it into a Spark DataFrame:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载包含信用卡交易信息的数据集。我们从本地目录获取数据并将其加载到 Spark DataFrame 中：
- en: '**#Create a downloads directory and copy the transactions.csv file by unzipping
    the** **transactions.csv.zip file:**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**#创建一个下载目录并解压** **transactions.csv.zip 文件以复制 transactions.csv 文件：**'
- en: '[https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/transactions.csv.zip](https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/transactions.csv.zip)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/transactions.csv.zip](https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/transactions.csv.zip)'
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Initiating a tmlt-analytics session
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动 tmlt-analytics 会话
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When a session is initialized with a finite privacy budget, it offers a straightforward
    interface promise: all queries executed on this session, collectively, will yield
    differentially private outcomes with a maximum epsilon value of 3.5\. Epsilon
    serves as a metric for quantifying potential privacy loss, where a lower epsilon
    implies a more stringent constraint on privacy loss and, consequently, a higher
    level of protection. In this context, the interface promise corresponds to a privacy
    guarantee, ensuring a minimum level of safeguarding for private data.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话使用有限的隐私预算初始化时，它提供了一个直接的接口承诺：在这个会话上执行的查询，总体上，将产生具有最大 epsilon 值 3.5 的差分隐私结果。Epsilon
    是衡量潜在隐私损失的一个指标，较低的 epsilon 表示对隐私损失有更严格的限制，从而提供更高的保护水平。在这种情况下，接口承诺对应于隐私保证，确保对私有数据有最低级别的保护。
- en: 'In addition to the data itself, several additional pieces of information are
    required:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据本身之外，还需要一些额外的信息：
- en: The **privacy_budget** parameter specifies the privacy guarantee that the session
    will provide.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私预算**参数指定了会话将提供的隐私保证。'
- en: The **source_id** parameter serves as an identifier for the DataFrame. It will
    be used to reference this specific DataFrame when constructing queries.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**source_id**参数作为 DataFrame 的标识符。它将被用来在构建查询时引用这个特定的 DataFrame。'
- en: The **protected_change** parameter defines the unit of data for which the differential
    privacy guarantee is applied. In this example, **AddOneRow()** is used to protect
    individual rows within the dataset.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**protected_change**参数定义了差分隐私保证应用的数据单元。在这个例子中，**AddOneRow()**用于保护数据集中的单个行。'
- en: Exeucting DP queries using Session
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Session 执行 DP 查询
- en: 'Our first query finds the number of total transactions in the data with DP
    enabled:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次查询是在启用 DP 的情况下找到数据中的总交易数量：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To execute the query on the desired private data, we utilize `QueryBuilder("transactions")`
    in the first step, which indicates the specific source data (data source) we want
    to query, corresponding to the `source_id` parameter specified earlier. In the
    following line, the `count()` statement is used to retrieve the total number of
    records in the dataset. Once the query is constructed, we proceed to run it on
    the data by employing the `evaluate` method of our session. To accomplish this,
    we allocate a privacy budget to the evaluation process. In this case, we evaluate
    the query with differential privacy, setting ε=1 as the privacy parameter:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要在所需私有数据上执行查询，我们在第一步使用 `QueryBuilder("transactions")`，这表示我们想要查询的特定源数据（数据源），对应于之前指定的
    `source_id` 参数。在下一行，使用 `count()` 语句检索数据集中的总记录数。一旦构建了查询，我们就通过使用会话的 `evaluate` 方法在数据上运行它。为此，我们将隐私预算分配给评估过程。在这种情况下，我们使用差分隐私评估查询，将
    ε=1 设置为隐私参数：
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The results of the query are returned as a Spark DataFrame. We can see them
    using the `show()` method of this DataFrame. We have utilized 1 out of 3.5 of
    our allocated privacy budget for this query, so the remaining privacy budget will
    be 2.5:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的结果以 Spark DataFrame 的形式返回。我们可以使用这个 DataFrame 的 `show()` 方法来查看它们。我们为这个查询使用了
    3.5 个隐私预算中的 1 个，所以剩余的隐私预算将是 2.5：
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you are following along with the example and executing the code, you may
    observe varying values. This variation is a fundamental aspect of differential
    privacy, as it introduces randomization (referred to as noise) during query execution.
    To showcase this characteristic, let’s proceed to evaluate the same query one
    more time and see the result.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随示例并执行代码，你可能会观察到不同的值。这种变化是差分隐私的基本方面，因为它在查询执行期间引入了随机化（称为噪声）。为了展示这一特性，让我们再次评估相同的查询并查看结果。
- en: 'The amount of noise added to the query computation can vary based on the privacy
    parameters, the type of aggregation, and the underlying data. However, in many
    instances, the query result still provides reliable insights into the original
    data. In this particular scenario, we can confirm this by executing a count query
    directly on the original DataFrame, which will yield the true and accurate result:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 查询计算中添加的噪声量可能取决于隐私参数、聚合类型和基础数据。然而，在许多情况下，查询结果仍然提供了对原始数据的可靠见解。在这个特定场景中，我们可以通过直接在原始
    DataFrame 上执行计数查询来确认这一点，这将产生真实和准确的结果：
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Playing with privacy budgets
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩转隐私预算
- en: Describe the session object to know the attributes and the remaining privacy
    budget.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 描述会话对象以了解其属性和剩余的隐私预算。
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Utilizing privacy budgets with privacy queries
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用隐私预算进行隐私查询
- en: Let’s find out the number of customers whose purchases are worth less than $25.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出购买金额低于25美元的客户数量。
- en: 'This query consumes epsilon=1 out of our total budget:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询消耗了我们的总预算中的epsilon=1：
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have utilized 1 unit of our remaining total privacy budget of 2.5, so there
    is 1.5 left. Let’s try another query to consume another 1 unit of the privacy
    budget:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了剩余总隐私预算中的1个单位，所以还剩下1.5个单位。让我们尝试另一个查询来消耗另一个1个单位的隐私预算：
- en: Let’s find out the number of customers whose purchases are greater than $25
    but less than $50.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出购买金额大于25美元但小于50美元的客户数量。
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have utilized a budget of 3 out of a total of 3.5, so there is 0.5 left.
    Let’s try another query to consume the privacy budget of 1 (run the query more
    than the available budget and observe the results).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了3个单位中的3.5个单位，所以还剩下0.5个单位。让我们尝试另一个查询来消耗1个单位的隐私预算（运行查询超过可用预算并观察结果）。
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It will throw a runtime error as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它将抛出以下运行时错误：
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let’s display the remaining privacy budget for use in the subsequent queries.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们显示剩余的隐私预算，以便在后续查询中使用。
- en: '`print(session.remaining_privacy_budget)`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(session.remaining_privacy_budget)`'
- en: '[PRE38]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Rewrite the last query so that it will make use of the remaining available
    budget so that the privacy budget is used completely, instead of wasting the unused
    budget. In this case, we will not specify the privacy budget as 1 or 2, but will
    make use of the remaining privacy budget from the `Session` class itself:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写最后一个查询，使其能够利用剩余的可用预算，以便完全使用隐私预算，而不是浪费未使用的预算。在这种情况下，我们不会指定隐私预算为1或2，而是将使用`Session`类本身的剩余隐私预算：
- en: '[PRE39]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Total number of high purchase counts by applying differential privacy.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用差分隐私计算的高购买次数总数。
- en: '**Groupby queries**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**分组查询**'
- en: In Tumult Analytics, the KeySet class is utilized to define the list of groupby
    keys. It allows us to specify both the columns by which we intend to group the
    data and the potential values associated with those columns. The KeySet class
    serves as a convenient means of specifying the grouping criteria in Tumult Analytics.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tumult Analytics中，KeySet类被用来定义分组键的列表。它允许我们指定我们打算按哪些列对数据进行分组，以及与这些列关联的潜在值。KeySet类在Tumult
    Analytics中作为指定分组标准的一种便捷方式。
- en: Let’s now write a query to find the average transaction amount on each terminal
    (taking just the first 10 terminals for this example).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个查询来查找每个终端的平均交易金额（在这个例子中仅取前10个终端）。
- en: 'Create a session with the privacy budget set to 2.5:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个隐私预算设置为2.5的会话：
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Make use of the `KeySet` class and define the groupby column (TERMINAL_ID)
    or columns and values as well, to filter:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`KeySet`类并定义分组列（TERMINAL_ID）或列和值，以进行过滤：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Execute the query and provide the lower and upper bounds to clip `TX_AMOUNT`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询并提供剪裁`TX_AMOUNT`的下限和上限：
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this way, we can generate the aggregates using differential privacy, ensuring
    they are not the same as the actual aggregates.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以使用差分隐私生成汇总，确保它们与实际汇总不同。
- en: Queries using privacy IDs
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用隐私ID的查询
- en: Previously, we focused on working with tables where each individual in the dataset
    was linked to a single row. However, this is not always the case. In certain datasets,
    it is possible for the same individual to appear in multiple rows. In such cases,
    it is typical to assign a unique identifier to each person (i.e., across different
    rows). The objective then shifts toward concealing whether all the rows associated
    with a particular identifier are present in the data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们专注于处理每个数据集中的个体都链接到单行表的表格。然而，这并不总是情况。在某些数据集中，同一个人可能出现在多个行中。在这种情况下，通常会给每个人分配一个唯一的标识符（即跨不同行）。目标随后转向隐藏与特定标识符关联的所有行是否都存在于数据中。
- en: Tumult Analytics refers to these identifiers as privacy IDs. Each privacy ID
    corresponds to a one-to-one mapping with a person or any other entity that requires
    protection. The aim is to safeguard the privacy of individuals or entities by
    preserving the anonymity of their presence within the dataset. This can be achieved
    by making use of the `AddRowsWithID` protected change. This protected change will
    prevent arbitrarily adding and removing many rows all sharing the same ID.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Tumult Analytics 将这些标识符称为隐私ID。每个隐私ID与一个人或任何其他需要保护的实体进行一对一映射。目标是通过对数据集中存在的匿名性进行保护来保护个人或实体的隐私。这可以通过使用
    `AddRowsWithID` 受保护更改来实现。此受保护更改将防止任意添加和删除许多具有相同ID的行。
- en: 'Initializing a session with the privacy ID:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐私ID初始化会话：
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Execute the query with the privacy ID:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐私ID执行查询：
- en: '[PRE44]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s execute this code and observe the output:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行此代码并观察输出：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This error arises due to the absence of a constraint on the number of rows a
    single individual can contribute to the dataset. It is possible for a single customer
    to do many transactions, even exceeding 1,000 or more. However, differential privacy
    necessitates concealing the influence of an individual’s data through the introduction
    of statistical noise.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是由于缺少对单个个人可以向数据集贡献的行数的限制。单个客户可能进行许多交易，甚至超过1,000行或更多。然而，差分隐私需要通过引入统计噪声来隐藏个人数据的影响。
- en: 'In order to address this issue, it is necessary to establish a restriction
    on the maximum influence that a single customer can exert on the computed statistic
    before conducting aggregations. This constraint is enforced on the data to mitigate
    any potential impact. The most straightforward constraint, known as `MaxRowsPerID`,
    restricts the total number of rows contributed by each privacy ID. To enforce
    this constraint, we can simply pass it as a parameter to the `enforce()` operation.
    For the specific query at hand, we will set the maximum number of contributed
    rows per library member to 100:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，有必要在执行聚合之前对单个客户对计算统计量的最大影响建立限制。此限制被应用于数据以减轻任何潜在的影响。最直接的约束，称为 `MaxRowsPerID`，限制了每个隐私ID贡献的总行数。为了强制执行此约束，我们可以简单地将它作为参数传递给
    `enforce()` 操作。对于当前的具体查询，我们将设置每个图书馆成员贡献的最大行数为100：
- en: '[PRE46]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding output only showing the top 20 rows.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出仅显示了前20行。
- en: Tumult Analytics provides filters, joins, and transformations of the data to
    execute complex queries, apply differential privacy to large datasets, and make
    use of Spark distributed processing. We have covered the basic key features, but
    there are many more features to explore based on the use cases in the application/system.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Tumult Analytics 提供了数据过滤、连接和转换功能，以执行复杂查询，对大型数据集应用差分隐私，并利用 Spark 分布式处理。我们已经涵盖了基本的关键特性，但基于应用/系统中的用例，还有许多更多特性可以探索。
- en: Machine learning using differential privacy
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用差分隐私的机器学习
- en: In this section, our objective is to develop a machine learning classification
    model that can accurately distinguish between fraudulent and genuine credit card
    transactions. To ensure privacy protection, we will also apply differential privacy
    techniques to the model. The classification model will be trained on a labeled
    dataset consisting of historical credit card transactions, where each transaction
    is labeled as either fraudulent or genuine. Popular machine learning algorithms
    such as logistic regression, decision trees, or neural networks can be applied
    to build the classification model and will make use of neural networks in our
    case.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的目标是开发一个机器学习分类模型，能够准确地区分欺诈和真实的信用卡交易。为了确保隐私保护，我们还将对模型应用差分隐私技术。分类模型将在包含历史信用卡交易的历史数据集上训练，其中每笔交易都被标记为欺诈或真实。像逻辑回归、决策树或神经网络这样的流行机器学习算法可以应用于构建分类模型，在我们的案例中我们将使用神经网络。
- en: To incorporate differential privacy, we will leverage techniques such as the
    addition of noise to the training process and the use of privacy-preserving algorithms.
    These techniques ensure that the model’s training process and subsequent predictions
    do not compromise the privacy of individual transactions or sensitive customer
    information.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入差分隐私，我们将利用向训练过程添加噪声和使用隐私保护算法等技术。这些技术确保模型的训练过程和随后的预测不会损害单个交易或敏感客户信息的隐私。
- en: By integrating differential privacy into the classification model, we can provide
    robust privacy guarantees while maintaining high accuracy in identifying fraudulent
    transactions. This ensures that the model can effectively protect customers’ privacy
    and prevent unauthorized access to sensitive financial data.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we will explore the steps involved in training the
    classification model, evaluating its performance, and applying differential privacy
    techniques to enhance privacy protection. By the end, we will have a powerful
    model capable of accurately classifying credit card transactions as either fraudulent
    or genuine while ensuring the privacy of the individuals involved.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Synthetic Dataset Generation: Introducing Fraudulent Transactions'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will make use of the same transaction data used earlier, add another column
    to the dataset called `TX_FRAUD`, and mark any transaction greater than $75 as
    fraudulent. This obviously doesn’t reflect the real world, but we will generate
    our example synthetic data using this rule. In this dataset, roughly 25% of the
    data is marked as fraudulent transactions while 75% of the data is genuine. In
    a real-world scenario, fraudulent transactions will likely be less than 1% in
    most datasets, which is highly imbalanced.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '*Source* *code: Fraud_Transactions_Generator.ipynb*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Figure 5.13 – Transactions Data](img/B16573_05_13.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Transactions Data
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 4557166 rows × 6 columns
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![Figure 5.14 – First few rows of transactions data](img/B16573_05_14.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – First few rows of transactions data
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Develop a classification model using scikit-learn
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the high-level steps for developing a classification model:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Load the **fraud_transactions** dataset.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split the dataset into train and test in the ratio of (70:30).
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the classifier (logistic regression from sci-kit learn).
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Train the classifier with the training data (70% of the transactions).
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out the accuracy of the classifier with the test dataset (30% of the transactions).
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out the calculated weights/coefficient used in the **decision** function
    and intercept from the logistic regression model.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Source* *code: Noise_Gradient_Final.ipynb*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Figure 5.15 – Fraud transactions dataset](img/B16573_05_15.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Fraud transactions dataset
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once we know the gradients/coefficients of the classifier and intercept as
    well, then it will be easy to calculate the predictions. In our case, we have
    three features, `CUSTOMER_ID`, `TERMINAL_ID`, and `TRANSACTON_AMOUNT`. The linear
    equation will come with three features:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '*y = w1 * x1 + w2 * x2 + w3 * x3 + b*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know the feature values (x1, x2, x3…. xn), weights (w1, w2, w3, …,
    wn), and b value (bias /intercept), then we can calculate the y-hat value (predictions).
    Logistic regression uses a logistic function to estimate/predict the probabilities.
    In our case, it will be the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: y-hat = 1.0 / 1.0 + e – (w1 * x1 + w2 * x2 + w3 * x3 + b)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take one actual transaction and calculate the prediction value using
    the weights obtained from the model:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将取一个实际交易并使用从模型获得的权重来计算预测值：
- en: '| CUSTOMER_ID | TERMINAL_ID | TX_AMOUNT | TX_FRAUD |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| CUSTOMER_ID | TERMINAL_ID | TX_AMOUNT | TX_FRAUD |'
- en: '| 79 | 3115 | 78 | 1 |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 79 | 3115 | 78 | 1 |'
- en: Table 5.16 – Prediction for CUSTOMER_ID
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.16 – 对CUSTOMER_ID的预测
- en: '[PRE52]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Logistic regression uses the stochastic gradient descent algorithm internally
    in order to calculate gradients/coefficients.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归在内部使用随机梯度下降算法来计算梯度/系数。
- en: Let’s implement our own stochastic gradient descent algorithm to calculate the
    weights instead of using the scikit-learn-provided one in the logistic regression
    model.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现自己的随机梯度下降算法来计算权重，而不是使用逻辑回归模型中scikit-learn提供的算法。
- en: High-level implementation of the SGD algorithm
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SGD算法的高级实现
- en: 'The steps to implement the SGD algorithm are as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 实现SGD算法的步骤如下：
- en: 'Initialize the initial weights with all zeros (one zero for each feature and
    the bias/intercept also as zero): Initial weights = [0,0,0] and intercept=0'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将初始权重初始化为零（每个特征一个零，偏置/截距也设为零）：初始权重 = [0,0,0] 和截距=0
- en: 'Do the following for each row in the training data:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对训练数据中的每一行执行以下操作：
- en: Calculate the predictions based on the initial weights and intercept.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据初始权重和截距计算预测。
- en: 'Find out the error between the actual value and the predicted value:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找实际值和预测值之间的误差：
- en: '*Error = Actual Value –* *Predicted Value*'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*误差 = 实际值 – 预测值*'
- en: 'Update the intercept based on the error and the learning rate value:'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据误差和学习率值更新截距：
- en: intercept= intercept + l_rate * error * yhat * (1.0 - yhat)
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: intercept= intercept + l_rate * error * yhat * (1.0 - yhat)
- en: Update the weights for all training data in the training set.
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新训练集中所有训练数据的权重。
- en: Based on the number of epochs, repeat the preceding steps.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据epoch的数量，重复前面的步骤。
- en: '[PRE53]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this way, we can calculate the coefficients. The final coefficients are calculated
    as the average of all coefficients/gradients.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以计算系数。最终系数是所有系数/梯度的平均值。
- en: Applying differential privacy options using machine learning
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用机器学习应用差分隐私选项
- en: Applying differential privacy to the preceding algorithm means generating gradients
    with differential privacy so that the model doesn’t reveal the details of the
    training examples. When applying differential privacy to SGD, the objective is
    to incorporate privacy protection into the training process of the machine learning
    model. This involves adding noise to the gradients computed during the SGD optimization
    steps to ensure that the trained model does not reveal specific details about
    any individual data point.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 将差分隐私应用于前面的算法意味着生成具有差分隐私的梯度，这样模型就不会泄露训练示例的细节。当将差分隐私应用于SGD时，目标是将隐私保护集成到机器学习模型的训练过程中。这涉及到在SGD优化步骤中添加噪声到计算的梯度，以确保训练好的模型不会泄露关于任何单个数据点的具体细节。
- en: The addition of noise in SGD with differential privacy helps prevent potential
    privacy breaches by making it difficult to distinguish the impact of any particular
    training example on the model’s updates. It ensures that the model’s parameters
    do not memorize or overfit specific training samples, thereby offering privacy
    guarantees for the individuals whose data was used in the training process.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有差分隐私的SGD中添加噪声有助于通过使区分任何特定训练示例对模型更新的影响变得困难来防止潜在的隐私泄露。它确保模型的参数不会记住或过度拟合特定的训练样本，从而为在训练过程中使用的数据的个体提供隐私保证。
- en: Generating gradients using differential privacy
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用差分隐私生成梯度
- en: There are two approaches for generating gradients using differential privacy
    in the context of machine learning.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习环境中使用差分隐私生成梯度有两种方法。
- en: '**Approach 1:**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法1：**'
- en: Generate the final gradients using the normal SGD algorithm on the training
    data.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正常SGD算法在训练数据上生成最终梯度。
- en: Calculate the sum of the gradients obtained from the preceding SGD step.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算从前一个SGD步骤获得的梯度的总和。
- en: Add noise to the sum of the gradients using the Laplace mechanism, taking into
    account the desired sensitivity and privacy budget.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用拉普拉斯机制对梯度的总和添加噪声，考虑到所需的敏感性和隐私预算。
- en: '**Approach 2:**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法2：**'
- en: Apply the clipping method to each training example or the overall training data.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个训练示例或整体训练数据应用剪裁方法。
- en: Generate gradients using the clipped training data inputs.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用剪裁的训练数据输入生成梯度。
- en: Compute the sum of the gradients obtained in the previous step.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算上一步获得的梯度的总和。
- en: Add noise to the sum of the gradients using either the Gaussian or Laplace mechanism,
    considering the desired sensitivity and privacy budget.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用高斯或拉普拉斯机制对梯度总和添加噪声，考虑所需的敏感度和隐私预算。
- en: Calculate the count of the training examples using differential privacy, treating
    it as a count query with sensitivity set to 1 and utilizing the required privacy
    budget.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用差分隐私计算训练示例的数量，将其视为敏感度设置为1的计数查询，并利用所需的隐私预算。
- en: Compute the average of the noisy gradients sum and the noisy count to obtain
    the differentially private gradients average.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算噪声梯度总和和噪声计数的平均值，以获得差分隐私梯度平均值。
- en: Both approaches aim to incorporate differential privacy into the gradient calculation
    process, thereby protecting the privacy of individual training examples while
    training the machine learning model. The choice between the two approaches depends
    on the specific requirements of the application and the desired level of privacy
    guarantees.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都旨在将差分隐私纳入梯度计算过程，从而在训练机器学习模型的同时保护单个训练示例的隐私。选择这两种方法之间的差异取决于应用的特定要求和期望的隐私保证水平。
- en: By adding appropriate noise and applying privacy-preserving mechanisms, these
    approaches ensure that the gradients used for updating the model parameters do
    not reveal sensitive information about individual training examples. This enables
    the training process to provide privacy guarantees while still achieving accurate
    and reliable model performance.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加适当的噪声并应用隐私保护机制，这些方法确保用于更新模型参数的梯度不会泄露关于单个训练示例的敏感信息。这使得训练过程能够在提供隐私保证的同时，仍然实现准确和可靠的模式性能。
- en: Let’s now implement *Approach 2* for our fraud detection example.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的欺诈检测示例实现*方法2*。
- en: 'As we know, clipping is the process of setting the lower and upper bounds for
    the data, so implement the following `clip` function:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，裁剪是设置数据上下限的过程，因此实现以下`clip`函数：
- en: '[PRE54]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By combining SGD with differential privacy, as we have done here, we can develop
    machine learning models that not only provide accurate predictions but also offer
    privacy protection for sensitive data. It enables organizations to leverage large-scale
    datasets while adhering to privacy regulations and ethical considerations.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将随机梯度下降（SGD）与差分隐私相结合，正如我们在这里所做的那样，我们可以开发出既提供准确预测又为敏感数据提供隐私保护的机器学习模型。这使组织能够在遵守隐私法规和道德考量的情况下利用大规模数据集。
- en: Clustering using differential privacy
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用差分隐私进行聚类
- en: Let’s consider a scenario where we have a dataset of users’ browsing behavior.
    The goal of k-means clustering in this context is to identify *k* points, referred
    to as cluster centers, that minimize the sum of squared distances of the data
    points from their nearest cluster center. This partitioning allows us to group
    the users based on their browsing patterns. Additionally, we can assign new users
    to a group based on the closest cluster center. However, the release of the cluster
    centers could potentially reveal sensitive information about specific users. For
    instance, if a particular user’s browsing behavior is significantly different
    from the majority, the standard k-means clustering algorithm might assign a cluster
    center specifically to this user, thereby disclosing sensitive details about their
    browsing habits. To address this privacy concern, we will implement clustering
    with differential privacy. By doing so, we aim to protect the privacy of individual
    users while still providing meaningful clustering results based on their browsing
    behavior.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，其中我们有一个用户浏览行为的数据库集。在这种情况下，k-means聚类的目标是识别*k*个点，称为聚类中心，这些点使数据点到其最近聚类中心的平方距离之和最小化。这种分区使我们能够根据用户的浏览模式对用户进行分组。此外，我们还可以根据最近聚类中心将新用户分配到一组。然而，聚类中心的发布可能会泄露关于特定用户的敏感信息。例如，如果某个用户的浏览行为与大多数用户显著不同，标准的k-means聚类算法可能会为该用户分配一个特定的聚类中心，从而泄露关于其浏览习惯的敏感细节。为了解决这个隐私问题，我们将实现具有差分隐私的聚类。通过这样做，我们旨在保护单个用户的隐私，同时仍然根据他们的浏览行为提供有意义的聚类结果。
- en: 'First, to illustrate the nature of the problem, let’s generate our cluster
    centroids without differential privacy:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了说明问题的本质，让我们在不使用差分隐私的情况下生成我们的聚类中心：
- en: '*Source* *code: Clustering_Differential_Privacy_diffprivlib.ipynb*'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码：Clustering_Differential_Privacy_diffprivlib.ipynb*'
- en: '[PRE55]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, we have a synthetic dataset with two sensitive data
    attributes. We perform clustering using the KMeans algorithm from scikit-learn
    without incorporating differential privacy. We retrieve the cluster centroids
    using the `cluster_centers_` attribute.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个包含两个敏感数据属性的合成数据集。我们使用scikit-learn中的KMeans算法进行聚类，而不包含差分隐私。我们使用`cluster_centers_`属性检索聚类中心。
- en: The problem with this approach is that the cluster centroids, which represent
    the center of each cluster, can reveal sensitive information about the data. In
    this case, the cluster centroids could potentially expose the mean values of the
    sensitive attributes. To address this privacy concern, differential privacy techniques
    can be applied to add noise to the cluster centroids, making it more challenging
    to infer sensitive information. However, note that the application of differential
    privacy in clustering algorithms requires careful consideration of privacy-utility
    trade-offs and appropriate privacy parameter selection.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，代表每个聚类中心的聚类中心可能会泄露关于数据的敏感信息。在这种情况下，聚类中心可能会暴露敏感属性的均值。为了解决这个隐私问题，可以应用差分隐私技术向聚类中心添加噪声，使其更难以推断敏感信息。然而，请注意，在聚类算法中应用差分隐私需要仔细考虑隐私-效用权衡和适当的隐私参数选择。
- en: Let’s generate the centroids by adding noise to the datasets.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向数据集添加噪声来生成中心点。
- en: 'Follow these steps:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Define the **add_noise** function, which takes the original data, privacy parameter
    epsilon, and sensitivity as inputs. It generates Laplace-distributed noise and
    adds it to the data points. The noise is scaled by the sensitivity and privacy
    parameter epsilon.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义**add_noise**函数，该函数接受原始数据、隐私参数epsilon和敏感性作为输入。它生成拉普拉斯分布的噪声并将其添加到数据点。噪声按敏感性比例和隐私参数epsilon缩放。
- en: Calculate the sensitivity, which is the maximum change in data points due to
    the addition or removal of a single data point. In this case, we calculate the
    maximum absolute difference between any data point and the mean of the dataset.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算敏感性，即由于添加或删除单个数据点而引起的数据点的最大变化。在这种情况下，我们计算任何数据点与数据集均值的最大绝对差异。
- en: Specify the privacy parameter epsilon, which determines the amount of noise
    to be added. Add noise to the data points using the **add_noise** function.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定隐私参数epsilon，它决定了要添加的噪声量。使用**add_noise**函数向数据点添加噪声。
- en: Perform clustering on the noisy data using k-means clustering with two clusters.
    Retrieve the cluster labels assigned by the algorithm. Print the original data
    points, noisy data points, and the clusters assigned to each point.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用k-means聚类对噪声数据进行聚类，使用两个聚类。检索算法分配的聚类标签。打印原始数据点、噪声数据点和分配给每个点的聚类。
- en: '[PRE56]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Generating differentially private centroids using IBM’s diffprivlib framework
    as an alternative method to the same use case “browsing** **behaviour scenario”.**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用IBM的diffprivlib框架生成不同的隐私中心，作为“浏览** **行为场景”相同用例的替代方法**。'
- en: 'The diffprivlib framework is a Python library that provides tools and algorithms
    for performing differentially private data analysis. `Diffprivlib` consists of
    four main components that contribute to its functionality:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: diffprivlib框架是一个Python库，提供了执行差分隐私数据分析的工具和算法。`Diffprivlib`由四个主要组件组成，这些组件有助于其功能：
- en: '**Mechanisms**: These components serve as the fundamental building blocks of
    differential privacy and are utilized in all models implementing differential
    privacy. Mechanisms in diffprivlib are customizable and designed for use by experts
    who are implementing their own models.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机制**：这些组件是差分隐私的基本构建块，并被用于所有实现差分隐私的模型中。diffprivlib中的机制是可定制的，旨在供实施自己模型的专家使用。'
- en: '**Models**: This module encompasses machine learning models integrated with
    differential privacy. **Diffprivlib** provides a variety of models that implement
    differential privacy, including clustering, classification, regression, dimensionality
    reduction, and preprocessing. These models are designed to ensure privacy while
    performing their respective tasks.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：此模块包含与差分隐私集成的机器学习模型。**Diffprivlib**提供了多种实现差分隐私的模型，包括聚类、分类、回归、降维和预处理。这些模型旨在在执行各自任务的同时确保隐私。'
- en: '**Tools**: **Diffprivlib** offers a range of generic tools designed for differentially
    private data analysis. These tools provide functionalities such as differentially
    private histograms, which adhere to the same format as NumPy’s histogram function.
    They enable users to perform various data analysis tasks while preserving privacy.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具**：**Diffprivlib**提供了一系列通用的工具，旨在用于差分隐私数据分析。这些工具提供了如差分隐私直方图等功能，其格式与NumPy的直方图函数相同。它们使用户能够在保护隐私的同时执行各种数据分析任务。'
- en: '**Accountant**: The accountant component includes the **BudgetAccountant**
    class, which facilitates the tracking of privacy budgets and calculation of total
    privacy loss using advanced composition techniques. This feature is crucial for
    managing and controlling privacy expenditure across multiple differentially private
    operations, ensuring that privacy guarantees are maintained. Together, these components
    in diffprivlib contribute to a comprehensive framework for implementing differential
    privacy in various data analysis scenarios. They provide the necessary tools,
    models, mechanisms, and privacy accounting capabilities to support privacy-preserving
    data analysis tasks.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会计**：会计组件包括**BudgetAccountant**类，它通过高级组合技术促进隐私预算的跟踪和计算总隐私损失。这一功能对于管理和控制多个差分隐私操作中的隐私支出至关重要，确保隐私保证得到维持。diffprivlib中的这些组件共同构成了一个全面的框架，用于在各种数据分析场景中实现差分隐私。它们提供了必要的工具、模型、机制和隐私会计能力，以支持隐私保护的数据分析任务。'
- en: Let’s generate cluster centroids using the diffprivlib framework.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用diffprivlib框架生成聚类中心。
- en: 'Install the `diffprivlib` framework using `pip`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`安装`diffprivlib`框架：
- en: '[PRE57]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Follow these steps:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Import the **KMeans** class from **diffprivlib.models**.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**diffprivlib.models**导入**KMeans**类。
- en: Specify the epsilon privacy parameter=, which determines the strength of privacy
    protection.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定epsilon隐私参数=，它决定了隐私保护强度。
- en: Create an instance of KMeans with the **epsilon** parameter and the desired
    number of clusters.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有**epsilon**参数和所需簇数的KMeans实例。
- en: Fit the differentially private KMeans model to the data using the **fit** method.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**fit**方法将差分隐私KMeans模型拟合到数据。
- en: Finally, retrieve the differentially private cluster centroids using the **cluster_centers_**
    attribute of the KMeans model.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用KMeans模型的**cluster_centers_**属性检索差分隐私聚类中心。
- en: '[PRE58]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It’s important to note that differential privacy in diffprivlib operates under
    the assumption of a trusted curator, where privacy guarantees are provided if
    the curator follows the privacy-preserving mechanisms correctly.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，diffprivlib中的差分隐私是在假设有一个可信的监管者的前提下运行的，如果监管者正确遵循隐私保护机制，则提供隐私保证。
- en: However, for a complete implementation of differential privacy, additional considerations,
    such as the choice of appropriate privacy parameters and the impact on data utility,
    should be carefully addressed.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了完整实现差分隐私，还需要仔细考虑一些额外的因素，例如选择合适的隐私参数以及数据效用的影响。
- en: Deep learning using differential privacy
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用差分隐私的深度学习
- en: In this section, we will focus on developing a fraud detection model using the
    PyTorch framework. Additionally, we will train deep learning models with differential
    privacy using open source frameworks such as PyTorch and Opacus. Using the PyTorch
    framework, we will develop a deep learning model specifically designed for fraud
    detection. PyTorch is a popular open source deep learning library that provides
    a flexible and efficient platform for building and training neural networks. Its
    rich set of tools and APIs make it well-suited for developing sophisticated machine
    learning models.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于使用PyTorch框架开发一个欺诈检测模型。此外，我们将使用如PyTorch和Opacus等开源框架，通过差分隐私训练深度学习模型。使用PyTorch框架，我们将开发一个专门针对欺诈检测的深度学习模型。PyTorch是一个流行的开源深度学习库，它提供了一个灵活且高效的平台，用于构建和训练神经网络。其丰富的工具和API使其非常适合开发复杂的机器学习模型。
- en: To incorporate differential privacy into the training process, we will utilize
    the Opacus library. Opacus is an open source PyTorch extension that provides tools
    for training deep learning models with differential privacy. It offers mechanisms
    such as gradient clipping, noise addition, and privacy analysis, which help ensure
    that the trained model preserves the privacy of individual data points.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将差分隐私纳入训练过程，我们将利用 Opacus 库。Opacus 是一个开源的 PyTorch 扩展，为训练具有差分隐私的深度学习模型提供工具。它提供了梯度裁剪、噪声添加和隐私分析等机制，有助于确保训练的模型保护单个数据点的隐私。
- en: By combining PyTorch and Opacus, we can train deep learning models with differential
    privacy for fraud detection. This approach allows us to benefit from the expressive
    power of deep learning while adhering to privacy regulations and protecting sensitive
    information. Throughout this section, we will explore techniques for data preprocessing,
    model architecture design, training, and evaluation. We will consider the unique
    challenges and considerations associated with fraud detection, such as imbalanced
    datasets, feature engineering, and performance evaluation metrics.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 PyTorch 和 Opacus，我们可以为欺诈检测训练具有差分隐私的深度学习模型。这种方法使我们能够从深度学习的表达能力中受益，同时遵守隐私法规并保护敏感信息。在本节中，我们将探讨数据预处理、模型架构设计、训练和评估的技术。我们将考虑与欺诈检测相关的独特挑战和考虑因素，例如不平衡数据集、特征工程和性能评估指标。
- en: By the end of this section, you will have a comprehensive understanding of how
    to develop a fraud detection model using PyTorch and train it with differential
    privacy using frameworks such as Opacus. This knowledge will empower you to build
    robust and privacy-preserving machine learning models for fraud detection and
    similar applications.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将全面了解如何使用 PyTorch 开发欺诈检测模型，并使用 Opacus 等框架通过差分隐私进行训练。这些知识将使你能够构建用于欺诈检测和类似应用的稳健且保护隐私的机器学习模型。
- en: Fraud detection model using PyTorch
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PyTorch 的欺诈检测模型
- en: 'In order to develop a deep learning model using PyTorch, we can follow the
    steps outlined next:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 PyTorch 开发深度学习模型，我们可以遵循以下步骤：
- en: '**Load the transaction data**: Start by loading the transaction data into a
    pandas DataFrame object.'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**加载交易数据**：首先，将交易数据加载到 pandas DataFrame 对象中。'
- en: '**Split the data**: Split the loaded data into training and testing sets.'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分割数据**：将加载的数据分割成训练集和测试集。'
- en: '**Convert the data to PyTorch tensors**: To work with PyTorch, we need to convert
    the data into PyTorch tensors. PyTorch tensors are efficient data structures that
    allow us to perform computations using the GPU for accelerated training. We use
    the **torch.tensor** function to convert the data.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将数据转换为 PyTorch 张量**：为了使用 PyTorch，我们需要将数据转换为 PyTorch 张量。PyTorch 张量是高效的数据结构，允许我们使用
    GPU 进行加速训练。我们使用 **torch.tensor** 函数转换数据。'
- en: '**Create a simple linear model**: Define a deep learning model architecture
    using PyTorch’s **nn.Module** class. For a simple linear model, we use the **nn.Linear**
    module to create a linear layer. To classify transactions as fraud or not, we
    add a sigmoid layer at the end of the model using the **nn.Sigmoid** activation
    function.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个简单的线性模型**：使用 PyTorch 的 **nn.Module** 类定义深度学习模型架构。对于简单的线性模型，我们使用 **nn.Linear**
    模块创建线性层。为了将交易分类为欺诈或非欺诈，我们在模型末尾添加一个 sigmoid 层，使用 **nn.Sigmoid** 激活函数。'
- en: '**Train the model**: Set up the training loop to iterate over the training
    data and update the model’s parameters based on the defined loss function and
    optimization algorithm. Use PyTorch’s **nn.CrossEntropyLoss** as the loss function
    and select an appropriate optimizer such as **torch.optim.SGD** or **torch.optim.Adam**
    for updating the model’s parameters.'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**训练模型**：设置训练循环，遍历训练数据并根据定义的损失函数和优化算法更新模型的参数。使用 PyTorch 的 **nn.CrossEntropyLoss**
    作为损失函数，并选择合适的优化器，如 **torch.optim.SGD** 或 **torch.optim.Adam** 来更新模型的参数。'
- en: '**Monitor the loss**: During training, keep track of the loss at each step.
    The loss represents the discrepancy between the predicted outputs of the model
    and the true labels. By monitoring the loss, you can assess the progress of the
    model’s training and make adjustments if necessary.'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控损失**：在训练过程中，跟踪每一步的损失。损失表示模型预测输出与真实标签之间的差异。通过监控损失，你可以评估模型训练的进度，并在必要时进行调整。'
- en: By following these steps, we develop a deep learning model using PyTorch for
    fraud detection. It’s important to note that this is a simplified overview, and
    you may need to customize the model architecture, incorporate additional layers
    or techniques, and fine-tune hyperparameters based on the specific requirements
    of your fraud detection task.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，我们使用 PyTorch 开发了一个用于欺诈检测的深度学习模型。需要注意的是，这是一个简化的概述，你可能需要根据你的欺诈检测任务的具体要求自定义模型架构、集成额外的层或技术，并微调超参数。
- en: '*Source Code:* *Fraud_Detection_Deep Learning.ipynb*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码：* *Fraud_Detection_Deep Learning.ipynb*'
- en: '**# unzip the fraud_transactions.csv.zip file (provided in the GitHub repo
    of this book** **as fraud_transactions.csv)**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 解压提供的 GitHub 仓库中的 fraud_transactions.csv.zip 文件（作为本书的** **fraud_transactions.csv**
    **）**'
- en: '[https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/fraud_transactions.csv.zip](https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/fraud_transactions.csv.zip)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/fraud_transactions.csv.zip](https://github.com/PacktPublishing/Privacy-Preserving-Machine-Learning/blob/main/Chapter%205/fraud_transactions.csv.zip)'
- en: '[PRE59]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Fraud detection model with differential privacy using the Opacus framework
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Opacus 框架实现的具有差分隐私的欺诈检测模型
- en: '**Opacus**, an open source library, is the PyTorch implementation of the SGD-DP
    algorithm that supports differential privacy. Opacus preserves the privacy of
    each training sample while limiting the impact on the accuracy of the final model.
    In this way, the privacy of outliers is also preserved. Opacus adds noise to the
    gradients in every iteration to prevent the model from simply memorizing the training
    examples. Opacus adds noise at the right scale (too much noise will reduce the
    accuracy, and too little won’t help to protect privacy) by looking at the norm
    of the gradients.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**Opacus**，一个开源库，是支持差分隐私的 SGD-DP 算法的 PyTorch 实现。Opacus 在限制对最终模型准确率影响的同时，保护了每个训练样本的隐私。这样，异常值的隐私也得到了保护。Opacus
    在每次迭代中向梯度添加噪声，以防止模型简单地记住训练示例。Opacus 通过查看梯度的范数来添加适当的噪声尺度（噪声过多会降低准确率，而过少则无法帮助保护隐私）。'
- en: More details about Opacus can be found at [https://opacus.ai/](https://opacus.ai/).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Opacus 的详细信息可以在 [https://opacus.ai/](https://opacus.ai/) 找到。
- en: 'Installing the Opacus library is done with the following code (I used the following
    version in this example: `opacus==1.1.2`):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Opacus 库的代码如下（我在这个例子中使用了以下版本：`opacus==1.1.2`）：
- en: '[PRE60]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We will develop the same deep learning model and train it with differential
    privacy using the Opacus framework with PyTorch.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发相同的深度学习模型，并使用 PyTorch 的 Opacus 框架进行差分隐私训练。
- en: 'Implement the following steps:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 实施以下步骤：
- en: Load the transaction data.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载交易数据。
- en: Split the data into train and test data sets using pandas DataFrames.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas DataFrames 将数据分为训练集和测试集。
- en: Convert the data into PyTorch tensors.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据转换为 PyTorch 张量。
- en: Create a simple linear model and use the sigmoid layer at the end to classify
    transactions as fraud or not.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的线性模型，并在最后使用 sigmoid 层来对交易进行欺诈或非欺诈的分类。
- en: Make the model a private one (i.e., apply differential privacy to the model)
    using the instance of **PrivacyEngine** provided by Opacus to protect the training
    data.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Opacus 提供的 **PrivacyEngine** 实例将模型变为私有（即，将差分隐私应用于模型），以保护训练数据。
- en: Train the model and measure the epsilon (privacy budget).
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练模型并测量 epsilon（隐私预算）。
- en: '*Source :* *Fraud_Detection_DP.ipynb*'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源：* *Fraud_Detection_DP.ipynb*'
- en: '[PRE61]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In each epoch, the training loss fluctuates, but at the same time, privacy loss
    (budget) ε increases.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个纪元中，训练损失波动，但与此同时，隐私损失（预算）ε 增加。
- en: In this way, deep learning models can be trained for differential privacy with
    minimal code changes using Opacus and protect the training data’s privacy.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，使用 Opacus 和 PyTorch，可以以最小的代码更改对深度学习模型进行差分隐私训练，并保护训练数据的隐私。
- en: Differential privacy machine learning frameworks
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 差分隐私机器学习框架
- en: 'The following are some of the popular differential privacy machine learning
    frameworks:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的差分隐私机器学习框架：
- en: '| Framework | Implementation |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 实现 |'
- en: '| --- | --- |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Opacus | PyTorch. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| Opacus | PyTorch. |'
- en: '| Tensor Flow Privacy | TensorFlow. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| Tensor Flow Privacy | TensorFlow。 |'
- en: '| Pyvacy | TensorFlow Privacy, but for PyTorch. |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| Pyvacy | TensorFlow Privacy，但针对 PyTorch。 |'
- en: '| JAX(DP) | JAX is Autograd and XLA, brought together for high-performance
    machine learning research. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| JAX(DP) | JAX 是 Autograd 和 XLA 的结合，用于高性能机器学习研究。 |'
- en: '| Pysyft | `Pysyft` is a Python library for private, secure machine learning
    using federated learning and differential privacy. It allows for secure and private
    training and inference of machine learning models across multiple devices. |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| Pysyft | `Pysyft` 是一个用于使用联邦学习和差分隐私进行私有、安全机器学习的Python库。它允许在多个设备上安全且私有地训练和推理机器学习模型。|'
- en: Table 5.17 – DP ML frameworks
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.17 – DP ML框架
- en: Limitations of differential privacy and strategies to overcome them
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 差分隐私的局限性和克服策略
- en: 'Differential privacy has gained significant attention and adoption in both
    academia and industry due to its ability to balance privacy and utility. However,
    like any other technique, differential privacy has its limitations and challenges
    that need to be addressed to ensure its effective implementation. Following are
    some of the major limitations of differential privacy and potential strategies
    to overcome them:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 由于差分隐私能够在隐私和效用之间取得平衡，它在学术界和工业界都受到了显著的关注和采用。然而，像任何其他技术一样，差分隐私有其局限性和挑战，需要解决以确保其有效实施。以下是差分隐私的一些主要局限性和克服它们的潜在策略：
- en: '**Noise and utility trade-off**: Differential privacy achieves privacy by adding
    noise to query responses, which introduces a trade-off between privacy and utility.
    The amount of noise added determines the level of privacy, but excessive noise
    can significantly reduce the utility of the released data. Striking the right
    balance between privacy and utility is a challenge.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪声与效用权衡**：差分隐私通过向查询响应中添加噪声来实现隐私保护，这引入了隐私与效用之间的权衡。添加的噪声量决定了隐私水平，但过多的噪声会显著降低发布数据的效用。在隐私与效用之间取得平衡是一个挑战。'
- en: '**Strategy to overcome**: One approach to mitigating this limitation is to
    design better algorithms that minimize the impact of noise on utility. Researchers
    are constantly developing advanced mechanisms and techniques to optimize the noise
    injection process, such as adaptive noise calibration, privacy amplification through
    subsampling, or leveraging machine learning to generate more accurate and privacy-preserving
    responses.'
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：缓解这种限制的一种方法是为算法设计更好的算法，以最小化噪声对效用的影响。研究人员正在不断开发先进的机制和技术来优化噪声注入过程，例如自适应噪声校准、通过子采样进行隐私放大或利用机器学习生成更准确且具有隐私保护的响应。'
- en: '**Inference attacks**: Differential privacy focuses on protecting individual
    privacy by limiting the influence of a single record. However, adversaries may
    employ sophisticated inference attacks to glean information by combining multiple
    noisy queries or utilizing external side information. These attacks exploit patterns
    or correlations present in the data to infer sensitive details.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推理攻击**：差分隐私侧重于通过限制单个记录的影响来保护个人隐私。然而，攻击者可能会采用复杂的推理攻击，通过组合多个噪声查询或利用外部辅助信息来获取信息。这些攻击利用数据中存在的模式或相关性来推断敏感细节。'
- en: '**Strategy to overcome**: To overcome inference attacks, additional privacy-preserving
    techniques can be combined with differential privacy. For instance, secure **multi-party
    computation (MPC)** protocols can be used to compute aggregate statistics without
    revealing individual data points, thereby enhancing privacy protection.'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：为了克服推理攻击，可以将额外的隐私保护技术与差分隐私相结合。例如，可以使用安全的**多方计算（MPC）协议**来计算汇总统计信息，而不泄露单个数据点，从而增强隐私保护。'
- en: '**Privacy budget exhaustion**: Differential privacy employs a privacy budget,
    which represents the maximum allowable privacy loss over a sequence of queries.
    Each query consumes a portion of this budget, and once it is depleted, no further
    queries can be made while maintaining differential privacy guarantees. This limitation
    poses a challenge in scenarios where a large number of queries need to be answered.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私预算耗尽**：差分隐私使用隐私预算，它表示在一系列查询中允许的最大隐私损失。每次查询都会消耗一部分预算，一旦预算耗尽，在保持差分隐私保证的情况下，就不能再进行进一步的查询。这种限制在需要回答大量查询的场景中提出了挑战。'
- en: '**Strategy to overcome**: One approach to address privacy budget exhaustion
    is to allocate budgets dynamically based on the sensitivity of the data or the
    specific context of the queries. By adapting the budget allocation strategy, it
    is possible to optimize the utility of the released data and extend the number
    of allowable queries without compromising privacy. Additionally, advanced composition
    techniques, such as Rényi differential privacy, can be employed to manage privacy
    budgets more effectively and allow for finer-grained control.'
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：解决隐私预算耗尽的一种方法是根据数据的敏感性或查询的具体上下文动态分配预算。通过调整预算分配策略，可以优化发布数据的效用，并扩展允许的查询次数，而不会损害隐私。此外，可以采用高级组合技术，如Rényi差分隐私，以更有效地管理隐私预算并允许更细粒度的控制。'
- en: '**External data and auxiliary information**: Differential privacy assumes that
    the released data is the only source of information available to an adversary.
    However, adversaries could potentially leverage external data sources or auxiliary
    information to improve their attacks. These external sources might reveal additional
    details about individuals or contain correlated data, making it challenging to
    maintain privacy guarantees.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部数据和辅助信息**：差分隐私假设发布的数据是攻击者可用的唯一信息来源。然而，攻击者可能利用外部数据源或辅助信息来改进他们的攻击。这些外部来源可能揭示有关个人的额外细节或包含相关数据，这使得保持隐私保证变得具有挑战性。'
- en: '**Strategy to overcome**: To overcome this limitation, it is crucial to carefully
    analyze the potential impact of external data sources and auxiliary information
    on privacy. Adapting data integration techniques, such as secure multiparty computation
    or cryptographic protocols, can help protect against attacks that exploit external
    information. Moreover, proactive measures such as data de-identification and minimizing
    data linkage can further enhance privacy protection against such threats.'
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：为了克服这一限制，仔细分析外部数据源和辅助信息对隐私的潜在影响至关重要。采用数据集成技术，如安全多方计算或加密协议，可以帮助抵御利用外部信息的攻击。此外，采取主动措施，如数据去标识化和最小化数据关联，可以进一步增强对这种威胁的隐私保护。'
- en: '**Limited support for complex data types**: Differential privacy has predominantly
    focused on numerical or categorical data, which limits its applicability to more
    complex data types such as text, images, or graphs. Preserving privacy in these
    domains while maintaining meaningful utility poses a challenge.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对复杂数据类型的支持有限**：差分隐私主要关注数值或分类数据，这限制了其在文本、图像或图等更复杂数据类型上的适用性。在这些领域保持隐私同时保持有意义的效用是一个挑战。'
- en: '**Strategy to overcome**: Researchers are actively exploring techniques to
    extend differential privacy to complex data types. For example, for text data,
    approaches such as differentially private text generation or privacy-preserving
    NLP models are being developed. For images, techniques such as differentially
    private deep learning or generative adversarial networks with privacy guarantees
    are being investigated. These advancements aim to provide privacy guarantees for
    a wider range of data types. LLMs trained with differential privacy also expose
    certain privacy leaks. For more information, we strongly suggest reading the research
    paper at [https://arxiv.org/pdf/2202.05520.pdf](https://arxiv.org/pdf/2202.05520.pdf).'
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：研究人员正在积极探索将差分隐私扩展到复杂数据类型的技术。例如，对于文本数据，正在开发差分隐私文本生成或隐私保护的自然语言处理模型。对于图像，正在研究具有隐私保证的差分隐私深度学习或生成对抗网络。这些进步旨在为更广泛的数据类型提供隐私保证。使用差分隐私训练的LLMs也暴露了某些隐私泄露。有关更多信息，我们强烈建议阅读研究论文[https://arxiv.org/pdf/2202.05520.pdf](https://arxiv.org/pdf/2202.05520.pdf)。'
- en: '**Limited protection against insider attacks**: Differential privacy primarily
    focuses on protecting data against external adversaries. However, it may not be
    as effective in scenarios where insider attacks are a concern. Insiders with access
    to the raw data might intentionally modify the data or use their knowledge to
    breach privacy.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对内部攻击的保护有限**：差分隐私主要关注保护数据免受外部对手的攻击。然而，在内部攻击成为关注点的情况下，它可能并不那么有效。能够访问原始数据的内部人员可能会故意修改数据或利用他们的知识来侵犯隐私。'
- en: '**Strategy to overcome**: Combining differential privacy with additional security
    measures can help mitigate insider attacks. Techniques such as secure enclaves
    or secure hardware can be employed to protect the privacy of sensitive data even
    from those with direct access. Employing access controls, audit logs, and strict
    data governance policies can also deter insider threats and ensure accountability.
    We will learn more about secure enclaves in [*Chapter 9*](B16573_09.xhtml#_idTextAnchor204).'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：将差分隐私与额外的安全措施相结合可以帮助减轻内部攻击。例如，可以使用安全区域或安全硬件来保护敏感数据的隐私，即使是有直接访问权限的人也无法获取。采用访问控制、审计日志和严格的数据治理政策也可以威慑内部威胁并确保问责制。我们将在[第9章](B16573_09.xhtml#_idTextAnchor204)中了解更多关于安全区域的内容。'
- en: '**Difficulty in preserving temporal privacy**: Differential privacy is primarily
    designed for static datasets, and it can be challenging to preserve privacy when
    dealing with temporal data or time-series analysis. Temporal correlations in the
    data can potentially lead to privacy breaches or inference attacks.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护时间隐私的困难**：差分隐私主要设计用于静态数据集，在处理时间数据或时间序列分析时保护隐私可能具有挑战性。数据中的时间相关性可能导致隐私泄露或推理攻击。'
- en: '**Strategy to overcome**: To address temporal privacy concerns, researchers
    are exploring techniques such as personalized differential privacy, where privacy
    parameters are adjusted based on an individual’s data history. Another approach
    involves introducing temporal consistency mechanisms that consider the correlation
    between consecutive queries or time intervals while preserving privacy. These
    techniques aim to protect privacy in dynamic and evolving datasets.'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：为了解决时间隐私问题，研究人员正在探索个性化差分隐私等技术，其中隐私参数根据个人的数据历史进行调整。另一种方法是在保持隐私的同时，引入考虑连续查询或时间间隔之间相关性的时间一致性机制。这些技术旨在保护动态和不断发展的数据集中的隐私。'
- en: '**Limited support for machine learning models**: Differential privacy techniques
    often pose challenges when applied to machine learning models, especially deep
    learning architectures. The perturbation of model parameters or gradients may
    degrade the model’s performance or introduce vulnerabilities.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对机器学习模型的有限支持**：差分隐私技术在应用于机器学习模型时往往面临挑战，尤其是在深度学习架构中。模型参数或梯度的扰动可能会降低模型性能或引入漏洞。'
- en: '**Strategy to overcome**: To overcome this limitation, researchers are developing
    privacy-preserving machine learning techniques tailored to differential privacy.
    Techniques such as federated learning, where models are trained on decentralized
    data without sharing sensitive information, can ensure privacy while maintaining
    utility. Additionally, advancements in privacy-preserving deep learning algorithms,
    such as differentially private stochastic gradient descent, aim to strike a balance
    between model performance and privacy guarantees. We will cover federated learning
    in more depth in the next chapter.'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：为了克服这一限制，研究人员正在开发针对差分隐私的隐私保护机器学习技术。例如，联邦学习技术，在无需共享敏感信息的情况下，在去中心化数据上训练模型，可以确保隐私同时保持效用。此外，隐私保护深度学习算法的进步，如差分隐私随机梯度下降，旨在在模型性能和隐私保证之间取得平衡。我们将在下一章更深入地介绍联邦学习。'
- en: '**Lack of standardization and interoperability**: The absence of standardized
    frameworks and interoperability can hinder the widespread adoption of differential
    privacy. Different implementations and approaches make it challenging to compare
    results or integrate privacy-preserving techniques across different platforms
    or systems.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏标准化和互操作性**：缺乏标准化框架和互操作性可能会阻碍差分隐私的广泛应用。不同的实现和方案使得比较结果或在不同平台或系统间集成隐私保护技术变得具有挑战性。'
- en: '**Strategy to overcome**: Establishing standardized guidelines and frameworks
    can help address the interoperability challenge. Organizations and industry consortia
    can collaborate to develop common APIs, protocols, and evaluation metrics for
    differential privacy. Efforts in open source libraries and tools, along with community-driven
    initiatives, can facilitate knowledge sharing and enable seamless integration
    of differential privacy techniques into existing systems and workflows.'
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克服策略**：建立标准化的指南和框架可以帮助解决互操作性挑战。组织和企业联盟可以合作开发差分隐私的通用API、协议和评估指标。开源库和工具的努力，以及社区驱动的倡议，可以促进知识共享，并使差分隐私技术能够无缝集成到现有系统和工作流程中。'
- en: Overall, while differential algorithms have many advantages, they are not a
    one-size-fits-all solution, and careful consideration must be taken when using
    them in practical applications.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，虽然微分算法有很多优点，但它们并不是万能的解决方案，在实际应用中使用它们时必须仔细考虑。
- en: Summary
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In summary, in this chapter, we went through open source frameworks including
    PyDP, PipelineDP, Tumult Analytics, and PySpark in order to implement differential
    privacy. We implemented fraud detection machine learning models with and without
    differential privacy by developing a private stochastic gradient descent algorithm.
    We also implemented deep learning models and trained the models with differential
    privacy using the Opacus framework, which is based on PyTorch. Finally, we covered
    the limitations of differential privacy and strategies to overcome these limitations.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们探讨了包括PyDP、PipelineDP、Tumult Analytics和PySpark在内的开源框架，以实现差分隐私。我们通过开发一个私有的随机梯度下降算法，实现了带有和没有差分隐私的欺诈检测机器学习模型。我们还实现了深度学习模型，并使用基于PyTorch的Opacus框架，通过差分隐私训练了这些模型。最后，我们讨论了差分隐私的局限性以及克服这些局限性的策略。
- en: In the next chapter, we’ll learn about the need for federated learning as we
    deep dive into it, covering the algorithms used and the frameworks that support
    federated learning, and explore an end-to-end implementation of a fraud detection
    use case using federated learning.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解联邦学习的必要性，包括使用的算法和支撑联邦学习的框架，并探讨使用联邦学习实现欺诈检测用例的端到端实现。
