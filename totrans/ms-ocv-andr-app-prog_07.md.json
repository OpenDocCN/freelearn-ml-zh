["```py\n    <org.opencv.android.JavaCameraView\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"fill_parent\"\n            android:visibility=\"gone\"\n            android:id=\"@+id/java_surface_view\"\n            opencv:camera_id=\"any\" />\n    ```", "```py\nMat temp = inputFrame.rgba();\n\nCore.rectangle(temp, new Point(temp.cols()/2 - 200, temp.rows() / 2 - 200), new Point(temp.cols() / 2 + 200, temp.rows() / 2 + 200), new Scalar(255,255,255),1);\n```", "```py\nFile external_storage = Environment.getExternalStorageDirectory();\n```", "```py\nFile mnist_images_file = new File(external_storage, images_path);\n\nFileInputStream images_reader = new FileInputStream(mnist_images_file);\n```", "```py\n[offset] [type]          [value]          [description] \n0000     32 bit integer  0x00000803(2051) magic number \n0004     32 bit integer  60000            number of images \n0008     32 bit integer  28               number of rows \n0012     32 bit integer  28               number of columns \n0016     unsigned byte  ??                pixel \n0017     unsigned byte   ??               pixel \n........ \nxxxx     unsigned byte   ??               pixel\n```", "```py\nMat training_images = null;\n\ntry{\n            //Read the file headers which contain the total number of images and dimensions. First 16 bytes hold the header\n            /*\n            byte 0 -3 : Magic Number (Not to be used)\n            byte 4 - 7: Total number of images in the dataset\n            byte 8 - 11: width of each image in the dataset\n            byte 12 - 15: height of each image in the dataset\n            */\n\n            byte [] header = new byte[16];\n            images_reader.read(header, 0, 16);\n\n            //Combining the bytes to form an integer\n            ByteBuffer temp = ByteBuffer.wrap(header, 4, 12);\n            total_images = temp.getInt();\n            width = temp.getInt();\n            height = temp.getInt();\n\n            //Total number of pixels in each image\n            int px_count = width * height;\n            training_images = new Mat(total_images, px_count, CvType.CV_8U);\n\n            //images_data = new byte[total_images][px_count];\n            //Read each image and store it in an array.\n\n            for (int i = 0 ; i < total_images ; i++)\n            {\n                byte[] image = new byte[px_count];\n                images_reader.read(image, 0, px_count);\n                training_images.put(i,0,image);\n            }\n            training_images.convertTo(training_images, CvType.CV_32FC1);\n            images_reader.close();\n        }\n        catch (IOException e)\n        {\n            Log.i(\"MNIST Read Error:\", \"\" + e.getMessage());\n        }\n```", "```py\nbyte[] image = new byte[px_count];\nimages_reader.read(image, 0, px_count);\n```", "```py\ntraining_images.put(i,0,image);\n```", "```py\n[offset] [type]         [value]          [description] \n0000     32 bit integer  0x00000801(2049) magic \n  number (MSB first)\n0004     32 bit integer  60000            number of items \n0008     unsigned byte   ??               label \n0009     unsigned byte   ??               label \n........ \nxxxx     unsigned byte   ??               label\n```", "```py\n//Read Labels\n        Mat training_labels = null;\n\n        labels_data = new byte[total_images];\n        File mnist_labels_file = new File(external_storage, labels_path);\n        FileInputStream labels_reader = new FileInputStream(mnist_labels_file);\n\n        try{\n\n            training_labels = new Mat(total_images, 1, CvType.CV_8U);\n            Mat temp_labels = new Mat(1, total_images, CvType.CV_8U);\n            byte[] header = new byte[8];\n            //Read the header\n            labels_reader.read(header, 0, 8);\n            //Read all the labels at once\n            labels_reader.read(labels_data,0,total_images);\n            temp_labels.put(0,0, labels_data);\n\n            //Take a transpose of the image\n            Core.transpose(temp_labels, training_labels);\n            training_labels.convertTo(training_labels, CvType.CV_32FC1);\n            labels_reader.close();\n        }\n        catch (IOException e)\n        {\n            Log.i(\"MNIST Read Error:\", \"\" + e.getMessage());\n        }\n```", "```py\nknn = new CvKNearest();\nknn.train(training_images, training_labels, new Mat(), false, 10, false);\n```", "```py\nvoid FindMatch(Mat test_image)\n    {\n\n        //Dilate the image\n        Imgproc.dilate(test_image, test_image, Imgproc.getStructuringElement(Imgproc.CV_SHAPE_CROSS, new Size(3,3)));\n        //Resize the image to match it with the sample image size\n        Imgproc.resize(test_image, test_image, new Size(width, height));\n        //Convert the image to grayscale\n        Imgproc.cvtColor(test_image, test_image, Imgproc.COLOR_RGB2GRAY);\n        //Adaptive Threshold\n        Imgproc.adaptiveThreshold(test_image,test_image,255,Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY_INV,15, 2);\n\n        Mat test = new Mat(1, test_image.rows() * test_image.cols(), CvType.CV_32FC1);\n        int count = 0;\n        for(int i = 0 ; i < test_image.rows(); i++)\n        {\n            for(int j = 0 ; j < test_image.cols(); j++) {\n                test.put(0, count, test_image.get(i, j)[0]);\n                count++;\n            }\n        }\n\n        Mat results = new Mat(1, 1, CvType.CV_8U);\n\n        knn.find_nearest(test, 10, results, new Mat(), new Mat());\n        Log.i(\"Result:\", \"\" + results.get(0,0)[0]);\n\n    }\n```", "```py\nMat test = new Mat(1, test_image.rows() * test_image.cols(), CvType.CV_32FC1);\nint count = 0;\nfor(int i = 0 ; i < test_image.rows(); i++)\n{\n    for(int j = 0 ; j < test_image.cols(); j++) {\n        test.put(0, count, test_image.get(i, j)[0]);\n        count++;\n    }\n}\n```", "```py\nknn.find_nearest(test, 10, results, new Mat(), new Mat());\n```", "```py\npublic Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n\n        //Get image size and draw a rectangle on the image for reference\n        Mat temp = inputFrame.rgba();\n        Core.rectangle(temp, new Point(temp.cols()/2 - 200, temp.rows() / 2 - 200), new Point(temp.cols() / 2 + 200, temp.rows() / 2 + 200), new Scalar(255,255,255),1);\n        Mat digit = temp.submat(temp.rows()/2 - 180, temp.rows() / 2 + 180, temp.cols() / 2 - 180, temp.cols() / 2 + 180).clone();\n        Core.transpose(digit,digit);\n        mnist.FindMatch(digit);\n\n        return temp;\n    }\n```", "```py\nCore.transpose(digit,digit);\n```", "```py\nknn = new CvKNearest();\nknn.train(training_images, training_labels, new Mat(), false, 10, false);\n```", "```py\nsvm = new CvSVM();\nsvm.train(training_images, training_labels);\n```", "```py\nknn.find_nearest(test, 10, results, new Mat(), new Mat());\n```", "```py\nsvm.predict(test);\n```"]