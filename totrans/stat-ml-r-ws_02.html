<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer017">&#13;
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>&#13;
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Getting Started with R</h1>&#13;
			<p>In this chapter, we will cover the basics of R, the most widely used open source language for statistical analysis and modeling. We will start with an introduction to RStudio, how to perform simple calculations, the common data structures and control logic, and how to write functions <span class="No-Break">in R.</span></p>&#13;
			<p>By the end of the chapter, you will be able to do basic computations in R using common data structures such as vectors, lists and data frames in the RStudio <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>). You will also be able to wrap these calculations in functions using <span class="No-Break">different methods.</span></p>&#13;
			<p>In this chapter, we will cover <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><span class="No-Break">Introducing R</span></li>&#13;
				<li>Covering the R and <span class="No-Break">RStudio basics</span></li>&#13;
				<li>Common data structures <span class="No-Break">in R</span></li>&#13;
				<li>Control logic <span class="No-Break">in R</span></li>&#13;
				<li>Exploring functions <span class="No-Break">in R</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>&#13;
			<p>To complete the exercises in this chapter, you will need to have <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>The latest version of R, which is 4.1.2 at the time <span class="No-Break">of writing</span></li>&#13;
				<li>The latest version of RStudio Desktop, which <span class="No-Break">is 2021.09.2+382</span></li>&#13;
			</ul>&#13;
			<p>All the code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_1/Chapter_1.R"><span class="No-Break">https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_1/Chapter_1.R</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Introducing R</h1>&#13;
			<p>R is a <a id="_idIndexMarker000"/>popular open source language that supports statistical analysis and modeling, and it is most widely used by statisticians developing statistical models and performing data analysis. One question commonly asked by learners is how to choose between Python and R. For those new to both and needing a simple model for a not-so-big dataset, R would be a better choice. It has rich resources to support modeling and plotting tasks that were developed by statisticians long before Python was born. Besides its many off-the-shelf graphing and statistical modeling offerings, the R community is also catching up in advanced machine learning such as deep learning, which the Python community <span class="No-Break">currently dominates.</span></p>&#13;
			<p>There are many differences between the two languages, and recent years have witnessed increasing convergence in many aspects. This book aims to equip you with the essential knowledge to understand and use statistics and calculus via R. We hope that at some point, you will be able to extract from the inner workings of the language itself and think at the methodological level when performing some analysis. After cultivating the essential skills from the fundamentals, it will just be a matter of personal preference regarding the specific language in use. To this end, R provides dedicated utility functions to automatically “convert” Python code to be used within the R context, which gives us another reason not to worry about choosing a <span class="No-Break">specific language.</span></p>&#13;
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Covering the R and RStudio basics</h1>&#13;
			<p>It is easy to confuse R with <strong class="bold">RStudio</strong> if you <a id="_idIndexMarker001"/>are a first-time user. In a nutshell, R is the engine that supports all sorts of backend computations, and RStudio is a convenient tool for navigating and managing related coding and reference resources. Specifically, RStudio is an <strong class="bold">IDE</strong> where the user writes R code, performs analysis, and develops models without worrying much about the backend logistics required by the R engine. The interface provided by RStudio makes the development work much more convenient and user-friendly than the vanilla <span class="No-Break">R interface.</span></p>&#13;
			<p>First, we need to install R on our computer, as the RStudio will ship with the computation horsepower upon installation. We can choose the corresponding version of R at <a href="https://cloud.r-project.org/">https://cloud.r-project.org/</a>, depending <a id="_idIndexMarker002"/>on the specific type of operating system we use. RStudio can then be downloaded at <a href="https://www.rstudio.com/products/rstudio/download/">https://www.rstudio.com/products/rstudio/download/</a> and installed accordingly. When launching the<a id="_idIndexMarker003"/> RStudio application after installing both software, the R engine will be automatically detected and used. Let’s go through an exercise to get familiar with <span class="No-Break">the interface.</span></p>&#13;
			<h3>Exercise 1.01 – exploring RStudio</h3>&#13;
			<p>RStudio <a id="_idIndexMarker004"/>provides a comprehensive environment for working with R scripts and exploring the data simultaneously. In this exercise, we will look at a basic example of how to write a simple script to store a string and perform a simple calculation <span class="No-Break">using RStudio.</span></p>&#13;
			<p>Perform the following steps to complete <span class="No-Break">this exercise:</span></p>&#13;
			<ol>&#13;
				<li>Launch the RStudio application and observe the <span class="No-Break">three panes:</span><ul><li>The <strong class="bold">Console</strong> pane is used to execute R commands and display the <span class="No-Break">immediate result.</span></li><li>The <strong class="bold">Environment</strong> pane stores all the global variables in the <span class="No-Break">current </span><span class="No-Break"><strong class="bold">session</strong></span><span class="No-Break">.</span></li><li>The <strong class="bold">Files</strong> pane lists all the files within the current working directory along with other tabs, as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span><p class="list-inset">Note that the R version is printed as a message in the console (highlighted in the <span class="No-Break">dashed box):</span></p></li></ul></li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer008" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_001.jpg" alt="Figure 1.1 – A screenshot of the RStudio upon the first launch" width="1538" height="928"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – A screenshot of the RStudio upon the first launch</p>&#13;
			<p class="list-inset">We can<a id="_idIndexMarker005"/> also type <strong class="source-inline">R.version</strong> in the console to retrieve more detailed information on the version of the R engine in use, as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em>. It is essential to check the R version, as different versions <em class="italic">may</em> produce different results when running the <span class="No-Break">same code.</span></p>&#13;
			<div>&#13;
				<div id="_idContainer009" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_002.jpg" alt="Figure 1.2 – Typing a command in the console to check the R version" width="492" height="418"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Typing a command in the console to check the R version</p>&#13;
			<ol>&#13;
				<li value="2">Build a <a id="_idIndexMarker006"/>new <strong class="bold">R script</strong> by clicking <a id="_idIndexMarker007"/>on the plus sign in the upper-left corner or via <strong class="bold">File</strong> | <strong class="bold">New File</strong> | <strong class="bold">R Script</strong>. An R script allows us to write longer R code that involves functions and chunks of code executed in sequence. We will build an R script and name it <strong class="source-inline">test.R</strong> upon saving the file. See the following figure for <span class="No-Break">an illustration:</span></li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer010" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_003..jpg" alt="Figure 1.3 – Creating a new R script" width="1410" height="871"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Creating a new R script</p>&#13;
			<ol>&#13;
				<li value="3">Running the <a id="_idIndexMarker008"/>script can be achieved by placing the cursor at the current line and pressing <em class="italic">Cmd</em> + <em class="italic">Enter</em> for macOS or <em class="italic">Ctrl</em> + <em class="italic">Enter</em> for Windows; alternatively, click on the <strong class="bold">Run</strong> button at the top of the R script pane, as shown in the <span class="No-Break">following figure:</span></li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer011" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_004..jpg" alt="Figure 1.4 – Executing the script by clicking on the Run button" width="1641" height="331"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Executing the script by clicking on the Run button</p>&#13;
			<ol>&#13;
				<li value="4">Type the following commands in the script editing pane and observe the output in the console as well as the changes in the other panes. First, we create a <strong class="bold">variable</strong> named <strong class="source-inline">test</strong> by assigning <strong class="source-inline">"I am a string"</strong>. A variable can be used to store an object, which could take the form of a string, number, data frame, or even function (more on this later). Strings consist of characters, a common data type in R. The <strong class="source-inline">test</strong> variable created in the script is also reflected in the <strong class="bold">Environment</strong> pane, which is a convenient check as we can also observe the content in the variable. See <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.5</em> for <span class="No-Break">an illustration:</span><pre class="source-code">&#13;
# String assignment&#13;
test = "I am a string"&#13;
print(test)</pre></li>			</ol>&#13;
			<div>&#13;
				<div id="_idContainer012" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_005..jpg" alt="Figure 1.5 – Creating a string-type variable" width="1315" height="257"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Creating a string-type variable</p>&#13;
			<p class="list-inset">We also<a id="_idIndexMarker009"/> assign a simple addition operation to <strong class="source-inline">test2</strong> and print it out in the console. These commands are also annotated via the <strong class="source-inline">#</strong> sign, where the contents after the sign are not executed and are only used to provide an explanation of the following code. See <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.6</em> for <span class="No-Break">an illustration:</span></p>&#13;
			<pre class="source-code">&#13;
# Simple calculation&#13;
test2 = 1 + 2&#13;
print(test2)</pre>			<div>&#13;
				<div id="_idContainer013" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_006..jpg" alt="Figure 1.6 – Assigning a string and performing basic computation" width="1130" height="674"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Assigning a string and performing basic computation</p>&#13;
			<ol>&#13;
				<li value="5">We <a id="_idIndexMarker010"/>can also check the contents of the environment workspace via the <span class="No-Break"><strong class="source-inline">ls()</strong></span><span class="No-Break"> function:</span><pre class="source-code">&#13;
&gt;&gt;&gt; ls()&#13;
"test"  "test2"</pre></li>			</ol>&#13;
			<p>In addition, note that the newly created R script is also reflected in the <strong class="bold">Files</strong> pane. RStudio is an excellent one-stop IDE for working with R and will be the programming interface for this book. We will introduce more features of RStudio in a more specific context along <span class="No-Break">the way.</span></p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">The canonical way of assigning some value to a variable is via the <strong class="source-inline">&lt;-</strong> operator instead of the <strong class="source-inline">=</strong> sign as in the example. However, the author chose to use the <strong class="source-inline">=</strong> sign as it is faster to type on the screen and has an equivalent effect as the <strong class="source-inline">&lt;-</strong> sign in the majority <span class="No-Break">of cases.</span></p>&#13;
			<p class="callout">In addition, note that the output message in the <strong class="bold">Console</strong> pane has a preceding <strong class="source-inline">[1]</strong> sign, which indicates that the result is a one-dimensional output. We will ignore this sign in the output message unless <span class="No-Break">otherwise specified.</span></p>&#13;
			<p>The exercise in <a id="_idIndexMarker011"/>the previous section provides an additional example, which is an essential operation in R. As with other modern programming languages, R also ships with many standard arithmetic operators, including subtraction <strong class="source-inline">(-)</strong>, multiplication <strong class="source-inline">(*)</strong>, division <strong class="source-inline">(/)</strong>, exponentiation <strong class="source-inline">(^)</strong>, and modulo <strong class="source-inline">(%%)</strong> operators. The modulo operator returns the remainder of the numerator in the <span class="No-Break">division operation.</span></p>&#13;
			<p>Let’s look at an exercise to go through some common <span class="No-Break">arithmetic operations.</span></p>&#13;
			<h3>Exercise 1.02 – common arithmetic operations in R</h3>&#13;
			<p>This <a id="_idIndexMarker012"/>exercise will perform different arithmetic operations (addition, subtraction, multiplication, division, exponentiation, and modulo) between two numbers: 5 <span class="No-Break">and 2.</span></p>&#13;
			<p>Type the <a id="_idIndexMarker013"/>commands under the <strong class="bold">EXERCISE 1.02</strong> comment section in the <strong class="bold">R Script</strong> pane and observe the output message in the console shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.7</em>. Note that we removed the <strong class="source-inline">print()</strong> function, as directly executing the command will also print out the result as highlighted in <span class="No-Break">the console:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer014" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_007..jpg" alt="Figure 1.7 – Performing common arithmetic operations in R" width="816" height="936"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Performing common arithmetic operations in R</p>&#13;
			<p>Note that these elementary arithmetic operations can jointly form complex operations. When evaluating <a id="_idIndexMarker014"/>a complex operation that consists of multiple operators, the general rule of thumb<a id="_idIndexMarker015"/> is to use parentheses to enforce the execution of a specific component according to the desired sequence. This follows in most numeric analyses using any <span class="No-Break">programming language.</span></p>&#13;
			<p>But, what forms can we expect the data to take <span class="No-Break">in R?</span></p>&#13;
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Common data types in R</h2>&#13;
			<p>There <a id="_idIndexMarker016"/>are five most basic data types in R: <strong class="bold">numeric</strong>, <strong class="bold">integer</strong>, <strong class="bold">character</strong>, <strong class="bold">logical</strong>, and <strong class="bold">factor</strong>. Any complex R object can be decomposed into individual elements that fall into one of these five data types and, therefore, contain one or more data types. The definition of these five data types is <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Numeric</strong> is the<a id="_idIndexMarker017"/> default data type in R and represents a <a id="_idIndexMarker018"/>decimal value, such as <strong class="source-inline">1.23</strong>. A variable is treated as a numeric even if we assign an integer value to it in the <span class="No-Break">first place.</span></li>&#13;
				<li><strong class="bold">Integer</strong> is a <a id="_idIndexMarker019"/>whole number and so a subset of the <a id="_idIndexMarker020"/>numeric <span class="No-Break">data type.</span></li>&#13;
				<li><strong class="bold">Character</strong> is<a id="_idIndexMarker021"/> the data type used to store a sequence <a id="_idIndexMarker022"/>of characters (including letters, symbols, or even numbers) to form a string or a piece of text, surrounded by double or <span class="No-Break">single quotes.</span></li>&#13;
				<li><strong class="bold">Logical</strong> is <a id="_idIndexMarker023"/>a Boolean data type that only takes one of<a id="_idIndexMarker024"/> two values: <strong class="source-inline">TRUE</strong> or <strong class="source-inline">FALSE</strong>. It is often used in a conditional statement to determine whether specific codes after the condition should <span class="No-Break">be executed.</span></li>&#13;
				<li><strong class="bold">Factor</strong> is a <a id="_idIndexMarker025"/>special <a id="_idIndexMarker026"/>data type used to store categorical variables that contain a limited number of categories (or <strong class="bold">levels</strong>), ordered or unordered. For example, a list of student heights classified as low, medium, and high can be represented as a factor type to encode the inherent ordering, which would not be available when represented as a character type. On the other hand, unordered lists such as male and female can also be represented as <span class="No-Break">factor types.</span></li>&#13;
			</ul>&#13;
			<p>Let’s go through an example to understand these different <span class="No-Break">data types.</span></p>&#13;
			<h3>Exercise 1.03 – understanding data types in R</h3>&#13;
			<p>R has strict rules on<a id="_idIndexMarker027"/> the data types when performing arithmetic operations. In general, the data types of all variables should be the same when evaluating a particular <strong class="bold">statement</strong> (a piece of code). Performing an arithmetic operation on different data types may give an error. In this exercise, we will look at how to check the data type to ensure the type consistency and different ways to convert the data type from<a id="_idIndexMarker028"/> one <span class="No-Break">into another:</span></p>&#13;
			<ol>&#13;
				<li>We start by creating five variables, each belonging to a different data type. Check the data type using the <strong class="source-inline">class()</strong> function. Note that we can use the semicolon to separate <span class="No-Break">different actions:</span><pre class="source-code">&#13;
&gt;&gt;&gt; a = 1.0; b = 1; c = "test"; d = TRUE; e = factor("test")&#13;
&gt;&gt;&gt; class(a); class(b); class(c); class(d); class(e)&#13;
"numeric"&#13;
"numeric"&#13;
"character"&#13;
"logical"&#13;
"factor"</pre><p class="list-inset">As expected, the data type of the <strong class="source-inline">b</strong> variable is converted into numeric even when it is assigned an integer in the <span class="No-Break">first place.</span></p></li>				<li>Perform addition on the variables. Let’s start with the <strong class="source-inline">a</strong> and <span class="No-Break"><strong class="source-inline">b</strong></span><span class="No-Break"> variables:</span><pre class="source-code">&#13;
&gt;&gt;&gt; a + b&#13;
2&#13;
&gt;&gt;&gt; class(a + b)&#13;
"numeric"</pre><p class="list-inset">Note that the decimal point is ignored when displaying the result of the addition, which is still numeric as verified via the <span class="No-Break"><strong class="source-inline">class()</strong></span><span class="No-Break"> function.</span></p><p class="list-inset">Now, let’s look at the addition between <strong class="source-inline">a</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">c</strong></span><span class="No-Break">:</span></p><pre class="source-code">&gt;&gt;&gt; a + c&#13;
Error in a + c : non-numeric argument to binary operator</pre><p class="list-inset">This time, we<a id="_idIndexMarker029"/> received an <em class="italic">error</em> message due to a mismatch in data types when evaluating an addition operation. This is because the <strong class="source-inline">+</strong> addition operator in R is a binary operator designed to take in two values (operands) and produce another, all of which need to be numeric (including integer, of course). The error pops up when any of the two input <em class="italic">arguments</em> <span class="No-Break">are non-numeric.</span></p></li>				<li>Let’s <a id="_idIndexMarker030"/>trying adding <strong class="source-inline">a</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">d</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; a + d&#13;
2&#13;
&gt;&gt;&gt; class(a + d)&#13;
"numeric"</pre><p class="list-inset">Surprisingly, the result is the same as <strong class="source-inline">a + b</strong>, suggesting that the Boolean <strong class="source-inline">b</strong> variable taking a <strong class="source-inline">TRUE</strong> value is converted into a value of one under the hood. Correspondingly, a Boolean value of <strong class="source-inline">FALSE</strong>, obtained by adding an exclamation mark before the variable, would be treated as zero when performing an arithmetic operation with <span class="No-Break">a numeric:</span></p><pre class="source-code">&gt;&gt;&gt; a + !d&#13;
1</pre><p class="list-inset">Note that the implicit Boolean conversion occurs in settings when such conversion is necessary to proceed in a specific statement. For example, <strong class="source-inline">d</strong> is converted into a numeric value of one when evaluating whether <strong class="source-inline">a</strong> <span class="No-Break">equals </span><span class="No-Break"><strong class="source-inline">d</strong></span><span class="No-Break">:</span></p><pre class="source-code">&gt;&gt;&gt; a == d&#13;
TRUE</pre></li>				<li>Convert the data types using the <strong class="source-inline">as.(datatype)</strong> family of functions <span class="No-Break">in R.</span><p class="list-inset">For example, the <strong class="source-inline">as.numeric()</strong> function converts the input parameter into a numeric, <strong class="source-inline">as.integer()</strong> returns the integer part of the input decimal, <strong class="source-inline">as.character()</strong> converts all inputs (including numeric and Boolean) into strings, and <strong class="source-inline">as.logical()</strong> converts any non-zero numeric into <strong class="source-inline">TRUE</strong> and zero into <strong class="source-inline">FALSE</strong>. Let’s look at a <span class="No-Break">few examples:</span></p><pre class="source-code">&#13;
&gt;&gt;&gt; class(as.numeric(b))&#13;
"numeric"</pre><p class="list-inset">This<a id="_idIndexMarker031"/> suggests that the <strong class="source-inline">b</strong> variable is successfully converted into numeric. Note<a id="_idIndexMarker032"/> that type conversion is a standard data processing operation in R, and type incompatibility is a popular source of error that may be difficult <span class="No-Break">to trace:</span></p><pre class="source-code">&gt;&gt;&gt; as.integer(1.8)&#13;
1&#13;
&gt;&gt;&gt; round(1.8)&#13;
2</pre><p class="list-inset">Since <strong class="source-inline">as.integer()</strong> only returns the integer part of the input, the result is always “floored” to the lower bound integer. We could use the <strong class="source-inline">round()</strong> function to round it up or down, depending on the value of the first digit after the <span class="No-Break">decimal point:</span></p><pre class="source-code">&gt;&gt;&gt; as.character(a)&#13;
"1"&#13;
&gt;&gt;&gt; as.character(d)&#13;
"TRUE"</pre><p class="list-inset">The <strong class="source-inline">as.character()</strong> function converts all input parameters into strings as represented by the double quotes, including numeric and Boolean. The converted value no longer maintains the original arithmetic property. For example, a numeric<a id="_idIndexMarker033"/> converted into a character would not go through the addition operation. Also, a Boolean converted into a character would no longer be evaluated via a logical statement and treated as <span class="No-Break">a character:</span></p><pre class="source-code">&gt;&gt;&gt; as.factor(a)&#13;
1&#13;
Levels: 1&#13;
&gt;&gt;&gt; as.factor(c)&#13;
test&#13;
Levels: test</pre><p class="list-inset">Since there<a id="_idIndexMarker034"/> is only one element in the input parameter, the resulting number of levels is only <strong class="source-inline">1</strong>, meaning the original <span class="No-Break">input itself.</span></p></li>			</ol>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">A <a id="_idIndexMarker035"/>categorical variable is<a id="_idIndexMarker036"/> called a <strong class="bold">nominal</strong> variable when there is no natural ordering<a id="_idIndexMarker037"/> among the categories, and an <strong class="bold">ordinal</strong> variable if there is natural ordering. For example, the temperature variable valued as either <strong class="source-inline">high</strong>, <strong class="source-inline">medium</strong>, or <strong class="source-inline">low</strong> has an inherent ordering in nature, while a gender variable valued as either <strong class="source-inline">male</strong> or <strong class="source-inline">female</strong> has <span class="No-Break">no order.</span></p>&#13;
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Common data structures in R</h1>&#13;
			<p>Data structures<a id="_idIndexMarker038"/> provide an organized way to store various data points that follow either the same or different types. This section will look at the typical data structures used in R, including the vector, matrix, data frame, <span class="No-Break">and list.</span></p>&#13;
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Vector</h2>&#13;
			<p>A <strong class="bold">vector</strong> is<a id="_idIndexMarker039"/> a <a id="_idIndexMarker040"/>one-dimensional array that can hold a series of elements of any consistent data type, including numeric, integer, character, logical, or factor. We can create a vector by filling in comma-separated elements in the input argument of the combine function, <strong class="source-inline">c()</strong>. The arithmetic operations between two vectors are similar to the single-element example earlier, provided that their lengths are equal. There needs to be a one-to-one correspondence between the elements of the two vectors; if not, the calculation <em class="italic">may</em> give an error. Let’s look at <span class="No-Break">an exercise.</span></p>&#13;
			<h3>Exercise 1.04 – working with vectors</h3>&#13;
			<p>We will create<a id="_idIndexMarker041"/> two vectors of the same length in this exercise and add them up. As an extension, we will also attempt the same addition using a vector of a different length. We will also perform a pairwise comparison between the <span class="No-Break">two vectors:</span></p>&#13;
			<ol>&#13;
				<li>Create two vectors named <strong class="source-inline">vec_a</strong> and <strong class="source-inline">vec_b</strong> and extract simple summary statistics such as <strong class="source-inline">mean</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">sum</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a = c(1,2,3)&#13;
&gt;&gt;&gt; vec_b = c(1,1,1)&#13;
&gt;&gt;&gt; sum(vec_a)&#13;
6&#13;
&gt;&gt;&gt; mean(vec_a)&#13;
2</pre><p class="list-inset">The sum and mean of a vector can be generated using the <strong class="source-inline">sum()</strong> and <strong class="source-inline">mean()</strong> function, respectively. We will cover more ways to summarize a <span class="No-Break">vector later.</span></p></li>				<li>Add up <strong class="source-inline">vec_a</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">vec_b</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a + vec_b&#13;
2 3 4</pre><p class="list-inset">The <a id="_idIndexMarker042"/>addition between two vectors is performed element-wise. The result can also be saved into another variable for further processing. How about adding a single element to <span class="No-Break">a vector?</span></p></li>				<li>Add <strong class="source-inline">vec_a</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a + 1&#13;
2 3 4</pre><p class="list-inset">Under the hood, element one is broadcasted into vector <strong class="source-inline">c(1,1,1)</strong>, whose length is decided by <strong class="source-inline">vec_a</strong>. <strong class="bold">Broadcasting</strong> is a <a id="_idIndexMarker043"/>unique mechanism that replicates the elements of the short vector into the required length, as long as the length of the longer vector is a multiple of the short vector’s length. The same trick may not apply when it is not <span class="No-Break">a multiple.</span></p></li>				<li>Add <strong class="source-inline">vec_a</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">c(1,1)</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a + c(1,1)&#13;
2 3 4&#13;
Warning message:&#13;
In vec_a + c(1, 1) :&#13;
longer object length is not a multiple of shorter object length</pre><p class="list-inset">We still get the same result, except for a warning message saying that the longer vector’s length of three is not a multiple of the shorter vector length of two. Pay attention to this warning message. It is not recommended to follow such practice as the warning may become an explicit error or become the implicit cause of an underlying bug in an <span class="No-Break">extensive program.</span></p></li>				<li>Next, we will perform a pairwise comparison between the <span class="No-Break">two vectors:</span><pre class="source-code">&#13;
vec_a &gt; vec_b&#13;
FALSE  TRUE  TRUE&#13;
vec_a == vec_b&#13;
TRUE FALSE FALSE</pre><p class="list-inset">Here, we <a id="_idIndexMarker044"/>have used evaluation operators such as <strong class="source-inline">&gt;</strong> (greater than) and <strong class="source-inline">==</strong> (equal to), returning logical results (<strong class="source-inline">TRUE</strong> or <strong class="source-inline">FALSE</strong>) for <span class="No-Break">each pair.</span></p><p class="list-inset">Note, there are multiple logical comparison operators in R. The common ones include <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">&lt;</strong> for <span class="No-Break">less than</span></li><li><strong class="source-inline">&lt;=</strong> for less than or <span class="No-Break">equal to</span></li><li><strong class="source-inline">&gt;</strong> for <span class="No-Break">greater than</span></li><li><strong class="source-inline">&gt;=</strong> for greater than or <span class="No-Break">equal to</span></li><li><strong class="source-inline">==</strong> for <span class="No-Break">equal to</span></li><li><strong class="source-inline">!=</strong> for not <span class="No-Break">equal to</span></li></ul></li>			</ol>&#13;
			<p>Besides the common arithmetic operations, we may also be interested in selected partial components of a vector. We can use square brackets to select specific elements of a vector, which is the same way to select elements in other data structures such as in a matrix or a data frame. In between the square brackets are indices indicating what elements to select. For example, we can use <strong class="source-inline">vec_a[1]</strong> to select the first element of <strong class="source-inline">vec_a</strong>. Let’s go through an exercise to look at different ways to subset <span class="No-Break">a vector.</span></p>&#13;
			<h3>Exercise 1.05 – subsetting a vector</h3>&#13;
			<p>We<a id="_idIndexMarker045"/> can pass in the select index (starting from <strong class="source-inline">1</strong>) to select the corresponding element in the vector. We can wrap the indices via the <strong class="source-inline">c()</strong> combine function and pass in the square brackets to select multiple elements. Selecting multiple sequential indices can also be achieved via a shorthand notation by writing the first and last index with a colon in between. Let’s run through different ways of subsetting <span class="No-Break">a vector:</span></p>&#13;
			<ol>&#13;
				<li>Select the first element <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">vec_a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a[1]&#13;
1</pre></li>				<li>Select the first and third elements <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">vec_a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a[c(1,3)]&#13;
1 3</pre></li>				<li>Select all three elements <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">vec_a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a[c(1,2,3)]&#13;
1 2 3</pre><p class="list-inset">Selecting <a id="_idIndexMarker046"/>multiple elements in this way is not very convenient since we need to type every index. When the indices are sequential, a nice shorthand trick is to use the starting and end index separated by a colon. For example, <strong class="source-inline">1:3</strong> would be the same <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">c(1,2,3)</strong></span><span class="No-Break">:</span></p><pre class="source-code">&gt;&gt;&gt; vec_a[1:3]&#13;
1 2 3</pre><p class="list-inset">We can also perform more complex subsetting by adding a conditional statement within the square brackets as the selection criteria. For example, the logical evaluation introduced earlier returns either <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong>. An element whose index is marked as <strong class="source-inline">true</strong> in the square bracket would be selected. Let’s see <span class="No-Break">an example.</span></p></li>				<li>Select elements in <strong class="source-inline">vec_a</strong> that are bigger than the corresponding elements <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">vec_b</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a[vec_a &gt; vec_b]&#13;
2 3</pre><p class="list-inset">The result contains<a id="_idIndexMarker047"/> the last two elements since only the second and third indices are set <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p></li>			</ol>&#13;
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Matrix</h2>&#13;
			<p>Like<a id="_idIndexMarker048"/> a vector, a <strong class="bold">matrix</strong> is a <a id="_idIndexMarker049"/>two-dimensional array consisting of a collection of elements of the same data type arranged in a fixed number of rows and columns. It is often faster to work with a data structure exclusively containing the same data type since the program does not need to differentiate between different types of data. This makes the matrix a popular data structure in scientific computing, especially in an optimization procedure that involves intensive computation. Let’s get familiar with the matrix, including different ways to create, index, subset, and enlarge <span class="No-Break">a matrix.</span></p>&#13;
			<h3>Exercise 1.06 – creating a matrix</h3>&#13;
			<p>The standard way <a id="_idIndexMarker050"/>to create a matrix in R is to call the <strong class="source-inline">matrix()</strong> function, where we need to supply three <span class="No-Break">input arguments:</span></p>&#13;
			<ul>&#13;
				<li>The elements to be filled in <span class="No-Break">the matrix</span></li>&#13;
				<li>The number of rows in <span class="No-Break">the matrix</span></li>&#13;
				<li>The filling direction (either by row or <span class="No-Break">by column)</span></li>&#13;
			</ul>&#13;
			<p>We will also rename the rows and columns of <span class="No-Break">the matrix:</span></p>&#13;
			<ol>&#13;
				<li>Use <strong class="source-inline">vec_a</strong> and <strong class="source-inline">vec_b</strong> to create a matrix <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">mtx_a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; mtx_a = matrix(c(vec_a,vec_b), nrow=2, byrow=TRUE)&#13;
&gt;&gt;&gt; mtx_a&#13;
     [,1] [,2] [,3]&#13;
[1,]    1    2    3&#13;
[2,]    1    1    1</pre><p class="list-inset">First, the input vectors, <strong class="source-inline">vec_a</strong> and <strong class="source-inline">vec_b</strong>, are combined via the <strong class="source-inline">c()</strong> function to form a long vector, which then gets sequentially arranged into two rows (<strong class="source-inline">nrow=2</strong>) row-wise (<strong class="source-inline">byrow=TRUE</strong>). Feel free to try out different dimension configurations, such as setting three rows and two columns when creating <span class="No-Break">the matrix.</span></p><p class="list-inset">Pay<a id="_idIndexMarker051"/> attention to the row and column names in the output. The rows are indexed by the first index in the square bracket, while the second indexes the columns. We can also rename the matrix <span class="No-Break">as follows.</span></p></li>				<li>Rename the matrix <strong class="source-inline">mtx_a</strong> via the <strong class="source-inline">rownames()</strong> and <span class="No-Break"><strong class="source-inline">colnames()</strong></span><span class="No-Break"> functions:</span><pre class="source-code">&#13;
&gt;&gt;&gt; rownames(mtx_a) = c("r1", "r2")&#13;
&gt;&gt;&gt; colnames(mtx_a) = c("c1", "c2", "c3")&#13;
&gt;&gt;&gt; mtx_a&#13;
   c1 c2 c3&#13;
r1  1  2  3&#13;
r2  1  1  1</pre></li>			</ol>&#13;
			<p>Let’s look at how to select elements from <span class="No-Break">the matrix.</span></p>&#13;
			<h3>Exercise 1.07 – subsetting a matrix</h3>&#13;
			<p>We can<a id="_idIndexMarker052"/> still use the square brackets to select one or more matrix elements. The colon shorthand trick also applies to <span class="No-Break">matrix subsetting:</span></p>&#13;
			<ol>&#13;
				<li>Select the element at the first row and second column of the <span class="No-Break"><strong class="source-inline">mtx_a</strong></span><span class="No-Break"> matrix:</span><pre class="source-code">&#13;
&gt;&gt;&gt; mtx_a[1,2]&#13;
2</pre></li>				<li>Select all elements of the last two columns across all rows in the <span class="No-Break"><strong class="source-inline">mtx_a</strong></span><span class="No-Break"> matrix:</span><pre class="source-code">&#13;
&gt;&gt;&gt; mtx_a[1:2,c(2,3)]&#13;
   c2 c3&#13;
r1  2  3&#13;
r2  1  1</pre></li>				<li>Select all elements of the second row of the <span class="No-Break"><strong class="source-inline">mtx_a</strong></span><span class="No-Break"> matrix:</span><pre class="source-code">&#13;
&gt;&gt;&gt; mtx_a[2,]&#13;
c1 c2 c3&#13;
 1  1  1</pre><p class="list-inset">In this <a id="_idIndexMarker053"/>example, we have used the fact that the second (column-level) index indicates that all columns are selected when left blank. The same applies to the first (row-level) index <span class="No-Break">as well.</span></p><p class="list-inset">We can also select the second row using the <span class="No-Break">row name:</span></p><pre class="source-code">&gt;&gt;&gt; mtx_a[rownames(mtx_a)=="r2",]&#13;
c1 c2 c3&#13;
1  1</pre><p class="list-inset">Selecting elements by matching the row name using a conditional evaluation statement offers a more precise way of subsetting the matrix, especially when counting the exact index becomes troublesome. Name-based indexing also applies <span class="No-Break">to columns.</span></p></li>				<li>Select the third row of the <span class="No-Break"><strong class="source-inline">mtx_a</strong></span><span class="No-Break"> matrix:</span><pre class="source-code">&#13;
&gt;&gt;&gt; mtx_a[,3]&#13;
r1 r2&#13;
 3  1&#13;
&gt;&gt;&gt; mtx_a[,colnames(mtx_a)=="c3"]&#13;
r1 r2&#13;
 3  1</pre><p class="list-inset">Therefore, we have multiple ways to select the specific elements of interest from <span class="No-Break">a matrix.</span></p></li>			</ol>&#13;
			<p>Working with a matrix requires similar arithmetic operations compared to a vector. In the next exercise, we <a id="_idIndexMarker054"/>will look at summarizing a matrix both row-wise and column-wise and performing basic operations such as addition <span class="No-Break">and multiplication.</span></p>&#13;
			<h3>Exercise 1.08 – arithmetic operations with a matrix</h3>&#13;
			<p>Let’s<a id="_idIndexMarker055"/> start by making a <span class="No-Break">new matrix:</span></p>&#13;
			<ol>&#13;
				<li>Create another matrix named <strong class="source-inline">mtx_b</strong> whose elements are double those <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">mtx_a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; mtx_b = mtx_a * 2&#13;
&gt;&gt;&gt; mtx_b&#13;
   c1 c2 c3&#13;
r1  2  4  6&#13;
r2  2  2  2</pre><p class="list-inset">Besides multiplication, all standard arithmetic operators (such as <strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, and <strong class="source-inline">/</strong>) apply in a similar element-wise fashion to a matrix, backed by the same broadcasting mechanism. Operations between two matrices of the same size are also <span class="No-Break">performed element-wise.</span></p></li>				<li>Divide <strong class="source-inline">mtx_a</strong> <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">mtx_b</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; mtx_a / mtx_b&#13;
    c1  c2  c3&#13;
r1 0.5 0.5 0.5&#13;
r2 0.5 0.5 0.5</pre></li>				<li>Calculate the row-wise and column-wise sum and mean of <strong class="source-inline">mtx_a</strong> using <strong class="source-inline">rowSums()</strong>, <strong class="source-inline">colSums()</strong>,<strong class="source-inline"> rowMeans()</strong>, and <span class="No-Break"><strong class="source-inline">colMeans()</strong></span><span class="No-Break"> respectively:</span><pre class="source-code">&#13;
&gt;&gt;&gt; rowSums(mtx_a)&#13;
r1 r2&#13;
 6  3&#13;
&gt;&gt;&gt; colSums(mtx_a)&#13;
c1 c2 c3&#13;
 2  3  4&#13;
&gt;&gt;&gt; rowMeans(mtx_a)&#13;
r1 r2&#13;
 2  1&#13;
&gt;&gt;&gt; colMeans(mtx_a)&#13;
c1  c2  c3&#13;
1.0 1.5 2.0</pre></li>			</ol>&#13;
			<p>When<a id="_idIndexMarker056"/> running an optimizing procedure, we often need to save some intermediate metrics, such as model loss and accuracy, for diagnosis. These metrics can be saved in a matrix form by gradually appending new data to the current matrix. Let’s look at how to expand a matrix both row-wise <span class="No-Break">and column-wise.</span></p>&#13;
			<h3>Exercise 1.09 – expanding a matrix</h3>&#13;
			<p>Adding<a id="_idIndexMarker057"/> a column or multiple columns to a matrix can be achieved via the <strong class="source-inline">cbind()</strong> function, which merges a new matrix or vector column-wise. Similarly, an additional matrix or vector can be concatenated row-wise via the <span class="No-Break"><strong class="source-inline">rbind()</strong></span><span class="No-Break"> function:</span></p>&#13;
			<ol>&#13;
				<li>Append <strong class="source-inline">mtx_b</strong> to <span class="No-Break"><strong class="source-inline">mtx_a</strong></span><span class="No-Break"> column-wise:</span><pre class="source-code">&#13;
&gt;&gt;&gt; cbind(mtx_a, mtx_b)&#13;
   c1 c2 c3 c1 c2 c3&#13;
r1  1  2  3  2  4  6&#13;
r2  1  1  1  2  2  2</pre><p class="list-inset">We may need to rename the columns since some of them overlap. This also applies to the row-wise concatenation <span class="No-Break">as follows.</span></p></li>				<li>Append <strong class="source-inline">mtx_b</strong> to <span class="No-Break"><strong class="source-inline">mtx_a</strong></span><span class="No-Break"> row-wise:</span><pre class="source-code">&#13;
&gt;&gt;&gt; rbind(mtx_a, mtx_b)&#13;
   c1 c2 c3&#13;
r1  1  2  3&#13;
r2  1  1  1&#13;
r1  2  4  6&#13;
r2  2  2  2</pre></li>			</ol>&#13;
			<p>So, we’ve seen the <a id="_idIndexMarker058"/>matrix in operation. How about data <span class="No-Break">frames next?</span></p>&#13;
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Data frame</h2>&#13;
			<p>A <strong class="bold">data frame</strong> is a <a id="_idIndexMarker059"/>standard data structure where variables <a id="_idIndexMarker060"/>are stored as columns and observations as rows in an <strong class="bold">object</strong>. It is<a id="_idIndexMarker061"/> an advanced version of a matrix in that the elements for each column can be of different <span class="No-Break">data types.</span></p>&#13;
			<p>The R engine comes with several default datasets stored as data frames. In the next exercise, we will look at different ways to examine and understand the structure of a <span class="No-Break">data frame.</span></p>&#13;
			<h3>Exercise 1.10 – understanding data frames</h3>&#13;
			<p>The data frame<a id="_idIndexMarker062"/> is a famous data structure representing rectangular-shaped data similar to Excel. Let’s examine a default dataset in R as <span class="No-Break">an example:</span></p>&#13;
			<ol>&#13;
				<li>Load the <span class="No-Break"><strong class="source-inline">iris</strong></span><span class="No-Break"> dataset:</span><pre class="source-code">&#13;
&gt;&gt;&gt; data("iris")&#13;
&gt;&gt;&gt; dim(iris)&#13;
150   5</pre><p class="list-inset">Checking the dimension using the <strong class="source-inline">dim()</strong> function suggests that the <strong class="source-inline">iris</strong> dataset contains 150 rows and five columns. We can initially understand its contents by looking at the first and last few observations (rows) in <span class="No-Break">the dataset.</span></p></li>				<li>Examine<a id="_idIndexMarker063"/> the first and last five rows using <strong class="source-inline">head()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">tail()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; head(iris)&#13;
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species&#13;
1          5.1         3.5          1.4         0.2  setosa&#13;
2          4.9         3.0          1.4         0.2  setosa&#13;
3          4.7         3.2          1.3         0.2  setosa&#13;
4          4.6         3.1          1.5         0.2  setosa&#13;
5          5.0         3.6          1.4         0.2  setosa&#13;
6          5.4         3.9          1.7         0.4  setosa&#13;
&gt;&gt;&gt; tail(iris)&#13;
    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species&#13;
145          6.7         3.3          5.7         2.5 virginica&#13;
146          6.7         3.0          5.2         2.3 virginica&#13;
147          6.3         2.5          5.0         1.9 virginica&#13;
148          6.5         3.0          5.2         2.0 virginica&#13;
149          6.2         3.4          5.4         2.3 virginica&#13;
150          5.9         3.0          5.1         1.8 virginica</pre><p class="list-inset">Note that<a id="_idIndexMarker064"/> the row names are sequentially indexed by integers starting from one by default. The first four columns are numeric, and the last is a character (or factor). We can look at the structure of the data frame <span class="No-Break">more systematically.</span></p></li>				<li>Examine the structure of the <strong class="source-inline">iris</strong> dataset <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">str()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str(iris)&#13;
'data.frame':    150 obs. of  5 variables:&#13;
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...&#13;
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...&#13;
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...&#13;
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...&#13;
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...</pre><p class="list-inset">The <strong class="source-inline">str()</strong> function summarizes the data frame structure, including the total number of observations and variables, the complete list of variable names, data type, and the first few observations. The number of categories (levels) is also shown if the column is <span class="No-Break">a factor.</span></p><p class="list-inset">We can also create a data frame by passing in vectors as columns of the same length to the <span class="No-Break"><strong class="source-inline">data.frame()</strong></span><span class="No-Break"> function.</span></p></li>				<li>Create a data frame called <strong class="source-inline">df_a</strong> with two columns that correspond to <strong class="source-inline">vec_a</strong> and <span class="No-Break"><strong class="source-inline">vec_b</strong></span><span class="No-Break"> respectively:</span><pre class="source-code">&#13;
&gt;&gt;&gt; df_a = data.frame("a"=vec_a, "b"=vec_b)&#13;
&gt;&gt;&gt; df_a&#13;
  a b&#13;
1 1 1&#13;
2 2 1&#13;
3 3 1</pre></li>			</ol>&#13;
			<p>Selecting the <a id="_idIndexMarker065"/>elements of a data frame can be done in a similar fashion to matrix selection. Other functions such as <strong class="source-inline">subset()</strong> make the selection more flexible. Let’s go through <span class="No-Break">an example.</span></p>&#13;
			<h3>Exercise 1.11 – selecting elements in a data frame</h3>&#13;
			<p>In this <a id="_idIndexMarker066"/>exercise, we will first look at different ways to select a particular set of elements and then introduce the <strong class="source-inline">subset()</strong> function to perform customized <span class="No-Break">conditional selection:</span></p>&#13;
			<ol>&#13;
				<li>Select the second column of the <strong class="source-inline">df_a</strong> <span class="No-Break">data frame:</span><pre class="source-code">&#13;
&gt;&gt;&gt; df_a[,2]&#13;
1 1 1</pre><p class="list-inset">The row-level indexing is left blank to indicate that all rows will be selected. We can also make it explicit by referencing all <span class="No-Break">row-level indices:</span></p><pre class="source-code">&gt;&gt;&gt; df_a[1:3,2]&#13;
1 1 1</pre><p class="list-inset">We can also select by using the name of the second column <span class="No-Break">as follows:</span></p><pre class="source-code">&gt;&gt;&gt; df_a[,"b"]&#13;
1 1 1</pre><p class="list-inset">Alternatively, we can use the shortcut <strong class="source-inline">$</strong> sign to reference the column <span class="No-Break">name directly:</span></p><pre class="source-code">&gt;&gt;&gt; df_a$b&#13;
1 1 1</pre><p class="list-inset">The <strong class="source-inline">subset()</strong> function provides an easy and structured way to perform row-level filtering and column-level selection. Let’s see how it works <span class="No-Break">in practice.</span></p></li>				<li>Select <a id="_idIndexMarker067"/>the rows of <strong class="source-inline">df_a</strong> where column <strong class="source-inline">a</strong> is greater <span class="No-Break">than two:</span><pre class="source-code">&#13;
&gt;&gt;&gt; subset(df_a, a&gt;2)&#13;
  a b&#13;
3 3 1</pre><p class="list-inset">Note that row index three is also shown as part of <span class="No-Break">the output.</span></p><p class="list-inset">We can directly use column <strong class="source-inline">a</strong> within the context of the <strong class="source-inline">subset()</strong> function, saving us from using the <strong class="source-inline">$</strong> sign instead. We can also select the column by passing the column name to the <span class="No-Break"><strong class="source-inline">select</strong></span><span class="No-Break"> argument.</span></p></li>				<li>Select column <strong class="source-inline">b</strong> where column <strong class="source-inline">a</strong> is greater than two <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">df_a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; subset(df_a, a&gt;2, select="b")&#13;
  b&#13;
3 1</pre></li>			</ol>&#13;
			<p>Another typical operation in data analysis is sorting one or more variables of a data frame. Let’s see how it works <span class="No-Break">in R.</span></p>&#13;
			<h3>Exercise 1.12 – sorting vectors and data frames</h3>&#13;
			<p>The <strong class="source-inline">order()</strong> function<a id="_idIndexMarker068"/> can <a id="_idIndexMarker069"/>be used to return the ranked position of the elements in the input vector, which can then be used to sort the elements via <span class="No-Break">updated indexing:</span></p>&#13;
			<ol>&#13;
				<li>Create the <strong class="source-inline">c(5,1,10)</strong> vector in <strong class="source-inline">vec_c</strong> and sort it in <span class="No-Break">ascending order:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_c = c(5,1,10)&#13;
&gt;&gt;&gt; order(vec_c)&#13;
2 1 3&#13;
&gt;&gt;&gt; vec_c[order(vec_c)]&#13;
1  5 10</pre><p class="list-inset">Since the smallest element in <strong class="source-inline">vec_c</strong> is <strong class="source-inline">1</strong>, the corresponding ranked position is <strong class="source-inline">1</strong>. Similarly, <strong class="source-inline">5</strong> is set as the second rank and <strong class="source-inline">10</strong> as the third and highest rank. The ranked positions are then used to reshuffle and sort the original vector, the same as how we would select its elements <a id="_idIndexMarker070"/>via <span class="No-Break"><strong class="bold">positional indexing</strong></span><span class="No-Break">.</span></p><p class="list-inset">The <strong class="source-inline">order()</strong> function<a id="_idIndexMarker071"/> ranks the elements in ascending order<a id="_idIndexMarker072"/> by default. What if we want to sort by descending order? We could simply add a minus sign to the <span class="No-Break">input vector.</span></p></li>				<li>Sort the <strong class="source-inline">df_a</strong> data frame by column <strong class="source-inline">a</strong> in <span class="No-Break">descending order:</span><pre class="source-code">&#13;
&gt;&gt;&gt; df_a[order(-df_a$a),]&#13;
  a b&#13;
3 3 1&#13;
2 2 1&#13;
1 1 1</pre></li>			</ol>&#13;
			<p>Data frames will be the primary structures we will work with in this book. Let’s look at the last and most complex data <span class="No-Break">structure: list.</span></p>&#13;
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>List</h2>&#13;
			<p>A <strong class="bold">list</strong> is a <a id="_idIndexMarker073"/>flexible <a id="_idIndexMarker074"/>data structure that can hold different data types (numeric, integer, character, logical, factor, or even list itself), each possibly having a different length. It is the most complex structure we have introduced so far, gathering various objects in a structured way. To recap, let’s compare the four data structures in terms of the contents, data type, and length in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.8</em>. In general, all four structures can store elements of any data type. Vectors (one-dimensional array) and matrices (two-dimensional array) require the contents to be homogeneous data types. A data frame contains one or more vectors whose data types could differ, and a list could <a id="_idIndexMarker075"/>contain entries of different data types. Matrices and data frames follows a rectangular shape and so require the same length for each column. However, the entries in a list could be of arbitrary lengths (subject to memory constraint) different from <span class="No-Break">each other.</span></p>&#13;
			<div>&#13;
				<div id="_idContainer015" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_008..jpg" alt="Figure 1.8 – Comparing four different data structures in terms of contents, data type, and length" width="1650" height="813"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Comparing four different data structures in terms of contents, data type, and length</p>&#13;
			<p>Let’s look at how<a id="_idIndexMarker076"/> to create <span class="No-Break">a list.</span></p>&#13;
			<h3>Exercise 1.13 – creating a list</h3>&#13;
			<p>In this exercise, we <a id="_idIndexMarker077"/>will go through different ways to manipulate a list, including creating and renaming a list, and accessing, adding, and removing elements in <span class="No-Break">a list:</span></p>&#13;
			<ol>&#13;
				<li>Create a list using the previous <strong class="source-inline">a</strong>, <strong class="source-inline">vec_a</strong>, and <span class="No-Break"><strong class="source-inline">df_a</strong></span><span class="No-Break"> variables:</span><pre class="source-code">&#13;
&gt;&gt;&gt; ls_a = list(a, vec_a, df_a)&#13;
&gt;&gt;&gt; ls_a&#13;
[[1]]&#13;
[1] 1&#13;
[[2]]&#13;
[1] 1 2 3&#13;
[[3]]&#13;
  a b&#13;
1 1 1&#13;
2 2 1&#13;
3 3 1</pre><p class="list-inset">The output shows that the list elements are indexed by double square brackets, which can be used to access the entries in <span class="No-Break">the list.</span></p></li>				<li>Access<a id="_idIndexMarker078"/> the second entry in the <span class="No-Break">list, </span><span class="No-Break"><strong class="source-inline">ls_a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; ls_a[[2]]&#13;
1 2 3</pre><p class="list-inset">The default indices can also be renamed to enable entry selection <span class="No-Break">by name.</span></p></li>				<li>Rename the list based on the original names and access the <span class="No-Break"><strong class="source-inline">vec_a</strong></span><span class="No-Break"> variable:</span><pre class="source-code">&#13;
&gt;&gt;&gt; names(ls_a) &lt;- c("a", "vec_a", "df_a")&#13;
ls_a&#13;
$a&#13;
[1] 1&#13;
$vec_a&#13;
[1] 1 2 3&#13;
$df_a&#13;
  a b&#13;
1 1 1&#13;
2 2 1&#13;
3 3 1&#13;
&gt;&gt;&gt; ls_a[['vec_a']]&#13;
1 2 3&#13;
&gt;&gt;&gt; ls_a$vec_a&#13;
1 2 3</pre><p class="list-inset">We can access a specific entry in the list by using the name either in square brackets or via the <strong class="source-inline">$</strong> <span class="No-Break">sign.</span></p></li>				<li>Add a new <a id="_idIndexMarker079"/>entry named <strong class="source-inline">new_entry</strong> with the content <strong class="source-inline">"test"</strong> in the <span class="No-Break"><strong class="source-inline">ls_a</strong></span><span class="No-Break"> list:</span><pre class="source-code">&#13;
&gt;&gt;&gt; ls_a[['new_entry']] = "test"&#13;
&gt;&gt;&gt; ls_a&#13;
$a&#13;
[1] 1&#13;
$vec_a&#13;
[1] 1 2 3&#13;
$df_a&#13;
  a b&#13;
1 1 1&#13;
2 2 1&#13;
3 3 1&#13;
$new_entry&#13;
[1] "test"</pre><p class="list-inset">The result shows that <strong class="source-inline">"test"</strong> is now added to the last entry of <strong class="source-inline">ls_a</strong>. We can also remove a specific entry by assigning <strong class="source-inline">NULL</strong> <span class="No-Break">to it.</span></p></li>				<li>Remove <a id="_idIndexMarker080"/>the entry named <strong class="source-inline">df_a</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ls_a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; ls_a[['df_a']] = NULL&#13;
&gt;&gt;&gt; ls_a&#13;
$a&#13;
[1] 1&#13;
$vec_a&#13;
[1] 1 2 3&#13;
$new_entry&#13;
[1] "test"</pre><p class="list-inset">The entry named <strong class="source-inline">df_a</strong> is now successfully removed from the list. We can also update an existing entry in <span class="No-Break">the list.</span></p></li>				<li>Update the entry named <strong class="source-inline">vec_a</strong> to <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">c(1,2)</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; ls_a[['vec_a']] = c(1,2)&#13;
&gt;&gt;&gt; ls_a&#13;
$a&#13;
[1] 1&#13;
$vec_a&#13;
[1] 1 2&#13;
$new_entry&#13;
[1] "test"</pre><p class="list-inset">The entry named <strong class="source-inline">vec_a</strong> is now <span class="No-Break">successfully updated.</span></p></li>			</ol>&#13;
			<p>The flexibility <a id="_idIndexMarker081"/>and scalability of the list structure make it a popular choice for storing heterogeneous data elements, similar to the dictionary in Python. In the next section, we will extend our knowledge base by going over the control logic in R, which gives us more flexibility and precision when writing <span class="No-Break">long programs.</span></p>&#13;
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Control logic in R</h1>&#13;
			<p>Relational <a id="_idIndexMarker082"/>and logical operators<a id="_idIndexMarker083"/> help compare statements as we add logic to the program. We can also add to the complexity by evaluating multiple conditional statements via loops that repeatedly iterate over a sequence of actions. This section will cover the essential relational and logical operators that form the building blocks of <span class="No-Break">conditional statements.</span></p>&#13;
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Relational operators</h2>&#13;
			<p>We<a id="_idIndexMarker084"/> briefly<a id="_idIndexMarker085"/> covered a few relational operators such as <strong class="source-inline">&gt;=</strong> and <strong class="source-inline">==</strong> earlier. This section will provide a detailed walkthrough on the use of standard relational operators. Let’s look at a <span class="No-Break">few examples.</span></p>&#13;
			<h3>Exercise 1.14 – practicing with standard relational operators</h3>&#13;
			<p>Relational operators<a id="_idIndexMarker086"/> allow us to compare two quantities and obtain the single result of the comparison. We will go over the following steps to learn how to express and use standard relational operators <span class="No-Break">in R:</span></p>&#13;
			<ol>&#13;
				<li>Execute the following evaluations using the equality operator (<strong class="source-inline">==</strong>) and observe <span class="No-Break">the output:</span><pre class="source-code">&#13;
&gt;&gt;&gt; 1 == 2&#13;
FALSE&#13;
&gt;&gt;&gt; "statistics" == "calculus"&#13;
FALSE&#13;
&gt;&gt;&gt; TRUE == TRUE&#13;
TRUE&#13;
&gt;&gt;&gt; TRUE == FALSE&#13;
FALSE</pre><p class="list-inset">The equality operator performs by strictly evaluating the two input arguments on both sides (including logical data) and only returns <strong class="source-inline">TRUE</strong> if they <span class="No-Break">are equal.</span></p></li>				<li>Execute<a id="_idIndexMarker087"/> the same evaluations using the inequality operator (<strong class="source-inline">!=</strong>) and observe <span class="No-Break">the output:</span><pre class="source-code">&#13;
&gt;&gt;&gt; 1 != 2&#13;
TRUE&#13;
&gt;&gt;&gt; "statistics" != "calculus"&#13;
TRUE&#13;
&gt;&gt;&gt; TRUE != TRUE&#13;
FALSE&#13;
&gt;&gt;&gt; TRUE != FALSE&#13;
TRUE</pre><p class="list-inset">The inequality operator is the exact opposite of the <span class="No-Break">equality operator.</span></p></li>				<li>Execute the following evaluations using the greater than and less than operators (<strong class="source-inline">&gt;</strong> and <strong class="source-inline">&lt;</strong>) and observe <span class="No-Break">the output:</span><pre class="source-code">&#13;
&gt;&gt;&gt; 1 &lt; 2&#13;
TRUE&#13;
&gt;&gt;&gt; "statistics" &gt; "calculus"&#13;
TRUE&#13;
&gt;&gt;&gt; TRUE &gt; FALSE&#13;
TRUE</pre><p class="list-inset">In the second evaluation, the comparison between character data follows the pairwise alphabetical order of both strings starting from the leftmost character. In this case, the letter <strong class="source-inline">s</strong> comes after <strong class="source-inline">c</strong> and is encoded as a higher-valued numeric. In the third example, <strong class="source-inline">TRUE</strong> is converted into one and <strong class="source-inline">FALSE</strong> into zero, so returning a logical value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">TRUE</strong></span><span class="No-Break">.</span></p></li>				<li>Execute<a id="_idIndexMarker088"/> the following evaluations using the greater-than-or-equal-to operator (<strong class="source-inline">&gt;=</strong>) and less-than-or-equal-to operator (<strong class="source-inline">&lt;=</strong>) and observe <span class="No-Break">the output:</span><pre class="source-code">&#13;
&gt;&gt;&gt; 1 &gt;= 2&#13;
FALSE&#13;
&gt;&gt;&gt; 2 &lt;= 2&#13;
TRUE</pre><p class="list-inset">Note that these operators consist of two conditional evaluations connected via an <strong class="source-inline">OR</strong> operator (<strong class="source-inline">|</strong>). We can, therefore, break it down into two evaluations in brackets, resulting in the same output <span class="No-Break">as before:</span></p><pre class="source-code">&gt;&gt;&gt; (1 &gt; 2) | (1 == 2)&#13;
FALSE&#13;
&gt;&gt;&gt; (2 &lt; 2) | (2 == 2)&#13;
TRUE</pre><p class="list-inset">The relational operators also apply to vectors, which we encountered earlier, such as row-level filtering to subset a <span class="No-Break">data frame.</span></p></li>				<li>Compare <strong class="source-inline">vec_a</strong> with <strong class="source-inline">1</strong> using the <span class="No-Break">greater-than operator:</span><pre class="source-code">&#13;
&gt;&gt;&gt; vec_a &gt; 1&#13;
FALSE  TRUE  TRUE</pre><p class="list-inset">We would get the same result by separately comparing each element and combining the resulting <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">c()</strong></span><span class="No-Break">.</span></p></li>			</ol>&#13;
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Logical operators</h2>&#13;
			<p>A <strong class="bold">logical operator</strong> is <a id="_idIndexMarker089"/>used to combine the results of <a id="_idIndexMarker090"/>multiple relational operators. There are three basic logical operators in R, including <strong class="source-inline">AND</strong> (<strong class="source-inline">&amp;</strong>), <strong class="source-inline">OR</strong> (<strong class="source-inline">|</strong>), and <strong class="source-inline">NOT</strong> (<strong class="source-inline">!</strong>). The <strong class="source-inline">AND</strong> operator returns <strong class="source-inline">TRUE</strong> only if both operands are <strong class="source-inline">TRUE</strong>, and the <strong class="source-inline">OR</strong> operator returns <strong class="source-inline">TRUE</strong> if at least one operand is <strong class="source-inline">TRUE</strong>. On the other hand, the <strong class="source-inline">NOT</strong> operator flips the evaluation result to <span class="No-Break">the opposite.</span></p>&#13;
			<p>Let’s go through an exercise on the use of these <span class="No-Break">logical operators.</span></p>&#13;
			<h3>Exercise 1.15 – practicing using standard logical operators</h3>&#13;
			<p>We will start<a id="_idIndexMarker091"/> with the <strong class="source-inline">AND</strong> operator, the most widely used control logic to ensure a specific action only happens if multiple conditions are satisfied at the <span class="No-Break">same time:</span></p>&#13;
			<ol>&#13;
				<li>Execute the following evaluations using the <strong class="source-inline">AND</strong> operator and observe <span class="No-Break">the output:</span><pre class="source-code">&#13;
&gt;&gt;&gt; TRUE &amp; FALSE&#13;
FALSE&#13;
&gt;&gt;&gt; TRUE &amp; TRUE&#13;
TRUE&#13;
&gt;&gt;&gt; FALSE &amp; FALSE&#13;
FALSE&#13;
&gt;&gt;&gt; 1 &gt; 0 &amp; 1 &lt; 2&#13;
TRUE</pre><p class="list-inset">The result shows that both conditions need to be satisfied to obtain a <span class="No-Break"><strong class="source-inline">TRUE</strong></span><span class="No-Break"> output.</span></p></li>				<li>Execute the following evaluations using the <strong class="source-inline">OR</strong> operator and observe <span class="No-Break">the output:</span><pre class="source-code">&#13;
&gt;&gt;&gt; TRUE | FALSE&#13;
TRUE&#13;
&gt;&gt;&gt; TRUE | TRUE&#13;
TRUE&#13;
&gt;&gt;&gt; FALSE | FALSE&#13;
FALSE&#13;
&gt;&gt;&gt; 1 &lt; 0 | 1 &lt; 2&#13;
TRUE</pre><p class="list-inset">The result shows that the output is <strong class="source-inline">TRUE</strong> if at least one condition is evaluated <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">TRUE</strong></span><span class="No-Break">.</span></p></li>				<li>Execute<a id="_idIndexMarker092"/> the following evaluations using the <strong class="source-inline">NOT</strong> operator and observe <span class="No-Break">the output:</span><pre class="source-code">&#13;
&gt;&gt;&gt; !TRUE&#13;
FALSE&#13;
&gt;&gt;&gt; !FALSE&#13;
TRUE&#13;
&gt;&gt;&gt; !(1&lt;0)&#13;
TRUE</pre><p class="list-inset">In the third example, the evaluation is the same as <strong class="source-inline">1 &gt;= 0</strong>, which returns <strong class="source-inline">TRUE</strong>. The <strong class="source-inline">NOT</strong> operator, therefore, reverses the evaluation result after the <span class="No-Break">exclamation sign.</span></p><p class="list-inset">These operators can also be used to perform pairwise logical evaluations <span class="No-Break">in vectors.</span></p></li>				<li>Execute the following evaluations and observe <span class="No-Break">the output:</span><pre class="source-code">&#13;
&gt;&gt;&gt; c(TRUE, FALSE) &amp; c(TRUE, TRUE)&#13;
TRUE FALSE&#13;
&gt;&gt;&gt; c(TRUE, FALSE) | c(TRUE, TRUE)&#13;
TRUE TRUE&#13;
&gt;&gt;&gt; !c(TRUE, FALSE)&#13;
FALSE  TRUE</pre></li>			</ol>&#13;
			<p>There is <a id="_idIndexMarker093"/>also a long-form for the <strong class="source-inline">AND</strong> (<strong class="source-inline">&amp;&amp;</strong>) and the <strong class="source-inline">OR</strong> (<strong class="source-inline">||</strong>) logical operators. Different from the element-wise comparison in the previous short-form, the long-form is used to evaluate only the first element of each input vector, and such evaluation continues only until the result is determined. In other words, the long-form only returns a single result when evaluating two vectors of multiple elements. It is most widely used in modern R programming control flow, especially in the conditional <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> statement.</span></p>&#13;
			<p>Let’s look at the <span class="No-Break">following example:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; c(TRUE, FALSE) &amp;&amp; c(FALSE, TRUE)&#13;
FALSE&#13;
&gt;&gt;&gt; c(TRUE, FALSE) || c(FALSE, TRUE)&#13;
TRUE</pre>			<p>Both evaluations are based on the first element of each vector. That is, the second element of each vector is ignored in both evaluations. This offers computational benefit, especially when the vectors are large. Since there is no point in continuing the evaluation if the final result can be obtained by evaluating the first element, we can safely discard <span class="No-Break">the rest.</span></p>&#13;
			<p>In the first evaluation using <strong class="source-inline">&amp;&amp;</strong>, comparing the first element of the two vectors (<strong class="source-inline">TRUE</strong> and <strong class="source-inline">FALSE</strong>) returns <strong class="source-inline">FALSE</strong>, while continuing the comparison of the second element will also return <strong class="source-inline">FALSE</strong>, so the second comparison is unnecessary. In the second evaluation using <strong class="source-inline">||</strong>, comparing the first element (<strong class="source-inline">TRUE | FALSE</strong>) gives <strong class="source-inline">TRUE</strong>, saving the need to make the second comparison, as the result will always be evaluated <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">TRUE</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Conditional statements</h2>&#13;
			<p>A <strong class="bold">conditional statement</strong>, or <a id="_idIndexMarker094"/>more specifically, the <strong class="source-inline">if-else</strong> statement, is used to combine<a id="_idIndexMarker095"/> the result of multiple logical operators and decide the flow of follow-up actions. It is commonly used to increase the complexity of large R programs. The <strong class="source-inline">if-else</strong> statement follows a general structure as follows, where the evaluation condition is first validated. If <a id="_idIndexMarker096"/>the validation returns <strong class="source-inline">TRUE</strong>, the expression within the curve braces of the <strong class="source-inline">if</strong> clause would be executed and the rest of the code is<a id="_idIndexMarker097"/> ignored. Otherwise, the expression within the <strong class="source-inline">else</strong> clause would <span class="No-Break">be executed:</span></p>&#13;
			<pre class="source-code">&#13;
if(evaluation condition){&#13;
some expression&#13;
} else {&#13;
other expression&#13;
}</pre>			<p>Let’s go through an exercise to see how to use the <strong class="source-inline">if-else</strong> <span class="No-Break">control statement.</span></p>&#13;
			<h3>Exercise 1.16 – practicing using the conditional statement</h3>&#13;
			<p>Time for <a id="_idIndexMarker098"/>another exercise! Let’s practice using the <span class="No-Break">conditional statement:</span></p>&#13;
			<ol>&#13;
				<li>Initialize an <strong class="source-inline">x</strong> variable with a value of <strong class="source-inline">1</strong> and write an <strong class="source-inline">if-else</strong> condition to determine the output message. Print out <strong class="source-inline">"positive"</strong> if <strong class="source-inline">x</strong> is greater than zero, and <strong class="source-inline">"not </strong><span class="No-Break"><strong class="source-inline">positive"</strong></span><span class="No-Break"> otherwise:</span><pre class="source-code">&#13;
&gt;&gt;&gt; x = 1&#13;
&gt;&gt;&gt; if(x &gt; 0){&#13;
&gt;&gt;&gt;	print("positive")&#13;
&gt;&gt;&gt; } else {&#13;
&gt;&gt;&gt; 	print("not positive")&#13;
&gt;&gt;&gt; }&#13;
"positive"</pre><p class="list-inset">The condition within the <strong class="source-inline">if</strong> clause evaluates to be <strong class="source-inline">TRUE</strong>, and the code inside is executed, printing out <strong class="source-inline">"positive"</strong> in the console. Note that the <strong class="source-inline">else</strong> branch is optional and can be removed if we only intend to place one check to the input. Additional <strong class="source-inline">if-else</strong> control can also be embedded within <span class="No-Break">a branch.</span></p><p class="list-inset">We <a id="_idIndexMarker099"/>can also add additional branches using the <strong class="source-inline">if-else</strong> conditional control statement, where the middle part can be repeated <span class="No-Break">multiple times.</span></p></li>				<li>Initialize an <strong class="source-inline">x</strong> variable with <strong class="source-inline">0</strong> and write a control flow to determine and print out <span class="No-Break">its sign:</span><pre class="source-code">&#13;
&gt;&gt;&gt; x = 0&#13;
&gt;&gt;&gt; if(x &gt; 0){&#13;
&gt;&gt;&gt;  print("positive")&#13;
&gt;&gt;&gt; } else if(x == 0){&#13;
&gt;&gt;&gt;  print("zero")&#13;
&gt;&gt;&gt; } else {&#13;
&gt;&gt;&gt;  print("negative")&#13;
&gt;&gt;&gt; }&#13;
"zero"</pre><p class="list-inset">As the conditions are sequentially evaluated, the second statement returns <strong class="source-inline">TRUE</strong> and so prints <span class="No-Break">out </span><span class="No-Break"><strong class="source-inline">"zero"</strong></span><span class="No-Break">.</span></p></li>			</ol>&#13;
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Loops</h2>&#13;
			<p>A <strong class="bold">loop</strong> is <a id="_idIndexMarker100"/>similar to the <strong class="source-inline">if</strong> statement; the codes will only be executed <a id="_idIndexMarker101"/>if the condition evaluates to be <strong class="source-inline">TRUE</strong>. The only difference is that a loop will continue to iteratively execute the code as long as the condition is <strong class="source-inline">TRUE</strong>. There are two types of loops: the <strong class="source-inline">while</strong> loop and the <strong class="source-inline">for</strong> loop. The <strong class="source-inline">while</strong> loop is used when the number of iterations is unknown, and the termination relies on either the evaluation condition or a separated condition within the running expression using the <strong class="source-inline">break</strong> control statement. The <strong class="source-inline">for</strong> loop is<a id="_idIndexMarker102"/> used when the number of iterations <span class="No-Break">is known.</span></p>&#13;
			<p>The <strong class="source-inline">while</strong> loop <a id="_idIndexMarker103"/>follows a general structure as follows, where <strong class="source-inline">condition 1</strong> first gets evaluated to determine the expression within the outer curly braces that should be executed. There is an (optional) <strong class="source-inline">if</strong> statement to decide whether the <strong class="source-inline">while</strong> loop needs to be terminated based on <strong class="source-inline">condition 2</strong>. These two conditions control the termination of the <strong class="source-inline">while</strong> loop, which exits the execution as long as any one condition evaluates as <strong class="source-inline">TRUE</strong>. Inside the <strong class="source-inline">if</strong> clause, <strong class="source-inline">condition 2</strong> can be placed anywhere within the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> block:</span></p>&#13;
			<pre class="source-code">&#13;
while(condition 1){&#13;
some expression&#13;
if(condition 2){&#13;
        break&#13;
}&#13;
}</pre>			<p>Note<a id="_idIndexMarker104"/> that <strong class="source-inline">condition 1</strong> within the <strong class="source-inline">while</strong> statement needs to be <strong class="source-inline">FALSE</strong> at some point; otherwise, the loop will continue indefinitely, which may cause a session expiry error <span class="No-Break">within RStudio.</span></p>&#13;
			<p>Let’s go through an exercise to look at how to use the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop.</span></p>&#13;
			<h3>Exercise 1.17 – practicing the while loop</h3>&#13;
			<p>Let’s try <a id="_idIndexMarker105"/>out the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop:</span></p>&#13;
			<ol>&#13;
				<li>Initialize an <strong class="source-inline">x</strong> variable with a value of <strong class="source-inline">2</strong> and write a <strong class="source-inline">while</strong> loop. If <strong class="source-inline">x</strong> is less than <strong class="source-inline">10</strong>, square it and print out <span class="No-Break">its value:</span><pre class="source-code">&#13;
&gt;&gt;&gt; x = 2&#13;
&gt;&gt;&gt; while(x &lt; 10){&#13;
&gt;&gt;&gt;   x = x^2&#13;
&gt;&gt;&gt;   print(x)&#13;
&gt;&gt;&gt; }&#13;
4&#13;
16</pre><p class="list-inset">The <strong class="source-inline">while</strong> loop is executed twice, bringing the value of <strong class="source-inline">x</strong> from <strong class="source-inline">2</strong> to <strong class="source-inline">16</strong>. During the third evaluation, <strong class="source-inline">x</strong> is above 10 and the conditional statement evaluates to be <strong class="source-inline">FALSE</strong>, thus exiting the loop. We can also print out <strong class="source-inline">x</strong> to double-check <span class="No-Break">its value:</span></p><pre class="source-code">&gt;&gt;&gt; x&#13;
16</pre></li>				<li>Add a <a id="_idIndexMarker106"/>condition after the squaring to exit the loop if <strong class="source-inline">x</strong> is greater <span class="No-Break">than 10:</span><pre class="source-code">&#13;
&gt;&gt;&gt; x = 2&#13;
&gt;&gt;&gt; while(x &lt; 10){&#13;
&gt;&gt;&gt;   x = x^2&#13;
&gt;&gt;&gt;   if(x &gt; 10){&#13;
&gt;&gt;&gt;     break&#13;
&gt;&gt;&gt;  }&#13;
&gt;&gt;&gt;   print(x)&#13;
&gt;&gt;&gt; }&#13;
4</pre><p class="list-inset">Only one number is printed out this time. The reason is that when <strong class="source-inline">x</strong> is changed to <strong class="source-inline">16</strong>, the <strong class="source-inline">if</strong> condition evaluates to be <strong class="source-inline">TRUE</strong>, thus triggering the <strong class="source-inline">break</strong> statement to exit the <strong class="source-inline">while</strong> loop and ignore the <strong class="source-inline">print()</strong> statement. Let’s verify the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break">:</span></p><pre class="source-code">&gt;&gt;&gt; x&#13;
16</pre></li>			</ol>&#13;
			<p>Let’s look at the <strong class="source-inline">for</strong> loop, which assumes the following general structure. Here, <strong class="source-inline">var</strong> is a placement to sequentially reference the contents in <strong class="source-inline">sequence</strong>, which can be a vector, a list, or another <span class="No-Break">data structure:</span></p>&#13;
			<pre class="source-code">&#13;
for(var in sequence){&#13;
some expression&#13;
}</pre>			<p>The same <a id="_idIndexMarker107"/>expression will be evaluated for each unique variable in <strong class="source-inline">sequence</strong>, unless an explicit <strong class="source-inline">if</strong> condition is triggered to either exit the loop using <strong class="source-inline">break</strong>, or skip the rest of the code and immediately jump to the next iteration using <strong class="source-inline">next</strong>. Let’s go through an exercise to put these <span class="No-Break">in perspective.</span></p>&#13;
			<h3>Exercise 1.18 – practicing using the for loop</h3>&#13;
			<p>Next, let’s<a id="_idIndexMarker108"/> try<a id="_idIndexMarker109"/> the <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> loop:</span></p>&#13;
			<ol>&#13;
				<li>Create a vector to store three strings (<strong class="source-inline">statistics</strong>, <strong class="source-inline">and</strong>, and <strong class="source-inline">calculus</strong>) and print out <span class="No-Break">each element:</span><pre class="source-code">&#13;
&gt;&gt;&gt; string_a = c("statistics","and","calculus")&#13;
&gt;&gt;&gt; for(i in string_a){&#13;
&gt;&gt;&gt;   print(i)&#13;
&gt;&gt;&gt; }&#13;
"statistics"&#13;
"and"&#13;
"calculus"</pre><p class="list-inset">Here, the <strong class="source-inline">for</strong> loop iterates through each element in the <strong class="source-inline">string_a</strong> vector by sequentially assigning the element value to the <strong class="source-inline">i</strong> variable at each iteration. We can also choose to iterate using the vector index, <span class="No-Break">as follows:</span></p><pre class="source-code">&gt;&gt;&gt; for(i in 1:length(string_a)){&#13;
&gt;&gt;&gt;   print(string_a[i])&#13;
&gt;&gt;&gt; }&#13;
"statistics"&#13;
"and"&#13;
"calculus"</pre><p class="list-inset">Here, we<a id="_idIndexMarker110"/> created a series of integer indexes from <strong class="source-inline">1</strong> up to the length of the vector and assigned them to the <strong class="source-inline">i</strong> variable in each iteration, which is then used to reference the element in the <strong class="source-inline">string_a</strong> vector. This is a more<a id="_idIndexMarker111"/> flexible and versatile way of referencing elements in a vector since we can also use the same index to reference other vectors. Directly referencing the element as in the previous approach is more concise and readable. However, it lacks the level of control and flexibility without the <span class="No-Break">looping index.</span></p></li>				<li>Add a condition to break the loop if the current element <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">"and"</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; for(i in string_a){&#13;
&gt;&gt;&gt;   if(i == "and"){&#13;
&gt;&gt;&gt;     break&#13;
&gt;&gt;&gt;   }&#13;
&gt;&gt;&gt;   print(i)&#13;
&gt;&gt;&gt; }&#13;
"statistics"</pre><p class="list-inset">The loop is exited upon satisfying the <strong class="source-inline">if</strong> condition when the current value in <strong class="source-inline">i</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">"and"</strong></span><span class="No-Break">.</span></p></li>				<li>Add a condition to jump to the next iteration if the current element <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">"and"</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; for(i in string_a){&#13;
&gt;&gt;&gt;   if(i == "and"){&#13;
&gt;&gt;&gt;    next&#13;
&gt;&gt;&gt;   }&#13;
&gt;&gt;&gt;  print(i)&#13;
&gt;&gt;&gt; }&#13;
"statistics"&#13;
"calculus"</pre><p class="list-inset">When the<a id="_idIndexMarker112"/> next statement is evaluated, the following <strong class="source-inline">print()</strong> function<a id="_idIndexMarker113"/> is ignored, and the program jumps to the next iteration, printing only <strong class="source-inline">"statistics"</strong> and <strong class="source-inline">"calculus"</strong> with the <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">and"</strong></span><span class="No-Break"> element.</span></p></li>			</ol>&#13;
			<p>So far, we have covered some of the most fundamental building blocks in R. We are now ready to come to the last and most widely used building <span class="No-Break">block: functions.</span></p>&#13;
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Exploring functions in R</h1>&#13;
			<p>A <strong class="bold">function</strong> is a <a id="_idIndexMarker114"/>collection of statements in the form of an object that <a id="_idIndexMarker115"/>receives an (optional) input, completes a specific task, and (optionally) generates an output. We may or may not be interested in how a function achieves the task and produces the output. When we only care about utilizing an existing function, which could be built-in and provisioned by R itself or pre-written by someone else, we can treat it as a black box and pass the required input to obtain the output we want. Examples include the <strong class="source-inline">sum()</strong> and <strong class="source-inline">mean()</strong> functions we used in the previous exercise. We can also define our own function to operate as an interface that processes a given input signal and produces an output. See <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.9</em> for <span class="No-Break">an illustration:</span></p>&#13;
			<p class="IMG---Figure"> </p>&#13;
			<div>&#13;
				<div id="_idContainer016" class="IMG---Figure">&#13;
					<img src="Images/B18680_01_009..jpg" alt="Figure 1.9 – Illustration of a function’s workflow" width="1586" height="680"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Illustration of a function’s workflow</p>&#13;
			<p>A function <a id="_idIndexMarker116"/>can be created using the <strong class="source-inline">function</strong> keyword with the <span class="No-Break">following format:</span></p>&#13;
			<pre class="source-code">&#13;
function_name = function(argument_1, argument_2, …){&#13;
  some statements&#13;
}</pre>			<p>A function <a id="_idIndexMarker117"/>can be decomposed into the <span class="No-Break">following parts:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Function name</strong>: The name of the functional object registered and stored in the R environment. We use this name followed by a pair of parentheses and (optionally) input arguments within the parentheses to call <span class="No-Break">the function.</span></li>&#13;
				<li><strong class="bold">Input argument</strong>: A placeholder used to receive input value when calling the function. An argument can be optional (with a default value assigned) or compulsory (with no default value assigned). Setting all arguments as optional is the same as requiring no compulsory input arguments for the function. However, we will need to pass a specific value to a compulsory argument in order to call the function. In addition, the optional argument can also appear after the compulsory argument, <span class="No-Break">if any.</span></li>&#13;
				<li><strong class="bold">Function body</strong>: This <a id="_idIndexMarker118"/>is the area where the main statement is executed <a id="_idIndexMarker119"/>to complete a specific action and fulfill the purpose of <span class="No-Break">the function.</span></li>&#13;
				<li><strong class="bold">Return value</strong>: The last statement to be evaluated within the function body, usually explicitly wrapped within the <span class="No-Break"><strong class="source-inline">return()</strong></span><span class="No-Break"> function.</span></li>&#13;
			</ul>&#13;
			<p>Let’s go through an exercise on creating a <span class="No-Break">user-defined function.</span></p>&#13;
			<h3>Exercise 1.19 – creating a user-defined function</h3>&#13;
			<p>Now, let’s try <span class="No-Break">it out:</span></p>&#13;
			<ol>&#13;
				<li>Create a <a id="_idIndexMarker120"/>function named <strong class="source-inline">test_func</strong> to<a id="_idIndexMarker121"/> receive an input and print out <strong class="source-inline">"(input) is fun"</strong>. Allow the option to print the message <span class="No-Break">in uppercase:</span><pre class="source-code">&#13;
test_func = function(x, cap=FALSE){&#13;
  msg = paste(x,"is fun!")&#13;
  if(cap){&#13;
    msg = toupper(msg)&#13;
  }&#13;
  return(msg)&#13;
}</pre><p class="list-inset">Note that we used the <strong class="source-inline">=</strong> sign instead of <strong class="source-inline">&lt;-</strong> to assign the functional object to the <strong class="source-inline">test_func</strong> variable. However, the latter is more commonly observed when creating functions in R. In the input, we created two arguments: the compulsory argument, <strong class="source-inline">x</strong>, to receive the message to be printed, and the optional argument, <strong class="source-inline">cap</strong>, to determine whether the message needs to be converted into uppercase. The optional argument means that the user can either go with the default setting (that is, a lowercase message) by not supplying anything to this argument or overwrite the default behavior by explicitly passing in <span class="No-Break">a value.</span></p><p class="list-inset">In the <a id="_idIndexMarker122"/>function body, we first create a <strong class="source-inline">msg</strong> variable and assign the message content by calling the <strong class="source-inline">paste()</strong> function, a built-in function to concatenate the two input arguments. If the <strong class="source-inline">cap</strong> argument is <strong class="source-inline">FALSE</strong>, the <strong class="source-inline">if</strong> statement will evaluate to <strong class="source-inline">FALSE</strong> and <strong class="source-inline">msg</strong> will be directly returned as the function’s output. Otherwise, the statement within the <strong class="source-inline">if</strong> clause will be triggered to convert the <strong class="source-inline">msg</strong> variable into uppercase using the <strong class="source-inline">toupper()</strong> function, another built-in function <span class="No-Break">in R.</span></p></li>				<li>Let’s see what <a id="_idIndexMarker123"/>happens after calling the function in <span class="No-Break">different ways:</span><pre class="source-code">&#13;
&gt;&gt;&gt; test_func("r")&#13;
"r is fun!"&#13;
&gt;&gt;&gt; test_func("r",cap=TRUE)&#13;
"R IS FUN!"&#13;
&gt;&gt;&gt; test_func()&#13;
Error in paste(x, "is fun!") : argument "x" is missing, with no default</pre><p class="list-inset">The first two cases work as expected. In the third case, we did not supply any value to the <strong class="source-inline">x</strong> argument, defined as a compulsory argument. This leads to an error and fails to call <span class="No-Break">the function.</span></p></li>			</ol>&#13;
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Summary</h1>&#13;
			<p>In this chapter, we covered the essential building blocks in R, including how to leverage and navigate the RStudio IDE, basic arithmetic operations (addition, subtraction, multiplication, division, exponentiation, and modulo), common data structures (vectors, matrices, data frames, and lists), control logic, including relational operators (<strong class="source-inline">&gt;</strong>, <strong class="source-inline">==</strong>, <strong class="source-inline">&lt;</strong>, <strong class="source-inline">&gt;=</strong>, <strong class="source-inline">&lt;=</strong>, and <strong class="source-inline">!=</strong>) and logical operators (<strong class="source-inline">&amp;</strong>, <strong class="source-inline">|</strong>, <strong class="source-inline">!</strong>, <strong class="source-inline">&amp;&amp;</strong>, and <strong class="source-inline">||</strong>), conditional statements using <strong class="source-inline">ifelse</strong>, the <strong class="source-inline">for</strong> and <strong class="source-inline">while</strong> loops, and finally, functions in R. Understanding these fundamental aspects will greatly benefit our learning in later chapters as we gradually introduce more <span class="No-Break">challenging topics.</span></p>&#13;
			<p>In the next chapter, we will cover <strong class="source-inline">dplyr</strong>, one of the most widely used libraries for data processing and manipulation. Tapping into the various utility functions provided by <strong class="source-inline">dplyr</strong> will make it much easier to handle most data <span class="No-Break">processing tasks.</span></p>&#13;
		</div>&#13;
	</div></body></html>