["```py\nMat clone = image.clone(); \n```", "```py\nMat clone; \nimage.copyTo(clone); \n```", "```py\nMat A(1, 1, CV_32FC3), \n   B(1, 1, CV_32FC3); \n\nA.at<Vec3f>(0, 0)[0] = 0; \nA.at<Vec3f>(0, 0)[1] = 1; \nA.at<Vec3f>(0, 0)[2] = 2; \n\nB.at<Vec3f>(0, 0)[0] = 3; \nB.at<Vec3f>(0, 0)[1] = 4; \nB.at<Vec3f>(0, 0)[2] = 5; \n\nMat AxB = A.cross(B); \nMat BxA = B.cross(A);\n```", "```py\nint D = 0; // or +1, +2, -1, -2 and so on \nMat dg = image.diag(D); \n```", "```py\ndouble result = A.dot(B); \n```", "```py\nMat id = Mat::eye(10, 10, CV_32F); \n```", "```py\ndouble scale = 0.25; \nMat id = Mat::eye(10, 10, CV_32F) * scale; \n```", "```py\nMat inverted = m.inv(); \n```", "```py\nMat result = A.mul(B); \n```", "```py\ndouble scale = 0.75; \nMat result = A.mul(B, scale);\n```", "```py\nMat m1 = Mat::zeroes(240, 320, CV_8UC1); \nMat m2 = Mat::ones(240, 320, CV_8UC1); \n```", "```py\nMat white = Mat::ones(240, 320, CV_8UC1) * 255; \n```", "```py\nMat transpose = image.t(); \n```", "```py\ntranspose(mat, trp); \n```", "```py\nint ch = 1; \nint rows = 200; \nMat rshpd = image.reshape(ch, rows); \n```", "```py\nMat image = imread(\"Test.png\"); \nMat overlay = imread(\"Overlay.png\"); \nMat result; \nadd(image, overlay, result); \n```", "```py\nresult = image + overlay; \n```", "```py\nresult = image + 80; \n```", "```py\nresult = image + Vec3b(80, 80, 80); \n```", "```py\ndouble alpha = 1.0; // First image weight \ndouble beta = 0.30; // Second image weight \ndouble gamma = 0.0; // Added to the sum \naddWeighted(image, alpha, overlay, beta, gamma, result); \n```", "```py\nMat image = imread(\"Test.png\"); \nMat overlay = imread(\"Overlay.png\"); \nMat result; \nsubtract(image, overlay, result); \n```", "```py\nresult = image - overlay; \n```", "```py\nresult = image - 80;\n```", "```py\nresult = image - Vec3b(80, 80, 80); \n```", "```py\ndouble scale = 1.25; \nmultiply(imageA, imageB, result1, scale); \ndivide(imageA, imageB, result2, scale); \n```", "```py\nresultBrighter = image * 5; \nresultDarker = image / 5; \n```", "```py\nbitwise_not(image, result); \n```", "```py\nresult = ~image; \n```", "```py\nbitwise_and(image, mask, result); \n```", "```py\nresult = image & mask; \n```", "```py\nresult = image & Vec3b(0xFF, 0x00, 0xFF); \n```", "```py\nbitwise_or(image, mask, result);\n```", "```py\nresult = image | mask; \n```", "```py\nresult = image | Vec3b(0x00, 0xFF, 0x00); \n```", "```py\nbitwise_xor(image, mask, result); \n```", "```py\nresult = image ^ mask;\n```", "```py\ncompare(image1, image2, result, CMP_EQ); \n```", "```py\nresult = image1 == image2; // CMP_EQ \nresult = image1 > image2; // CMP_GT \nresult = image1 >= image2; // CMP_GE \nresult = image1 < image2; // CMP_LT \nresult = image1 <= image2; // CMP_LE \nresult = image1 != image2; // CMP_NE \n```", "```py\nMat lb = Mat::zeros(image.rows, \n                    image.cols, \n                    image.type()); \nMat hb = Mat::ones(image.rows, \n                   image.cols, \n                   image.type()) * 50; \ninRange(image, lb, hb, result); \n```", "```py\nmin(image1, image2, result); \n```", "```py\nmax(image1, image2, result); \n```", "```py\nabsdiff(image1, image2, result);\n```", "```py\nexp(mat, result); \n```", "```py\nlog(mat, result); \n```", "```py\npow(mat, 3.0, result); \n```", "```py\nsqrt(mat, result); \n```", "```py\nint top = 50; \nint bottom = 50; \nint left = 50; \nint right = 50; \nBorderTypes border = BORDER_REPLICATE; \ncopyMakeBorder(image, \n               result, \n               top, \n               bottom, \n               left, \n               right, \n               border); \n```", "```py\nint code = +1; \nflip(image, result, code);\n```", "```py\nRotateFlags rt = ROTATE_90_CLOCKWISE; \nrotate(image, result, rt); \n```", "```py\nMat channels[3] = {ch1, ch2, ch3}; \nmerge(channels, 3, result); \n```", "```py\nint idx = 2; \ninsertChannel(ch, image, idx); \n```", "```py\nMat channels[3]; \nsplit(image, channels); \n```", "```py\nint idx = 2; \nMat ch; \nextractChannel(image, ch, idx); \n```", "```py\nMat image = imread(\"Test.png\"); \nMat result(image.rows, image.cols, image.type()); \n\nvector<int> fromTo = {0,1, \n                      1,2, \n                      2,0}; \nmixChannels(image, result, fromTo); \n```", "```py\nDecompTypes dt = DECOMP_LU; \ninvert(image, result, dt); \n```", "```py\nMat image = imread(\"Test.png\"); \nMat result; \nScalar m = mean(image); \ncout << m[0] << endl; \ncout << m[1] << endl; \ncout << m[2] << endl; \n```", "```py\nScalar s = sum(image); \n```", "```py\nScalar m; \nScalar stdDev; \nmeanStdDev(image, m, stdDev); \n```", "```py\nint optRows = getOptimalDFTSize( image.rows ); \nint optCols = getOptimalDFTSize( image.cols ); \n\nMat resizedImg; \ncopyMakeBorder(image, \n               resizedImg, \n               0, \n               optRows - image.rows, \n               0, \n               optCols - image.cols, \n               BORDER_CONSTANT, \n               Scalar::all(0)); \n```", "```py\nvector<Mat> channels = {Mat_<float>(resizedImg), \n                   Mat::zeros(resizedImg.size(), CV_32F)}; \n\nMat complexImage; \nmerge(channels, complexImage); \n\ndft(complexImage, complexImage); \n```", "```py\nsplit(complexImage, channels); \n\nMat mag; \nmagnitude(channels[0], channels[1], mag); \n```", "```py\nmag += Scalar::all(1); \nlog(mag, mag); \n```", "```py\nnormalize(mag, mag, 0.0, 1.0, CV_MINMAX);\n```", "```py\nint cx = mag.cols/2; \nint cy = mag.rows/2; \n\nMat Q1(mag, Rect(0, 0, cx, cy)); \nMat Q2(mag, Rect(cx, 0, cx, cy)); \nMat Q3(mag, Rect(0, cy, cx, cy)); \nMat Q4(mag, Rect(cx, cy, cx, cy)); \n\nMat tmp; \nQ1.copyTo(tmp); \nQ4.copyTo(Q1); \ntmp.copyTo(Q4); \n\nQ2.copyTo(tmp); \nQ3.copyTo(Q2); \ntmp.copyTo(Q3); \n```", "```py\ndft(input, output, DFT_INVERSE); \n```", "```py\nidft(input, output); \n```", "```py\nrandn(rmat, mean, stddev); \n```", "```py\nrandu(rmat, lowBand, highBand);\n```", "```py\nrandShuffle(array); \n```", "```py\nMat image = imread(\"Test.png\", IMREAD_GRAYSCALE); \nMat result; \nvector<Point> idx; \nfindNonZero(image, idx); \nif(idx.size() > 0) \n    cout << idx[0].x << \",\" << idx[0].y << endl; \n```", "```py\nMat image = imread(\"Test.png\", IMREAD_GRAYSCALE); \nMat result; \nint nonZero = countNonZero(image); \nfloat white = float(nonZero) / float(image.total()); \nfloat black = 1.0 - white; \ncout << black << endl;\n```", "```py\ndouble minVal, maxVal; \nPoint minLoc, maxLoc; \nminMaxLoc(image, &minVal, &maxVal, &minLoc, &maxLoc); \n```", "```py\ndouble minVal, maxVal; \nint minIdx, maxIdx; \nminMaxIdx(image, &minVal, &maxVal, &minIdx, &maxIdx); \n```", "```py\nMat lut(1, 256, CV_8UC1); \nfor(int i=0; i<256; i++) \n{ \n    if(i < 125) \n        lut.at<uchar>(0, i) = 0; \n    else if(i > 175) \n        lut.at<uchar>(0, i) = 255; \n    else \n        lut.at<uchar>(0, i) = i; \n} \n\nMat result; \nLUT(image, lut, result); \n```"]