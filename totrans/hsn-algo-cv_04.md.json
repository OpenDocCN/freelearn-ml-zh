["```py\nstring text = \"www.amin-ahmadi.com\"; \nint offset = 25; \nPoint origin(offset, image.rows - offset); \nHersheyFonts fontFace = FONT_HERSHEY_COMPLEX; \ndouble fontScale = 1.5; \nScalar color(0, 242, 255); \nint thickness = 2; \nLineTypes lineType = LINE_AA; \nbool bottomLeftOrigin = false; \n\nputText(image, \n        text, \n        origin, \n        fontFace, \n        fontScale, \n        color, \n        thickness, \n        lineType, \n        bottomLeftOrigin); \n```", "```py\ndouble fontScale = getFontScaleFromHeight(fontFace, \n                           50, // pixels for height \n                           thickness); \n```", "```py\nint baseLine; \nSize size = getTextSize(\"Example\", \n                        FONT_HERSHEY_PLAIN, \n                        3.2, \n                        2, \n                        &baseLine); \n\ncout << \"Size = \" << size.width << \" , \" << size.height << endl; \ncout << \"Baseline = \" << baseLine << endl; \n```", "```py\nSize = 216 , 30 \nBaseline = 17 \n```", "```py\nPoint position(image.cols/2, \n               image.rows/2); \nScalar color = Scalar::all(0); \nMarkerTypes markerType = MARKER_CROSS; \nint markerSize = 25; \nint thickness = 2; \nint lineType = LINE_AA; \ndrawMarker(image, \n           position, \n           color, \n           markerType, \n           markerSize, \n           thickness, \n           lineType); \n```", "```py\nPoint pt1(25, image.rows/2); \nPoint pt2(image.cols/2 - 25, image.rows/2); \nScalar color = Scalar(0,255,0); \nint thickness = 5; \nint lineType = LINE_AA; \nint shift = 0; \n\nline(image, \n     pt1, \n     pt2, \n     color, \n     thickness, \n     lineType, \n     shift); \n```", "```py\ndouble tipLength = 0.2; \n\narrowedLine(image, \n            pt1, \n            pt2, \n            color, \n            thickness, \n            lineType, \n            shift, \n            tipLength); \n```", "```py\nPoint center(image.cols/2, \n             image.rows/2); \nint radius = 200; \ncircle(image, \n       center, \n       radius, \n       color, \n       thickness, \n       lineType, \n       shift); \n```", "```py\nrectangle(image, \n          pt1, \n          pt2, \n          color, \n          thickness, \n          lineType, \n          shift); \n```", "```py\nRect rect(pt1,pt2); \nrectangle(image, \n          color, \n          thickness, \n          lineType, \n          shift); \n```", "```py\nSize axes(200, 100); \ndouble angle = 20.0; \ndouble startAngle = 0.0; \ndouble endAngle = 360.0; \nellipse(image, \n        center, \n        axes, \n        angle, \n        startAngle, \n        endAngle, \n        color, \n        thickness, \n        lineType, \n        shift);\n```", "```py\nSize size(150, 300); \ndouble angle = 45.0; \nRotatedRect rotRect(center, \n                    axes, \n                    angle); \nellipse(image, \n        rotRect, \n        color, \n        thickness, \n        lineType); \n```", "```py\nvector<Point> pts; \npts.push_back(Point(100, 100)); \npts.push_back(Point(50, 150)); \npts.push_back(Point(50, 200)); \npts.push_back(Point(150, 200)); \npts.push_back(Point(150, 150)); \nbool isClosed = true; \npolylines(image, \n          pts, \n          isClosed, \n          color, \n          thickness, \n          lineType, \n          shift); \n```", "```py\nstring window = \"Image\"; // Title of the image output window\nstring trackbar = \"Radius\"; // Label of the trackbar\nMat image = imread(\"Test.png\"); \nPoint center(image.cols/2, image.rows/2); // A Point object that points to the center of the image\nint radius = 25;\nScalar color = Scalar(0, 255, 0); // Green color in BGR (OpenCV default) color space\nint thickness = 2; LineTypes lineType = LINE_AA; int shift = 0; \n\n// Actual callback function where drawing and displaying happens\nvoid drawCircle(int, void*) \n{ \n    Mat temp = image.clone(); \n\n    circle(temp, \n           center, \n           radius, \n           color, \n           thickness, \n           lineType, \n           shift); \n\n    imshow(window, temp); \n} \n\nint main() \n{     \n    namedWindow(window); // create a window titled \"Image\" (see above)\n\n    createTrackbar(trackbar, // label of the trackbar\n                   window, // label of the window of the trackbar\n                   &radius, // the value that'll be changed by the trackbar\n                   min(image.rows, image.cols) / 2, // maximum accepted value\n                   drawCircle); \n\n    setTrackbarMin(trackbar, window, 25); // set min accespted value by trackbar\n    setTrackbarMax(trackbar, window, min(image.rows, image.cols) / 2); // set max again\n\n    drawCircle(0,0); // call the callback function and wait\n    waitKey(); \n\n    return 0; \n} \n```", "```py\nint ksize = 5; // must be odd \nmedianBlur(image, result, ksize); \n```", "```py\nint ddepth = -1; \nSize ksize(7,7); \nPoint anchor(-1, -1); \nbool normalize = true; \nBorderTypes borderType = BORDER_DEFAULT; \n\nboxFilter(image, \n          result, \n          ddepth, \n          ksize, \n          anchor, \n          normalize, \n          borderType); \n```", "```py\nSize ksize(7,7); \nPoint anchor(-1, -1); \nBorderTypes borderType = BORDER_DEFAULT; \n\nblur(image, \n     result, \n     ksize, \n     anchor, \n     borderType); \n```", "```py\nint ddepth = -1; \nSize ksize(7,7); \nPoint anchor(-1, -1); \nbool normalize = true; \nBorderTypes borderType = BORDER_DEFAULT; \n\nsqrBoxFilter(image, \n             result, \n             ddepth, \n             ksize, \n             anchor, \n             normalize, \n             borderType); \n```", "```py\nSize ksize(7,7); \ndouble sigmaX = 1.25; \ndouble sigmaY = 0.0; \nBorderTypes borderType = BORDER_DEFAULT; \n\nGaussianBlur(image, \n             result, \n             ksize, \n             sigmaX, \n             sigmaY, \n             borderType); \n```", "```py\nint d = 9; \ndouble sigmaColor = 250.0; \ndouble sigmaSpace = 200.0; \nBorderTypes borderType = BORDER_DEFAULT; \n\nbilateralFilter(image, \n                result, \n                d, \n                sigmaColor, \n                sigmaSpace, \n                borderType); \n```", "```py\nMorphTypes op = MORPH_ERODE; \nMorphShapes shape = MORPH_RECT; \nSize ksize(3,3); \nPoint anchor(-1, -1); \nMat kernel = getStructuringElement(shape, \n                                   ksize, \n                                   anchor); \nint iterations = 3; \nBorderTypes borderType = BORDER_CONSTANT; \nScalar borderValue = morphologyDefaultBorderValue(); \nmorphologyEx(image, \n             result, \n             op, \n             kernel, \n             anchor, \n             iterations, \n             borderType, \n             borderValue); \n```", "```py\nint ddepth = -1; \nint dx = 1; \nint dy = 1; \nint ksize = 5; \ndouble scale = 0.3; \ndouble delta = 0.0; \n\nBorderTypes borderType = BORDER_DEFAULT; \nSobel(image, \n      result, \n      ddepth, \n      dx, \n      dy, \n      ksize, \n      scale, \n      delta, \n      borderType); \n```", "```py\nMat resultDX, resultDY; \nint ksize = 3; \nBorderTypes borderType = BORDER_DEFAULT; \nspatialGradient(image, \n                resultDX, \n                resultDY, \n                ksize, \n                borderType); \n```", "```py\nint ddepth = -1; \nint ksize = 3; \ndouble scale = 1.0; \ndouble delta = 0.0; \nBorderTypes borderType = BORDER_DEFAULT; \nLaplacian(image, \n          result, \n          ddepth, \n          ksize, \n          scale, \n          delta, \n          borderType); \n```", "```py\nint ddepth = -1; \nMat kernel{+1, -1, +1, \n           -1, +2, -1, \n           +1, -1, +1}; \nPoint anchor(-1, -1); \ndouble delta = 0.0; \nBorderTypes borderType = BORDER_DEFAULT; \nfilter2D(image, \n         result, \n         ddepth, \n         kernel, \n         anchor, \n         delta, \n         borderType); \n```", "```py\ndouble thresh = 175.0; \ndouble maxval = 255.0; \nThresholdTypes type = THRESH_BINARY; \nthreshold(image, \n          result, \n          thresh, \n          maxval, \n          type); \n```", "```py\ndouble maxValue = 255.0; \nAdaptiveThresholdTypes adaptiveMethod =  \n                             ADAPTIVE_THRESH_GAUSSIAN_C; \nThresholdTypes thresholdType = THRESH_BINARY; \nint blockSize = 5; \ndouble c = 0.0; \nadaptiveThreshold(image, \n                  result, \n                  maxValue, \n                  adaptiveMethod, \n                  thresholdType, \n                  blockSize, \n                  c); \n```", "```py\nColorConversionCodes code = COLOR_RGB2GRAY; \ncvtColor(image, \n         result, \n         code); \n```", "```py\nSize dsize(0, 0); \ndouble fx = 1.8; \ndouble fy = 0.3; \nInterpolationFlags interpolation = INTER_CUBIC; \nresize(image, \n       result, \n       dsize, \n       fx, \n       fy, \n       interpolation); \n```", "```py\nMat mapX(image.size(), CV_32FC1); \nMat mapY(image.size(), CV_32FC1); \n// Create maps here... \nInterpolationFlags interpolation = INTER_CUBIC; \nBorderTypes borderMode = BORDER_CONSTANT; \nScalar borderValue = Scalar(0, 0, 0); \nremap(image, \n      result, \n      mapX, \n      mapY, \n      interpolation, \n      borderMode, \n      borderValue); \n```", "```py\nfor(int i=0; i<image.rows; i++) \n    for(int j=0; j<image.cols; j++) \n    { \n        mapX.at<float>(i,j) = j; \n        mapY.at<float>(i,j) = image.rows-i; \n    } \n```", "```py\nmapX.at<float>(i,j) = image.cols - j; \nmapY.at<float>(i,j) = i; \n```", "```py\nPoint2f center(image.cols/2,image.rows/2); \nfor(int i=0; i<image.rows; i++) \n    for(int j=0; j<image.cols; j++) \n    { \n        // find i,j in the standard coordinates \n        double x = j - center.x; \n        double y = i - center.y; \n\n        // Perform any mapping for X and Y \n        x = x*x/750; \n        y = y; \n\n        // convert back to image coordinates \n        mapX.at<float>(i,j) = x + center.x; \n        mapY.at<float>(i,j) = y + center.y; \n    } \n```", "```py\nColormapTypes colormap = COLORMAP_JET; \napplyColorMap(image, \n              result, \n              colormap); \n```", "```py\nMat userColor(256, 1, CV_8UC3); \nfor(int i=0; i<=255; i++) \n    userColor.at<Vec3b>(i,0) = Vec3b(i, 255-i, i); \napplyColorMap(image, \n              result, \n              userColor); \n```"]