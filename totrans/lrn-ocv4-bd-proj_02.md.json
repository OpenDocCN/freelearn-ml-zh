["```py\ncmake_minimum_required (VERSION 3.0) \nproject (CMakeTest) \nadd_executable(${PROJECT_NAME} main.cpp) \n```", "```py\n# Create our hello library \n    add_library(Hello hello.cpp hello.h) \n\n# Create our application that uses our new library \n    add_executable(executable main.cpp) \n\n# Link our executable with the new library \n    target_link_libraries(executable Hello) \n```", "```py\n    cmake_minimum_required (VERSION 3.0) \n    PROJECT(Chapter2) \n# Requires OpenCV \n    FIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) \n# Show a message with the opencv version detected \n    MESSAGE(\"OpenCV version : ${OpenCV_VERSION}\") \n# Add the paths to the include directories/to the header files\n    include_directories(${OpenCV_INCLUDE_DIRS}) \n# Add the paths to the compiled libraries/objects\n    link_directories(${OpenCV_LIB_DIR}) \n# Create a variable called SRC \n    SET(SRC main.cpp) \n# Create our executable \n    ADD_EXECUTABLE(${PROJECT_NAME} ${SRC}) \n# Link our library \n    TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS})\n```", "```py\ncmake_minimum_required (VERSION 3.0) \ncmake_policy(SET CMP0012 NEW) \nPROJECT(Chapter2) \n```", "```py\n# Requires OpenCV \n    FIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) \n# Show a message with the opencv version detected \n    MESSAGE(\"OpenCV version : ${OpenCV_VERSION}\") \n    include_directories(${OpenCV_INCLUDE_DIRS}) \n    link_directories(${OpenCV_LIB_DIR})\n```", "```py\nOpenCV version : 4.0.0\n```", "```py\n# Create a variable called SRC \n    SET(SRC main.cpp) \n# Create our executable \n    ADD_EXECUTABLE(${PROJECT_NAME} ${SRC}) \n# Link our library \n    TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS}) \n```", "```py\nSET(SRC main.cpp \n        utils.cpp \n        color.cpp\n)\n```", "```py\nCMakeLists.txt \nmain.cpp \nutils/ \n   CMakeLists.txt \n   computeTime.cpp \n   computeTime.h \n   logger.cpp \n   logger.h \n   plotting.cpp \n   plotting.h \n```", "```py\n    cmake_minimum_required (VERSION 3.0) \n    project (Chapter2) \n\n# Opencv Package required \n    FIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) \n\n#Add opencv header files to project \n    include_directories(${OpenCV_INCLUDE_DIR}) \n    link_directories(${OpenCV_LIB_DIR}) \n\n# Add a subdirectory to the build. \n    add_subdirectory(utils)\n\n# Add optional log with a precompiler definition \n    option(WITH_LOG \"Build with output logs and images in tmp\" OFF) \n    if(WITH_LOG) \n       add_definitions(-DLOG) \n    endif(WITH_LOG) \n\n# generate our new executable \n    add_executable(${PROJECT_NAME} main.cpp) \n# link the project with his dependencies \n    target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS} Utils) \n```", "```py\n# Add new variable for src utils lib \n    SET(UTILS_LIB_SRC \n       computeTime.cpp  \n       logger.cpp  \n       plotting.cpp \n    ) \n# create our new utils lib \n    add_library(Utils ${UTILS_LIB_SRC}) \n# make sure the compiler can find include files for our library \n    target_include_directories(Utils PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}) \n```", "```py\n#ifdef LOG \n    logi(\"Number of iteration %d\", i); \n#endif \n```", "```py\nif(WITH_LOG) \n   add_definitions(-DLOG) \nendif(WITH_LOG) \n```", "```py\nValue= Row_i*num_cols*num_channels + Col_i + channel_i \n```", "```py\n#include <iostream> \n#include <string> \n#include <sstream> \nusing namespace std; \n\n// OpenCV includes \n#include \"opencv2/core.hpp\" \n#include \"opencv2/highgui.hpp\" \nusing namespace cv; \n\nint main(int argc, const char** argv) \n{ \n   // Read images \n   Mat color= imread(\"../lena.jpg\"); \n   Mat gray= imread(\"../lena.jpg\",CV_LOAD_IMAGE_GRAYSCALE); \n\n  if(! color.data ) // Check for invalid input\n {\n cout << \"Could not open or find the image\" << std::endl ;\n return -1;\n }\n   // Write images \n   imwrite(\"lenaGray.jpg\", gray); \n\n   // Get same pixel with opencv function \n   int myRow=color.cols-1; \n   int myCol=color.rows-1; \n   Vec3b pixel= color.at<Vec3b>(myRow, myCol); \n   cout << \"Pixel value (B,G,R): (\" << (int)pixel[0] << \",\" << (int)pixel[1] << \",\" << (int)pixel[2] << \")\" << endl; \n\n   // show images \n   imshow(\"Lena BGR\", color); \n   imshow(\"Lena Gray\", gray); \n   // wait for any key press \n   waitKey(0); \n   return 0; \n} \n\n```", "```py\n// OpenCV includes \n#include \"opencv2/core.hpp\" \n#include \"opencv2/highgui.hpp\" \nusing namespace cv; \n```", "```py\n// Read images \nMat color= imread(\"../lena.jpg\"); \nMat gray= imread(\"../lena.jpg\",CV_LOAD_IMAGE_GRAYSCALE); \n```", "```py\n// Write images \nimwrite(\"lenaGray.jpg\", gray); \n```", "```py\n// Get same pixel with opencv function \nint myRow=color.cols-1; \nint myCol=color.rows-1;\n```", "```py\nVec3b pixel= color.at<Vec3b>(myRow, myCol); \ncout << \"Pixel value (B,G,R): (\" << (int)pixel[0] << \",\" << (int)pixel[1] << \",\" << (int)pixel[2] << \")\" << endl; \n```", "```py\n// show images \nimshow(\"Lena BGR\", color); \nimshow(\"Lena Gray\", gray); \n// wait for any key press \nwaitKey(0); \n```", "```py\ncmake_minimum_required (VERSION 3.0) \ncmake_policy(SET CMP0012 NEW) \nPROJECT(project) \n\n# Requires OpenCV \nFIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) \nMESSAGE(\"OpenCV version : ${OpenCV_VERSION}\") \n\ninclude_directories(${OpenCV_INCLUDE_DIRS}) \nlink_directories(${OpenCV_LIB_DIR}) \n\nADD_EXECUTABLE(sample main.cpp) \nTARGET_LINK_LIBRARIES(sample ${OpenCV_LIBS})\n```", "```py\n// OpenCV command line parser functions \n// Keys accepted by command line parser \nconst char* keys = \n{ \n   \"{help h usage ? | | print this message}\" \n    \"{@video | | Video file, if not defined try to use webcamera}\" \n}; \n```", "```py\n\"{name_param | default_value | description}\"\n```", "```py\nCommandLineParser parser(argc, argv, keys);\n```", "```py\n//If requires help show \nif (parser.has(\"help\")) \n{ \n       parser.printMessage(); \n       return 0; \n} \n```", "```py\n   String videoFile= parser.get<String>(0);\n```", "```py\n   // Check if params are correctly parsed in his variables \n   if (!parser.check()) \n   { \n       parser.printErrors(); \n       return 0; \n   } \n```", "```py\nVideoCapture cap; // open the default camera \nif(videoFile != \"\") \n   cap.open(videoFile); \nelse \n   cap.open(0); \nif(!cap.isOpened())  // check if we succeeded \n   return -1;  \n```", "```py\nnamedWindow(\"Video\",1); \nfor(;;) \n{ \n    Mat frame; \n    cap >> frame; // get a new frame from camera \n    if(frame) \n       imshow(\"Video\", frame); \n    if(waitKey(30) >= 0) break; \n} \n// Release the camera or video cap \ncap.release(); \n```", "```py\nVec<double,19> myVector; \n```", "```py\ntypedef Vec<uchar, 2> Vec2b; \ntypedef Vec<uchar, 3> Vec3b; \ntypedef Vec<uchar, 4> Vec4b; \n\ntypedef Vec<short, 2> Vec2s; \ntypedef Vec<short, 3> Vec3s; \ntypedef Vec<short, 4> Vec4s; \n\ntypedef Vec<int, 2> Vec2i; \ntypedef Vec<int, 3> Vec3i; \ntypedef Vec<int, 4> Vec4i; \n\ntypedef Vec<float, 2> Vec2f; \ntypedef Vec<float, 3> Vec3f; \ntypedef Vec<float, 4> Vec4f; \ntypedef Vec<float, 6> Vec6f; \n\ntypedef Vec<double, 2> Vec2d; \ntypedef Vec<double, 3> Vec3d; \ntypedef Vec<double, 4> Vec4d; \ntypedef Vec<double, 6> Vec6d; \n\n```", "```py\nScalar s0(0);\nScalar s1(0.0, 1.0, 2.0, 3.0);\nScalar s2(s1);\n```", "```py\ntypedef Point_<int> Point2i; \ntypedef Point2i Point; \ntypedef Point_<float> Point2f; \ntypedef Point_<double> Point2d; \n The following operators are defined for points:\n    pt1 = pt2 + pt3; \n    pt1 = pt2 - pt3; \n    pt1 = pt2 * a; \n    pt1 = a * pt2; \n    pt1 = pt2 / a; \n    pt1 += pt2; \n    pt1 -= pt2; \n    pt1 *= a; \n    pt1 /= a; \n    double value = norm(pt); // L2 norm \n    pt1 == pt2; \n    pt1 != pt2; \n```", "```py\nSize s(100,100);\nMat img=Mat::zeros(s, CV_8UC1); // 100 by 100 single channel matrix\ns.width= 200;\nint area= s.area(); returns 100x200\n```", "```py\nMat img=imread(\"lena.jpg\");\nRect rect_roi(0,0,100,100);\nMat img_roi=img(r);\n```", "```py\nRotatedRect(const Point2f& center, const Size2f& size, float angle); \n```", "```py\nMat a= Mat(Size(5,5), CV_32F); \n```", "```py\nCV_8UC1 \nCV_8UC3 \nCV_8UC4 \nCV_32FC1 \nCV_32FC3 \nCV_32FC4\n```", "```py\nMat mz= Mat::zeros(5,5, CV_32F); \nMat mo= Mat::ones(5,5, CV_32F); \n```", "```py\nMat m= Mat::eye(5,5, CV_32F); \n```", "```py\nMat a= Mat::eye(Size(3,2), CV_32F); \nMat b= Mat::ones(Size(3,2), CV_32F); \nMat c= a+b; \nMat d= a-b;\n```", "```py\nMat m1= Mat::eye(2,3, CV_32F); \nMat m2= Mat::ones(3,2, CV_32F); \n// Scalar by matrix \ncout << \"nm1.*2n\" << m1*2 << endl; \n// matrix per element multiplication \ncout << \"n(m1+2).*(m1+3)n\" << (m1+1).mul(m1+3) << endl; \n// Matrix multiplication \ncout << \"nm1*m2n\" << m1*m2 << endl; \n```", "```py\nint countNonZero(src); \n```", "```py\nmeanStdDev(src, mean, stddev); \n```", "```py\nminMaxLoc(src, minVal, maxVal, minLoc, maxLoc); \n```", "```py\n#include \"opencv2/opencv.hpp\" \nusing namespace cv; \n\nint main(int, char** argv) \n{ \n   // create our writer \n    FileStorage fs(\"test.yml\", FileStorage::WRITE); \n    // Save an int \n    int fps= 5; \n    fs << \"fps\" << fps; \n    // Create some mat sample \n    Mat m1= Mat::eye(2,3, CV_32F); \n    Mat m2= Mat::ones(3,2, CV_32F); \n    Mat result= (m1+1).mul(m1+3); \n    // write the result \n    fs << \"Result\" << result; \n    // release the file \n    fs.release(); \n\n    FileStorage fs2(\"test.yml\", FileStorage::READ); \n\n    Mat r; \n    fs2[\"Result\"] >> r; \n    std::cout << r << std::endl; \n\n    fs2.release(); \n\n    return 0; \n} \n```", "```py\nFileStorage fs(\"test.yml\", FileStorage::WRITE); \n```", "```py\nint fps= 5; \nfs << \"fps\" << fps; \n```", "```py\nMat m1= Mat::eye(2,3, CV_32F); \nMat m2= Mat::ones(3,2, CV_32F); \nMat result= (m1+1).mul(m1+3); \n// write the result \nfs << \"Result\" << result;\n```", "```py\n%YAML:1.0 \nfps: 5 \nResult: !!opencv-matrix \n   rows: 2 \n   cols: 3 \n   dt: f \n   data: [ 8., 3., 3., 3., 8., 3\\. ] \n```", "```py\n#include \"opencv2/opencv.hpp\" \nusing namespace cv; \n\nint main(int, char** argv) \n{ \n   FileStorage fs2(\"test.yml\", FileStorage::READ); \n\n   Mat r; \n   fs2[\"Result\"] >> r; \n   std::cout << r << std::endl; \n\n   fs2.release(); \n\n   return 0; \n} \n```", "```py\nFileStorage fs2(\"test.yml\", FileStorage::READ); \n```", "```py\nMat r; \nfs2[\"Result\"] >> r; \n```"]