- en: 'Chapter 11: Deploying Models with Flask Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章：使用 Flask 应用程序部署模型
- en: Over the course of this book, we explored the development of numerous robust
    machine learning models in areas such as breast cancer detection, scientific topic
    modeling, protein classification, and molecular property prediction. In each of
    these tutorials, we prepared and validated our models to allow them to have the
    best predictive power possible. We will now pivot from the development of new
    models to the deployment of trained models to our end users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们探讨了在乳腺癌检测、科学主题建模、蛋白质分类和分子性质预测等领域开发众多稳健的机器学习模型。在这些教程中，我们准备并验证了我们的模型，以便它们具有尽可能强的预测能力。现在，我们将从开发新模型转向将训练好的模型部署给最终用户。
- en: 'Within this chapter, we will explore one of the most popular frameworks for
    the preparation of web applications: **Flask**. We will use Flask to prepare a
    web application to serve our models to end users, and we will also prepare an
    **Application Programming Interface** (**API**) to serve our predictions to other
    web applications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨用于准备 Web 应用程序的最受欢迎的框架之一：**Flask**。我们将使用 Flask 准备一个 Web 应用程序，向最终用户提供我们的模型，我们还将准备一个
    **应用程序编程接口**（**API**）来向其他 Web 应用程序提供我们的预测。
- en: 'Over the course of this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding API frameworks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 API 框架
- en: Working with Flask and Visual Studio Code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flask 和 Visual Studio Code 进行工作
- en: Using Flask as an API and web application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Flask 用作 API 和 Web 应用程序
- en: Tutorial – Deploying a pretrained model using Flask
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程 – 使用 Flask 部署预训练模型
- en: With these objectives in mind, let's go ahead and get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些目标，让我们开始吧！
- en: Understanding API frameworks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 API 框架
- en: 'Whether you are logging in to your email account, scrolling through social
    media, or even logging in to an online retailer, we use **web applications** on
    a daily basis to accomplish a variety of tasks. For example, imagine a user scrolling
    through an electronic laboratory notebook on their local computer. When the user
    logs in and sees their data, this information is retrieved using an API (that
    is, an *application programming interface*, not to be confused with an *active
    pharmaceutical ingredient*). Once the data is retrieved for the user in the backend,
    it populates the frontend in a beautiful **User Interface** (**UI**) that allows
    the user to interact with the data, make changes, and save it. We can use web
    applications and APIs in a variety of ways, such as transferring data, communicating
    with others, or even making predictions, as illustrated in *Figure 11.1*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在登录您的电子邮件账户、浏览社交媒体，还是登录在线零售商，我们每天都在使用 **Web 应用程序** 来完成各种任务。例如，想象一个用户在他们的本地计算机上滚动查看电子实验室笔记。当用户登录并看到他们的数据时，这些信息是通过
    API（即应用程序编程接口，不要与活性药物成分混淆）检索的。一旦在后台为用户检索到数据，它就会在前端以美观的 **用户界面**（**UI**）中填充，使用户能够与数据交互、进行更改并保存它。我们可以以各种方式使用
    Web 应用程序和 API，例如传输数据、与他人沟通，甚至进行预测，如图 *11.1* 所示：
- en: '![Figure 11.1 – Some examples of web application functionality ](img/B17761_11_001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 一些 Web 应用程序功能的示例](img/B17761_11_001.jpg)'
- en: Figure 11.1 – Some examples of web application functionality
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 一些 Web 应用程序功能的示例
- en: 'With all of these capabilities, APIs and their counterparts have provided the
    main tool in the web application space for creating UIs to serve data and make
    predictions. There are a number of useful **web application frameworks** available
    for a range of programming languages, as illustrated in *Figure 11.2*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 带着所有这些功能，API 和它们的对应物为 Web 应用程序空间提供了创建 UI 以服务数据和进行预测的主要工具。如图 *11.2* 所示，有多个有用的
    **Web 应用程序框架** 可用于各种编程语言：
- en: '![Figure 11.2 – Some examples of web application frameworks ](img/B17761_11_002.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 一些 Web 应用程序框架的示例](img/B17761_11_002.jpg)'
- en: Figure 11.2 – Some examples of web application frameworks
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 一些 Web 应用程序框架的示例
- en: 'For the purposes of this chapter, we will focus on one of the more popular
    machine learning deployment frameworks: Flask ([https://github.com/pallets/flask](https://github.com/pallets/flask)).
    Relative to its counterparts, Flask can be thought of as a **micro web framework**
    – it is completely written in Python and highly abstracted, allowing users to
    get started in the model deployment process with little to no difficulties.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将关注更受欢迎的机器学习部署框架之一：Flask ([https://github.com/pallets/flask](https://github.com/pallets/flask))。与它的类似框架相比，Flask
    可以被视为一个 **微 Web 框架**——它完全用 Python 编写，高度抽象，使用户能够轻松开始模型部署过程。
- en: 'As we begin to deploy models using the Flask framework, it is important to
    ask ourselves who the end user of our application will be. In many cases, predictions
    using our previously trained models will be conducted by colleagues and stakeholders.
    Therefore, having a useable UI will be important. On the other hand, our deployed
    models may not be needed by a person but rather a piece of software or another
    web application that will need to programmatically interact with it. In that case,
    a UI will not be needed – however, we will need an organized way (for example,
    **JSON**) to handle the transfer of data between the two systems. We can see a
    depiction of these two cases in *Figure 11.3*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 Flask 框架部署模型时，重要的是要问自己我们的应用程序的最终用户是谁。在许多情况下，使用我们之前训练的模型进行预测将由同事和利益相关者完成。因此，拥有一个可用的
    UI 将非常重要。另一方面，我们的部署模型可能不需要个人，而是需要软件或另一个需要以编程方式与之交互的 Web 应用程序。在这种情况下，UI 将不是必需的——然而，我们需要一种有组织的方式（例如，**JSON**）来处理两个系统之间的数据传输。我们可以在
    *图 11.3* 中看到这两个案例的描述：
- en: '![Figure 11.3 – The two general types of web applications ](img/B17761_11_003.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 两种常见的 Web 应用类型](img/B17761_11_003.jpg)'
- en: Figure 11.3 – The two general types of web applications
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 两种常见的 Web 应用类型
- en: 'In either case, we will be able to accommodate both of these cases using Flask.
    The Flask framework offers a variety of architectures – both simple and complex
    – allowing users to select the pattern that best fits their needs. Flask APIs,
    in a similar way to their counterparts such as **Django**, **Node.js**, and **Spring**,
    all generally operate in a similar manner using URLs. For both backend APIs and
    frontend UIs, we can use URLs to organize how we develop an application. For example,
    users can log in to a website to view and edit data within their profiles, whereas
    APIs can allow external entities to interact with models, as depicted in *Figure
    11.4*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们都可以使用 Flask 来适应这两种情况。Flask 框架提供了各种架构——既简单又复杂——使用户能够选择最适合他们需求的模式。与 **Django**、**Node.js**
    和 **Spring** 等类似框架一样，Flask API 通常使用 URL 以类似的方式运行。对于后端 API 和前端 UI，我们可以使用 URL 来组织我们开发应用程序的方式。例如，用户可以登录网站查看和编辑其个人资料中的数据，而
    API 可以允许外部实体与模型交互，如图 *11.4* 所示：
- en: '![Figure 11.4 – The two general types of web applications with examples ](img/B17761_11_004.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 带示例的两种常见的 Web 应用类型](img/B17761_11_004.jpg)'
- en: Figure 11.4 – The two general types of web applications with examples
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 带示例的两种常见的 Web 应用类型
- en: 'In order to interact with a web application, a user needs to make what is known
    as an **HTTP request**, which is usually carried out without them knowing. Each
    of these requests is generally associated with a URL, allowing the user to accomplish
    a task. The four HTTP request types are depicted in *Figure 11.5*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 Web 应用程序交互，用户需要发起一个被称为 **HTTP 请求** 的操作，这通常是在用户不知情的情况下完成的。每个请求通常都与一个 URL
    相关联，使用户能够完成任务。四种 HTTP 请求类型如图 *11.5* 所示：
- en: '![Figure 11.5 – The four HTTP request types ](img/B17761_11_005.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 四种 HTTP 请求类型](img/B17761_11_005.jpg)'
- en: Figure 11.5 – The four HTTP request types
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 四种 HTTP 请求类型
- en: For example, if a user navigating to `www.website.com/profile` intends to retrieve
    the details of their profile, they would use a `GET` request. On the other hand,
    an application using the API with the intention of classifying a segment of text
    would use a `POST` request to send the text to [www.website.com/api/classify](http://www.website.com/api/classify).
    These URL paths are known as *routes* within the confines of web applications,
    and they allow developers and data scientists to better organize their models
    for deployment. In the following section, we will see how routes can be used more
    specifically within the Flask framework.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个用户导航到 `www.website.com/profile` 并意图检索其个人资料详情，他们将使用一个 `GET` 请求。另一方面，一个使用
    API 并意图对文本片段进行分类的应用程序将使用 `POST` 请求将文本发送到 [www.website.com/api/classify](http://www.website.com/api/classify)。这些
    URL 路径在 Web 应用程序范围内被称为 *路由*，它们允许开发者和数据科学家更好地组织他们的模型以进行部署。在下一节中，我们将看到如何在 Flask
    框架中更具体地使用路由。
- en: Working with Flask and Visual Studio Code
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flask 和 Visual Studio Code 进行工作
- en: Flask is one of the most commonly used and versatile web applications available
    in the **Python** language. Its abstract and **high-level framework** makes it
    easy for users of all levels to have an implementation up and running in no time.
    Over the course of this section, we will learn about the different components
    of a Flask application and deploy a simple model locally on our machine.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 是在 **Python** 语言中最常用且功能最丰富的 Web 应用程序之一。其抽象和 **高级框架** 使得所有级别的用户都能在短时间内快速实现。在本节的整个过程中，我们将了解
    Flask 应用程序的不同组件，并在我们的机器上本地部署一个简单的模型。
- en: Before we can get started with Flask, we will need an **Integrated Development
    Environment** (**IDE**) to work with. So far, we have worked almost exclusively
    in **Jupyter Notebook** to train and develop models. When it comes to implementation,
    we will need another type of IDE to work with. There are numerous Python IDEs
    we can use, such as **PyCharm**, **Spyder**, or **Visual Studio** **Code** (**VSC**).
    I personally have found VSC to be the most user-friendly to work with, and therefore,
    we will use that as our primary IDE in this section. You can download VSC from
    their website ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))
    or by using **Anaconda**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Flask 之前，我们需要一个 **集成开发环境** (**IDE**) 来进行工作。到目前为止，我们几乎一直在 **Jupyter Notebook**
    中训练和开发模型。当涉及到实现时，我们需要另一种类型的 IDE 来进行工作。我们可以使用许多 Python IDE，例如 **PyCharm**、**Spyder**
    或 **Visual Studio** **代码** (**VSC**)。我个人发现 VSC 是最易于使用的，因此在本节中我们将使用它作为我们的主要 IDE。您可以从他们的网站
    ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))
    或使用 **Anaconda** 下载 VSC。
- en: 'Go ahead and begin the installation process, which might take a few minutes.
    While you wait, create a new folder called `flask-test` on your local computer.
    Once the installation process is complete, open VSC. You can open the folder you
    just created in a few simple steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 开始安装过程，这可能需要几分钟。在等待的同时，在您的本地计算机上创建一个名为 `flask-test` 的新文件夹。一旦安装过程完成，打开 VSC。您可以通过几个简单的步骤打开您刚刚创建的文件夹：
- en: Click **File** on the top menu.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部菜单中的 **文件**。
- en: Click **Open Folder**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **打开文件夹**。
- en: Navigate to your directory and click **Select Folder**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您的目录并点击 **选择文件夹**。
- en: You should now see the name of your directory in the `app.py` by right-clicking
    in the explorer pane and selecting **New File**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该能在资源管理器窗格中右键单击并选择 **新建文件** 来在 `app.py` 中看到您目录的名称。
- en: 'The `app.py` file is the main file that Flask uses in its framework. Everything
    within the application is included in this file or referenced from within it.
    Although its content depends on the exact implementation of the user, the file
    generally contains four main sections:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件是 Flask 在其框架中使用的主体文件。应用程序中的所有内容都包含在这个文件中，或者从该文件中引用。尽管其内容取决于用户的精确实现，但该文件通常包含四个主要部分：'
- en: Importing libraries, data, and other resources
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库、数据和其它资源
- en: Instantiating the application and declaring other useful functions
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化应用程序并声明其他有用的函数
- en: Declaring the routes for the application
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明应用程序的路由
- en: Running the `__name__ == "__main__" driver` piece of code
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `__name__ == "__main__"` 驱动代码
- en: 'We can see an illustration of these components in *Figure 11.6*:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在 *图 11.6* 中看到这些组件的示意图：
- en: '![Figure 11.6 – The main components of a Flask application ](img/B17761_11_006.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – Flask 应用程序的主要组件](img/B17761_11_006.jpg)'
- en: Figure 11.6 – The main components of a Flask application
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – Flask 应用程序的主要组件
- en: 'Let''s now go ahead and populate `app.py` with some code. This is generally
    done in four main sections:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续填充 `app.py` 中的代码。这通常在四个主要部分中完成：
- en: 'We will begin by importing the `Flask` class from the `flask` library:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从 `flask` 库中导入 `Flask` 类：
- en: '[PRE0]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will need to create an instance of our Flask app:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们 Flask 应用的一个实例：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now use the app object to create routes for our application. Routes
    operate by executing the function directly beneath it when that route is interacted
    with. Let''s make a simple one that returns `"Hello Biotech World!"`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用应用对象来为我们的应用程序创建路由。路由通过在与之交互时直接执行其下方的函数来操作。让我们创建一个简单的路由，它返回 `"Hello Biotech
    World!"`：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we will need a driver for the application that can fulfill using `if
    __name__ == ''__main__''`. We will also set the `debug` parameter as `True` to
    help us address any potential issues, and we will set the `port` value to `8080`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一个应用程序的驱动程序，它可以满足使用 `if __name__ == '__main__'` 的条件。我们还将设置 `debug` 参数为
    `True` 以帮助我们解决任何潜在的问题，并将 `port` 值设置为 `8080`：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the command line in VSC, go ahead and run the Python application:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 VSC 的命令行中，运行 Python 应用程序：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Figure 11.7 – The main components of a URL ](img/B17761_11_007.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – URL 的主要组件](img/B17761_11_007.jpg)'
- en: Figure 11.7 – The main components of a URL
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – URL 的主要组件
- en: In our case, we are currently editing the path or endpoint of the application.
    Flask applications can handle many paths and endpoints, giving developers a great
    deal of flexibility.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们目前正在编辑应用的路径或端点。Flask 应用可以处理许多路径和端点，为开发者提供了很大的灵活性。
- en: You can stop the application from running by pressing *CTRL* + *C* in the command
    line, which will halt the process. With the process halted, go ahead and create
    a second route by copying the current route and function directly below it. Give
    the path a value of `/lifescience` (instead of just `/`) and give its function
    a unique name such as `lifescience`. Next, change the returned value, run the
    application again, and navigate to `http://localhost:8080/lifescience`. If all
    was successful, you should be able to see your new message!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在命令行中按 *CTRL* + *C* 来停止应用程序的运行，这将停止进程。进程停止后，您可以复制当前路由和函数直接在其下方创建第二个路由。将路径值设为
    `/lifescience`（而不是仅仅 `/`），并为其函数提供一个独特的名称，例如 `lifescience`。接下来，更改返回值，再次运行应用程序，并导航到
    `http://localhost:8080/lifescience`。如果一切顺利，您应该能够看到您的新消息！
- en: Routes and Functions
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 路由和函数
- en: Please note that routes must be unique – this means that you cannot have multiple
    routes in Flask pointing to `/biotech`. Similarly, the function beneath the route
    must also be unique in its name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，路由必须是唯一的——这意味着您不能在 Flask 中有多个指向 `/biotech` 的路由。同样，路由下方的函数在其名称上也必须是唯一的。
- en: When deploying our models, we will work with similar architecture. However,
    the return statements will generally comprise either a UI for people to use or
    data for applications to consume. In the following section, we will explore this
    in a little more depth by using a **Natural Language Processing** (**NLP**) use
    case.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署我们的模型时，我们将使用类似的架构。然而，返回语句通常将包括供人们使用的 UI 或供应用程序消费的数据。在下一节中，我们将通过使用 **自然语言处理**（**NLP**）用例来更深入地探讨这一点。
- en: Using Flask as an API and web application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flask 作为 API 和 Web 应用
- en: In [*Chapter 9*](B17761_09_Final_JM_ePub.xhtml#_idTextAnchor132), *Natural Language
    Processing*, we explored the use of the `transformers` library for the purposes
    of running text similarity search engines. By using this technology, we could
    have explored other models and implementations, such as **sentiment analysis**,
    **text classification**, and many more. One particular type of model that has
    gained a great deal of traction when it comes to NLP is the **summarization**
    model.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B17761_09_Final_JM_ePub.xhtml#_idTextAnchor132) *自然语言处理* 中，我们探讨了使用
    `transformers` 库来运行文本相似度搜索引擎的目的。通过使用这项技术，我们可以探索其他模型和实现，例如 **情感分析**、**文本分类**以及更多。在自然语言处理（NLP）方面，有一种特定类型的模型已经获得了很大的关注，那就是
    **摘要** 模型。
- en: 'We can think of summarization models as tasks designed to reduce several paragraphs
    of text down to a few sentences, thereby allowing users to reduce the amount of
    time required to read. Luckily for us, we can implement an out-of-the-box summarization
    model using the `transformers` library and install that in our `app.py` file.
    Not only will we need to cater to human users (by using a UI), but we will also
    need to cater to web applications (APIs) that may be interested in using our model.
    In order to accommodate these two cases, we will need three files in total within
    our project to get us started:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将摘要模型视为设计用来将几段文本缩减为几个句子的任务，从而使用户能够减少阅读所需的时间。幸运的是，我们可以使用 `transformers` 库实现一个现成的摘要模型，并将其安装在我们的
    `app.py` 文件中。我们不仅需要满足人类用户（通过使用 UI），还需要满足可能对使用我们的模型感兴趣的网络应用程序（API）。为了适应这两种情况，我们将在项目中需要总共三个文件来开始：
- en: '`app.py`: This is the main file in which the Flask framework and all NLP models
    are instantiated.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py`：这是主文件，其中实例化了 Flask 框架和所有 NLP 模型。'
- en: '`styles.css`: This is a CSS file that allows us to style the UI.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styles.css`：这是一个 CSS 文件，它允许我们设置 UI 的样式。'
- en: '`index.html`: This is an HTML file with a pre-built UI page that human users
    will interact with.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`：这是一个带有预构建 UI 页面的 HTML 文件，人类用户将与它交互。'
- en: For better organization, let's add the CSS file to a directory called `styles`
    and the HTML file to a directory called `templates`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的组织，让我们将 CSS 文件添加到名为 `styles` 的目录中，将 HTML 文件添加到名为 `templates` 的目录中。
- en: When working with new Flask applications, we generally want to have a *blank
    slate* when it comes to the libraries we installed via `pip`. In other words,
    each Flask application should have its own *virtual environment*, where we only
    install libraries the application will need and use. We can accomplish this using
    `virtualenv`, which (ironically) can be installed using `pip`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理新的 Flask 应用程序时，我们通常希望使用 `pip` 安装的库方面有一个 *空白状态*。换句话说，每个 Flask 应用程序都应该拥有自己的
    *虚拟环境*，在那里我们只安装应用程序需要和使用的库。我们可以使用 `virtualenv` 来实现这一点，而讽刺的是，`virtualenv` 本身也可以通过
    `pip` 安装。
- en: 'Once installed, we can use `virtualenv` on the command line to create a new
    environment for this project called `.venv`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以在命令行中使用 `virtualenv` 创建一个新的项目环境，命名为 `.venv`：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can call your virtual environment anything you like, but most users generally
    default to the name in the preceding command. You will know this command was successful
    when you see a new directory in your current working directory with the specified
    name. We will now need to *activate* the environment, which can be a little tricky
    depending on the type of system you are using. **Windows** users can activate
    their environment using the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给你的虚拟环境起任何你喜欢的名字，但大多数用户通常默认使用前面命令中的名字。当你看到当前工作目录中出现了指定名称的新目录时，你就知道这个命令执行成功了。我们现在需要
    *激活* 这个环境，这可能会根据你使用的系统类型而有点棘手。**Windows** 用户可以使用以下命令来激活他们的环境：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On the other hand, **Linux** and **Mac** users can activate their environments
    via the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**Linux** 和 **Mac** 用户可以通过以下命令来激活他们的环境：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can confirm the environment was activated if its name appears on the left-hand
    side of the command line's current working directory. Go ahead and install `flask`
    and `transformers`, as we will need these libraries in the current environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看命令行当前工作目录的左侧是否有环境名称出现来确认环境已被激活。现在，请安装 `flask` 和 `transformers`，因为我们将在当前环境中需要这些库。
- en: 'With the environment set up and including the three files discussed, we should
    have a directory structure as depicted in *Figure 11.8*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好环境并包含前面讨论的三个文件后，我们应该有一个如 *图 11.8* 所示的目录结构：
- en: '![Figure 11.8 – The current folder structure of this project in VSC ](img/B17761_11_008.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 在 VSC 中此项目的当前文件夹结构](img/B17761_11_008.jpg)'
- en: Figure 11.8 – The current folder structure of this project in VSC
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 在 VSC 中此项目的当前文件夹结构
- en: 'With the project structure now in place, let''s add some code to `app.py`.
    We can begin by importing some of the libraries we will need within this application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目结构现在已经到位的情况下，让我们向 `app.py` 文件中添加一些代码。我们可以从导入这个应用程序中需要的库开始：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that the libraries have been imported, we can instantiate an instance of
    the `Flask` application just as before. However, we will need to specify the template
    folder this time:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库已经导入，我们可以像之前一样实例化 `Flask` 应用程序的实例。然而，这次我们需要指定模板文件夹：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the application instantiated, we can now create an instance of the summarizer
    model from the transformers `pipeline` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用实例化后，我们现在可以从transformers的`pipeline`类创建摘要模型的实例：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we can add our *routes*. We will first create a route to our home page,
    which displays the UI using the `index.html` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加我们的*路由*。我们首先创建一个到主页的路由，该路由使用`index.html`文件显示UI：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will then need to add two routes: one for the UI, and another for the API.
    There are many best practices that vary depending on the framework, the industry,
    and the use case. In most scenarios, `api` endpoints are generally preceded with
    the `api` word to distinguish them from others. Let''s go ahead and create a route
    for the UI first:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加两个路由：一个用于UI，另一个用于API。根据框架、行业和用例的不同，有许多最佳实践。在大多数情况下，`api`端点通常以`api`这个词开头，以区分它们。让我们先创建一个用于UI的路由：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that within this function, we use the `request.form.get` function to
    retrieve the values from the form in the UI. In addition, we use some regular
    expressions to clean up the text, and then we summarize the contents using the
    summarizer model. Finally, we return the summary and the `index.html` file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个函数内部，我们使用`request.form.get`函数从UI表单中检索值。此外，我们使用一些正则表达式来清理文本，然后使用摘要模型总结内容。最后，我们返回摘要和`index.html`文件。
- en: 'Let''s now create the second route for the api:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为api创建第二个路由：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that in addition to taking the input data, cleaning the contents, and
    summarizing it, we can take the `maxlen` and `minlen` parameters directly from
    the `JSON` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了获取输入数据、清理内容和摘要之外，我们还可以直接从`JSON`对象中获取`maxlen`和`minlen`参数。
- en: 'Finally, we can go ahead and execute the code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以继续执行代码：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With that, we have successfully developed the Flask application. Once deployed,
    you should be able to navigate to `http://localhost:5000/` and start summarizing
    paragraphs of text! We can see an example of the application in *Figure 11.9*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就成功开发了Flask应用。一旦部署，你应该能够导航到`http://localhost:5000/`并开始总结文本段落！我们可以在*图11.9*中看到一个应用的示例：
- en: '![Figure 11.9 – A screenshot of the summarizer web application  ](img/B17761_11_009.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 摘要Web应用的截图](img/B17761_11_009.jpg)'
- en: Figure 11.9 – A screenshot of the summarizer web application
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 摘要Web应用的截图
- en: 'In addition, we can use applications such as `POST` request, add the URL, and
    then add the data in the form of a dictionary and the content type of the application/JSON:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`POST`请求等应用，添加URL，然后将数据以字典的形式添加，并指定内容类型为application/JSON：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the application now working, we managed to successfully create a solution
    that uses Flask to cater to both human users and other web applications. In the
    final chapter of this book, we will deploy this application to the cloud. However,
    one of the most important steps of doing this is providing a list of the libraries
    that need to be installed. Given that we have set up a virtual environment, we
    can easily transfer a list of these libraries to a `requirements.txt` file via
    `pip`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用正在运行，我们成功创建了一个解决方案，使用Flask为人类用户和其他Web应用提供服务。在本书的最后一章，我们将把这个应用部署到云端。然而，完成这一步骤的一个重要步骤是提供一个需要安装的库列表。鉴于我们已经设置了一个虚拟环境，我们可以通过`pip`轻松地将这些库的列表转移到`requirements.txt`文件中：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With that, you should now see a `requirements.txt` file in the same directory
    as `app.py`. It is important to ensure that the environment you use only contains
    the libraries you plan to use. This helps keep the application light and fast
    to use. In the following section, we will look at a more in-depth application
    – one that uses a previously trained model concerning the breast cancer dataset
    we saw earlier in this book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你现在应该能在`app.py`相同的目录下看到一个`requirements.txt`文件。确保你使用的环境只包含你计划使用的库非常重要。这有助于保持应用轻量级且使用快速。在下一节中，我们将查看一个更深入的应用——一个使用之前训练的模型，该模型涉及本书前面看到的乳腺癌数据集。
- en: Tutorial – Deploying a pretrained model using Flask
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 – 使用Flask部署预训练模型
- en: In the previous example of creating a Flask application, we saw how we can make
    use of the application in conjunction with a predictive model to deploy a solution
    to our end users. However, the model that we deployed was an out-of-the-box solution
    and not a model we developed ourselves. In this section, we will once again deploy
    a model within a Flask application; however, we use a model based on the cancer
    dataset we saw in [*Chapter 5*](B17761_05_Final_JM_ePub.xhtml#_idTextAnchor082),
    *Understanding Machine Learning*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Flask 应用程序的先前的例子中，我们看到了如何结合预测模型使用应用程序来部署解决方案给最终用户。然而，我们部署的模型是一个现成的解决方案，而不是我们自己开发的模型。在本节中，我们将在
    Flask 应用程序中再次部署一个模型；然而，我们使用的是基于我们在[*第 5 章*](B17761_05_Final_JM_ePub.xhtml#_idTextAnchor082)中看到的癌症数据集的模型，*理解机器学习*。
- en: If you recall, the main idea behind this model was to take in a number of measurements
    for a given tumor, and based on those measurements, determine what the diagnosis
    will likely be, resulting in either `Malignant` or `Benign`. Within this application,
    we will enable users to interact with a trained model and enter measurements that
    the model will use to make a prediction. With this in mind, let's get started!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，这个模型的主要思想是接受给定肿瘤的一组测量值，并根据这些测量值确定诊断结果，结果可能是`恶性`或`良性`。在这个应用程序中，我们将允许用户与训练好的模型交互，并输入模型将用于预测的测量值。考虑到这一点，让我们开始吧！
- en: In the same way as before, go ahead and add a new folder and a new virtual environment
    to install the relevant libraries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，继续添加一个新的文件夹和一个新的虚拟环境来安装相关的库。
- en: 'Using the same directory architecture and process as before, we can begin by
    importing the relevant libraries. Notice that we have added the `pickle` library
    here, as we will need to use the *pickled* models we previously created:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的目录结构和流程，我们可以首先导入相关的库。请注意，我们在这里添加了`pickle`库，因为我们需要使用之前创建的*序列化*模型：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our next step involves importing the two models we trained – the actual classification
    model and the standard scaler model we used for the data:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步涉及导入我们训练的两个模型——实际的分类模型和用于数据的标准缩放模型：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then define a `predict_diagnosis` function to clean up our code later
    when developing our routes. This function will take the input data in the form
    of a list, the scaler model, and the classification model:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个`predict_diagnosis`函数，以便在开发我们的路由时清理代码。这个函数将接受以列表形式输入的数据、缩放模型和分类模型：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will instantiate the Flask application while specifying the `template`
    folder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实例化 Flask 应用程序，同时指定`template`文件夹：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With these items taken care of, we can focus on our routes. First, we will
    create a `home` route that users will see first:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些事项后，我们可以专注于我们的路由。首先，我们将创建一个`home`路由，用户将首先看到：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will need a `prediction` route, just as before. The only difference
    here is that the number of input values will be greater, as we are working with
    a few more features now:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个`prediction`路由，就像之前一样。这里唯一的区别是输入值的数量将更多，因为我们现在正在处理更多的特征：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we can go ahead and run the application:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以继续运行应用程序：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Upon running the model and navigating to localhost in the web browser, the
    application will appear. Go ahead and try making a few predictions using the UI,
    an example of which is displayed in *Figure 11.10*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行模型并在网络浏览器中导航到localhost后，应用程序将出现。请尝试使用UI进行一些预测，如图*图 11.10*所示：
- en: '![Figure 11.10 – A screenshot of the breast cancer web application  ](img/B17761_11_0010.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 乳腺癌网络应用程序的屏幕截图](img/B17761_11_0010.jpg)'
- en: Figure 11.10 – A screenshot of the breast cancer web application
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 乳腺癌网络应用程序的屏幕截图
- en: We can see that the model is able to take our input data, run a prediction,
    and return a result to the user. One thing we did not do here is create an API
    route for other web applications to interact with our model. As a challenge, go
    ahead and create this route, using the previous summarization application as an
    example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，该模型能够接受我们的输入数据，运行预测，并将结果返回给用户。我们没有在这里做的一件事是为其他网络应用程序与我们的模型交互创建一个API路由。作为一个挑战，请继续创建这个路由，以之前的总结应用程序为例。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we steered away from the development of models and focused
    more on how models can be deployed to interact with web applications. We investigated
    the idea of data transfer via APIs, and we also learned about some of the most
    common frameworks. We investigated one of the most common Python web application
    frameworks known as Flask. Using Flask, we developed an NLP summarization model
    that allows both human users and other web applications to interact with it and
    use its capabilities. In addition, we learned how to deploy previously trained
    models, such as those from `scikit-learn`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们偏离了模型开发的方向，更多地关注了模型如何部署以与Web应用程序交互。我们研究了通过API进行数据传输的想法，并且还了解了一些最常用的框架。我们调查了最常用的Python
    Web应用程序框架之一，即Flask。使用Flask，我们开发了一个NLP摘要模型，允许人类用户和其他Web应用程序与之交互并使用其功能。此外，我们还学习了如何部署之前训练好的模型，例如来自`scikit-learn`的模型。
- en: In each of these instances, we launched our models locally as we developed their
    frameworks and capabilities. In the next chapter, we will make our model available
    to others by using **Docker** containers and **AWS** to deploy our model to the
    cloud.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些实例中，我们在开发它们的框架和功能时，在本地启动了我们的模型。在下一章中，我们将通过使用**Docker**容器和**AWS**将我们的模型部署到云端，使我们的模型对他人可用。
