- en: '*Chapter 3*: Building the Edge'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：构建边缘'
- en: In this chapter, you will learn about **edge** solution concepts such as gateways
    and how **AWS IoT Greengrass** is used as a powerful edge appliance to interact
    with physical interfaces and leaf devices. The goal of this chapter is to start
    building proficiency with the use of IoT Greengrass for the writing and deploying
    of software components. This material is foundational to much of the book's hands-on
    projects and for understanding how we build solutions for the edge.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解**边缘**解决方案的概念，例如网关，以及如何使用**AWS IoT Greengrass**作为强大的边缘设备与物理接口和叶子设备进行交互。本章的目标是开始使用IoT
    Greengrass编写和部署软件组件，以建立熟练度。这部分内容是本书许多动手实践项目的基础，也是理解我们如何构建边缘解决方案的关键。
- en: We will introduce you to the different protocols that IoT Greengrass can support
    out of the box and discuss commonly used protocols when building edge solutions.
    Additionally, we will review several security best practices for you to learn
    how to keep your edge workloads protected from threats and vulnerabilities. The
    chapter concludes with a hands-on activity to connect your first two device capabilities
    as components, whether using actual hardware or a pair of simulators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您介绍IoT Greengrass开箱即支持的多种协议，并讨论构建边缘解决方案时常用的协议。此外，我们将回顾几个安全最佳实践，以便您学习如何保护您的边缘工作负载免受威胁和漏洞的侵害。本章以一个动手活动结束，该活动将连接您的第一个两个设备功能作为组件，无论您使用的是实际硬件还是一对模拟器。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exploring the topology of the edge
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索边缘拓扑
- en: Reviewing common standards and protocols
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查常见标准和协议
- en: Security at the edge
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘安全
- en: Connecting your first device – sensing at the edge
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接第一个设备 – 在边缘感知
- en: Connecting your second device – actuating at the edge
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接第二个设备 – 在边缘执行操作
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the hands-on exercises in this chapter, you will need to have completed
    the steps in [*Chapter 2*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032), *Foundations
    of Edge Workloads* such that your edge device has been set up with the IoT Greengrass
    Core software running and the `greengrass-cli` component installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的动手练习，您需要完成[*第2章*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032)中*边缘工作负载基础*的步骤，以确保您的边缘设备已设置好运行IoT
    Greengrass Core软件，并安装了`greengrass-cli`组件。
- en: 'You will want to clone the chapter''s resources from the book''s GitHub repository,
    for ease of use, if you haven''t already done so. There is a step included in
    the *Connecting your first device – sensing at the edge* section that enables
    you to clone the repository at [https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter3](https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter3).
    You can perform this step now if you would like to browse the resources in advance:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，为了方便使用，您可能需要从书的GitHub仓库中克隆本章的资源。在*连接第一个设备 – 在边缘感知*部分中包含了一个步骤，允许您在[https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter3](https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter3)克隆仓库。如果您想提前浏览资源，现在就可以执行此步骤：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As a reminder, the hands-on steps for this book were authored with a **Raspberry
    Pi** and **Sense HAT** expansion board in mind. For those of you using other Linux-based
    systems for the edge device, alternate technical resources are included in the
    GitHub repository with guidance on how to substitute them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，本书的动手步骤是以**树莓派**和**Sense HAT**扩展板为背景编写的。对于那些使用其他基于Linux的系统作为边缘设备的您，GitHub仓库中包含了替代技术资源，并提供了如何替换它们的指导。
- en: Exploring the topology of the edge
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索边缘拓扑
- en: 'Solutions built for the edge take on many shapes and sizes. The number of distinct
    devices included in a solution ranges from one to many. The network layout, compute
    resources, and budget allowed will drive your architectural and implementation
    decisions. In an edge **machine learning** (**ML**) solution, we should consider
    the requirements for running ML models. ML models work more accurately when they
    are custom built for a specific instance of a device, as opposed to one model
    supporting many physical instances of the same device. This means that as the
    number of devices supported by an edge ML workload grows, so too will the number
    of ML models and compute resources required at the edge. There are four topologies
    to consider when architecting an edge ML solution: star, bus, tree, and hybrid.
    Here is a description of each of them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Star topology**: The **Home Base Solutions** (**HBS**) hub device and appliance
    monitoring kits represent a common pattern in edge ML solutions called **star**
    topology. The appliance monitoring kits are single-purpose devices that report
    telemetry back to the hub device. This creates several advantages in terms of
    cost optimization for the kits since they do not need to bundle all of the hardware
    that is necessary to independently communicate directly with a cloud solution.
    Nor do they require any compute power or local storage to run their own ML models.
    The hub device in the star topology acts as a server in the sense that it can
    exchange data with the kits and perform heavier compute and storage tasks on their
    behalf. Entities such as leaf devices or software components address other entities
    directly to send them messages, and they get routed to the right destination.
    The following diagram shows an example of the HBS product design operating in
    a star topology:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – An example of the star topology with hub and devices'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_03_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – An example of the star topology with hub and devices
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Bus topology**: In a **bus** pattern, all of the nodes in the topology are
    connected to a single shared line, meaning a message published by one entity can
    be received by as many entities as are sharing the bus. The bus pattern comes
    from computer network history where devices are used to physically tap into the
    network line, expanding the bus with each device. While these days, we don''t
    usually view this pattern as physically wired, there is a logical application
    of the bus pattern in edge ML solutions. In a decoupled solution, such as the
    one we are building, an entity such as a software component or leaf device can
    publish a message without addressing any other particular entity by using a topic
    address. A topic address doesn''t strictly identify other entities; it is up to
    those other entities to subscribe to such topic addresses in order to get a copy
    of the message. In this way, the hub device is, technically, the center of a star-like
    topology; however, the way in which connected entities interact with each other
    is, in practice, more like a bus. The following diagram illustrates the bus concept
    for a parallel universe where HBS delivers the monitoring of industrial equipment
    with an equipment monitoring kit, a local server running ML inference, and an
    **andon** light all connected to a hub:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总线拓扑**：在总线模式中，拓扑中的所有节点都连接到一条单独的共享线，这意味着一个实体发布的消息可以被共享总线的所有实体接收。总线模式源于计算机网络的历史，当时设备被用来物理地接入网络线路，每个设备都扩展了总线。虽然现在我们通常不将这种模式视为物理布线，但在边缘机器学习解决方案中，总线模式有一个逻辑应用。在一个解耦的解决方案中，例如我们正在构建的解决方案，一个实体，如软件组件或叶设备，可以通过使用主题地址发布消息，而无需指向任何其他特定实体。主题地址并不严格标识其他实体；其他实体需要订阅这样的主题地址，以便获取消息的副本。这样，中心设备在技术上是一个星形拓扑的中心；然而，实际上连接的实体之间相互交互的方式更像是总线。以下图示说明了总线概念，在一个平行宇宙中，HBS通过设备监控套件、运行机器学习推理的本地服务器和连接到中心的总线灯来提供工业设备的监控：'
- en: '![Figure 3.2 – An example of the logical bus topology'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 逻辑总线拓扑的示例'
- en: '](img/Figure_03_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_03_02.jpg]'
- en: Figure 3.2 – An example of the logical bus topology
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 逻辑总线拓扑的示例
- en: '**Tree topology**: While it is a good practice for any edge ML solution to
    functionally operate in isolation, we cannot ignore the benefits of bridging our
    solution to the wider network and cloud services. In a **tree** topology, our
    hub device is just one layer of nodes in a tree graph where a centralized service
    communicates with our fleet of hubs. Each hub is then responsible for a specific
    number of leaf devices and components running in a local star pattern. Managing
    our HBS product at scale requires us to think about the fleet in its entirety.
    The following diagram shows the relationship between a cloud service orchestrating
    our fleet, the fleet of HBS hub devices, and the local appliance monitoring kits
    supported per hub:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树形拓扑**：虽然对于任何边缘机器学习解决方案来说，在功能上独立运行是一种好的做法，但我们不能忽视将我们的解决方案与更广泛的网络和云服务桥接的好处。在树形拓扑中，我们的中心设备只是树形图中节点的一个层次，其中集中式服务与我们的枢纽群进行通信。然后，每个枢纽负责特定数量的运行在本地星形模式下的叶设备和组件。在规模上管理我们的HBS产品需要我们考虑整个枢纽群。以下图示显示了云服务协调我们的枢纽群、HBS枢纽设备群以及每个枢纽支持的本地设备监控套件之间的关系：'
- en: '![Figure 3.3 – An example of the tree topology for managing a fleet of connected
    hubs'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 管理连接的枢纽群的总线拓扑示例'
- en: '](img/Figure_03_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 逻辑总线拓扑的示例](img/Figure_03_03.jpg)'
- en: Figure 3.3 – An example of the tree topology for managing a fleet of connected
    hubs
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 管理连接的枢纽群的总线拓扑示例
- en: '**Hybrid topology**: If our product design or hub device budget didn''t allow
    running ML workloads at the edge and simply handled the cloud connectivity on
    behalf of the kits, this would necessitate a **hybrid** topology. In a hybrid
    topology, the hub might centralize just enough resources to establish the cloud
    connectivity and routes messages back and forth between the kits and the cloud
    service. Here, hybrid defines the additional topological complexity of running
    further compute workloads, such as our ML inference, in the cloud. In this scenario,
    the cloud-based ML workloads making inferences against incoming telemetry would
    require some subset of device messages to be transmitted to the cloud. Some scenarios
    might opt to reduce the bill of materials of the hub in favor of a cloud-based
    ML solution. This makes sense when the volume of traffic is on the lower end of
    the spectrum or when the number of ML workloads exceeds what is reasonable to
    run on a single gateway device. The following diagram shows a modified example
    of our fictional product design running as a hybrid:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合拓扑**：如果我们的产品设计或中心设备预算不允许在边缘运行机器学习工作负载，而只是代表套件处理云连接，这将需要**混合**拓扑。在混合拓扑中，中心设备可能仅集中足够的资源以建立云连接，并在套件和云服务之间来回路由消息。在这里，混合定义了在云中运行进一步计算工作负载（如我们的机器学习推理）的额外拓扑复杂性。在这种情况下，基于云的机器学习工作负载对传入的遥测数据进行推理时，需要将一些设备消息子集传输到云。某些场景可能会选择减少中心设备的物料清单，以换取基于云的机器学习解决方案。当流量量处于较低端或当机器学习工作负载数量超过在单个网关设备上合理运行的数量时，这是有意义的。以下图显示了我们的虚构产品设计作为混合拓扑的修改示例：'
- en: '![Figure 3.4 – An example of hybrid topology with remote compute and storage
    resources'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 带有远程计算和存储资源的混合拓扑示例'
- en: '](img/Figure_03_04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_03_04.jpg)'
- en: Figure 3.4 – An example of hybrid topology with remote compute and storage resources
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 带有远程计算和存储资源的混合拓扑示例
- en: 'There are two additional patterns that are common when studying network topologies,
    that is, the mesh and ring topologies:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究网络拓扑时，有两个额外的模式是常见的，即网状和环形拓扑：
- en: 'In a **mesh topology**, nodes can have one-to-many relationships with other
    nodes and exchange information through that network of connections to reach that
    information''s destination:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**网状拓扑**中，节点可以与其他节点形成一对一或多对一的关系，并通过该连接网络交换信息以到达信息的目的地：
- en: '![Figure 3.5 – A mesh topology where a sensor on gateway 2 traverses the mesh
    to'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 网状拓扑，其中网关2上的传感器穿越网状结构以'
- en: reach an actuator on gateway 5
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 达到网关5的执行器
- en: '](img/Figure_03_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_03_05.jpg)'
- en: Figure 3.5 – A mesh topology where a sensor on gateway 2 traverses the mesh
    to reach an actuator on gateway 5
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 网状拓扑，其中网关2上的传感器穿越网状结构以到达网关5的执行器
- en: 'In a **ring topology**, nodes have at most two neighboring connections and
    exchange information through the ring until it reaches its destination:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**环形拓扑**中，节点最多有两个相邻连接，并通过环形交换信息，直到达到目的地：
- en: '![Figure 3.6 – A ring topology where a sensor reading from gateway 2 passes
    through adjacent gateways to reach an actuator at gateway 3'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 环形拓扑，其中从网关2读取的传感器数据通过相邻网关传输，以到达网关3的执行器'
- en: '](img/Figure_03_06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_03_06.jpg)'
- en: Figure 3.6 – A ring topology where a sensor reading from gateway 2 passes through
    adjacent gateways to reach an actuator at gateway 3
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 环形拓扑，其中从网关2读取的传感器数据通过相邻网关传输，以到达网关3的执行器
- en: These patterns emphasize decentralization where nodes connect to each other
    directly. While these patterns have their time and place in the broader spectrum
    of IoT solutions, they are infrequently used in edge ML solutions where a gateway
    or hub device and cloud service are often best practices or outright requirements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式强调了去中心化，其中节点直接相互连接。虽然这些模式在物联网解决方案的更广泛范围内有其时间和地点，但在边缘机器学习解决方案中它们很少使用，在这些解决方案中，网关或中心设备以及云服务通常是最佳实践或直接要求。
- en: When deciding on a particular topology for your solution architecture, start
    by considering whether all devices at the edge are weighted equally or whether
    they will communicate with a central node such as a gateway. A consumer product
    design for an edge ML solution tends to use the star pattern when thinking about
    the edge in isolation. A good edge solution should be able to operate in its star
    pattern even when any external link to a larger tree or hybrid topology is severed.
    We use the star pattern to implement the HBS product since the hub device will
    run any and all ML runtime workloads that we require.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定解决方案架构的特定拓扑时，首先考虑边缘的所有设备是否被同等加权，或者它们是否会与一个中心节点，如网关进行通信。针对边缘机器学习解决方案的消费产品设计倾向于在单独考虑边缘时采用星形模式。一个好的边缘解决方案应该能够在任何外部链接到更大的树形或混合拓扑被切断的情况下，仍然以星形模式运行。我们使用星形模式来实现HBS产品，因为中心设备将运行我们所需的任何和所有机器学习运行时工作负载。
- en: IoT Greengrass is designed to run as the hub of a star implementation and plug
    into a larger tree or hybrid topology connecting to the AWS cloud. Solution architects
    can choose how much or how little compute work is performed by the gateway device
    running IoT Greengrass. In the next section, we will review the protocols used
    to exchange messages at the edge and between the edge and cloud.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网Greengrass被设计为作为星形实现的中心，并连接到AWS云的更大树形或混合拓扑。解决方案架构师可以选择运行物联网Greengrass的网关设备执行多少或多少计算工作。在下一节中，我们将回顾在边缘和边缘与云之间交换消息所使用的协议。
- en: Reviewing common standards and protocols
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查常见标准和协议
- en: Protocols define the specifications for exchanging messages with an edge solution.
    This means the format of the message, how it is serialized over the wire, and
    also the networking protocols for communicating between two actors in the solution.
    Standards and protocols help us to architect within best practices and enable
    quick decision-making when selecting implementations. Before diving into the common
    protocols that are used in edge solutions, first, let's review two architectural
    standards used in information technology and operations technology to gain an
    understanding of where IoT Greengrass fits into these standards. Using these as
    a baseline will help set the context for the protocols used and how messages traverse
    these models in an edge solution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 协议定义了与边缘解决方案交换消息的规范。这意味着消息的格式，它在线上的序列化方式，以及解决方案中两个参与者之间通信的网络协议。标准和协议帮助我们按照最佳实践进行架构，并在选择实现时进行快速决策。在深入研究边缘解决方案中使用的常见协议之前，首先，让我们回顾在信息技术和运营技术中使用的两个架构标准，以了解物联网Greengrass如何融入这些标准。使用这些标准作为基线将有助于设定协议使用的上下文以及消息如何在边缘解决方案中穿越这些模型。
- en: IoT Greengrass in the OSI model
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSI模型中的物联网Greengrass
- en: 'The **Open Systems Interconnection** (**OSI**) model defines a stack of seven
    layers of network communications, describing the purpose and media used to exchange
    information between devices at each layer. At the top of the stack is layer seven,
    the *application layer*, where high-level APIs and transfer protocols are defined.
    At the bottom is layer one, the *physical layer*, where digital bits are transmitted
    over physical media using electricity and radio signals. The following is a diagram
    of the OSI model and shows how IoT Greengrass fits in with individual layers:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放系统互联**（**OSI**）模型定义了一个由七个网络通信层组成的堆栈，描述了每个层之间设备交换信息的目的和使用的媒体。在堆栈的顶部是第七层，即*应用层*，在这里定义了高级API和传输协议。在底部是第一层，即*物理层*，在这里使用电和无线电信号通过物理媒体传输数字位。以下是一个OSI模型的图示，展示了物联网Greengrass如何与各个层相匹配：'
- en: '![Figure 3.7 – An OSI model with an overlay of IoT Greengrass layer interactions'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – 带有物联网Greengrass层交互覆盖的OSI模型'
- en: '](img/Figure_03_07.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_03_07.jpg]'
- en: Figure 3.7 – An OSI model with an overlay of IoT Greengrass layer interactions
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 带有物联网Greengrass层交互覆盖的OSI模型
- en: Here, you can observe that our runtime orchestrator, IoT Greengrass, operates
    from layer four to layer seven. There are high-level applications and transfer
    protocols used in the IoT Greengrass Core software to exchange application messages
    with the AWS cloud and local devices using protocols such as HTTPS and MQTT. Additionally,
    libraries bundled in the core software are responsible for the transport layer
    communications in the TCP/IP stack, but then further transmission throughout the
    OSI model is handed off to the host operating system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以观察到我们的运行时编排器，物联网Greengrass，从第四层运行到第七层。在物联网Greengrass Core软件中使用了高级应用程序和传输协议，用于通过HTTPS和MQTT等协议与应用程序消息与AWS云和本地设备进行交换。此外，核心软件中捆绑的库负责TCP/IP堆栈中的传输层通信，但随后将OSI模型中的进一步传输转交给主机操作系统。
- en: Note that while the IoT Greengrass Core software operates from layer four to
    layer seven, the software components deployed to your edge solution might reach
    all the way down to layer one. For example, any sensors or actuators physically
    connected to the IoT Greengrass device could be accessed with code running in
    a component, usually with a low-level library API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然物联网Greengrass Core软件从第四层运行到第七层，但部署到你的边缘解决方案的软件组件可能达到第一层。例如，任何物理连接到物联网Greengrass设备的传感器或执行器都可以通过在组件中运行的代码访问，通常使用低级库API。
- en: IoT Greengrass in ANSI/ISA-95
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ANSI/ISA-95中的物联网Greengrass
- en: '**American National Standards Institute/International Society of Automation
    standard 95** (**ANSI/ISA-95**) defines the process in which to relate the interfaces
    between the enterprise and control systems. This standard is used in enterprise
    and industrial solution architectures. It describes another layered hierarchy;
    this one is for the level at which systems are controlled and suggests the time
    scale at which decisions must be made. The following diagram presents another
    frame of reference for how IoT Greengrass and an edge ML solution fit into a holistic
    picture:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**美国国家标准协会/国际自动化协会标准95**（**ANSI/ISA-95**）定义了企业控制系统之间接口关联的过程。此标准用于企业及工业解决方案架构中。它描述了另一个分层体系；这一层是系统控制的层级，并建议在此层级上做出决策的时间尺度。以下图表展示了物联网Greengrass和边缘机器学习解决方案如何融入整体图景：'
- en: '![Figure 3.8 – The ISA-95 model with an overlay of IoT Greengrass layer interactions'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 在ISA-95模型上叠加物联网Greengrass层交互'
- en: '](img/Figure_03_08.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_03_08.jpg)'
- en: Figure 3.8 – The ISA-95 model with an overlay of IoT Greengrass layer interactions
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 在ISA-95模型上叠加物联网Greengrass层交互
- en: Here, you can observe that IoT Greengrass primarily fits in layer three, the
    *Monitoring and Supervising* layer of control systems, to facilitate the upward
    aggregation of device telemetry, downward distribution of commands, and handle
    some decision making in a supervisory capacity. IoT Greengrass is useful in any
    kind of edge solution, be it consumer-grade products or to facilitate the operation
    of industrial machinery. While our HBS product example is not an industrial use
    case, the same pattern applies in that our hub device performs as a gateway for
    sensor monitoring equipment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以观察到物联网Greengrass主要适用于第三层，即控制系统的*监控与监督*层，以促进设备遥测数据的向上聚合、向下分发命令，并在监督职能中处理一些决策。物联网Greengrass适用于任何类型的边缘解决方案，无论是消费级产品还是促进工业机械的运行。虽然我们的HBS产品示例不是一个工业用例，但同样的模式适用，即我们的中心设备作为传感器监控设备的网关。
- en: Now that you have a framework regarding how IoT Greengrass fits into these hierarchies,
    we can review common protocols that are used at the relevant layers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了物联网Greengrass如何融入这些层级，我们可以回顾一下在相关层级中使用的常见协议。
- en: Application layer protocols
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用层协议
- en: Examples of application layer communications include requesting data from an
    API, publishing sensor telemetry, or sending a command to a device. This kind
    of data is relevant to the solution itself and the business logic in service of
    your solution's outcomes. For example, none of the other layers of the OSI model,
    such as the transport layer or the network layer, make decisions in the event
    that a deployed sensor is reporting the ambient temperature at 22°C. Only the
    running applications of your solution can use this data and send or receive that
    data by interacting with the application layer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层通信的例子包括从API请求数据、发布传感器遥测数据或向设备发送命令。这类数据与解决方案本身以及服务于解决方案结果的业务逻辑相关。例如，OSI模型的其他层，如传输层或网络层，在部署的传感器报告环境温度为22°C时不会做出决策。只有你的解决方案运行的应用程序可以使用这些数据，并通过与应用层交互发送或接收这些数据。
- en: To communicate between the edge and the cloud, the most popular application
    layer protocol is **HTTPS** for request-response interactions. IoT Greengrass
    uses HTTPS to interact with AWS cloud services for the purposes of fetching metadata
    and downloading resources for your components, such as the component recipe and
    artifacts such as your code and trained ML models. Additionally, your custom components
    running at the edge might use HTTPS to interact with other AWS services, on-premises
    systems, and the APIs of other remote servers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘和云之间进行通信时，最流行的应用层协议是用于请求-响应交互的**HTTPS**。IoT Greengrass使用HTTPS与AWS云服务进行交互，用于获取元数据和下载组件资源，例如组件配方和代码以及训练好的机器学习模型等资源。此外，运行在边缘的自定义组件可能也会使用HTTPS与其他AWS服务、本地系统和其他远程服务器的API进行交互。
- en: 'To exchange messages between the edge and the cloud, and within the edge solution,
    bi-directional messaging protocols (also called *publish-subscribe* or *pubsub*)
    are commonly used, such as MQTT or AMQP. The benefits of these kinds of protocols
    are listed as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在边缘和云之间以及边缘解决方案内部交换消息，通常使用双向消息协议（也称为*发布-订阅*或*pubsub*），如MQTT或AMQP。这些协议的优点如下：
- en: They use stateful connections to minimize the frequency of handshake connections.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使用有状态的连接来最小化握手连接的频率。
- en: Traffic can flow in either direction without one end or the other having to
    be responsible for initiating a new exchange.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量可以双向流动，无需任一端负责启动新的交换。
- en: They offer minimal overhead per message making them ideal for constrained devices.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们为每条消息提供最小的开销，这使得它们非常适合受限设备。
- en: Clients at the edge can initiate these connections, eliminating the need for
    inbound connections to be permitted by network firewall rules.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘的客户端可以发起这些连接，从而消除了网络防火墙规则需要允许入站连接的需求。
- en: 'IoT Greengrass uses the MQTT protocol to open connections to the AWS IoT Core
    service in a client-broker model in order to pass messages from local devices
    up to the cloud, receive commands from the cloud and relay them to local devices,
    and synchronize the state after a period of disconnection. Additionally, IoT Greengrass
    can serve as the broker to other local devices that connect to it via MQTT. The
    following is a diagram of an IoT Greengrass device, such as the HBS hub device,
    acting as both the client and the broker:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: IoT Greengrass使用MQTT协议以客户端-代理模型打开与AWS IoT Core服务的连接，以便将本地设备上传的消息传递到云中，从云中接收命令并将它们传递给本地设备，并在断开连接一段时间后同步状态。此外，IoT
    Greengrass还可以作为通过MQTT连接到它的其他本地设备的代理。以下是一个IoT Greengrass设备（如HBS网关设备）作为客户端和代理的示意图：
- en: '![Figure 3.9 – The HBS hub acting as both a client to AWS IoT and a server
    to local devices'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 – HBS网关同时作为AWS IoT的客户端和本地设备的服务器'
- en: '](img/Figure_03_09.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_03_09.jpg]'
- en: Figure 3.9 – The HBS hub acting as both a client to AWS IoT and a server to
    local devices
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – HBS网关同时作为AWS IoT的客户端和本地设备的服务器
- en: Next up are the message format protocols that describe the way data is structured
    as it is sent over the application layer protocols.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是消息格式协议，它描述了数据在通过应用层协议发送时的结构化方式。
- en: Message format protocols
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息格式协议
- en: If a messaging protocol such as MQTT specifies how connections are established
    and how messages are exchanged, a *message format protocol* specifies what the
    shape and content of an exchanged message are. You can consider a telephone as
    an analogy. The telephone handset represents how speech is sent in both directions,
    but the language being spoken by the participants at both ends must be understood
    in order for that speech to make sense! In this analogy, MQTT represents the telephone
    itself (abstracting away the public telephone exchange network), and the message
    format protocol is the language being spoken by the people on either end.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个消息协议，例如MQTT，规定了如何建立连接以及如何交换消息，那么一个*消息格式协议*就规定了交换消息的形状和内容。你可以将电话作为类比。电话听筒代表了语音在两个方向上的发送方式，但参与者两端所说的语言必须被理解，这样说话才有意义！在这个类比中，MQTT代表了电话本身（抽象掉了公共电话交换网络），而消息格式协议就是两端人们所说的语言。
- en: 'For any two participants exchanging data with each other, that data is either
    transmitted as binary or it will go through a process of serialization and deserialization.
    Common message format protocols used in edge solutions include **JavaScript Object
    Notation** (**JSON**), Google **Protocol Buffers** (**protobuf**), and **Binary
    JSON** (**BSON**). These formats make it easier for devices, edge components,
    and cloud solutions to interoperate. This is especially important in an architecture
    that is inclusive of mixed programming languages. The message format is a means
    of abstraction that is key to architecting solutions. By using a serializable
    message format protocol, the following diagram shows how a component written in
    Python can exchange messages with a component written in Java:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何两个相互交换数据的参与者，这些数据要么以二进制形式传输，要么会经过序列化和反序列化的过程。在边缘解决方案中常用的常见消息格式协议包括**JavaScript对象表示法**（**JSON**）、Google
    **协议缓冲区**（**protobuf**）和**二进制JSON**（**BSON**）。这些格式使得设备、边缘组件和云解决方案之间的互操作性变得更容易。在包含多种编程语言的架构中，这一点尤为重要。消息格式是一种抽象手段，对于构建解决方案至关重要。通过使用可序列化的消息格式协议，以下图显示了用Python编写的组件如何与用Java编写的组件交换消息：
- en: '![Figure 3.10 – An example of serialization/deserialization using Greengrass
    components'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 使用Greengrass组件进行序列化和反序列化的示例'
- en: '](img/Figure_03_10.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_03_10.jpg)'
- en: Figure 3.10 – An example of serialization/deserialization using Greengrass components
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 使用Greengrass组件进行序列化和反序列化的示例
- en: You could send all messages as binary data, but you would end up with an overhead
    in each recipient that would need to figure out what to do with that data or enact
    strict conventions for what can be sent. For example, a sensor device that only
    ever sends a numerical measurement in degrees centigrade could just send the value
    as binary data. If that system never changes, there's limited value to adding
    notation and serializing it. The recipient on the other end can be hardcoded to
    know what to do with it, thus saving overhead on metadata, structure, and bandwidth.
    This works for rigid, static systems and for cases where transmission costs must
    be the top priority for optimization.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所有消息都发送为二进制数据，但每个接收者都会产生额外的开销，需要确定如何处理这些数据或实施严格的发送约定。例如，一个只发送摄氏度数值测量的传感器设备可以直接发送二进制数据。如果该系统永远不会改变，添加注释和序列化的价值有限。接收端可以硬编码来了解如何处理它，从而节省元数据、结构和带宽的开销。这对于刚性、静态系统以及传输成本必须是最优化的优先级的情况是有效的。
- en: Unstructured data such as images, video, and audio is commonly sent as binary
    payloads but with an accompanying header indicating what kind of data it is. In
    an HTTP request, the *Content-Type* header will include a value such as *text/HTML*
    or a MIME type such as *video/MP4*. This header tells the recipient how to process
    the binary payload of that message.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不规则数据，如图像、视频和音频，通常以二进制有效载荷的形式发送，但会附带一个头部来指示数据的类型。在一个HTTP请求中，*Content-Type*头部将包括一个值，如*text/HTML*或MIME类型如*video/MP4*。这个头部告诉接收者如何处理该消息的二进制有效载荷。
- en: The **interprocess communication** (**IPC**) functionality that is provided
    by IoT Greengrass to components to enable the exchange of messages between them
    supports the JSON message format along with the raw binary format. In this chapter,
    you will build two components that use IPC to pass JSON messages from one component
    to the other.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网Greengrass为组件提供的**进程间通信**（IPC）功能，以支持它们之间消息的交换，支持JSON消息格式以及原始二进制格式。在本章中，你将构建两个组件，它们使用IPC将JSON消息从一个组件传递到另一个组件。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since IoT Greengrass does not prescribe any particular protocol to interact
    with edge devices and systems, you can easily implement components that include
    libraries to interact with any device and any protocol.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于物联网Greengrass没有规定与边缘设备和系统交互的任何特定协议，你可以轻松实现包含与任何设备或任何协议交互的库的组件。
- en: The key takeaway regarding protocols is that we can use common protocols for
    the same, or similar, advantages as we use a good architecture pattern. They are
    battle-tested, well-documented, easy to implement, and prevent us from getting
    lost in the cycles of implementation details where our time would be better spent
    on delivering outcomes. In the next section, we will cover, at a high level, the
    security threats for an edge ML solution and some best practices and tools for
    mitigating them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于协议的关键要点是，我们可以使用与良好架构模式相同的或类似的通用协议。它们经过实战检验，文档齐全，易于实现，并防止我们陷入实现细节的循环中，我们的时间本可以更好地用于交付成果。在下一节中，我们将从高层次概述边缘机器学习解决方案的安全威胁以及缓解这些威胁的最佳实践和工具。
- en: Security at the edge
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘安全
- en: With IoT security being a hot topic and frequently making headlines, security
    in your edge ML solutions must be your top priority. Your leadership at HBS will
    never want to see their company or product name in the news for a story concerning
    a hacked device. Ultimately, security is about establishing and maintaining trust
    with your customer. You can use a threat modeling exercise such as STRIDE to analyze
    atomic actors in your edge system such as end devices, gateways, and software
    components to reason about worst-case scenarios and the minimum viable mitigation
    to prevent them. In this section, we will cover common security threats and the
    best practices for mitigating them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着物联网安全成为热门话题并频繁成为头条新闻，你的边缘机器学习解决方案中的安全性必须是你的首要任务。HBS的领导层永远不会希望看到他们的公司或产品名称因黑客攻击设备的故事而出现在新闻中。最终，安全性是关于与你的客户建立和维护信任。你可以使用如STRIDE这样的威胁建模练习来分析你的边缘系统中原子操作者，如端设备、网关和软件组件，以推理最坏情况场景和防止这些场景的最小可行缓解措施。在本节中，我们将介绍常见的安全威胁以及缓解它们的最佳实践。
- en: End devices to your gateway
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端设备到网关
- en: Let's start with the terminal segment in our edge ML solution along with the
    appliance monitoring kit itself and its connection to the hub device. The worst-case
    scenario for this segment is that an unhealthy appliance is mistakenly reported
    as healthy. If a customer installs the product and it fails to do the one thing
    it advertises, this will lose all customer trust in the product. To mitigate this
    scenario, the sensor readings from the monitoring kit must be authentic. This
    means we must prevent the hub device from receiving false measurements from a
    spoofed kit.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的边缘机器学习解决方案的终端部分开始，包括监控套件本身及其与中心设备的连接。这个部分的极端情况是，一个不健康的设备被错误地报告为健康。如果客户安装了产品，但它未能完成其宣传的功能，这将失去所有客户对产品的信任。为了缓解这种情况，监控套件的传感器读数必须是真实的。这意味着我们必须防止中心设备从欺骗套件接收虚假测量值。
- en: Here, the best practice is to use some form of secret material that only the
    kit and the hub device understand. A secret can be a pre-shared key in a symmetrical
    cryptographic model, or it could be a public key and private key pair in an asymmetrical
    cryptographic model. If the kit can sign measurements sent to the hub device with
    a secret, then only the hub device can read them, and it will understand that
    it could only come from the device that it's paired with. Similarly, the monitoring
    kit would only act on messages, such as a request to update firmware, if those
    messages were signed by a secret it recognizes from the paired hub device.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最佳实践是使用只有套件和中心设备才能理解的某种形式的秘密材料。秘密可以是对称加密模型中的预共享密钥，也可以是非对称加密模型中的公钥和私钥对。如果套件可以使用秘密对发送到中心设备的测量结果进行签名，那么只有中心设备可以读取它们，并且它会理解这些结果只能来自与之配对的设备。同样，监控套件只会对消息采取行动，例如请求更新固件，如果这些消息是由它识别的配对中心设备签名的秘密。
- en: A safe design pattern for our pairing process between the monitoring kit and
    hub device is to task the customer with a manual step, such as a physical button
    press. This is similar to the Wi-Fi pairing method called **Wi-Fi Protected Setup**
    (**WPS**). If the customer has to manually start the pairing process, this means
    it is harder for an attacker to initiate communication with either the kit or
    the hub. If an attacker has physical access to the customer's premises to initiate
    pairing with their own device, this would be a much larger security breach that
    compromises our future product.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们监控套件和中心设备之间的配对过程设计一个安全的设计模式，是将手动步骤任务分配给客户，例如按下物理按钮。这与称为**Wi-Fi保护设置**（**WPS**）的Wi-Fi配对方法类似。如果客户必须手动启动配对过程，这意味着攻击者更难与套件或中心设备建立通信。如果攻击者能够物理访问客户的场所并使用自己的设备进行配对，这将是一个更大的安全漏洞，会损害我们未来的产品。
- en: IoT Greengrass provides a component called *secret manager* to help with this
    use case. The secret manager component can securely retrieve secret materials
    from the cloud through the AWS Secrets Manager service. You can build workflows
    into your edge solution, such as the monitoring kit pairing process, to establish
    a cryptographically verifiable relationship between your devices.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网Greengrass提供了一个名为*秘密管理器*的组件来帮助处理这种情况。秘密管理器组件可以通过AWS Secrets Manager服务从云中安全地检索秘密材料。您可以将工作流程构建到您的边缘解决方案中，例如监控套件的配对过程，以在您的设备之间建立可加密验证的关系。
- en: The gateway device
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网关设备
- en: 'The following list of risks and mitigations focus on the gateway device itself,
    which runs the IoT Greengrass Core software:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下风险和缓解措施列表专注于运行物联网Greengrass Core软件的网关设备：
- en: '**Secure connectivity to the cloud**: So, how do you ensure that the connection
    between the core device and the cloud service, such as AWS IoT Core, is secure?
    Well, here, the worst-case scenarios are that the messages exchanged have been
    accessed, tampered with, or delivered to a spoofed endpoint. The best practice,
    and the one built into IoT Greengrass, is to use a **public key infrastructure**
    (**PKI**) and mutual validation. PKI implements asymmetrical cryptography by generating
    private keys and public certificates. A recipient uses the public certificate
    to validate that the messages from the sender are authentic. In a mutual validation
    model, both ends of a connection use this structure to prove the authenticity
    of the other during the handshake. Devices that include a **Trusted Platform Module**
    (**TPM**), which comes with a private key securely stored in it, can generate
    certificates for use in PKI without ever exposing the private key.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全连接到云端**：那么，您如何确保核心设备与云服务（如AWS IoT Core）之间的连接是安全的呢？在这里，最坏的情况是交换的消息已被访问、篡改或发送到伪造的端点。最佳实践，也是物联网Greengrass内置的做法，是使用**公钥基础设施**（**PKI**）和相互验证。PKI通过生成私钥和公钥证书来实现非对称加密。接收者使用公钥证书来验证发送者的消息是真实的。在相互验证模型中，连接的两端都使用这种结构在握手过程中证明对方的真实性。包含**可信平台模块**（**TPM**）的设备，其中包含安全存储的私钥，可以在不暴露私钥的情况下为PKI生成证书。'
- en: '**Inbound network connections**: Any device on a network could be susceptible
    to receiving incoming connection requests. The worst-case scenario is that an
    attacker gains remote access to a system and starts probing the system or executing
    code. The best practice for establishing connections is to refuse inbound-initiated
    connections and rely on outbound, client-initiated connections instead.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入站网络连接**：网络上的任何设备都可能容易受到接收传入连接请求的影响。最坏的情况是，攻击者获得对系统的远程访问权限，并开始探测系统或执行代码。建立连接的最佳实践是拒绝入站发起的连接，并依赖出站、客户端发起的连接。'
- en: '**Boot tampering**: So, what happens if a device is physically modified between
    the point of manufacture and when a customer receives it? Well, malicious code
    could be loaded onto the device to be executed when it is received by the customer
    and added to the network. To prevent any tampering of the device, design your
    hardware platform with (or build on top of existing platforms that use) a TPM.
    A TPM can be used to validate that an encrypted disk has not been modified between
    boot sequences.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动篡改**：那么，如果设备在制造和客户收到它之间被物理修改，会发生什么情况呢？恶意代码可能会被加载到设备上，在客户收到设备并加入网络时执行。为了防止对设备的任何篡改，请使用TPM（可信平台模块）设计您的硬件平台（或构建在现有平台之上，这些平台使用TPM），TPM可以用来验证加密磁盘在启动序列之间没有被修改。'
- en: Edge components
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘组件
- en: 'Next, we will move on to the components that are running in your edge solution
    on the IoT Greengrass Core device:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续讨论在物联网Greengrass Core设备上运行的边缘解决方案组件：
- en: '**Component integrity on disk**: So, what happens if an attacker can access
    the component artifacts after they are deployed to the core device? The worst-case
    scenario is that valuable intellectual property is stolen or modified to change
    component behavior. In IoT Greengrass, all component resources such as artifacts
    and recipes are stored on disk as root. The working directories that components
    use for file I/O belong to the default component system user in the IoT Greengrass
    configuration or the override user that has been specified during deployment.
    The best practice is to protect the root and component system user access by limiting
    additional system users beyond what is needed for the components of the solution.
    If additional system users are required to be on the device, they should not belong
    to the same groups as your component users or have permissions to escalate privilege
    to the root configuration.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘上的组件完整性**：那么，如果攻击者在组件部署到核心设备之后能够访问组件工件，会发生什么情况呢？最坏的情况是，有价值的知识产权被窃取或修改以改变组件行为。在物联网Greengrass中，所有组件资源，如工件和食谱，都存储在磁盘上作为root。组件用于文件I/O的工作目录属于物联网Greengrass配置中的默认组件系统用户或部署期间指定的覆盖用户。最佳实践是限制除了解决方案组件所需之外的其他系统用户对root和组件系统用户访问的保护。如果需要在设备上使用额外的系统用户，他们不应属于与您的组件用户相同的组，也不应有权限提升到root配置的权限。'
- en: '`RequiresPrivilege` flag and then has full access to the core device. IoT Greengrass
    prevents this attack by computing a digest (that is, a mathematical summation
    for asserting the authenticity of a payload) whenever you upload and register
    a component. The core device will validate the digest against the component artifacts
    and fail if an artifact has been tampered with.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequiresPrivilege`标志然后对核心设备拥有完全访问权限。物联网Greengrass通过在您上传和注册组件时计算摘要（即，用于断言有效载荷真实性的数学求和）来防止这种攻击。核心设备将验证摘要与组件工件进行比较，如果工件被篡改，则失败。'
- en: '**Model poisoning**: So, what happens if an attacker compromises a model-backed
    decision-making process? For example, a camera feed using a local ML model to
    detect anomalous presence activity gets retrained with new data once a week. If
    an attacker understands the retraining loop, they can poison the training data
    over time with the intent of shifting the anomaly threshold to their advantage.
    To mitigate model poisoning, use **human-in-the-loop validation** to approve of
    new labeled data used in training. Human-in-the-loop validation means that you
    have a mechanism for your human experts to review unusual results, flagged results,
    or subsets of results as model quality assurance. Additionally, you can use a
    static approved training dataset to test later generations of models against their
    original success benchmark.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` wildcard, or sensitive topics, for explicit approval.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, this section covered a few high-risk security threats and the built-in mitigations
    provided by IoT Greengrass along with several best practices you can implement.
    Security at the edge is both complex and complicated. You can use threat modeling
    to identify the worst-case scenarios and best practices to mitigate those threats.
    In the next section, you will continue your journey as the HBS IoT architect by
    connecting two devices using components that deliver a simple sensor-to-actuator
    flow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your first device – sensing at the edge
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will deploy a new component that delivers the first sensing
    capability of your edge solution. In the context of our HBS appliance monitoring
    kit and hub device, this first component will represent the sensor of an appliance
    monitoring kit. The sensor reports to the hub device the measured temperature
    and humidity of an attached **heating, ventilation, and air conditioning** (**HVAC**)
    appliance. Sensor data will be written to a local topic using the IPC feature
    of IoT Greengrass. A later section will deploy another component that consumes
    this sensor data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Raspberry Pi and a Sense HAT for your edge device, the temperature
    and humidity measurements will be taken from the Sense HAT board. For any other
    project configurations, you will use a software data producer component to simulate
    measurements of new data. Component definitions for both paths are available in
    the GitHub repository, in the `chapter3` folder.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Both versions of the component have been written for the Python 3 runtime and
    defined using Python virtual environments to isolate dependencies. You will deploy
    one or the other using `greengrass-cli` to create a new local deployment that
    merges with the component. This chapter covers steps regarding how to install
    the component that reads from and writes to the Sense HAT. Any procedural differences
    for the data producer and consumer components are covered in the GitHub repository's
    `README.md` file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Installing the sensor component
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing this component is just like installing the `com.hbs.hub.HelloWorld`
    component from [*Chapter 2*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032),
    *Foundations of Edge Workloads*. You will use the IoT Greengrass CLI to merge
    in a predefined component using the `deployment` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安装此组件就像安装[*第2章*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032)中的`com.hbs.hub.HelloWorld`组件一样，*边缘工作负载基础*。你将使用IoT
    Greengrass CLI通过`deployment`命令合并一个预定义的组件：
- en: 'On your hub device (Raspberry Pi), clone the Git repository that contains the
    book''s companion resources:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的中心设备（树莓派）上，克隆包含书籍配套资源的Git仓库：
- en: '[PRE1]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Change directory into the cloned folder for `chapter3`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到克隆的`chapter3`文件夹：
- en: '[PRE2]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a deployment to include the `com.hbs.hub.ReadSenseHAT` component (or
    `com.hbs.hub.ReadSenseHATSimulated` if working on hardware other than a Raspberry
    Pi):'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个部署，包括`com.hbs.hub.ReadSenseHAT`组件（或在除树莓派以外的硬件上工作，请使用`com.hbs.hub.ReadSenseHATSimulated`）：
- en: '[PRE3]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can monitor the progress of the deployment in the log file:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在日志文件中监控部署的进度：
- en: '[PRE4]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the logs stop updating from the deployment, you can validate that the
    component was installed successfully:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当部署的日志停止更新时，你可以验证该组件是否已成功安装：
- en: '[PRE5]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should observe the `com.hbs.hub.ReadSenseHAT`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到`com.hbs.hub.ReadSenseHAT`。
- en: Now that the component has been installed, let's review the component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件已经安装，让我们来审查这个组件。
- en: Reviewing the sensor component
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查传感器组件
- en: Let's review some interesting bits from this sensor component so that you have
    a better idea of what's going on in this component. In this section, we will review
    a few highlights, starting with the recipe file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些来自这个传感器组件的有趣部分，以便你更好地了解这个组件中正在发生的事情。在本节中，我们将回顾一些亮点，从配方文件开始。
- en: IPC permissions
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPC权限
- en: 'In the `com.hbs.hub.ReadSenseHAT-1.0.0.json` section, we are using a new concept
    in the configuration called `accessControl`. This configuration defines the features
    of IoT Greengrass that the component is allowed to use. In this case, the recipe
    is defining a permission to use IPC and publish messages to any local topic. The
    operation is `aws.greengrass#PublishToTopic`, and the resource is the `*` wildcard,
    meaning the component is permitted to publish to any topic. In a later section,
    you will observe a different permission defined here to subscribe to IPC and receive
    the messages being published by this component. Here is the relevant section of
    the recipe file showing the `accessControl` configuration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`com.hbs.hub.ReadSenseHAT-1.0.0.json`部分，我们使用配置中的新概念`accessControl`。此配置定义了组件允许使用的IoT
    Greengrass功能。在这种情况下，配方定义了一个使用IPC并将消息发布到任何本地主题的权限。操作是`aws.greengrass#PublishToTopic`，资源是`*`通配符，意味着组件被允许发布到任何主题。在稍后的部分，你将观察到这里定义的不同权限，用于订阅IPC并接收此组件发布的消息。以下是显示`accessControl`配置的配方文件的相关部分：
- en: com.hbs.hub.ReadSenseHAT-1.0.0.json
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: com.hbs.hub.ReadSenseHAT-1.0.0.json
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding JSON snippet, you can see that the default configuration for
    this component includes the `accessControl` key. The first child of `accessControl`
    is a key that is used to describe which system permission we are setting. In this
    scenario, the permission is for the `aws.greengrass.ipc.pubsub` system. The next
    child key is a unique policy ID that must be unique across all of your components.
    The best practice is to use the format of *component name, system name or shorthand,
    and a counter*, all joined by colon characters. The list of operations includes
    just one permission for publishing messages, but it could also include the operation
    for subscribing. Finally, the list of resources indicates the explicit list of
    topics permitted for the preceding operations. In this scenario, we use the `*`
    wildcard for simplicity; however, a better practice for observing the principle
    of least privilege is to exhaustively enumerate topics.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的JSON片段中，你可以看到此组件的默认配置包括`accessControl`键。`accessControl`的第一个子键用于描述我们设置的哪个系统权限。在这个场景中，权限是针对`aws.greengrass.ipc.pubsub`系统的。下一个子键是一个唯一的策略ID，必须在所有组件中都是唯一的。最佳实践是使用*组件名称，系统名称或缩写，以及一个计数器*的格式，所有这些通过冒号字符连接。操作列表仅包括一个发布消息的权限，但它也可以包括订阅的操作。最后，资源列表表示允许执行先前操作的确切主题列表。在这个场景中，我们使用`*`通配符以简化；然而，为了观察最小权限原则，更好的做法是穷尽性地列出主题。
- en: Multiple life cycle steps
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个生命周期步骤
- en: 'In the simple `"Hello, world"` component, there was just a single life cycle
    step to invoke the shell script at runtime. In this component, you can see that
    we are using two different life cycle steps: install and run. Each life cycle
    step is processed at a different event in the IoT Greengrass component life cycle:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The **Bootstrap** step is evaluated when the component is first deployed or
    when a new version of the component is deployed. You should include instructions
    in the Bootstrap life cycle when you want Greengrass or the device to restart.
    This component doesn't require any restarts, so we exclude it from the recipe.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Install** step will run each time the component is launched, for example,
    after any time the device restarts and Greengrass is restarting components. Here,
    you should include instructions that install or configure dependencies before
    your main component code starts.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Bootstrap` and `Install` scripts have been completed successfully. Use
    the `Run` step to run an application or one-off activity.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another kind of life cycle step is the `Run` or `Startup` in a recipe, not both.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The IoT Greengrass Core software supports multiple life cycle events in order
    to provide flexible use of the component recipe model and component dependency
    graph. A complete definition of these life cycle events can be found in the *References*
    section, which is at the end of the chapter. The `Run`, `Install`, and `Startup`
    life cycle events are the most commonly used in component recipes.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the life cycle steps of this recipe:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: com.hbs.hub.ReadSenseHAT-1.0.0.json
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this recipe, we use the `Install` step to make system-level changes that
    require escalated permissions, such as making sure Python is installed. The `Install`
    step uses `pip` to install any Python libraries defined by the `requirements.txt`
    file in our component artifacts. Finally, the `Run` step invokes Python to start
    our program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Virtual environments
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this Python component, we are using a feature of Python 3 called virtual
    environments. A virtual environment allows you to specify an explicit version
    of the Python runtime to use when interpreting code. We use this to install any
    dependency libraries locally, so neither the dependencies nor runtime conflict
    with the system-level Python. This reinforces the best practice of applying isolation
    to our component. The relative invocation of `env/bin/python` is telling the script
    to use the virtual environment's version of Python instead of the one at the system
    level at `/usr/bin/python`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: This component uses a `requirements.txt` file to store information about the
    Python packages used and the versions of those packages to install. The requirements
    file is stored as an artifact of the component, along with the Python code file.
    Since it is an artifact, the command to `pip` must use the `{artifacts:path}`
    variable provided by IoT Greengrass to locate this file on disk.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'We could achieve even better isolation for our component in one of two ways:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**System-level Python runtime management**: We could use a more specific methodology
    to load Python runtimes onto the device and reference the version this component
    needs. There is a risk of using the system-level Python 3 runtime that the recipe
    installs in the Bootstrap script since another component could later install a
    different Python 3 runtime. The best practice would be to use further components
    as dependencies to install each specific runtime that our component requires access
    to. In this way, a component such as this one could depend on a component that
    installs Python 3.7 and another component could depend on a component that installs
    Python 3.9, without conflicting with each other.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerization**: Containers are a piece of technology used to enforce
    even stricter process and dependency isolation than a Python virtual environment.
    We could build and deploy our sensor component in a Docker container that includes
    the Python runtime, system packages, and Python libraries and perform any additional
    custom steps in a container environment before invoking our Python code. This
    would achieve the best level of isolation; however, it has the drawback of increased
    complexity to develop and requires more total disk space consumption to achieve
    that level of isolation. For a production environment, you, as the IoT architect,
    are responsible for making trade-offs on how much isolation is warranted for the
    additional overhead.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this HBS project is a prototype and we are using a Raspberry Pi device
    that comes with Python 3 preinstalled, it is within acceptable risk to simply
    ensure Python 3 is installed. A comprehensive isolation approach with containers
    for every component could fit, but the lighter-weight approach with Python virtual
    environments is sufficient at this prototype stage.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Permissions to Unix devices
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code that reads from your Sense HAT device uses the Sense HAT Python library
    to read values from the device files that the Unix kernel exposes as device interfaces.
    These device files, such as `/dev/i2c-1` and `/dev/input/event2`, are restricted
    to system users in groups such as `i2c` and `input`. The root user has access
    to these devices and a Raspberry Pi, and so does the default `pi` user. Our default
    component user, `ggc_user`, is not in these groups; therefore, code run as `ggc_user`
    will not be able to access values from these device interfaces. There are three
    ways to resolve this issue, which are listed as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: First, you could add `ggc_user` to the `i2c` and `input` groups using a system
    command such as `usermod -a -G i2c,input ggc_user`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, you could set the `RequiresPrivilege` flag in the component recipe's
    `Run` script to `true`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, you could override which system user the component should run at deployment
    time by adding the `--runWith COMPONENT:posixUser=USERNAME` flag. (This can be
    done with a configuration change in the deployment component in production components,
    which is covered in [*Chapter 4*](B17595_04_Final_SS_ePub.xhtml#_idTextAnchor073),
    *Extending the Cloud to the Edge*.)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best practice is to update the groups that the `ggc_user` component user
    is in. This reduces how often we use privileged access in our IoT Greengrass components
    and maintains our isolation principle by bundling the requirement in our recipe
    file. Running the component as the `pi` user isn''t bad; however, as a developer,
    you should not assume this user will exist on every device and have the necessary
    permissions just because they are operating system defaults. For convenience,
    here is another clip of the life cycle step that sets up our user permissions
    for `ggc_user`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: com.hbs.hub.ReadSenseHAT-1.0.0.json
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This covers the interesting new features used in the component recipe file.
    Next, let's take a deep dive into important bits of the code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A critical part of monitoring your components is to log important events. These
    lines set up a logger object that you can use throughout your Python code. This
    should be standard in every application:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: read_senseHAT.py
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When building Python applications for IoT Greengrass, you can copy lines such
    as these to Bootstrap logging. Note that your logger will capture logs at the
    `INFO` level or a level that is higher in criticality. Debug logs will not be
    captured unless you set the level to `logging.DEBUG`. You might set different
    levels of logs depending on where in the development life cycle you are, such
    as `DEBUG` in beta and `INFO` in production. You could set the logging level as
    a variable with component-level configuration and override it for a given deployment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Reading from Sense HAT
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `build_message` function is some simple code to initiate the Sense
    HAT interface and read values from its temperature and humidity sensors. These
    represent the values measured by our HBS appliance monitoring kit, attached to
    a fictional HVAC appliance:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Read_senseHAT.py
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code builds up a new object, called `message`, and sets child properties
    equal to the values we're getting from the Sense HAT library. The code also sets
    a simple device ID string, and generates the current timestamp.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a message
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will cover the key lines of code inside the `publish_message` function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: read_senseHAT.py
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These lines of code prepare the message and the request that will be communicated
    to the IPC service of IoT Greengrass as a new publish operation. This code will
    look familiar in any later components that require you to publish messages to
    other components running on the HBS hub device.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken a tour of the sensor application source code, let's examine
    what values you are measuring in the log file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Testing the sensor component
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To inspect the values that you are sampling from the sensor, you can tail the
    log file for this component. If you are using the `ReadSenseHATSimulated` component,
    make sure you inspect that log file instead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Tail the log file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should observe new entries in the log file with the temperature and humidity
    measurements sampled. These values are being logged and also published over IPC
    to any other components that are listening for them. You don't have any other
    components listening on IPC yet, so now is a great time to move on to your second
    component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your second device – actuating at the edge
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previously deployed component acts as a sensor to read values from a fictional
    appliance monitoring kit and publishes those values over IoT Greengrass IPC on
    a local topic. The next step is to create an actuator component that will respond
    to those published measurements and act upon them. Your actuator component will
    subscribe to the same local topic over IPC and render the sensor readings to the
    LED matrix of your Sense HAT board. For projects not using the Raspberry Pi with
    Sense HAT, the simulation actuator component will write measurements to a file
    as a proof of concept.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Installing the component
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous installation, you will create a deployment that merges
    with the new component. Please refer to the earlier steps for the location of
    the source files and validation steps that the deployment concluded. For projects
    not using the Raspberry Pi with the Sense HAT module, you will deploy the `com.hbs.hub.SimulatedActuator`
    component instead.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a deployment to include the `com.hbs.hub.WriteSenseHAT` component:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once deployed, you should start seeing messages appear on the LED matrix in
    the format of `t: 40.15 h:23.79`. These are the temperature and humidity values
    reported by your sensor component. The following photograph shows a snapshot of
    the LED matrix scrolling through the output message:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – A photograph of Sense HAT scrolling through reported sensor
    values'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_03_11.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – A photograph of Sense HAT scrolling through reported sensor values
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'If, at any point, you get tired of seeing the scrolling messages on your device,
    you can simply remove the `com.hbs.hub.WriteSenseHAT` component with a new deployment,
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Read on to learn how this component is structured.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the actuator component
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's review the interesting differences between this component and the sensor
    component.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Recipe file differences
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with the recipe file, there is only one key difference to observe.
    Here is a snippet of the recipe file that we''ll review:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: com.hbs.hub.WriteSenseHAT-1.0.0.json
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the recipe for `com.hbs.hub.WriteSenseHAT`, the `accessControl` permission
    specifies a different operation, `aws.greengrass#SubscribeToTopic`. This is the
    inverse of what we defined in the sensor component (`aws.greengrass#PublishToTopic`).
    This permission allows the component to set up topic subscriptions on IPC and
    receive messages published by other IPC clients, such as the sensor component.
    The following diagram shows the contrast of IPC permissions between a publishing
    sensor and a subscribing actuator:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – IPC permissions for the sensor and the actuator'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_03_12.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – IPC permissions for the sensor and the actuator
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, the resources list uses the `*` wildcard to indicate that
    the component can subscribe to any local topic. Following a principle of least
    privilege for a production solution, this list of resources would specify the
    explicit list of topics to which the component is allowed to publish or subscribe.
    Since this hub device is a prototype, the wildcard approach is acceptable. Each
    of the read and write components accept arguments to override the local topic
    used for your own experimentation (please check out the `main()` functions to
    learn more). Since any topic can be passed in as an override, this is another
    reason to use the wildcard resource with the component permissions. Recall that
    this is okay for developing and testing, but the best practice for production
    components would be to exhaustively specify the permitted topics for publishing
    and subscribing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the recipe file is essentially the same, with differences simply
    in the naming of the component and the Python file to invoke in the `Run` script.
    Also, note that we add a new user group to `ggc_user`; the `video` group enables
    access to the LED matrix. Next, let's review the interesting new lines of code
    from this component's Python file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages on IPC
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The business logic for receiving messages over IPC and writing messages to
    the LED matrix is coded in `scrolling_measurements.py`. Here are a few important
    sections to familiarize yourself with:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: scrolling_measurements.py
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this selection, you can observe that a new local class is defined, called
    `StreamHandler`. The `StreamHandler` class is responsible for implementing the
    behavior of IPC client subscription methods such as the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '`on_stream_event` is the handler defining what to do when a new message arrives.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_stream_error` is the handler defining what to do when the subscription
    encounters an error.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_stream_close` is the handler defining how to clean up any resources when
    the subscription is closed.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the sensor component is publishing messages in JSON format, you can see
    that it is easy to get the value of that payload with `event.json_message.message`.
    Following this, the `on_stream_event` handler retrieves the values for both the
    `temperature` and `humidity` keys and sends a string to the `scroll_message` function.
    Here is the code for that function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: scrolling_measurements.py
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's it! You can view how easy it is to work with the Sense HAT library. The
    library provides the logic to manipulate the LED matrix into a scrolling wall
    of text. There are additional functions in the library for more fine-grained control
    of the LED matrix if scrolling a text message is too specific an action. You might
    want to render a solid color, a simple bitmap, or create an animation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In this pair of components, the messages transmitted over IPC use the JSON specification.
    This is a clean default for device software that can use JSON libraries since
    it reduces the code we have to write for serializing and deserializing messages
    over the wire. Additionally, using JSON payloads will reduce code for components
    that will exchange messages with the cloud via the AWS IoT Core service. This
    service also defaults to JSON payloads. However, both the IPC feature of IoT Greengrass
    and the AWS IoT Core service support sending messages with binary payloads.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In the context of the HBS hub device and appliance monitoring kit, the Raspberry
    Pi and its Sense HAT board are pulling double duty when it comes to representing
    both devices in our prototype model. It would be impractical to ask customers
    to review scrolling text on a screen attached to either device. In reality, the
    solution would only notify customers of an important event and not signal each
    time the measurements are taken. However, this pattern of sensor and actuator
    communicating through a decoupled interface of IPC topics and messages illustrates
    a core concept that we will use throughout the rest of the edge solutions built
    in this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the topologies that are common in building
    edge ML solutions and how they relate to the constraints and requirements informing
    architectural decisions. You learned about the common protocols used in exchanging
    messages throughout the edge and to the cloud, and why those protocols are used
    today. You learned how to evaluate an edge ML solution for security risks and
    the best practices for mitigating those risks. Additionally, you delivered your
    first multi-component edge solution that maps sensor readings to an actuator using
    a decoupled interface.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the basics of building for the edge, the next chapter
    will introduce how to build and deploy for the edge using cloud services and a
    remote deployment tool. In addition to this, you will deploy your first ML component
    using a precompiled model.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge check
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving on to the next chapter, test your knowledge by answering these
    questions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The answers can be found at the end of the book:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: What are three network topologies that are common in edge solutions? Which one
    is implemented by the HBS hub device and appliance monitoring kit?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: IoT Greengrass operates at the physical layer (that is, layer
    1) of the OSI model.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using a publish/subscribe model to exchange messages?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: IoT Greengrass can act as both a messaging client and a messaging
    broker.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Is a message such as `{"temperature": 70}` an example of structured data or
    unstructured data? Is it serializable?'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is image data captured from a camera an example of structured data or unstructured
    data? Is it serializable?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you think is the worst-case scenario if your home network router was
    compromised by an attacker but was still processing traffic as normal?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a mitigation strategy for verifying authenticity between two network
    devices?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to protect root access via privilege escalation on a gateway
    device?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there any downside to wrapping every edge component in a container?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functionality does IoT Greengrass provide to allow components to exchange
    messages?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is one way to make the sensor and actuator solution you deployed in this
    chapter more secure? (Hint: review the recipe files!)'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How might you redesign the sensor and actuator solution if you required a third
    component to interpret the sensor results before sending a message to the actuator?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following resources for additional information on the concepts
    discussed in this chapter:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '*The STRIDE Threat Model*: [https://docs.microsoft.com/en-us/previous-versions/commerce-server/ee823878(v=cs.20)?redirectedfrom=MSDN](https://docs.microsoft.com/en-us/previous-versions/commerce-server/ee823878(v=cs.20)?redirectedfrom=MSDN)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OSI model*: [https://en.wikipedia.org/wiki/OSI_model](https://en.wikipedia.org/wiki/OSI_model)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ISA95, Enterprise-Control System Integration*: [https://www.isa.org/standards-and-publications/isa-standards/isa-standards-committees/isa95](https://www.isa.org/standards-and-publications/isa-standards/isa-standards-committees/isa95)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PEP 405 -- Python Virtual Environments*: [https://www.python.org/dev/peps/pep-0405/](https://www.python.org/dev/peps/pep-0405/%20%0D)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Open Container Initiative*: [https://opencontainers.org/](https://opencontainers.org/)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker: [https://www.docker.com/](https://www.docker.com/)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AWS IoT Greengrass component recipe reference*: [https://docs.aws.amazon.com/greengrass/v2/developerguide/component-recipe-reference.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/component-recipe-reference.html)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
