["```py\ndistanceInCentimeters = 4042 * (objectSizeInPixels ^ -1.2)  \n```", "```py\nimport math\n\ndef hueFromBGR(color):\n    b, g, r = color\n    # Note: sqrt(3) = 1.7320508075688772\n    hue = math.degrees(math.atan2(\n        1.7320508075688772 * (g - b), 2 * r - g - b))\n    if hue < 0.0:\n        hue += 360.0\n    return hue\n\ndef saturationFromBGR(color):\n    return max(color) - min(color)\n```", "```py\nhslImage = cv2.cvtColor(bgrImage, cv2.COLOR_BGR2HLS)\n\nhsvImage = cv2.cvtColor(bgrImage, cv2.COLOR_BGR2HSV)\n```", "```py\nimport math\n\ndef dist2D(p0, p1):\n    deltaX = p1[0] - p0[0]\n    deltaY = p1[1] - p0[1]\n    return math.sqrt(deltaX * deltaX +\n                     deltaY * deltaY)\n```", "```py\ndist = numpy.linalg.norm(a1 - a0)\n```", "```py\n#!/usr/bin/env python\n\nimport numpy\nimport cv2\nimport os\nimport threading\nimport wx\n\ntry:\n   import cPickle as pickle\nexcept:\n   import pickle\n\nimport ColorUtils\nimport GeomUtils\nimport PyInstallerUtils\nimport ResizeUtils\nimport WxUtils\n```", "```py\nCOLOR_Red =         ((  0,   0, 255), 'red')\nCOLOR_YellowWhite = ((223, 247, 255), 'yellowish white')\nCOLOR_AmberYellow = ((  0, 191, 255), 'amber or yellow')\nCOLOR_Green =       ((128, 255, 128), 'green')\nCOLOR_BlueWhite =   ((255, 231, 223), 'bluish white')\nCOLOR_BluePurple =  ((255,  64,   0), 'blue or purple')\nCOLOR_Pink =        ((240, 128, 255), 'pink')\n```", "```py\nclass LivingHeadlights(wx.Frame):\n\n    def __init__(self, configPath, thresholdStep=8.0,\n                 minThreshold=191.0, maxThreshold=255.0,\n                 minRepeatability=2,\n                 minDistBetweenBlobsProportional=0.02,\n                 minBlobAreaProportional=0.005,\n                 maxBlobAreaProportional=0.1,\n                 minBlobCircularity=0.7, cameraDeviceID=0,\n                 imageSize=(640, 480),\n                 title='The Living Headlights'):\n```", "```py\n        self.mirrored = True\n\n        self._running = True\n```", "```py\n        self._configPath = configPath\n        self._pixelDistBetweenLights = None\n        if os.path.isfile(configPath):\n            with open(self._configPath, 'rb') as file:\n                self._referencePixelDistBetweenLights = \\\n                        pickle.load(file)\n                self._referenceMetersToCamera = \\\n                        pickle.load(file)\n                self._convertMetersToFeet = pickle.load(file)\n        else:\n            self._referencePixelDistBetweenLights = None\n            self._referenceMetersToCamera = None\n            self._convertMetersToFeet = False\n```", "```py\n        self._capture = cv2.VideoCapture(cameraDeviceID)\n        size = ResizeUtils.cvResizeCapture(\n                self._capture, imageSize)\n        w, h = size\n        self._imageWidth, self._imageHeight = w, h\n```", "```py\n        self._image = None\n        self._grayImage = None\n\n        self._imageFrontBuffer = None\n        self._imageFrontBufferLock = threading.Lock()\n```", "```py\n        minDistBetweenBlobs = \\\n                min(w, h) * \\\n                minDistBetweenBlobsProportional\n\n        area = w * h\n        minBlobArea = area * minBlobAreaProportional\n        maxBlobArea = area * maxBlobAreaProportional\n\n        detectorParams = cv2.SimpleBlobDetector_Params()\n\n        detectorParams.minDistBetweenBlobs = \\\n                minDistBetweenBlobs\n\n        detectorParams.thresholdStep = thresholdStep\n        detectorParams.minThreshold = minThreshold\n        detectorParams.maxThreshold = maxThreshold\n\n        detectorParams.minRepeatability = minRepeatability\n\n        detectorParams.filterByArea = True\n        detectorParams.minArea = minBlobArea\n        detectorParams.maxArea = maxBlobArea\n\n        detectorParams.filterByColor = True\n        detectorParams.blobColor = 255\n\n        detectorParams.filterByCircularity = True\n        detectorParams.minCircularity = minBlobCircularity\n\n        detectorParams.filterByInertia = False\n\n        detectorParams.filterByConvexity = False\n\n        self._detector = cv2.SimpleBlobDetector_create(\n                detectorParams)\n```", "```py\n        style = wx.CLOSE_BOX | wx.MINIMIZE_BOX | \\\n                wx.CAPTION | wx.SYSTEM_MENU | \\\n                wx.CLIP_CHILDREN\n        wx.Frame.__init__(self, None, title=title,\n                          style=style, size=size)\n        self.SetBackgroundColour(wx.Colour(232, 232, 232))\n```", "```py\n        self.Bind(wx.EVT_CLOSE, self._onCloseWindow)\n\n        quitCommandID = wx.NewId()\n        self.Bind(wx.EVT_MENU, self._onQuitCommand,\n                  id=quitCommandID)\n        acceleratorTable = wx.AcceleratorTable([\n            (wx.ACCEL_NORMAL, wx.WXK_ESCAPE,\n             quitCommandID)\n        ])\n        self.SetAcceleratorTable(acceleratorTable)\n```", "```py\n        self._videoPanel = wx.Panel(self, size=size)\n        self._videoPanel.Bind(\n                wx.EVT_ERASE_BACKGROUND,\n                self._onVideoPanelEraseBackground)\n        self._videoPanel.Bind(\n                wx.EVT_PAINT, self._onVideoPanelPaint)\n\n        self._videoBitmap = None\n\n        self._calibrationTextCtrl = wx.TextCtrl(\n                self, style=wx.TE_PROCESS_ENTER)\n        self._calibrationTextCtrl.Bind(\n                wx.EVT_KEY_UP,\n                self._onCalibrationTextCtrlKeyUp)\n\n        self._distanceStaticText = wx.StaticText(self)\n        if self._referencePixelDistBetweenLights is None:\n            self._showInstructions()\n        else:\n            self._clearMessage()\n\n        self._calibrationButton = wx.Button(\n                self, label='Calibrate')\n        self._calibrationButton.Bind(\n                wx.EVT_BUTTON, self._calibrate)\n        self._calibrationButton.Disable()\n\n        border = 12\n\n        metersButton = wx.RadioButton(self,\n                                      label='Meters')\n        metersButton.Bind(wx.EVT_RADIOBUTTON,\n                          self._onSelectMeters)\n\n        feetButton = wx.RadioButton(self, label='Feet')\n        feetButton.Bind(wx.EVT_RADIOBUTTON,\n                        self._onSelectFeet)\n```", "```py\n        if self._convertMetersToFeet:\n            feetButton.SetValue(True)\n        else:\n            metersButton.SetValue(True)\n```", "```py\n        unitButtonsSizer = wx.BoxSizer(wx.VERTICAL)\n        unitButtonsSizer.Add(metersButton)\n        unitButtonsSizer.Add(feetButton)\n```", "```py\n        controlsSizer = wx.BoxSizer(wx.HORIZONTAL)\n        style = wx.ALIGN_CENTER_VERTICAL | wx.RIGHT\n        controlsSizer.Add(self._calibrationTextCtrl, 0,\n                          style, border)\n        controlsSizer.Add(unitButtonsSizer, 0, style,\n                          border)\n        controlsSizer.Add(self._calibrationButton, 0,\n                          style, border)\n        controlsSizer.Add(self._distanceStaticText, 0,\n                          wx.ALIGN_CENTER_VERTICAL)\n```", "```py\n        rootSizer = wx.BoxSizer(wx.VERTICAL)\n        rootSizer.Add(self._videoPanel)\n        rootSizer.Add(controlsSizer, 0,\n                      wx.EXPAND | wx.ALL, border)\n        self.SetSizerAndFit(rootSizer)\n```", "```py\n        self._captureThread = threading.Thread(\n                target=self._runCaptureLoop)\n        self._captureThread.start()\n```", "```py\n    def _onCloseWindow(self, event):\n        self._running = False\n        self._captureThread.join()\n        configDir = os.path.dirname(self._configPath)\n        if not os.path.isdir(configDir):\n            os.makedirs(configDir)\n        with open(self._configPath, 'wb') as file:\n            pickle.dump(self._referencePixelDistBetweenLights,\n                        file)\n            pickle.dump(self._referenceMetersToCamera, file)\n            pickle.dump(self._convertMetersToFeet, file)\n        self.Destroy()\n```", "```py\n    def _onQuitCommand(self, event):\n        self.Close()\n```", "```py\n    def _onVideoPanelEraseBackground(self, event):\n        pass\n\n    def _onVideoPanelPaint(self, event):\n\n        self._imageFrontBufferLock.acquire()\n\n        if self._imageFrontBuffer is None:\n            self._imageFrontBufferLock.release()\n            return\n\n        # Convert the image to bitmap format.\n        self._videoBitmap = \\\n                WxUtils.wxBitmapFromCvImage(self._imageFrontBuffer)\n\n        self._imageFrontBufferLock.release()\n\n        # Show the bitmap.\n        dc = wx.BufferedPaintDC(self._videoPanel)\n        dc.DrawBitmap(self._videoBitmap, 0, 0)\n```", "```py\n    def _onSelectMeters(self, event):\n        self._convertMetersToFeet = False\n\n    def _onSelectFeet(self, event):\n        self._convertMetersToFeet = True\n```", "```py\n    def _onCalibrationTextCtrlKeyUp(self, event):\n        self._enableOrDisableCalibrationButton()\n```", "```py\n    def _calibrate(self, event):\n        self._referencePixelDistBetweenLights = \\\n                self._pixelDistBetweenLights\n        s = self._calibrationTextCtrl.GetValue()\n        self._calibrationTextCtrl.SetValue('')\n        self._referenceMetersToCamera = float(s)\n        if self._convertMetersToFeet:\n            self._referenceMetersToCamera *= 0.3048\n```", "```py\n    def _runCaptureLoop(self):\n        while self._running:\n            success, self._image = self._capture.read(\n                    self._image)\n            if self._image is not None:\n                self._detectAndEstimateDistance()\n                if (self.mirrored):\n                    self._image[:] = numpy.fliplr(self._image)\n\n                # Perform a thread-safe swap of the front and\n                # back image buffers.\n                self._imageFrontBufferLock.acquire()\n                self._imageFrontBuffer, self._image = \\\n                        self._image, self._imageFrontBuffer\n                self._imageFrontBufferLock.release()\n\n                # Send a refresh event to the video panel so\n                # that it will draw the image from the front\n                # buffer.\n                self._videoPanel.Refresh()\n```", "```py\n    def _detectAndEstimateDistance(self):\n\n        self._grayImage = cv2.cvtColor(\n                self._image, cv2.COLOR_BGR2GRAY,\n                self._grayImage)\n        blobs = self._detector.detect(self._grayImage)\n        blobsForColors = {}\n```", "```py\n        for blob in blobs:\n\n            centerXAsInt, centerYAsInt = \\\n                    (int(n) for n in blob.pt)\n            radiusAsInt = int(blob.size)\n\n            minX = max(0, centerXAsInt - radiusAsInt)\n            maxX = min(self._imageWidth,\n                       centerXAsInt + radiusAsInt)\n            minY = max(0, centerYAsInt - radiusAsInt)\n            maxY = min(self._imageHeight,\n                       centerYAsInt + radiusAsInt)\n\n            region = self._image[minY:maxY, minX:maxX]\n```", "```py\n            # Get the region's dimensions, which may\n            # differ from the blob's diameter if the blob\n            # extends past the edge of the image.\n            h, w = region.shape[:2]\n\n            meanColor = region.reshape(w * h, 3).mean(0)\n            meanHue = ColorUtils.hueFromBGR(meanColor)\n            meanSaturation = ColorUtils.saturationFromBGR(\n                    meanColor)\n\n            if meanHue < 22.5 or meanHue > 337.5:\n                color = COLOR_Red\n            elif meanHue < 67.5:\n                if meanSaturation < 25.0:\n                    color = COLOR_YellowWhite\n                else:\n                    color = COLOR_AmberYellow\n            elif meanHue < 172.5:\n                color = COLOR_Green\n            elif meanHue < 277.5:\n                if meanSaturation < 25.0:\n                    color = COLOR_BlueWhite\n                else:\n                    color = COLOR_BluePurple\n            else:\n                color = COLOR_Pink\n\n            if color in blobsForColors:\n                blobsForColors[color] += [blob]\n            else:\n                blobsForColors[color] = [blob]\n```", "```py\n        self._processBlobsForColors(blobsForColors)\n        self._enableOrDisableCalibrationButton()\n```", "```py\n    def _processBlobsForColors(self, blobsForColors):\n\n        self._pixelDistBetweenLights = None\n\n        for color in blobsForColors:\n\n            prevBlob = None\n\n            for blob in blobsForColors[color]:\n\n                colorBGR, colorName = color\n\n                centerAsInts = \\\n                        tuple(int(n) for n in blob.pt)\n                radiusAsInt = int(blob.size)\n\n                # Fill the circle with the selected color.\n                cv2.circle(self._image, centerAsInts,\n                           radiusAsInt, colorBGR,\n                           cv2.FILLED, cv2.LINE_AA)\n                # Outline the circle in black.\n                cv2.circle(self._image, centerAsInts,\n                           radiusAsInt, (0, 0, 0), 1,\n                           cv2.LINE_AA)\n\n                if prevBlob is not None:\n\n                    if self._pixelDistBetweenLights is \\\n                            None:\n                        self._pixelDistBetweenLights = \\\n                                GeomUtils.dist2D(blob.pt,\n                                             prevBlob.pt)\n                        wx.CallAfter(self._showDistance,\n                                     colorName)\n\n                    prevCenterAsInts = \\\n                        tuple(int(n) for n in prevBlob.pt)\n\n                    # Connect the current and previous\n                    # circle with a black line.\n                    cv2.line(self._image, prevCenterAsInts,\n                             centerAsInts, (0, 0, 0), 1,\n                             cv2.LINE_AA)\n\n                prevBlob = blob\n```", "```py\n    def _enableOrDisableCalibrationButton(self):\n        s = self._calibrationTextCtrl.GetValue()\n        if len(s) < 1 or \\\n                self._pixelDistBetweenLights is None:\n            self._calibrationButton.Disable()\n        else:\n            # Validate that the input is a number.\n            try:\n                float(s)\n                self._calibrationButton.Enable()\n            except:\n                self._calibrationButton.Disable()\n```", "```py\n    def _showInstructions(self):\n        self._showMessage(\n                'When a pair of lights is highlighted, '\n                'enter the\\ndistance and click '\n                '\"Calibrate\".')\n```", "```py\n    def _showDistance(self, colorName):\n        if self._referenceMetersToCamera is None:\n            return\n        value = self._referenceMetersToCamera * \\\n                self._referencePixelDistBetweenLights / \\\n                self._pixelDistBetweenLights\n        if self._convertMetersToFeet:\n            value /= 0.3048\n            unit = 'feet'\n        else:\n            unit = 'meters'\n        self._showMessage(\n                'A pair of %s lights was spotted\\nat '\n                '%.2f %s.' % \\\n                (colorName, value, unit))\n```", "```py\n    def _clearMessage(self):\n        # Insert an endline for consistent spacing.\n        self._showMessage('\\n')\n```", "```py\n    def _showMessage(self, message):\n        self._distanceStaticText.SetLabel(message)\n```", "```py\ndef main():\n    app = wx.App()\n    configPath = PyInstallerUtils.resourcePath(\n            'config.dat')\n    livingHeadlights = LivingHeadlights(configPath)\n    livingHeadlights.Show()\n    app.MainLoop()\n\nif __name__ == '__main__':\n    main()\n```"]