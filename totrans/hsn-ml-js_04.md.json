["```py\n/**\n * @param {Array.<number>} numbers\n * @return {float}\n */\nfunction mean(numbers) {\n    var sum = 0, length = numbers.length;\n\n    if (length === 0) {\n        /**\n         * Mathematically, the mean of an empty set is undefined,\n         * so we could return early here. We could also allow the function\n         * to attempt dividing 0/0, would would return NaN in JavaScript but\n         * fail in some other languages (so probably a bad habit to encourage).\n         * Ultimately, I would like this function to not return mixed types,\n         * so instead let's throw an error.\n         */\n        throw new Error('Cannot calculate mean of empty set');\n    }\n\n    for (var i = 0; i < length; i++) {\n        sum += numbers[i];\n    }\n\n    return sum / length;\n}\n```", "```py\nconst mean = numbers => numbers.reduce((sum, val) => sum + val, 0) / numbers.length;\n```", "```py\nconst sum = (numbers) => numbers.reduce((sum, val) => sum + val, 0);\nconst mean = (numbers) => sum(numbers) / numbers.length;\n```", "```py\n/**\n * Calculates only the 2-dimensional distance between two points a and b.\n * Each point should be an array with length = 2, and both elements defined and numeric.\n * @param {Array.number} a\n * @param {Array.number} b\n * @return {float}\n */\nfunction distance2d(a, b) {\n    // Difference between b[0] and a[0]\n    var diff_0 = b[0] - a[0];\n    // Difference between b[1] and a[1]\n    var diff_1 = b[1] - a[1];\n\n    return Math.sqrt(diff_0*diff_0 + diff_1*diff_1);\n}\n```", "```py\n/**\n * Calculates the N-dimensional distance between two points a and b.\n * Each point should be an array with equal length, and all elements defined and numeric.\n * @param {Array.number} a\n * @param {Array.number} b\n * @return {float}\n */\nfunction distance(a, b) {\n\n    var length = a.length,\n        sumOfSquares = 0;\n\n    if (length !== b.length) {\n        throw new Error('Points a and b must be the same length');\n    }\n\n    for (var i = 0; i < length; i++) {\n        var diff = b[i] - a[i];\n        sumOfSquares += diff*diff;\n    }\n\n    return Math.sqrt(sumOfSquares);\n}\n```", "```py\nconst distance = (a, b) => Math.sqrt(\n    a.map((aPoint, i) => b[i] - aPoint)\n     .reduce((sumOfSquares, diff) => sumOfSquares + (diff*diff), 0)\n);\n```", "```py\n{\n  \"name\": \"Ch4-kmeans\",\n  \"version\": \"1.0.0\",\n  \"description\": \"ML in JS Example for Chapter 4 - kmeans\",\n  \"main\": \"src/index.js\",\n  \"author\": \"Burak Kanber\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"build-web\": \"browserify src/index.js -o dist/index.js -t [ babelify --presets [ env ] ]\",\n    \"build-cli\": \"browserify src/index.js --node -o dist/index.js -t [ babelify --presets [ env ] ]\",\n    \"start\": \"yarn build-cli && node dist/index.js\"\n  },\n  \"dependencies\": {\n    \"babel-core\": \"^6.26.0\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"babelify\": \"^8.0.0\",\n    \"browserify\": \"^15.1.0\"\n  }\n}\n```", "```py\n/**\n * Calculate the mean of an array of numbers.\n * @param {Array.<number>} numbers\n * @return {number}\n */\nconst mean = numbers => numbers.reduce((sum, val) => sum + val, 0) / numbers.length;\n\n/**\n * Calculate the distance between two points.\n * Points must be given as arrays or objects with equivalent keys.\n * @param {Array.<number>} a\n * @param {Array.<number>} b\n * @return {number}\n */\nconst distance = (a, b) => Math.sqrt(\n    a.map((aPoint, i) => b[i] - aPoint)\n     .reduce((sumOfSquares, diff) => sumOfSquares + (diff*diff), 0)\n);\n```", "```py\nclass KMeans {\n\n    /**\n     * @param k\n     * @param data\n     */\n    constructor(k, data) {\n        this.k = k;\n        this.data = data;\n        this.reset();\n    }\n\n    /**\n     * Resets the solver state; use this if you wish to run the\n     * same solver instance again with the same data points\n     * but different initial conditions.\n     */\n    reset() {\n        this.error = null;\n        this.iterations = 0;\n        this.iterationLogs = [];\n        this.centroids = this.initRandomCentroids();\n        this.centroidAssignments = [];\n    }\n\n}\n\nexport default KMeans;\n```", "```py\n/**\n * Determines the number of dimensions in the dataset.\n * @return {number}\n */\ngetDimensionality() {\n    const point = this.data[0];\n    return point.length;\n}\n```", "```py\n\n/**\n * For a given dimension in the dataset, determine the minimum\n * and maximum value. This is used during random initialization\n * to make sure the random centroids are in the same range as\n * the data.\n *\n * @param n\n * @returns {{min: *, max: *}}\n */\ngetRangeForDimension(n) {\n    const values = this.data.map(point => point[n]);\n    return {\n        min: Math.min.apply(null, values),\n        max: Math.max.apply(null, values)\n    };\n}\n```", "```py\n/**\n * Get ranges for all dimensions.\n * @see getRangeForDimension\n * @returns {Array} Array whose indices are the dimension number and whose members are the output of getRangeForDimension\n */\ngetAllDimensionRanges() {\n    const dimensionRanges = [];\n    const dimensionality = this.getDimensionality();\n\n    for (let dimension = 0; dimension < dimensionality; dimension++) {\n        dimensionRanges[dimension] = this.getRangeForDimension(dimension);\n    }\n\n    return dimensionRanges;\n\n}\n```", "```py\n\n/**\n * Initializes random centroids, using the ranges of the data\n * to set minimum and maximum bounds for the centroids.\n * You may inspect the output of this method if you need to debug\n * random initialization, otherwise this is an internal method.\n * @see getAllDimensionRanges\n * @see getRangeForDimension\n * @returns {Array}\n */\ninitRandomCentroids() {\n\n    const dimensionality = this.getDimensionality();\n    const dimensionRanges = this.getAllDimensionRanges();\n    const centroids = [];\n\n    // We must create 'k' centroids.\n    for (let i = 0; i < this.k; i++) {\n\n        // Since each dimension has its own range, create a placeholder at first\n        let point = [];\n\n        /**\n         * For each dimension in the data find the min/max range of that dimension,\n         * and choose a random value that lies within that range. \n         */\n        for (let dimension = 0; dimension < dimensionality; dimension++) {\n            const {min, max} = dimensionRanges[dimension];\n            point[dimension] = min + (Math.random()*(max-min));\n        }\n\n        centroids.push(point);\n\n    }\n\n    return centroids;\n\n}\n```", "```py\nconst example_randomCentroids = [\n    [1, 3], [5, 8], [3, 0]\n];\n\nexport default {\n    example_randomCentroids\n};\n```", "```py\nimport KMeans from './kmeans.js';\nimport example_data from './data.js';\n\nconsole.log(\"\\nML in JS Chapter 4 k-means clustering examples.\");\nconsole.log(\"===============================================\\n\");\n\nconsole.log(\"Testing centroid generation:\");\nconsole.log(\"===============================================\\n\");\n\nconst ex_randomCentroids_solver = new KMeans(2, example_data.example_randomCentroids);\n\nconsole.log(\"Randomly initialized centroids: \");\nconsole.log(ex_randomCentroids_solver.centroids);\nconsole.log(\"\\n-----------------------------------------------\\n\\n\");\n```", "```py\n$ yarn start\nyarn run v1.3.2\n$ yarn build-cli && node dist/index.js\n$ browserify src/index.js --node -o dist/index.js -t [ babelify --presets [ env ] ]\n\n ML in JS Chapter 4 k-means clustering examples.\n ===============================================\n\n Testing centroid generation:\n ===============================================\n\n Randomly initialized centroids:\n [ [ 4.038663181817283, 7.765675509733137 ],\n [ 1.976405159755187, 0.026837564634993427 ] ]\n```", "```py\n/**\n * Given a point in the data to consider, determine the closest\n * centroid and assign the point to that centroid.\n * The return value of this method is a boolean which represents\n * whether the point's centroid assignment has changed;\n * this is used to determine the termination condition for the algorithm.\n * @param pointIndex\n * @returns {boolean} Did the point change its assignment?\n */\nassignPointToCentroid(pointIndex) {\n\n    const lastAssignedCentroid = this.centroidAssignments[pointIndex];\n    const point = this.data[pointIndex];\n    let minDistance = null;\n    let assignedCentroid = null;\n\n    for (let i = 0; i < this.centroids.length; i++) {\n        const centroid = this.centroids[i];\n        const distanceToCentroid = distance(point, centroid);\n\n        if (minDistance === null || distanceToCentroid < minDistance) {\n            minDistance = distanceToCentroid;\n            assignedCentroid = i;\n        }\n\n    }\n\n    this.centroidAssignments[pointIndex] = assignedCentroid;\n\n    return lastAssignedCentroid !== assignedCentroid;\n\n}\n```", "```py\n/**\n * For all points in the data, call assignPointsToCentroids\n * and returns whether _any_ point's centroid assignment has\n * been updated.\n *\n * @see assignPointToCentroid\n * @returns {boolean} Was any point's centroid assignment updated?\n */\nassignPointsToCentroids() {\n    let didAnyPointsGetReassigned = false;\n    for (let i = 0; i < this.data.length; i++) {\n        const wasReassigned = this.assignPointToCentroid(i);\n        if (wasReassigned) didAnyPointsGetReassigned = true;\n    }\n    return didAnyPointsGetReassigned;\n}\n```", "```py\n/**\n * Given a centroid to consider, returns an array\n * of all points assigned to that centroid.\n *\n * @param centroidIndex\n * @returns {Array}\n */\ngetPointsForCentroid(centroidIndex) {\n    const points = [];\n    for (let i = 0; i < this.data.length; i++) {\n        const assignment = this.centroidAssignments[i];\n        if (assignment === centroidIndex) {\n            points.push(this.data[i]);\n        }\n    }\n    return points;\n}\n```", "```py\n/**\n * Given a centroid to consider, update its location to\n * the mean value of the positions of points assigned to it.\n * @see getPointsForCentroid\n * @param centroidIndex\n * @returns {Array}\n */\nupdateCentroidLocation(centroidIndex) {\n    const thisCentroidPoints = this.getPointsForCentroid(centroidIndex);\n    const dimensionality = this.getDimensionality();\n    const newCentroid = [];\n    for (let dimension = 0; dimension < dimensionality; dimension++) {\n        newCentroid[dimension] = mean(thisCentroidPoints.map(point => point[dimension]));\n    }\n    this.centroids[centroidIndex] = newCentroid;\n    return newCentroid;\n}\n```", "```py\n/**\n * For all centroids, call updateCentroidLocation\n */\nupdateCentroidLocations() {\n    for (let i = 0; i < this.centroids.length; i++) {\n        this.updateCentroidLocation(i);\n    }\n}\n```", "```py\n/**\n * Calculates the total \"error\" for the current state\n * of centroid positions and assignments.\n * Here, error is defined as the root-mean-squared distance\n * of all points to their centroids.\n * @returns {Number}\n */\ncalculateError() {\n\n    let sumDistanceSquared = 0;\n    for (let i = 0; i < this.data.length; i++) {\n        const centroidIndex = this.centroidAssignments[i];\n        const centroid = this.centroids[centroidIndex];\n        const point = this.data[i];\n        const thisDistance = distance(point, centroid);\n        sumDistanceSquared += thisDistance*thisDistance;\n    }\n\n    this.error = Math.sqrt(sumDistanceSquared / this.data.length);\n    return this.error;\n}\n```", "```py\n/**\n * Run the k-means algorithm until either the solver reaches steady-state,\n * or the maxIterations allowed has been exceeded.\n *\n * The return value from this method is an object with properties:\n * {\n *  centroids {Array.<Object>},\n *  iteration {number},\n *  error {number},\n *  didReachSteadyState {Boolean}\n * }\n *\n * You are most likely interested in the centroids property of the output.\n *\n * @param {Number} maxIterations Default 1000\n * @returns {Object}\n */\nsolve(maxIterations = 1000) {\n\n    while (this.iterations < maxIterations) {\n\n        const didAssignmentsChange = this.assignPointsToCentroids();\n        this.updateCentroidLocations();\n        this.calculateError();\n\n        this.iterationLogs[this.iterations] = {\n            centroids: [...this.centroids],\n            iteration: this.iterations,\n            error: this.error,\n            didReachSteadyState: !didAssignmentsChange\n        };\n\n        if (didAssignmentsChange === false) {\n            break;\n        }\n\n        this.iterations++;\n\n    }\n\n    return this.iterationLogs[this.iterationLogs.length - 1];\n\n}\n```", "```py\nconst example_2d3k = [\n    [1, 2], [2, 3], [2, 5], [1, 6], [4, 6],\n    [3, 5], [2, 4], [4, 3], [5, 2], [6, 9],\n    [4, 4], [3, 3], [8, 6], [7, 5], [9, 6],\n    [9, 7], [8, 8], [7, 9], [11, 3], [11, 2],\n    [9, 9], [7, 8], [6, 8], [12, 2], [14, 3],\n    [15, 1], [15, 4], [14, 2], [13, 1], [16, 4]\n];\n```", "```py\nexport default {\n    example_randomCentroids,\n    example_2d3k\n};\n```", "```py\nconsole.log(\"Solving example: 2d data with 3 clusters:\");\nconsole.log(\"===============================================\\n\");\n\nconsole.log(\"Solution for 2d data with 3 clusters:\");\nconsole.log(\"-------------------------------------\");\nconst ex_1_solver = new KMeans(3, example_data.example_2d3k);\nconst ex_1_centroids = ex_1_solver.solve();\nconsole.log(ex_1_centroids);\nconsole.log(\"\");\n```", "```py\nSolving example: 2d data with 3 clusters:\n==========================================================\n\nSolution for 2d data with 3 clusters:\n---------------------------------------------------------\n { centroids:\n [ [ 2.8181818181818183, 3.909090909090909 ],\n [ 13.444444444444445, 2.4444444444444446 ],\n [ 7.6, 7.5 ] ],\n iteration: 1,\n error: 1.878739816915397,\n didReachSteadyState: true }\n```", "```py\nconsole.log(\"Iteration log for 2d data with 3 clusters:\");\nconsole.log(\"------------------------------------------\");\nex_1_solver.iterationLogs.forEach(log => console.log(log));\nconsole.log(\"\");\n```", "```py\nSolving example: 2d data with 3 clusters:\n=====================================================================\n\n Solution for 2d data with 3 clusters:\n --------------------------------------------------------------------\n { centroids:\n [ [ 2.8181818181818183, 3.909090909090909 ],\n [ 13.444444444444445, 2.4444444444444446 ],\n [ 7.6, 7.5 ] ],\n iteration: 4,\n error: 1.878739816915397,\n didReachSteadyState: true }\n\n Iteration log for 2d data with 3 clusters:\n ----------------------------------------------------------------------\n { centroids: [ [ 2.7, 3.7 ], [ 9, 4.125 ], [ 10.75, 5.833333333333333 ] ],\n iteration: 0,\n error: 3.6193538404281806,\n didReachSteadyState: false }\n { centroids:\n [ [ 2.8181818181818183, 3.909090909090909 ],\n [ 9.714285714285714, 3.857142857142857 ],\n [ 10.75, 5.833333333333333 ] ],\n iteration: 1,\n error: 3.4964164297074007,\n didReachSteadyState: false }\n { centroids: [ [ 3.0833333333333335, 4.25 ], [ 11.375, 2.75 ], [ 10, 6.7 ] ],\n iteration: 2,\n error: 3.19709069137691,\n didReachSteadyState: false }\n { centroids:\n [ [ 2.8181818181818183, 3.909090909090909 ],\n [ 13.444444444444445, 2.4444444444444446 ],\n [ 7.6, 7.5 ] ],\n iteration: 3,\n error: 1.878739816915397,\n didReachSteadyState: false }\n { centroids:\n [ [ 2.8181818181818183, 3.909090909090909 ],\n [ 13.444444444444445, 2.4444444444444446 ],\n [ 7.6, 7.5 ] ],\n iteration: 4,\n error: 1.878739816915397,\n didReachSteadyState: true }\n```", "```py\nconsole.log(\"Test 2d data with 3 clusters five times:\");\nconsole.log(\"----------------------------------------\");\nfor (let i = 0; i < 5; i++) {\n    ex_1_solver.reset();\n    const solution = ex_1_solver.solve();\n    console.log(solution);\n}\nconsole.log(\"\");\n```", "```py\nTest 2d data with 3 clusters five times:\n--------------------------------------------------------------\n { centroids:\n [ [ 13.444444444444445, 2.4444444444444446 ],\n [ 2.8181818181818183, 3.909090909090909 ],\n [ 7.6, 7.5 ] ],\n iteration: 2,\n error: 1.878739816915397,\n didReachSteadyState: true }\n { centroids:\n [ [ 2.8181818181818183, 3.909090909090909 ],\n [ 7.6, 7.5 ],\n [ 13.444444444444445, 2.4444444444444446 ] ],\n iteration: 1,\n error: 1.878739816915397,\n didReachSteadyState: true }\n { centroids:\n [ [ 7.6, 7.5 ],\n [ 13.444444444444445, 2.4444444444444446 ],\n [ 2.8181818181818183, 3.909090909090909 ] ],\n iteration: 3,\n error: 1.878739816915397,\n didReachSteadyState: true }\n { centroids:\n [ [ 11.333333333333334, 2.3333333333333335 ],\n [ 5.095238095238095, 5.619047619047619 ],\n [ 14.5, 2.5 ] ],\n iteration: 2,\n error: 3.0171467652692345,\n didReachSteadyState: true }\n { centroids:\n [ [ 7.6, 7.5 ],\n [ 2.8181818181818183, 3.909090909090909 ],\n [ 13.444444444444445, 2.4444444444444446 ] ],\n iteration: 2,\n error: 1.878739816915397,\n didReachSteadyState: true }\n```", "```py\nconst example_3d3k = [\n    [1, 1, 1],\n    [1, 2, 1],\n    [2, 1, 2],\n    [2, 2, 3],\n    [2, 4, 3],\n    [5, 4, 5],\n    [5, 3, 4],\n    [6, 2, 6],\n    [5, 3, 6],\n    [6, 4, 7],\n    [9, 1, 4],\n    [10, 2, 5],\n    [9, 2, 5],\n    [9, 2, 4],\n    [10, 3, 3]\n];\n```", "```py\nexport default {\n    example_randomCentroids,\n    example_2d3k,\n    example_3d3k\n};\n```", "```py\nconsole.log(\"Solving example: 3d data with 3 clusters:\");\nconsole.log(\"===============================================\\n\");\nconsole.log(\"Solution for 3d data with 3 clusters:\");\nconsole.log(\"-------------------------------------\");\nconst ex_2_solver = new KMeans(3, example_data.example_3d3k);\nconst ex_2_centroids = ex_2_solver.solve();\nconsole.log(ex_2_centroids);\nconsole.log(\"\");\n```", "```py\nSolving example: 3d data with 3 clusters:\n====================================================================\n\nSolution for 3d data with 3 clusters:\n---------------------------------------------------------------------\n { centroids: [ [ 1.6, 2, 2 ], [ 5.4, 3.2, 5.6 ], [ 9.4, 2, 4.2 ] ],\n iteration: 5,\n error: 1.3266499161421599,\n didReachSteadyState: true }\n```", "```py\nimport KMeans from './kmeans.js';\n\nclass KMeansAutoSolver {\n\n    constructor(kMin = 1, kMax = 5, maxTrials = 5, data) {\n        this.kMin = kMin;\n        this.kMax = kMax;\n        this.maxTrials = maxTrials;\n        this.data = data;\n        this.reset();\n    }\n\n    reset() {\n        this.best = null;\n        this.log = [];\n    }\n\n    solve(maxIterations = 1000) {\n\n        for (let k = this.kMin; k < this.kMax; k++) {\n\n            for (let currentTrial = 0; currentTrial < this.maxTrials; currentTrial++) {\n\n                const solver = new KMeans(k, this.data);\n                // Add k and currentTrial number to the solution before logging\n                const solution = Object.assign({}, solver.solve(maxIterations), {k, currentTrial});\n                this.log.push(solution);\n\n                if (this.best === null || solution.error < this.best.error) {\n                    this.best = solution;\n                }\n\n            }\n\n        }\n\n        return this.best;\n\n    }\n}\n\nexport default KMeansAutoSolver;\n```", "```py\nconst example_2dnk = [\n [1, 2], [1, 1], [2, 3], [2, 4], [3, 3],\n [4, 4], [2, 12], [2, 14], [3, 14], [4, 13],\n [4, 15], [3, 17], [8, 4], [7, 6], [7, 5],\n [8, 7], [9, 7], [9, 8], [8, 14], [9, 15],\n [9, 16], [10, 15], [10, 14], [11, 14], [10, 18]\n];\n```", "```py\nexport default {\n    example_randomCentroids,\n    example_2d3k,\n    example_3d3k,\n    example_2dnk\n};\n```", "```py\nimport KMeansAutoSolver from './kmeans-autosolver';\n```", "```py\nconsole.log(\"Solving example: 2d data with unknown clusters:\");\nconsole.log(\"===============================================\\n\");\nconsole.log(\"Solution for 2d data with unknown clusters:\");\nconsole.log(\"-------------------------------------\");\nconst ex_3_solver = new KMeansAutoSolver(1, 5, 5, example_data.example_2dnk);\nconst ex_3_solution = ex_3_solver.solve();\nconsole.log(ex_3_solution);\n```", "```py\nSolving example: 2d data with unknown clusters:\n================================================================\n\nSolution for 2d data with unknown clusters:\n----------------------------------------------------------------\n { centroids:\n [ [ 2.1666666666666665, 2.8333333333333335 ],\n [ 9.571428571428571, 15.142857142857142 ],\n [ 8, 6.166666666666667 ],\n [ 3, 14.166666666666666 ] ],\n iteration: 2,\n error: 1.6236349578000828,\n didReachSteadyState: true,\n k: 4,\n currentTrial: 0 }\n```", "```py\nconst thisDistance = distance(point, centroid);\n```", "```py\nconst thisDistance = distance(point, centroid) + this.k;\n```"]