- en: Chapter 8. Video Surveillance, Background Modeling, and Morphological Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：视频监控、背景建模和形态学操作
- en: In this chapter, we will learn how to detect a moving object in a video that
    is taken from a static camera. This is used extensively in video surveillance
    systems. We will discuss the different characteristics that can be used to build
    this system. We will learn about background modeling and see how we can use it
    to build a model of the background in a live video. Once we do this, we will combine
    all the blocks to detect the objects of interest in the video.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何检测从静态摄像机拍摄的视频中的移动对象。这在视频监控系统中被广泛使用。我们将讨论可以用来构建此系统的不同特征。我们将了解背景建模，并看看我们如何可以使用它来构建实时视频中的背景模型。一旦我们这样做，我们将结合所有模块来检测视频中的感兴趣对象。
- en: 'By the end of this chapter, you should be able to answer the following questions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够回答以下问题：
- en: What is naive background subtraction?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是天真背景减法？
- en: What is frame differencing?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是帧差分？
- en: How to build a background model?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建背景模型？
- en: How to identify a new object in a static video?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在静态视频中识别新对象？
- en: What is morphological image processing and how is it related to background modeling?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形态学图像处理是什么？它与背景建模有何关系？
- en: How to achieve different effects using morphological operators?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用形态学算子实现不同的效果？
- en: Understanding background subtraction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解背景减法
- en: Background subtraction is very useful in video surveillance. Basically, the
    background subtraction technique performs really well in cases where we need to
    detect moving objects in a static scene. Now, how is this useful for video surveillance?
    The process of video surveillance involves dealing with a constant data flow.
    The data stream keeps coming in at all times, and we need to analyze it to identify
    any suspicious activities. Let's consider the example of a hotel lobby. All the
    walls and furniture have a fixed location. Now, if we build a background model,
    we can use it to identify suspicious activities in the lobby. We can take advantage
    of the fact that the background scene remains static (which happens to be true
    in this case). This helps us avoid any unnecessary computation overheads.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 背景减法在视频监控中非常有用。基本上，背景减法技术在需要检测静态场景中移动对象的情况下表现非常好。现在，这对视频监控有什么用呢？视频监控的过程涉及处理恒定的数据流。数据流始终在流入，我们需要分析它以识别任何可疑活动。让我们考虑酒店大堂的例子。所有墙壁和家具都有固定的位置。现在，如果我们构建一个背景模型，我们可以用它来识别大堂中的可疑活动。我们可以利用背景场景保持静态的事实（在这个例子中恰好是真实的）。这有助于我们避免任何不必要的计算开销。
- en: 'As the name suggests, this algorithm works by detecting the background and
    assigning each pixel of an image to two classes: either the background (assuming
    that it''s static and stable) or the foreground. It then subtracts the background
    from the current frame to obtain the foreground. By the static assumption, foreground
    objects will naturally correspond to objects or people moving in front of the
    background.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，这个算法通过检测背景并将图像中的每个像素分配到两个类别：背景（假设它是静态和稳定的）或前景。然后它从当前帧中减去背景以获得前景。根据静态假设，前景对象将自然对应于在背景前移动的对象或人。
- en: In order to detect moving objects, we first need to build a model of the background.
    This is not the same as direct frame differencing because we are actually modeling
    the background and using this model to detect moving objects. When we say that
    we are *modeling the background*, we are basically building a mathematical formulation
    that can be used to represent the background. So, this performs in a much better
    way than the simple frame differencing technique. This technique tries to detect
    static parts of the scene and then updates the background model. This background
    model is then used to detect background pixels. So, it's an adaptive technique
    that can adjust according to the scene.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测移动对象，我们首先需要构建背景模型。这不同于直接帧差分，因为我们实际上是在建模背景并使用此模型来检测移动对象。当我们说我们在“建模背景”时，我们基本上是在构建一个可以用来表示背景的数学公式。因此，这比简单的帧差分技术表现得更好。这种技术试图检测场景中的静态部分，然后更新背景模型。然后，这个背景模型用于检测背景像素。因此，它是一种自适应技术，可以根据场景进行调整。
- en: Naive background subtraction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 天真背景减法
- en: 'Let''s start the background subtraction discussion from the beginning. What
    does a background subtraction process look like? Consider the following image:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从背景减法的讨论开始。背景减法过程是什么样的？考虑以下这张图片：
- en: '![Naive background subtraction](img/B04283_08_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![天真背景减法](img/B04283_08_01.jpg)'
- en: 'The preceding image represents the background scene. Now, let''s introduce
    a new object into this scene:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片表示的是背景场景。现在，让我们向这个场景中引入一个新的物体：
- en: '![Naive background subtraction](img/B04283_08_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![天真背景减法](img/B04283_08_02.jpg)'
- en: 'As shown in the preceding image, there is a new object in the scene. So, if
    we compute the difference between this image and our background model, you should
    be able to identify the location of the TV remote:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张图片所示，场景中有一个新的物体。因此，如果我们计算这个图像和我们的背景模型之间的差异，你应该能够识别电视遥控器的位置：
- en: '![Naive background subtraction](img/B04283_08_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![天真背景减法](img/B04283_08_03.jpg)'
- en: 'The overall process looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程看起来是这样的：
- en: '![Naive background subtraction](img/B04283_08_04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![天真背景减法](img/B04283_08_04.jpg)'
- en: Does it work well?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是否工作得很好？
- en: There's a reason why we call it the **naive** approach. It works under ideal
    conditions, and as we know, nothing is ideal in the real world. It does a reasonably
    good job of computing the shape of the given object, but it does so under some
    constraints. One of the main requirements of this approach is that the color and
    intensity of the object should be sufficiently different from that of the background.
    Some of the factors that affect these kinds of algorithms are image noise, lighting
    conditions, autofocus in cameras, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以称之为**天真**的方法，是有原因的。它在理想条件下是有效的，而我们都知道，在现实世界中没有任何事情是理想的。它能够相当好地计算给定物体的形状，但这是在一定的约束条件下完成的。这种方法的一个主要要求是物体的颜色和强度应该与背景有足够的差异。影响这类算法的一些因素包括图像噪声、光照条件、相机的自动对焦等等。
- en: 'Once a new object enters our scene and stays there, it will be difficult to
    detect new objects that are in front of it. This is because we don''t update our
    background model, and the new object is now part of our background. Consider the
    following image:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个新的物体进入我们的场景并停留下来，就很难检测到它前面的新物体。这是因为我们没有更新我们的背景模型，而新的物体现在成为了我们背景的一部分。考虑以下这张图片：
- en: '![Does it work well?](img/B04283_08_05.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![是否工作得很好？](img/B04283_08_05.jpg)'
- en: 'Now, let''s say a new object enters our scene:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个新的物体进入我们的场景：
- en: '![Does it work well?](img/B04283_08_06.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![是否工作得很好？](img/B04283_08_06.jpg)'
- en: 'We identify this to be a new object, which is fine. Let''s say another object
    comes into the scene:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其识别为一个新的物体，这是可以的。假设另一个物体进入场景：
- en: '![Does it work well?](img/B04283_08_07.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![是否工作得很好？](img/B04283_08_07.jpg)'
- en: 'It will be difficult to identify the location of these two different objects
    because their locations overlap. Here''s what we get after subtracting the background
    and applying the threshold:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个不同物体的位置重叠，将很难识别它们的位置。这是在减去背景并应用阈值后的结果：
- en: '![Does it work well?](img/B04283_08_08.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![是否工作得很好？](img/B04283_08_08.jpg)'
- en: In this approach, we assume that the background is static. If some parts of
    our background start moving, then those parts will start getting detected as new
    objects. So, even if the movements are minor, say a waving flag, it will cause
    problems in our detection algorithm. This approach is also sensitive to changes
    in illumination, and it cannot handle any camera movement. Needless to say, it's
    a delicate approach! We need something that can handle all these things in the
    real world.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们假设背景是静态的。如果背景的某些部分开始移动，那么这些部分将开始被检测为新的物体。因此，即使移动很小，比如挥动的旗帜，也会导致我们的检测算法出现问题。这种方法对光照变化也很敏感，并且无法处理任何相机移动。不用说，这是一个非常敏感的方法！我们需要能够在现实世界中处理所有这些事情的东西。
- en: Frame differencing
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧差分
- en: We know that we cannot keep a static background image that can be used to detect
    objects. So, one of the ways to fix this would be to use frame differencing. It
    is one of the simplest techniques that we can use to see what parts of the video
    are moving. When we consider a live video stream, the difference between successive
    frames gives a lot of information. The concept is fairly straightforward. We just
    take the difference between successive frames and display the difference.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们无法保持一个静态的背景图像来检测对象。因此，解决这个问题的一种方法就是使用帧差分。这是我们能够使用的最简单技术之一，可以用来查看视频的哪些部分在移动。当我们考虑实时视频流时，连续帧之间的差异提供了大量信息。这个概念相当直接。我们只需计算连续帧之间的差异并显示差异。
- en: 'If I move my laptop rapidly, we can see something like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我快速移动我的笔记本电脑，我们可以看到类似这样的情况：
- en: '![Frame differencing](img/B04283_08_09.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![帧差分](img/B04283_08_09.jpg)'
- en: 'Instead of the laptop, let''s move the object and see what happens. If I rapidly
    shake my head, it will look something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用笔记本电脑，而是移动物体并看看会发生什么。如果我快速摇头，它看起来会是这样：
- en: '![Frame differencing](img/B04283_08_10.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![帧差分](img/B04283_08_10.jpg)'
- en: 'As you can see in the preceding images, only the moving parts of the video
    get highlighted. This gives us a good starting point to see the areas that are
    moving in the video. Let''s take a look at the function to compute the frame difference:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，只有视频的移动部分被突出显示。这为我们提供了一个很好的起点，可以看到视频中哪些区域在移动。让我们看看计算帧差异的函数：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Frame differencing is fairly straightforward. You compute the absolute difference
    between the current frame and previous frame and between the current frame and
    next frame. We then take these frame differences and apply a bitwise AND operator.
    This will highlight the moving parts in the image. If you just compute the difference
    between the current frame and previous frame, it tends to be noisy. Hence, we
    need to use the bitwise AND operator between successive frame differences to get
    some stability when we see the moving objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 帧差分相当直接。你计算当前帧与前一帧以及当前帧与下一帧之间的绝对差异。然后我们应用位与操作符来处理这些帧差异。这将突出显示图像中的移动部分。如果你只是计算当前帧与前一帧之间的差异，它往往会很嘈杂。因此，我们需要在连续帧差异之间使用位与操作符，以便在观察移动对象时获得一些稳定性。
- en: 'Let''s take a look at the function that can extract and return a frame from
    the webcam:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可以提取并返回摄像头帧的函数：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, it''s pretty straightforward. We just need to resize the frame
    and convert it to grayscale. Now that we have the helper functions ready, let''s
    take a look at the `main` function and see how it all comes together:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这相当直接。我们只需要调整帧的大小并将其转换为灰度图。现在我们已经准备好了辅助函数，让我们看看`main`函数，看看它是如何整合在一起的：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How well does it work?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效果如何？
- en: 'As we can see, frame differencing addresses a couple of important problems
    that we faced earlier. It can quickly adapt to lighting changes or camera movements.
    If an object comes in the frame and stays there, it will not be detected in the
    future frames. One of the main concerns of this approach is about detecting uniformly
    colored objects. It can only detect the edges of a uniformly colored object. This
    is because a large portion of this object will result in very low pixel differences,
    as shown in the following image:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，帧差分解决了我们之前遇到的一些重要问题。它可以快速适应光照变化或相机移动。如果一个物体进入画面并停留在那里，它将不会被检测到未来的帧中。这种方法的主要担忧之一是检测颜色均匀的对象。它只能检测颜色均匀对象的边缘。这是因为该对象的大部分区域将导致非常低的像素差异，如下面的图像所示：
- en: '![How well does it work?](img/B04283_08_11.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![效果如何？](img/B04283_08_11.jpg)'
- en: 'Let''s say this object moved slightly. If we compare this with the previous
    frame, it will look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个物体稍微移动了一下。如果我们将其与前一帧进行比较，它看起来会是这样：
- en: '![How well does it work?](img/B04283_08_12.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![效果如何？](img/B04283_08_12.jpg)'
- en: Hence, we have very few pixels that are labeled on that object. Another concern
    is that it is difficult to detect whether an object is moving toward the camera
    or away from it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这个对象上有很少的像素被标记。另一个担忧是，很难检测一个物体是朝向相机移动还是远离相机。
- en: The Mixture of Gaussians approach
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高斯混合方法
- en: 'Before we talk about **Mixture of Gaussians** (**MOG**), let''s see what a
    *mixture model* is. A mixture model is just a statistical model that can be used
    to represent the presence of subpopulations within our data. We don''t really
    care about what category each data point belongs to. All we need to do is identify
    whether the data has multiple groups inside it. Now, if we represent each subpopulation
    using the Gaussian function, then it''s called Mixture of Gaussians. Let''s consider
    the following image:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论**高斯混合**（**MOG**）之前，让我们看看什么是*混合模型*。混合模型只是一个可以用来表示我们数据中存在子群体的统计模型。我们并不真正关心每个数据点属于哪个类别。我们只需要确定数据内部是否有多个组。现在，如果我们用高斯函数来表示每个子群体，那么它就被称为高斯混合。让我们考虑以下图像：
- en: '![The Mixture of Gaussians approach](img/B04283_08_13.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![高斯混合方法](img/B04283_08_13.jpg)'
- en: Now, as we gather more frames in this scene, every part of the image will gradually
    become part of the background model. This is what we discussed earlier as well.
    If a scene is static, the model adapts itself to make sure that the background
    model is updated. The foreground mask, which is supposed to represent the foreground
    object, looks like a black image at this point because every pixel is part of
    the background model.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们在这个场景中收集更多的帧，图像的每一部分都将逐渐成为背景模型的一部分。这也是我们之前讨论过的。如果一个场景是静态的，模型会自动调整以确保背景模型得到更新。前景掩码，本应表示前景对象，此时看起来像一张黑图，因为每个像素都是背景模型的一部分。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenCV has multiple algorithms implemented for the Mixture of Gaussians approach.
    One of them is called **MOG** and the other is called **MOG2**. To get a detailed
    explanation, you can refer to [http://docs.opencv.org/master/db/d5c/tutorial_py_bg_subtraction.html#gsc.tab=0](http://docs.opencv.org/master/db/d5c/tutorial_py_bg_subtraction.html#gsc.tab=0).
    You will also be able check out the original research papers that were used to
    implement these algorithms.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV实现了多个用于高斯混合方法的算法。其中之一被称为**MOG**，另一个被称为**MOG2**。要获取详细说明，您可以参考[http://docs.opencv.org/master/db/d5c/tutorial_py_bg_subtraction.html#gsc.tab=0](http://docs.opencv.org/master/db/d5c/tutorial_py_bg_subtraction.html#gsc.tab=0)。您还可以查看用于实现这些算法的原始研究论文。
- en: 'Let''s introduce a new object into this scene and see what the foreground mask
    looks like using the MOG approach:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在场景中引入一个新的对象，并看看使用MOG方法的前景掩码是什么样的：
- en: '![The Mixture of Gaussians approach](img/B04283_08_14.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![高斯混合方法](img/B04283_08_14.jpg)'
- en: 'Let''s wait for some time and introduce a new object into the scene. Let''s
    take a look at what the new foreground mask looks like using the MOG2 approach:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们等待一段时间，并向场景中引入一个新的对象。让我们看看使用MOG2方法的新前景掩码是什么样的：
- en: '![The Mixture of Gaussians approach](img/B04283_08_15.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![高斯混合方法](img/B04283_08_15.jpg)'
- en: 'As you can see in the preceding images, the new objects are being identified
    correctly. Let''s take a look at the interesting part of the code (you can get
    the complete code in the `.cpp` files):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图像中看到的，新对象被正确地识别了。让我们看看代码的有趣部分（完整的代码可以在`.cpp`文件中找到）：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What happened in the code?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码中发生了什么？
- en: 'Let''s quickly go through the code and see what''s happening there. We use
    the Mixture of Gaussians model to create a background subtractor object. This
    object represents the model that will be updated as and when we encounter new
    frames from the webcam. As we can see in the code, we initialize two background
    subtraction models: `BackgroundSubtractorMOG` and `BackgroundSubtractorMOG2`.
    They represent two different algorithms that are used for background subtraction.
    The first one refers to the paper by *P. KadewTraKuPong* and *R. Bowden titled*,
    *An improved adaptive background mixture model for real-time tracking with shadow
    detection*. You can check it out at [http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf](http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf).
    The second one refers to the paper by *Z.Zivkovic* titled, *Improved adaptive
    Gausian Mixture Model for background subtraction*. You can check it out at [http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf](http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf).
    We start an infinite `while` loop and continuously read the input frames from
    the webcam. With each frame, we update the background model, as shown in the following
    lines:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下代码，看看那里发生了什么。我们使用高斯混合模型来创建一个背景减除对象。这个对象代表了一个模型，它将在我们遇到来自摄像头的新的帧时进行更新。正如我们在代码中所看到的，我们初始化了两个背景减除模型：`BackgroundSubtractorMOG`
    和 `BackgroundSubtractorMOG2`。它们代表了用于背景减除的两个不同算法。第一个指的是由 *P. KadewTraKuPong* 和
    *R. Bowden* 撰写的论文，标题为 *An improved adaptive background mixture model for real-time
    tracking with shadow detection*。您可以在 [http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf](http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf)
    上查看。第二个指的是由 *Z.Zivkovic* 撰写的论文，标题为 *Improved adaptive Gausian Mixture Model for
    background subtraction*。您可以在 [http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf](http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf)
    上查看。我们启动一个无限循环 `while`，并持续从摄像头读取输入帧。对于每一帧，我们更新背景模型，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The background model gets updated in these steps. Now, if a new object enters
    the scene and stays there, it will become part of the background model. This helps
    us overcome one of the biggest shortcomings of the naïve background subtraction
    model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 背景模型在这些步骤中更新。现在，如果一个新物体进入场景并停留，它将成为背景模型的一部分。这有助于我们克服朴素背景减除模型的最大缺点之一。
- en: Morphological image processing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态学图像处理
- en: As discussed earlier, background subtraction methods are affected by many factors.
    Their accuracy depends on how we capture the data and how it's processed. One
    of the biggest factors that tend to affect these algorithms is the noise level.
    When we say *noise*, we are talking about things, such as graininess in an image,
    isolated black/white pixels, and so on. These issues tend to affect the quality
    of our algorithms. This is where morphological image processing comes into picture.
    Morphological image processing is used extensively in a lot of real-time systems
    to ensure the quality of the output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，背景减除方法受许多因素影响。它们的准确性取决于我们如何捕获数据以及如何处理数据。影响这些算法的最大因素之一是噪声水平。当我们说 *噪声* 时，我们指的是图像中的颗粒感、孤立的黑/白像素等问题。这些问题往往会影响我们算法的质量。这就是形态学图像处理发挥作用的地方。形态学图像处理在许多实时系统中被广泛使用，以确保输出质量。
- en: Morphological image processing refers to processing the shapes of features in
    the image. For example, you can make a shape thicker or thinner. Morphological
    operators rely on how the pixels are ordered in an image, but on their values.
    This is the reason why they are really well suited to manipulate shapes in binary
    images. Morphological image processing can be applied to grayscale images as well,
    but the pixel values will not matter much.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 形态学图像处理是指处理图像中特征形状的过程。例如，你可以使形状变厚或变薄。形态学算子依赖于图像中像素的顺序，但不是它们的值。这就是为什么它们非常适合在二值图像中操作形状。形态学图像处理也可以应用于灰度图像，但像素值不会很重要。
- en: What's the underlying principle?
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本原理是什么？
- en: Morphological operators use a structuring element to modify an image. What is
    a structuring element? A structuring element is basically a small shape that can
    be used to inspect a small region in the image. It is positioned at all the pixel
    locations in the image so that it can inspect that neighborhood. We basically
    take a small window and overlay it on top of a pixel. Depending on the response,
    we take an appropriate action at that pixel location.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 形态学算子使用结构元素来修改图像。什么是结构元素？结构元素基本上是一个可以用来检查图像中小区域的形状。它被放置在图像的所有像素位置，以便它可以检查该邻域。我们基本上取一个小窗口并将其叠加在像素上。根据响应，我们在该像素位置采取适当的行动。
- en: 'Let''s consider the following input image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下输入图像：
- en: '![What''s the underlying principle?](img/B04283_08_16.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![基本原理是什么？](img/B04283_08_16.jpg)'
- en: We will apply a bunch of morphological operations to this image to see how the
    shape changes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这张图像应用一系列形态学操作，以查看形状如何变化。
- en: Slimming the shapes
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瘦身形状
- en: 'We can achieve this effect using an operation called **erosion**. This is an
    operation that makes a shape thinner by peeling the boundary layers of all the
    shapes in the image:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个称为**腐蚀**的操作来实现这种效果。这是一个通过剥离图像中所有形状的边界层来使形状变薄的操作：
- en: '![Slimming the shapes](img/B04283_08_17.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![瘦身形状](img/B04283_08_17.jpg)'
- en: 'Let''s take a look at the function that performs morphological erosion:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行形态学腐蚀的函数：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can check out the complete code in the `.cpp` files to understand how to
    use this function. Basically, we build a structuring element using an built-in
    OpenCV function. This object is used as a probe to modify each pixel based on
    certain conditions. These *conditions* refer to what's happening around that particular
    pixel in the image. For example, is it surrounded by white pixels? Or is it surrounded
    by black pixels? Once we have an answer, we can take an appropriate action.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`.cpp`文件中查看完整的代码，以了解如何使用此函数。基本上，我们使用内置的OpenCV函数构建一个结构元素。此对象用作探针，根据某些条件修改每个像素。这些**条件**指的是图像中特定像素周围发生的情况。例如，它是被白色像素包围的吗？或者它是被黑色像素包围的吗？一旦我们得到答案，我们就可以在该像素位置采取适当的行动。
- en: Thickening the shapes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加厚形状
- en: 'We use an operation called **dilation** to achieve thickening. This is an operation
    that makes a shape thicker by adding boundary layers to all the shapes in the
    image:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个称为**膨胀**的操作来实现加厚。这是一个通过向图像中所有形状添加边界层来使形状变厚的操作：
- en: '![Thickening the shapes](img/B04283_08_18.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![加厚形状](img/B04283_08_18.jpg)'
- en: 'Here is the code to do this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行此操作的代码：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Other morphological operators
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他形态学算子
- en: Here are some other morphological operators that are interesting. Let's first
    take a look at the output image. We can take a look at the code at the end of
    this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他有趣的形态学算子。让我们首先看看输出图像。我们可以在本节末尾查看代码。
- en: Morphological opening
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形态学开运算
- en: 'This is an operation that *opens* a shape. This operator is frequently used
    for noise removal in an image. We can achieve morphological opening by applying
    erosion followed by dilation to an image. The morphological opening process basically
    removes small objects from the foreground in the image by placing them in the
    background:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**打开**形状的操作。这个算子常用于图像中的噪声去除。我们可以通过在图像上应用腐蚀后跟膨胀来实现形态学开运算。形态学开运算过程基本上通过将小对象放置在背景中来从图像的前景中移除小对象：
- en: '![Morphological opening](img/B04283_08_19.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![形态学开运算](img/B04283_08_19.jpg)'
- en: 'Here is the function to the perform morphological opening:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行形态学开运算的函数：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see here, we apply erosion and dilation to the image to perform the
    morphological opening.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们对图像应用腐蚀和膨胀来执行形态学开运算。
- en: Morphological closing
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形态学闭合
- en: This is an operation that *closes* a shape by filling the gaps. This operation
    is also used for noise removal. We achieve morphological closing by applying dilation
    followed by erosion to an image. This operation removes tiny holes in the foreground
    by changing small objects in the background into the foreground.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**闭合**形状的操作，通过填充间隙来实现。这个操作也用于噪声去除。我们通过在图像上应用膨胀后跟腐蚀来实现形态学闭合。这个操作通过将背景中的小对象变成前景来移除前景中的小孔。
- en: '![Morphological closing](img/B04283_08_20.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![形态学闭合](img/B04283_08_20.jpg)'
- en: 'Let''s quickly take a look at the function to perform the morphological closing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下执行形态学闭合的函数：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Drawing the boundary
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制边界
- en: 'We achieve this using the morphological gradient. This is an operation that
    draws the boundary around a shape by taking the difference between dilation and
    erosion of an image:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过形态学梯度来实现这一点。这是一种通过取图像膨胀和腐蚀的差来绘制形状边界的操作：
- en: '![Drawing the boundary](img/B04283_08_21.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![绘制边界](img/B04283_08_21.jpg)'
- en: 'Let''s take a look at the function to perform the morphological gradient:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看执行形态学梯度的函数：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: White Top-Hat transform
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 白顶帽变换
- en: 'While Top-Hat transform, also simply called Top-Hat transform, extracts finer
    details from the images. We can apply white top-hat transform by computing the
    difference between the input image and its morphological opening. This gives us
    the objects in the image that are smaller than the structuring elements and are
    brighter than the surroundings. So, depending on the size of the structuring element,
    we can extract various objects in the given image:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶帽变换，也简称为顶帽变换，从图像中提取更细的细节时。我们可以通过计算输入图像与其形态学开运算的差来应用白顶帽变换。这使我们能够识别出图像中比结构元素小且比周围区域亮的物体。因此，根据结构元素的大小，我们可以从给定图像中提取各种物体：
- en: '![White Top-Hat transform](img/B04283_08_22.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![白顶帽变换](img/B04283_08_22.jpg)'
- en: 'If you look carefully at the output image, you can see those black rectangles.
    This means that the structuring element was able to fit in there, and so those
    regions are blackened out. Here is the function to do this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察输出图像，你可以看到那些黑色矩形。这意味着结构元素能够适应那里，因此这些区域被涂成了黑色。这里是执行此操作的函数：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Black Top-Hat transform
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑顶帽变换
- en: Black Top-Hat transform, also simply called Black Hat transform, extracts finer
    details from the image as well. We can apply black top-hat transform by computing
    the difference between the morphological closing of an image and the image itself.
    This gives us the objects in the image that are smaller than the structuring element
    and are darker than the surroundings.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 黑顶帽变换，也简称为黑帽变换，同样可以从图像中提取更细的细节。我们可以通过计算图像的形态学闭运算与图像本身的差来应用黑顶帽变换。这使我们能够识别出图像中比结构元素小且比周围区域暗的物体。
- en: '![Black Top-Hat transform](img/B04283_08_23.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![黑顶帽变换](img/B04283_08_23.jpg)'
- en: 'Let''s take a look at the function to perform the black hat transform:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看执行黑帽变换的函数：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about the algorithms that are used for background
    modeling and morphological image processing. We discussed naïve background subtraction
    and its limitations. We learned how to get motion information using frame differencing
    and how it can be constrain us when we want to track different types of objects.
    We also discussed Mixture of Gaussians, along with its formulation and implementation
    details. We then discussed morphological image processing. We learned how it can
    be used for various purposes and different operations were demonstrated to show
    the use cases.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了用于背景建模和形态学图像处理的算法。我们讨论了简单的背景减法及其局限性。我们学习了如何使用帧差分来获取运动信息，以及它在追踪不同类型物体时可能对我们的约束。我们还讨论了高斯混合模型，包括其公式和实现细节。然后我们讨论了形态学图像处理。我们学习了它可用于各种目的，并通过不同的操作演示了其用例。
- en: In the next chapter, we will discuss how to track an object and the various
    techniques that can be used to do it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何追踪物体以及可以用来实现这一目标的多种技术。
