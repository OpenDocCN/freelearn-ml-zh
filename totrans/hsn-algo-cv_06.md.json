["```py\nVideoCapture cam(0); \n// check if camera was opened correctly \nif(!cam.isOpened()) \n    return -1; \n// infinite loop \nwhile(true) \n{ \n    Mat frame; \n    cam >> frame; \n    if(frame.empty()) \n        break; \n\n    applyColorMap(frame, frame, COLORMAP_JET); \n\n    // display the frame \n    imshow(\"Camera\", frame); \n\n    // stop camera if space is pressed \n    if(waitKey(10) == ' ') \n        break; \n} \n\ncam.release(); \n```", "```py\nint key = -1; \nwhile(key != ' ') \n{ \n    Mat frame; \n    cam >> frame; \n    if(frame.empty()) \n        break; \n    switch (key) \n    { \n    case 'j': applyColorMap(frame, frame, COLORMAP_JET); \n        break; \n    case 'h': applyColorMap(frame, frame, COLORMAP_HOT); \n        break; \n    } \n    imshow(\"Camera\", frame); \n    int k = waitKey(10); \n    if(k > 0) \n        key = k; \n} \n```", "```py\nVideoCapture cam(0); \nif(!cam.isOpened()) \n    return -1; \nvector<Scalar> avgs; \nint key = -1; \nwhile(key != ' ') \n{ \n    Mat frame; \n    cam >> frame; \n    if(frame.empty()) \n        break; \n    if(avgs.size() > 60) // remove the first item if more than 60 \n        avgs.erase(avgs.begin()); \n    Mat frameGray; \n    cvtColor(frame, frameGray, CV_BGR2GRAY); \n    avgs.push_back( mean(frameGray) ); \n    Scalar allAvg = mean(avgs); \n    putText(frame, \n            to_string(allAvg[0]), \n            Point(0,frame.rows-1), \n            FONT_HERSHEY_PLAIN, \n            1.0, \n            Scalar(0,255,0)); \n    imshow(\"Camera\", frame); \n    int k = waitKey(10); \n    if(k > 0) \n        key = k; \n} \ncam.release(); \n```", "```py\nRect srchWnd(0, 0, 100, 100); \nTermCriteria criteria(TermCriteria::MAX_ITER \n                      + TermCriteria::EPS, \n                      20, // number of iterations \n                      1.0 // epsilon value \n                      ); \n// Calculate back-projection image \nmeanShift(backProject, \n          srchWnd, \n          criteria);\n```", "```py\nVideoCapture cam(0); \nif(!cam.isOpened()) \n    return -1; \n\nint key = -1; \nwhile(key != ' ') \n{ \n    Mat frame; \n    cam >> frame; \n    if(frame.empty()) \n        break; \n\n    int k = waitKey(10); \n    if(k > 0) \n        key = k; \n} \n\ncam.release(); \n```", "```py\nint bins = 360; \nint grnHue = 120; // green color hue value \nint hueOffset = 50; // the accepted threshold \nMat histogram(bins, 1, CV_32FC1); \nfor(int i=0; i<bins; i++) \n{ \n    histogram.at<float>(i, 0) = \n            (i > grnHue - hueOffset) \n            && \n            (i < grnHue + hueOffset) \n            ? \n                255.0 : 0.0; \n} \n```", "```py\nRect srchWnd(0,0, 100, 100); \nTermCriteria criteria(TermCriteria::MAX_ITER \n                      + TermCriteria::EPS, \n                      20, \n                      1.0); \n```", "```py\nMat frmHsv, hue; \nvector<Mat> hsvChannels; \ncvtColor(frame, frmHsv, COLOR_BGR2HSV); \nsplit(frmHsv, hsvChannels); \nhue = hsvChannels[0]; \n\nint nimages = 1; \nint channels[] = {0}; \nMat backProject; \nfloat rangeHue[] = {0, 180}; \nconst float* ranges[] = {rangeHue}; \ndouble scale = 1.0; \nbool uniform = true; \ncalcBackProject(&hue, \n                nimages, \n                channels, \n                histogram, \n                backProject, \n                ranges, \n                scale, \n                uniform); \n```", "```py\nmeanShift(backProject, \n          srchWnd, \n          criteria); \n```", "```py\nrectangle(frame, \n          srchWnd, // search window rectangle \n          Scalar(0,0,255), // red color \n          2 // thickness \n          );\n```", "```py\ncvtColor(backProject, backProject, COLOR_GRAY2BGR); \nrectangle(backProject, \n          srchWnd, \n          Scalar(0,0,255), \n          2); \n```", "```py\nswitch(key) \n{ \ncase 'b': imshow(\"Camera\", backProject); \n    break; \ncase 'v': default: imshow(\"Camera\", frame); \n    break; \n} \n```", "```py\nPoint p(srchWnd.x + srchWnd.width/2, \n        srchWnd.y + srchWnd.height/2); \nroute.push_back(p); \nif(route.size() > 60) // last 60 frames \n    route.erase(route.begin()); // remove first element\n```", "```py\npolylines(frame, \n          route, // the vector of Point objects \n          false, // not a closed polyline \n          Scalar(0,255,0), // green color \n          2 // thickness \n          ); \n```", "```py\nbool selecting = false; \nRect selection; \nPoint spo; // selection point origin \n\nvoid onMouse(int event, int x, int y, int flags, void*) \n{ \n    switch(event) \n    { \n    case EVENT_LBUTTONDOWN: \n    { \n        spo.x = x; \n        spo.y = y; \n        selection.x = spo.x; \n        selection.y = spo.y; \n        selection.width = 0; \n        selection.height = 0; \n        selecting = true; \n\n    } break; \n    case EVENT_LBUTTONUP: \n    { \n        selecting = false; \n    } break; \n    default: \n    { \n        selection.x = min(x, spo.x); \n        selection.y = min(y, spo.y); \n        selection.width = abs(x - spo.x); \n        selection.height = abs(y - spo.y); \n    } break; \n    } \n} \n```", "```py\nif(selecting) \n{ \n    Mat sel(frame, selection); \n    bitwise_not(sel, sel); // invert the selected area \n\n    srchWnd = selection; // set the search window \n\n    // create the histogram using the hue of the selection \n} \n```", "```py\nCamShift(backProject, \n         srchWnd, \n         criteria); \n```", "```py\nRotatedRect rotRect = CamShift(backProject, \n                               srchWnd, \n                               criteria); \n```", "```py\nPoint2f rps[4]; \nrotRect.points(rps); \nfor(int i=0; i<4; i++) \n    line(frame, \n         rps[i], \n         rps[(i+1)%4], \n         Scalar(255,0,0),// blue color \n         2); \n```", "```py\nellipse(frame, \n        rotRect, \n        Scalar(255,0,0), \n        2); \n```", "```py\nint lbHue = 00 , hbHue = 180; \nint lbSat = 30 , hbSat = 256; \nint lbVal = 30 , hbVal = 230; \n\nMat mask; \ninRange(objImgHsv, \n        Scalar(lbHue, lbSat, lbVal), \n        Scalar(hbHue, hbSat, hbVal), \n        mask); \n\ncalcHist(&objImgHue, \n         nimages, \n         channels, \n         mask, \n         histogram, \n         dims, \n         histSize, \n         ranges, \n         uniform); \n```", "```py\nKalmanFilter kalman(4, // dynamic parameters: X,Y,X',Y' \n                    2  // measurement parameters: X,Y \n                    ); \n```", "```py\nKalmanFilter kalman(4, 2, 0, CV_32F); \n```", "```py\nMat_<float> tm(4, 4); // transition matrix \ntm << 1,0,1,0, // next x = 1X + 0Y + 1X' + 0Y' \n      0,1,0,1, // next y = 0X + 1Y + 0X' + 1Y' \n      0,0,1,0, // next x'= 0X + 0Y + 1X' + 0Y \n      0,0,0,1; // next y'= 0X + 0Y + 0X' + 1Y' \nkalman.transitionMatrix =  tm; \n```", "```py\nMat_<float> pos(2,1); \npos.at<float>(0) = 0; \npos.at<float>(1) = 0; \n\nkalman.statePre.at<float>(0) = 0; // init x \nkalman.statePre.at<float>(1) = 0; // init y \nkalman.statePre.at<float>(2) = 0; // init x' \nkalman.statePre.at<float>(3) = 0; // init y'\n```", "```py\nsetIdentity(kalman.measurementMatrix); \n```", "```py\nsetIdentity(kalman.processNoiseCov, \n            Scalar::all(0.000001)); \n```", "```py\nstring window = \"Canvas\"; \nnamedWindow(window); \nsetMouseCallback(window, onMouse); \n```", "```py\nvoid onMouse(int, int x, int y, int, void*) \n{ \n    objectPos.x = x; \n    objectPos.y = y; \n} \nPoint object that is used to store the last position of the mouse on the window. It needs to be defined globally in order to be accessible by both onMouse and the main function in which we'll use the KalmanFilter class. Here's the definition:\n```", "```py\nPoint objectPos; \n```", "```py\nvector<Point> trackRoute; \nwhile(waitKey(10) < 0) \n{ \n    // empty canvas \n    Mat canvas(500, 1000, CV_8UC3, Scalar(255, 255, 255)); \n\n    pos(0) = objectPos.x; \n    pos(1) = objectPos.y; \n\n    Mat estimation = kalman.correct(pos); \n\n    Point estPt(estimation.at<float>(0), \n                estimation.at<float>(1)); \n\n    trackRoute.push_back(estPt); \n    if(trackRoute.size() > 100) \n        trackRoute.erase(trackRoute.begin()); \n\n    polylines(canvas, \n              trackRoute, \n              false, \n              Scalar(0,0,255), \n              5); \n\n    imshow(window, canvas); \n\n    kalman.predict(); \n} \n```", "```py\nmouseRoute.push_back(objectPos); \nif(mouseRoute.size() > 100) \n    mouseRoute.erase(mouseRoute.begin()); \npolylines(canvas, \n          mouseRoute, \n          false, \n          Scalar(0,0,0), \n          2); \n```", "```py\nvector<Point> mouseRoute; \n```", "```py\nsetIdentity(kalman.processNoiseCov, \n            Scalar::all(0.001)); \n```", "```py\nCamShift(backProject, \n         srchWnd, \n         criteria); \n\nPoint objectPos(srchWnd.x + srchWnd.width/2, \n                srchWnd.y + srchWnd.height/2); \n\npos(0) = objectPos.x; \npos(1) = objectPos.y; \n\nMat estimation = kalman.correct(pos); \n\nPoint estPt(estimation.at<float>(0), \n            estimation.at<float>(1)); \n\ndrawMarker(frame, \n           estPt, \n           Scalar(0,255,0), \n           MARKER_CROSS, \n           30, \n           2); \n\nkalman.predict();\n```", "```py\nint history = 500; \ndouble dist2Threshold = 400.0; \nbool detectShadows = true; \nPtr<BackgroundSubtractorKNN> bgs = \n        createBackgroundSubtractorKNN(history, \n                                      dist2Threshold, \n                                      detectShadows);\n```", "```py\nVideoCapture cam(0); \nif(!cam.isOpened()) \n    return -1; \n\nwhile(true) \n{ \n    Mat frame; \n    cam >> frame; \n    if(frame.empty()) \n        break; \n\n    Mat fgMask; // foreground mask \n    bgs->apply(frame, \n               fgMask); \n\n    Mat fg; // foreground image \n    bitwise_and(frame, frame, fg, fgMask); \n\n    Mat bg; // background image \n    bgs->getBackgroundImage(bg); \n\n    imshow(\"Input Image\", frame); \n    imshow(\"Background Image\", bg); \n    imshow(\"Foreground Mask\", fgMask); \n    imshow(\"Foreground Image\", fg); \n\n    int key = waitKey(10); \n    if(key == 27) // escape key \n        break; \n} \n\ncam.release();\n```", "```py\nmedianBlur(fgMask,fgMask,3); \n```", "```py\nint history = 500; \ndouble varThreshold = 16.0; \nbool detectShadows = true; \nPtr<BackgroundSubtractorMOG2> bgs = \n        createBackgroundSubtractorMOG2(history, \n                                       varThreshold, \n                                       detectShadows); \n```"]