- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining Existing Codebases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Brownfield** is another word for working with existing code. In my career
    as a developer, most of the work carried out has been on existing code. The opposite
    of brownfield is **greenfield**, which is a new project with no existing code.'
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, it’s important to cover how to work with existing codebases,
    and there’s a lot to get excited about when working with an AI assistant like
    GitHub Copilot in a brownfield context.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the different types of maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how we work with maintenance in a process to de-risk introduced changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GitHub Copilot to help us with maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a bit different from other chapters in the book. The focus is
    on describing various problems you may encounter in the space of existing codebases.
    You’re recommended to use the prompt suggestion approach with which you’re the
    most comfortable, be it prompt comments or the chat interface. As for patterns,
    you’re encouraged to try out all three major patterns introduced, that is, PIC,
    TAG, or Exploratory patterns as described in *Chapter 2*. This chapter however
    focuses on using the “Exploratory pattern”.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different types of maintenance, and it’s important to understand
    the differences between them. Here are some different types that you’re likely
    to encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Corrective maintenance**: This is when we’re fixing bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptive maintenance**: In this case, we change code to adapt to new requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Perfective maintenance**: When we improve code without changing the functionality.
    Examples of this could be refactoring or improving the performance of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preventive maintenance**: Changing the code to prevent future bugs or issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maintenance process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every time you change code, you introduce risk. For example, a bug fix could
    introduce a new bug. To mitigate this risk, we need to follow a process. A suggested
    process could be the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify**: Identify the problem or the change that needs to be made.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inspect**: Inspect the test coverage and how well your code is covered by
    tests. The better it’s covered, the more likely you are to detect any introduced
    bugs or other issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Plan**: Plan the change. How are you going to make it? What tests are you
    going to write? What tests are you going to run?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implement**: Implement the change.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Verify**: Verify that the change works as expected. Run the tests, run the
    application, check the logs, etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integrate:** This is about ensuring any change you make in a branch is merged
    into the main branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Release/deploy the change**: You want to make sure the end customer can leverage
    the benefit of this change. For that to happen, you need to deploy it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we need to cover all these steps for every change? No, it depends on the
    change; some changes might be so small that we might want to bundle many of them
    before we make a release that we want the end customer to have. The good news
    is that we have a great tool in GitHub Copilot that can help us with some of these
    minor steps, allowing us to focus on the more important steps.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing a bug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some bugs are more severe than others. In a best-case scenario, your bug is
    seldom encountered, or when it does occur it’s not a big deal. In a worst-case
    scenario, your bug loses you money. Let’s focus on a case where the bug loses
    you money in a scenario where you’re running an e-commerce site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopefully, this code has never been shipped in production, but it’s a good
    example of a bug that could be catastrophic for an e-commerce site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The problem you might have is that `ship_order` is called even if `process_payment`
    fails, which means you ship orders without getting paid, losing you money.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at this code, you might not have a problem if `process_payment` throws
    an error and you don’t even get to `ship_order`.
  prefs: []
  type: TYPE_NORMAL
- en: What if it doesn’t and, instead, returns a numerical code that depends on payment
    results, like so?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t read the error code, you might not notice that the payment failed,
    and the order is shipped. So, what’s our approach here?
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Identify the problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to identify the problem; in this case, there are two things
    you can do, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read the code**: What does our code look like? Are errors thrown, does it
    return a code, or something else entirely?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Check the tests**: Do we have a test that covers this scenario? If not, we
    need to write one. The test should show that we have a bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use Copilot for this, with a prompt like so (here, we simulate `process_payment`
    to return error codes instead of throwing errors). Select the `ship_order` code
    in the main window, and then type a prompt as follows in the chat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test for the code; `ship_order` should not be called if `process_payment`
    returns 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the GitHub Copilot Chat function and selecting the `process_cart`
    code in our text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a response similar to the below code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]python'
  prefs: []
  type: TYPE_NORMAL
- en: import unittest
  prefs: []
  type: TYPE_NORMAL
- en: from unittest.mock import Mock, patch
  prefs: []
  type: TYPE_NORMAL
- en: 'from your_module import process_cart  # replace with the actual module name'
  prefs: []
  type: TYPE_NORMAL
- en: 'class TestProcessCart(unittest.TestCase):'
  prefs: []
  type: TYPE_NORMAL
- en: '@patch(''your_module.get_cart'')  # replace with the actual module name'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@patch(''your_module.process_payment'')'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@patch(''your_module.ship_order'')'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def test_order_not_shipped_if_payment_fails(self, mock_ship_order, mock_process_payment,
    mock_get_cart):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Arrange
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: mock_cart = Mock()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: mock_cart.get_card.return_value = 'test_card'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: mock_get_cart.return_value = mock_cart
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: mock_process_payment.return_value = 1
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Act
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: process_cart()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: mock_ship_order.assert_not_called()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: unittest.main()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: The above code contains a test that tests what happens if we get error code
    1 from `process_payment`. What we want to have happen is for `ship_order` not
    to be called.
  prefs: []
  type: TYPE_NORMAL
- en: This test will fail, as we have a bug in our code, which is a good thing, as
    we’ve identified a bug and can prove it exists with a test.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Implement the change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a test that shows we have a bug, we can implement the change.
    We can be confident to make the code change, as we have a test that shows that
    we have a bug, and we’ve hopefully also improved test coverage enough.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t start refactoring unless you have good test coverage or the change is
    so small that you are confident that you won’t introduce a bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we now improve the code? Simple – we can use GitHub Copilot to help
    us with the implementation. Let’s use the following prompt to help us with the
    code change we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the change; `ship_order` should not be called if `process_payment`
    returns 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code for `process_cart` should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]python'
  prefs: []
  type: TYPE_NORMAL
- en: 'def process_cart():'
  prefs: []
  type: TYPE_NORMAL
- en: get cart from database
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: cart = get_cart()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: card = cart.get_card()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: payment_status = process_payment(card, cart)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Only ship the order if the payment was successful
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if payment_status != 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ship_order(cart)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: This code above is a step in the right direction, as it now contains an `if`
    statement that checks the payment status.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further improve the code, we can use Copilot to help us make the code more
    robust and easier to read. Let’s use the following prompt for additional improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Refactor the code, making it easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might give you the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Here, Copilot has suggested that we extract the payment status into a separate
    function. This is a good suggestion, as it makes the code easier to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we’ll look at an existing codebase and add a new feature.
    The codebase is like the one we used in the previous example, but it’s a bit more
    complex. This is because it has a few more functions involving different types
    of payment methods. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]python'
  prefs: []
  type: TYPE_NORMAL
- en: import re
  prefs: []
  type: TYPE_NORMAL
- en: 'def validate_card(card):'
  prefs: []
  type: TYPE_NORMAL
- en: Visa cards start with 4 and have 13 or 16 digits.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: MasterCard cards start with 51 through 55 and have 16 digits.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: visa_pattern = r'^4[0-9]{12}(?:[0-9]{3})?$'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mastercard_pattern = r'^5[1-5][0-9]{14}$'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if re.match(visa_pattern, card):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return 'Visa'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elif re.match(mastercard_pattern, card):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return 'MasterCard'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return None
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def process_payment(card, cart):'
  prefs: []
  type: TYPE_NORMAL
- en: card_type = validate_card(card)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if card_type is None:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return 1  # Invalid card'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Process the payment here
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Return 0 if the payment is successful, 1 otherwise
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: pass
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def process_cart():'
  prefs: []
  type: TYPE_NORMAL
- en: Get cart from database
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: cart = get_cart()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: card = cart.get_card()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: payment_status = process_payment(card, cart)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Only ship the order if the payment was successful
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if payment_status == 0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ship_order(cart)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate_card` validates the card number and returns the card type if valid;
    otherwise, it returns `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process_payment` processes the payment and returns `0` if the payment was
    successful; otherwise, it returns `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process_cart` processes the cart, gets the card, processes the payment, and
    ships the order if the payment is successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1\. Identify a problem and find the function/s to change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our task is to make our code also support American Express cards. Implementing
    a new card means that we need to update the `validate_card` function to support
    American Express cards.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know what functions need to change, but does GitHub Copilot know?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s ask GitHub Copilot, with a prompt.
  prefs: []
  type: TYPE_NORMAL
- en: In the identification step, we used our know-how to identify what and where
    to change. A good practice is to rely on a combination of your own skills and
    the Copilot tool to help analyze and identify problems.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Implement change, and add a new feature and tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use GitHub Copilot to help us with this. We can use the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Add support for American Express cards.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get code similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above code, Copilot has made the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a new regular expression in the `validate_card` function to support
    American Express cards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new `elif` statement to return American Express if the card matches
    the new regular expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, we’re not done yet; we need to add a test to verify that the code
    works as expected. Let’s use the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test for the code; validate_card should return American Express for
    a valid card.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your test should look like below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]python'
  prefs: []
  type: TYPE_NORMAL
- en: import unittest
  prefs: []
  type: TYPE_NORMAL
- en: 'from your_module import validate_card  # replace with the actual module name'
  prefs: []
  type: TYPE_NORMAL
- en: 'class TestValidateCard(unittest.TestCase):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_validate_card_returns_amex_for_valid_amex_card(self):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Arrange
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: valid_amex_card = '378282246310005'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Act
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: result = validate_card(valid_amex_card)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: self.assertEqual(result, 'American Express')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: unittest.main()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: The new test, `test_validate_card_returns_amex_for_valid_amex_card`, was added
    by Copilot and tests that the `validate_card` function returns `American Express`
    for a valid American Express card.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it’s a good idea to keep iterating; you not only want to test
    that the code works for a valid card but also for an invalid card, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Copilot as a challenge to write more tests.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving performance is a common task but can be tricky to achieve. Usually,
    you need specific tools to measure performance, and you need to know what to measure.
    A good way to find out how to improve your code in this way is to use a decorator
    to *profile* how long a method takes to execute. Then, you can measure specific
    methods and find out which methods to improve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a decorator being used on a function that sleeps for 2
    seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `profile` function is a decorator that takes a function as input and returns
    a function that wraps the input function. The `wrapper` function measures the
    time it takes to execute the input function and prints the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Were you to run this code via the terminal, you would see output similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: OK, so how do we use this to improve performance? Let’s use GitHub Copilot and
    see how we can get advice on improving performance on a piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code we want to improve. This processes records and looks for duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Most developers looking at this will refer back to their algorithms and data
    structures books and start thinking about things like *Big O notation*, a way
    to measure the performance of an algorithm. The main thing to focus on is reducing
    the number of costly operations to improve performance while retaining the same
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the question we should ask GitHub Copilot is, how do we improve this code?
    Let’s use the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Improve the performance of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get something like this back:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why is this code better? Well, let’s prove it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, by calculating the Big O notation for the original code and then for
    the new code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, by using the decorator we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Big O notation calculation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try this prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the Big O complexity for this code? Show me how you calculated it as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of the provided code is *O(n^2)*, where n is the number
    of records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it’s calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: The outer loop runs n times, where n is the number of records. This is because
    it iterates over each record in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the outer loop, there’s an inner loop that also runs n times for the
    same reason.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the inner loop runs n times for each iteration of the outer loop, the
    total number of iterations is *n * n*, or *n^2*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the time complexity is *O(n^2)*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if you double the number of records, the time it takes to process
    them will increase by about four times. This is a characteristic of quadratic
    time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: OK, *O(n^2)* is not great, but what about the new code?
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the same prompt but on the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of the provided code is *O(n)*, where n is the number of
    records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it’s calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: The loop runs n times, where n is the number of records. This is because it
    iterates over each record in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the loop, the operations (checking if a record is in the set and potentially
    adding it to the set) are constant time, *O(1)*, because set operations in Python
    are typically constant time on average.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the time complexity is *O(n)* ** O(1)*, which simplifies to *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if you double the number of records, the time it takes to process
    them will also double, which is a characteristic of linear time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '*O(n)* is better than *O(n^2)*, but how much better? Let’s measure this in
    the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK, so algorithmically, we know that the new code is better, but how much better?
    Let’s measure it by using the decorator and calling the code. Let’s use the input
    of 1,000 records and 10,000 records and compare the time it takes to execute the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let’s see if the new code is faster than the old code. Let’s try with 10,000
    records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by combining your knowledge with GitHub Copilot, you can improve
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Your code won’t always look this obvious, and you might need to do more work
    to improve performance. You’re recommended to use a profiler to measure performance,
    and then use GitHub Copilot to help you improve the code.
  prefs: []
  type: TYPE_NORMAL
- en: Improving maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting use case is using GitHub Copilot to help you improve the
    maintainability of your code. So what are some things that you can do to improve
    the maintainability of your code? Here’s a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improve the naming** of variables, functions, classes, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separate concerns**: For example, separate business logic from presentation
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remove duplication**: Especially in large codebases, you’re likely to find
    duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improve readability**: You can improve readability by, for example, using
    comments, docstrings, event tests, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with a codebase and see how we can improve it. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The above codebase describes the following at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: A function, `calculate_total`, that calculates the total for a cart and a list
    of discounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of discounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you can see from this codebase is that it’s not very maintainable, as it’s
    hard to understand what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Identify the problems. What problems do you see?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first ask GitHub Copilot what it thinks about the code and decide what
    to do next. Let’s use the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: What do you think about the code? What would you do to improve it?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You get a lengthy response back with a bullet list and improved code. Let’s
    look at the bullet list first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Classes for Items and Discounts**: Right now, items and discounts are
    represented as dictionaries and strings, respectively. Using classes for these
    entities would make the code more readable and flexible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separate Discount Functions**: The discount functions are currently defined
    inside the `calculate_total` function. It would be better to define these functions
    separately to improve readability and make the code easier to test and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use a More Extensible Approach for Applying Discounts**: The current approach
    for applying discounts involves a series of `if-elif` statements. This could be
    made more extensible by storing the discount functions in a dictionary or a list
    of `Discount` objects, and then iterating over that collection to apply the discounts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: The problems identified above all seem reasonable – using classes, separating
    functions, and using dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Add tests and de-risk change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we look at a suggested code change, we need to minimize the risk of
    introducing a bug. The first thing we should do is check our test coverage. In
    this case, we don’t have any tests, so we need to write some. Let’s use the following
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Write tests for this code, covering all possible execution paths.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should never trust what an AI generates, so take your time to review
    the code, run a test coverage tool, and ensure that you’re happy with the code
    before you proceed to the next step, which is to improve the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the code from the first suggestion from Copilot, you want to ensure
    that it runs and uses classes like `Item` when you add items to a cart, for example.
    Below is the result of those alterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: OK, so we now have a codebase that we’re happy with and that’s passing tests.
    Let’s now look at the suggested code change from GitHub Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Implement change and improve maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OK, we feel confident that we have good test coverage and we’re ready to improve
    the code. Let’s use the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Improve the maintainability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the maintainability of the code, we can make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the discount functions out of `calculate_total` to make them standalone
    functions. This improves readability and makes it easier to test these functions
    individually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a dictionary to map discount names to their corresponding functions. This
    eliminates the need for multiple `if/elif` statements when applying discounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is now easier to maintain, as the following changes have been introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '`calculate_total` is a vastly smaller function, where each of the functions
    it used to contain has been moved out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same method mentioned also now uses a dictionary to map names to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key to using Copilot effectively is to keep iterating, keep making small
    changes, and see what Copilot suggests. Change the prompt slightly, see what happens,
    and go with the output that best suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try improving the code further using a prompt and GitHub Copilot. What should
    happen if there’s a problem with the payment? Should you log it, maybe raise an
    error, etc.?
  prefs: []
  type: TYPE_NORMAL
- en: Updating an existing e-commerce site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s continue working on the e-commerce site that we presented in previous
    chapters. In this chapter, we’ll focus on improving the codebase and adding new
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, let’s show the `basket.html` file we’ve started to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is an early version of a prototype; it’s not meant to be production-ready
    code. However, we can use this code to improve it and make it production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know this code isn’t great, let’s improve it with Copilot and the
    following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Improve the code, making it production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This prompt highlights some of the problems with the code, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separate JavaScript and CSS into external files**: This makes the code more
    maintainable and allows for caching of these resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use a build tool or a module bundler**: Tools like Webpack or Parcel can
    help you manage dependencies, transpile modern JavaScript to older versions for
    better browser compatibility, and minify your code for production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error Handling**: Add error handling to your methods to ensure your application
    can gracefully handle unexpected situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vue Component Structure**: Instead of creating the entire `Vue app` in one
    script, break it down into reusable components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessibility**: Ensure that your HTML is accessible by using appropriate
    ARIA roles and properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a great list of things we can ask about next, but let’s see what code
    changes it suggests. It suggests code separated into two different files, one
    for the HTML and one for the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at how the JavaScript was improved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A great step forward. As a developer, you can see that the JavaScript code
    uses static data, so let’s change that with the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Improve the code, use dynamic data by calling an API, and also generate a separate
    Python API with Flask that has the route /api/basket, containing the basket data.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we get two files, the API and the JavaScript code. Let’s look at the API
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Above you get a route `/api/basket` that returns the basket data. Let’s look
    at the improved JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! We’re now getting data from the API. How can we improve the code? If
    you’ve built a Vue app before, you will know that it involves using the Vue CLI
    and has a build step. Let’s ask GitHub Copilot about this with the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Improve the code, use the Vue CLI, and add a build step.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we get both commands and file changes back as a response, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `Vue` CLI globally on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Vue` project
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create a new `Vue` component for the basket. Create a new file `Basket.vue`
    in the `src/components` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import and use this component in your main `App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the `Vue` CLI’s build command to create a production-ready
    version of your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will create a dist directory with a production-ready version of your app.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: This looks like a step in the right direction. However, you should always test
    the code to make sure it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: As a challenge, see if the above code works and if you can improve it further.
  prefs: []
  type: TYPE_NORMAL
- en: Code is likely to change between versions of a framework. In this case, we’re
    using Vue.js, so make sure to consult the documentation for the version that you
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find a piece of code you want to improve. Follow the process outlined in this
    chapter to:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the problems. What problems do you see?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add tests and de-risk changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the changes and improve maintainability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you don’t have a piece of code you want to improve, try using the code from
    this chapter or the code from the Kata (Gilded Rose) GitHub page: [https://github.com/emilybache/GildedRose-Refactoring-Kata](https://github.com/emilybache/GildedRose-Refactoring-Kata).'
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What’s the difference between greenfield and brownfield development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A: Greenfield development is when you start coding from scratch; brownfield
    development is when you update existing code.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the best way to update existing code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A: The best way is to make small changes and have plenty of tests in place.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we established that a very important aspect of writing code
    is to update existing code, which is known as brownfield development. We also
    looked at how GitHub Copilot can help you with this task.
  prefs: []
  type: TYPE_NORMAL
- en: The most important message to take away from this chapter is to ensure that
    you have an approach to updating code that de-risks the changes you’re about to
    make. It’s better to make a small change several times than a big one once. It’s
    also strongly recommended to have plenty of tests in place before you start changing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/aicode](https://packt.link/aicode)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code510410532445718281.png)'
  prefs: []
  type: TYPE_IMG
