- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Introduction to Time Series
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列简介
- en: In [*Chapter 9*](B18945_09.xhtml#_idTextAnchor148), *Discriminant Analysis*,
    we concluded our overview of statistical classification modeling by introducing
    conditional probability using Bayes’ theorem, **Linear Discriminant Analysis**
    (**LDA**), and **Quadratic Discriminant Analysis** (**QDA**). In this chapter,
    we will introduce time series, the underlying statistical concepts, and how to
    apply them in everyday analysis. We will introduce the topic with the distinction
    between time-series data and what we have discussed up to this point in the book.
    We then provide an overview of what to expect with time-series modeling and the
    goals it can be leveraged to achieve. Within the context of time series, we then
    reintroduce the mean and variance statistical parameters, in addition to correlation.
    We provide an overview of **linear differencing**, **cross-correlation**, and
    **autoregressive** (**AR**) and **moving average** (**MA**) properties and how
    to identify their ordering using **autocorrelation function** (**ACF**) and **partial
    ACF** (**PACF**) plots. After, we provide an overview of the introductory white-noise
    model. We conclude the chapter with a detailed, formal overview of the concept
    of stationarity, arguably the most important precursor to successful time-series
    forecasting.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 9 章*](B18945_09.xhtml#_idTextAnchor148)中，*判别分析*，我们通过引入贝叶斯定理的条件概率、**线性判别分析**（**LDA**）和**二次判别分析**（**QDA**）来结束我们对统计分类建模的概述。在本章中，我们将介绍时间序列、其背后的统计概念以及如何在日常分析中应用它们。我们将通过区分时间序列数据与本书到目前为止所讨论的内容来引入这个主题。然后，我们概述了时间序列建模可以期待的内容以及它可以实现的目标。在时间序列的背景下，我们重新引入了均值和方差统计参数，以及相关性。我们概述了**线性差分**、**互相关**和**自回归**（**AR**）以及**移动平均**（**MA**）属性，以及如何使用**自相关函数**（**ACF**）和**偏自相关函数**（**PACF**）图来识别它们的阶数。之后，我们概述了入门级白噪声模型。我们以对平稳性概念的详细、正式概述来结束本章，平稳性可以说是成功进行时间序列预测的最重要先决条件之一。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: What is a time series?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是时间序列？
- en: Goals of time-series analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列分析的目标
- en: Statistical measurements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计测量
- en: The white-noise model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白噪声模型
- en: Stationarity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平稳性
- en: What is a time series?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是时间序列？
- en: In this chapter and the next few chapters, we will work with a type of data
    called time-series data. Up until this point, we have worked with independent
    data—that is, data consisting of samples that are not related. A time series is
    typically a measurement of the same sample taken over time, which makes the samples
    in this type of data related. There are many time series present around us every
    day. A few common examples of time series are daily temperature measurements,
    stock price ticks, and the heights of ocean tides. While a time series does not
    need to be measured at fixed intervals, in this book, we will primarily be concerned
    with measurements taken at fixed intervals, such as daily or every second.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和接下来的几章中，我们将处理一种称为时间序列数据的数据类型。到目前为止，我们一直在处理独立数据——也就是说，由不相关的样本组成的数据。时间序列通常是同一样本随时间的测量，这使得此类数据中的样本相关。我们周围每天都有许多时间序列。时间序列的一些常见例子包括每日温度测量、股票价格波动和海洋潮汐的高度。虽然时间序列不需要在固定间隔进行测量，但在这本书中，我们将主要关注固定间隔的测量，例如每日或每秒。
- en: 'Let’s look at some notation. In the following equation, we have a variable
    x that is repeatedly sampled over time. The subscripts enumerate the sample points
    (sample 1 through sample t), and the whole series of samples is denoted X. The
    subscript value is commonly called the **lag** of the variable. For example, x 2
    could be referred to as the second lag of the variable x:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些符号。在下面的方程中，我们有一个变量 x，它在时间上被反复采样。下标枚举了采样点（从样本 1 到样本 t），整个样本系列表示为 X。下标值通常被称为变量的**滞后**。例如，x²可以被称为变量
    x 的第二个滞后：
- en: X = x 1, x 2, … x t−1, x t
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: X = x₁, x₂, … xₜ₋₁, xₜ
- en: In general, the x points can be univariate or multivariate. For example, we
    could take a temperature reading over time that would result in a **univariate
    time series**, meaning each x term would correspond to a single temperature value.
    We could also take a more holistic set of weather readings such as temperature,
    humidity, rainfall, and sunshine, which would result in a **multivariate time
    series**, meaning each x term would correspond to a temperature, humidity, rainfall,
    and sunshine value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，x 点可以是单变量或多变量。例如，我们可以取一段时间内的温度读数，这将导致一个**单变量时间序列**，意味着每个 x 项将对应一个单独的温度值。我们也可以取一个更全面的天气读数集，如温度、湿度、降雨量和阳光，这将导致一个**多变量时间序列**，意味着每个
    x 项将对应温度、湿度、降雨量和阳光值。
- en: Our discussions on time series start with single variable analysis in this chapter
    and *Chapter 11*, *ARIMA Models*. But as with the chapters on regression, we will
    start with a single-variable approach and proceed to work with multivariate time
    series. Just as with the chapters on regression, we may find the multiple variables
    in a time series are related to the outcome of a variable of interest. In [*Chapter
    12*](B18945_12.xhtml#_idTextAnchor188), *Multivariate Time Series*, we will deal
    with the extra complexity of multivariate time series and extend the single-variable
    models discussed in [*Chapter 11*](B18945_11.xhtml#_idTextAnchor174) to multiple
    variables in [*Chapter 12*](B18945_12.xhtml#_idTextAnchor188). In this chapter,
    we will cover the basics of time series.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章和第 11 章*ARIMA 模型*中开始讨论时间序列，但就像回归章节一样，我们将从单变量方法开始，然后转向处理多变量时间序列。正如回归章节一样，我们可能会发现时间序列中的多个变量与感兴趣变量的结果相关。在第
    12 章*多变量时间序列*中，我们将处理多变量时间序列的额外复杂性，并将第 11 章中讨论的单变量模型扩展到第 12 章中的多个变量。在本章中，我们将介绍时间序列的基本知识。
- en: Time series typically exhibit a property called **serial correlation**, which
    means that previous knowledge provides some knowledge about the future of the
    time series. We can measure serial correlation by comparing the current value
    of a time series to the previous values in the series to determine if present
    values are correlated with previous values. This type of correlation is also called
    **autocorrelation**. We will discuss more on autocorrelation later in this chapter,
    including how to determine if a series exhibits autocorrelation. Later in this
    chapter, we will look at how to make the calculations to determine whether data
    exhibits serial correlation and to calculate autocorrelation. However, let’s first
    discuss what we intend to achieve with time-series analysis.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列通常具有一个称为**序列相关性**的性质，这意味着先前的知识可以提供一些关于时间序列未来的知识。我们可以通过比较时间序列的当前值与序列中的先前值来确定当前值是否与先前值相关，从而衡量序列相关性。这种相关性也称为**自相关性**。在本章的后面，我们将讨论更多关于自相关性的内容，包括如何确定一个序列是否表现出自相关性。在本章的后面，我们将探讨如何进行计算以确定数据是否表现出序列相关性以及如何计算自相关性。然而，让我们首先讨论我们希望通过时间序列分析实现的目标。
- en: Goals of time series analysis
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列分析的目标
- en: 'There are two goals in time-series analysis:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析有两个目标：
- en: Identifying any patterns in the time series
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别时间序列中的任何模式
- en: Forecasting future values of the time series
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测时间序列的未来值
- en: We can use time-series analysis methods to uncover the nature of a time series.
    At the most basic level, we may want to know if a series appears to be random
    or if a time series appears to exhibit a pattern. If a time series has a pattern,
    we can determine if it has seasonal behavior, cyclical patterns, or exhibits trending
    behavior. *We will investigate the behaviors of time series both by observation
    and by the results of fitting models*. Models can provide insight into the nature
    of a series and allow us to forecast the future values of a time series.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用时间序列分析方法来揭示时间序列的本质。在最基本层面上，我们可能想知道一个序列是否看起来是随机的，或者时间序列是否显示出某种模式。如果一个时间序列有模式，我们可以确定它是否有季节性行为、周期性模式或表现出趋势行为。*我们将通过观察和模型拟合的结果来研究时间序列的行为*。模型可以提供关于序列本质的见解，并允许我们预测时间序列的未来值。
- en: The other goal of time-series analysis is **forecasting**. We see examples of
    forecasting in many common situations, such as weather forecasting and stock price
    forecasting. It is important to keep in mind that the methods of forecasting we
    cover in this book are not infallible. Great care should be taken when communicating
    results from forecasting models. Predictions from models are always uncertain.
    *Predictions should always be contextualized with an understanding of the model
    uncertainty*. We will endeavor to reinforce this concept through the use of prediction
    intervals and model error rates.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析的另一个目标是**预测**。我们在许多常见情况下都能看到预测的例子，例如天气预报和股价预测。重要的是要记住，本书中涵盖的预测方法并非完美无缺。在传达预测模型的结果时，应格外小心。模型预测总是不确定的。*预测应始终与对模型不确定性的理解相结合*。我们将通过使用预测区间和模型错误率来努力强化这一概念。
- en: Now, with the context of what we hope to achieve with time-series analysis,
    let’s start looking at tools for analyzing univariate time series.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在了解我们希望通过时间序列分析实现的目标的背景下，让我们开始探讨分析单变量时间序列的工具。
- en: Statistical measurements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计测量
- en: When using time-series models to work with serially correlated data sets, we
    need to understand mean and variance – within the context of time – in addition
    to autocorrelation and cross-correlation. Understanding these variables helps
    build an intuition about how time-series models work and when they are more useful
    than models that do not account for time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用时间序列模型处理序列相关数据集时，我们需要理解在时间背景下的均值和方差，除了自相关和互相关。理解这些变量有助于建立对时间序列模型如何工作以及它们何时比不考虑时间的模型更有用的直觉。
- en: Mean
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均值
- en: 'In time-series analysis, the sample mean of a series is the sum of all values
    across each point in time in the series divided by the count of values. Where
    *t* represents each discrete time step and *n* is the total number of time steps,
    we can calculate the sample mean of a time series as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析中，一个时间序列的样本均值是该序列中每个时间点的所有值的总和除以值的数量。其中 *t* 代表每个离散的时间步长，*n* 是总的时间步长数，我们可以如下计算时间序列的样本均值：
- en: _ X  =  1 _ n  ∑ t=1 n x t
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: _ X  =  1 _ n  ∑ t=1 n x t
- en: There are two types of processes generating time series; one is an ergodic process
    and the other is non-ergodic. An ergodic process has consistent output independent
    of time, whereas a non-ergodic process does not necessarily have consistent output
    over time. The sample mean of an ergodic process converges to the true population
    mean as the sample size increases. However, the sample mean of a non-ergodic process
    does not converge as the sample size increases; the sample mean of one end-to-end
    phase of a process’s output may not converge toward the process population mean
    similarly to the sample mean of another end-to-end phase of the same process.
    One example of a non-ergodic process is a machine that requires frequent recalibration
    as output quality diminishes due to factors such as moisture or vibration. The
    tools introduced in this chapter, and expanded in the next, will help an analyst
    overcome limitations presented by this natural constraint presented in process-driven
    time-series data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 生成时间序列的过程有两种类型；一种是有遍历性的过程，另一种是非遍历性的。有遍历性的过程具有独立于时间的恒定输出，而非遍历性的过程则不一定在时间上有恒定的输出。有遍历性的过程的样本均值随着样本量的增加会收敛到真实总体均值。然而，非遍历性的过程的样本均值不会随着样本量的增加而收敛；一个过程输出的一端到端的样本均值可能不会像另一个相同过程的一端到端的样本均值那样收敛到过程总体均值。非遍历性过程的例子之一是，由于湿度或振动等因素导致输出质量下降时需要频繁校准的机器。本章中介绍的工具，以及下一章中扩展的工具，将帮助分析师克服由过程驱动的时间序列数据中这种自然约束带来的局限性。
- en: 'In time-series analysis, the mean is commonly referred to as the **signal**.
    With respect to forecasting, the mean must be constant across time. We discussed
    in [*Chapter 6*](B18945_06.xhtml#_idTextAnchor104)*, Simple Linear Regression*
    – as we will later in this chapter and in the next – the concept of first-order
    differencing, which is a **low-pass linear filter** used to *remove* high-frequency
    data from our output and *pass through* low-frequency data. When a signal is not
    constant, as when it is monotonically increasing or decreasing, for example, a
    first-order difference can often be applied—and repeated as needed—to produce
    a constant. This is one requirement of a **stationary** time series. We will discuss
    all components of stationarity in the *Stationarity* section of this chapter.
    Once a mean is constant, the variance around it can be assessed for autocorrelation.
    If autocorrelation exists within the variance around the mean, we can produce
    models to learn the patterns of the process producing it. We can also forecast
    the process’s future patterns. A model with a constant mean and no autocorrelation
    can often be forecasted with the mean using a white-noise model. For all times,
    *t*, in a series, the formulation for a first-order linear difference is this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析中，平均值通常被称为**信号**。就预测而言，平均值必须随时间保持恒定。我们在[*第6章*](B18945_06.xhtml#_idTextAnchor104)“简单线性回归”中讨论了这一点——我们将在本章和下一章中进一步讨论——第一阶差分的概念，它是一种**低通线性滤波器**，用于**去除**输出中的高频数据并**通过**低频数据。当信号不是恒定的，例如它单调增加或减少时，通常可以应用第一阶差分——并且根据需要重复应用——以产生一个恒定的值。这是**平稳**时间序列的一个要求。我们将在本章的“平稳性”部分讨论平稳性的所有组成部分。一旦平均值是恒定的，就可以评估其周围的方差以进行自相关分析。如果平均值周围的方差存在自相关，我们可以生成模型来学习产生该过程的模式。我们还可以预测该过程未来的模式。具有恒定平均值和无自相关的模型通常可以使用白噪声模型使用平均值进行预测。对于序列中的所有时间`t`，第一阶线性差分的公式如下：
- en: Y t ′ = Y t − Y t−1.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Yt′ = Yt − Yt−1.
- en: 'Since the first-order difference is a numerical differentiation, it will result
    in the removal of one data point from the time series, so must be applied prior
    to any modeling. Here is an example of a first-order difference in tabular data:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一阶差分是数值微分，它会导致从时间序列中移除一个数据点，因此必须在任何建模之前应用。以下是一个表格数据中第一阶差分的示例：
- en: '| **Raw Data** | **First-Order Difference** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **原始数据** | **第一阶差分** |'
- en: '| 1.7 |  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 1.7 |  |'
- en: '| 1.4 | -0.3 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 1.4 | -0.3 |'
- en: '| 1.9 | 0.5 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 1.9 | 0.5 |'
- en: '| 2.3 | 0.4 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 2.3 | 0.4 |'
- en: '| 2.1 | -0.2 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 2.1 | -0.2 |'
- en: Figure 10.1 – First-order difference in tabular data
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 表格数据中的第一阶差分
- en: 'Here, we have an example of data transformed with a first-order difference.
    The `numpy` `diff()` function can be used as follows, where `n=1` prescribes a
    first-order difference:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个使用第一阶差分转换的数据示例。可以使用`numpy`的`diff()`函数，其中`n=1`指定第一阶差分：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Variance
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方差
- en: 'Variance is a statistic for measuring the dispersion of data around a mean
    for a given distribution. Within the context of time-series analysis, variance
    is distributed around the mean across time. If we have a discrete and stationary
    process, we can calculate the variance of the sample mean as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 方差是衡量给定分布中数据围绕平均值分散程度的统计量。在时间序列分析的背景下，方差随时间分布在平均值周围。如果我们有一个离散且平稳的过程，我们可以按以下方式计算样本均值的方差：
- en: Var( _ X ) =  σ 2 _ n   ∑ k=−(n−1) n−1 (1 −  |k| _ n ) ρ k
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Var(X) = σ2n ∑k=−(n−1)n−1(1 − |k|n)ρk
- en: 'Here, *n* is the length of the time series, *k* is the number of lags to be
    included in the series autocorrelation (serial correlation) calculation and ρ k
    is the autocorrelation for that lookback horizon. This variance calculation can
    be obtained through model construction, which we will walk through in [*Chapter
    11*](B18945_11.xhtml#_idTextAnchor174)*, ARIMA Models*. It is in model construction
    – where we build the **characteristic equations** for the time series – that the
    measurement of variance becomes most important. Otherwise, we focus on autocorrelation
    to build intuition about the variance and the process producing it. Oftentimes,
    we have what is referred to as white-noise variance, which is a random distribution
    of variance generated from a stochastic process. White-noise variance has no autocorrelation
    across the time horizon. In the case of white-noise variance, we have only the
    following calculation for variance, which is the same calculation for data that
    is not serially correlated:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*n* 是时间序列的长度，*k* 是要包含在序列自相关（序列相关）计算中的滞后数，ρ_k 是该回望范围的自相关。这种方差计算可以通过模型构建获得，我们将在[*第11章*](B18945_11.xhtml#_idTextAnchor174)*，ARIMA模型*中介绍。在模型构建——即我们为时间序列构建**特征方程**的地方——测量方差变得最为重要。否则，我们关注自相关以建立对方差及其产生过程的直觉。通常，我们有什么被称为白噪声方差，这是从随机过程中生成的随机方差分布。白噪声方差在时间范围内没有自相关。在白噪声方差的情况下，我们只有以下方差计算，这与非序列相关数据的计算相同：
- en: Var( _ X ) =  σ 2 _ n
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Var( _ X _ ) = σ^2 _ n
- en: Data exhibiting white-noise variance can often be modeled with an average as
    there are no correlated errors. However, there may be transformations required
    in order to use an average, such as a first-order difference or a seasonal difference.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表现出白噪声方差的数据通常可以用平均值来建模，因为没有相关误差。然而，可能需要进行变换才能使用平均值，例如一阶差分或季节性差分。
- en: 'One common hypothesis test used in time-series analysis to assess if the variance
    in a series is white noise is the Ljung-Box test, created by Greta Ljung and George
    Box. The Ljung-Box test has the following hypotheses:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析中，用于评估序列方差是否为白噪声的常见假设检验是Ljung-Box测试，由Greta Ljung和George Box创建。Ljung-Box测试有以下假设：
- en: 'H o : Data points are independently distributed with no serially correlated
    errors'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'H_0 : 数据点独立分布，没有序列相关误差'
- en: 'H a : Data points are not independently distributed and thus present serially
    correlated errors'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'H_a : 数据点不是独立分布的，因此存在序列相关误差'
- en: 'This test can be applied to the residuals of any time-series model—for example,
    a linear model that uses time as an input or an **autoregressive integrated moving
    average** (**ARIMA**) model. If the result of the Ljung-Box test is the validation
    of the null hypothesis, the model tested is assumed to be valid. If the null hypothesis
    is rejected, a different model may be required. The Ljung-Box test statistic is
    shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试可以应用于任何时间序列模型的残差——例如，使用时间作为输入的线性模型或**自回归积分移动平均**（**ARIMA**）模型。如果Ljung-Box测试的结果是验证零假设，则假定测试的模型是有效的。如果拒绝零假设，可能需要不同的模型。Ljung-Box测试统计量如下所示：
- en: Q = n(n + 2)∑ k=1 h   ˆ ρ  k 2 _ n − k
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Q = n(n + 2)∑ k=1 h ˆρ k^2 _ n − k
- en: 'Here, *n* is the sample size, *k* corresponds to each lag in the test, *h*
    is the total time horizon being tested, and  ˆ ρ  k is the sample autocorrelation
    for each lag. The test follows the Chi-Square (χ 2) distribution and thus places
    more emphasis on more recent lags than those in the distant past. The Ljung-Box
    test statistic is compared to χ 2 distribution with *h* degrees of freedom, as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*n* 是样本大小，*k* 对应于测试中的每个滞后，*h* 是正在测试的总时间范围，ˆρ_k 是每个滞后的样本自相关。该测试遵循卡方（χ^2）分布，因此比远期滞后的更重视近期滞后。Ljung-Box测试统计量与具有
    *h* 个自由度的χ^2分布进行比较，如下所示：
- en: Q > χ 1−α,h 2
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Q > χ^(1−α)_{h,2}
- en: 'Here, *h* is the tested horizon. A Q-statistic greater than the χ 2 critical
    value results in rejecting the null hypothesis. The Ljung-Box test can also be
    applied to data without a model to test whether it is constant, zero-mean data
    with white-noise variance. Otherwise, the test is performed on the residuals of
    a model. Let’s generate a random, normally distributed sample of 1,000 data points
    having a mean of 0 and a standard deviation of 1 so that we can test using Ljung-Box
    whether the data is **stationary** **white noise**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*h*是测试的滞后。如果Q统计量大于χ 2临界值，则拒绝零假设。Ljung-Box测试也可以应用于没有模型的数据，以测试它是否是具有白噪声方差的零均值数据。否则，测试是在模型的残差上进行的。让我们生成一个具有均值为0和标准差为1的1,000个数据点的随机正态分布样本，以便我们可以使用Ljung-Box测试来检查数据是否是**平稳**
    **白噪声**：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can observe based on the raw data that the mean is constant. We can also
    see that the autocorrelation structure appears to have no significant lags, which
    is a strong indication the variance is randomly distributed white noise. In model
    development, this lack of autocorrelation is what you would want to see from the
    residuals to help verify a model fits the process’s data well:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据原始数据观察到均值是恒定的。我们还可以看到，自相关结构似乎没有显著的滞后，这是一个强烈的迹象，表明方差是随机分布的白噪声。在模型开发中，这种缺乏自相关是您希望从残差中看到的，以帮助验证模型很好地拟合了过程的数据：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In *Figure 10**.2,* we can see the original white noise data and the ACF plot,
    which exhibits no statistically significant autocorrelation across lags:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Figure 10**.2*中，我们可以看到原始白噪声数据和ACF图，该图在滞后期之间显示出没有统计上显著的自相关：
- en: '![Figure 10.2 – Visual analysis of random white noise](img/B18945_10_002.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.2 – 随机白噪声的视觉分析](img/B18945_10_002.jpg)'
- en: Figure 10.2 – Visual analysis of random white noise
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.2 – 随机白噪声的视觉分析
- en: 'Now, let’s use the Ljung-Box test to check our assumptions about autocorrelation.
    We perform this test with the `acorr_ljungbox()` function from `statsmodels`.
    We apply the `lags=[50]` argument to test if the autocorrelation is 0 out to 50
    lags:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Ljung-Box测试来检查我们对自相关的假设。我们使用`statsmodels`中的`acorr_ljungbox()`函数进行此测试。我们应用`lags=[50]`参数来测试自相关是否在50个滞后期之外为0：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The test returns an insignificant p-value, seen here. Therefore, we can assert
    that at a 95% level of confidence, the data has no autocorrelation and is thus
    white noise:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 测试返回了一个不显著的p值，如这里所示。因此，我们可以断言，在95%的置信水平下，数据没有自相关，因此是白噪声：
- en: '|  | `lb_stat` | `lb_pvalue` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  | `lb_stat` | `lb_pvalue` |'
- en: '| `50` | `51.152656` | `0.428186` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `50` | `51.152656` | `0.428186` |'
- en: Figure 10.3 – Ljung-Box test results for autocorrelation on white noise data
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.3 – 白噪声数据自相关Ljung-Box测试结果
- en: Autocorrelation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自相关
- en: 'As we’ve mentioned to this point, autocorrelation, also called serial correlation,
    is a measure of correlation for a given point corresponding to previous points
    in the time-constrained sequence of data. It is called “auto” as it refers to
    a variable’s correlation with itself at a previous lag. Autocorrelation across
    all preceding lags in the specified horizon—as opposed to for a specific lag—is
    referred to as **autocorrelation structure**. Here, we have, for any given lag
    *k* greater than zero, the ACF, r k:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们之前所提到的，自相关，也称为序列相关，是衡量数据时间序列中对应于先前点的给定点的相关性的度量。它被称为“自相关”，因为它指的是变量在先前滞后期与其自身的相关性。在指定范围内所有先前滞后期的自相关（而不是特定滞后期的自相关）被称为**自相关结构**。在这里，对于任何大于零的给定滞后*k*，我们有自相关函数，r k:'
- en: r k =  ∑ t=k+1 n  (y t −  _ y )(y t−k −  _ y )  ________________  ∑ t=1 n  (y t
    −  _ y ) 2
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: r k =  ∑t=k+1n(yt −  _y)(yt−k −  _y) __________________ ∑t=1n(yt −  _y)2
- en: 'We discussed autocorrelation in [*Chapter 6*](B18945_06.xhtml#_idTextAnchor104)*,
    Simple Linear Regression*, within the context of identifying serial correlation
    as a violation of the required assumption of sampling independence for linear
    regression. Here, we note that autocorrelation is a core component of time-series
    data. We previously visually explored this data in both [*Chapter 6*](B18945_06.xhtml#_idTextAnchor104)
    and this chapter using the ACF plot. We also discussed first-order differencing.
    Let’s explore these two concepts in depth using the *United States Macroeconomic*
    data set from `statsmodels`, which we used in [*Chapter 6*](B18945_06.xhtml#_idTextAnchor104).
    Here, we select `realinv` and `realdpi`, converting both variables to a 32-bit
    float:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第[*第6章*](B18945_06.xhtml#_idTextAnchor104) *简单线性回归*中讨论了自相关，是在识别自相关作为线性回归所需假设的样本独立性的违反的背景下。在这里，我们指出自相关是时间序列数据的核心组成部分。我们之前在[*第6章*](B18945_06.xhtml#_idTextAnchor104)和本章中使用了ACF图来直观地探索了这些数据。我们还讨论了一阶差分。让我们使用`statsmodels`中的*美国宏观经济*数据集深入探讨这两个概念，我们在[*第6章*](B18945_06.xhtml#_idTextAnchor104)中使用了这个数据集。在这里，我们选择`realinv`和`realdpi`，将这两个变量都转换为32位浮点数：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let’s plot the data and its ACF using 50 lags (`lags=50`) and a 5% level
    of significance (`alpha=0.05`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用50个滞后（`lags=50`）和5%的显著性水平（`alpha=0.05`）来绘制数据和其ACF：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We get the resulting plot as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果图：
- en: '![Figure 10.4 – realinv: original and first-difference data and ACFs](img/B18945_10_004.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – realinv：原始数据和一阶差分数据及其ACF](img/B18945_10_004.jpg)'
- en: 'Figure 10.4 – *realinv*: original and first-difference data and ACFs'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – *realinv*：原始数据和一阶差分数据及其ACF
- en: We can observe in the first plot of *Figure 10**.4* a positive, deterministic
    signal highlighting an overall upward trend in investment. We can also observe
    that—especially as the time nears lag 0—some variance around the data. These two
    components of the data are what we would initially attempt to model. In the original
    data’s ACF, we can see a significant, dampening autocorrelation structure, which
    is characteristic of exponential growth. However, because of the strong trend
    that dominates the autocorrelation, we aren’t able to observe any information
    about the correlation in the variance, such as potential seasonality, for example.
    To remove the strong signal, we apply a first difference using the `numpy.diff()`
    function so that we can observe the variance’s autocorrelation structure. Looking
    at the ACF for the differenced data, we can see some autocorrelation in the variance
    extending to lag 3 when applying a 95% confidence level.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图10.4的第一幅图中观察到，投资整体呈上升趋势的确定性信号，并且可以观察到数据周围的一些方差，尤其是在接近滞后0的时间附近。这些数据成分是我们最初尝试建模的。在原始数据的ACF中，我们可以看到一个显著的、衰减的自相关结构，这是指数增长的典型特征。然而，由于主导自相关的强烈趋势，我们无法观察到关于方差相关性的任何信息，例如潜在的季节性等。为了消除强烈的信号，我们使用`numpy.diff()`函数应用一阶差分，这样我们就可以观察到方差的
    autocorrelation 结构。观察差分数据的ACF，我们可以看到在应用95%置信水平时，方差的自相关延伸到滞后3。
- en: At this point, it is worth mentioning **autoregressive moving average** (**ARMA**)
    modeling, which we will use in [*Chapter 11*](B18945_11.xhtml#_idTextAnchor174),
    *ARIMA Models*. As we can see in the ACF plot, there is a long horizon of autocorrelation
    present. Going back to the autocorrelation equation we noted earlier, we can see
    the calculation does not control for specific lags in the time series since the
    errors across each point are all summed together prior to dividing by the variance.
    This is why the original ACF shows a dampening effect; it is reasonable to assume
    that lag 0 is not smoothly serially correlated, individually, with each previous
    lag. Because the ACF does not control for autocorrelation between specific lags,
    we can use this correlation information to build a moving average function that
    can help model the noise component of the data across a long period.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得提及**自回归移动平均**（**ARMA**）模型，我们将在[*第11章*](B18945_11.xhtml#_idTextAnchor174)
    *ARIMA模型*中使用它。正如我们在ACF图中可以看到的，存在一个长的自相关范围。回到我们之前提到的自相关方程，我们可以看到计算并没有控制时间序列中特定的滞后，因为每个点的误差在除以方差之前都被加在一起。这就是为什么原始ACF显示了衰减效应；合理地假设滞后0不是与每个之前的滞后平滑地序列相关的。因为ACF没有控制特定滞后之间的自相关，我们可以使用这种相关性信息来构建一个移动平均函数，这有助于在长时间段内建模数据的噪声成分。
- en: 'However, if we want to be able to construct a component of a model that allows
    us to define the relationship from point to point within the framework of ARMA
    models, we will want to also observe the PACF, which does control for the correlation
    between lags. Note in *Figure 10**.5* the original data and its PACF. It shows
    a much different level of granularity than the ACF plot does; whereas in the PACF
    we don’t see a continued significant correlation with lag 0 and those beyond lag
    4 until we near lag 30, we do see significant correlation in the ACF until almost
    lag 20\. However, the original data is not very helpful because it is not stationary,
    which is why we see almost as much correlation between lag 0 and lag 45 as we
    do lag 0 and lag 1, which suggests we would not be able to build a model that
    converges without transformation (the first-order difference, in this case):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要能够构建一个模型成分，使我们能够在ARMA模型的框架内定义点与点之间的关系，我们还将想要观察PACF，因为它确实控制了滞后之间的相关性。注意在*图10.5*中原始数据和它的PACF。它显示的粒度水平与ACF图大不相同；而在PACF中，我们直到接近滞后30时才看到与滞后0以及滞后4之后的持续显著相关性，而在ACF中，我们直到接近滞后20时才看到显著相关性。然而，原始数据并不很有帮助，因为它不是平稳的，这就是为什么我们看到滞后0和滞后45之间的相关性几乎与滞后0和滞后1之间的相关性一样多，这表明我们可能无法构建一个不经过变换（在这种情况下是一阶差分）就能收敛的模型：
- en: '![Figure 10.5 – realinv: original and first-difference data and PACFs](img/B18945_10_005.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – realinv：原始数据和一阶差分数据以及PACFs](img/B18945_10_005.jpg)'
- en: 'Figure 10.5 – *realinv*: original and first-difference data and PACFs'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – *realinv*：原始数据和一阶差分数据以及偏自相关函数（PACF）
- en: The result of the ACF in *Figure 10**.4* for the *transformed (differenced)
    data* suggests a moving average component up to an order of 3 (MA(3)) could be
    useful (although an MA(1) may be better). The result of the PACF in *Figure 10**.5*
    for the *transformed data* suggests an autoregressive component of order 1 (AR(1))
    may be useful. Using the PACF, we could also conclude an AR(10) may be useful,
    but selecting an order this high will often result in overfitting. A rule of thumb
    is to not use an AR or MA component with an order greater than approximately 5
    for process modeling. Model order, however, depends on the analyst and the process
    details. While we will discuss this concept in depth in [*Chapter 11*](B18945_11.xhtml#_idTextAnchor174)*,
    ARIMA Models*, if we are building an ARIMA model for this data, we would have
    a model of order (2,1,3) following the *AR(p)* and *MA(q)* construct we selected
    with an integrated difference, *d*, for the first-order difference we applied
    illustrated as an order **(p,d,q)** model. The orders are used to build **characteristic
    polynomial equations** based on the model that we can then use to assess **stationarity**
    and **invertibility**, which helps identify **model uniqueness** and assess its
    ability to **converge** toward a solution, using the roots of the equations’ factored
    forms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.4* 中对于*转换（差分）数据*的ACF结果表明，一个高达3阶（MA(3)）的移动平均成分可能是有用的（尽管MA(1)可能更好）。*图10.5*
    中对于*转换数据*的PACF结果表明，一个一阶自回归成分（AR(1)）可能是有用的。使用PACF，我们还可以得出AR(10)可能是有用的结论，但选择如此高的阶数通常会导致过度拟合。一个经验法则是，在过程建模中不要使用阶数大于大约5的AR或MA成分。然而，模型阶数取决于分析师和过程细节。虽然我们将在[*第11章*](B18945_11.xhtml#_idTextAnchor174)*，ARIMA模型*中深入讨论这个概念，如果我们为这些数据构建ARIMA模型，我们将有一个根据我们选择的带有积分差分*d*的一阶差分构建的模型，即*AR(p)*和*MA(q)*结构，如下所示**（p,d,q）**模型。这些阶数用于根据模型构建**特征多项式方程**，然后我们可以使用这些方程的因式分解形式的根来评估**平稳性**和**可逆性**，这有助于识别**模型唯一性**并评估其收敛到解的能力。'
- en: Cross-correlation
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉相关
- en: 'Moving on, we have, for any given lag *k* greater than zero, the **cross-correlation
    function** (**CCF**) that can be used to identify the correlation between two
    variables across points in time. This analysis can be used to facilitate the identification
    of leading or lagging indicators. The CCF for two one-dimensional vectors, *i*
    and *j*, for a given lag, *k*,  ˆ p  i,j(k), is shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，对于任何大于零的给定滞后 *k*，我们有一个**交叉相关函数**（**CCF**），它可以用来识别两个变量在不同时间点之间的相关性。这种分析可以用来帮助识别领先或滞后指标。对于给定滞后
    *k* 的两个一维向量 *i* 和 *j* 的交叉相关函数 ˆ p  i,j(k) 如下所示：
- en: ˆ p  i,j(k) =  ∑ t=1 n−k (x t,i −  _ x  i)(x t+k,j −  _ x  j)   _______________________   √ ____________  ∑ t=1 n  (x t,i
    −  _ x  i) 2  √ _____________  ∑ t=1 n  (x t+k,j −  _ x  j) 2
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ˆ p  i,j(k) =  ∑ t=1 n−k (x t,i −  _ x  i)(x t+k,j −  _ x  j)   _______________________   √ ____________  ∑ t=1 n  (x t,i
    −  _ x  i) 2  √ _____________  ∑ t=1 n  (x t+k,j −  _ x  j) 2
- en: In considering a case of linear regression where we have two ordered, sequence-based
    input variables predicting an ordered, sequenced-based dependent variable, we
    evaluate the input and output variables at the same time, *t*. However, if using
    cross-correlation to identify a leading or lagging indicator, we can identify
    the lag, *k*, at which the leading variable leads and modify its series position
    by *k* indices. For example, if the time unit of our model is in weeks and we
    build a regression model to predict sales using advertising as an input, we may
    find that in any given week, advertising has no impact on sales. However, after
    performing a cross-correlation analysis, we find a strong lag of 1 exists between
    advertising and sales such that investment in advertising in 1 week directly impacts
    sales in the following week. We then use this information to shift forward the
    advertising expenditure variable by 1 week and rerun the regression model to leverage
    the strong correlation between advertising expense and sales to predict market
    behavior. This is what we can refer to as a **lag effect**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑线性回归的案例中，我们有两个按顺序排列的基于序列的输入变量预测一个按顺序排列的基于序列的因变量时，我们同时评估输入和输出变量，即*t*。然而，如果使用交叉相关来识别领先或滞后指标，我们可以识别出领先变量领先时的滞后，即*k*，并通过*k*个索引修改其序列位置。例如，如果我们的模型的时间单位是周，并且我们构建一个回归模型来预测使用广告作为输入的销售，我们可能会发现，在任何给定的一周中，广告对销售没有影响。然而，在执行交叉相关分析后，我们发现广告和销售之间存在1周的强烈滞后，这意味着在1周内投资的广告直接影响到下一周的销售。然后我们使用这个信息将广告支出变量提前1周，并重新运行回归模型，利用广告支出和销售之间的强相关性来预测市场行为。这可以被称为**滞后效应**。
- en: 'Let’s look at an example of this in practice with Python. First, we need to
    assess the data. Let’s load the data to begin. We need to convert the values to
    a `float` type. We can round to two decimals and select `realinv` and `realdpi`,
    the variables for real gross private domestic investment and real private disposable
    income, respectively:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个Python的实际例子来看一下。首先，我们需要评估数据。让我们加载数据开始。我们需要将值转换为`float`类型。我们可以四舍五入到两位小数，并选择`realinv`和`realdpi`，分别是实际国内总投资和实际私人可支配收入的变量：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After plotting the data, here, we can see both series have what appears to
    be a strong, deterministic signal, which is the primary influence on the autocorrelations.
    It can easily be argued that the two variables are positively correlated, and
    both are increasing over time, which is mostly true. However, there is more to
    the data than meets the eye, in that regard; the mean (signal) is deterministic,
    but we need to assess the variance around the mean to truly understand how the
    two processes are correlated beyond the trend component. Note that in the following
    code, we use a lag of 50 when calculating the ACFs. A general rule of thumb in
    measuring ACFs is to not exceed a lag of 50 points, although this may differ based
    on context:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制数据后，我们可以看到两个序列似乎都有一种强烈的、确定性的信号，这是自相关性的主要影响因素。可以很容易地论证这两个变量是正相关的，并且两者都在随时间增加，这在很大程度上是正确的。然而，在这一点上，数据还有更多值得注意的地方；均值（信号）是确定的，但我们需要评估均值周围的方差，才能真正理解两个过程在趋势成分之外的关联程度。注意，在下面的代码中，我们在计算ACF时使用了50个滞后。在测量ACF时的一般规则是不要超过50个滞后点，尽管这可能会根据上下文而有所不同：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We get the following plot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下图表：
- en: '![Figure 10.6 – Comparing realinv to realdpi: raw data and ACF plots](img/B18945_10_006.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 比较realinv与realdpi：原始数据和ACF图](img/B18945_10_006.jpg)'
- en: 'Figure 10.6 – Comparing *realinv* to *realdpi*: raw data and ACF plots'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 比较realinv与realdpi：原始数据和ACF图
- en: We can see in *Figure 10**.6* that in addition to the strong deterministic signal,
    the ACF plots for both have exponentially dampening autocorrelations that are
    significant at the 95% confidence (outside of the shaded area) level. Based on
    this information in the ACFs, we should perform at least a **first-order difference**.
    We may need to perform two first-order differences if the ACFs exhibit the same
    behavior after one **first-order** **linear difference**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图10.6*中看到，除了强烈的确定性信号外，两个变量的ACF图都有指数衰减的自相关，在95%的置信水平（在阴影区域外）上是显著的。基于ACF中的这些信息，我们应该至少执行**一阶差分**。如果ACF在执行一次**一阶****线性差分**后表现出相同的行为，我们可能需要执行两次一阶差分。
- en: 'Let’s create the differenced data:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建差分数据：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, reusing the previous plotting code, we can see the data in *Figure 10**.7*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新使用之前的绘图代码，我们可以看到*图10.7*中的数据：
- en: '![Figure 10.7 – Comparing differenced realinv to differenced realdpi](img/B18945_10_007.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 比较差分realinv与差分realdpi](img/B18945_10_007.jpg)'
- en: Figure 10.7 – Comparing differenced *realinv* to differenced *realdpi*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 比较差分*realinv*与差分*realdpi*
- en: Based on *Figure 10**.7*, we can see *the deterministic signal that was previously
    dominating the autocorrelation in* *Figure 10**.6 is now removed*. There are a
    few points slightly outside the 95% confidence interval, although the level of
    significance is small (we do not consider lag 0 as lag 0 is 100% correlated with
    itself). Because some autocorrelation remains, we can consider their behaviors
    to not be entirely random. Thus, they could be cross-correlated. Since we addressed
    the issue of the deterministic signal, we can now assess the cross-correlation
    between the two series. Note that the means of the two series have been differenced
    to a constant zero. This is one condition of stationarity. Another is constant
    variance. We can see the differenced data has minimal autocorrelation, but that
    it is beyond the 95% confidence limit. Thus, we can ascertain additional ARIMA
    modeling may be useful, but we could also argue for using an average for modeling.
    However, we can also see that the third requirement of stationarity—constant covariance
    between periods—does not seem to be met; as the series continues across time steps,
    the variance fluctuates. We will discuss stationarity in more depth in the following
    section. For now, let’s turn our attention to cross-correlation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*图10.7*，我们可以看到之前在*图10.6*中主导自相关性的确定性信号现在已被移除。有几个点稍微超出了95%的置信区间，尽管显著性水平很小（我们不考虑滞后0，因为滞后0与自身100%相关）。由于一些自相关仍然存在，我们可以认为它们的行为并非完全随机。因此，它们可能是互相关的。由于我们已经解决了确定性信号的问题，我们现在可以评估两个序列之间的互相关性。请注意，两个序列的均值已经被差分到常数零。这是平稳性的一个条件。另一个条件是常数方差。我们可以看到差分数据具有最小的自相关性，但它超出了95%的置信限制。因此，我们可以确定额外的ARIMA建模可能是有用的，但我们也可以主张使用平均值进行建模。然而，我们也可以看到平稳性的第三个要求——期间内常数协方差——似乎没有满足；随着序列随时间步长继续，方差波动。我们将在下一节中更深入地讨论平稳性。现在，让我们将注意力转向互相关性。
- en: 'Now that we have removed the deterministic signal and the variance is the dominating
    behavior in the ACF plots, let’s compare the two time series to see if they have
    a lagging or leading relationship. Here, we construct a CCF for graphically plotting
    that. We have three options for the confidence interval using a dictionary, `zscore_vals`,
    to build the z-scores we use to build these confidence intervals—90%, 95%, and
    99%:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经移除了确定性信号，方差在ACF图中占主导地位，让我们比较这两个时间序列，看看它们之间是否存在滞后或领先关系。在这里，我们构建一个CCF来图形化地展示这一点。我们使用字典`zscore_vals`来构建z分数，从而构建三个置信区间选项——90%，95%，和99%：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can observe in *Figure 10**.8* many points of correlation beyond the 95%
    confidence interval we applied. However, we observe the highest level of correlation
    is at lag 0\. There may be multiple correct answers depending on the data domain
    or forecast error when a model is applied, but using the statistics, our study
    indicates the series are most correlated at lag 0 and thus, neither is a leading
    nor lagging indicator of the other. It is important to note the practical significance
    of a roughly 0.20 correlation is low; it explains very little variance. Therefore,
    short-term influence is minimal:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.8*中，我们可以观察到许多点超过了我们应用的95%置信区间。然而，我们观察到最高的相关性水平是在滞后0处。根据数据域或模型应用时的预测误差，可能会有多个正确答案，但使用统计数据，我们的研究表明，序列在滞后0处相关性最高，因此，它们既不是领先指标也不是滞后指标。重要的是要注意，大约0.20的相关性的实际意义很低；它解释了很少的方差。因此，短期影响很小：
- en: '![Figure 10.8 – Cross-correlation between realinv and realdpi](img/B18945_10_008.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – realinv与realdpi之间的互相关](img/B18945_10_008.jpg)'
- en: Figure 10.8 – Cross-correlation between *realinv* and *realdpi*
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – *realinv*与*realdpi*之间的互相关
- en: 'Since we’ve assessed that short-term cross-correlation between the two series’
    variances is minimal and we might still be interested in the strength of correlation
    overall, we could at this point use Pearson’s correlation coefficient to compare
    the two trends, which would measure correlation between the two long-run linear
    trends. Recall the equation for Pearson’s correlation coefficient to observe the
    relationship to the long-run mean:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经评估出两个时间序列方差之间的短期交叉相关性最小，而我们可能仍然对整体的相关强度感兴趣，因此在此阶段我们可以使用皮尔逊相关系数来比较这两个趋势，这将衡量两个长期线性趋势之间的相关性。回想一下皮尔逊相关系数的公式，以观察其与长期平均数的关系：
- en: r =  ∑ i=1 n  (x i −  _ x )(y i −  _ y )  ___________________   √ _____________________   ∑ i=1 n  (x i
    −  _ x ) 2∑ i=1 n  (y i −  _ y ) 2
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: r =  ∑ i=1 n (x i −  _ x)(y i −  _ y)  _________________________   √ _______________________   ∑
    i=1 n (x i −  _ x) 2 ∑ i=1 n (y i −  _ y) 2
- en: 'Let’s suppose, however, there was a leading indicator present in our data.
    Let’s shift `realdpi` forward by one place. Notice the `pandas` function `shift()`
    here, performing this operation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，然而，我们的数据中存在一个领先指标。让我们将`realdpi`向前移动一个位置。注意这里的`pandas`函数`shift()`执行此操作：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We get the result as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![Figure 10.9 – Shifted cross-correlation with leading indicator](img/B18945_10_009.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 带有领先指标的位移交叉相关性](img/B18945_10_009.jpg)'
- en: Figure 10.9 – Shifted cross-correlation with leading indicator
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 带有领先指标的位移交叉相关性
- en: After shifting `realdpi` forward one position, we can identify in *Figure 10**.9*
    that `realinv` is now a leading indicator, by a lag of one. If this were our original,
    differenced data, we might decide to apply a shift to the `realinv` variable—keeping
    in mind the practicality of the level of correlation—then use `realdpi` and the
    shifted `realinv` variable when using one variable to forecast the values of the
    other.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`realdpi`向前移动一个位置后，我们可以在*图10.9*中识别出`realinv`现在是一个领先指标，滞后一个单位。如果这是我们原始的、差分后的数据，我们可能会决定对`realinv`变量应用一个位移——同时考虑到相关性的实用性——然后在用一个变量预测另一个变量的值时使用`realdpi`和位移后的`realinv`变量。
- en: The white-noise model
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 白噪声模型
- en: 'Any time series can be considered to process two fundamental elements: signal
    and noise. We can present this mathematically as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时间序列都可以被认为是处理两个基本元素：信号和噪声。我们可以用以下数学公式表示这一点：
- en: y(t) = signal(t) + noise(t)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: y(t) = signal(t) + noise(t)
- en: 'The signal is some predictable pattern that we can model with a mathematical
    function. But the noise element in a time series is unpredictable and so cannot
    be modeled. Thinking of a time series this way leads to two consequential points:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是我们可以用数学函数建模的可预测模式。但时间序列中的噪声元素是不可预测的，因此不能建模。以这种方式思考时间序列会导致两个重要的观点：
- en: Before attempting to model, we should verify that the time series *is not consistent*
    with noise.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在尝试建模之前，我们应该验证时间序列*不是与噪声一致的*。
- en: Once we have fit a model to a time series, we should verify that the residuals
    *are consistent* with noise.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们对时间序列拟合了一个模型，我们应该验证残差*是与噪声一致的*。
- en: Regarding the first point, if a time series is consistent with noise, there
    is no predictable pattern to model, and attempting to model the time series could
    lead to misleading results. About the second point, if the residuals of a time-series
    model are not consistent with noise, then there are additional patterns we can
    further model, and the current model is not sufficient to explain the patterns
    in the signal. Of course, to make these assessments, we first need to understand
    what noise is. In this section, we will discuss the **white-noise model**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第一个问题，如果一个时间序列与噪声一致，那么就没有可预测的模式可以建模，尝试建模时间序列可能会导致误导性的结果。关于第二个问题，如果一个时间序列模型的残差与噪声不一致，那么我们还可以进一步建模其他模式，并且当前模型不足以解释信号中的模式。当然，为了做出这些评估，我们首先需要了解噪声是什么。在本节中，我们将讨论**白噪声模型**。
- en: White noise is a time series where the samples are independent and have a fixed
    variance with a mean of zero. This means that each sample of the time series is
    random. So, how do we assess whether a series is random? Let’s work through an
    example. Take a look at the series in *Figure 10**.10*. Do you think this series
    is random or a signal?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 白噪声是一个时间序列，其中样本是独立的，具有固定的方差和零均值。这意味着时间序列的每个样本都是随机的。那么，我们如何评估一个序列是否是随机的呢？让我们通过一个例子来分析。看看*图10.10*中的序列。你认为这个序列是随机的还是信号？
- en: '![Figure 10.10 – A sample time series](img/B18945_10_010.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 一个样本时间序列](img/B18945_10_010.jpg)'
- en: Figure 10.10 – A sample time series
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 一个样本时间序列
- en: The time series in *Figure 10**.10* is a random series generated with `numpy`.
    This is not clear from just observing the time series. Let’s take a look at how
    to determine whether a series is noise.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.10* 中的时间序列是使用 `numpy` 生成的随机序列。仅从观察时间序列中无法看出这一点。让我们看看如何确定一个序列是否为噪声。'
- en: 'As mentioned previously, the samples in a time series are independent. This
    means that the sample should not be autocorrelated. We can check the autocorrelation
    of this series with an ACF plot. The results are shown in *Figure 10**.11*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，时间序列中的样本是独立的。这意味着样本不应自相关。我们可以通过ACF图来检查这个序列的自相关性。结果如图 *图10.11* 所示：
- en: '![Figure 10.11 – ACF plot of time series in Figure 10.10](img/B18945_10_011.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 图10.10中时间序列的ACF图](img/B18945_10_011.jpg)'
- en: Figure 10.11 – ACF plot of time series in Figure 10.10
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 图10.10中时间序列的ACF图
- en: The ACF plot shows that the series does not appear to exhibit autocorrelation.
    This is a strong indication that the time series does not have a pattern to model
    and may just be noise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ACF图显示该序列似乎没有自相关性。这是一个强烈的迹象，表明该时间序列没有可建模的模式，可能仅仅是噪声。
- en: 'Another assessment we have is the Ljung-Box test for autocorrelation. This
    is a statistical test for autocorrelation in the lags of a time series. The null
    hypothesis is there is no autocorrelation, and the alternative hypothesis is there
    is a correlation. Since autocorrelation is appear at any lag of the time series,
    the Ljung-Box test provides a p-value for the autocorrelation at each lag. Performing
    the test on this series, we get the following p-values for the first 10 lags:
    `[0.41, 0.12, 0.21, 0.31, 0.44, 0.53, 0.5, 0.57, 0.26, 0.2]`. Each of these values
    is large, which indicates this series is likely noise.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种评估方法是Ljung-Box自相关检验。这是对时间序列滞后自相关性的统计检验。零假设是没有自相关性，备择假设是有相关性。由于自相关性可能出现在时间序列的任何滞后中，Ljung-Box检验为每个滞后提供了自相关的p值。对这个序列进行检验，我们得到前10个滞后的以下p值：`[0.41,
    0.12, 0.21, 0.31, 0.44, 0.53, 0.5, 0.57, 0.26, 0.2]`。这些值中的每一个都很大，这表明这个序列很可能是噪声。
- en: Both methods discussed previously indicate that the series shown is noise, which
    is the correct result (we know this series is randomly generated). As we progress
    with modeling time series, we will use these methods to determine whether a series
    is noise as part of model assessment. We will close this chapter with a discussion
    on the concept of time series stationarity.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的两种方法都表明显示的序列是噪声，这是正确的结果（我们知道这个序列是随机生成的）。随着我们进行时间序列建模，我们将使用这些方法来确定一个序列是否为噪声，作为模型评估的一部分。我们将以对时间序列平稳性的概念讨论来结束这一章。
- en: Stationarity
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态性
- en: 'In this section, we provide an overview of stationary and non-stationary time
    series. Broadly speaking, the main difference between these two types of time
    series is the statistical properties such as mean, variance, and autocorrelation.
    They do not vary across time in stationary time series but do change through time
    in non-stationary time series. Particularly, time series with a trend or seasonality
    is non-stationary because the trend or seasonality will affect the statistical
    properties. The following examples illustrate the behaviors of stationary versus
    non-stationary time series [1]:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了静态和非静态时间序列。总的来说，这两种类型时间序列的主要区别在于统计特性，如均值、方差和自相关性。在静态时间序列中，这些特性不会随时间变化，但在非静态时间序列中会随时间变化。特别是，具有趋势或季节性的时间序列是非静态的，因为趋势或季节性会影响统计特性。以下示例说明了静态与非静态时间序列的行为
    [1]：
- en: '![Figure 10.12 – Examples of stationary and non-stationary time series](img/B18945_10_012.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 静态和非静态时间序列的示例](img/B18945_10_012.jpg)'
- en: Figure 10.12 – Examples of stationary and non-stationary time series
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 静态和非静态时间序列的示例
- en: 'In order to check the stationary properties, we will check the three following
    conditions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查静态特性，我们将检查以下三个条件：
- en: 'The mean is independent of time:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值与时间无关：
- en: E[X t] = μ for all t
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: E[X t] = μ 对于所有 t
- en: 'The variance is independent of time:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方差与时间无关：
- en: Var[X t] = σ 2 for all t
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Var[X t] = σ 2 对于所有 t
- en: No autocorrelation with time—the correlation between X t 1 and X t 2 only depends
    on how far apart they are on time, t 2 − t 1
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与时间无自相关性——X t 1 和 X t 2 之间的相关性仅取决于它们在时间上的距离，t 2 − t 1
- en: 'We will now explore [the analysis in Pytho](https://www.kaggle.com/datasets/chirag19/air-passengers)n
    using the *Air Passengers* dataset ([https://www.kaggle.com/datasets/chirag19/air-passengers](https://www.kaggle.com/datasets/chirag19/air-passengers))
    providing monthly totals of US airline passengers from 1949 to 1960 that can be
    downloaded from *Kaggle* or can be found in GitHub repository of the book ([https://github.com/PacktPublishing/Building-Statistical-Models-in-Python/blob/main/chapter_10/airline-passengers.csv](https://github.com/PacktPublishing/Building-Statistical-Models-in-Python/blob/main/chapter_10/airline-passengers.csv)).
    First, we import the data to a Python notebook, change the index type to `datetime`,
    and plot the dataset:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用*Air Passengers*数据集([https://www.kaggle.com/datasets/chirag19/air-passengers](https://www.kaggle.com/datasets/chirag19/air-passengers))进行Python分析，该数据集提供了1949年至1960年美国航空公司乘客的月度总计，可以从*Kaggle*下载，也可以在本书的GitHub仓库中找到([https://github.com/PacktPublishing/Building-Statistical-Models-in-Python/blob/main/chapter_10/airline-passengers.csv](https://github.com/PacktPublishing/Building-Statistical-Models-in-Python/blob/main/chapter_10/airline-passengers.csv))。首先，我们将数据导入Python笔记本，将索引类型更改为`datetime`，并绘制数据集：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Figure 10.13 – Visualization of passengers using US airlines 1949-1960](img/B18945_10_013.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 1949-1960年美国航空公司乘客可视化](img/B18945_10_013.jpg)'
- en: Figure 10.13 – Visualization of passengers using US airlines 1949-1960
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 1949-1960年美国航空公司乘客可视化
- en: 'From the plot, we can see there are trends and seasonal effects here. Then,
    it is clearly non-stationary. In the `statsmodels` package, there is a function
    called `seasonal_decompose` to help us break the original data into different
    plots for visualization purposes. You can see it in action here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中，我们可以看到这里存在趋势和季节性效应。然后，它显然是非平稳的。在`statsmodels`包中，有一个名为`seasonal_decompose`的函数，可以帮助我们将原始数据分解成不同的图表进行可视化。您可以在以下操作中看到它：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We get the resulting plot as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果图：
- en: '![Figure 10.14 – Trend and seasonality visualization of passengers using US
    airlines 1949-1960](img/B18945_10_014.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 1949-1960年美国航空公司乘客趋势和季节性可视化](img/B18945_10_014.jpg)'
- en: Figure 10.14 – Trend and seasonality visualization of passengers using US airlines
    1949-1960
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 1949-1960年美国航空公司乘客趋势和季节性可视化
- en: 'The trend plot shows that the number of passengers using US airlines increases
    over time. It appears to oscillate seasonally, with summers being the peak. There
    is a level of dependency between the data points and time, and the variances seem
    to be smaller earlier (fewer passengers using US airlines in the early 1950s)
    and greater later (more passengers using the services in the late 1950s). These
    observations show us that conditions 1 and 2 (constant mean and constant variance
    with time) are violated. Looking at the non-constant variance differently, we
    can create boxplots for each year from 1949 to 1960 for visualization, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势图显示，使用美国航空公司的乘客数量随时间增加。它似乎季节性地波动，夏季达到峰值。数据点和时间之间存在一定的依赖性，方差似乎在早期较小（20世纪50年代初使用美国航空公司的乘客较少）和后期较大（20世纪50年代末使用服务的乘客较多）。这些观察结果表明，条件1和2（均值和方差随时间保持恒定）被违反。从非恒定方差的不同角度来看，我们可以为1949年至1960年的每一年创建箱线图进行可视化，如下所示：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the preceding code, we get the following result:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的代码，我们得到以下结果：
- en: '![Figure 10.15 – Boxplot: passengers using US airlines 1949-1960](img/B18945_10_015.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 1949-1960年美国航空公司乘客箱线图](img/B18945_10_015.jpg)'
- en: 'Figure 10.15 – Boxplot: passengers using US airlines 1949-1960'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 1949-1960年美国航空公司乘客箱线图
- en: 'To check autocorrelation, we use the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查自相关，我们使用以下代码：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We get the result as shown in *Figure 10**.16*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如图*图10.16*所示：
- en: '![Figure 10.16 – ACF visualization of passengers using US airlines 1949-1960](img/B18945_10_016.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 1949-1960年美国航空公司乘客的ACF可视化](img/B18945_10_016.jpg)'
- en: Figure 10.16 – ACF visualization of passengers using US airlines 1949-1960
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 1949-1960年美国航空公司乘客的ACF可视化
- en: 'However, the trend dominates the data. After removing the trend and rerunning
    the code, we get the *Figure 10**.17* ACF plot. There appears to be a strong seasonal
    component. The autocorrelation cycles are similarly repeated after some lag counts
    and spaces over time steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，趋势在数据中占主导地位。在去除趋势并重新运行代码后，我们得到*图10.17*自相关函数（ACF）图。似乎存在一个强烈的季节性成分。自相关周期在经过一些滞后计数和时间步长后重复：
- en: '![Figure 10.17 – ACF visualization of passengers using US airlines 1949-1960](img/B18945_10_017.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – 1949-1960年美国航空公司乘客的ACF可视化](img/B18945_10_017.jpg)'
- en: Figure 10.17 – ACF visualization of passengers using US airlines 1949-1960
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 1949-1960年美国航空公司乘客数量的ACF可视化
- en: The Ljung-Box test that we discussed in the *Variance* and *Autocorrelation*
    sections can also be used to check autocorrelation. Using that test, we get `lb_pvalue
    = 0`. Therefore, the data has autocorrelation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*方差*和*自相关*部分讨论的Ljung-Box检验也可以用来检查自相关。使用该测试，我们得到`lb_pvalue = 0`。因此，数据存在自相关。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started with an introduction to time series. We provided an overview
    of what a time series is and how it can be used to meet specific goals. We also
    discussed the criteria for differentiating time-series data from data that does
    not depend on time. We also discussed stationarity, which factors are important
    for stationarity, how to measure them, and how to resolve cases where stationarity
    does not exist. From there, we were able to understand the primary functions of
    ACF and PACF analysis and for making inferences about processes using variance
    around the mean. Additionally, we provided an introduction to time-series modeling
    with an overview of the white-noise model and the basic concepts behind autoregressive
    and moving average components, which help form the basis of ARIMA and **seasonal
    autoregressive integrated moving average** (**SARIMA**) time-series models.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从时间序列的介绍开始。我们概述了时间序列是什么以及如何用它来满足特定目标。我们还讨论了区分时间序列数据与不依赖于时间的数据的标准。我们还讨论了平稳性，哪些因素对平稳性很重要，如何衡量它们，以及如何解决不存在平稳性的情况。从那里，我们能够理解ACF和PACF分析的主要功能以及如何通过围绕均值的方差对过程进行推断。此外，我们还介绍了时间序列建模，概述了白噪声模型以及自回归和移动平均组件背后的基本概念，这些有助于形成ARIMA和**季节性自回归积分移动平均**（**SARIMA**）时间序列模型的基础。
- en: In [*Chapter 11*](B18945_11.xhtml#_idTextAnchor174)*, ARIMA Models*, we will
    also move deeper into the discussion of autoregressive, moving average, and ARMA
    models with conceptual overviews and step-by-step examples in Python. We also
    work on integrated SARIMA models, as well as methods for the evaluation of fit
    for these models.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B18945_11.xhtml#_idTextAnchor174)*中，ARIMA模型*，我们将进一步深入讨论自回归、移动平均和ARMA模型，包括概念概述和Python中的逐步示例。我们还研究了集成SARIMA模型，以及评估这些模型拟合度的方法。
- en: References
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] André Bauer, *Automated Hybrid Time Series Forecasting: Design, Benchmarking,
    and Use Cases*, University of Chicago, 2021.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] André Bauer，*自动化混合时间序列预测：设计、基准测试和用例*，芝加哥大学，2021年。'
