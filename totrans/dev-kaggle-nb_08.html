<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer195">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 class="chapterTitle" id="_idParaDest-112"><span class="koboSpan" id="kobo.2.1">Analyzing Acoustic Signals to Predict the Next Simulated Earthquake</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In the previous chapters, we explored basic table-formatted data, covering categories like categorical, ordinal, and numerical data, as well as text, geographical coordinates, and imagery. </span><span class="koboSpan" id="kobo.3.2">The current chapter shifts our focus to a different data category, specifically, simulated or experimental signal data. </span><span class="koboSpan" id="kobo.3.3">This data type often appears in a range of formats beyond the standard CSV file format.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">Our primary case study will be data from the </span><em class="italic"><span class="koboSpan" id="kobo.5.1">LANL Earthquake Prediction</span></em><span class="koboSpan" id="kobo.6.1"> Kaggle competition (see </span><em class="italic"><span class="koboSpan" id="kobo.7.1">Reference 1</span></em><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">I contributed to this competition with a widely recognized and frequently forked notebook titled </span><em class="italic"><span class="koboSpan" id="kobo.9.1">LANL Earthquake EDA and Prediction</span></em><span class="koboSpan" id="kobo.10.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Reference</span></em> <em class="italic"><span class="koboSpan" id="kobo.12.1">2</span></em><span class="koboSpan" id="kobo.13.1">), which will serve as the foundational resource for this chapter’s principal notebook. </span><span class="koboSpan" id="kobo.13.2">We’ll then delve into feature engineering, employing a variety of signal analysis techniques vital for developing a predictive model for the competition. </span><span class="koboSpan" id="kobo.13.3">Our goal will be to construct an initial model that predicts the competition’s target variable: the time until failure, which is the remaining time before the next simulated lab earthquake.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.14.1">The research in the domain of earthquake prediction has shown that before earthquakes, the movement of the tectonic plates generates signals in a low-frequency acoustic spectrum. </span><span class="koboSpan" id="kobo.14.2">By studying these signals, researchers try to understand the relationship between the signal’s profile and the moment when the failure (that is, the earthquake) occurs. </span><span class="koboSpan" id="kobo.14.3">In a laboratory, the sliding and shearing of tectonic plates are simulated. </span><span class="koboSpan" id="kobo.14.4">This competition uses the laboratory measurement data, including the acoustic signals, as well as the time when failures occur.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.15.1">To sum up, this chapter will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Data formats used for various signal data</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Exploration of the </span><em class="italic"><span class="koboSpan" id="kobo.18.1">LANL Earthquake Prediction</span></em><span class="koboSpan" id="kobo.19.1"> Kaggle competition data</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Feature engineering</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Training the model for the competition </span><em class="italic"><span class="koboSpan" id="kobo.22.1">LANL Earthquake Prediction</span></em></li>
</ul>
<h1 class="heading-1" id="_idParaDest-113"><span class="koboSpan" id="kobo.23.1">Introducing the LANL Earthquake Prediction competition</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.24.1">The </span><em class="italic"><span class="koboSpan" id="kobo.25.1">LANL Earthquake Prediction</span></em><span class="koboSpan" id="kobo.26.1"> competition centers</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.27.1"> on utilizing seismic signals to determine the precise timing of a laboratory-induced earthquake. </span><span class="koboSpan" id="kobo.27.2">Currently, predicting natural earthquakes remains beyond the reach of our scientific knowledge and technological capabilities. </span><span class="koboSpan" id="kobo.27.3">The ideal scenario for scientists is to predict the timing, location, and magnitude of such an event.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.28.1">Simulated earthquakes, however, created in highly controlled artificial environments, mimic real-world seismic activities. </span><span class="koboSpan" id="kobo.28.2">These simulations enable attempts to forecast lab-generated quakes using the same types of signals observed in natural settings. </span><span class="koboSpan" id="kobo.28.3">In this competition, participants use an acoustic data input signal to estimate the time until the next artificial earthquake occurs, as detailed in </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Reference 3</span></em><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">The challenge is to predict the timing of the earthquake, addressing one of the three critical unknowns in earthquake forecasting: when it will happen, where it will occur, and how powerful it will be.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.31.1">The training data is a single file with two columns: acoustic signal amplitude and time to failure. </span><span class="koboSpan" id="kobo.31.2">The test data consists of multiple files (2,526 in total) with acoustic signal amplitude segments for which we will have to predict the time to failure. </span><span class="koboSpan" id="kobo.31.3">A sample submission file has one column with the segment ID, </span><code class="inlineCode"><span class="koboSpan" id="kobo.32.1">seg_id</span></code><span class="koboSpan" id="kobo.33.1">, and the value to predict: </span><code class="inlineCode"><span class="koboSpan" id="kobo.34.1">time_to_failure</span></code><span class="koboSpan" id="kobo.35.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.36.1">The competitors are tasked with training their models with the acoustic signal and time-to-failure data in the training file and predicting the time-to-failure for each segment from each file in the test folder. </span><span class="koboSpan" id="kobo.36.2">This competition</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.37.1"> data is in a very convenient format, that is, </span><strong class="keyWord"><span class="koboSpan" id="kobo.38.1">comma-separated values</span></strong><span class="koboSpan" id="kobo.39.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.40.1">CSV</span></strong><span class="koboSpan" id="kobo.41.1">) format, but this is not a requirement. </span><span class="koboSpan" id="kobo.41.2">Other competitions or datasets on Kaggle with signal data use different, less common formats. </span><span class="koboSpan" id="kobo.41.3">Because this chapter</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.42.1"> is about analyzing signal data, this is the right place to review this format. </span><span class="koboSpan" id="kobo.42.2">Let’s first look into some of these formats.</span></p>
<h1 class="heading-1" id="_idParaDest-114"><span class="koboSpan" id="kobo.43.1">Formats for signal data</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.44.1">Several competitions on Kaggle </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.45.1">used sound data as an addition to regular tabular features. </span><span class="koboSpan" id="kobo.45.2">There were three competitions organized by Cornell Lab of Ornithology’s BirdCLEF (LifeCLEF Bird Recognition Challenge) in 2021, 2022, and 2023 for predicting a bird species from samples of bird songs (see </span><em class="italic"><span class="koboSpan" id="kobo.46.1">Reference 4</span></em><span class="koboSpan" id="kobo.47.1"> for an example of one of these competitions). </span><span class="koboSpan" id="kobo.47.2">The format used in these competitions was </span><code class="inlineCode"><span class="koboSpan" id="kobo.48.1">.ogg</span></code><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">.ogg</span></code><span class="koboSpan" id="kobo.51.1"> format is used to store audio data with less bandwidth. </span><span class="koboSpan" id="kobo.51.2">It is considered technically superior to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.52.1">.mp3</span></code><span class="koboSpan" id="kobo.53.1"> format.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.54.1">We can read these types of file formats using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">librosa</span></code><span class="koboSpan" id="kobo.56.1"> library (see </span><em class="italic"><span class="koboSpan" id="kobo.57.1">Reference 5</span></em><span class="koboSpan" id="kobo.58.1">). </span><span class="koboSpan" id="kobo.58.2">The following code can be used to load an </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">.ogg</span></code><span class="koboSpan" id="kobo.60.1"> file and display the sound wave:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.61.1">import</span></span><span class="koboSpan" id="kobo.62.1"> matplotlib.pyplot </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.63.1">as</span></span><span class="koboSpan" id="kobo.64.1"> plt
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.65.1">import</span></span><span class="koboSpan" id="kobo.66.1"> librosa
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.67.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.68.1">display_sound_wave</span></span><span class="koboSpan" id="kobo.69.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.70.1">sound_path=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.71.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.72.1">,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.73.1">               text=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.74.1">"Test"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.75.1">, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.76.1">               color=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.77.1">"green"</span></span><span class="koboSpan" id="kobo.78.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.79.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.80.1">    Display a sound wave</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.81.1">    Args</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.82.1">        sound_path: path to the sound file</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.83.1">        text: text to display</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.84.1">        color: color for text to display</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.85.1">    Returns</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.86.1">        None</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.87.1">    """</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.88.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.89.1">not</span></span><span class="koboSpan" id="kobo.90.1"> sound_path:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.91.1">return</span></span><span class="koboSpan" id="kobo.92.1">    
    y_sound, sr_sound = librosa.load(sound_path)
    audio_sound, _ = librosa.effects.trim(y_sound)
    fig, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.93.1">1</span></span><span class="koboSpan" id="kobo.94.1">, figsize = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.95.1">16</span></span><span class="koboSpan" id="kobo.96.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.97.1">3</span></span><span class="koboSpan" id="kobo.98.1">))
    fig.suptitle(</span><span class="hljs-string"><span class="koboSpan" id="kobo.99.1">f'Sound Wave: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.100.1">{text}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.101.1">'</span></span><span class="koboSpan" id="kobo.102.1">, fontsize=</span><span class="hljs-number"><span class="koboSpan" id="kobo.103.1">12</span></span><span class="koboSpan" id="kobo.104.1">)
    librosa.display.waveshow(y = audio_sound, sr = sr_sound, color = color)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.105.1">The library </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">librosa</span></code><span class="koboSpan" id="kobo.107.1">, when loading the audio sound, will return values as a time series with floating-point values (see </span><em class="italic"><span class="koboSpan" id="kobo.108.1">Reference 6</span></em><span class="koboSpan" id="kobo.109.1">). </span><span class="koboSpan" id="kobo.109.2">It isn’t just the </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">.ogg</span></code><span class="koboSpan" id="kobo.111.1"> format that is supported; it will work with any code supported by soundfile or Audioread. </span><span class="koboSpan" id="kobo.111.2">The default sampling rate is 22050 but this can be also set upon load, using the parameter </span><em class="italic"><span class="koboSpan" id="kobo.112.1">sr</span></em><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">Other parameters that can be used when loading an audio wave are the offset and the duration (both given in seconds – together, they allow you to select the time interval of the sound wave you will load).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.114.1">In an earlier version of the BirdCLEF</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.115.1"> competition, </span><em class="italic"><span class="koboSpan" id="kobo.116.1">Cornell Birdcall Identification</span></em><span class="koboSpan" id="kobo.117.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.118.1">Reference 7</span></em><span class="koboSpan" id="kobo.119.1">), audio sounds in the dataset</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.120.1"> were given in </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">.mp3</span></code><span class="koboSpan" id="kobo.122.1"> format. </span><span class="koboSpan" id="kobo.122.2">For this format, we can use librosa to load, transform, or visualize the sound waves. </span><strong class="keyWord"><span class="koboSpan" id="kobo.123.1">Waveform Audio File</span></strong><span class="koboSpan" id="kobo.124.1"> format (or </span><strong class="keyWord"><span class="koboSpan" id="kobo.125.1">WAV</span></strong><span class="koboSpan" id="kobo.126.1">), another frequently used format, can also be loaded using librosa.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.127.1">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">.wav</span></code><span class="koboSpan" id="kobo.129.1"> format, we can alternatively use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.130.1">scipy.io</span></code><span class="koboSpan" id="kobo.131.1"> module </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">wavfile</span></code><span class="koboSpan" id="kobo.133.1"> to load data. </span><span class="koboSpan" id="kobo.133.2">The following code will load and display a file in </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">.wav</span></code><span class="koboSpan" id="kobo.135.1"> format. </span><span class="koboSpan" id="kobo.135.2">In this case, the amplitude is not scaled down to a -1:1 interval (the maximum value is 32K): </span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">import</span></span><span class="koboSpan" id="kobo.137.1"> matplotlib.pyplot </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.138.1">as</span></span><span class="koboSpan" id="kobo.139.1"> plt
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.140.1">from</span></span><span class="koboSpan" id="kobo.141.1"> scipy.io </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.142.1">import</span></span><span class="koboSpan" id="kobo.143.1"> wavfile
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.144.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.145.1">display_wavefile</span></span><span class="koboSpan" id="kobo.146.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.147.1">sound_path=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.148.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.149.1">,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.150.1">               text=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.151.1">"Test"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.152.1">, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.153.1">               color=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.154.1">"green"</span></span><span class="koboSpan" id="kobo.155.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.156.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.157.1">    Display a sound wave - load using wavefile</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.158.1">    sr: sample rate</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.159.1">    y_sound: sound samples</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.160.1">    Args</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.161.1">        sound_path: path to the sound file</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.162.1">        text: text to display</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.163.1">        color: color for text to display</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.164.1">    Returns</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.165.1">        None</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.166.1">    """</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.167.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.168.1">not</span></span><span class="koboSpan" id="kobo.169.1"> sound_path:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.170.1">return</span></span><span class="koboSpan" id="kobo.171.1">    
    sr_sound, y_sound = wavfile.load(sound_path)
    fig, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.172.1">1</span></span><span class="koboSpan" id="kobo.173.1">, figsize = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.174.1">16</span></span><span class="koboSpan" id="kobo.175.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.176.1">3</span></span><span class="koboSpan" id="kobo.177.1">))
    fig.suptitle(</span><span class="hljs-string"><span class="koboSpan" id="kobo.178.1">f'Sound Wave: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.179.1">{text}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.180.1">'</span></span><span class="koboSpan" id="kobo.181.1">, fontsize=</span><span class="hljs-number"><span class="koboSpan" id="kobo.182.1">12</span></span><span class="koboSpan" id="kobo.183.1">)
    ax.plot(np.linspace(</span><span class="hljs-number"><span class="koboSpan" id="kobo.184.1">0</span></span><span class="koboSpan" id="kobo.185.1">, sr_sound/</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.186.1">len</span></span><span class="koboSpan" id="kobo.187.1">(y_sound), sr_sound), y_sound)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.188.1">Signal, not specifically audio signal, data can also be stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">.npy</span></code><span class="koboSpan" id="kobo.190.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">.npz</span></code><span class="koboSpan" id="kobo.192.1"> format, which are both </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">numpy</span></code><span class="koboSpan" id="kobo.194.1"> formats to store array data. </span><span class="koboSpan" id="kobo.194.2">These formats can be loaded using </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">numpy</span></code><span class="koboSpan" id="kobo.196.1"> functions, as you can see in the following code snippets. </span><span class="koboSpan" id="kobo.196.2">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">npy</span></code><span class="koboSpan" id="kobo.198.1"> format, this will load a multi-column array:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.199.1">import</span></span><span class="koboSpan" id="kobo.200.1"> numpy </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.201.1">as</span></span><span class="koboSpan" id="kobo.202.1"> np
f = np.load(</span><span class="hljs-string"><span class="koboSpan" id="kobo.203.1">'data_path/file.npy'</span></span><span class="koboSpan" id="kobo.204.1">, allow_pickle=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.205.1">True</span></span><span class="koboSpan" id="kobo.206.1">)
columns_, data_  = f
data_df = pd.DataFrame(data_, columns = columns_)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.207.1">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.208.1">.npz</span></code><span class="koboSpan" id="kobo.209.1"> format, the following code will load a similar structure, previously compressed (one file only):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.210.1">import</span></span><span class="koboSpan" id="kobo.211.1"> numpy </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.212.1">as</span></span><span class="koboSpan" id="kobo.213.1"> np
f = np.load(</span><span class="hljs-string"><span class="koboSpan" id="kobo.214.1">'data_path/file.npz'</span></span><span class="koboSpan" id="kobo.215.1">, allow_pickle=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.216.1">True</span></span><span class="koboSpan" id="kobo.217.1">)
columns_, data_ = f[</span><span class="hljs-string"><span class="koboSpan" id="kobo.218.1">'arr_0'</span></span><span class="koboSpan" id="kobo.219.1">]
data_df = pd.DataFrame(data_, columns = columns_)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.220.1">For data stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.221.1">.rds</span></code><span class="koboSpan" id="kobo.222.1"> format, an R-specific format for saving data, we can load the data using the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.223.1">!pip install pyreadr
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.224.1">import</span></span><span class="koboSpan" id="kobo.225.1"> pyreadr
f = pyreadr.read_r(</span><span class="hljs-string"><span class="koboSpan" id="kobo.226.1">'data_path/file.rds'</span></span><span class="koboSpan" id="kobo.227.1">)
data_df = f[</span><span class="hljs-literal"><span class="koboSpan" id="kobo.228.1">None</span></span><span class="koboSpan" id="kobo.229.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.230.1">To store multi-dimensional array data, </span><strong class="keyWord"><span class="koboSpan" id="kobo.231.1">NetCDF-4</span></strong><span class="koboSpan" id="kobo.232.1"> format (</span><strong class="keyWord"><span class="koboSpan" id="kobo.233.1">Network Common Data Form, version 4</span></strong><span class="koboSpan" id="kobo.234.1">) is used. </span><span class="koboSpan" id="kobo.234.2">In </span><em class="italic"><span class="koboSpan" id="kobo.235.1">Reference 8</span></em><span class="koboSpan" id="kobo.236.1">, we have an example</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.237.1"> of such multi-dimensional signal data, from Earthdata NASA satellite measurements, from the dataset </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">EarthData MERRA2 CO</span></code><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">The following code snippet reads a subset of measurements </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.240.1">for CO, focusing on the COCL dimension (Column Burden kg m-2), and includes values for latitude, longitude, and time:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.241.1">from</span></span><span class="koboSpan" id="kobo.242.1"> netCDF4 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.243.1">import</span></span><span class="koboSpan" id="kobo.244.1"> Dataset
data = Dataset(file_path, more=</span><span class="hljs-string"><span class="koboSpan" id="kobo.245.1">"r"</span></span><span class="koboSpan" id="kobo.246.1">)
lons = data.variables[</span><span class="hljs-string"><span class="koboSpan" id="kobo.247.1">'lon'</span></span><span class="koboSpan" id="kobo.248.1">][:]
lats = data.variables[</span><span class="hljs-string"><span class="koboSpan" id="kobo.249.1">'lat'</span></span><span class="koboSpan" id="kobo.250.1">][:]
time = data.variables[</span><span class="hljs-string"><span class="koboSpan" id="kobo.251.1">'time'</span></span><span class="koboSpan" id="kobo.252.1">][:]
COCL = data.variables[</span><span class="hljs-string"><span class="koboSpan" id="kobo.253.1">'COCL'</span></span><span class="koboSpan" id="kobo.254.1">][:,:,:]; COCL = COCL[</span><span class="hljs-number"><span class="koboSpan" id="kobo.255.1">0</span></span><span class="koboSpan" id="kobo.256.1">,:,:]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.257.1">For more details, you </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.258.1">can consult </span><em class="italic"><span class="koboSpan" id="kobo.259.1">Reference 9</span></em><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">For now, let’s get back to our competition data, which is in CSV format, although it represents an audio signal (sound waves), as we already clarified.</span></p>
<h1 class="heading-1" id="_idParaDest-115"><span class="koboSpan" id="kobo.261.1">Exploring our competition data</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.262.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">LANL Earthquake Prediction</span></code><span class="koboSpan" id="kobo.264.1"> dataset</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.265.1"> consists of the following data:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.266.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">train.csv</span></code><span class="koboSpan" id="kobo.268.1"> file, with two columns only:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">acoustic_data</span></code><span class="koboSpan" id="kobo.270.1">: This is the amplitude of the acoustic signal.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">time_to_failure</span></code><span class="koboSpan" id="kobo.272.1">: This is the time to failure corresponding to the current data segment.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.273.1">A test folder with 2,624 files with small segments of acoustic data.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.274.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">sample_submission.csv</span></code><span class="koboSpan" id="kobo.276.1"> file; for each test file, those competing will need to give an estimate for time to failure.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.277.1">The training data (9.56 GB) contains 692 million rows. </span><span class="koboSpan" id="kobo.277.2">The actual time constant for the samples in the training data results from the continuous variation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">time_to_failure</span></code><span class="koboSpan" id="kobo.279.1"> values. </span><span class="koboSpan" id="kobo.279.2">The acoustic data is integer values, from -5,515 to 5,444, with an average of 4.52 and a standard deviation of 10.7 (values oscillating around 0). </span><span class="koboSpan" id="kobo.279.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">time_to_failure</span></code><span class="koboSpan" id="kobo.281.1"> values are real numbers, ranging from 0 to 16, with a mean of 5.68 and a standard deviation of 3.67. </span><span class="koboSpan" id="kobo.281.2">To reduce the memory footprint for the training data, we read the data with a reduced dimension for both acoustic data and </span><code class="inlineCode"><span class="koboSpan" id="kobo.282.1">time_to_failure</span></code><span class="koboSpan" id="kobo.283.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.284.1">%%time
train_df = pd.read_csv(os.path.join(PATH,'train.csv'), dtype={'acoustic_data': np.int16, 'time_to_failure': np.float32})
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.285.1">Let’s check the first values in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.286.1">training</span></code><span class="koboSpan" id="kobo.287.1"> data. </span><span class="koboSpan" id="kobo.287.2">We will not use all the </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">time_to_failure</span></code><span class="koboSpan" id="kobo.289.1"> data (only values associated with the end-of-time interval for which we will aggregate interval acoustic data); therefore, rounding in order to reduce the size of the time to failure from double to float is not important here:</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.290.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B20963_08_01.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.291.1">Figure 8.1. </span><span class="koboSpan" id="kobo.291.2">First rows of data in the training data</span></p>
<p class="normal"><span class="koboSpan" id="kobo.292.1">Let’s visualize, on the same graph, the acoustic signal values</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.293.1"> and the time to failure. </span><span class="koboSpan" id="kobo.293.2">We will use a subsampling rate of 1/100 (sample each 100</span><sup class="superscript"><span class="koboSpan" id="kobo.294.1">th</span></sup><span class="koboSpan" id="kobo.295.1"> row) to represent the full training data (see </span><em class="italic"><span class="koboSpan" id="kobo.296.1">Figure 8.2</span></em><span class="koboSpan" id="kobo.297.1">). </span><span class="koboSpan" id="kobo.297.2">We will use the following code to represent these graphs:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.298.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.299.1">plot_acc_ttf_data</span></span><span class="koboSpan" id="kobo.300.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.301.1">idx, train_ad_sample_df, train_ttf_sample_df, title=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.302.1">"Acoustic data and time to failure: 1% sampled data"</span></span><span class="koboSpan" id="kobo.303.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.304.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.305.1">    Plot acoustic data and time to failure</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.306.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.307.1">        train_ad_sample_df: train acoustic data sample</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.308.1">        train_ttf_sample_df: train time to failure data sample</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.309.1">        title: title of the plot</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.310.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.311.1">        None</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.312.1">    """</span></span><span class="koboSpan" id="kobo.313.1">
    fig, ax1 = plt.subplots(figsize=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.314.1">12</span></span><span class="koboSpan" id="kobo.315.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.316.1">8</span></span><span class="koboSpan" id="kobo.317.1">))
    plt.title(title)
    plt.plot(idx, train_ad_sample_df, color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.318.1">'r'</span></span><span class="koboSpan" id="kobo.319.1">)
    ax1.set_ylabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.320.1">'acoustic data'</span></span><span class="koboSpan" id="kobo.321.1">, color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.322.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.323.1">r'</span></span><span class="koboSpan" id="kobo.324.1">)
    plt.legend([</span><span class="hljs-string"><span class="koboSpan" id="kobo.325.1">'acoustic data'</span></span><span class="koboSpan" id="kobo.326.1">], loc=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.327.1">0.01</span></span><span class="koboSpan" id="kobo.328.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.329.1">0.95</span></span><span class="koboSpan" id="kobo.330.1">))
    ax2 = ax1.twinx()
    plt.plot(idx, train_ttf_sample_df, color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.331.1">'b'</span></span><span class="koboSpan" id="kobo.332.1">)
    ax2.set_ylabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.333.1">'time to failure'</span></span><span class="koboSpan" id="kobo.334.1">, color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.335.1">'b'</span></span><span class="koboSpan" id="kobo.336.1">)
    plt.legend([</span><span class="hljs-string"><span class="koboSpan" id="kobo.337.1">'time to failure'</span></span><span class="koboSpan" id="kobo.338.1">], loc=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.339.1">0.01</span></span><span class="koboSpan" id="kobo.340.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.341.1">0.9</span></span><span class="koboSpan" id="kobo.342.1">))
    plt.grid(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.343.1">True</span></span><span class="koboSpan" id="kobo.344.1">)
</span></code></pre>
<figure class="mediaobject"><span class="koboSpan" id="kobo.345.1"><img alt="A graph with red and blue lines  Description automatically generated" src="../Images/B20963_08_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.346.1">Figure 8.2. </span><span class="koboSpan" id="kobo.346.2">Acoustic signal data and time to failure data over an entire training set, subsampled at 1/100</span></p>
<p class="normal"><span class="koboSpan" id="kobo.347.1">Let’s zoom into the first part of the time</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.348.1"> interval. </span><span class="koboSpan" id="kobo.348.2">We will show the first 1% of the data (no subsampling). </span><span class="koboSpan" id="kobo.348.3">In </span><em class="italic"><span class="koboSpan" id="kobo.349.1">Figure 8.3</span></em><span class="koboSpan" id="kobo.350.1">, we are showing, on the same graph, the acoustic signal and time to failure for the first 6.29 million rows of data. </span><span class="koboSpan" id="kobo.350.2">We can observe that before the failure (but not very close in time), there is a large oscillation, with both negative and positive peaks. </span><span class="koboSpan" id="kobo.350.3">This oscillation is also preceded by a few smaller ones, at irregular time intervals.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.351.1"><img alt="A graph with red lines and blue lines  Description automatically generated" src="../Images/B20963_08_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.352.1">Figure 8.3: Acoustic signal data and time to failure data for the first 1% of the data</span></p>
<p class="normal"><span class="koboSpan" id="kobo.353.1">Let’s also look at the next 1% of the training</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.354.1"> data (without subsampling). </span><span class="koboSpan" id="kobo.354.2">In </span><em class="italic"><span class="koboSpan" id="kobo.355.1">Figure 8.4</span></em><span class="koboSpan" id="kobo.356.1">, we show this time series for acoustic signal values and time to failure. </span><span class="koboSpan" id="kobo.356.2">There is no failure during this time interval. </span><span class="koboSpan" id="kobo.356.3">We observe many irregular small oscillations, with both negative and positive peaks.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.357.1"><img alt="A graph with red lines  Description automatically generated" src="../Images/B20963_08_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.358.1">Figure 8.4: Acoustic signal data and time to failure for the second 1% of the data in the training set</span></p>
<p class="normal"><span class="koboSpan" id="kobo.359.1">Let’s also look at the last few percentages of the data (last 5% of time) in the training set. </span><span class="koboSpan" id="kobo.359.2">In </span><em class="italic"><span class="koboSpan" id="kobo.360.1">Figure 8.5</span></em><span class="koboSpan" id="kobo.361.1">, we observe the same pattern of several larger oscillations superposed on smaller irregular oscillations, and with a major oscillation just before the failure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.362.1"><img alt="A graph with red and blue lines  Description automatically generated" src="../Images/B20963_08_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.363.1">Figure 8.5: Acoustic signal data and time to failure for the last 5% of the data in the training set</span></p>
<p class="normal"><span class="koboSpan" id="kobo.364.1">Let’s now also look at a few examples</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.365.1"> of variations of the acoustic signal in the test data samples. </span><span class="koboSpan" id="kobo.365.2">There are 2,624 data segment files in the test data. </span><span class="koboSpan" id="kobo.365.3">We will select a few of them to visualize. </span><span class="koboSpan" id="kobo.365.4">We will use a modified visualization function since in the test data, we only have the acoustic signals:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.366.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.367.1">plot_acc_data</span></span><span class="koboSpan" id="kobo.368.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.369.1">test_sample_df, segment_name</span></span><span class="koboSpan" id="kobo.370.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.371.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.372.1">    Plot acoustic data for a train segment</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.373.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.374.1">        test_sample_df: test acoustic data sample</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.375.1">        segment_name: title of the plot</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.376.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.377.1">        None</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.378.1">    """</span></span><span class="koboSpan" id="kobo.379.1">
    fig, ax1 = plt.subplots(figsize=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.380.1">12</span></span><span class="koboSpan" id="kobo.381.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.382.1">8</span></span><span class="koboSpan" id="kobo.383.1">))
    plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.384.1">f"Test segment: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.385.1">{segment_name}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.386.1">"</span></span><span class="koboSpan" id="kobo.387.1">)
    plt.plot(test_sample_df, color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.388.1">'r'</span></span><span class="koboSpan" id="kobo.389.1">)
    ax1.set_ylabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.390.1">'acoustic data'</span></span><span class="koboSpan" id="kobo.391.1">, color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.392.1">'r'</span></span><span class="koboSpan" id="kobo.393.1">)
    plt.legend([</span><span class="hljs-string"><span class="koboSpan" id="kobo.394.1">f"acoustic data: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.395.1">{segment_name}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.396.1">"</span></span><span class="koboSpan" id="kobo.397.1">], loc=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.398.1">0.01</span></span><span class="koboSpan" id="kobo.399.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.400.1">0.95</span></span><span class="koboSpan" id="kobo.401.1">))
    plt.grid(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.402.1">True</span></span><span class="koboSpan" id="kobo.403.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.404.1">In </span><em class="italic"><span class="koboSpan" id="kobo.405.1">Figure 8.6</span></em><span class="koboSpan" id="kobo.406.1">, we are showing the acoustic signal graph</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.407.1"> for the segment </span><strong class="screenText"><span class="koboSpan" id="kobo.408.1">seg_00030f</span></strong><span class="koboSpan" id="kobo.409.1">:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.410.1"><img alt="A graph showing a red line  Description automatically generated" src="../Images/B20963_08_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.411.1">Figure 8.6: Acoustic signal data for test segment seg_00030f</span></p>
<p class="normal"><span class="koboSpan" id="kobo.412.1">In the next figure, we are showing the acoustic signal graph for segment </span><strong class="screenText"><span class="koboSpan" id="kobo.413.1">seg_0012b5</span></strong><span class="koboSpan" id="kobo.414.1">:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.415.1"><img alt="A graph showing a red line  Description automatically generated" src="../Images/B20963_08_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.416.1">Figure 8.7: Acoustic signal data for test segment seg_0012b5</span></p>
<p class="normal"><span class="koboSpan" id="kobo.417.1">In the notebooks associated with this chapter, you can see more examples of such test acoustic signals. </span><span class="koboSpan" id="kobo.417.2">The test segments show quite a large variety of signal profiles, depicting the same sequence of small oscillations</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.418.1"> with intercalated peaks with variable amplitude, similar to what we can see in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.419.1">training</span></code><span class="koboSpan" id="kobo.420.1"> data subsampled earlier.</span></p>
<h2 class="heading-2" id="_idParaDest-116"><span class="koboSpan" id="kobo.421.1">Solution approach</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.422.1">The task in the competition</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.423.1"> is to accurately forecast a singular </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">time_to_failure</span></code><span class="koboSpan" id="kobo.425.1"> value for each segment in the test dataset. </span><span class="koboSpan" id="kobo.425.2">Each segment of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">test</span></code><span class="koboSpan" id="kobo.427.1"> set comprises 150,000 data rows. </span><span class="koboSpan" id="kobo.427.2">In contrast, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">training</span></code><span class="koboSpan" id="kobo.429.1"> dataset is vast, encompassing 692 million rows, with one column dedicated to our target variable: the time until failure. </span><span class="koboSpan" id="kobo.429.2">We plan to divide the training data into uniform segments, each containing 150,000 rows, and use the final time-to-failure value from each segment as the target variable for that segment. </span><span class="koboSpan" id="kobo.429.3">This approach is designed to align the training data with the format of the test data, facilitating more effective model training.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.430.1">Additionally, we will engineer new features by aggregating values across both the training and test datasets, resulting in a single row that encapsulates multiple features for each data segment. </span><span class="koboSpan" id="kobo.430.2">The subsequent</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.431.1"> section will delve into the signal processing techniques employed for feature generation.</span></p>
<h1 class="heading-1" id="_idParaDest-117"><span class="koboSpan" id="kobo.432.1">Feature engineering</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.433.1">We will use several libraries</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.434.1"> specific to signal processing to generate most of the features. </span><span class="koboSpan" id="kobo.434.2">From SciPy (Python scientific library), we are using a few functions from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">signal</span></code><span class="koboSpan" id="kobo.436.1"> module. </span><span class="koboSpan" id="kobo.436.2">The Hann function returns a Hann window, which modifies the signal to smooth the values at the end of the sampled signal to 0 (uses a cosine “bell” function). </span><span class="koboSpan" id="kobo.436.3">The Hilbert function computes the analytic signal, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">Hilbert</span></code><span class="koboSpan" id="kobo.438.1"> transform. </span><span class="koboSpan" id="kobo.438.2">The Hilbert transform is a mathematical technique used in signal processing, with a property that shifts the phase of the original signal by 90 degrees.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.439.1">Other library functions used are from </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">numpy</span></code><span class="koboSpan" id="kobo.441.1">: Fast Fourier Transform (FFT), </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">mean</span></code><span class="koboSpan" id="kobo.443.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.444.1">min</span></code><span class="koboSpan" id="kobo.445.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.446.1">max</span></code><span class="koboSpan" id="kobo.447.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.448.1">std</span></code><span class="koboSpan" id="kobo.449.1"> (standard deviation), </span><code class="inlineCode"><span class="koboSpan" id="kobo.450.1">abs</span></code><span class="koboSpan" id="kobo.451.1"> (absolute value), </span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">diff</span></code><span class="koboSpan" id="kobo.453.1"> (the difference between two successive values in the signal), and </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">quantile</span></code><span class="koboSpan" id="kobo.455.1"> (where a sample is divided into equal-sized, adjacent groups). </span><span class="koboSpan" id="kobo.455.2">We are also using a few statistical functions that are available from </span><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">pandas</span></code><span class="koboSpan" id="kobo.457.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">mad</span></code><span class="koboSpan" id="kobo.459.1"> (median absolute deviation), </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">kurtosis</span></code><span class="koboSpan" id="kobo.461.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">skew</span></code><span class="koboSpan" id="kobo.463.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">median</span></code><span class="koboSpan" id="kobo.465.1">. </span><span class="koboSpan" id="kobo.465.2">We are implementing functions to calculate trend features and classic STA/LTA. </span><span class="koboSpan" id="kobo.465.3">Classic STA/LTA represents the ratio between the amplitude of the signal of a short time window of length STA and a long time window, LTA. </span><span class="koboSpan" id="kobo.465.4">Let’s dive in!</span></p>
<h2 class="heading-2" id="_idParaDest-118"><span class="koboSpan" id="kobo.466.1">Trend feature and classic STA/LTA</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.467.1">We start by defining two functions, for the calculation</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.468.1"> of a trend feature and classic </span><strong class="keyWord"><span class="koboSpan" id="kobo.469.1">Short-Term Average</span></strong><span class="koboSpan" id="kobo.470.1">/</span><strong class="keyWord"><span class="koboSpan" id="kobo.471.1">Long-Term Average</span></strong><span class="koboSpan" id="kobo.472.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.473.1">STA</span></strong><span class="koboSpan" id="kobo.474.1">/</span><strong class="keyWord"><span class="koboSpan" id="kobo.475.1">LTA</span></strong><span class="koboSpan" id="kobo.476.1">). </span><span class="koboSpan" id="kobo.476.2">STA/LTA is a seismic signal analysis technique used in seismology. </span><span class="koboSpan" id="kobo.476.3">It measures</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.477.1"> the ratio of short-term to long-term signal averages. </span><span class="koboSpan" id="kobo.477.2">It is useful</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.478.1"> in earthquake detection as it identifies distinct</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.479.1"> patterns in seismic data. </span><span class="koboSpan" id="kobo.479.2">Therefore, it will also be a useful feature to include in our model.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.480.1">We show here the code to calculate the trend feature. </span><span class="koboSpan" id="kobo.480.2">This is calculated using a linear regression model (for 1D data) and retrieves the slope of the resulting regression line. </span><span class="koboSpan" id="kobo.480.3">We use the option to transform all the sampled data into positive values before performing regression (that is, calculating the slope/trend for the absolute values of the data). </span><span class="koboSpan" id="kobo.480.4">The trend data contains important information about the overall signal:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.481.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.482.1">add_trend_feature</span></span><span class="koboSpan" id="kobo.483.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.484.1">arr, abs_values=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.485.1">False</span></span><span class="koboSpan" id="kobo.486.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.487.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.488.1">    Calculate trend features</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.489.1">    Uses a linear regression algorithm to extract the trend</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.490.1">    from the list of values in the array (arr)</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.491.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.492.1">        arr: array of values</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.493.1">        abs_values: flag if to use abs values, default is False</span></span>
<span class="hljs-string"> </span>
<span class="hljs-string"><span class="koboSpan" id="kobo.494.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.495.1">        trend feature</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.496.1">    """</span></span><span class="koboSpan" id="kobo.497.1">
    idx = np.array(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.498.1">range</span></span><span class="koboSpan" id="kobo.499.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.500.1">len</span></span><span class="koboSpan" id="kobo.501.1">(arr)))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.502.1">if</span></span><span class="koboSpan" id="kobo.503.1"> abs_values:
        arr = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.504.1">abs</span></span><span class="koboSpan" id="kobo.505.1">(arr)
    lr = LinearRegression()
    lr.fit(idx.reshape(-</span><span class="hljs-number"><span class="koboSpan" id="kobo.506.1">1</span></span><span class="koboSpan" id="kobo.507.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.508.1">1</span></span><span class="koboSpan" id="kobo.509.1">), arr)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.510.1">return</span></span><span class="koboSpan" id="kobo.511.1"> lr.coef_[</span><span class="hljs-number"><span class="koboSpan" id="kobo.512.1">0</span></span><span class="koboSpan" id="kobo.513.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.514.1">Next, we calculate the classic STA/LTA, which represents</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.515.1"> the ratio between the amplitude</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.516.1"> of the signal of a short</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.517.1"> time window of length </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">STA</span></code><span class="koboSpan" id="kobo.519.1"> and a long time</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.520.1"> window, </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">LTA</span></code><span class="koboSpan" id="kobo.522.1">. </span><span class="koboSpan" id="kobo.522.2">The function receives as parameters the signal and the length for the short-time average and long-time average windows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.523.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.524.1">classic_sta_lta</span></span><span class="koboSpan" id="kobo.525.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.526.1">x, length_sta, length_lta</span></span><span class="koboSpan" id="kobo.527.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.528.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.529.1">    Calculate classic STA/LTA</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.530.1">    STA/LTA represents the ratio between amplitude of the</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.531.1">    signal on a short time window of length LTA and on a</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.532.1">    long time window LTA</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.533.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.534.1">        length_sta: length of short time average window</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.535.1">        length_lta: length of long time average window</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.536.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.537.1">        STA/LTA</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.538.1">    """</span></span><span class="koboSpan" id="kobo.539.1">
    sta = np.cumsum(x ** </span><span class="hljs-number"><span class="koboSpan" id="kobo.540.1">2</span></span><span class="koboSpan" id="kobo.541.1">)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.542.1"># Convert to float</span></span><span class="koboSpan" id="kobo.543.1">
    sta = np.require(sta, dtype=np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.544.1">float</span></span><span class="koboSpan" id="kobo.545.1">)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.546.1"># Copy for LTA</span></span><span class="koboSpan" id="kobo.547.1">
    lta = sta.copy()
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.548.1"># Compute the STA and the LTA</span></span><span class="koboSpan" id="kobo.549.1">
    sta[length_sta:] = sta[length_sta:] - sta[:-length_sta]
    sta /= length_sta
    lta[length_lta:] = lta[length_lta:] - lta[:-length_lta]
    lta /= length_lta
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.550.1"># Pad zeros</span></span><span class="koboSpan" id="kobo.551.1">
    sta[:length_lta - </span><span class="hljs-number"><span class="koboSpan" id="kobo.552.1">1</span></span><span class="koboSpan" id="kobo.553.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.554.1">0</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.555.1"># Avoid division by zero by setting zero values to tiny float</span></span><span class="koboSpan" id="kobo.556.1">
    dtiny = np.finfo(</span><span class="hljs-number"><span class="koboSpan" id="kobo.557.1">0.0</span></span><span class="koboSpan" id="kobo.558.1">).tiny
    idx = lta &lt; dtiny
    lta[idx] = dtiny
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.559.1">return</span></span><span class="koboSpan" id="kobo.560.1"> sta / lta
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.561.1">Next, we implement the function to calculate features, which receives as parameters the sample index, the data subsample, and a handle to the transformed training data. </span><span class="koboSpan" id="kobo.561.2">This function will use various signal processing algorithms to build aggregated features from the time variation acoustic signal per segment. </span><span class="koboSpan" id="kobo.561.3">In the case of the training data, we use windows of 150K rows</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.562.1"> from the training set (without stride). </span><span class="koboSpan" id="kobo.562.2">In the case of the test set, each test file represents</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.563.1"> a segment of 150K. </span><span class="koboSpan" id="kobo.563.2">In the following subsections, we will review</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.564.1"> the engineered features that will be included</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.565.1"> in the model.</span></p>
<h2 class="heading-2" id="_idParaDest-119"><span class="koboSpan" id="kobo.566.1">FFT-derived features</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.567.1">One of the features of the model is the </span><strong class="keyWord"><span class="koboSpan" id="kobo.568.1">Fast Fourier Transform</span></strong><span class="koboSpan" id="kobo.569.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.570.1">FFT</span></strong><span class="koboSpan" id="kobo.571.1">) applied to the entire segment; this is not directly</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.572.1"> used as a feature but as a basis for the calculation of multiple aggregation functions (see next subsection). </span><span class="koboSpan" id="kobo.572.2">The FFT is calculated using a fast implementation of the discrete Fourier transform.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.573.1">We are using </span><code class="inlineCode"><span class="koboSpan" id="kobo.574.1">numpy</span></code><span class="koboSpan" id="kobo.575.1"> implementations for </span><strong class="keyWord"><span class="koboSpan" id="kobo.576.1">FFT</span></strong><span class="koboSpan" id="kobo.577.1"> for one-dimensional</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.578.1"> arrays (</span><code class="inlineCode"><span class="koboSpan" id="kobo.579.1">fft.fft</span></code><span class="koboSpan" id="kobo.580.1">), which is extremely fast, </span><code class="inlineCode"><span class="koboSpan" id="kobo.581.1">numpy</span></code><span class="koboSpan" id="kobo.582.1"> being based on </span><strong class="keyWord"><span class="koboSpan" id="kobo.583.1">BLAS</span></strong><span class="koboSpan" id="kobo.584.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.585.1">Basic Linear Algebra Subprograms</span></strong><span class="koboSpan" id="kobo.586.1">) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.587.1">Lapack</span></strong><span class="koboSpan" id="kobo.588.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.589.1">Linear Algebra PACkage</span></strong><span class="koboSpan" id="kobo.590.1">), two libraries that provide routines for performing</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.591.1"> basic vector and matrix operations and solving linear algebra equations. </span><span class="koboSpan" id="kobo.591.2">The output of the function used here is a one-dimensional array of complex values. </span><span class="koboSpan" id="kobo.591.3">Then, we extract the vectors of real and imaginary parts from the array of complex values, and we calculate the following features:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.592.1">Extract real and imaginary parts of the FFT; this is the first part of further processing the Fourier fast transform of the acoustic signal.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.593.1">Calculate the mean, standard deviation, min, and max for both the real and imaginary parts of the FFT. </span><span class="koboSpan" id="kobo.593.2">From the previous transformation, which separates the real and imaginary parts of the FFT, we then calculate these aggregate functions.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.594.1">Calculate the mean, standard deviation, min and max for both the real and imaginary parts of the FFT for 5K and 15K data points from the end of the FFT vector.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.595.1">The code to create the file segment </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.596.1">as well as the FFT and FFT-derived features</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.597.1"> is given here. </span><span class="koboSpan" id="kobo.597.2">First, we calculate the FFT for the subset of the acoustic data. </span><span class="koboSpan" id="kobo.597.3">Then, we calculate the real and imaginary parts of the FFT. </span><span class="koboSpan" id="kobo.597.4">From the real FFT component, we calculate, using pandas’ aggregated functions, the mean, standard deviation, max, and min values. </span><span class="koboSpan" id="kobo.597.5">We then calculate similar values from the imaginary part of the FFT signal:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.598.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.599.1">create_features</span></span><span class="koboSpan" id="kobo.600.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.601.1">seg_id, seg, X</span></span><span class="koboSpan" id="kobo.602.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.603.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.604.1">    Create features</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.605.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.606.1">        seg_id: the id of current data segment to process</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.607.1">        seg: the current selected segment data</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.608.1">        X: transformed train data</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.609.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.610.1">        None</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.611.1">    """</span></span><span class="koboSpan" id="kobo.612.1">
    xc = pd.Series(seg[</span><span class="hljs-string"><span class="koboSpan" id="kobo.613.1">'acoustic_data'</span></span><span class="koboSpan" id="kobo.614.1">].values)
    zc = np.fft.fft(xc)
    
    
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.615.1">#FFT transform values</span></span><span class="koboSpan" id="kobo.616.1">
    realFFT = np.real(zc)
    imagFFT = np.imag(zc)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.617.1">'Rmean'</span></span><span class="koboSpan" id="kobo.618.1">] = realFFT.mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.619.1">'Rstd'</span></span><span class="koboSpan" id="kobo.620.1">]  = realFFT.std()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.621.1">'Rmax'</span></span><span class="koboSpan" id="kobo.622.1">]  = realFFT.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.623.1">max</span></span><span class="koboSpan" id="kobo.624.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.625.1">'Rmin'</span></span><span class="koboSpan" id="kobo.626.1">]  = realFFT.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.627.1">min</span></span><span class="koboSpan" id="kobo.628.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.629.1">'Imean'</span></span><span class="koboSpan" id="kobo.630.1">] = imagFFT.mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.631.1">'Istd'</span></span><span class="koboSpan" id="kobo.632.1">]  = imagFFT.std()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.633.1">'Imax'</span></span><span class="koboSpan" id="kobo.634.1">]  = imagFFT.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.635.1">max</span></span><span class="koboSpan" id="kobo.636.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.637.1">'Imin'</span></span><span class="koboSpan" id="kobo.638.1">]  = imagFFT.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.639.1">min</span></span><span class="koboSpan" id="kobo.640.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.641.1">'Rmean_last_5000'</span></span><span class="koboSpan" id="kobo.642.1">]  = realFFT[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.643.1">5000</span></span><span class="koboSpan" id="kobo.644.1">:].mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.645.1">'Rstd__last_5000'</span></span><span class="koboSpan" id="kobo.646.1">]  = realFFT[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.647.1">5000</span></span><span class="koboSpan" id="kobo.648.1">:].std()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.649.1">'Rmax_last_5000'</span></span><span class="koboSpan" id="kobo.650.1">]   = realFFT[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.651.1">5000</span></span><span class="koboSpan" id="kobo.652.1">:].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.653.1">max</span></span><span class="koboSpan" id="kobo.654.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.655.1">'Rmin_last_5000'</span></span><span class="koboSpan" id="kobo.656.1">]   = realFFT[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.657.1">5000</span></span><span class="koboSpan" id="kobo.658.1">:].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.659.1">min</span></span><span class="koboSpan" id="kobo.660.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.661.1">'Rmean_last_15000'</span></span><span class="koboSpan" id="kobo.662.1">] = realFFT[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.663.1">15000</span></span><span class="koboSpan" id="kobo.664.1">:].mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.665.1">'Rstd_last_15000'</span></span><span class="koboSpan" id="kobo.666.1">] = realFFT[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.667.1">15000</span></span><span class="koboSpan" id="kobo.668.1">:].std()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.669.1">'Rmax_last_15000'</span></span><span class="koboSpan" id="kobo.670.1">] = realFFT[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.671.1">15000</span></span><span class="koboSpan" id="kobo.672.1">:].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.673.1">max</span></span><span class="koboSpan" id="kobo.674.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.675.1">'Rmin_last_15000'</span></span><span class="koboSpan" id="kobo.676.1">] = realFFT[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.677.1">15000</span></span><span class="koboSpan" id="kobo.678.1">:].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.679.1">min</span></span><span class="koboSpan" id="kobo.680.1">()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.681.1">We then follow with calculating features derived from various aggregated functions.</span></p>
<h2 class="heading-2" id="_idParaDest-120"><span class="koboSpan" id="kobo.682.1">Features derived from aggregate functions</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.683.1">The mean, standard</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.684.1"> deviation, max, and min applied</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.685.1"> to the entire segment are calculated with the following code, using pandas’ aggregate functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.686.1">mean</span></code><span class="koboSpan" id="kobo.687.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.688.1">std</span></code><span class="koboSpan" id="kobo.689.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">max</span></code><span class="koboSpan" id="kobo.691.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">min</span></code><span class="koboSpan" id="kobo.693.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.694.1">    xc = pd.Series(seg[</span><span class="hljs-string"><span class="koboSpan" id="kobo.695.1">'acoustic_data'</span></span><span class="koboSpan" id="kobo.696.1">].values)
    zc = np.fft.fft(xc)
    
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.697.1">'mean'</span></span><span class="koboSpan" id="kobo.698.1">] = xc.mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.699.1">'std'</span></span><span class="koboSpan" id="kobo.700.1">] = xc.std()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.701.1">'max'</span></span><span class="koboSpan" id="kobo.702.1">] = xc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.703.1">max</span></span><span class="koboSpan" id="kobo.704.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.705.1">'min'</span></span><span class="koboSpan" id="kobo.706.1">] = xc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.707.1">min</span></span><span class="koboSpan" id="kobo.708.1">()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.709.1">We continue to compute additional aggregated features. </span><span class="koboSpan" id="kobo.709.2">For our model, we will include various signal processing techniques, as you’ll notice, and then, by measuring the feature importance after we train our baseline model, we will qualify which features contribute more to our model prediction.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.710.1">Moving on, we calculate the mean change for the entire segment; here, “segment” refers to the original subset of acoustic data. </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">change</span></code><span class="koboSpan" id="kobo.712.1"> is calculated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">numpy</span></code><span class="koboSpan" id="kobo.714.1"> function </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">diff</span></code><span class="koboSpan" id="kobo.716.1"> and the parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">1</span></code><span class="koboSpan" id="kobo.718.1">. </span><span class="koboSpan" id="kobo.718.2">This function receives an array of values and calculates the difference between each successive value in the array. </span><span class="koboSpan" id="kobo.718.3">Then we calculate the average of the values in the array of differences. </span><span class="koboSpan" id="kobo.718.4">We also calculate the mean change rate for the entire acoustic data segment. </span><span class="koboSpan" id="kobo.718.5">This is calculated as the average of non-zero values in the new change vector divided by the original values in the data segment. </span><span class="koboSpan" id="kobo.718.6">The code for these features is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.719.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.720.1">'mean_change_abs'</span></span><span class="koboSpan" id="kobo.721.1">] = np.mean(np.diff(xc))
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.722.1">'mean_change_rate'</span></span><span class="koboSpan" id="kobo.723.1">] = np.mean(nonzero(np.diff(xc) / xc[:-</span><span class="hljs-number"><span class="koboSpan" id="kobo.724.1">1</span></span><span class="koboSpan" id="kobo.725.1">])[</span><span class="hljs-number"><span class="koboSpan" id="kobo.726.1">0</span></span><span class="koboSpan" id="kobo.727.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.728.1">Additionally, we also calculate the maximum and minimum of the absolute values (per entire segment). </span><span class="koboSpan" id="kobo.728.2">After calculating the absolute values, we calculate the minimum and maximum values. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.729.1">We are trying to include a diverse range of features, to capture as much of the signal patterns as possible, when we aggregate the temporal signal. </span><span class="koboSpan" id="kobo.729.2">The code for this is:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.730.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.731.1">'abs_max'</span></span><span class="koboSpan" id="kobo.732.1">] = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.733.1">abs</span></span><span class="koboSpan" id="kobo.734.1">(xc).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.735.1">max</span></span><span class="koboSpan" id="kobo.736.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.737.1">'abs_min'</span></span><span class="koboSpan" id="kobo.738.1">] = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.739.1">abs</span></span><span class="koboSpan" id="kobo.740.1">(xc).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.741.1">min</span></span><span class="koboSpan" id="kobo.742.1">()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.743.1">A set of aggregated functions on the first and last 10K and 50K values per acoustic data segment can also be calculated, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.744.1">Standard deviation for first 50K and last 10K values per acoustic data segment</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.745.1">Average value for first 50K and last 10K values per acoustic data segment</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.746.1">Minimum values for first 50K and last 10K values per acoustic data segment</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.747.1">Maximum values for first 50K and last 10K values per acoustic data segment</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.748.1">These features are aggregating</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.749.1"> a smaller part of the signal</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.750.1"> and therefore will capture signal characteristics from only a smaller interval before the failure. </span><span class="koboSpan" id="kobo.750.2">The combination of aggregated features on the whole signal length and on a smaller part of the signal will add more information about the signal. </span><span class="koboSpan" id="kobo.750.3">The code for these features will be:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.751.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.752.1">'std_first_50000'</span></span><span class="koboSpan" id="kobo.753.1">] = xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.754.1">50000</span></span><span class="koboSpan" id="kobo.755.1">].std()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.756.1">'std_last_50000'</span></span><span class="koboSpan" id="kobo.757.1">] = xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.758.1">50000</span></span><span class="koboSpan" id="kobo.759.1">:].std()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.760.1">'std_first_10000'</span></span><span class="koboSpan" id="kobo.761.1">] = xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.762.1">10000</span></span><span class="koboSpan" id="kobo.763.1">].std()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.764.1">'std_last_10000'</span></span><span class="koboSpan" id="kobo.765.1">] = xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.766.1">10000</span></span><span class="koboSpan" id="kobo.767.1">:].std()
    
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.768.1">'avg_first_50000'</span></span><span class="koboSpan" id="kobo.769.1">] = xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.770.1">50000</span></span><span class="koboSpan" id="kobo.771.1">].mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.772.1">'avg_last_50000'</span></span><span class="koboSpan" id="kobo.773.1">] = xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.774.1">50000</span></span><span class="koboSpan" id="kobo.775.1">:].mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.776.1">'avg_first_10000'</span></span><span class="koboSpan" id="kobo.777.1">] = xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.778.1">10000</span></span><span class="koboSpan" id="kobo.779.1">].mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.780.1">'avg_last_10000'</span></span><span class="koboSpan" id="kobo.781.1">] = xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.782.1">10000</span></span><span class="koboSpan" id="kobo.783.1">:].mean()
    
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.784.1">'min_first_50000'</span></span><span class="koboSpan" id="kobo.785.1">] = xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.786.1">50000</span></span><span class="koboSpan" id="kobo.787.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.788.1">min</span></span><span class="koboSpan" id="kobo.789.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.790.1">'min_last_50000'</span></span><span class="koboSpan" id="kobo.791.1">] = xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.792.1">50000</span></span><span class="koboSpan" id="kobo.793.1">:].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.794.1">min</span></span><span class="koboSpan" id="kobo.795.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.796.1">'min_first_10000'</span></span><span class="koboSpan" id="kobo.797.1">] = xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.798.1">10000</span></span><span class="koboSpan" id="kobo.799.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.800.1">min</span></span><span class="koboSpan" id="kobo.801.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.802.1">'min_last_10000'</span></span><span class="koboSpan" id="kobo.803.1">] = xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.804.1">10000</span></span><span class="koboSpan" id="kobo.805.1">:].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.806.1">min</span></span><span class="koboSpan" id="kobo.807.1">()
    
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.808.1">'max_first_50000'</span></span><span class="koboSpan" id="kobo.809.1">] = xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.810.1">50000</span></span><span class="koboSpan" id="kobo.811.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.812.1">max</span></span><span class="koboSpan" id="kobo.813.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.814.1">'max_last_50000'</span></span><span class="koboSpan" id="kobo.815.1">] = xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.816.1">50000</span></span><span class="koboSpan" id="kobo.817.1">:].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.818.1">max</span></span><span class="koboSpan" id="kobo.819.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.820.1">'max_first_10000'</span></span><span class="koboSpan" id="kobo.821.1">] = xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.822.1">10000</span></span><span class="koboSpan" id="kobo.823.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.824.1">max</span></span><span class="koboSpan" id="kobo.825.1">()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.826.1">'max_last_10000'</span></span><span class="koboSpan" id="kobo.827.1">] = xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.828.1">10000</span></span><span class="koboSpan" id="kobo.829.1">:].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.830.1">max</span></span><span class="koboSpan" id="kobo.831.1">()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.832.1">Next, we include the ratio of maximum to minimum values for the entire acoustic data segment and the difference between the maximum and minimum values for the entire acoustic data segment. </span><span class="koboSpan" id="kobo.832.2">We also add the number of values exceeding a certain amplitude of oscillation (above 500 units) and the sum of values per entire segment. </span><span class="koboSpan" id="kobo.832.3">We try to capture some of the hidden patterns in the signal using this diversity of features we engineer. </span><span class="koboSpan" id="kobo.832.4">In particular, here, we include information from the extreme oscillations in the signal:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.833.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.834.1">'max_to_min'</span></span><span class="koboSpan" id="kobo.835.1">] = xc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.836.1">max</span></span><span class="koboSpan" id="kobo.837.1">() / np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.838.1">abs</span></span><span class="koboSpan" id="kobo.839.1">(xc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.840.1">min</span></span><span class="koboSpan" id="kobo.841.1">())
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.842.1">'max_to_min_diff'</span></span><span class="koboSpan" id="kobo.843.1">] = xc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.844.1">max</span></span><span class="koboSpan" id="kobo.845.1">() - np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.846.1">abs</span></span><span class="koboSpan" id="kobo.847.1">(xc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.848.1">min</span></span><span class="koboSpan" id="kobo.849.1">())
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.850.1">'count_big'</span></span><span class="koboSpan" id="kobo.851.1">] = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.852.1">len</span></span><span class="koboSpan" id="kobo.853.1">(xc[np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.854.1">abs</span></span><span class="koboSpan" id="kobo.855.1">(xc) &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.856.1">500</span></span><span class="koboSpan" id="kobo.857.1">])
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.858.1">'sum'</span></span><span class="koboSpan" id="kobo.859.1">] = xc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.860.1">sum</span></span><span class="koboSpan" id="kobo.861.1">()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.862.1">We continue to add diverse aggregated features</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.863.1"> that try to capture various characteristics</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.864.1"> of the original signal. </span><span class="koboSpan" id="kobo.864.2">We further calculate the mean change rate (excluding nulls) for the first 10K and last 50K data points per acoustic data segment:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.865.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.866.1">'mean_change_rate_first_50000'</span></span><span class="koboSpan" id="kobo.867.1">] = np.mean(nonzero((np.diff(xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.868.1">50000</span></span><span class="koboSpan" id="kobo.869.1">]) / xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.870.1">50000</span></span><span class="koboSpan" id="kobo.871.1">][:-</span><span class="hljs-number"><span class="koboSpan" id="kobo.872.1">1</span></span><span class="koboSpan" id="kobo.873.1">]))[</span><span class="hljs-number"><span class="koboSpan" id="kobo.874.1">0</span></span><span class="koboSpan" id="kobo.875.1">])
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.876.1">'mean_change_rate_last_50000'</span></span><span class="koboSpan" id="kobo.877.1">] = np.mean(nonzero((np.diff(xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.878.1">50000</span></span><span class="koboSpan" id="kobo.879.1">:]) / xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.880.1">50000</span></span><span class="koboSpan" id="kobo.881.1">:][:-</span><span class="hljs-number"><span class="koboSpan" id="kobo.882.1">1</span></span><span class="koboSpan" id="kobo.883.1">]))[</span><span class="hljs-number"><span class="koboSpan" id="kobo.884.1">0</span></span><span class="koboSpan" id="kobo.885.1">])
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.886.1">'mean_change_rate_first_10000'</span></span><span class="koboSpan" id="kobo.887.1">] = np.mean(nonzero((np.diff(xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.888.1">10000</span></span><span class="koboSpan" id="kobo.889.1">]) / xc[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.890.1">10000</span></span><span class="koboSpan" id="kobo.891.1">][:-</span><span class="hljs-number"><span class="koboSpan" id="kobo.892.1">1</span></span><span class="koboSpan" id="kobo.893.1">]))[</span><span class="hljs-number"><span class="koboSpan" id="kobo.894.1">0</span></span><span class="koboSpan" id="kobo.895.1">])
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.896.1">'mean_change_rate_last_10000'</span></span><span class="koboSpan" id="kobo.897.1">] = np.mean(nonzero((np.diff(xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.898.1">10000</span></span><span class="koboSpan" id="kobo.899.1">:]) / xc[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.900.1">10000</span></span><span class="koboSpan" id="kobo.901.1">:][:-</span><span class="hljs-number"><span class="koboSpan" id="kobo.902.1">1</span></span><span class="koboSpan" id="kobo.903.1">]))[</span><span class="hljs-number"><span class="koboSpan" id="kobo.904.1">0</span></span><span class="koboSpan" id="kobo.905.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.906.1">Some of the features we are adding will exclude the elements in the data that are </span><code class="inlineCode"><span class="koboSpan" id="kobo.907.1">0</span></code><span class="koboSpan" id="kobo.908.1">, to ensure only non-zero values are included in the calculation of the aggregated function. </span><span class="koboSpan" id="kobo.908.2">The code for using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.909.1">nonzero</span></code><span class="koboSpan" id="kobo.910.1"> function is:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.911.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.912.1">nonzero</span></span><span class="koboSpan" id="kobo.913.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.914.1">x</span></span><span class="koboSpan" id="kobo.915.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.916.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.917.1">    Utility function to simplify call of numpy `nonzero` function</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.918.1">    """</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.919.1">return</span></span><span class="koboSpan" id="kobo.920.1"> np.nonzero(np.atleast_1d(x))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.921.1">A set of engineered features</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.922.1"> involves quantiles, specifically</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.923.1"> the 01%, 05%, 95%, and 99% quantile values, for the entire acoustic data segment. </span><span class="koboSpan" id="kobo.923.2">The quantiles are calculated using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.924.1">numpy</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.925.1">quantile</span></code><span class="koboSpan" id="kobo.926.1"> function. </span><span class="koboSpan" id="kobo.926.2">A quantile is a statistical term that refers to dividing a dataset into intervals of equal probability. </span><span class="koboSpan" id="kobo.926.3">For example, a 75% quantile value is the point where 75% of the data has values less than that number. </span><span class="koboSpan" id="kobo.926.4">A 50% quantile</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.927.1"> is the point where 50% of the data has values less than that number (and is also called the median). </span><span class="koboSpan" id="kobo.927.2">We also add absolute values for the 01%, 05%, 95%, and 99% quantile values. </span><span class="koboSpan" id="kobo.927.3">See the following code for the calculation of these features:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.928.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.929.1">'q95'</span></span><span class="koboSpan" id="kobo.930.1">] = np.quantile(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.931.1">0.95</span></span><span class="koboSpan" id="kobo.932.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.933.1">'q99'</span></span><span class="koboSpan" id="kobo.934.1">] = np.quantile(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.935.1">0.99</span></span><span class="koboSpan" id="kobo.936.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.937.1">'q05'</span></span><span class="koboSpan" id="kobo.938.1">] = np.quantile(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.939.1">0.05</span></span><span class="koboSpan" id="kobo.940.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.941.1">'q01'</span></span><span class="koboSpan" id="kobo.942.1">] = np.quantile(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.943.1">0.01</span></span><span class="koboSpan" id="kobo.944.1">)
    
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.945.1">'abs_q95'</span></span><span class="koboSpan" id="kobo.946.1">] = np.quantile(np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.947.1">abs</span></span><span class="koboSpan" id="kobo.948.1">(xc), </span><span class="hljs-number"><span class="koboSpan" id="kobo.949.1">0.95</span></span><span class="koboSpan" id="kobo.950.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.951.1">'abs_q99'</span></span><span class="koboSpan" id="kobo.952.1">] = np.quantile(np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.953.1">abs</span></span><span class="koboSpan" id="kobo.954.1">(xc), </span><span class="hljs-number"><span class="koboSpan" id="kobo.955.1">0.99</span></span><span class="koboSpan" id="kobo.956.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.957.1">'abs_q05'</span></span><span class="koboSpan" id="kobo.958.1">] = np.quantile(np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.959.1">abs</span></span><span class="koboSpan" id="kobo.960.1">(xc), </span><span class="hljs-number"><span class="koboSpan" id="kobo.961.1">0.05</span></span><span class="koboSpan" id="kobo.962.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.963.1">'abs_q01'</span></span><span class="koboSpan" id="kobo.964.1">] = np.quantile (np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.965.1">abs</span></span><span class="koboSpan" id="kobo.966.1">(xc), </span><span class="hljs-number"><span class="koboSpan" id="kobo.967.1">0.01</span></span><span class="koboSpan" id="kobo.968.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.969.1">Another type of engineered feature introduced is trend values (calculated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.970.1">add_trend_values</span></code><span class="koboSpan" id="kobo.971.1"> function with the absolute flag off). </span><span class="koboSpan" id="kobo.971.2">Trend values will capture the general direction in which the acoustic data signal is changing. </span><span class="koboSpan" id="kobo.971.3">For a signal that shows an oscillation around 0 with high frequency, the trend will capture the change in the average value of the actual signal.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.972.1">We also add absolute trend values (calculated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.973.1">add_trend_values</span></code><span class="koboSpan" id="kobo.974.1"> function with the absolute flag on). </span><span class="koboSpan" id="kobo.974.2">We include this type of engineering feature to capture patterns in the signal that appear in the absolute value of the signal. </span><span class="koboSpan" id="kobo.974.3">In this case, for the calculation of the trend, we use the absolute values of the original signal. </span><span class="koboSpan" id="kobo.974.4">Therefore, this trend will capture the direction of variation of the absolute value of the signal. </span><span class="koboSpan" id="kobo.974.5">The corresponding code is given here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.975.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.976.1">'trend'</span></span><span class="koboSpan" id="kobo.977.1">] = add_trend_feature(xc)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.978.1">'abs_trend'</span></span><span class="koboSpan" id="kobo.979.1">] = add_trend_feature(xc, abs_values=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.980.1">True</span></span><span class="koboSpan" id="kobo.981.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.982.1">Next, we include the mean of absolute values and the standard deviation of absolute values. </span><span class="koboSpan" id="kobo.982.2">Median absolute deviation (</span><code class="inlineCode"><span class="koboSpan" id="kobo.983.1">mad</span></code><span class="koboSpan" id="kobo.984.1">), </span><code class="inlineCode"><span class="koboSpan" id="kobo.985.1">Kurtosis</span></code><span class="koboSpan" id="kobo.986.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.987.1">Skew</span></code><span class="koboSpan" id="kobo.988.1"> (skewness), and </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">Median</span></code><span class="koboSpan" id="kobo.990.1"> values are also calculated. </span><span class="koboSpan" id="kobo.990.2">These functions are calculated using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.991.1">numpy</span></code><span class="koboSpan" id="kobo.992.1"> implementation. </span><span class="koboSpan" id="kobo.992.2">The median absolute deviation is a robust measure of the variability of a univariate sample of quantitative data. </span><span class="koboSpan" id="kobo.992.3">Kurtosis is a measure of the combined weight of a distribution tail relative to the center of the distribution. </span><span class="koboSpan" id="kobo.992.4">Skew (from skewness) is a measure of the asymmetry or distortion of a symmetric distribution. </span><span class="koboSpan" id="kobo.992.5">The median is, as we’ve already observed, the value separating the higher half from the lower half of a set of data. </span><span class="koboSpan" id="kobo.992.6">All these aggregated functions capture complementary</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.993.1"> information about the signal. </span><span class="koboSpan" id="kobo.993.2">The code for the calculation of these aggregation</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.994.1"> functions is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.995.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.996.1">'abs_mean'</span></span><span class="koboSpan" id="kobo.997.1">] = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.998.1">abs</span></span><span class="koboSpan" id="kobo.999.1">(xc).mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1000.1">'abs_std'</span></span><span class="koboSpan" id="kobo.1001.1">] = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1002.1">abs</span></span><span class="koboSpan" id="kobo.1003.1">(xc).std()
    
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1004.1">'mad'</span></span><span class="koboSpan" id="kobo.1005.1">] = xc.mad()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1006.1">'kurt'</span></span><span class="koboSpan" id="kobo.1007.1">] = xc.kurtosis()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1008.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1009.1">skew'</span></span><span class="koboSpan" id="kobo.1010.1">] = xc.skew()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1011.1">'med'</span></span><span class="koboSpan" id="kobo.1012.1">] = xc.median()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1013.1">Next, we include several features calculated by using transformation functions specific to signal processing.</span></p>
<h2 class="heading-2" id="_idParaDest-121"><span class="koboSpan" id="kobo.1014.1">Features derived using the Hilbert transform and Hann window</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1015.1">We also calculate the Hilbert mean. </span><span class="koboSpan" id="kobo.1015.2">We apply the Hilbert</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.1016.1"> transform of the acoustic signal</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.1017.1"> segment using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1018.1">scipy.signal.hilbert</span></code><span class="koboSpan" id="kobo.1019.1"> function. </span><span class="koboSpan" id="kobo.1019.2">This calculates</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.1020.1"> the analytic signal, using</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.1021.1"> the Hilbert transform. </span><span class="koboSpan" id="kobo.1021.2">Then, we calculate the mean of the absolute value of the transformed data. </span><span class="koboSpan" id="kobo.1021.3">The Hilbert transform is used frequently in signal processing and captures important information about the signal. </span><span class="koboSpan" id="kobo.1021.4">Because we use aggregation functions to generate features from our temporal data, we would like to include a large, diverse range of existing signal processing techniques, to add important complementary elements of the signal when training the model:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1022.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1023.1">'Hilbert_mean'</span></span><span class="koboSpan" id="kobo.1024.1">] = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1025.1">abs</span></span><span class="koboSpan" id="kobo.1026.1">(hilbert(xc)).mean()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1027.1">Next, we include a feature derived from the Hann window mean value. </span><span class="koboSpan" id="kobo.1027.2">We use this feature derived from the Hann window to reduce the abrupt discontinuities at the edge of the signal. </span><span class="koboSpan" id="kobo.1027.3">The Hann window mean value is calculated using the convolution of the original signal with the result of the Hanning window and dividing by the sum of all values in the Hanning window:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1028.1">     X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1029.1">'Hann_window_mean'</span></span><span class="koboSpan" id="kobo.1030.1">] = (convolve(xc, hann(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1031.1">150</span></span><span class="koboSpan" id="kobo.1032.1">), mode=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1033.1">'same'</span></span><span class="koboSpan" id="kobo.1034.1">) / </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1035.1">sum</span></span><span class="koboSpan" id="kobo.1036.1">(hann(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1037.1">150</span></span><span class="koboSpan" id="kobo.1038.1">))).mean()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1039.1">We previously introduced the definition of classical STA/LTA. </span><span class="koboSpan" id="kobo.1039.2">We calculate a few features like classical STA/LTA mean for 500-10K, 5K-100K, 3,333-6,666, and 10K-25K STA/LTA windows. </span><span class="koboSpan" id="kobo.1039.3">These are calculated</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.1040.1"> with the STA/LTA function</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.1041.1"> introduced previously. </span><span class="koboSpan" id="kobo.1041.2">We include a variety of transformations</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.1042.1"> to try to capture diverse signal characteristics in the aggregated</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.1043.1"> engineering features:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1044.1">    
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1045.1">'Hilbert_mean'</span></span><span class="koboSpan" id="kobo.1046.1">] = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1047.1">abs</span></span><span class="koboSpan" id="kobo.1048.1">(hilbert(xc)).mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1049.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1050.1">Hann_window_mean'</span></span><span class="koboSpan" id="kobo.1051.1">] = (convolve(xc, hann(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1052.1">150</span></span><span class="koboSpan" id="kobo.1053.1">), mode=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1054.1">'same'</span></span><span class="koboSpan" id="kobo.1055.1">) / </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1056.1">sum</span></span><span class="koboSpan" id="kobo.1057.1">(hann(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1058.1">150</span></span><span class="koboSpan" id="kobo.1059.1">))).mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1060.1">'classic_sta_lta1_mean'</span></span><span class="koboSpan" id="kobo.1061.1">] = classic_sta_lta(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1062.1">500</span></span><span class="koboSpan" id="kobo.1063.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1064.1">10000</span></span><span class="koboSpan" id="kobo.1065.1">).mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1066.1">'classic_sta_lta2_mean'</span></span><span class="koboSpan" id="kobo.1067.1">] = classic_sta_lta(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1068.1">5000</span></span><span class="koboSpan" id="kobo.1069.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1070.1">100000</span></span><span class="koboSpan" id="kobo.1071.1">).mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1072.1">'classic_sta_lta3_mean'</span></span><span class="koboSpan" id="kobo.1073.1">] = classic_sta_lta(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1074.1">3333</span></span><span class="koboSpan" id="kobo.1075.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1076.1">6666</span></span><span class="koboSpan" id="kobo.1077.1">).mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1078.1">'classic_sta_lta4_mean'</span></span><span class="koboSpan" id="kobo.1079.1">] = classic_sta_lta(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1080.1">10000</span></span><span class="koboSpan" id="kobo.1081.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1082.1">25000</span></span><span class="koboSpan" id="kobo.1083.1">).mean()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1084.1">Finally, we will also calculate features based on moving averages.</span></p>
<h2 class="heading-2" id="_idParaDest-122"><span class="koboSpan" id="kobo.1085.1">Features based on moving averages</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1086.1">Next, we calculate several </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.1087.1">moving averages, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1088.1">Moving average means for the 700, 1.5K, 3K, and 6K windows (and excluding NaNs)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1089.1">Exponentially weighted moving average with spans of 300, 3K, and 6K</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1090.1">Average standard deviation moving average over 700 and 400 windows</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1091.1">Moving averages means for 700-size window plus or minus 2 times average standard deviation moving average over the same size window</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1092.1">The moving averages help</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.1093.1"> us to discern patterns, reduce noise, and provide a clear picture of the underlying trends in the data. </span><span class="koboSpan" id="kobo.1093.2">The code for that will be:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1094.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1095.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1096.1">Moving_average_700_mean'</span></span><span class="koboSpan" id="kobo.1097.1">] = xc.rolling(window=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1098.1">700</span></span><span class="koboSpan" id="kobo.1099.1">).mean().mean(skipna=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1100.1">True</span></span><span class="koboSpan" id="kobo.1101.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1102.1">'Moving_average_1500_mean'</span></span><span class="koboSpan" id="kobo.1103.1">] = xc.rolling(window=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1104.1">1500</span></span><span class="koboSpan" id="kobo.1105.1">).mean().mean(skipna=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1106.1">True</span></span><span class="koboSpan" id="kobo.1107.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1108.1">'Moving_average_3000_mean'</span></span><span class="koboSpan" id="kobo.1109.1">] = xc.rolling(window=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1110.1">3000</span></span><span class="koboSpan" id="kobo.1111.1">).mean().mean(skipna=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1112.1">True</span></span><span class="koboSpan" id="kobo.1113.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1114.1">'Moving_average_6000_mean'</span></span><span class="koboSpan" id="kobo.1115.1">] = xc.rolling(window=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1116.1">6000</span></span><span class="koboSpan" id="kobo.1117.1">).mean().mean(skipna=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1118.1">True</span></span><span class="koboSpan" id="kobo.1119.1">)
    ewma = pd.Series.ewm
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1120.1">'exp_Moving_average_300_mean'</span></span><span class="koboSpan" id="kobo.1121.1">] = (ewma(xc, span=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1122.1">300</span></span><span class="koboSpan" id="kobo.1123.1">).mean()).mean(skipna=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1124.1">True</span></span><span class="koboSpan" id="kobo.1125.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1126.1">'exp_Moving_average_3000_mean'</span></span><span class="koboSpan" id="kobo.1127.1">] = ewma(xc, span=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1128.1">3000</span></span><span class="koboSpan" id="kobo.1129.1">).mean().mean(skipna=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1130.1">True</span></span><span class="koboSpan" id="kobo.1131.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1132.1">'exp_Moving_average_30000_mean'</span></span><span class="koboSpan" id="kobo.1133.1">] = ewma(xc, span=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1134.1">6000</span></span><span class="koboSpan" id="kobo.1135.1">).mean().mean(skipna=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1136.1">True</span></span><span class="koboSpan" id="kobo.1137.1">)
    no_of_std = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1138.1">2</span></span><span class="koboSpan" id="kobo.1139.1">
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1140.1">'MA_700MA_std_mean'</span></span><span class="koboSpan" id="kobo.1141.1">] = xc.rolling(window=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1142.1">700</span></span><span class="koboSpan" id="kobo.1143.1">).std().mean()
    X.loc[seg_id,</span><span class="hljs-string"><span class="koboSpan" id="kobo.1144.1">'MA_700MA_BB_high_mean'</span></span><span class="koboSpan" id="kobo.1145.1">] = (X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1146.1">'Moving_average_700_mean'</span></span><span class="koboSpan" id="kobo.1147.1">] + no_of_std * X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1148.1">'MA_700MA_std_mean'</span></span><span class="koboSpan" id="kobo.1149.1">]).mean()
    X.loc[seg_id,</span><span class="hljs-string"><span class="koboSpan" id="kobo.1150.1">'MA_700MA_BB_low_mean'</span></span><span class="koboSpan" id="kobo.1151.1">] = (X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1152.1">'Moving_average_700_mean'</span></span><span class="koboSpan" id="kobo.1153.1">] - no_of_std * X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1154.1">'MA_700MA_std_mean'</span></span><span class="koboSpan" id="kobo.1155.1">]).mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1156.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1157.1">MA_400MA_std_mean'</span></span><span class="koboSpan" id="kobo.1158.1">] = xc.rolling(window=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1159.1">400</span></span><span class="koboSpan" id="kobo.1160.1">).std().mean()
    X.loc[seg_id,</span><span class="hljs-string"><span class="koboSpan" id="kobo.1161.1">'MA_400MA_BB_high_mean'</span></span><span class="koboSpan" id="kobo.1162.1">] = (X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1163.1">'Moving_average_700_mean'</span></span><span class="koboSpan" id="kobo.1164.1">] + no_of_std * X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1165.1">'MA_400MA_std_mean'</span></span><span class="koboSpan" id="kobo.1166.1">]).mean()
    X.loc[seg_id,</span><span class="hljs-string"><span class="koboSpan" id="kobo.1167.1">'MA_400MA_BB_low_mean'</span></span><span class="koboSpan" id="kobo.1168.1">] = (X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1169.1">'Moving_average_700_mean'</span></span><span class="koboSpan" id="kobo.1170.1">] - no_of_std * X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1171.1">'MA_400MA_std_mean'</span></span><span class="koboSpan" id="kobo.1172.1">]).mean()
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1173.1">'MA_1000MA_std_mean'</span></span><span class="koboSpan" id="kobo.1174.1">] = xc.rolling(window=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1175.1">1000</span></span><span class="koboSpan" id="kobo.1176.1">).std().mean()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1177.1">We also calculate the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1178.1">IQR</span></strong><span class="koboSpan" id="kobo.1179.1">, the 001% and 999% quantiles. </span><span class="koboSpan" id="kobo.1179.2">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.1180.1">IQR</span></strong><span class="koboSpan" id="kobo.1181.1"> (meaning </span><strong class="keyWord"><span class="koboSpan" id="kobo.1182.1">interquartile range</span></strong><span class="koboSpan" id="kobo.1183.1">) is calculated by subtracting</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.1184.1"> the 25% percentile from the 75% percentile (using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1185.1">numpy</span></code><span class="koboSpan" id="kobo.1186.1"> functions). </span><span class="koboSpan" id="kobo.1186.2">The interquartile range is the region where 50% of the data is found. </span><span class="koboSpan" id="kobo.1186.3">The 001% and 999% quantiles are also calculated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1187.1">numpy</span></code><span class="koboSpan" id="kobo.1188.1"> function for quantiles. </span><span class="koboSpan" id="kobo.1188.2">The IQR and the various other quantiles we have included are useful because they provide important information about the central tendency and the spread of the signal:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1189.1">    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1190.1">'iqr'</span></span><span class="koboSpan" id="kobo.1191.1">] = np.subtract(*np.percentile(xc, [</span><span class="hljs-number"><span class="koboSpan" id="kobo.1192.1">75</span></span><span class="koboSpan" id="kobo.1193.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1194.1">25</span></span><span class="koboSpan" id="kobo.1195.1">]))
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1196.1">'q999'</span></span><span class="koboSpan" id="kobo.1197.1">] = np.quantile(xc,</span><span class="hljs-number"><span class="koboSpan" id="kobo.1198.1">0.999</span></span><span class="koboSpan" id="kobo.1199.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1200.1">'q001'</span></span><span class="koboSpan" id="kobo.1201.1">] = np.quantile(xc,</span><span class="hljs-number"><span class="koboSpan" id="kobo.1202.1">0.001</span></span><span class="koboSpan" id="kobo.1203.1">)
    X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1204.1">'ave10'</span></span><span class="koboSpan" id="kobo.1205.1">] = stats.trim_mean(xc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1206.1">0.1</span></span><span class="koboSpan" id="kobo.1207.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1208.1">For windows of 10, 100, and 1,000, we calculate the moving average and moving standard deviation. </span><span class="koboSpan" id="kobo.1208.2">With these values, we then calculate the min, max, mean, standard deviation, average absolute and relative change, 01%, 05%, 95%, and 99% quantiles, and absolute max roll. </span><span class="koboSpan" id="kobo.1208.3">We include these features because they reveal information about the local characteristics of the signal within the specified window. </span><span class="koboSpan" id="kobo.1208.4">Subsequently, for the features derived from the moving average standard deviation</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.1209.1"> calculated for windows of 10, 100, and 1,000, the code is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1210.1">for</span></span><span class="koboSpan" id="kobo.1211.1"> windows </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1212.1">in</span></span><span class="koboSpan" id="kobo.1213.1"> [</span><span class="hljs-number"><span class="koboSpan" id="kobo.1214.1">10</span></span><span class="koboSpan" id="kobo.1215.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1216.1">100</span></span><span class="koboSpan" id="kobo.1217.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1218.1">1000</span></span><span class="koboSpan" id="kobo.1219.1">]:
        x_roll_std = xc.rolling(windows).std().dropna().values
        
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1220.1">'ave_roll_std_'</span></span><span class="koboSpan" id="kobo.1221.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1222.1">str</span></span><span class="koboSpan" id="kobo.1223.1">(windows)] = x_roll_std.mean()
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1224.1">'std_roll_std_'</span></span><span class="koboSpan" id="kobo.1225.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1226.1">str</span></span><span class="koboSpan" id="kobo.1227.1">(windows)] = x_roll_std.std()
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1228.1">'max_roll_std_'</span></span><span class="koboSpan" id="kobo.1229.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1230.1">str</span></span><span class="koboSpan" id="kobo.1231.1">(windows)] = x_roll_std.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1232.1">max</span></span><span class="koboSpan" id="kobo.1233.1">()
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1234.1">'min_roll_std_'</span></span><span class="koboSpan" id="kobo.1235.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1236.1">str</span></span><span class="koboSpan" id="kobo.1237.1">(windows)] = x_roll_std.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1238.1">min</span></span><span class="koboSpan" id="kobo.1239.1">()
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1240.1">'q01_roll_std_'</span></span><span class="koboSpan" id="kobo.1241.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1242.1">str</span></span><span class="koboSpan" id="kobo.1243.1">(windows)] = np.quantile(x_roll_std, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1244.1">0.01</span></span><span class="koboSpan" id="kobo.1245.1">)
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1246.1">'q05_roll_std_'</span></span><span class="koboSpan" id="kobo.1247.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1248.1">str</span></span><span class="koboSpan" id="kobo.1249.1">(windows)] = np.quantile(x_roll_std, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1250.1">0.05</span></span><span class="koboSpan" id="kobo.1251.1">)
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1252.1">'q95_roll_std_'</span></span><span class="koboSpan" id="kobo.1253.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1254.1">str</span></span><span class="koboSpan" id="kobo.1255.1">(windows)] = np.quantile(x_roll_std, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1256.1">0.95</span></span><span class="koboSpan" id="kobo.1257.1">)
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1258.1">'q99_roll_std_'</span></span><span class="koboSpan" id="kobo.1259.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1260.1">str</span></span><span class="koboSpan" id="kobo.1261.1">(windows)] = np.quantile(x_roll_std, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1262.1">0.99</span></span><span class="koboSpan" id="kobo.1263.1">)
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1264.1">'av_change_abs_roll_std_'</span></span><span class="koboSpan" id="kobo.1265.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1266.1">str</span></span><span class="koboSpan" id="kobo.1267.1">(windows)] = np.mean(np.diff(x_roll_std))
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1268.1">'av_change_rate_roll_std_'</span></span><span class="koboSpan" id="kobo.1269.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1270.1">str</span></span><span class="koboSpan" id="kobo.1271.1">(windows)] = np.mean(nonzero((np.diff(x_roll_std) / x_roll_std[:-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1272.1">1</span></span><span class="koboSpan" id="kobo.1273.1">]))[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1274.1">0</span></span><span class="koboSpan" id="kobo.1275.1">])
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1276.1">'abs_max_roll_std_'</span></span><span class="koboSpan" id="kobo.1277.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1278.1">str</span></span><span class="koboSpan" id="kobo.1279.1">(windows)] = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1280.1">abs</span></span><span class="koboSpan" id="kobo.1281.1">(x_roll_std).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1282.1">max</span></span><span class="koboSpan" id="kobo.1283.1">()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1284.1">For the features derived from the moving average mean, calculated for windows of 10, 100, and 1,000, the code is:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1285.1">for</span></span><span class="koboSpan" id="kobo.1286.1"> windows </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1287.1">in</span></span><span class="koboSpan" id="kobo.1288.1"> [</span><span class="hljs-number"><span class="koboSpan" id="kobo.1289.1">10</span></span><span class="koboSpan" id="kobo.1290.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1291.1">100</span></span><span class="koboSpan" id="kobo.1292.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1293.1">1000</span></span><span class="koboSpan" id="kobo.1294.1">]:
        x_roll_mean = xc.rolling(windows).mean().dropna().values
                
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1295.1">'ave_roll_mean_'</span></span><span class="koboSpan" id="kobo.1296.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1297.1">str</span></span><span class="koboSpan" id="kobo.1298.1">(windows)] = x_roll_mean.mean()
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1299.1">'std_roll_mean_'</span></span><span class="koboSpan" id="kobo.1300.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1301.1">str</span></span><span class="koboSpan" id="kobo.1302.1">(windows)] = x_roll_mean.std()
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1303.1">'max_roll_mean_'</span></span><span class="koboSpan" id="kobo.1304.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1305.1">str</span></span><span class="koboSpan" id="kobo.1306.1">(windows)] = x_roll_mean.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1307.1">max</span></span><span class="koboSpan" id="kobo.1308.1">()
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1309.1">'min_roll_mean_'</span></span><span class="koboSpan" id="kobo.1310.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1311.1">str</span></span><span class="koboSpan" id="kobo.1312.1">(windows)] = x_roll_mean.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1313.1">min</span></span><span class="koboSpan" id="kobo.1314.1">()
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1315.1">'q01_roll_mean_'</span></span><span class="koboSpan" id="kobo.1316.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1317.1">str</span></span><span class="koboSpan" id="kobo.1318.1">(windows)] = np.quantile(x_roll_mean, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1319.1">0.01</span></span><span class="koboSpan" id="kobo.1320.1">)
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1321.1">'q05_roll_mean_'</span></span><span class="koboSpan" id="kobo.1322.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1323.1">str</span></span><span class="koboSpan" id="kobo.1324.1">(windows)] = np.quantile(x_roll_mean, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1325.1">0.05</span></span><span class="koboSpan" id="kobo.1326.1">)
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1327.1">'q95_roll_mean_'</span></span><span class="koboSpan" id="kobo.1328.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1329.1">str</span></span><span class="koboSpan" id="kobo.1330.1">(windows)] = np.quantile(x_roll_mean, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1331.1">0.95</span></span><span class="koboSpan" id="kobo.1332.1">)
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1333.1">'q99_roll_mean_'</span></span><span class="koboSpan" id="kobo.1334.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1335.1">str</span></span><span class="koboSpan" id="kobo.1336.1">(windows)] = np.quantile(x_roll_mean, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1337.1">0.99</span></span><span class="koboSpan" id="kobo.1338.1">)
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1339.1">'av_change_abs_roll_mean_'</span></span><span class="koboSpan" id="kobo.1340.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1341.1">str</span></span><span class="koboSpan" id="kobo.1342.1">(windows)] = np.mean(np.diff(x_roll_mean))
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1343.1">'av_change_rate_roll_mean_'</span></span><span class="koboSpan" id="kobo.1344.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1345.1">str</span></span><span class="koboSpan" id="kobo.1346.1">(windows)] = np.mean(nonzero((np.diff(x_roll_mean) / x_roll_mean[:-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1347.1">1</span></span><span class="koboSpan" id="kobo.1348.1">]))[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1349.1">0</span></span><span class="koboSpan" id="kobo.1350.1">])
        X.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1351.1">'abs_max_roll_mean_'</span></span><span class="koboSpan" id="kobo.1352.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1353.1">str</span></span><span class="koboSpan" id="kobo.1354.1">(windows)] = np.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1355.1">abs</span></span><span class="koboSpan" id="kobo.1356.1">(x_roll_mean).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1357.1">max</span></span><span class="koboSpan" id="kobo.1358.1">()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1359.1">For each 150K-row segment generated</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.1360.1"> from the training data, we are calculating these features. </span><span class="koboSpan" id="kobo.1360.2">Then, the time to failure is selected as the value from the last row in the current segment:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1361.1"># iterate over all segments</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1362.1">for</span></span><span class="koboSpan" id="kobo.1363.1"> seg_id </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1364.1">in</span></span><span class="koboSpan" id="kobo.1365.1"> tqdm_notebook(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1366.1">range</span></span><span class="koboSpan" id="kobo.1367.1">(segments)):
    seg = train_df.iloc[seg_id*rows:seg_id*rows+rows]
    create_features(seg_id, seg, train_X)
    train_y.loc[seg_id, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1368.1">'time_to_failure'</span></span><span class="koboSpan" id="kobo.1369.1">] = seg[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1370.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1371.1">time_to_failure'</span></span><span class="koboSpan" id="kobo.1372.1">].values[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1373.1">1</span></span><span class="koboSpan" id="kobo.1374.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1375.1">Next, we are scaling all features using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1376.1">StandardScaler</span></code><span class="koboSpan" id="kobo.1377.1">. </span><span class="koboSpan" id="kobo.1377.2">This is not mandatory if we are using a model based on decision trees (such as random forest or XGBoost). </span><span class="koboSpan" id="kobo.1377.3">We include this step for a case where we would like to use other models, for example, one based on neural networks, where normalizing the features would be a necessary step:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1378.1">scaler = StandardScaler()
scaler.fit(train_X)
scaled_train_X = pd.DataFrame(scaler.transform(train_X), columns=train_X.columns)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1379.1">We repeat the same process for test data segments:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1380.1">for</span></span><span class="koboSpan" id="kobo.1381.1"> seg_id </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1382.1">in</span></span><span class="koboSpan" id="kobo.1383.1"> tqdm_notebook(test_X.index):
    seg = pd.read_csv(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1384.1">'../input/LANL-Earthquake-Prediction/test/'</span></span><span class="koboSpan" id="kobo.1385.1"> + seg_id + </span><span class="hljs-string"><span class="koboSpan" id="kobo.1386.1">'.csv'</span></span><span class="koboSpan" id="kobo.1387.1">)
    create_features(seg_id, seg, test_X)
scaled_test_X = pd.DataFrame(scaler.transform(test_X), columns=test_X.columns)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1388.1">After we analyzed the data, we generated</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.1389.1"> a set of engineered features. </span><span class="koboSpan" id="kobo.1389.2">We intend to use these features to build a baseline model. </span><span class="koboSpan" id="kobo.1389.3">Then, based on the model evaluation, we can further select what features to keep and, eventually, to create new features.</span></p>
<h1 class="heading-1" id="_idParaDest-123"><span class="koboSpan" id="kobo.1390.1">Building a baseline model</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1391.1">From the original temporal </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.1392.1">data, through feature engineering, we generated time-aggregated features for each time segment in the training data, equal in duration with one test set. </span><span class="koboSpan" id="kobo.1392.2">For the baseline model demonstrated in this competition, we chose </span><code class="inlineCode"><span class="koboSpan" id="kobo.1393.1">LGBMRegressor</span></code><span class="koboSpan" id="kobo.1394.1">, one of the best-performing algorithms at the time of the competition, which, in many cases, had a similar performance to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1395.1">XGBoost</span></code><span class="koboSpan" id="kobo.1396.1">. </span><span class="koboSpan" id="kobo.1396.2">The training data is split using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1397.1">KFold</span></code><span class="koboSpan" id="kobo.1398.1"> into five splits, and we run training and validation for each fold until we reach the final number of iterations or when the validation error ceases to improve after a specified number of steps (given by the </span><em class="italic"><span class="koboSpan" id="kobo.1399.1">patience</span></em><span class="koboSpan" id="kobo.1400.1"> parameter). </span><span class="koboSpan" id="kobo.1400.2">For each split, we then also run the prediction for the test set, with the best model – trained with the current train split for the current fold, that is, with 4/5 from the training set. </span><span class="koboSpan" id="kobo.1400.3">At the end, we will work out the average of the predictions obtained for each fold. </span><span class="koboSpan" id="kobo.1400.4">We can use this cross-validation approach because our data is no longer temporal (time-series) data. </span><span class="koboSpan" id="kobo.1400.5">We split the data into segments of 150K rows, of the same length as the test data, and then created aggregated features from this data:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1401.1">n_fold = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1402.1">5</span></span><span class="koboSpan" id="kobo.1403.1">
folds = KFold(n_splits=n_fold, shuffle=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1404.1">True</span></span><span class="koboSpan" id="kobo.1405.1">, random_state=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1406.1">42</span></span><span class="koboSpan" id="kobo.1407.1">)
train_columns = scaled_train_X.columns.values
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1408.1">The model parameters are given in the following code</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.1409.1"> excerpt. </span><span class="koboSpan" id="kobo.1409.2">We set some of the usual parameters</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.1410.1"> for LightGBM, as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1411.1">The number of leaves</span></strong><span class="koboSpan" id="kobo.1412.1">: This parameter controls the number of leaves (or terminal nodes) in each tree. </span><span class="koboSpan" id="kobo.1412.2">An increasing number of leaves allows the model to capture more complex patterns but also increases the risk of overfitting.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1413.1">Minimum data in leaf</span></strong><span class="koboSpan" id="kobo.1414.1">: If the number of samples in a leaf node is below this threshold, the node will not split. </span><span class="koboSpan" id="kobo.1414.2">This parameter helps control overfitting.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1415.1">The objective</span></strong><span class="koboSpan" id="kobo.1416.1">: This is regression for our model.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1417.1">Learning rate</span></strong><span class="koboSpan" id="kobo.1418.1">: This will control how fast the model learns.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1419.1">The boosting method</span></strong><span class="koboSpan" id="kobo.1420.1">: We can choose between gradient-boosted decision trees (</span><em class="italic"><span class="koboSpan" id="kobo.1421.1">gbdt</span></em><span class="koboSpan" id="kobo.1422.1">), dart gradient boosting (</span><em class="italic"><span class="koboSpan" id="kobo.1423.1">dgb</span></em><span class="koboSpan" id="kobo.1424.1">), and gradient-based one-side sampling (</span><em class="italic"><span class="koboSpan" id="kobo.1425.1">goss</span></em><span class="koboSpan" id="kobo.1426.1">). </span><span class="koboSpan" id="kobo.1426.2">We are using </span><em class="italic"><span class="koboSpan" id="kobo.1427.1">gbdt </span></em><span class="koboSpan" id="kobo.1428.1">here.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1429.1">The feature fraction</span></strong><span class="koboSpan" id="kobo.1430.1">: This is the percentage of features used in a subset of data presented to a tree within the tree ensemble employed by the algorithm.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1431.1">Bagging frequency, bagging fraction, and bagging seed</span></strong><span class="koboSpan" id="kobo.1432.1">: These control how we divide the sample set presented to the algorithm when we subsample it to present it to different trees.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1433.1">Metric</span></strong><span class="koboSpan" id="kobo.1434.1">: In this case, </span><em class="italic"><span class="koboSpan" id="kobo.1435.1">mae</span></em><span class="koboSpan" id="kobo.1436.1">, which is the mean absolute error.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1437.1">Regularization factor lambda_l1</span></strong></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1438.1">Verbosity</span></strong><span class="koboSpan" id="kobo.1439.1">: This parameter controls the amount of information the algorithm prints to the console during training. </span><span class="koboSpan" id="kobo.1439.2">A verbosity of 0 means silent mode (no information), while a verbosity of 1 prints messages about the training progress.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1440.1">Number of parallel processing threads</span></strong><span class="koboSpan" id="kobo.1441.1">: This parameter controls the number of parallel threads used by the algorithm during training.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1442.1">The randomization factor random_state</span></strong><span class="koboSpan" id="kobo.1443.1">: This parameter is the random seed used to initialize various</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.1444.1"> parameters of the algorithm.</span></li>
</ul>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1445.1">params = {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1446.1">'num_leaves'</span></span><span class="koboSpan" id="kobo.1447.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1448.1">51</span></span><span class="koboSpan" id="kobo.1449.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1450.1">'min_data_in_leaf'</span></span><span class="koboSpan" id="kobo.1451.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1452.1">10</span></span><span class="koboSpan" id="kobo.1453.1">, 
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1454.1">'objective'</span></span><span class="koboSpan" id="kobo.1455.1">:</span><span class="hljs-string"><span class="koboSpan" id="kobo.1456.1">'regression'</span></span><span class="koboSpan" id="kobo.1457.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1458.1">'max_depth'</span></span><span class="koboSpan" id="kobo.1459.1">: -</span><span class="hljs-number"><span class="koboSpan" id="kobo.1460.1">1</span></span><span class="koboSpan" id="kobo.1461.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1462.1">'learning_rate'</span></span><span class="koboSpan" id="kobo.1463.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1464.1">0.001</span></span><span class="koboSpan" id="kobo.1465.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1466.1">"boosting"</span></span><span class="koboSpan" id="kobo.1467.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1468.1">"gbdt"</span></span><span class="koboSpan" id="kobo.1469.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1470.1">"feature_fraction"</span></span><span class="koboSpan" id="kobo.1471.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1472.1">0.91</span></span><span class="koboSpan" id="kobo.1473.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1474.1">"bagging_freq"</span></span><span class="koboSpan" id="kobo.1475.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1476.1">1</span></span><span class="koboSpan" id="kobo.1477.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1478.1">"bagging_fraction"</span></span><span class="koboSpan" id="kobo.1479.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1480.1">0.91</span></span><span class="koboSpan" id="kobo.1481.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1482.1">"bagging_seed"</span></span><span class="koboSpan" id="kobo.1483.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1484.1">42</span></span><span class="koboSpan" id="kobo.1485.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1486.1">"metric"</span></span><span class="koboSpan" id="kobo.1487.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1488.1">'mae'</span></span><span class="koboSpan" id="kobo.1489.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1490.1">"lambda_l1"</span></span><span class="koboSpan" id="kobo.1491.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1492.1">0.1</span></span><span class="koboSpan" id="kobo.1493.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1494.1">"verbosity"</span></span><span class="koboSpan" id="kobo.1495.1">: -</span><span class="hljs-number"><span class="koboSpan" id="kobo.1496.1">1</span></span><span class="koboSpan" id="kobo.1497.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1498.1">"nthread"</span></span><span class="koboSpan" id="kobo.1499.1">: -</span><span class="hljs-number"><span class="koboSpan" id="kobo.1500.1">1</span></span><span class="koboSpan" id="kobo.1501.1">,
         </span><span class="hljs-string"><span class="koboSpan" id="kobo.1502.1">"random_state"</span></span><span class="koboSpan" id="kobo.1503.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1504.1">42</span></span><span class="koboSpan" id="kobo.1505.1">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1506.1">The code for training, validation, and testing (per fold) is shown</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.1507.1"> here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1508.1">oof = np.zeros(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1509.1">len</span></span><span class="koboSpan" id="kobo.1510.1">(scaled_train_X))
predictions = np.zeros(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1511.1">len</span></span><span class="koboSpan" id="kobo.1512.1">(scaled_test_X))
feature_importance_df = pd.DataFrame()
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1513.1">#run model</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1514.1">for</span></span><span class="koboSpan" id="kobo.1515.1"> fold_, (trn_idx, val_idx) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1516.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1517.1">enumerate</span></span><span class="koboSpan" id="kobo.1518.1">(folds.split(scaled_train_X,train_y.values)):
    strLog = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1519.1">"fold {}"</span></span><span class="koboSpan" id="kobo.1520.1">.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1521.1">format</span></span><span class="koboSpan" id="kobo.1522.1">(fold_)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1523.1">print</span></span><span class="koboSpan" id="kobo.1524.1">(strLog)
    
    X_tr, X_val = scaled_train_X.iloc[trn_idx], scaled_train_X.iloc[val_idx]
    y_tr, y_val = train_y.iloc[trn_idx], train_y.iloc[val_idx]
    model = lgb.LGBMRegressor(**params, n_estimators = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1525.1">20000</span></span><span class="koboSpan" id="kobo.1526.1">, n_jobs = -</span><span class="hljs-number"><span class="koboSpan" id="kobo.1527.1">1</span></span><span class="koboSpan" id="kobo.1528.1">)
    model.fit(X_tr, 
              y_tr, 
              eval_set=[(X_tr, y_tr), (X_val, y_val)], 
              eval_metric=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1529.1">'mae'</span></span><span class="koboSpan" id="kobo.1530.1">,
              verbose=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1531.1">1000</span></span><span class="koboSpan" id="kobo.1532.1">, 
              early_stopping_rounds=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1533.1">500</span></span><span class="koboSpan" id="kobo.1534.1">)
    oof[val_idx] = model.predict(X_val, num_iteration=model.best_iteration_)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1535.1">#feature importance</span></span><span class="koboSpan" id="kobo.1536.1">
    fold_importance_df = pd.DataFrame()
    fold_importance_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1537.1">"Feature"</span></span><span class="koboSpan" id="kobo.1538.1">] = train_columns
    fold_importance_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1539.1">"importance"</span></span><span class="koboSpan" id="kobo.1540.1">] = model.feature_importances_[:</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1541.1">len</span></span><span class="koboSpan" id="kobo.1542.1">(train_columns)]
    fold_importance_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1543.1">"fold"</span></span><span class="koboSpan" id="kobo.1544.1">] = fold_ + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1545.1">1</span></span><span class="koboSpan" id="kobo.1546.1">
    feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1547.1">0</span></span><span class="koboSpan" id="kobo.1548.1">)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1549.1">#predictions</span></span><span class="koboSpan" id="kobo.1550.1">
    predictions += model.predict(scaled_test_X, num_iteration=model.best_iteration_) / folds.n_splits
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1551.1">We initialize the prediction vector (which has the dimension of the submission file, that is, one entry for each test segment) with zeros. </span><span class="koboSpan" id="kobo.1551.2">We also initialize an out-of-folds vector (the length of the training data, which is the number of training segments).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1552.1">For each fold, we sample</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.1553.1"> subsets of data and target values for both the training and validation sets. </span><span class="koboSpan" id="kobo.1553.2">Then, we use them as input for the model, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1554.1">LGBMRegressor</span></code><span class="koboSpan" id="kobo.1555.1">, initialized with the model parameters defined before (we also add the number of estimators and the number of workers). </span><span class="koboSpan" id="kobo.1555.2">We fit the model with the subset of the training set corresponding to the current fold and validate it with the corresponding validation subset of the training data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1556.1">We set the evaluation metric as well: </span><em class="italic"><span class="koboSpan" id="kobo.1557.1">mae</span></em><span class="koboSpan" id="kobo.1558.1"> – meaning </span><em class="italic"><span class="koboSpan" id="kobo.1559.1">mean absolute error</span></em><span class="koboSpan" id="kobo.1560.1"> – the frequency for printing out the evaluation error, and the number of iterations for early stopping. </span><span class="koboSpan" id="kobo.1560.2">This parameter (number of iterations for early stopping) controls the number of steps that the algorithm waits before stopping, when the validation error does not improve during training. </span><span class="koboSpan" id="kobo.1560.3">We accumulate the validation results in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1561.1">oof</span></strong><span class="koboSpan" id="kobo.1562.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1563.1">out-of-folds</span></strong><span class="koboSpan" id="kobo.1564.1">) vector and concatenate the feature importance vector for the current fold to the feature importance DataFrame. </span><span class="koboSpan" id="kobo.1564.2">Early stopping is used to keep the best model for prediction – based on validation during training.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1565.1">Feature importance will be used to observe, during the iterative process of feature engineering, feature selection, and model training – if, for a model trained with certain features, the feature importance does not have a high variation between folds. </span><span class="koboSpan" id="kobo.1565.2">At each fold, we are also running a prediction for the entire test set, with the model trained and validated per fold. </span><span class="koboSpan" id="kobo.1565.3">Then, we increment the prediction vector with the values per fold, divided by the number of folds. </span><span class="koboSpan" id="kobo.1565.4">This is equivalent to a model ensemble, where each model is trained with a different subset of data, corresponding to each fold split.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1566.1">When evaluating the current model, we will examine three pieces of information: the training and validation errors, the variation of these errors across the folds, and the variation of feature importance between the folds. </span><span class="koboSpan" id="kobo.1566.2">Ideally, these variations – of training and validation errors across folds, as well as the feature importance variation across folds – are smaller. </span><em class="italic"><span class="koboSpan" id="kobo.1567.1">Figure 8.8</span></em><span class="koboSpan" id="kobo.1568.1"> shows the evaluation plots from the training of the baseline model.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1569.1">As you can see, we plot the training progress at every 1,000th step (verbosity set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1570.1">1000</span></code><span class="koboSpan" id="kobo.1571.1">), and implement an early stop at 500 (training stops if there’s no improvement in the validation error for the last 500 iterations). </span><span class="koboSpan" id="kobo.1571.2">The best model (in terms of validation error) is retained for predicting</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.1572.1"> from the test. </span><span class="koboSpan" id="kobo.1572.2">Test prediction is averaged over the five splits.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1573.1"><img alt="A screenshot of a computer program  Description automatically generated" src="../Images/B20963_08_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1574.1">Figure 8.8: Model training evaluation output – training and validation error</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.1575.1">Figure 8.9</span></em><span class="koboSpan" id="kobo.1576.1"> shows the feature importance graph, with the average value per fold and the standard deviation:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1577.1"><img alt="A colorful graph with numbers  Description automatically generated with medium confidence" src="../Images/B20963_08_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1578.1">Figure 8.9: Feature importance: average and standard deviation values (from values on the five folds) – top 20 features</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1579.1">After we performed data analysis, we proceeded with building time-aggregated features, on subsets of the training set with the same duration as the test sets. </span><span class="koboSpan" id="kobo.1579.2">With the new dataset formed with the engineered features, we trained a baseline model. </span><span class="koboSpan" id="kobo.1579.3">For the baseline model, we used cross-validation with five folds and used each fold model for the prediction of the test set. </span><span class="koboSpan" id="kobo.1579.4">The final prediction</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.1580.1"> was formed by averaging the predictions for each fold.</span></p>
<h1 class="heading-1" id="_idParaDest-124"><span class="koboSpan" id="kobo.1581.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1582.1">In this chapter, we delved into handling signal data, focusing particularly on audio signals. </span><span class="koboSpan" id="kobo.1582.2">We explored various storage formats for such data and examined libraries for loading, transforming, and visualizing this data type. </span><span class="koboSpan" id="kobo.1582.3">To develop potent features, we applied a range of signal-processing techniques. </span><span class="koboSpan" id="kobo.1582.4">Our feature engineering efforts transformed time-series data from each training segment and aggregated features for each test set. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1583.1">We consolidated all feature engineering processes into a single function, applicable to all training segments and test sets. </span><span class="koboSpan" id="kobo.1583.2">The transformed features underwent scaling. </span><span class="koboSpan" id="kobo.1583.3">We then used this prepared data to train a baseline model utilizing the LGBMRegressor algorithm. </span><span class="koboSpan" id="kobo.1583.4">This model employed cross-validation, and we generated predictions for the test set using the model trained in each fold. </span><span class="koboSpan" id="kobo.1583.5">Subsequently, we aggregated these predictions to create the submission file. </span><span class="koboSpan" id="kobo.1583.6">Additionally, we captured and visualized the feature importance for each fold.</span></p>
<h1 class="heading-1" id="_idParaDest-125"><span class="koboSpan" id="kobo.1584.1">References</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1585.1">LANL Earthquake Prediction, Can you predict upcoming laboratory earthquakes?, Kaggle Competition: </span><a href="https://www.kaggle.com/competitions/LANL-Earthquake-Prediction"><span class="url"><span class="koboSpan" id="kobo.1586.1">https://www.kaggle.com/competitions/LANL-Earthquake-Prediction</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1587.1">Gabriel Preda, LANL Earthquake EDA and Prediction: </span><a href="https://www.kaggle.com/code/gpreda/lanl-earthquake-eda-and-prediction"><span class="url"><span class="koboSpan" id="kobo.1588.1">https://www.kaggle.com/code/gpreda/lanl-earthquake-eda-and-prediction</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1589.1">LANL Earthquake Prediction, dataset description: </span><a href="https://www.kaggle.com/competitions/LANL-Earthquake-Prediction/data"><span class="url"><span class="koboSpan" id="kobo.1590.1">https://www.kaggle.com/competitions/LANL-Earthquake-Prediction/data</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1591.1">BirdCLEF 2021 - Birdcall Identification, identify bird calls in soundscape recordings, Kaggle competition: </span><a href="https://www.kaggle.com/competitions/birdclef-2021"><span class="url"><span class="koboSpan" id="kobo.1592.1">https://www.kaggle.com/competitions/birdclef-2021</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1593.1">McFee, Brian, Colin Raffel, Dawen Liang, Daniel PW Ellis, Matt McVicar, Eric Battenberg, and Oriol Nieto. </span><span class="koboSpan" id="kobo.1593.2">“librosa: Audio and music signal analysis in Python.” </span><span class="koboSpan" id="kobo.1593.3">In Proceedings of the 14th Python in Science Conference, pp. </span><span class="koboSpan" id="kobo.1593.4">18-25. </span><span class="koboSpan" id="kobo.1593.5">2015</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1594.1">librosa load function: </span><a href="https://librosa.org/doc/main/generated/librosa.load.html"><span class="url"><span class="koboSpan" id="kobo.1595.1">https://librosa.org/doc/main/generated/librosa.load.html</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1596.1">Cornell Birdcall Identification, Kaggle competition: </span><a href="https://www.kaggle.com/competitions/birdsong-recognition"><span class="url"><span class="koboSpan" id="kobo.1597.1">https://www.kaggle.com/competitions/birdsong-recognition</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1598.1">EarthData MERRA2 CO, Earth Data NASA Satellite Measurements, Kaggle dataset: </span><a href="https://www.kaggle.com/datasets/gpreda/earthdata-merra2-co"><span class="url"><span class="koboSpan" id="kobo.1599.1">https://www.kaggle.com/datasets/gpreda/earthdata-merra2-co</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1600.1">Gabriel Preda, EARTHDATA-MERRA2 Data Exploration, Kaggle Notebook: </span><a href="https://www.kaggle.com/code/gpreda/earthdata-merra2-data-exploration"><span class="url"><span class="koboSpan" id="kobo.1601.1">https://www.kaggle.com/code/gpreda/earthdata-merra2-data-exploration</span></span></a></li>
</ol>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1602.1">Join our book’s Discord space</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1603.1">Join our Discord community to meet like-minded people and learn alongside more than 5000 members at:</span></p>
<p class="normal"><a href="https://packt.link/kaggle"><span class="url"><span class="koboSpan" id="kobo.1604.1">https://packt.link/kaggle</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1605.1"><img alt="" role="presentation" src="../Images/QR_Code9220780366773140.png"/></span></p>
</div>
</body></html>