- en: Chapter 5. Speaking with Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 与应用程序对话
- en: In the previous chapter, we learned how to discover and understand the intent
    of a user, based on utterances. In this chapter, we will learn how to add audio
    capabilities to our applications, convert text to speech and speech to text, and
    learn how to identify the person speaking. Throughout this chapter, we will learn
    how you can utilize spoken audio to verify a person. Finally, we will briefly
    touch on how to customize speech recognition to make it unique for your application's
    usage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何根据话语发现和理解用户的意图。在本章中，我们将学习如何为我们的应用程序添加音频功能，将文本转换为语音和语音转换为文本，以及如何识别说话者。在本章中，我们将学习如何利用语音音频来验证一个人。最后，我们将简要介绍如何自定义语音识别，使其适用于您的应用程序的使用。
- en: 'By the end of this chapter, we will have covered the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将涵盖以下主题：
- en: Converting spoken audio to text and text to spoken audio
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将语音音频转换为文本和文本转换为语音音频
- en: Recognizing intent from spoken audio by utilizing LUIS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用LUIS识别语音音频中的意图
- en: Verifying that the speaker is who they claim to be
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证说话者是否为其声称的身份
- en: Identifying the speaker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别说话者
- en: Tailoring the Speaker Recognition API to recognize custom speaking styles and
    environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制说话者识别API以识别自定义说话风格和环境
- en: Converting text to audio and vice versa
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本到音频和音频到文本的转换
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Microsoft Cognitive
    Services"), *Getting Started with Microsoft Cognitive Services*, we utilized a
    part of the Bing Speech API. We gave the example application the ability to say
    sentences to us. We will use the code that we created in that example now, but
    we will dive a bit deeper into the details.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 使用Microsoft认知服务入门") *使用Microsoft认知服务入门* 中，我们使用了Bing Speech
    API的一部分。我们给了示例应用程序说句子的能力。现在我们将使用在那个示例中创建的代码，但我们将更深入地探讨细节。
- en: We will also go through the other feature of Bing Speech API, that is, converting
    spoken audio to text. The idea is that we can speak to the smart-house application,
    which will recognize what we are saying. Using the textual output, the application
    will use LUIS to gather the intent of our sentence. If LUIS needs more information,
    the application will politely ask us for more via audio.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍Bing Speech API的另一个功能，即将语音音频转换为文本。想法是我们可以对智能屋应用程序说话，该应用程序将识别我们在说什么。使用文本输出，应用程序将使用LUIS来收集我们句子的意图。如果LUIS需要更多信息，应用程序将通过音频礼貌地要求我们提供更多信息。
- en: To get started, we want to modify the build definition of the smart-house application.
    We need to specify whether we are running it on a 32-bit or 64-bit OS. To utilize
    speech-to-text conversion, we want to install the Bing Speech NuGet client package.
    Search for `Microsoft.ProjectOxford.SpeechRecognition` and install either the
    32-bit version or the 64-bit version, depending on your system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们希望修改智能屋应用程序的构建定义。我们需要指定我们是在32位还是64位操作系统上运行它。为了利用语音到文本转换，我们希望安装Bing Speech
    NuGet客户端包。搜索 `Microsoft.ProjectOxford.SpeechRecognition` 并根据您的系统安装32位版本或64位版本。
- en: Further on, we need to add references to `System.Runtime.Serialization` and
    `System.Web`. These are needed so that we are able to make web requests and deserialize
    response data from the APIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，我们需要添加对 `System.Runtime.Serialization` 和 `System.Web` 的引用。这些引用是必要的，以便我们能够进行网络请求并反序列化来自API的响应数据。
- en: Speaking to the application
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与应用程序对话
- en: Add a new file to the `Model` folder, called `SpeechToText.cs`. Beneath the
    automatically created `SpeechToText` class, we want to add an `enum` type variable
    called `SttStatus`. It should have two values, `Success` and `Error`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Model` 文件夹中添加一个新文件，命名为 `SpeechToText.cs`。在自动创建的 `SpeechToText` 类下面，我们希望添加一个名为
    `SttStatus` 的 `enum` 类型变量。它应该有两个值，`Success` 和 `Error`。
- en: 'In addition, we want to define an `EventArgs` class for events that we will
    raise during execution. Add the following class at the bottom of the file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望定义一个用于我们在执行期间将引发的事件的 `EventArgs` 类。在文件底部添加以下类：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the `event` argument will hold the operation status, a message
    of any kind, and a list of strings. This will be a list with potential speech-to-text
    conversions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`event` 参数将包含操作状态、任何类型的消息以及一个字符串列表。这将是一个包含潜在语音到文本转换的列表。
- en: The `SpeechToText` class needs to implement `IDisposable`. This is done so that
    we can clean up the resources used for recording spoken audio and shut down the
    application properly. We will add the details presently, so for now, just make
    sure to add the `Dispose` function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpeechToText` 类需要实现 `IDisposable`。这样做是为了我们可以清理用于记录语音音频的资源并正确关闭应用程序。我们将在稍后添加详细信息，所以现在只需确保添加
    `Dispose` 函数。'
- en: 'Now, we need to define a few private members in the class, as well as an event:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在类中定义一些私有成员，以及一个事件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `OnSttStatusUpdated` event will be triggered whenever we have a new operation
    status. `DataRecognitionClient` and `MicrophoneRecognitionClient` are the two
    objects that we can use to call the Bing Speech API. We will look at how they
    are created presently.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有新的操作状态时，`OnSttStatusUpdated` 事件将被触发。`DataRecognitionClient` 和 `MicrophoneRecognitionClient`
    是我们可以用来调用 Bing 语音 API 的两个对象。我们将现在看看它们是如何创建的。
- en: We define `SpeechRecognitionMode` as `ShortPhrase`. This means that we do not
    expect any spoken sentences longer than 15 seconds. The alternative is `LongDictation`,
    which means that we can convert spoken sentences to be up to 2 minutes long.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `SpeechRecognitionMode` 定义为 `ShortPhrase`。这意味着我们不会期望任何超过 15 秒的语音句子。另一种选择是
    `LongDictation`，这意味着我们可以将语音句子转换成长达 2 分钟的长度。
- en: Finally, we specify the language to be English, and define a `bool` type variable,
    which indicates whether or not we are currently recording anything.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指定语言为英语，并定义一个 `bool` 类型的变量，该变量表示我们是否正在记录任何内容。
- en: 'In our constructor, we accept the Bing Speech API key as a parameter. We will
    use this in the creation of our API clients:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们接受 Bing 语音 API 密钥作为参数。我们将在创建我们的 API 客户端时使用它：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we create both `_dataRecClient` and `_micRecClient` by calling
    `SpeechRecognitionServiceFactory`. For the first client, we state that we want
    to use intent recognition as well. The parameters required are the language, Bing
    API key, the LUIS app ID, and the LUIS API key. By using a `DataRecognitionClient`
    object, we can upload audio files with speech.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过调用 `SpeechRecognitionServiceFactory` 创建了 `_dataRecClient` 和 `_micRecClient`。对于第一个客户端，我们声明我们想要使用意图识别。所需的参数包括语言、Bing
    API 密钥、LUIS 应用 ID 和 LUIS API 密钥。通过使用 `DataRecognitionClient` 对象，我们可以上传带有语音的音频文件。
- en: By using `MicrophoneRecognitionClient`, we can use a microphone for real-time
    conversion. For this, we do not want intent detection, so we call `CreateMicrophoneClient`.
    In this case, we only need to specify the speech mode, the language, and the Bing
    Speech API key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `MicrophoneRecognitionClient`，我们可以使用麦克风进行实时转换。为此，我们不想进行意图检测，因此调用 `CreateMicrophoneClient`。在这种情况下，我们只需要指定语音模式、语言和
    Bing 语音 API 密钥。
- en: 'Before leaving the constructor, we call the `Initialize` function. In this,
    we subscribe to certain events on each of the clients:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开构造函数之前，我们调用 `Initialize` 函数。在这个函数中，我们为每个客户端订阅某些事件：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, there are quite a few similarities between the two clients.
    The two differences are that `_dataRecClient` will get intents through the `OnIntent`
    event, and `_micRecClient` will get the microphone status through the `OnMicrophoneStatus`
    event.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个客户端之间有很多相似之处。两个不同之处在于 `_dataRecClient` 将通过 `OnIntent` 事件获取意图，而 `_micRecClient`
    将通过 `OnMicrophoneStatus` 事件获取麦克风状态。
- en: 'We do not really care about partial responses. However, they may be useful
    in some cases, as they will continuously give the currently completed conversion:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不真正关心部分响应。然而，在某些情况下，它们可能很有用，因为它们将连续给出当前完成的转换：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For our application, we will choose to output it to the debug console window.
    In this case, `PartialResult` is a string with the partially converted text:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，我们将选择将其输出到调试控制台窗口。在这种情况下，`PartialResult` 是一个包含部分转换文本的字符串：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We do not care about the current microphone status, either. Again, we output
    the status to the debug console window.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不关心当前的麦克风状态。同样，我们将状态输出到调试控制台窗口。
- en: Before moving on, add a helper function, called `RaiseSttStatusUpdated`. This
    should raise `OnSttStatusUpdated` when called.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，添加一个名为 `RaiseSttStatusUpdated` 的辅助函数。当被调用时，它应该引发 `OnSttStatusUpdated`。
- en: 'When we are calling `_dataRecClient`, we may recognize intents from LUIS. In
    these cases, we want to raise an event, where we output the recognized intent.
    This is done with the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `_dataRecClient` 时，我们可能会从 LUIS 识别意图。在这些情况下，我们想要引发一个事件，其中输出识别到的意图。这是通过以下代码完成的：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We choose to print out intent information and the `Payload`. This is a string
    containing recognized entities, intents, and actions that are triggered from LUIS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择打印出意图信息和`Payload`。这是一个包含从LUIS触发的识别实体、意图和动作的字符串。
- en: 'If any errors occur during the conversion, there are several things we will
    want to do. First and foremost, we want to stop any microphone recordings that
    may be running. There is really no point in trying to convert more in the current
    operation if it has failed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换过程中发生任何错误，我们将想要做几件事情。首先，我们想要停止可能正在运行的任何麦克风录音。如果当前操作失败，尝试转换更多内容实际上是没有意义的：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will create `StopMicRecording` presently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即创建`StopMicRecording`。
- en: 'In addition, we want to notify any subscribers that the conversion failed.
    In such cases, we want to give details about error codes and error messages:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们想要通知任何订阅者转换失败。在这种情况下，我们想要提供有关错误代码和错误消息的详细信息：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `OnConversationError` event does, fortunately, provide us with detailed
    information about any errors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`OnConversationError`事件为我们提供了关于任何错误的详细信息。
- en: 'Now, let''s look at the `StopMicRecording` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`StopMicRecording`方法：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a simple function that calls `EndMicAndRecognition` on the `_micRecClient
    MicrophoneRecognitionClient` object. When this is called, we stop the client from
    recording.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，它会在`_micRecClient MicrophoneRecognitionClient`对象上调用`EndMicAndRecognition`。当这个函数被调用时，我们将停止客户端的录音。
- en: The final event handler that we need to create is the `OnResponseReceived` handler.
    This will be triggered whenever we receive a complete, converted response from
    the service.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个事件处理程序是`OnResponseReceived`处理程序。这将在我们从服务接收到完整、转换后的响应时被触发。
- en: 'Again, we want to make sure we do not record any more if we are currently recording:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果我们正在录音，我们想要确保不再记录任何内容：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `SpeechResponseEventArgs` argument contains a `PhraseResponse` object.
    This contains an array of `RecognizedPhrase`, which we want to access. Each item
    in this array contains the confidence of correct conversion. It also contains
    the converted phrases as `DisplayText`. This uses inverse text normalization,
    proper capitalization, and punctuation, and it masks profanities with asterisks:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpeechResponseEventArgs`参数包含一个`PhraseResponse`对象。它包含一个`RecognizedPhrase`数组，我们想要访问。数组中的每个项目都包含正确转换的置信度。它还包含作为`DisplayText`的转换后的短语。这使用逆文本归一化、正确的首字母大小写和标点符号，并用星号屏蔽亵渎性词汇：'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We may also get the converted phrases in other formats, as described in the
    following table:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还会以以下表格中描述的其他格式获得转换后的短语：
- en: '| Format | Description |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 格式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LexicalForm` | This is the raw, unprocessed recognition result. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `LexicalForm` | 这是原始的、未经处理的识别结果。|'
- en: '| `InverseTextNormalizationResult` | This displays phrases such as *one two
    three four* as *1234*, so it is ideal for usages such as *go to second street*.
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `InverseTextNormalizationResult` | 这将短语如*one two three four*显示为*1234*，因此它非常适合像*go
    to second street*这样的用途。|'
- en: '| `MaskedInverseTextNormalizationResult` | Inverse text normalization and the
    profanity mask. No capitalization or punctuation is applied. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `MaskedInverseTextNormalizationResult` | 逆文本归一化和亵渎性屏蔽。不应用首字母大小写或标点符号。|'
- en: 'For our use, we are just interested in the `DisplayText`. With a populated
    list of recognized phrases, we raise the status update event:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的使用，我们只对`DisplayText`感兴趣。有了识别短语列表，我们将引发状态更新事件：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To be able to use this class, we need a couple of public functions so that
    we can start speech recognition:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用这个类，我们需要几个公共函数，这样我们就可以开始语音识别：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `StartMicToText` method will call the `StartMicAndRecognition` method on
    the `_micRecClient` object. This will allow us to use the microphone to convert
    spoken audio. This function will be our main way of accessing this API:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartMicToText`方法将在`_micRecClient`对象上调用`StartMicAndRecognition`方法。这将允许我们使用麦克风将语音音频转换。这个函数将成为我们访问此API的主要方式：'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second function will require a filename for the audio file, with the audio
    we want to convert. We open the file, with read access, and are ready to read
    it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数将需要一个音频文件的文件名，这是我们想要转换的音频。我们以读取权限打开文件，并准备好读取它：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As long as we have data available, we read from the file. We will fill up the
    `buffer`, and call the `SendAudio` method. This will then trigger a recognition
    operation in the service.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们有可用数据，我们就从文件中读取。我们将填充`buffer`，并调用`SendAudio`方法。这将触发服务中的识别操作。
- en: 'If any exceptions occur, we make sure to output the exception message to a
    debug window. Finally, we need to call the `EndAudio` method so that the service
    does not wait for any more data:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生任何异常，我们确保将异常消息输出到调试窗口。最后，我们需要调用`EndAudio`方法，以便服务不等待任何更多数据：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before leaving this class, we need to dispose of our API clients. Add the following
    in the `Dispose` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开这个班级之前，我们需要处理我们的API客户端。在`Dispose`函数中添加以下内容：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We stop microphone recording, unsubscribe from all events, and dispose and clear
    the client objects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们停止麦克风录音，取消订阅所有事件，并销毁和清除客户端对象。
- en: Make sure that the application compiles before moving on. We will look at how
    to use this class presently.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在继续之前应用程序已经编译。我们现在将探讨如何使用这个类。
- en: Letting the application speak back
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许应用程序进行语音反馈
- en: We have already seen how to make the application speak back to us. We are going
    to use the same classes we created in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Microsoft Cognitive Services"), *Getting Started with Microsoft Cognitive
    Services*. Copy `Authentication.cs` and `TextToSpeech.cs` from the example project
    from [Chapter 1](ch01.html "Chapter 1. Getting Started with Microsoft Cognitive
    Services"), *Getting Started with Microsoft Cognitive Services,* into the `Model`
    folder. Make sure that the namespaces are changed accordingly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使应用程序对我们说话。我们将使用我们在[第1章](ch01.html "第1章。使用Microsoft认知服务入门")中创建的相同类，*使用Microsoft认知服务入门*。从[第1章](ch01.html
    "第1章。使用Microsoft认知服务入门")的示例项目中复制`Authentication.cs`和`TextToSpeech.cs`到`Model`文件夹中。确保相应地更改命名空间。
- en: As we have been through the code already, we will not go through it again. We
    will instead look at some of the details left out in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Microsoft Cognitive Services"), *Getting Started with Microsoft Cognitive
    Services*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经通过了代码，我们不会再次进行审查。相反，我们将查看[第1章](ch01.html "第1章。使用Microsoft认知服务入门")中省略的一些细节，*使用Microsoft认知服务入门*。
- en: Audio output format
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频输出格式
- en: 'The audio output format can be one of the following formats:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 音频输出格式可以是以下格式之一：
- en: '`raw-8khz-8bit-mono-mulaw`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raw-8khz-8bit-mono-mulaw`'
- en: '`raw-16khz-16bit-mono-pcm`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raw-16khz-16bit-mono-pcm`'
- en: '`riff-8khz-8bit-mono-mulaw`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`riff-8khz-8bit-mono-mulaw`'
- en: '`riff-16khz-16bit-mono-pcm`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`riff-16khz-16bit-mono-pcm`'
- en: Error codes
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误代码
- en: 'There are four possible error codes that can occur in calls to the API. These
    are described in the following table:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用API时可能会出现四种可能的错误代码。这些代码在以下表格中描述：
- en: '| Code | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `400 / BadRequest` | A required parameter is missing, empty, or null. Alternatively,
    a parameter is invalid. An example may be a string that''s longer than the allowed
    length. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `400 / BadRequest` | 缺少必需的参数，为空或为null。或者，参数无效。一个例子可能是一个超过允许长度的字符串。 |'
- en: '| `401 / Unauthorized` | The request is not authorized. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `401 / Unauthorized` | 请求未授权。 |'
- en: '| `413 / RequestEntityTooLarge` | The SSML input is larger than what''s supported.
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `413 / RequestEntityTooLarge` | SSML输入大于支持的大小。 |'
- en: '| `502 / BadGateway` | A network-related or server-related issue. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `502 / BadGateway` | 与网络或服务器相关的问题。 |'
- en: Supported languages
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持的语言
- en: 'The following languages are supported:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下语言：
- en: English (Australia), English (United Kingdom), English (United States), English
    (Canada), English (India), Spanish, Mexican Spanish, German, Arabic (Egypt), French,
    Canadian French, Italian, Japanese, Portuguese, Russian, Chinese (S), Chinese
    (Hong Kong), and Chinese (T).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 英语（澳大利亚），英语（英国），英语（美国），英语（加拿大），英语（印度），西班牙语，墨西哥西班牙语，德语，阿拉伯语（埃及），法语，加拿大法语，意大利语，日语，葡萄牙语，俄语，中文（简体），中文（香港），中文（繁体）。
- en: Utilizing LUIS based on spoken commands
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于语音命令利用LUIS
- en: To utilize the features that we have just added, we are going to modify `LuisView`
    and `LuisViewModel`. Add a new `Button` in the View, which will make sure that
    we record commands. Add a corresponding `ICommand` in the ViewModel.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用我们刚刚添加的功能，我们将修改`LuisView`和`LuisViewModel`。在视图中添加一个新的`Button`，这将确保我们记录命令。在视图模型中添加相应的`ICommand`。
- en: 'We also need to add a few more members to the class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向类中添加一些其他成员：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first two will be used to convert between spoken audio and text. The third
    is the API key for the Bing Speech API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个将用于将语音音频和文本之间进行转换。第三个是Bing语音API的API密钥。
- en: Make the ViewModel implement `IDisposable`, and explicitly dispose the `SpeechToText`
    object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让视图模型实现`IDisposable`，并显式销毁`SpeechToText`对象。
- en: 'Create the objects by adding the following in the constructor:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在构造函数中添加以下内容来创建对象：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will create the client objects and subscribe to the required events. Finally,
    it will call a function to generate authentication tokens for the REST API calls.
    This function should look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建客户端对象并订阅所需的事件。最后，它将调用一个函数来生成用于 REST API 调用的身份验证令牌。此函数应如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we receive any errors from `_ttsClient`, we want to output it to the debug
    console:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 `_ttsClient` 收到任何错误，我们希望将其输出到调试控制台：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We do not need to output this to the UI, as this is a nice-to-have feature.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将此输出到 UI，因为这只是一个可选功能。
- en: 'If we have audio available, we want to make sure that we play it. We do so
    by creating a `SoundPlayer` object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有音频可用，我们想确保播放它。我们通过创建一个 `SoundPlayer` 对象来实现这一点：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using the audio stream we got from the event arguments, we can play the audio
    to the user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从事件参数中获得的音频流，我们可以播放音频给用户。
- en: If we have a status update from `_sttClient`, we want to display this in the
    textbox.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到 `_sttClient` 的状态更新，我们想在文本框中显示此信息。
- en: 'If we have successfully recognized spoken audio, we want to show the `Message`
    string if it is available:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功识别了语音音频，我们希望显示可用的 `Message` 字符串：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also want to show all recognized phrases. Using the first available phrase,
    we make a call to LUIS:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望显示所有识别出的短语。使用第一个可用的短语，我们调用 LUIS：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the recognition failed, we print out any error messages that we may have.
    Finally, we make sure that the `ResultText` is updated with the new data:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果识别失败，我们打印出可能有的任何错误消息。最后，我们确保 `ResultText` 被更新为新的数据：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The newly created `ICommand` needs to have a function to start the recognition
    process:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的 `ICommand` 需要一个启动识别过程的功能：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The function starts the microphone recording.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始麦克风录音。
- en: 'Finally, we need to make some modifications to `OnLuisUtteranceResultUpdated`.
    Make the following modifications, where we output any `DialogResponse`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对 `OnLuisUtteranceResultUpdated` 进行一些修改。进行以下修改，其中我们输出任何 `DialogResponse`：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will play the `DialogResponse` if it exists. The application will ask you
    for more information if required. It will then start the recording, so we can
    answer without clicking any buttons.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在 `DialogResponse`，这将播放它。如果需要，应用程序将要求您提供更多信息。然后它将开始录音，这样我们就可以在不点击任何按钮的情况下回答。
- en: If no `DialogResponse` exists, we simply make the application say the summary
    to us. This will contain data on intents, entities, and actions from LUIS.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在 `DialogResponse`，我们只需让应用程序向我们说出摘要。这将包含来自 LUIS 的意图、实体和动作数据。
- en: Knowing who is speaking
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知道谁在说话
- en: Using the **Speaker Recognition** API, we can identify who is speaking. By defining
    one or more speaker profiles with corresponding samples, we can identify whether
    any of them are speaking at any time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **说话人识别** API，我们可以识别正在说话的人。通过定义一个或多个带有相应样本的说话人配置文件，我们可以识别在任何时候是否有任何人在说话。
- en: 'To be able to utilize this feature, we need to go through a few steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够利用此功能，我们需要进行几个步骤：
- en: We need to add one or more speaker profiles to the service.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向服务添加一个或多个说话人配置文件。
- en: Each speaker profile enrolls several spoken samples.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个说话人配置文件注册了几个语音样本。
- en: We call the service to identify a speaker based on audio input.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用服务以根据音频输入识别说话人。
- en: If you have not already done so, sign up for an API key for the Speaker Recognition
    API at [https://portal.azure.com](https://portal.azure.com).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请在 [https://portal.azure.com](https://portal.azure.com) 为说话人识别 API
    注册一个 API 密钥。
- en: Start by adding a new NuGet package to your smart-house application. Search
    for and add `Microsoft.ProjectOxford.SpeakerRecognition`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向您的智能屋应用程序添加一个新的 NuGet 包。搜索并添加 `Microsoft.ProjectOxford.SpeakerRecognition`。
- en: Add a new class called `SpeakerIdentification` to the `Model` folder of your
    project. This class will hold all of the functionality related to speaker identification.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目 `Model` 文件夹中添加一个名为 `SpeakerIdentification` 的新类。此类将包含与说话人识别相关的所有功能。
- en: 'Beneath the class, we will add another class, containing `EventArgs` for status
    updates:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在类别下方，我们将添加另一个类别，包含用于状态更新的 `EventArgs`：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The two first properties should be self-explanatory. The last one, `IdentificationProfile`,
    will hold the results of a successful identification process. We will look at
    what information this contains presently.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个属性应该是显而易见的。最后一个，`IdentificationProfile`，将包含成功识别过程的结果。我们将现在查看它包含哪些信息。
- en: 'We also want to send events for errors, so let''s add an `EventArgs` class
    for the required information:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望发送错误事件，因此让我们添加一个`EventArgs`类来存储所需的信息：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, the property should be self-explanatory.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，属性应该是自解释的。
- en: 'In the `SpeakerIdentification` class, add two events and one private member
    at the top of the class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SpeakerIdentification`类中，在类顶部添加两个事件和一个私有成员：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The events will be triggered if we have any status updates, a successful identification,
    or errors. The `ISpeakerIdentificationServiceClient` object is the access point
    for the Speaker Recognition API. Inject this object through the constructor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有任何状态更新、成功识别或错误，事件将被触发。`ISpeakerIdentificationServiceClient`对象是访问演讲者识别API的入口点。通过构造函数注入此对象。
- en: To make it easier to raise events, add two helper functions, one for each event.
    Call these `RaiseOnIdentificationStatusUpdated` and `RaiseOnIdentificationError`.
    They should accept the corresponding `EventArgs` object as a parameter and trigger
    the corresponding event.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易触发事件，添加两个辅助函数，每个事件一个。将这些函数命名为`RaiseOnIdentificationStatusUpdated`和`RaiseOnIdentificationError`。它们应该接受相应的`EventArgs`对象作为参数并触发相应的事件。
- en: Adding speaker profiles
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加演讲者配置文件
- en: To be able to identify speakers, we need to add profiles. Each profile can be
    seen as a unique person who we can identify later.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够识别演讲者，我们需要添加配置文件。每个配置文件可以看作是一个独特的人，我们可以在以后识别。
- en: At the time of writing, each subscription allows for 1,000 speaker profiles
    to be created. This also includes profiles that are created for verification,
    which we will look at presently.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，每个订阅允许创建1,000个演讲者配置文件。这还包括为验证创建的配置文件，我们将在下面查看。
- en: To facilitate creating profiles, we need to add some elements to our `AdministrationView`
    and `AdministrationViewModel` properties, so open these files.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于创建配置文件，我们需要向我们的`AdministrationView`和`AdministrationViewModel`属性中添加一些元素，因此请打开这些文件。
- en: In the View, add a new button for adding speaker profiles. Also, add a list
    box, which will show all of our profiles. How you lay out the UI is up to you.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，添加一个用于添加演讲者配置文件的新按钮。还要添加一个列表框，它将显示所有我们的配置文件。如何布局UI取决于你。
- en: The ViewModel will need a new `ICommand` property for the button. It will also
    need an `ObservableObject` property for our profile list; make sure it is of type
    `Guid`. We will also need to be able to select a profile, so add a `Guid` property
    for the selected profile.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel需要一个新`ICommand`属性用于按钮。它还需要一个`ObservableObject`属性用于我们的配置文件列表；确保它是`Guid`类型。我们还需要能够选择一个配置文件，因此添加一个用于所选配置文件的`Guid`属性。
- en: 'Additionally, we need to add a new member to the ViewModel:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要向ViewModel添加一个新成员：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the reference to the class we created earlier. Create this object in
    the constructor, passing on an `ISpeakerIdentificationServiceClient` object, which
    you inject via the ViewModel''s constructor. In the constructor, you should also
    subscribe to the events we created:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前创建的类的引用。在构造函数中创建此对象，传递一个`ISpeakerIdentificationServiceClient`对象，该对象通过ViewModel的构造函数注入。在构造函数中，你还应该订阅我们创建的事件：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Basically, we want both event handles to update the status text with the message
    they carry:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们希望两个事件处理程序都更新状态文本，以包含它们携带的消息：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code is for `OnSpeakerIdentificationStatusUpdated`. The same should
    be used for `OnSpeakerIdentificationError`, but set `StatusText` to be `e.ErrorMessage`
    instead.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是用于`OnSpeakerIdentificationStatusUpdated`的。对于`OnSpeakerIdentificationError`也应使用相同的代码，但将`StatusText`设置为`e.ErrorMessage`。
- en: 'In the function created for our `ICommand` property, we do the following to
    create a new profile:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的`ICommand`属性创建的函数中，我们执行以下操作以创建一个新的配置文件：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We make a call to our `_speakerIdentification` object''s `CreateSpeakerProfile`
    function. This function will return a `Guid`, which is the unique ID of that speaker.
    In our example, we do not do anything further with this. In a real-life application,
    I would recommend mapping this ID to a name in some way. As you will see presently,
    identifying people through GUIDs is for machines, not people:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用我们的`_speakerIdentification`对象的`CreateSpeakerProfile`函数。此函数将返回一个`Guid`，这是该演讲者的唯一ID。在我们的示例中，我们不做任何进一步的操作。在实际应用中，我建议以某种方式将此ID映射到名称。正如你将看到的，通过GUID识别人是为机器，而不是人：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We finish this function by calling a `GetSpeakerProfile` function, which we
    will create next. This will fetch a list of all the profiles we have created so
    that we can use these throught the further process:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用我们将在下面创建的`GetSpeakerProfile`函数来完成此函数。这将获取我们创建的所有配置文件的列表，以便我们可以在后续过程中使用这些信息：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In our `GetSpeakerProfiles` function, we call `ListSpeakerProfiles` on our
    `_speakerIdentification` object. This will, as we will see presently, fetch a
    list of GUIDs, containing the profile IDs. If this list is null, there is no point
    in moving on:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `GetSpeakerProfiles` 函数中，我们在 `_speakerIdentification` 对象上调用 `ListSpeakerProfiles`。这将，正如我们目前所看到的，获取一个包含资料
    ID 的 GUID 列表。如果这个列表为空，就没有继续的必要：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the list does contain anything, we add these IDs to our `SpeakerProfiles`,
    which is the `ObservableCollection` property. This will show all of our profiles
    in the UI.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中包含任何内容，我们将这些 ID 添加到我们的 `SpeakerProfiles` 中，这是一个 `ObservableCollection`
    属性。这将显示我们所有的资料在 UI 中。
- en: This function should also be called from the `Initialize` function, so we populate
    the list when we start the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数也应从 `Initialize` 函数中调用，因此我们在启动应用程序时填充列表。
- en: 'Back in the `SpeakerIdentification` class, create a new function called `CreateSpeakerProfile`.
    This should have the return type `Task<Guid>` and be marked as `async`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SpeakerIdentification` 类中，创建一个名为 `CreateSpeakerProfile` 的新函数。这个函数应该有 `Task<Guid>`
    返回类型，并标记为 `async`：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will then make a call to `CreateProfileAsync` on the API object. We need
    to specify the locale, which is used for the speaker profile. At the time of writing,
    `en-US` is the only valid option.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将对 API 对象调用 `CreateProfileAsync`。我们需要指定用于演讲者资料的区域设置。在编写本文时，`en-US` 是唯一有效的选项。
- en: 'If the call is successful, we get a `CreateProfileResponse` object in response.
    This contains the ID of the newly created speaker profile:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，我们将收到一个 `CreateProfileResponse` 对象作为响应。这个对象包含新创建的演讲者资料的 ID：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the `response` is null, we raise an error event. If it contains data, we
    return the `ProfileId` to the caller.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `response` 为空，我们引发一个错误事件。如果它包含数据，我们将返回 `ProfileId` 给调用者。
- en: Add the corresponding `catch` clause to finish the function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 添加相应的 `catch` 子句以完成函数。
- en: 'Create a new function called `ListSpeakerProfile`. This should return `Task<List<Guid>>`
    and be marked as `async`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `ListSpeakerProfile` 的新函数。这个函数应该返回 `Task<List<Guid>>` 并标记为 `async`：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will then create a list of type `Guid`, which is the list of speaker profiles
    we will return. Then, we call the `GetProfilesAsync` method on our `_speakerIdentificationClient`
    object. This will get us an array of type `Profile`, which contains information
    on each profile. This is information such as creation time, enrollment status,
    last modified, and so on. We are interested in the IDs of each profile:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个类型为 `Guid` 的列表，这是我们将要返回的演讲者资料列表。然后，我们在 `_speakerIdentificationClient`
    对象上调用 `GetProfilesAsync` 方法。这将给我们一个类型为 `Profile` 的数组，其中包含每个资料的信息。这些信息包括创建时间、注册状态、最后修改等。我们感兴趣的是每个资料的
    ID：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If any profiles are returned, we loop through the array and add each `profileId`
    to the previously created list. This list is then returned to the caller, which
    in our case will be the ViewModel.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回任何资料，我们将遍历数组，并将每个 `profileId` 添加到之前创建的列表中。然后，将此列表返回给调用者，在我们的例子中将是 ViewModel。
- en: End the function with the corresponding `catch` clause. Make sure that the code
    compiles and executes as expected before continuing. This means that you should
    now be able to add speaker profiles to the service and get the created profiles
    displayed in the UI.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相应的 `catch` 子句结束函数。在继续之前，确保代码能够编译并按预期执行。这意味着你现在应该能够将演讲者资料添加到服务中，并在 UI 中显示创建的资料。
- en: 'To delete a speaker profile, we will need to add a new function to `SpeakerIdentification`.
    Call this function `DeleteSpeakerProfile`, and let it accept a `Guid` as its parameter.
    This will be the ID of the given profile we want to delete. Mark the function
    as `async`. The function should look as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除演讲者资料，我们需要在 `SpeakerIdentification` 中添加一个新函数。将此函数命名为 `DeleteSpeakerProfile`，并让它接受一个
    `Guid` 作为其参数。这将是我们想要删除的给定资料的 ID。将函数标记为 `async`。函数看起来应该如下所示：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the call to the `DeleteProfileAsync` method expects a `Guid`
    type, `profileId`. There is no return value and, as such, when we call this function,
    we need to call the `GetSpeakerProfile` method in our ViewModel.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用 `DeleteProfileAsync` 方法期望一个 `Guid` 类型的 `profileId`。没有返回值，因此当我们调用此函数时，我们需要在我们的
    ViewModel 中调用 `GetSpeakerProfile` 方法。
- en: To facilitate the deletion of speaker profiles, add a new button to the UI and
    a corresponding `ICommand` property in the ViewModel.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于删除演讲者资料，向 UI 添加一个新按钮，并在 ViewModel 中添加相应的 `ICommand` 属性。
- en: Enrolling a profile
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册个人资料
- en: With a speaker profile in place, we need to associate spoken audio with the
    profile. We do this through a process called **enrolling**. For speaker identification,
    enrolling is text-independent. This means that you can use whatever sentence you
    want for enrollment. Once the voice is recorded, a number of features will be
    extracted to form a unique voice-print.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好扬声器配置文件后，我们需要将语音音频与配置文件关联起来。我们通过一个称为**注册**的过程来完成这个任务。对于扬声器识别，注册是文本无关的。这意味着你可以使用任何句子进行注册。一旦录音完成，将提取一系列特征来形成一个独特的声纹。
- en: When enrolling, the audio file you are using must be 5 seconds at least and
    5 minutes at most. Best practice states that you should accumulate at least 30
    seconds of speech. This is 30 seconds *after* silence has been removed, so several
    audio files may be required. This recommendation can be avoided by specifying
    an extra parameter, as we will see presently.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册时，你使用的音频文件必须至少5秒，最多5分钟。最佳实践建议你至少积累30秒的语音。这是在移除静音后的30秒，因此可能需要多个音频文件。我们可以通过指定一个额外的参数来避免这个建议，正如我们接下来将要看到的。
- en: How you choose to upload the audio file is up to you. In the smart-house application,
    we will use a microphone to record live audio. To do so, we will need to add a
    new NuGet package called **NAudio**. This is an audio library for .NET, which
    simplifies audio work.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择如何上传音频文件取决于你。在智能家居应用程序中，我们将使用麦克风来录制实时音频。为此，我们需要添加一个新的NuGet包，名为**NAudio**。这是一个.NET的音频库，它简化了音频工作。
- en: We will also need a class to deal with recording, which is out of the scope
    of this book. As such, I recommend you copy the `Recording.cs` file, which can
    be found in the sample project in the `Model` folder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个处理录音的类，这超出了本书的范围。因此，我建议你复制`Recording.cs`文件，该文件可以在示例项目的`Model`文件夹中找到。
- en: 'In the `AdministrationViewModel` ViewModel, add a private member for the newly
    copied class. Create the class and subscribe to the events defined in the `Initialize`
    function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AdministrationViewModel` ViewModel中，添加一个新复制的类的私有成员。创建这个类并订阅在`Initialize`函数中定义的事件：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have an event for errors and one for available audio stream. Let `OnRecordingError`
    print the `ErrorMessage` to the status text field.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个错误事件和一个可用音频流事件。让`OnRecordingError`将`ErrorMessage`打印到状态文本字段。
- en: 'In `OnAudioStreamAvailable`, add the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnAudioStreamAvailable`中添加以下内容：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we call `CreateSpeakerEnrollment` on the `_speakerIdentification` object.
    We will cover this function presently. The parameters we pass on are the `AudioStream`,
    from the recording, as well as the ID of the selected profile.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`_speakerIdentification`对象上调用`CreateSpeakerEnrollment`。我们将在后面介绍这个函数。我们传递的参数包括从录音中获取的`AudioStream`以及所选配置文件的ID。
- en: 'To be able to get audio files for enrollment, we need to start and stop the
    recording. This can be done by simply adding two new buttons, one for start and
    one for stop. They will then need to execute one of the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够获取用于注册的音频文件，我们需要开始和停止录音。这可以通过简单地添加两个新按钮来完成，一个用于开始，一个用于停止。然后它们需要执行以下操作：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Back in the `SpeakerIdentification.cs` file, we need to create a new function,
    `CreateSpeakerEnrollment`. This should accept `Stream` and `Guid` as parameters,
    and be marked as `async`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SpeakerIdentification.cs`文件中，我们需要创建一个新的函数`CreateSpeakerEnrollment`。这个函数应该接受`Stream`和`Guid`作为参数，并标记为`async`：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this function, we call the `EnrollAsync` function on `_speakerIdentificationClient`.
    This function requires both the `audioStream` and `profileId` as parameters. An
    optional third parameter is a `bool` type variable, which lets you decide whether
    or not you would like to use the recommended speech length or not. The default
    is `false`, meaning that you use the recommended setting of at least 30 seconds
    of speech.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们在`_speakerIdentificationClient`上调用`EnrollAsync`函数。这个函数需要`audioStream`和`profileId`作为参数。一个可选的第三个参数是一个`bool`类型的变量，它让你决定是否使用推荐的语音长度。默认值是`false`，这意味着你使用至少30秒的语音推荐设置。
- en: 'If the call is successful, we get an `OperationLocation` object back. This
    holds a URL that we can query for the enrollment status, which is precisely what
    we will do:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，我们将返回一个`OperationLocation`对象。这个对象包含一个URL，我们可以通过它查询注册状态，这正是我们接下来要做的：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we make sure that we have the `location` data. Without it, there is no
    point in moving on. If we do have the `location` data, we call a function, `GetEnrollmentOperationStatus`,
    specifying the `location` as the parameter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保我们有了 `location` 数据。如果没有它，就没有继续下去的意义。如果我们确实有 `location` 数据，我们调用一个函数，`GetEnrollmentOperationStatus`，指定
    `location` 作为参数。
- en: Add the corresponding `catch` clause to finish the function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为完成函数，添加相应的 `catch` 子句。
- en: 'The `GetEnrollmentOperationStatus` method accepts `OperationLocation` as a
    parameter. When we enter the function, we move into a `while` loop, which will
    run until the operation completes. We call `CheckEnrollmentStatusAsync`, specifying
    the `location` as the parameter. If this call is successful, it will return an
    `EnrollmentOperation` object, which contains data such as status, enrollment speech
    time, and an estimation of the time of enrollment left:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetEnrollmentOperationStatus` 方法接受 `OperationLocation` 作为参数。当我们进入函数时，我们进入一个
    `while` 循环，该循环将一直运行，直到操作完成。我们调用 `CheckEnrollmentStatusAsync`，指定 `location` 作为参数。如果这个调用成功，它将返回一个
    `EnrollmentOperation` 对象，其中包含状态、注册语音时间和剩余注册时间的估计：'
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When we have retrieved the result, we check to see if the status is running
    or not. If it isn''t, the operation has either failed, succeeded, or not started.
    In any case, we do not want to check any further, so we send an update with the
    status and break out of the loop:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检索到结果后，我们检查状态是否正在运行。如果不是，操作可能已失败、成功或尚未开始。在任何情况下，我们都不想进一步检查，因此我们发送一个包含状态的更新，并跳出循环：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the status is still running, we update the status and wait for 1 second before
    trying again.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态仍然是正在运行，我们更新状态，并在再次尝试之前等待 1 秒。
- en: 'With enrollment completed, there may be times when we need to reset the enrollment
    for a given profile. We can do so by creating a new function in `SpeakerIdentification`.
    Name it `ResetEnrollments`, and let it accept a `Guid` as a parameter. This should
    be the profile ID of the speaker profile to reset. Execute the following inside
    a `try` clause:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注册完成后，可能会有需要重置给定个人资料注册的情况。我们可以在 `SpeakerIdentification` 中创建一个新函数。命名为 `ResetEnrollments`，并让它接受一个
    `Guid` 作为参数。这应该是要重置的说话者个人资料的 ID。在 `try` 子句中执行以下操作：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will delete all audio files associated with the given profile and also
    reset the enrollment status. To call this function, add a new button to the UI
    and the corresponding `ICommand` property in the ViewModel.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除与给定个人资料关联的所有音频文件，并重置注册状态。要调用此函数，请向 UI 添加一个新按钮，并在 ViewModel 中添加相应的 `ICommand`
    属性。
- en: 'If you compile and run the application, you may get a result similar to the
    following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编译并运行应用程序，您可能会得到以下截图类似的结果：
- en: '![Enrolling a profile](img/B12373_05_01.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![注册个人资料](img/B12373_05_01.jpg)'
- en: Identifying the speaker
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别说话者
- en: The last step is to identify the speaker, which we will do in the `HomeView`
    and corresponding `HomeViewModel`. We do not need to modify the UI much, but we
    do need to add two buttons in order to start and stop the recording. Alternatively,
    if you are not using a microphone, you can get away with one button for browsing
    an audio file. Either way, add the corresponding `ICommand` properties in the
    ViewModel.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是识别说话者，我们将在 `HomeView` 和相应的 `HomeViewModel` 中完成这项工作。我们不需要修改 UI 很多，但我们需要添加两个按钮来开始和停止录音。或者，如果您不使用麦克风，您可以使用一个按钮来浏览音频文件。无论如何，在
    ViewModel 中添加相应的 `ICommand` 属性。
- en: We also need to add private members for the `Recording` and `SpeakerIdentification`
    classes. Both should be created in the constructor, where we should inject `ISpeakerIdentificationServiceClient`
    as well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为 `Recording` 和 `SpeakerIdentification` 类添加私有成员。这两个成员都应该在构造函数中创建，在那里我们应该注入
    `ISpeakerIdentificationServiceClient`。
- en: 'In the `Initialize` function, subscribe to the required events:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Initialize` 函数中，订阅所需的事件：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For both of the error event handlers, `OnSpeakerRecordingError` and `OnSpeakerIdentificationError`,
    we do not wish to print the error message here. For simplicity, we just output
    it to the debug console window.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个错误事件处理器，`OnSpeakerRecordingError` 和 `OnSpeakerIdentificationError`，我们不想在这里打印错误信息。为了简单起见，我们只需将其输出到调试控制台窗口。
- en: The `OnSpeakerRecordingAvailable` event will be triggered when we have recorded
    some audio. This is the event handler that will trigger an attempt to identify
    the person speaking.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们录制了一些音频时，`OnSpeakerRecordingAvailable` 事件将被触发。这是将触发尝试识别说话者的事件处理器。
- en: 'The first thing we need to do is get a list of speaker profile IDs. We do so
    by calling `ListSpeakerProfiles`, which we looked at earlier:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取说话者配置文件ID的列表。我们通过调用前面提到的`ListSpeakerProfiles`来实现这一点：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With the list of speaker profiles, we call the `IdentifySpeaker` method on
    the `_speakerIdentification` object. We pass on the recorded audio stream and
    the profile list, as an array, as parameters to the function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用说话者配置文件列表，我们在`_speakerIdentification`对象上调用`IdentifySpeaker`方法。我们将记录的音频流和配置文件列表作为参数传递给函数：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finish the event handler by adding the corresponding `catch` clause.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加相应的`catch`子句来完成事件处理程序。
- en: 'Back in the `SpeakerIdentification.cs` file, we add the new function, `IdentifySpeaker`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SpeakerIdentification.cs`文件中，我们添加新的函数`IdentifySpeaker`：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The function should be marked as `async` and accept a `Stream` and an array
    of `Guid` as parameters. To identify a speaker, we make a call to the `IdentifyAsync`
    function on the `_speakerIdentificationClient` object. This requires an audio
    file, in the form of a `Stream`, as well as an array of profile IDs. An optional
    third parameter is a `bool`, which you can use to indicate whether or not you
    want to deviate from the recommended speech length.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应标记为`async`并接受一个`Stream`和一个`Guid`数组作为参数。为了识别说话者，我们在`_speakerIdentificationClient`对象上调用`IdentifyAsync`函数。这需要一个音频文件，以`Stream`的形式，以及一个配置文件ID数组。可选的第三个参数是一个`bool`，你可以用它来指示你是否想偏离推荐的语音长度。
- en: 'If the call succeeds, we get an `OperationLocation` object back. This contains
    a URL that we can use to retrieve the status of the current identification process:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，我们将返回一个`OperationLocation`对象。它包含一个我们可以用来检索当前识别过程状态的URL：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If the resulting data contains nothing, we do not want to bother doing anything
    else. If it does contain data, we pass it on as a parameter to the `GetIdentificationOperationStatus`
    method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果数据中没有内容，我们不想做任何其他事情。如果它包含数据，我们将它作为参数传递给`GetIdentificationOperationStatus`方法：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This function is quite similar to `GetEnrollmentOperationStatus`. We go into
    a `while` loop, which will run until the operation completes. We call `CheckIdentificationStatusAsync`,
    passing on the `location` as a parameter, getting `IdentificationOperation` as
    a result. This will contain data, such as a status, the identified profiles ID,
    and the confidence of a correct result.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与`GetEnrollmentOperationStatus`非常相似。我们进入一个`while`循环，它将一直运行，直到操作完成。我们调用`CheckIdentificationStatusAsync`，传递`location`作为参数，得到`IdentificationOperation`作为结果。这将包含数据，如状态、已识别的配置文件ID和正确结果的置信度。
- en: 'If the operation is not running, we raise the event with the status message
    and the `ProcessingResult`. If the operation is still running, we update the status
    and wait for 1 second before trying again:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作未运行，我们以状态消息和`ProcessingResult`引发事件。如果操作仍在运行，我们更新状态，并在1秒后再次尝试：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Add the corresponding `catch` clause before heading back to the `HomeViewModel`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回到`HomeViewModel`之前，添加相应的`catch`子句。
- en: 'The last piece in the puzzle is to create `OnSpeakerIdentificationStatusReceived`.
    Add the following code inside HomeViewModel:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是创建`OnSpeakerIdentificationStatusReceived`。在`HomeViewModel`中添加以下代码：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We need to check to see whether or not we have an identified profile. If we
    do not, we leave the function. If we have an identified profile, we give a response
    to the screen, stating who it is.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查是否有一个已识别的配置文件。如果没有，我们离开函数。如果有已识别的配置文件，我们向屏幕给出响应，说明是谁。
- en: 'As with the administrative side of the application, this is a place where it
    would be convenient to have name-to-profile ID mapping. As you can see from the
    following resulting screenshot, recognizing one `GUID` among many is not that
    easy:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就像应用的管理端一样，这是一个方便的地方，可以有一个名称到配置文件ID的映射。正如以下结果截图所示，在众多`GUID`中识别一个并不容易：
- en: '![Identifying the speaker](img/B12373_05_02.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![识别说话者](img/B12373_05_02.jpg)'
- en: Verifying a person through speech
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过语音验证一个人
- en: The process of verifying if a person is who they claim to be is quite similar
    to the identification process. To show how it is done, we will create a new example
    project, as we do not need this functionality in our smart-house application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 验证一个人是否是他们所声称的是一个非常类似的过程。为了展示如何进行，我们将创建一个新的示例项目，因为我们不需要在智能屋应用中实现这个功能。
- en: Add the `Microsoft.ProjectOxford.SpeakerRecognition` and `NAudio` NuGet packages
    to the project. We will need the `Recording` class that we used earlier, so copy
    this from the smart-house application's `Model` folder.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Microsoft.ProjectOxford.SpeakerRecognition` 和 `NAudio` NuGet 包添加到项目中。我们需要之前使用的
    `Recording` 类，因此从智能家居应用的 `Model` 文件夹中复制此内容。
- en: Open the `MainView.xaml` file. We need a few elements in the UI for the example
    to work. Add a `Button` element to add speaker profiles. Add two `Listbox` elements.
    One will hold available verification phrases while the other will list our speaker
    profiles.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainView.xaml` 文件。为了示例能够工作，我们需要在 UI 中添加一些元素。添加一个 `Button` 元素以添加演讲者配置文件。添加两个
    `Listbox` 元素。一个将保存可用的验证短语，而另一个将列出我们的演讲者配置文件。
- en: Add `Button` elements for deleting a profile, starting and stopping enrollment
    recording, resetting enrollment, and starting/stopping verification recording.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 添加用于删除配置文件、开始和停止注册录音、重置注册以及开始/停止验证录音的 `Button` 元素。
- en: 'In the ViewModel, you will need to add two `ObservableCollection` properties:
    one of type `string`, the other of type `Guid`. One will contain the available
    verification phrases, while the other will contain the list of speaker profiles.
    You will also need a property for the selected speaker profile, and we also want
    a string property to show the status.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ViewModel 中，你需要添加两个 `ObservableCollection` 属性：一个类型为 `string`，另一个类型为 `Guid`。一个将包含可用的验证短语，而另一个将包含演讲者配置文件列表。你还需要一个属性用于选择演讲者配置文件，我们还想添加一个字符串属性以显示状态。
- en: The ViewModel will also need seven `ICommand` properties, one for each of our
    buttons.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel 还需要七个 `ICommand` 属性，每个按钮一个。
- en: Create a new class in the `Model` folder and call this `SpeakerVerification`.
    Add two new classes beneath this one, in the same file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Model` 文件夹中创建一个新的类，命名为 `SpeakerVerification`。在此类下创建两个新类，在同一文件中。
- en: 'The first one is the event arguments that we will pass on when we raise a status
    update event. The `Verification` property will, if set, hold the verification
    result, which we will see presently:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是当我们抛出状态更新事件时将传递的事件参数。如果设置，`Verification` 属性将保存验证结果，我们将在下面看到：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next class is a generic event argument, which is used when we raise an
    error event. In `SpeakerVerification` itself, add the following events:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类是一个泛型事件参数，当抛出错误事件时使用。在 `SpeakerVerification` 本身中，添加以下事件：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For our convenience, add helper functions to raise these. Call them `RaiseOnVerificationStatusUpdated`
    and `RaiseOnVerificationError`. Raise the correct event in each of them:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，添加辅助函数来引发这些事件。将它们命名为 `RaiseOnVerificationStatusUpdated` 和 `RaiseOnVerificationError`。在每个函数中引发正确的事件：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We also need to add a private member called `ISpeakerVerificationServiceClient`.
    This will be in charge of calling the API. We inject this through the constructor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个名为 `ISpeakerVerificationServiceClient` 的私有成员。它将负责调用 API。我们通过构造函数注入它。
- en: 'Add the following functions to the class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 向类中添加以下函数：
- en: '`CreateSpeakerProfile`: No parameters, the `async` function, and the return
    type `Task<Guid>`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateSpeakerProfile`：无参数，异步函数，返回类型 `Task<Guid>`'
- en: '`ListSpeakerProfile`: No parameters, the `async` function, and the return type
    `Task<List<Guid>>`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListSpeakerProfile`：无参数，异步函数，返回类型 `Task<List<Guid>>`'
- en: '`DeleteSpeakerProfile`: `Guid` as the required parameter, the `async` function,
    no returned values'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteSpeakerProfile`：必需参数为 `Guid`，异步函数，无返回值'
- en: '`ResetEnrollments`: `Guid` as the required parameter, the `async` function,
    no returned values'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResetEnrollments`：必需参数为 `Guid`，异步函数，无返回值'
- en: The contents of these functions can be copied from the corresponding functions
    in the smart-house application, as they are exactly the same. The only difference
    is that you need to change the API call from `_speakerIdentificationClient` to
    `_speakerVerificationClient`. Also, raising the events will require the newly
    created event arguments.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的内容可以从智能家居应用中的相应函数复制，因为它们完全相同。唯一的区别是，你需要将 API 调用从 `_speakerIdentificationClient`
    更改为 `_speakerVerificationClient`。此外，引发事件将需要新创建的事件参数。
- en: Next, we need a function to list verification phrases. These are phrases that
    are supported for use with verification. When enrolling a profile, you are required
    to say one of the sentences in this list.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数来列出验证短语。这些是支持用于验证的短语。在注册配置文件时，你必须说出列表中的句子之一。
- en: 'Create a function named `GetVerificationPhrase`. Have it return `Task<List<string>>`,
    and mark it as `async`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `GetVerificationPhrase` 的函数。让它返回 `Task<List<string>>`，并标记为 `async`：
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We will make a call to `GetPhrasesAsync`, specifying the language we want the
    phrases to be in. At the time of writing, English is the only possible choice.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`GetPhrasesAsync`，指定我们想要的短语语言。在撰写本文时，英语是唯一的选择。
- en: 'If this call is successful, we will get an array of `VerificationPhrases` in
    return. Each element in this array contains a string with the following phrase:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个调用成功，我们将返回一个包含`VerificationPhrases`数组的数组。该数组中的每个元素都包含以下短语的字符串：
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We loop through the array and add the phrases to our list, which we will return
    to the caller.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历数组并将短语添加到我们的列表中，我们将将其返回给调用者。
- en: So, we have created a profile and we have the list of possible verification
    phrases. Now, we need to do the enrollment. To enroll, the service requires at
    least three enrollments from each speaker. This means that you choose a phrase
    and enroll it at least three times.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经创建了一个配置文件，并且我们有可能的验证短语列表。现在，我们需要进行注册。为了注册，服务要求每个说话者至少有三次注册。这意味着您选择一个短语并至少注册三次。
- en: When you do the enrollment, it is highly recommended to use the same recording
    device that you will use for verification.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行注册时，强烈建议使用您将用于验证的相同录音设备。
- en: 'Create a new function called `CreateSpeakerEnrollment`. This should require
    a `Stream` and a `Guid`. The first parameter is the audio to use for enrollment.
    The latter is the ID of the profile we are enrolling. The function should be marked
    as `async`, and have no return value:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CreateSpeakerEnrollment`的新函数。这应该需要一个`Stream`和一个`Guid`。第一个参数是用于注册的音频。后者是我们注册的配置文件ID。该函数应标记为`async`，并且没有返回值：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When we call `EnrollAsync`, we pass on the `audioStream` and `profileId` parameters.
    If the call is successful, we get an `Enrollment` object back. This contains the
    current status of enrollment and specifies the number of enrollments you need
    to add before completing the process.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`EnrollAsync`时，我们传递`audioStream`和`profileId`参数。如果调用成功，我们将返回一个`Enrollment`对象。它包含注册的当前状态，并指定在完成过程之前需要添加的注册次数。
- en: 'If the `enrollmentStatus` is null, we exit the function and notify any subscribers.
    If we do have status data, we raise the event to notify it that there is a status
    update, specifying the current status:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`enrollmentStatus`为null，我们退出函数并通知任何订阅者。如果我们确实有状态数据，我们将引发事件以通知它有状态更新，并指定当前状态：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Add the corresponding `catch` clause to finish up the function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 添加相应的`catch`子句以完成函数。
- en: The last function we need in this class is a function for verification. To verify
    a speaker, you need to send in an audio file. This file must be at least 1 second
    and at most 15 seconds long. You will need to record the same phrase that you
    used for enrollment.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们还需要一个用于验证的函数。要验证说话者，您需要发送一个音频文件。此文件必须至少1秒长，最多15秒长。您需要录制与注册时相同的短语。
- en: 'Call the `VerifySpeaker` function and make it require a `Stream` and `Guid`.
    The stream is the audio file we will use for verification. The `Guid` is the ID
    of the profile we wish to verify. The function should be `async` and have no return
    type:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`VerifySpeaker`函数，并使其需要`Stream`和`Guid`。流是我们将用于验证的音频文件。`Guid`是我们希望验证的配置文件ID。该函数应该是`async`类型且没有返回类型：
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We will make a call to `VerifyAsync` from `_speakerVerificationClient`. The
    required parameters are `audioStream` and `speakerProfile`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`_speakerVerificationClient`调用`VerifyAsync`。所需的参数是`audioStream`和`speakerProfile`。
- en: 'A successful API call will result in a `Verification` object in response. This
    will contain the verification results, as well as the confidence of the results
    being correct:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的API调用将导致响应中返回一个`Verification`对象。这将包含验证结果，以及结果正确性的置信度：
- en: '[PRE67]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we do have a verification result, we raise the status update event. Add the
    corresponding `catch` clause to complete the function.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有验证结果，我们将引发状态更新事件。添加相应的`catch`子句以完成函数。
- en: Back in the ViewModel, we need to wire up the commands and event handlers. This
    is done in a similar manner as for speaker identification, and as such we will
    not cover the code in detail.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在ViewModel中，我们需要连接命令和事件处理器。这与说话者识别的方式类似，因此我们不会详细说明代码。
- en: 'With the code compiling and running, the result may look similar to the following
    screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码编译并运行时，结果可能看起来类似于以下截图：
- en: '![Verifying a person through speech](img/B12373_05_03.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![通过语音验证一个人](img/B12373_05_03.jpg)'
- en: Here, we can see that we have created a speaker profile. We have also completed
    the enrollment and are ready to verify the speaker.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经创建了一个说话人配置文件。我们已完成注册，并准备好验证说话人。
- en: 'Verifying the speaker profile may result in the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 验证说话人配置文件可能会导致以下结果：
- en: '![Verifying a person through speech](img/B12373_05_04.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![通过语音验证一个人](img/B12373_05_04.jpg)'
- en: As you can see, the verification was accepted with high confidence.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，验证被高度信任地接受。
- en: 'If we try to verify this using a different phrase or let someone else try to
    verify as a particular speaker profile, we may end up with the following result:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用不同的短语或让其他人尝试作为特定的说话人配置文件进行验证，我们可能会得到以下结果：
- en: '![Verifying a person through speech](img/B12373_05_05.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![通过语音验证一个人](img/B12373_05_05.jpg)'
- en: Here, we can see that the verification has been rejected.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到验证已被拒绝。
- en: Customizing speech recognition
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义语音识别
- en: When we use speech recognition systems, there are several components that are
    working together. Two of the more important components are acoustic and language
    models. The first one labels short fragments of audio into sound units. The second
    helps the system decide the words, based on the likelihood of a given word appearing
    in certain sequences.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用语音识别系统时，有几个组件正在协同工作。其中两个更重要的组件是声学模型和语言模型。第一个将音频的短片段标记为声音单元。第二个帮助系统根据给定单词在特定序列中出现的可能性来决定单词。
- en: Although Microsoft has done a great job of creating comprehensive acoustic and
    language models, there may still be times when you need to customize these models.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微软在创建全面的声学模型和语言模型方面做得很好，但仍然可能存在需要自定义这些模型的情况。
- en: Imagine that you have an application that is supposed to be used in a factory
    environment. Using speech recognition will require acoustic training of that environment
    so that the recognition can separate it from usual factory noises.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一个应该在工厂环境中使用的应用程序。使用语音识别将需要对该环境的声学训练，以便识别可以将其与通常的工厂噪音区分开来。
- en: Another example is if your application is used by a specific group of people,
    say, an application for search, where programming is the main topic. You would
    typically use words such as *object-oriented*, *dot net*, or *debugging*. This
    can be recognized by customizing language models.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果您的应用程序被特定群体的人使用，比如一个以编程为主要主题的搜索应用程序。您通常会使用诸如*面向对象*、*dot net*或*调试*之类的词语。这可以通过自定义语言模型来识别。
- en: Creating a custom acoustic model
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义声学模型
- en: To create custom acoustic models, you will need audio files and transcripts.
    Each audio file must be stored as a WAV and be between 100 ms and 1 minute in
    length. It is recommended that there is at least 100 ms of silence at the start
    and end of the file. Typically, this will be between 500 ms and 1 second. With
    a lot of background noise, it is recommended to have silences in-between content.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义声学模型，您需要音频文件和文本记录。每个音频文件必须存储为WAV格式，长度在100毫秒到1分钟之间。建议文件开头和结尾至少有100毫秒的静音。通常，这将在500毫秒到1秒之间。在背景噪音很多的情况下，建议在内容之间有静音。
- en: Each file should contain one sentence or utterance. Files should be uniquely
    named, and an entire set of files can be up to 2 GB. This translates to about
    17 to 34 hours of audio, depending on the sampling rate. All files in one set
    should be placed in a zipped folder, which then can be uploaded.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件应包含一个句子或话语。文件应具有唯一名称，整个文件集可达到2 GB。这相当于大约17到34小时的音频，具体取决于采样率。一个集合中的所有文件应放在一个压缩文件夹中，然后可以上传。
- en: Accompanying the audio files is a single file with the transcript. This should
    name the file and have the sentence next to the name. The filename and sentence
    should be separated by a tab.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 随音频文件附带的还有一个包含文本记录的单独文件。该文件应命名，并在名称旁边有句子。文件名和句子应由制表符分隔。
- en: Uploading the audio files and transcript will make CRIS process it. When this
    process is done, you will get a report stating which sentences have failed or
    succeeded. If anything fails, you will get the reason for the failure.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 上传音频文件和文本记录将使CRIS进行处理。当此过程完成后，您将获得一份报告，说明哪些句子失败或成功。如果任何内容失败，您将获得失败的原因。
- en: When the dataset has been uploaded, you can create the acoustic model. This
    will be associated with the dataset you select. When the model has been created,
    you can start the process to train it. Once the training is completed, you can
    deploy the model.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据集已上传后，您可以创建声学模型。这将与您选择的数据库相关联。当模型创建完成后，您可以开始训练过程。一旦训练完成，您可以部署该模型。
- en: Creating a custom language model
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义语言模型
- en: Creating custom language models will also require a dataset. This set is a single
    plain text file containing sentences or utterances unique to your model. Each
    new line marks a new utterance. The maximum file size is 2 GB.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义语言模型也需要一个数据集。这个集合是一个包含您模型独特句子或话语的单个纯文本文件。每行新标记一个新话语。最大文件大小为2 GB。
- en: Uploading the file will make CRIS process it. Once the processing is done, you
    will get a report, which will print any errors, with the reason of failure.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件后，CRIS将对其进行处理。一旦处理完成，您将获得一份报告，其中将打印出任何错误及其失败原因。
- en: With the processing done, you can create a custom language model. Each model
    will be associated with a given dataset of your selection. Once created, you can
    train the model, and when the training complete, you can deploy it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成后，您可以创建一个自定义语言模型。每个模型都将与您选择的给定数据集相关联。一旦创建，您就可以训练模型，训练完成后，您可以部署它。
- en: Deploying the application
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: To deploy and use the custom models, you will need to create a deployment. Here,
    you will name and describe the application. You can select acoustic models and
    language models. Be aware that you can only select one of each per deployed application.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署和使用自定义模型，您需要创建一个部署。在这里，您将命名并描述应用程序。您可以选择声学模型和语言模型。请注意，您可以为每个部署的应用程序选择每个模型的一个。
- en: Once created, the deployment will start. This process can take up to 30 minutes
    to complete, so be patient. When the deployment completes, you can get the required
    information by clicking on the application name. You will be given URLs you can
    use, as well as subscription keys to use.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 创建部署后，部署过程将开始。这个过程可能需要长达30分钟才能完成，所以请耐心等待。部署完成后，您可以通过单击应用程序名称来获取所需信息。您将获得可使用的URL以及用于订阅的密钥。
- en: To use the custom models with the Bing Speech API, you can overload `CreateDataClientWithIntent`
    and `CreateMicrophoneClient`. The overloads you will want to use specify both
    the primary and secondary API keys. You need to use the ones supplied by CRIS.
    Additionally, you need to specify the supplied URL as the last parameter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Bing语音API与自定义模型一起使用，您可以重载`CreateDataClientWithIntent`和`CreateMicrophoneClient`。您想要使用的重载将指定主API密钥和辅助API密钥。您需要使用CRIS提供的密钥。此外，您需要指定提供的URL作为最后一个参数。
- en: Once this is done, you are able to use customized recognition models.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您可以使用定制的识别模型。
- en: Translating speech on the fly
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时翻译语音
- en: Using the **Translator Speech** API, you can add automatic end-to-end translation
    for speech. Utilizing this API, one can submit an audio stream of speech and retrieve
    a textual and audio version of translated text. It uses silent detection to detect
    when speech has ended. Results will be streamed back once the pause is detected.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**翻译语音**API，您可以添加语音的自动端到端翻译。利用此API，可以提交语音音频流并检索翻译文本的文本和音频版本。它使用静音检测来检测语音何时结束。一旦检测到暂停，结果将流回。
- en: 'For a comprehensive list of supported languages, please visit the following
    site: [https://www.microsoft.com/en-us/translator/business/languages/](https://www.microsoft.com/en-us/translator/business/languages/).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取支持语言的完整列表，请访问以下网站：[https://www.microsoft.com/en-us/translator/business/languages/](https://www.microsoft.com/en-us/translator/business/languages/)。
- en: The result recieved from the API, will contain a stream of audio- and text-based
    results. The results contain the source text in its original language and the
    translation in the target language.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从API收到的结果将包含基于音频和文本的结果流。结果包含源语言中的源文本和目标语言中的翻译。
- en: 'For a thorough example on how to use the **Translator Speech** API, please
    visit the following sample at GitHub: [https://github.com/MicrosoftTranslator/SpeechTranslator](https://github.com/MicrosoftTranslator/SpeechTranslator).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用**翻译语音**API的详细示例，请访问以下GitHub上的示例：[https://github.com/MicrosoftTranslator/SpeechTranslator](https://github.com/MicrosoftTranslator/SpeechTranslator)。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have focused on speech. We started by looking at
    how we can convert spoken audio to text and text to spoken audio. Using this,
    we modified our LUIS implementation so that we can say commands and have conversations
    with the smart-house application. From there, we moved on to see how we can identify
    a person speaking using the Speaker Recognition API. Using the same API, we also
    learned how to verify that a person is who they claim to be. We briefly looked
    at the core functionality of the Custom Speech Service. Finally, we briefly covered
    an introduction to the Translator Speech API.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们一直专注于语音。我们首先探讨了如何将语音音频转换为文本，以及将文本转换为语音音频。利用这一点，我们修改了LUIS的实现，以便我们可以对智能家居应用程序下达命令并进行对话。从那里，我们继续探讨如何使用语音识别API来识别正在说话的人。使用相同的API，我们还学习了如何验证一个人是否是他们所声称的那个人。我们简要地了解了自定义语音服务的核心功能。最后，我们简要地介绍了翻译语音API的入门知识。
- en: In the following chapter, we will move back to textual APIs, where we will learn
    how to explore and analyze text in different ways.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将回到文本API，我们将学习如何以不同的方式探索和分析文本。
