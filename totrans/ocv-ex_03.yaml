- en: Chapter 3. Learning the Graphical User Interface and Basic Filtering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned the basic classes and structures of OpenCV
    and the most important class called `Mat`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to read and save images, videos, and the internal structure in
    the memory of images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to work now, but we need to show our results and have some basic
    interaction with our images. OpenCV provides us with a few basic user interfaces
    to work with and help create our applications and prototypes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how the user interface works, we are going to create a
    small application called **PhotoTool** at the end of this chapter. In this application,
    we will learn how to use filters and color conversions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The basic OpenCV user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenCV QT interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sliders and buttons
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An advanced user interface—OpenGL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color conversion
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic filters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the OpenCV user interface
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV has its own cross-operating system user interface that allows developers
    to create their own applications without the need to learn complex libraries for
    the user interface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The OpenCV user interface is basic, but it gives Computer Vision developers
    the basic functions to create and manage their software developments. All of them
    are native and optimized for real-time use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV provides two options for the user interface:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A basic interface based on native user interfaces, such as Cocoa or Carbon for
    OS X and GTK for Linux or Windows user interfaces, that are selected by default
    when you compile OpenCV.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slightly more advanced interface based on the QT library that is cross-platform.
    You have to enable the QT option manually in CMake before you compile OpenCV.![Introducing
    the OpenCV user interface](img/B04283_03_01.jpg)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic graphical user interface with OpenCV
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create a basic user interface with OpenCV. The OpenCV user interface
    allows us to create windows, add images to it, move it, resize it, and destroy
    it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interface is in the OpenCV''s module called `highui`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's understand the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task that we need to perform in order to enable a Graphical User
    Interface is import the OpenCV''s module `highui`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we are prepared to create our new windows, and then we need to load some
    images that are to be shown:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create the windows, we use the `namedWindow` function. This function has
    two parameters: the first parameter is a constant string with the window''s name,
    and the second parameter is the flags that we require, which is optional:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our case, we create two windows: the first window is called `Lena` and the
    second is called `Photo`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are the three flags for QT and native interfaces:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`WINDOW_NORMAL`: This flag allows the user to resize the window'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_AUTOSIZE`: If this flag is set, the window size is automatically adjusted
    to fit the display image and it is not possible to resize the window'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_OPENGL`: This flag enables OpenGL support'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'QT has some more flags, which are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '`WINDOW_FREERATIO` or `WINDOW_KEEPRATIO`: If set to `WINDOW_FREERATIO`, then
    the image is adjusted with no respect to its ratio. If set to `WINDOW_FREERATIO`,
    then the image is adjusted with respect to its ratio.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_GUI_NORMAL` or `CV_GUI_EXPANDED`: The first flag enables the basic interface
    without the status bar and toolbar. The second flag enables the most advanced
    graphical user interface with the status bar and toolbar.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we compile OpenCV with QT, all the windows that we create are, by default,
    in the expanded interface, but we can use native and more basic interfaces by
    adding the `CV_GUI_NORMAL` flag.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: By default, the flags are `WINDOW_AUTOSIZE`, `WINDOW_KEEPRATIO`, and `CV_GUI_EXPANDED`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create multiple windows, they are superimposed one above the other,
    but we can move the windows to any area of our desktop with the `moveWindow` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our code, we move the `Lena` window to the left 10 pixels 10 pixels to the
    top; and the `Photo` window to the left 520 pixels and 10 pixels to the top:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After showing the images that we loaded previously with the `imshow` function,
    we resize the `Lena` window to 512 pixels, calling the `resizeWindow` function.
    This function has three parameters: `window name`, `width`, and `height`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The specific window size is for the image area. Toolbars are not counted. Only
    windows without the enabled `WINDOW_AUTOSIZE` flag can be resized.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'After waiting for a key press with the `waitKey` function, we will remove or
    delete our windows with the `destroyWindow` function in which the name of the
    window is the only parameter that is required:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OpenCV has a function that is used to remove all the windows that we create
    in only one call. The function is called `destroyAllWindows`. To show how this
    function works, in our sample we create 10 windows and wait for a key press. When
    the user presses any key, we destroy all the windows. Anyway, OpenCV automatically
    handles the destruction of all the windows when the application is terminated,
    and it is not necessary to call this function at the end of our application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result of this code can be seen in the following images in two steps. The
    first image shows two windows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic graphical user interface with OpenCV](img/B04283_03_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'After pressing any key, the application continues and draws several windows
    by changing their positions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic graphical user interface with OpenCV](img/B04283_03_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: The graphical user interface with QT
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QT user interface gives us more control and options to work with our images.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface is divided into three main areas:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The toolbar
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image area
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status bar![The graphical user interface with QT](img/B04283_03_04.jpg)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The toolbar has the following buttons from left to right:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Four buttons for panning
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom x1
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom x30 and show labels
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom in
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom out
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the current image
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the properties windows
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These options can be seen more clearly in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical user interface with QT](img/B04283_03_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'The image area shows an image and a contextual menu when we push the right
    mouse button over the image. This area can show an overlay message at the top
    of the area using the `displayOverlay` function. This function accepts three parameters:
    the window name, the text that we want to show, and the period in milliseconds
    when the overlay text is displayed. If the time is set to `0`, the text never
    disappears:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![The graphical user interface with QT](img/B04283_03_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the status bar shows the bottom part of the window, the pixel value,
    and the position of the coordinates in the image:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical user interface with QT](img/B04283_03_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'We can use the status bar to show messages, such as an overlay. The function
    that can change the status bar message is `displayStatusBar`. This function has
    the same parameters as overlay functions: the window name, the text to show, and
    the period of time to show it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical user interface with QT](img/B04283_03_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Adding slider and mouse events to our interfaces
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mouse events and slider controls are very useful in Computer Vision and OpenCV.
    Using these controls, users can interact directly with the interface and change
    the properties of their input images or variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to introduce you to the concepts of adding slider
    and mouse events for basic interactions. To understand this correctly, we will
    create a small project, where we paint green circles in the image using the mouse
    events and blur the image with the slider:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's understand the code!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a variable to save the slider position, and then we need to
    save the slider position for access from other functions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we define our callbacks for our slider and mouse events that are required
    for the OpenCV `setMouseCallbac` and `createTrackbar` functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the main function, we load an image and create a new window called `Lena`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is time to create the slider. OpenCV has the `createTrackbar` function that
    is used to generate a slider with the following parameters in order:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The track bar name.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The window name.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer pointer to be used as a value; this parameter is optional. If the
    pointer value is set, the slider gets this position during its creation.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximal position on the slider.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback function when the position slider changes.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user data to be sent to the callback. It can be used to send data to callbacks
    without using global variables:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After creating the slider, we add the mouse events that allow you to paint
    circles when the user pushes the left mouse button. OpenCV has the `setMouseCallback`
    function. This function has three parameters, which are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The window name where we get the mouse events
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `callback` function to be called when there are mouse interactions
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User data refers to any data that will be sent to the callback function when
    it''s fired. In our example, we''ll send the entire `Lena` image:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To finalize the `main` function, we only need to initialize the image with
    the same parameter as the slider. To perform the initialization, we only need
    to call the `callback` function manually and wait for events before we close the
    windows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The slider callback applies a basic blur filter to the image using the slider
    value as a blur quantity:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function checks whether the slider value is 0 using the `pos` variable;
    in this case, we do not apply the filter because it generates a bad execution.
    We cannot apply a 0 pixels blur.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: After checking the slider value, we create an empty matrix called `imgBlur`
    to store the blur result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the image sent via the user data in the `callback` function, we
    have to cast the `void* userData` to correct the `pointer Mat*` image type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have the correct variables to be applied to the blur filter. The blur
    function applies a basic median filter to an input image, `*img` in our case,
    to an output image. The last parameter is the size of a blur kernel (a kernel
    is a small matrix used to calculate the means of convolution between the kernel
    and image) that we want to apply. In our case, we are using a squared kernel of
    the `pos` size.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we only need to update the image interface using the `imshow` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The mouse events callback has five input parameters: the first parameter defines
    the event type, the second and third parameters define the mouse position, the
    fourth parameter defines the wheel movement, and the fifth parameter defines the
    user input data.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The mouse event types are shown in the following table:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '| Event type | Description |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MOUSEMOVE` | When the user moves the mouse |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONDOWN` | When the user pushes the left mouse button |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONDOWN` | When the user pushes the right mouse button |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONDOWN` | When the user pushes the middle mouse button |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONUP` | When the user releases the left mouse button |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONUP` | When the user releases the right mouse button |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONUP` | When the user releases the middle mouse button |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONDBLCLK` | When the user double-clicks with the left mouse button
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONDBLCLK` | When the user double-clicks with the right mouse
    button |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONDBLCLK` | When the user double-clicks with the middle mouse
    button |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `EVENTMOUSEWHEEL` | When the user does a vertical scroll with the mouse wheel
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MOUSEHWHEEL` | When the user does a horizontal scroll with the mouse
    wheel |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: 'In our sample, we only go to manage events that come from a left-push mouse
    button, and then any other event different from `EVENT_LBUTTONDOWN` is discarded.
    After discarding other events, we get the input image, such as a slider callback,
    and draw a circle in the image with the circle OpenCV function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Adding buttons to a user interface
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create normal or QT interfaces and
    interact with them with a mouse and slider, but we can create different types
    of buttons as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Buttons are only supported in QT Windows.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of buttons supported are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The `push` button
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `checkbox`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `radiobox`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The buttons only appear in the control panel. The control panel is an independent
    window per program, where we can attach buttons and track bars.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: To show the control panel, we can push the last toolbar button, right-click
    on any part of the QT window, and select the **Display properties** window or
    the *Ctrl* + *P* shortcut.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to create a basic sample with buttons. The code is large, and
    we will first explain the main function and later explain each callback separately
    to understand each one of them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are going to apply three types of blur fiters, a sobel fiter, and a color
    conversion to gray. All these filters are optional and the user can choose each
    one of them using the buttons that we are going to create. Then, in order to get
    the status of each filter, we create three global Boolean variables:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the main function after we load the image and create the window, we have
    to use the `createButton` function to create each button.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three button types defined in OpenCV, which are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`QT_CHECKBOX`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QT_RADIOBOX`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QT_PUSH_BUTTON`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each button has five parameters with the following order:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The button name
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback function
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to user variable data passed to callback
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button type
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default initialized state used for the `checkbox` and `radiobox` button
    types
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we create a blur checkbox button, two radio buttons for color conversion,
    and a push button for the Sobel filter:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the most important part of the main function. We are going to explore
    the callback functions. Each callback changes its status variable to call another
    function called `applyFilters` and adds the filters activated by the input image:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `applyFilters` function checks the status variable for each filter:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To change the color to gray, we use the `cvtColor` function that accepts three
    parameters: an input image, an output image, and the color conversion type.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful color spaces conversions are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: RGB or BGR to gray (`COLOR_RGB2GRAY, COLOR_BGR2GRAY`)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to YcrCb (or YCC) (`COLOR_RGB2YCrCb, COLOR_BGR2YCrCb`)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to HSV (`COLOR_RGB2HSV, COLOR_BGR2HSV`)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to Luv (`COLOR_RGB2Luv, COLOR_BGR2Luv`)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gray to RGB or BGR (`COLOR_GRAY2RGB, COLOR_GRAY2BGR`)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that the code is easy to memorize.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that OpenCV works, by default, with the BGR format, and the color conversion
    is different for RGB and BGR, when converting to gray. Some developers think that
    gray equals *R+G+B/3*, but the optimal gray value is called **luminosity** and
    has the formula *0.21*R + 0.72*G + 0.07*B*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The blur filter was described in the previous section. Finally, if the `applySobel`
    variable is `true`, we apply the sobel filter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The sobel filter is an image derivatives that uses the sobel operator, commonly
    used to detect edges. OpenCV allow us to generate different derivatives with different
    kernel sizes, but the most common is a 3x3 kernel used to calculate the `x` derivatives
    or `y` derivatives.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important sobel parameters are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: An input image
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output image
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output image depth (`CV_8U`, `CV_16U`, `CV_32F`, `CV_64F`)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the derivatives x
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the derivatives y
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel size (3 value by default)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To generate a 3x3 kernel and first `x` order derivatives, we have to use the
    following parameters:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To generate the `y` order derivatives, we use the following parameters:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our example, we use the `x` and `y` derivatives simultaneously to overwrite
    the input:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the `x` and `y` derivatives is as shown:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding buttons to a user interface](img/B04283_03_09.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: OpenGL support
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV includes OpenGL support. OpenGL is a graphical library that is integrated
    in graphic cards as a standard. OpenGL allow us to draw from 2D to complex 3D
    scenes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV includes OpenGL support due to the importance of representing 3D spaces
    in some tasks. To allow a window support in OpenGL, we have to set up the `WINDOW_OPENGL`
    flag when we create the window with the `namedWindow` call.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a window with OpenGL support and draws a rotated
    plane that shows the web camera frames:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's understand the code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to create the required global variables where we store the
    video capture, save the frames, control the animation angle plane, and the OpenGL
    texture:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In our main function, we have to create the video camera capture to retrieve
    the camera frames:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the camera is opened correctly, then we have to create our window with OpenGL
    support using the `WINDOW_OPENGL` flag:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our example, we want to draw the images in a plane that come from the web
    camera, and then we need to enable the OpenGL textures:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we are ready to draw with OpenGL in our window, but we need set up a draw
    OpenGL callback such as a typical OpenGL application. OpenCV give us the `setOpenGLDrawCallback`
    function that has two parameters: the window name and the callback function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the OpenCV window and callback function defined, we need to create a loop
    to load the texture and update the window content by calling the OpenGL draw callback;
    finally, we need to update the angle position.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the window content, we use the OpenCV function update window with
    the window name as the parameter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are in the loop while the user press the *q* key.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Before we compile our application sample, we need to define the `loadTexture`
    function and our `on_opengl` callback draw function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadTexture` function converts our `Mat` frame to an OpenGL texture image
    that is ready to be loaded and used in each callback drawing. Before we load the
    image as a texture, we need to ensure that we have data in our frame matrix to
    check whether the data variable object is not empty:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTexture`函数将我们的`Mat`框架转换为OpenGL纹理图像，该图像已准备好在每次回调绘制中使用。在我们将图像作为纹理加载之前，我们需要确保我们的框架矩阵中有数据，以检查数据变量对象是否不为空：'
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we have data in our matrix frame, then we can create the OpenGL texture
    binding and set the OpenGL texture parameters as a linear interpolation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在矩阵框架中有数据，那么我们可以创建OpenGL纹理绑定并设置OpenGL纹理参数为线性插值：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we need to define how the pixels are stored in our matrix and how to generate
    the pixels with the OpenGL''s `glTexImage2D` function. It''s very important to
    note that OpenGL uses the RGB format and OpenCV has the BGR format by default,
    and we need to set it up correctly in this function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义像素在矩阵中的存储方式以及如何使用OpenGL的`glTexImage2D`函数生成像素。非常重要的一点是，OpenGL使用RGB格式，而OpenCV默认使用BGR格式，我们需要在这个函数中正确设置它：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we only need to finish drawing our plane for every callback when we call
    the `updateWindow` in the main loop. We use the common OpenGL functions, and then
    we load the identity OpenGL matrix to reset all our previous changes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在主循环中调用`updateWindow`时完成绘制我们的平面。我们使用常见的OpenGL函数，然后加载单位OpenGL矩阵以重置我们之前的所有更改：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Load the frame texture into the memory:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将框架纹理加载到内存中：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before we draw our plane, we apply all the transformations to our scene; in
    our case, we are going to rotate our plane in the (1, 1, 1) axis:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制我们的平面之前，我们将所有变换应用到我们的场景中；在我们的情况下，我们将在(1, 1, 1)轴上旋转我们的平面：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we have the scene set correctly to draw our plane, so we will draw quads
    faces and use `glBegin(GL_QUADS)`for this purpose:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经正确设置了场景来绘制我们的平面，所以我们将绘制四边形面并使用`glBegin(GL_QUADS)`来完成这个目的：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We draw a plane centered at the (0, 0) position with a two units of size. Then,
    we have to define the texture coordinate to be used and the vertex position using
    the `glTextCoord2D` and `glVertex2D` functions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以(0, 0)位置为中心绘制一个大小为两单位的平面。然后，我们必须使用`glTextCoord2D`和`glVertex2D`函数定义要使用的纹理坐标和顶点位置：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This OpenGL code is becoming obsolete, but it is important to better understand
    the OpenCV and OpenGL integration without the complex OpenGL code. To introduce
    you to modern OpenGL, read *Introduction to Modern OpenGL*, *Pack Publishing*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段OpenGL代码正在变得过时，但了解OpenCV和OpenGL集成而不使用复杂的OpenGL代码非常重要。为了向您介绍现代OpenGL，请阅读*现代OpenGL入门*，*Pack
    Publishing*。
- en: 'We can see the result in the following image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图像中看到结果：
- en: '![OpenGL support](img/B04283_03_10.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![OpenGL支持](img/B04283_03_10.jpg)'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create different types of user interface
    to show images or 3D interfaces using OpenGL. We learned how to create sliders
    and buttons and draw in 3D. We learned some basic image processing filters as
    well.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建不同类型的用户界面来使用OpenGL显示图像或3D界面。我们学习了如何创建滑块和按钮，并在3D中绘制。我们还学习了一些基本的图像处理过滤器。
- en: In the next chapter, we will learn how to construct a complete photo tool application
    using all that we learned using the graphical user interface. We will also learn
    how to apply multiple filters to an input image.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用图形用户界面构建一个完整的照片工具应用程序，使用我们所学到的所有知识。我们还将学习如何将多个过滤器应用到输入图像上。
