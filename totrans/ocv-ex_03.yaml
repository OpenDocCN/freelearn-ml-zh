- en: Chapter 3. Learning the Graphical User Interface and Basic Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned the basic classes and structures of OpenCV
    and the most important class called `Mat`.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to read and save images, videos, and the internal structure in
    the memory of images.
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to work now, but we need to show our results and have some basic
    interaction with our images. OpenCV provides us with a few basic user interfaces
    to work with and help create our applications and prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how the user interface works, we are going to create a
    small application called **PhotoTool** at the end of this chapter. In this application,
    we will learn how to use filters and color conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic OpenCV user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenCV QT interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sliders and buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An advanced user interface—OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the OpenCV user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV has its own cross-operating system user interface that allows developers
    to create their own applications without the need to learn complex libraries for
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenCV user interface is basic, but it gives Computer Vision developers
    the basic functions to create and manage their software developments. All of them
    are native and optimized for real-time use.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV provides two options for the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic interface based on native user interfaces, such as Cocoa or Carbon for
    OS X and GTK for Linux or Windows user interfaces, that are selected by default
    when you compile OpenCV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slightly more advanced interface based on the QT library that is cross-platform.
    You have to enable the QT option manually in CMake before you compile OpenCV.![Introducing
    the OpenCV user interface](img/B04283_03_01.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic graphical user interface with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create a basic user interface with OpenCV. The OpenCV user interface
    allows us to create windows, add images to it, move it, resize it, and destroy
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interface is in the OpenCV''s module called `highui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task that we need to perform in order to enable a Graphical User
    Interface is import the OpenCV''s module `highui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are prepared to create our new windows, and then we need to load some
    images that are to be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the windows, we use the `namedWindow` function. This function has
    two parameters: the first parameter is a constant string with the window''s name,
    and the second parameter is the flags that we require, which is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we create two windows: the first window is called `Lena` and the
    second is called `Photo`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are the three flags for QT and native interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WINDOW_NORMAL`: This flag allows the user to resize the window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_AUTOSIZE`: If this flag is set, the window size is automatically adjusted
    to fit the display image and it is not possible to resize the window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_OPENGL`: This flag enables OpenGL support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'QT has some more flags, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WINDOW_FREERATIO` or `WINDOW_KEEPRATIO`: If set to `WINDOW_FREERATIO`, then
    the image is adjusted with no respect to its ratio. If set to `WINDOW_FREERATIO`,
    then the image is adjusted with respect to its ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_GUI_NORMAL` or `CV_GUI_EXPANDED`: The first flag enables the basic interface
    without the status bar and toolbar. The second flag enables the most advanced
    graphical user interface with the status bar and toolbar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we compile OpenCV with QT, all the windows that we create are, by default,
    in the expanded interface, but we can use native and more basic interfaces by
    adding the `CV_GUI_NORMAL` flag.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the flags are `WINDOW_AUTOSIZE`, `WINDOW_KEEPRATIO`, and `CV_GUI_EXPANDED`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create multiple windows, they are superimposed one above the other,
    but we can move the windows to any area of our desktop with the `moveWindow` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our code, we move the `Lena` window to the left 10 pixels 10 pixels to the
    top; and the `Photo` window to the left 520 pixels and 10 pixels to the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After showing the images that we loaded previously with the `imshow` function,
    we resize the `Lena` window to 512 pixels, calling the `resizeWindow` function.
    This function has three parameters: `window name`, `width`, and `height`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The specific window size is for the image area. Toolbars are not counted. Only
    windows without the enabled `WINDOW_AUTOSIZE` flag can be resized.
  prefs: []
  type: TYPE_NORMAL
- en: 'After waiting for a key press with the `waitKey` function, we will remove or
    delete our windows with the `destroyWindow` function in which the name of the
    window is the only parameter that is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV has a function that is used to remove all the windows that we create
    in only one call. The function is called `destroyAllWindows`. To show how this
    function works, in our sample we create 10 windows and wait for a key press. When
    the user presses any key, we destroy all the windows. Anyway, OpenCV automatically
    handles the destruction of all the windows when the application is terminated,
    and it is not necessary to call this function at the end of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this code can be seen in the following images in two steps. The
    first image shows two windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic graphical user interface with OpenCV](img/B04283_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After pressing any key, the application continues and draws several windows
    by changing their positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic graphical user interface with OpenCV](img/B04283_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The graphical user interface with QT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QT user interface gives us more control and options to work with our images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface is divided into three main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: The toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status bar![The graphical user interface with QT](img/B04283_03_04.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The toolbar has the following buttons from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: Four buttons for panning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom x1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom x30 and show labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the current image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the properties windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These options can be seen more clearly in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical user interface with QT](img/B04283_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The image area shows an image and a contextual menu when we push the right
    mouse button over the image. This area can show an overlay message at the top
    of the area using the `displayOverlay` function. This function accepts three parameters:
    the window name, the text that we want to show, and the period in milliseconds
    when the overlay text is displayed. If the time is set to `0`, the text never
    disappears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![The graphical user interface with QT](img/B04283_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the status bar shows the bottom part of the window, the pixel value,
    and the position of the coordinates in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical user interface with QT](img/B04283_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the status bar to show messages, such as an overlay. The function
    that can change the status bar message is `displayStatusBar`. This function has
    the same parameters as overlay functions: the window name, the text to show, and
    the period of time to show it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical user interface with QT](img/B04283_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding slider and mouse events to our interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mouse events and slider controls are very useful in Computer Vision and OpenCV.
    Using these controls, users can interact directly with the interface and change
    the properties of their input images or variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to introduce you to the concepts of adding slider
    and mouse events for basic interactions. To understand this correctly, we will
    create a small project, where we paint green circles in the image using the mouse
    events and blur the image with the slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the code!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a variable to save the slider position, and then we need to
    save the slider position for access from other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define our callbacks for our slider and mouse events that are required
    for the OpenCV `setMouseCallbac` and `createTrackbar` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we load an image and create a new window called `Lena`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to create the slider. OpenCV has the `createTrackbar` function that
    is used to generate a slider with the following parameters in order:'
  prefs: []
  type: TYPE_NORMAL
- en: The track bar name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The window name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer pointer to be used as a value; this parameter is optional. If the
    pointer value is set, the slider gets this position during its creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximal position on the slider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback function when the position slider changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user data to be sent to the callback. It can be used to send data to callbacks
    without using global variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After creating the slider, we add the mouse events that allow you to paint
    circles when the user pushes the left mouse button. OpenCV has the `setMouseCallback`
    function. This function has three parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The window name where we get the mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `callback` function to be called when there are mouse interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User data refers to any data that will be sent to the callback function when
    it''s fired. In our example, we''ll send the entire `Lena` image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finalize the `main` function, we only need to initialize the image with
    the same parameter as the slider. To perform the initialization, we only need
    to call the `callback` function manually and wait for events before we close the
    windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The slider callback applies a basic blur filter to the image using the slider
    value as a blur quantity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function checks whether the slider value is 0 using the `pos` variable;
    in this case, we do not apply the filter because it generates a bad execution.
    We cannot apply a 0 pixels blur.
  prefs: []
  type: TYPE_NORMAL
- en: After checking the slider value, we create an empty matrix called `imgBlur`
    to store the blur result.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the image sent via the user data in the `callback` function, we
    have to cast the `void* userData` to correct the `pointer Mat*` image type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have the correct variables to be applied to the blur filter. The blur
    function applies a basic median filter to an input image, `*img` in our case,
    to an output image. The last parameter is the size of a blur kernel (a kernel
    is a small matrix used to calculate the means of convolution between the kernel
    and image) that we want to apply. In our case, we are using a squared kernel of
    the `pos` size.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we only need to update the image interface using the `imshow` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mouse events callback has five input parameters: the first parameter defines
    the event type, the second and third parameters define the mouse position, the
    fourth parameter defines the wheel movement, and the fifth parameter defines the
    user input data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mouse event types are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MOUSEMOVE` | When the user moves the mouse |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONDOWN` | When the user pushes the left mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONDOWN` | When the user pushes the right mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONDOWN` | When the user pushes the middle mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONUP` | When the user releases the left mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONUP` | When the user releases the right mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONUP` | When the user releases the middle mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONDBLCLK` | When the user double-clicks with the left mouse button
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONDBLCLK` | When the user double-clicks with the right mouse
    button |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONDBLCLK` | When the user double-clicks with the middle mouse
    button |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENTMOUSEWHEEL` | When the user does a vertical scroll with the mouse wheel
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MOUSEHWHEEL` | When the user does a horizontal scroll with the mouse
    wheel |'
  prefs: []
  type: TYPE_TB
- en: 'In our sample, we only go to manage events that come from a left-push mouse
    button, and then any other event different from `EVENT_LBUTTONDOWN` is discarded.
    After discarding other events, we get the input image, such as a slider callback,
    and draw a circle in the image with the circle OpenCV function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Adding buttons to a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create normal or QT interfaces and
    interact with them with a mouse and slider, but we can create different types
    of buttons as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Buttons are only supported in QT Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of buttons supported are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `push` button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `checkbox`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `radiobox`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The buttons only appear in the control panel. The control panel is an independent
    window per program, where we can attach buttons and track bars.
  prefs: []
  type: TYPE_NORMAL
- en: To show the control panel, we can push the last toolbar button, right-click
    on any part of the QT window, and select the **Display properties** window or
    the *Ctrl* + *P* shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to create a basic sample with buttons. The code is large, and
    we will first explain the main function and later explain each callback separately
    to understand each one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to apply three types of blur fiters, a sobel fiter, and a color
    conversion to gray. All these filters are optional and the user can choose each
    one of them using the buttons that we are going to create. Then, in order to get
    the status of each filter, we create three global Boolean variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the main function after we load the image and create the window, we have
    to use the `createButton` function to create each button.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three button types defined in OpenCV, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QT_CHECKBOX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QT_RADIOBOX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QT_PUSH_BUTTON`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each button has five parameters with the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: The button name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to user variable data passed to callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default initialized state used for the `checkbox` and `radiobox` button
    types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we create a blur checkbox button, two radio buttons for color conversion,
    and a push button for the Sobel filter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the most important part of the main function. We are going to explore
    the callback functions. Each callback changes its status variable to call another
    function called `applyFilters` and adds the filters activated by the input image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `applyFilters` function checks the status variable for each filter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To change the color to gray, we use the `cvtColor` function that accepts three
    parameters: an input image, an output image, and the color conversion type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful color spaces conversions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: RGB or BGR to gray (`COLOR_RGB2GRAY, COLOR_BGR2GRAY`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to YcrCb (or YCC) (`COLOR_RGB2YCrCb, COLOR_BGR2YCrCb`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to HSV (`COLOR_RGB2HSV, COLOR_BGR2HSV`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to Luv (`COLOR_RGB2Luv, COLOR_BGR2Luv`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gray to RGB or BGR (`COLOR_GRAY2RGB, COLOR_GRAY2BGR`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that the code is easy to memorize.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that OpenCV works, by default, with the BGR format, and the color conversion
    is different for RGB and BGR, when converting to gray. Some developers think that
    gray equals *R+G+B/3*, but the optimal gray value is called **luminosity** and
    has the formula *0.21*R + 0.72*G + 0.07*B*.
  prefs: []
  type: TYPE_NORMAL
- en: The blur filter was described in the previous section. Finally, if the `applySobel`
    variable is `true`, we apply the sobel filter.
  prefs: []
  type: TYPE_NORMAL
- en: The sobel filter is an image derivatives that uses the sobel operator, commonly
    used to detect edges. OpenCV allow us to generate different derivatives with different
    kernel sizes, but the most common is a 3x3 kernel used to calculate the `x` derivatives
    or `y` derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important sobel parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An input image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output image depth (`CV_8U`, `CV_16U`, `CV_32F`, `CV_64F`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the derivatives x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the derivatives y
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel size (3 value by default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To generate a 3x3 kernel and first `x` order derivatives, we have to use the
    following parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To generate the `y` order derivatives, we use the following parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our example, we use the `x` and `y` derivatives simultaneously to overwrite
    the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `x` and `y` derivatives is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding buttons to a user interface](img/B04283_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OpenGL support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV includes OpenGL support. OpenGL is a graphical library that is integrated
    in graphic cards as a standard. OpenGL allow us to draw from 2D to complex 3D
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV includes OpenGL support due to the importance of representing 3D spaces
    in some tasks. To allow a window support in OpenGL, we have to set up the `WINDOW_OPENGL`
    flag when we create the window with the `namedWindow` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a window with OpenGL support and draws a rotated
    plane that shows the web camera frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to create the required global variables where we store the
    video capture, save the frames, control the animation angle plane, and the OpenGL
    texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main function, we have to create the video camera capture to retrieve
    the camera frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the camera is opened correctly, then we have to create our window with OpenGL
    support using the `WINDOW_OPENGL` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we want to draw the images in a plane that come from the web
    camera, and then we need to enable the OpenGL textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to draw with OpenGL in our window, but we need set up a draw
    OpenGL callback such as a typical OpenGL application. OpenCV give us the `setOpenGLDrawCallback`
    function that has two parameters: the window name and the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With the OpenCV window and callback function defined, we need to create a loop
    to load the texture and update the window content by calling the OpenGL draw callback;
    finally, we need to update the angle position.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the window content, we use the OpenCV function update window with
    the window name as the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are in the loop while the user press the *q* key.
  prefs: []
  type: TYPE_NORMAL
- en: Before we compile our application sample, we need to define the `loadTexture`
    function and our `on_opengl` callback draw function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadTexture` function converts our `Mat` frame to an OpenGL texture image
    that is ready to be loaded and used in each callback drawing. Before we load the
    image as a texture, we need to ensure that we have data in our frame matrix to
    check whether the data variable object is not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have data in our matrix frame, then we can create the OpenGL texture
    binding and set the OpenGL texture parameters as a linear interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define how the pixels are stored in our matrix and how to generate
    the pixels with the OpenGL''s `glTexImage2D` function. It''s very important to
    note that OpenGL uses the RGB format and OpenCV has the BGR format by default,
    and we need to set it up correctly in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need to finish drawing our plane for every callback when we call
    the `updateWindow` in the main loop. We use the common OpenGL functions, and then
    we load the identity OpenGL matrix to reset all our previous changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the frame texture into the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we draw our plane, we apply all the transformations to our scene; in
    our case, we are going to rotate our plane in the (1, 1, 1) axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the scene set correctly to draw our plane, so we will draw quads
    faces and use `glBegin(GL_QUADS)`for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We draw a plane centered at the (0, 0) position with a two units of size. Then,
    we have to define the texture coordinate to be used and the vertex position using
    the `glTextCoord2D` and `glVertex2D` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This OpenGL code is becoming obsolete, but it is important to better understand
    the OpenCV and OpenGL integration without the complex OpenGL code. To introduce
    you to modern OpenGL, read *Introduction to Modern OpenGL*, *Pack Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the result in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenGL support](img/B04283_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create different types of user interface
    to show images or 3D interfaces using OpenGL. We learned how to create sliders
    and buttons and draw in 3D. We learned some basic image processing filters as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to construct a complete photo tool application
    using all that we learned using the graphical user interface. We will also learn
    how to apply multiple filters to an input image.
  prefs: []
  type: TYPE_NORMAL
