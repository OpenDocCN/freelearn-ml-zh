<html><head></head><body>
		<div id="_idContainer042">
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/><em class="italic">Chapter 3</em>: Data Analysis on Streaming Data</h1>
			<p>Now that you have seen an introduction to streaming data and streaming use cases, as well as an introduction to streaming architecture, it is time to enter into the core of this book: analytics and machine learning.</p>
			<p>As you probably know, descriptive statistics and data analysis are the entry points into machine learning, but they are also often used as a standalone use case. In this chapter, you will first discover descriptive statistics from a traditional statistics viewpoint. Some parts of traditional statistics focus on making correct estimations of descriptive statistics when only part of the data is available.</p>
			<p>In streaming, you will encounter such problems in an even more impacting manner than in batch data. Through a continuous data collection process, your descriptive statistics will continue changing on every new data point. This chapter will propose some solutions for dealing with this.</p>
			<p>You will also build a data visualization based on those descriptive statistics. After all, the human brain is wired in such a way that visual presentations are much easier to read than data matrices. Data visualization is an important tool to master and comes with some additional reflections to take into account when working on streaming data.</p>
			<p>The chapter will conclude with a short introduction to statistical process control. This subdomain of statistics focuses on analyzing a continuous stream of measurements. Although streaming analytics was not yet a thing when process control was invented, it became a new, important use case for those analytical methods.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Descriptive statistics on streaming data</li>
				<li>Introduction to sampling theory</li>
				<li>Overview of the main descriptive statistics</li>
				<li>Real-time visualizations</li>
				<li>Basic alerting systems</li>
			</ul>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Technical requirements</h1>
			<p>You can find all the code for this book on GitHub at the following link: <a href="https://github.com/PacktPublishing/Machine-Learning-for-Streaming-Data-with-Python">https://github.com/PacktPublishing/Machine-Learning-for-Streaming-Data-with-Python</a>. If you are not yet familiar with Git and GitHub, the easiest way to download the notebooks and code samples is the following:</p>
			<ol>
				<li>Go to the link of the repository.</li>
				<li>Click the green <strong class="bold">Code</strong> button.</li>
				<li>Select <strong class="bold">Download ZIP</strong>.</li>
			</ol>
			<p>When you download the ZIP file, unzip it in your local environment and you will be able to access the code through your preferred Python editor.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Python environment</h2>
			<p>To follow along with this book, you can download the code in the repository and execute it using your preferred Python editor.</p>
			<p>If you are not yet familiar with Python environments, I would advise you to check out Anaconda (<a href="https://www.anaconda.com/products/individual">https://www.anaconda.com/products/individual</a>), which comes with Jupyter Notebook and JupyterLab, which are both great for executing notebooks. It also comes with Spyder and VSCode for editing scripts and programs.</p>
			<p>If you have difficulty installing Python or the associated programs on your machine, you can check out Google Colab (<a href="https://colab.research.google.com/">https://colab.research.google.com/</a>) or Kaggle Notebooks (<a href="https://www.kaggle.com/code">https://www.kaggle.com/code</a>), which both allow you to run Python code in online notebooks for free, without any setup to do.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code in the book will generally use Colab and Kaggle Notebooks with Python version 3.7.13 and you can set up your own environment to mimic this. </p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Descriptive statistics on streaming data</h1>
			<p>Computing descriptive statistics is generally one of the first things covered in statistics and data analytics courses. Descriptive statistics are measurements that data practitioners are very familiar with, as they allow you to summarize a dataset in a small set of indicators.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Why are descriptive statistics different on streaming data?</h2>
			<p>On regular datasets, you can <a id="_idIndexMarker151"/>use almost any statistical software to easily obtain descriptive statistics using well-known formulas. On streaming datasets, unfortunately, this is much less obvious. </p>
			<p>The problem with applying descriptive statistics on streaming data is that the formulas are made for finding fixed measurements. In streaming data, you continue to receive new data, which unfortunately may alter your values. When you do not have all the data of a variable, you cannot be certain about its value. In the following section, you will get an introduction to sampling theory, the domain that deals with estimating parameters from data samples.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Introduction to sampling theory</h1>
			<p>Before diving into <a id="_idIndexMarker152"/>descriptive statistics in streaming data, it is important to understand the basics of descriptive statistics in regular data. The domain that deals with the estimation of descriptive statistics using samples of the data is called <strong class="bold">sampling theory</strong>.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Comparing population and sample</h2>
			<p>In regular statistics, the concept of population and sample is very important. Let's have a look at the definitions before diving into it further:</p>
			<ul>
				<li><strong class="bold">Individual</strong>: Individuals are the <a id="_idIndexMarker153"/>individual objects or people that are included in a study. If your study looks at products on a production line and you measure the characteristics of a product, then the individual is the product. If you are doing a study on website sales and you track data on each website visitor, then your individual is the website visitor.</li>
				<li><strong class="bold">Population</strong>: A statistical population is generally defined as the pool of individuals from which a sample is drawn. The population contains any individual that would theoretically qualify to participate in a study. In the production line example, the population would be all the products. In the website example, the population would be all the website visitors.</li>
				<li><strong class="bold">Sample</strong>: A sample is <a id="_idIndexMarker154"/>defined as a subset of the population on which you are going to execute your study. In most statistical studies, you work with a sample; you do not have data on all possible individuals in the world, but rather, you have a subset, which you hope is large enough. There are numerous statistical tools that help you to decide whether this is the case.</li>
			</ul>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Population parameters and sample statistics</h2>
			<p>When computing <a id="_idIndexMarker155"/>descriptive statistics on a sample, they are <a id="_idIndexMarker156"/>called <strong class="bold">sample statistics</strong>. Sample statistics are based on a sample, and although they are generally reliable estimates of the population, they are not perfect about the population.</p>
			<p>For the population, the term used is <strong class="bold">population parameters</strong>. They are accurate, and there is no measurement error here. However, they are, in most cases, impossible to measure, as you'll never have enough time and money to measure every individual in the population.</p>
			<p>Sample statistics allow you to estimate population parameters.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Sampling distribution</h2>
			<p>The sampling distribution is the <a id="_idIndexMarker157"/>distribution of the statistics. Imagine that a population of website customers spends, on average, 300 seconds (5 minutes) on your website. If you were drawing 100 random samples of your website visitors, and you computed the mean of each of those samples, you'd probably end up with 100 different estimates.</p>
			<p>The distribution of those estimates is called the <a id="_idIndexMarker158"/><strong class="bold">sampling distribution</strong>. It will follow a normal distribution in which the mean should be relatively close to the population mean. The standard deviation of the sampling distribution is called the <a id="_idIndexMarker159"/><strong class="bold">standard error</strong>. The standard error is used to estimate the stability or representativeness of your samples.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Sample size calculations and confidence level</h2>
			<p>In <a id="_idIndexMarker160"/>traditional statistics, sample <a id="_idIndexMarker161"/>size calculations can be used to define the number of elements that you need to have in a sample for the sample to be reliable. You need to define a confidence level and a sample size calculation formula for your specific statistic. Together, they will allow you to identify the sample size needed for reliably estimating your population parameters using sample statistics.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Rolling descriptive statistics from streaming</h2>
			<p>In streaming analytics, <a id="_idIndexMarker162"/>you will have more and more data as time goes on. It would be possible to recompute the overall statistics at the reception of a new data point. At some point, new data points will have very little impact compared to a large number of data points in the past. If a change occurs in the stream, it will take time for this change to be reflected in the descriptive statistic, and this is, therefore, not generally the best approach.</p>
			<p>The general approach for descriptive statistics on streaming data is to use a rolling window for computing and recomputing the descriptive statistics. Once you have decided on a definition of your window, you compute the statistics for all observations that are in your window.</p>
			<p>An example can be to choose a window of the last 25 products. This way, every time a new product measurement comes into your analytical application, you compute the average of this product together with the 24 preceding products.</p>
			<p>The more observations you have in your window, the less impact your last observation has. This can be great if you want to avoid false alarms, but it can be dangerous if you need every single product to be perfect. Choosing small numbers of individuals in your window will make your descriptive statistics vary heavily if a variation is present in your descriptive statistics.</p>
			<p>Tuning the window period is a good exercise to do when trying to fine-tune your descriptive statistics. By trying out different approaches, you can find the method that works best for your use case.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Exponential weight</h2>
			<p>Another tool <a id="_idIndexMarker163"/>that you can use for fine-tuning your descriptive statistics on streaming data is exponential weighting. Exponential weighting puts exponentially more weight on recent observations and less on past observations. This allows you to take in more historical observations without affecting the importance of recent observations.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Tracking convergence as an additional KPI</h2>
			<p>When tracking <a id="_idIndexMarker164"/><a id="_idIndexMarker165"/>descriptive statistics on a stream of data, it is a possibility to report multiple time windows of your measurements. For example, you could build a dashboard that informs your clients of the averages of the day, but at the same time, you can report the averages of the last hour and the averages of the last 15 minutes.</p>
			<p>By doing this, you may, for example, give your client the information that the day and hour went well in general (day and hour averages are according to specification), but in the last 15 minutes, your product starts to present problems, and the last 15 minutes' average is not according to specification. With this information, the operators can intervene quickly and stop or change the process according to their needs, without having to worry about the production earlier on in the day.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Overview of the main descriptive statistics</h1>
			<p>Let's now <a id="_idIndexMarker166"/>have a look at the most used descriptive statistics and see how you can adapt them to use a rolling window on any data stream. Of course, as you have seen in the previous chapter, streaming analytics can be executed on a multitude of tools. The important takeaway is to understand which descriptive analytics to use and to have a basis that can be adapted to different streaming input tools.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>The mean</h2>
			<p>The first <a id="_idIndexMarker167"/>descriptive statistic <a id="_idIndexMarker168"/>that will be covered is the mean. The mean is the most commonly used measure of centrality.</p>
			<h3>Interpretation and use</h3>
			<p>Together with other measures of <a id="_idIndexMarker169"/>centrality, such as the <a id="_idIndexMarker170"/>median and the mode, its goal is to describe the center of the distribution of a variable. If the distribution is perfectly symmetrical, the mean, median, and mode will be equal. If there is a skewed distribution, the mean will be affected by the outliers and move in the direction of the skew or the outliers.</p>
			<h3>Formula</h3>
			<p>The <a id="_idIndexMarker171"/>formula for the sample mean is the following:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Formula_03_001.jpg" alt=""/>
				</div>
			</div>
			<p>In this formula, <em class="italic">n</em> is the sample size and <em class="italic">x</em> is the value of the variable in the sample.</p>
			<h3>Code</h3>
			<p>There are many <a id="_idIndexMarker172"/>Python functions that you can use for the mean. One of those is the <strong class="source-inline">numpy</strong> function called <strong class="source-inline">mean</strong>. You can see an example of it used here:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-1</p>
			<pre class="source-code">values = [10,8,12,11,7,10,8,9,12,11,10]</pre>
			<pre class="source-code">import numpy as np</pre>
			<pre class="source-code">np.mean(values)</pre>
			<p>You should obtain a result of <strong class="source-inline">9.8181</strong>.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>The median</h2>
			<p>The <a id="_idIndexMarker173"/>median <a id="_idIndexMarker174"/>is the second measure of the centrality of a variable or a distribution.</p>
			<h3>Interpretation and use</h3>
			<p>Like the mean, the <a id="_idIndexMarker175"/>median is used to <a id="_idIndexMarker176"/>indicate the center. However, a difference from the mean is that the median is not sensitive to outliers and is much less sensitive to skewed distributions.</p>
			<p>An example where this is important is when studying the salaries of a country's population. Salaries are known to follow a strongly skewed distribution. Most people make between a minimum wage and an average wage. Few people make very high amounts of money. When computing the mean, it will be too high to represent the overall population, as it gets boosted upward by the high earners. Using the median is more sensible as it will more closely represent a lot of people.</p>
			<p>The median represents the point where 50% of the people will earn less than this amount and 50% will earn more than this amount.</p>
			<h3>Formula</h3>
			<p>The <a id="_idIndexMarker177"/>formula for the median is relatively complex to read, as it does not work with the actual values, but rather, it takes the middle value after ordering all the values from low to high. If there is an even number of values, there is no middle, so it will take the average of the two middle values:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Formula_03_002.jpg" alt=""/>
				</div>
			</div>
			<p>Here, <em class="italic">x</em> is an ordered list and the brackets indicate indexing on this list.</p>
			<h3>Code</h3>
			<p>You can <a id="_idIndexMarker178"/>compute the median as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-2</p>
			<pre class="source-code">values = [10,8,12,11,7,10,8,9,12,11,10]</pre>
			<pre class="source-code">import numpy as np</pre>
			<pre class="source-code">np.median(values)</pre>
			<p>The result of this computation should be <strong class="source-inline">10</strong>.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>The mode</h2>
			<p>The mode is the third <a id="_idIndexMarker179"/>commonly used <a id="_idIndexMarker180"/>measure of centrality in descriptive statistics. This section will explain its use and implementation in Python.</p>
			<h3>Interpretation and use</h3>
			<p>The mode represents the value that was present <a id="_idIndexMarker181"/>the most often in the data. If you have a continuous (numeric) variable, then you generally create bins to regroup your data before computing the mode. This way, you can make sure that it is representative.</p>
			<h3>Formula</h3>
			<p>The <a id="_idIndexMarker182"/>easiest way to find the mode is to count the number of occurrences per group or per value and take the value with the highest occurrences as the mode. This will work for categorical as well as numerical variables.</p>
			<h3>Code</h3>
			<p>You can use the <a id="_idIndexMarker183"/>following <a id="_idIndexMarker184"/>code to find the mode in Python:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-3</p>
			<pre class="source-code">values = [10,8,12,11,7,10,8,9,12,11,10]</pre>
			<pre class="source-code">import statistics</pre>
			<pre class="source-code">statistics.mode(values)</pre>
			<p>The obtained result should be <strong class="source-inline">10</strong>.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Standard deviation</h2>
			<p>You will now see a <a id="_idIndexMarker185"/>number <a id="_idIndexMarker186"/>of descriptive statistics for variability, starting with the standard deviation.</p>
			<h3>Interpretation and use</h3>
			<p>The standard <a id="_idIndexMarker187"/>deviation is a <a id="_idIndexMarker188"/>commonly used measure for variability. Measures for variability show the spread around the center that is present in your data. For example, where the mean can indicate the average salary of your population, it does not tell you whether everyone is close to this value or whether everyone is very far away. Measures of variability allow you to obtain this information.</p>
			<h3>Formula</h3>
			<p>The <a id="_idIndexMarker189"/>sample standard deviation can be computed as follows:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Formula_03_003.jpg" alt=""/>
				</div>
			</div>
			<h3>Code</h3>
			<p>You can compute the sample standard deviation as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-4</p>
			<pre class="source-code">values = [10,8,12,11,7,10,8,9,12,11,10]</pre>
			<pre class="source-code">import numpy as np</pre>
			<pre class="source-code">np.std(values, ddof=1)</pre>
			<p>You should obtain a result of <strong class="source-inline">1.66</strong>.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Variance</h2>
			<p>The <a id="_idIndexMarker190"/>variance is another measure of <a id="_idIndexMarker191"/>variability, and it is closely related to the standard deviation. Let's see how it works.</p>
			<h3>Interpretation and use</h3>
			<p>The <a id="_idIndexMarker192"/>variance is simply the square of the <a id="_idIndexMarker193"/>standard deviation. It is sometimes easier to work with the formula of variance, as it does not involve taking the square root. It is, therefore, easier to handle in some mathematical operations. The standard deviation is generally easier to use for interpretation.</p>
			<h3>Formula</h3>
			<p>The <a id="_idIndexMarker194"/>formula for variance is the following:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Formula_03_004.jpg" alt=""/>
				</div>
			</div>
			<h3>Code</h3>
			<p>You can use the <a id="_idIndexMarker195"/>following code for computing the sample variance:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-5</p>
			<pre class="source-code">values = [10,8,12,11,7,10,8,9,12,11,10]</pre>
			<pre class="source-code">import numpy as np</pre>
			<pre class="source-code">np.var(values, ddof=1)</pre>
			<p>The obtained result should be <strong class="source-inline">2.76</strong>.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Quartiles and interquartile range</h2>
			<p>The third measure of <a id="_idIndexMarker196"/>variability that will be <a id="_idIndexMarker197"/>covered is the <a id="_idIndexMarker198"/><strong class="bold">interquartile range</strong> (<strong class="bold">IQR</strong>). This will conclude the statistics for describing variability.</p>
			<h3>Interpretation and use</h3>
			<p>The IQR is a <a id="_idIndexMarker199"/>measure that is related to the <a id="_idIndexMarker200"/>median in some way. If you remember, the median is the point where 50% of the values are lower than it and 50% of the values are higher; it is really a middle point.</p>
			<p>The same can be done with a 25/75% split instead of a 50/50% split. In that case, they are called quartiles. By computing the first quartile (25% is lower and 75% is higher) and the third quartile (75% is lower and 25% is higher), you can get an idea of the variability of your data as well. The difference between the third quartile and the first quartile is called the IQR.</p>
			<h3>Formula</h3>
			<p>The formula for the <a id="_idIndexMarker201"/>IQR is simply the difference between the third and first quartiles, as follows:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Formula_03_005.jpg" alt=""/>
				</div>
			</div>
			<h3>Code</h3>
			<p>You can use the <a id="_idIndexMarker202"/>following Python code to compute the IQR:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-6</p>
			<pre class="source-code">values = [10,8,12,11,7,10,8,9,12,11,10]</pre>
			<pre class="source-code">import scipy.stats</pre>
			<pre class="source-code">scipy.stats.iqr(values)</pre>
			<p>You should find an IQR of <strong class="source-inline">2.5</strong>.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Correlations</h2>
			<p>Correlation is a <a id="_idIndexMarker203"/>descriptive statistic for describing relations hips between multiple variables. Let's see how it works.</p>
			<h3>Interpretation and use</h3>
			<p>Now <a id="_idIndexMarker204"/>that you have seen multiple measures of <a id="_idIndexMarker205"/>centrality and variability, you will now discover a descriptive statistic that allows you to study relations hips between two variables. The main descriptive statistic for this is <strong class="bold">correlation</strong>. There are multiple formulas and definitions of correlation, but here, you will see the most common one: Pearson correlation.</p>
			<p>The correlation coefficient will be <strong class="source-inline">-1</strong> for strong negative correlation, <strong class="source-inline">1</strong> for strong positive correlation, <strong class="source-inline">0</strong> for no correlation, or somewhere in between.</p>
			<h3>Formula</h3>
			<p>The formula <a id="_idIndexMarker206"/>for Pearson's correlation coefficient is shown here:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Formula_03_006.jpg" alt=""/>
				</div>
			</div>
			<h3>Code</h3>
			<p>You can <a id="_idIndexMarker207"/>compute it easily in Python using the following code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-7</p>
			<pre class="source-code">values_x = [10,8,12,11,7,10,8,9,12,11,10]</pre>
			<pre class="source-code">values_y = [12,9,11,11,8,11,9,10,14,10,9]</pre>
			<pre class="source-code">import numpy as np</pre>
			<pre class="source-code">np.corrcoef(values_x,values_y)</pre>
			<p>You should obtain a correlation matrix in which you can read that the correlation coefficient is <strong class="source-inline">0.77</strong>. This indicates a positive correlation between the two variables.</p>
			<p>Now that you have seen some numerical ways to describe data, it will be useful to discover some methods for visualizing this data in a more user-friendly way. The following section goes deeper into this.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Real-time visualizations</h1>
			<p>In this part, you <a id="_idIndexMarker208"/>will see how to set up a simple real-time visualization using Plotly's Dash. This tool is a great dashboarding tool for data scientists, as it is easy to learn and does not require much except for a Python environment.</p>
			<p>The code is a little bit too long to show in the book, but you can find the Python file (called <strong class="source-inline">ch3-realtimeviz.py</strong>) in the GitHub repository.</p>
			<p>In the code, you can see how a simple real-time graph is built. The general setup of the code is to have an app. You define the layout in the app using HTML-like building blocks. In this case, the layout contains one div (one block of content) in which there is a graph.</p>
			<p>The main component is the use of the <strong class="source-inline">Interval</strong> function in this layout. Using this will make the dashboard update automatically at a given frequency. It is fast enough to consider these as real-time updates.</p>
			<p>The callback <a id="_idIndexMarker209"/>decorates the function that is written just below it (<strong class="source-inline">update_graph</strong>). By decorating it this way, the app knows that it has to call this function every time an update is done (triggered by <strong class="source-inline">Interval</strong> in the layout). The <strong class="source-inline">update_graph</strong> function returns an updated graph.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Opening the dashboard</h2>
			<p>Once you run the code on your<a id="_idIndexMarker210"/> local machine, you will see the following information:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B18335_03_1.jpg" alt="Figure 3.1 – Output of Dash&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Output of Dash</p>
			<p>This link will give you access to the dashboard that is being updated in real time. It looks something like this:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B18335_03_2.jpg" alt="Figure 3.2 – The Plotly dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – The Plotly dashboard</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Comparing Plotly's Dash and other real-time visualization tools</h2>
			<p>There are many <a id="_idIndexMarker211"/>other data visualization tools out there. Popular examples are Power BI, QlikView, and Tableau. The great thing about Plotly's Dash is that it is super easy to get started with if you are already in a Python environment. It is free and does not require installation.</p>
			<p>If you want to be a pro in <strong class="bold">business intelligence</strong> (<strong class="bold">BI</strong>), it is worth checking out other tools. Many of them have capacities for real-time updates, and the specific documentation of each tool will guide you to it.</p>
			<p>When building dashboarding or data visualization systems, it is also important to consider your overall architecture. As discussed in the previous chapter, in many cases, you will have a data-generating system and an architecture that is able to manage this in real time. Just like any other analytics building block, you will need to make sure that your dashboard can be plugged into your data generating process, or you may need to build an in-between data store or data communication layer.</p>
			<p>We will now move on to the next use case of descriptive statistics: building basic alerting systems.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Building basic alerting systems</h1>
			<p>In the previous <a id="_idIndexMarker212"/>parts of this chapter, you have seen an introduction to descriptive statistics and visualization.</p>
			<p>Basic alerting systems will be covered as the last data analysis use case. In this part, you will see how you can use basic alerting systems on streaming data. For this, you will see how you can leverage descriptive statistics together with business rules to automatically generate alerts in real time. Example methods for alerting systems are as follows:</p>
			<ul>
				<li>Alerting systems on extreme values</li>
				<li>Alerting systems on process stability</li>
				<li>Alerting systems on constant variability</li>
				<li>Statistical process control and Lean Six Sigma control charts</li>
			</ul>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Alerting systems on extreme values</h2>
			<p>The first example for<a id="_idIndexMarker213"/> alerting and monitoring systems on streaming data is the use case that you have seen in earlier chapters: coding a business rule that sends an alert once observed values are outside of hardcoded boundaries.</p>
			<p>This example was coded in previous chapters as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-9</p>
			<pre class="source-code">import pandas as pd</pre>
			<pre class="source-code">data_batch = pd.DataFrame({</pre>
			<pre class="source-code">    'temperature': [10, 11, 10, 11, 12, 11, 10, 9, 10, 11, 12, 11, 9, 12, 11],</pre>
			<pre class="source-code">    'pH': [5, 5.5, 6, 5, 4.5, 5, 4.5, 5, 4.5, 5, 4, 4.5, 5, 4.5, 6]</pre>
			<pre class="source-code">})</pre>
			<pre class="source-code">data_batch</pre>
			<p>You will see the following data being printed:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B18335_03_3.jpg" alt="Figure 3.3 – The data batch&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – The data batch</p>
			<p>Let's now write<a id="_idIndexMarker214"/> the function and loop through the data to execute the function on each data point:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-10</p>
			<pre class="source-code">def super_simple_alert(datapoint):</pre>
			<pre class="source-code">  if datapoint['temperature'] &lt; 10:</pre>
			<pre class="source-code">    print('this is a real time alert. Temp too low')</pre>
			<pre class="source-code">  if datapoint['pH'] &gt; 5.5:</pre>
			<pre class="source-code">    print('this is a real time alert. pH too high')</pre>
			<pre class="source-code">data_iterable = data_batch.iterrows()</pre>
			<pre class="source-code">for i,new_datapoint in data_iterable:</pre>
			<pre class="source-code">  print(new_datapoint.to_json())</pre>
			<pre class="source-code">  super_simple_alert(new_datapoint)</pre>
			<p>The resulting print output shows that a number of alerts have been launched:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B18335_03_4.jpg" alt="Figure 3.4 – The printed results of your alerting system&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – The printed results of your alerting system</p>
			<p>This example <a id="_idIndexMarker215"/>is a great first step into alerting and monitoring systems: a common use case for streaming data. Let's see how you can build on this example to add more and more complex static logic to this.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Alerting systems on process stability (mean and median)</h2>
			<p>Rather than applying<a id="_idIndexMarker216"/> business logic to individual values, it may be better in some cases to add logic for averages. In many cases, it will not be necessary to send alerts if just one observation is out of specification. However, when the average of several products gets out of specification, you are likely to have a structural problem that needs to be solved.</p>
			<p>You could think of<a id="_idIndexMarker217"/> coding such an example as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-11</p>
			<pre class="source-code">import numpy as np</pre>
			<pre class="source-code">def super_simple_alert(hist_datapoints):</pre>
			<pre class="source-code">  print(hist_datapoints)</pre>
			<pre class="source-code">  if np.mean(hist_datapoints['temperature']) &lt; 10:</pre>
			<pre class="source-code">    print('this is a real time alert. temp too low')</pre>
			<pre class="source-code">  if np.mean(hist_datapoints['pH']) &gt; 5.5:</pre>
			<pre class="source-code">    print('this is a real time alert. pH too high')</pre>
			<pre class="source-code">data_iterable = data_batch.iterrows()</pre>
			<pre class="source-code"># create historization for window</pre>
			<pre class="source-code">hist_temp = []</pre>
			<pre class="source-code">hist_ph = []</pre>
			<pre class="source-code">for i,new_datapoint in data_iterable:</pre>
			<pre class="source-code">  hist_temp.append([new_datapoint['temperature']])</pre>
			<pre class="source-code">  hist_ph.append([new_datapoint['pH']])</pre>
			<pre class="source-code">  hist_datapoint = {</pre>
			<pre class="source-code">      'temperature': hist_temp[-3:],</pre>
			<pre class="source-code">      'pH': hist_ph[-3:]</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  super_simple_alert(hist_datapoint)</pre>
			<p>In this example, you see that there is a windowed average computed on the last 10 observations. This allows you to alert as soon as the average of the last three observations reaches a hardcoded alerting threshold. You should observe the following output:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B18335_03_5.jpg" alt="Figure 3.5 – Improved print output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Improved print output</p>
			<p>You can observe <a id="_idIndexMarker218"/>that the fact of using the average of three observations makes it much less likely to receive an alert. If you were to use even more observations in your window, this would be reduced even more. Fine-tuning should depend on the business case.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Alerting systems on constant variability (std and variance)</h2>
			<p>You can do the same<a id="_idIndexMarker219"/> with variability. As discussed in the section on descriptive statistics, a process is often described by centrality and variability. Even if your average is within specifications, there may be a large variability; if variability is large, this may be a problem for you as well.</p>
			<p>You can do alerting <a id="_idIndexMarker220"/>systems on variability using windowed computations of the mean. This can be used for a dashboard, but also for alerting systems and more.</p>
			<p>You can code this as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code block 3-12</p>
			<pre class="source-code">import numpy as np</pre>
			<pre class="source-code">def super_simple_alert(hist_datapoints):</pre>
			<pre class="source-code">  print(hist_datapoints)</pre>
			<pre class="source-code">  if np.std(hist_datapoints['temperature']) &gt; 1:</pre>
			<pre class="source-code">    print('this is a real time alert. temp variations too high')</pre>
			<pre class="source-code">  if np.std(hist_datapoints['pH']) &gt; 1:</pre>
			<pre class="source-code">    print('this is a real time alert. pH variations too high')</pre>
			<pre class="source-code">data_iterable = data_batch.iterrows()</pre>
			<pre class="source-code"># create historization for window</pre>
			<pre class="source-code">hist_temp = []</pre>
			<pre class="source-code">hist_ph = []</pre>
			<pre class="source-code">for i,new_datapoint in data_iterable:</pre>
			<pre class="source-code">  hist_temp.append([new_datapoint['temperature']])</pre>
			<pre class="source-code">  hist_ph.append([new_datapoint['pH']])</pre>
			<pre class="source-code">  hist_datapoint = {</pre>
			<pre class="source-code">      'temperature': hist_temp[-3:],</pre>
			<pre class="source-code">      'pH': hist_ph[-3:]</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  super_simple_alert(hist_datapoint)</pre>
			<p>Note that the alerts <a id="_idIndexMarker221"/>are now not based on the average value, but on variability. You will receive the following output for this example:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B18335_03_6.jpg" alt="Figure 3.6 – Even further improved print output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Even further improved print output</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Basic alerting systems using statistical process control</h2>
			<p>If you want to go <a id="_idIndexMarker222"/>a step further with this type of<a id="_idIndexMarker223"/> alert system, you can use methods from statistical process control. This domain of statistics focuses on controlling a process or a production method. The main tool that stems from this domain is <a id="_idIndexMarker224"/>called <strong class="bold">control charts</strong>.</p>
			<p>In control charts, you plot a statistic over time, but you add control limits. A standard control chart is the one in which you plot the sample average over time, and you add control limits based on standard deviation. You then count and observe a number of extreme values and when a certain number of repetitive events occur, you launch an alert.</p>
			<p>You will find a link in the <em class="italic">Further reading</em> section for more details on control charts and statistical process control.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Summary</h1>
			<p>In this chapter, you have learned the basics of doing data analysis on streaming data. You have seen that doing descriptive statistics on data streams does not work the same as when doing descriptive statistics on batch data. Estimation theory from batch data can be used, but you have to window over data to get a larger or smaller window of historical data.</p>
			<p>Windowing settings can have a strong impact on your results. Larger windows will take into account more data and will be taking into account data further back in time. They will, however, be much less sensitive to the new data point. After all, the larger the window, the lesser impact one new data point has.</p>
			<p>You have also learned how to build data visualizations using Plotly's Dash. This tool is great, as it is quite powerful and can still be used from a Python environment. Many other visualization tools exist, but the most important thing is to master at least one of them. This chapter has shown you the functional requirements for visualizing streaming data, and you'll be able to reproduce this on other data visualization tools if needed.</p>
			<p>The last part of the chapter introduced statistical process control. Until now, you have been working with static rules or descriptive statistics for building simple alerting systems. Statistical process control is an interesting domain for building more advanced alerting systems that are still relatively easy to comprehend and implement.</p>
			<p>In the next chapter, you will start discovering online machine learning. Once you get familiarized with online machine learning in general, you'll see, in later chapters, how you can replace static decision rules for alerting systems with machine learning-based anomaly detection models. The data analysis methods that you have seen in this chapter are an important first step in that direction.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Further reading </h1>
			<ul>
				<li><em class="italic">Estimation theory</em>: <a href="https://en.wikipedia.org/wiki/Estimation_theory">https://en.wikipedia.org/wiki/Estimation_theory</a></li>
				<li><em class="italic">Sampling</em>: <a href="https://en.wikipedia.org/wiki/Sampling_(statistics)">https://en.wikipedia.org/wiki/Sampling_(statistics)</a></li>
				<li><em class="italic">Windowing</em>: <a href="https://softwaremill.com/windowing-in-big-data-streams-spark-flink-kafka-akka/">https://softwaremill.com/windowing-in-big-data-streams-spark-flink-kafka-akka/</a></li>
				<li><em class="italic">Plot live graphs using Python Dash and Plotly</em>: <a href="https://www.geeksforgeeks.org/plot-live-graphs-using-python-dash-and-plotly/">https://www.geeksforgeeks.org/plot-live-graphs-using-python-dash-and-plotly/</a></li>
				<li>Plotly Dash documentation: <a href="https://plotly.com/">https://plotly.com/</a></li>
				<li>Control charts: <a href="https://en.wikipedia.org/wiki/Control_chart">https://en.wikipedia.org/wiki/Control_chart</a></li>
				<li><em class="italic">Engineering Statistics Handbook, Chapter 6.3 Univariate and Multivariate Control Charts</em>: <a href="https://www.itl.nist.gov/div898/handbook/pmc/section3/pmc3.htm">https://www.itl.nist.gov/div898/handbook/pmc/section3/pmc3.htm</a></li>
			</ul>
		</div>
	</body></html>