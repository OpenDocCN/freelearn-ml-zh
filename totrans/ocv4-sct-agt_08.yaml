- en: Creating a Physics Simulation Based on a Pen and Paper Sketch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于笔和纸草图创建物理模拟
- en: '"James Bond lives in a nightmarish world where laws are written at the point
    of a gun."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"詹姆斯·邦德生活在一个充满噩梦的世界，法律是由枪口写成的。"'
- en: – Yuri Zhukov, Pravda, 30 September 1965
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 尤里·祖科夫，《真理报》，1965年9月30日
- en: '"Just a moment. Three measures of Gordon''s, one of vodka, half a measure of
    Kina Lillet. Shake it very well until it''s ice-cold, then add a large thin slice
    of lemon peel. Got it?"'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '"稍等一下。来三份戈登的鸡尾酒，其中一份伏特加，半份金巴利。用力摇匀，直到冰凉，然后加入一大片柠檬皮。明白了吗？"'
- en: – Casino Royale, Chapter 7, Rouge et Noir (1953)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: – 《皇家赌场》，第七章，红与黑（1953）
- en: James Bond is a precise man. Like a physicist, he seems to see order in a world
    where others see chaos. Another mission, another romance, another shaken drink,
    another crashing car or helicopter or skier, and another gunshot, do not change
    the way the world works—the way the Cold War works. He seems to take comfort in
    this consistency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯·邦德是一个严谨的人。就像一个物理学家一样，他似乎在别人看到混乱的世界中看到了秩序。另一个任务，另一个恋情，另一杯摇匀的饮料，另一场撞车或直升机或滑雪事故，以及另一声枪响，都不会改变世界的运作方式——冷战的方式。他似乎在这份一致性中找到了安慰。
- en: A psychologist might say that Bond is reenacting an unhappy childhood, which
    the novels reveal to us in brief glimpses. The boy lacked a permanent home. His
    father was an international arms dealer for the Vickers company, so the family
    moved often for work. When James was 11, his parents died in a mountain climbing
    accident, the first of many dramatic, untimely deaths in the Bond saga. An aunt
    in Kent took in the orphaned James, but the next year he was sent to boarding
    at Eton College. There, the lonesome boy became infatuated with a maid, got into
    trouble over it, and was expelled, the first of his many short-lived and fraught
    romances. Next, he was sent even further from family, to Fettes College in Scotland.
    The pattern of displacement and trouble was set. By 16, he was trying to live
    the life of a playboy in Paris. By 20, he was a dropout from the University of
    Geneva and he was off to join the Royal Navy at the height of the Second World
    War.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 心理学家可能会说，邦德在重演一个不幸的童年，小说以简短的片段向我们揭示了这一点。这个男孩没有一个固定的家。他的父亲是维克斯公司的国际军火商，所以为了工作，这个家庭经常搬家。当詹姆斯11岁时，他的父母在登山事故中去世，这是邦德传奇中许多戏剧性、过早的死亡中的第一次。肯特的一个阿姨收养了这个孤儿詹姆斯，但第二年他被送到伊顿公学寄宿。在那里，这个孤独的男孩迷恋上一个女仆，因此陷入麻烦，并被开除，这是他许多短暂而充满挑战的恋情中的第一次。接下来，他被送到更远的地方，去了苏格兰的费茨学院。这种流离失所和麻烦的模式已经形成。到16岁时，他试图在巴黎过一种花花公子的生活。到20岁时，他是日内瓦大学的辍学生，在第二次世界大战的高潮时期加入了皇家海军。
- en: Amid all that upheaval, Bond did manage to learn a thing or two. He is clever—not
    just with his eyebrow-raising witty remarks, but also with his fast solutions
    to puzzles that involve mechanics, kinematics, or physics. He is never caught
    flat-footed (although he is sometimes caught in other ways).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些动荡中，邦德确实学到了一些东西。他很聪明——不仅是因为他那令人捧腹的机智评论，还因为他解决涉及力学、运动学或物理学的谜题时的快速反应。他从未被完全击败（尽管他有时会以其他方式被击败）。
- en: The moral of the story is that a secret agent must practice his physics, even
    under the most trying of circumstances. An app can help with that.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的意义是，特工必须练习他的物理学，即使在最艰难的情况下。一个应用程序可以帮助做到这一点。
- en: When I think about problems of geometry or physics, I like to draw them with
    a pen and paper. However, I also like to see animations. Our app, `Rollingball`,
    will allow us to combine these two media. It will use computer vision to detect
    simple geometric shapes that the user can draw on paper. Then, based on the detected
    shapes, the app will create a physics simulation that the user can watch. The
    user can also influence the simulation by tilting the device to alter the simulated
    direction of gravity. The experience is like designing and playing with one's
    own version of a ball-in-a-maze puzzle, a fine toy for aspiring secret agents.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我想起几何或物理问题的时候，我喜欢用笔和纸把它们画出来。然而，我也喜欢看到动画。我们的应用程序`Rollingball`将允许我们结合这两种媒体。它将使用计算机视觉来检测用户可以在纸上绘制的简单几何形状。然后，基于检测到的形状，应用程序将创建一个用户可以观看的物理模拟。用户还可以通过倾斜设备来改变模拟的重力方向，从而影响模拟。这种体验就像设计和玩自己版本的迷宫球游戏，这是一个适合有志成为特工的人的精美玩具。
- en: 'Building games is fun, but it is not all fun and games! We have a new list
    of skills to master in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 建造游戏很有趣，但不仅仅是游戏！在本章中，我们有一份新的技能列表要掌握：
- en: Detecting linear and circular edges with the Hough transform
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用霍夫变换检测线性边缘和圆形边缘
- en: Using OpenCV in the Unity game engine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unity 游戏引擎中使用 OpenCV
- en: Building a Unity game for Android
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Android 构建Unity 游戏
- en: Converting coordinates from OpenCV's space to Unity's space and creating three-dimensional
    objects in Unity based on our detection results in OpenCV
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将坐标从 OpenCV 空间转换为 Unity 空间，并根据我们在 OpenCV 中的检测结果在 Unity 中创建三维对象
- en: Customizing the appearance and physics behavior of three-dimensional objects
    in Unity, using shaders, materials, and physics materials
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用着色器、材质和物理材质自定义 Unity 中三维对象的外观和物理行为
- en: Drawing lines and rectangles using OpenGL calls from Unity
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenGL 调用从 Unity 绘制线条和矩形
- en: With these goals in mind, let's get ready to play ball!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些目标，让我们准备好玩球吧！
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter''s project has the following software dependencies:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目有以下软件依赖项：
- en: Unity—a cross-platform game engine that supports Windows and Mac as development
    platforms. Development on Linux is not supported in this chapter.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity——一个支持 Windows 和 Mac 作为开发平台的跨平台游戏引擎。本章不支持在 Linux 上进行开发。
- en: OpenCV for Unity.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV for Unity。
- en: Android SDK, which comes with Android Studio.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android SDK，它包含在 Android Studio 中。
- en: Where not otherwise noted, setup instructions are covered in [Chapter 1](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml),
    *Preparing for the Mission*. You might want to build and run the project in [Chapter
    4](61bdd7aa-b605-4061-8bfe-71084c7c7104.xhtml), *Controlling a Phone App with
    Your Suave Gestures*, to ensure that Android SDK is properly set up as part of
    Android Studio. Setup instructions for OpenCV for Unity are covered in the current
    chapter, in the section *Setting up OpenCV for Unity*. Always refer to the setup
    instructions for any version requirements. Instructions for building and running
    Unity projects are covered in the current chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有其他说明，设置说明包含在第 1 章 *准备任务* 中，[第 1 章](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml)。您可能希望在
    [第 4 章](61bdd7aa-b605-4061-8bfe-71084c7c7104.xhtml) *使用您的优雅手势控制手机应用* 中构建和运行项目，以确保
    Android SDK 作为 Android Studio 的一部分正确设置。OpenCV for Unity 的设置说明包含在本章的 *设置 OpenCV
    for Unity* 部分。始终参考任何版本的设置说明。构建和运行 Unity 项目的说明包含在本章中。
- en: The completed project from this chapter can be found in this book's GitHub repository,
    at [https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition](https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition),
    in the `Chapter006` folder. The repository doesn't contain the OpenCV for Unity
    plugin, which must be licensed and added to the project, as described in the *Setting
    up OpenCV for Unity* section in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完成项目可以在本书的 GitHub 仓库中找到，位于 [https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition](https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition)
    的 `Chapter006` 文件夹中。该仓库不包含 OpenCV for Unity 插件，该插件必须获得许可并添加到项目中，如本章 *设置 OpenCV
    for Unity* 部分中所述。
- en: Planning the Rollingball app
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划 Rollingball 应用
- en: '`Rollingball` will be a mobile app. We will develop it in the Unity game engine
    by using a third-party plugin called **OpenCV for Unity**. The app will be compatible
    with both Android and iOS. Our build instructions will focus on Android, but we
    will also provide a few notes for readers who are experienced with the iOS build
    process (on Mac).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rollingball` 将是一个移动应用。我们将使用名为 **OpenCV for Unity** 的第三方插件在 Unity 游戏引擎中开发它。该应用将兼容
    Android 和 iOS。我们的构建说明将专注于 Android，但我们也将为熟悉 iOS 构建过程的读者提供一些说明（在 Mac 上）。'
- en: For instructions on setting up Unity and finding relevant documentation and
    tutorials, please refer back to the *Setting up Unity and OpenCV* section in [Chapter
    1](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml), *Preparing for the Mission*. At
    the time of writing this book, Unity's officially supported development environments
    are Windows and Mac, although there is ongoing beta development toward Linux support.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置 Unity 和查找相关文档和教程的说明，请参阅第 1 章 *准备任务* 中 *设置 Unity 和 OpenCV* 部分，[第 1 章](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml)。在撰写本书时，Unity
    的官方支持的开发环境是 Windows 和 Mac，尽管正在进行针对 Linux 支持的 beta 版开发。
- en: 'Using the mobile device''s camera, `Rollingball` will scan two types of primitive
    shapes—circles and lines. The user will start by drawing any combination of these
    primitive shapes, or by setting up linear or circular objects on a plain background.
    For example, refer to the following image:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动设备的相机，`Rollingball` 将扫描两种原始形状——圆形和线条。用户将开始绘制这些原始形状的任何组合，或在平面背景上设置线性或圆形对象。例如，参考以下图像：
- en: '![](img/06aa0190-2658-4f7c-9eea-abf14afcfaef.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06aa0190-2658-4f7c-9eea-abf14afcfaef.jpg)'
- en: Here, we have several circles drawn on a paper napkin. Our detector will work
    best with outlines, rather than solid circles, and particularly with smoothly
    drawn outlines, rather than lumpy or broken outlines. For this image, our detector
    will work best on the two rightmost circles. We also have a pen with edges that
    look like straight lines against the background of the paper. Our detector will
    work well with these linear edges.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在一张纸巾上画了几个圆形。我们的检测器在轮廓上工作得最好，而不是实心圆形，尤其是平滑的轮廓，而不是凹凸不平或断裂的轮廓。对于这张图片，我们的检测器在两个最右边的圆形上工作得最好。我们还有一个笔，其边缘在纸的背景上看起来像是直线。我们的检测器可以很好地处理这些线性边缘。
- en: '`Rollingball` is a simple app in which the user primarily interacts with one
    Android activity or one iOS view controller. A live video feed fills most of the
    background. When circles or lines are detected, they are highlighted in red, as
    shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rollingball`是一个简单的应用程序，用户主要与一个Android活动或一个iOS视图控制器进行交互。实时视频填充了大部分背景。当检测到圆形或线条时，它们会以红色突出显示，如下面的屏幕截图所示：'
- en: '![](img/22b94b14-9bb8-4ad2-b8e4-50ae5c9e93b7.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22b94b14-9bb8-4ad2-b8e4-50ae5c9e93b7.png)'
- en: Note that some linear edges are detected multiple times. Lighting effects and
    discontinuities in the pen's color create ambiguities about where its edges are
    located.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些线性边缘被检测了多次。光照效果和笔颜色的不连续性造成了对其边缘位置的不确定性。
- en: 'The user can press a button to start the physics simulation. During the simulation,
    the video pauses, the detector stops running, and the red-highlighted areas are
    replaced with cyan balls and lines. The lines are stationary, but the balls fall
    freely and may bounce off each other and off the lines. Real-world gravity, as
    measured by the mobile device''s gravity sensor, is used to control the simulated
    direction of gravity. However, the simulation is two-dimensional, and gravity
    is flattened so that it points toward an edge of the screen. The following screenshot
    shows the simulated balls after they have fallen partway down the page, bounced
    apart, and rolled along the lines:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以按按钮开始物理模拟。在模拟过程中，视频暂停，检测器停止运行，红色突出显示的区域被替换为青色球体和线条。线条是静止的，但球体自由下落，可能会相互弹跳并沿着线条滚动。使用移动设备的重力传感器测量的现实世界重力被用来控制模拟的重力方向。然而，模拟是二维的，重力被压扁，使其指向屏幕的边缘。以下屏幕截图显示了球体在页面部分下落、弹跳分开并沿着线条滚动后的模拟效果：
- en: '![](img/15deca3d-40ac-4389-85f1-c7d84167a3d4.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15deca3d-40ac-4389-85f1-c7d84167a3d4.png)'
- en: The user can press the button again to clear all the simulated objects and resume
    the live video and detection. The cycle can continue indefinitely, with the user
    choosing to simulate different drawings or different views of the same drawing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以再次按按钮来清除所有模拟对象，并恢复实时视频和检测。这个循环可以无限进行，用户可以选择模拟不同的绘画或同一绘画的不同视图。
- en: Now, let's consider the techniques for detecting circles and lines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑检测圆形和线条的技术。
- en: Detecting circles and lines
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测圆形和线条
- en: From `The Living Headlights` (our project in [Chapter 5](b4619968-1f90-45f0-8a77-3505624bc0c0.xhtml),* Equipping
    Your Car with a Rearview Camera and Hazard Detection*), we are already familiar
    with one technique for detecting circles. We treated the problem as a special
    case of blob detection, and we used an OpenCV class, `SimpleBlobDetector`, which
    allows us to specify many detection criteria, such as a blob's size, color, and
    circularity (or non-circularity, that is, linearity).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从《活着的车灯》（我们项目中的[第5章](b4619968-1f90-45f0-8a77-3505624bc0c0.xhtml)，*装备汽车后视摄像头和危险检测*)，我们已经熟悉了一种检测圆形的技术。我们将这个问题视为blob检测的特殊情况，并使用了一个OpenCV类，`SimpleBlobDetector`，它允许我们指定许多检测标准，例如blob的大小、颜色和圆形度（或非圆形度，即线性）。
- en: 'A **blob** is a shape filled with a solid (or nearly solid) color. This definition
    implies that many circular or linear objects are not detectable as blobs. In the
    following screenshot, we can see a sunlit desk with a china teapot, china bowl,
    and pewter bowl:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blob**是一种填充了固体（或几乎固体）颜色的形状。这个定义意味着许多圆形或线性物体不能被检测为blob。在下面的屏幕截图中，我们可以看到一个阳光照耀的桌子，上面有中国茶壶、中国碗和锡碗：'
- en: '![](img/0b3b59eb-5cfc-4c51-8188-4198a7036671.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b3b59eb-5cfc-4c51-8188-4198a7036671.jpg)'
- en: The bowls and the lid of the teapot have approximately circular outlines in
    this top-down view. However, they are unlikely to pass detection as blobs, because
    the interior of each shape is multicolored, especially in uneven light.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种俯视图中，茶壶的碗和盖子的大致轮廓是圆形的。然而，它们不太可能被检测为块状，因为每个形状的内部是多色的，尤其是在不均匀的光照下。
- en: Blob detection starts with a simple threshold filter (marking bright regions
    as white and dark regions as black); a more general approach to shape detection
    should start with an edge-finding filter (marking edge regions as white and interior
    regions as black) and then a thresholding process. We define an edge as the discontinuity
    between neighboring regions of different brightness. Thus, an edge pixel has darker
    neighbors on one side and brighter neighbors on the opposite side. An edge-finding
    filter subtracts neighbor values from one side and adds them from the opposite
    side, in order to measure how strongly a pixel exhibits this edge-like contrast
    in a given direction. To achieve a measurement that is independent of edges' directions,
    we can apply multiple filters (each oriented for edges of a different direction)
    and treat each filter's output as a dimension of a vector whose magnitude represents
    the overall **edginess** of the pixel. A set of such measurements for all pixels
    is sometimes called the **derivative** of the image. Having computed the image's
    derivative, we select a threshold value based on the minimum contrast that we
    require in an edge. A high threshold accepts only high-contrast edges, while a
    lower threshold also accepts lower-contrast edges.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 轮廓检测从简单的阈值滤波器开始（将明亮区域标记为白色，将暗淡区域标记为黑色）；形状检测的更通用方法应该从边缘检测滤波器开始（将边缘区域标记为白色，将内部区域标记为黑色），然后进行阈值处理。我们定义边缘为不同亮度区域之间不连续性。因此，边缘像素在一侧有较暗的邻居，而在另一侧有较亮的邻居。边缘检测滤波器从一侧减去邻居值，从另一侧添加它们，以便测量像素在给定方向上表现出这种边缘对比度的强度。为了实现一个与边缘方向无关的测量，我们可以应用多个滤波器（每个滤波器都针对不同方向的边缘），并将每个滤波器的输出视为向量的一个维度，其大小表示像素的整体**边缘性**。对于所有像素的这种测量集合有时被称为图像的**导数**。计算完图像的导数后，我们根据所需的边缘最小对比度选择一个阈值。高阈值只接受高对比度边缘，而低阈值也接受低对比度边缘。
- en: A popular edge-finding technique is the **Canny algorithm**. OpenCV's implementation,
    the `Imgproc.Canny` function, performs both filtering and thresholding. As arguments,
    it takes a grayscale image, an output image, a low threshold value, and a high
    threshold value. The low threshold should accept all pixels that might be part
    of a good edge. The high threshold should only accept pixels that are definitely part
    of a good edge. From the set whose members might be edge pixels, the Canny algorithm
    only accepts the members that connect to definite edge pixels. The double criteria
    help to ensure that we can accept thin extremities of a major edge, while rejecting
    edges that are altogether faint. For example, a pen stroke or the curb of a road
    extending into the distance may be a major edge with thin extremities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的边缘检测技术是**Canny算法**。OpenCV的实现，`Imgproc.Canny`函数，执行过滤和阈值处理。作为参数，它接受一个灰度图像、一个输出图像、一个低阈值值和一个高阈值值。低阈值应该接受所有可能是良好边缘一部分的像素。高阈值应该只接受肯定是良好边缘一部分的像素。从可能是边缘像素的集合中，Canny算法只接受与肯定边缘像素相连的成员。双重标准有助于确保我们可以接受主要边缘的细末端，同时拒绝整体微弱的边缘。例如，笔触或延伸到远处的道路边缘可能是一个主要边缘，但其末端较细。
- en: Having identified edge pixels, we can count how many of them are intersected
    by a given primitive shape. The greater the number of intersections, the more
    confident we can be that the given primitive shape correctly represents an edge
    in the image. Each intersection is called a **vote**, and a shape needs a specified
    number of votes to be accepted as a real edge's shape. Out of all possible primitive
    shapes (of a given kind) in the image, we consider an evenly spaced, representative
    sample. We do so by specifying a step size for the shapes' geometric parameters.
    (For example, a line's parameters are a point and angle, while a circle's parameters
    are a center point and radius.) This sample of possible shapes is called a **grid**,
    the individual shapes in it are called **cells**, and votes are said to be cast
    in cells. This process (tallying the matches between actual edge pixels and a
    sample of possible shapes) is the core of a technique called the **Hough transform**,
    which has various specializations, such as **Hough line detection** and **Hough
    circle detection**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别了边缘像素后，我们可以计算有多少个边缘像素被给定的原始形状相交。交点数越多，我们越有信心认为给定的原始形状正确地表示了图像中的边缘。每个交点被称为**投票**，一个形状需要达到指定数量的投票才能被接受为真实边缘的形状。在图像中所有可能的原始形状（给定种类）中，我们考虑一个均匀分布的代表性样本。我们通过指定形状的几何参数的步长来实现这一点。（例如，线的参数是一个点和角度，而圆的参数是中心点和半径。）这个可能的形状样本被称为**网格**，其中的单个形状被称为**单元格**，投票是在单元格中投下的。这个过程（实际边缘像素与可能的形状样本之间的匹配计数）是称为**霍夫变换**的技术核心，它有各种专门化，如**霍夫线检测**和**霍夫圆检测**。
- en: Hough line detection has two implementations in OpenCV—`Imgproc.HoughLines`,
    which is based on the original Hough transform, and `Imgproc.HoughLinesP`, which
    is based on a probabilistic variant of the Hough transform. `Imgproc.HoughLines`
    does an exhaustive count of intersections for all possible lines for a given pair
    of step sizes, in pixels and in radians. `Imgproc.HoughLinesP` is usually faster
    (particularly in images with a few long line segments), as it takes possible lines
    in a random order and discards some of the possible lines after finding a good
    line in a region. `Imgproc.HoughLines` expresses each line as a distance from
    the origin and an angle, whereas `Imgproc.HoughLinesP` expresses each line as
    two points, the endpoints of a detected segment of the line, which is a more useful
    representation, since it gives us the option to treat the detection results as
    line segments, rather than indefinitely long lines. For both functions, the arguments
    include the image (which should be preprocessed with Canny, or a similar algorithm),
    the step sizes in pixels and radians, and the minimum number of intersections
    required to accept a line. The arguments to `Imgproc.HoughLinesP` also include
    a minimum length between endpoints and a maximum gap, where a gap consists of
    non-edge pixels between edge pixels that intersect the line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV中，霍夫线检测有两种实现方式——`Imgproc.HoughLines`，它基于原始的霍夫变换，以及`Imgproc.HoughLinesP`，它基于霍夫变换的概率变体。`Imgproc.HoughLines`会对给定的一对步长（以像素和弧度为单位）的所有可能线条进行穷举计数。`Imgproc.HoughLinesP`通常更快（尤其是在只有少量长线段的照片中），因为它以随机顺序考虑可能的线条，并在一个区域内找到一个好的线条后丢弃一些可能的线条。`Imgproc.HoughLines`将每条线表示为从原点到线的距离和角度，而`Imgproc.HoughLinesP`将每条线表示为两个点，即检测到的线段的端点，这种表示方式更有用，因为它允许我们将检测结果视为线段，而不是无限长的线。对于这两个函数，参数包括图像（应该使用Canny或其他类似算法进行预处理）、像素和弧度中的步长，以及接受线条所需的最小交点数。`Imgproc.HoughLinesP`的参数还包括端点之间的最小长度和最大间隙，其中间隙是指边缘像素之间相交的线上的非边缘像素。
- en: Hough circle detection has one implementation in OpenCV, `Imgproc.HoughCircles`,
    which is based on a variant of the Hough transform that makes use of gradient
    information at edges. This function's arguments include the image (not preprocessed
    with Canny or a similar algorithm, as `Imgproc.HoughCircles` applies the Canny
    algorithm internally), a downsampling factor (which acts somewhat like a blur
    factor to smooth the edges of potential circles), a minimum distance between detected
    circles' centers, a Canny edge detection threshold, a minimum number of intersections
    required to accept a circle, and minimum and maximum radii. The specified Canny
    threshold is the upper threshold; internally, the lower threshold is hardcoded
    as half of the upper threshold.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中有一个Hough圆检测的实现，即`Imgproc.HoughCircles`，它基于一种利用边缘梯度信息的Hough变换变体。此函数的参数包括图像（不需要使用Canny或类似算法进行预处理，因为`Imgproc.HoughCircles`内部应用了Canny算法）、一个下采样因子（它有点像模糊因子，用于平滑潜在圆的边缘）、检测到的圆中心之间的最小距离、Canny边缘检测阈值、接受圆所需的最小交点数以及最小和最大半径。指定的Canny阈值是上限阈值；内部，下限阈值被硬编码为上限阈值的一半。
- en: For more details on the Canny algorithm, the Hough transform, and OpenCV's implementations
    of them, refer to *Chapter 7, Extracting Lines, Contours, and Components,* in
    Robert Laganière's book, *OpenCV 3 Computer Vision Application Programming Cookbook*
    (*Packt Publishing, 2017*).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Canny算法、Hough变换以及OpenCV对这些算法的实现，请参阅Robert Laganière的书籍《OpenCV 3计算机视觉应用编程食谱》（Packt
    Publishing，2017年）的第7章“提取线、轮廓和组件”。
- en: Despite using a more efficient algorithm than the original Hough transform,
    `Imgproc.HoughCircles` is a computationally expensive function. Nonetheless, we
    use it in `Rollingball`, since many of today's mobile devices can handle the cost.
    For low-powered devices, such as Raspberry Pi, we would consider blob detection
    as a cheaper alternative. `Imgproc.HoughCircles` tends to work best with outlines
    of circles, whereas blob detection only works on solid circles. For line detection,
    we use the `Imgproc.HoughLinesP` function, which is not as expensive as OpenCV's
    other Hough detectors.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Imgproc.HoughCircles`比原始的Hough变换更高效，但它是一个计算成本较高的函数。尽管如此，我们在`Rollingball`中使用它，因为许多现代移动设备可以处理这种成本。对于低功耗设备，如Raspberry
    Pi，我们会考虑使用区域检测作为更经济的替代方案。`Imgproc.HoughCircles`通常与圆的轮廓一起工作，而区域检测仅适用于实心圆。对于线检测，我们使用`Imgproc.HoughLinesP`函数，它比OpenCV的其他Hough检测器便宜。
- en: Having chosen the algorithms and their OpenCV implementations, let's set up
    the plugin that will let us easily access this functionality in Unity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了算法及其OpenCV实现之后，让我们设置插件，以便我们可以在Unity中轻松访问这些功能。
- en: Setting up OpenCV for Unity
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置OpenCV for Unity
- en: Unity provides a cross-platform framework for scripting games in C#. However,
    it also supports platform-specific plugins in languages such as C, C++, Objective-C
    (for Mac and iOS), and Java (for Android). Developers may publish these plugins
    (and other assets) on the Unity Asset Store. Many published plugins represent
    a large amount of high-quality work, and buying one may be more economical than
    writing your own.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一个跨平台的框架，用于使用C#编写游戏脚本。然而，它也支持使用C、C++、Objective-C（适用于Mac和iOS）和Java（适用于Android）等语言编写的平台特定插件。开发者可以在Unity
    Asset Store上发布这些插件（和其他资产）。许多发布的插件代表了大量的高质量工作，购买一个可能比编写自己的更经济。
- en: OpenCV for Unity, by ENOX SOFTWARE ([https://enoxsoftware.com](https://enoxsoftware.com)),
    is a $95 plugin (at the time of writing this book). It offers a C# API that is
    closely based on OpenCV's official Java (Android) bindings. However, the plugin
    wraps OpenCV's C++ libraries and is compatible with Android, iOS, Windows Phone,
    Windows, Mac, Linux, and WebGL. It is reliable in my experience, and it saves
    us a lot of work that we would otherwise put into custom C++ code and C# wrappers.
    Moreover, it comes with several valuable samples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV for Unity，由ENOX SOFTWARE（[https://enoxsoftware.com](https://enoxsoftware.com)）开发，是一款售价95美元的插件（本书撰写时）。它提供了一个基于OpenCV官方Java（Android）绑定的C#
    API。然而，该插件封装了OpenCV的C++库，并且与Android、iOS、Windows Phone、Windows、Mac、Linux和WebGL兼容。在我的使用经验中，它非常可靠，并且它节省了我们大量原本需要投入到自定义C++代码和C#包装器中的工作。此外，它还附带了一些有价值的示例。
- en: OpenCV for Unity is not the only set of third-party C# bindings for OpenCV.
    Alternatives include OpenCvSharp ([https://github.com/shimat/opencvsharp](https://github.com/shimat/opencvsharp))
    and Emgu CV ([http://www.emgu.com](http://www.emgu.com)). However, in this book, we
    use OpenCV for Unity because it offers easy integration with Unity and it tends
    to be updated quickly when new OpenCV versions are released.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV for Unity不是OpenCV的唯一第三方C#绑定集。其他选择包括OpenCvSharp ([https://github.com/shimat/opencvsharp](https://github.com/shimat/opencvsharp))
    和 Emgu CV ([http://www.emgu.com](http://www.emgu.com))。然而，在这本书中，我们使用OpenCV for
    Unity，因为它与Unity的集成简单，并且当发布新的OpenCV版本时，它通常会快速更新。
- en: 'Let''s go shopping. Open Unity and create a new project. From the menu bar, select
    Window | Asset Store. If you haven''t already created a Unity account, follow
    the prompts to create one. Once you have logged into the store, you should see
    the Asset Store window. Enter `OpenCV for Unity` in the search bar in the upper-right
    corner. Click on the OpenCV for Unity link among the search results. You should
    see something similar to the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去购物。打开Unity并创建一个新的项目。从菜单栏中选择Window | Asset Store。如果你还没有创建Unity账户，请按照提示创建一个。一旦你登录到商店，你应该会看到Asset
    Store窗口。在右上角的搜索栏中输入`OpenCV for Unity`。点击搜索结果中的OpenCV for Unity链接。你应该会看到类似于以下截图的内容：
- en: '![](img/e9246272-9d84-4bb3-984f-3315282a08cd.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9246272-9d84-4bb3-984f-3315282a08cd.png)'
- en: 'Click on the Add to Cart button and complete the transaction, as directed.
    Click on the Download button and wait for the download to complete. Click on the
    Import button. You should now see the Import Unity Package window, as shown in
    the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加到购物车”按钮并按照指示完成交易。点击“下载”按钮并等待下载完成。点击“导入”按钮。你现在应该会看到如图所示的“导入Unity包”窗口：
- en: '![](img/cedde273-d2e9-4bfa-9451-73a684b3cd2c.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cedde273-d2e9-4bfa-9451-73a684b3cd2c.png)'
- en: This is a list of all of the files in the bundle that we just purchased. Ensure
    that all of their checkboxes are checked, and then click on the Import button.
    Soon, you should see all of the files in the Project pane of the Unity editor.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是刚刚购买的包中所有文件的列表。确保所有复选框都已勾选，然后点击“导入”按钮。很快，你应该会在Unity编辑器的项目面板中看到所有文件。
- en: The bundle includes further setup instructions and helpful links in the `OpenCVForUnity/ReadMe.pdf`
    file. Read the `ReadMe!` note that contains useful instructions for iOS if you
    wish to build for that platform.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包括在`OpenCVForUnity/ReadMe.pdf`文件中的进一步设置说明和有用的链接。如果你希望为iOS平台构建，请阅读包含有用说明的`ReadMe!`笔记。
- en: Throughout this chapter, paths are relative to the project's `Assets` folder,
    unless otherwise specified.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，除非另有说明，否则路径相对于项目的`Assets`文件夹。
- en: Next, let's try the samples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试一下示例。
- en: Configuring and building the Unity project
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和构建Unity项目
- en: Unity supports many target platforms. Switching to a new target is easy, as
    long as our plugins support it. We just need to set a few build configuration
    values, some of which are shared across multiple targets, and some of which are
    platform-specific.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Unity支持许多目标平台。只要我们的插件支持，切换到新平台很容易。我们只需要设置一些构建配置值，其中一些在多个目标之间共享，而另一些则是特定于平台的。
- en: 'From the menu bar, select Unity | Preferences..., which should bring up the
    Preferenceswindow. Click on the External Tools tab and set Android SDK to be the
    base path to your Android SDK installation. Normally, for an Android Studio environment,
    the path to the SDK is `C:\Users\username\AppData\Local\Android\sdk\` on Windows
    or `Users/<your_username>/Library/Android/sdk/` on Mac. Now, the window should
    look similar to the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单栏中选择Unity | 首选项...，这将打开首选项窗口。点击“外部工具”选项卡并将Android SDK设置为Android SDK安装的基路径。通常，对于Android
    Studio环境，Windows上的SDK路径是`C:\Users\username\AppData\Local\Android\sdk\`，而Mac上的路径是`Users/<your_username>/Library/Android/sdk/`。现在，窗口应该看起来类似于以下截图：
- en: '![](img/2a2b0a88-878e-4354-977b-c4ee096370af.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a2b0a88-878e-4354-977b-c4ee096370af.png)'
- en: 'Now, from the menu bar, select File | Build Settings. The Build Settings window
    should appear. Drag all of the sample scene files, such as `OpenCVForUnity/Examples/OpenCVForUnityExample.unity`
    and `OpenCVForUnity/Examples/Advanced/ComicFilterExample/ComicFilterExample.unity`,
    from the Project pane to the Scenes In Build list in the Build Settings window.
    The first scene in the list is the start-up scene. Ensure that `OpenCVForUnityExample`
    is the first in the list. (Drag and drop the list items to reorder them.) Also,
    ensure that all of the scenes'' checkboxes are checked. Click on the Android platform,
    and then the Switch Platform button. The window should now look like the following
    screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从菜单栏中选择 File | Build Settings。 Build Settings 窗口应该会出现。将所有示例场景文件，例如 `OpenCVForUnity/Examples/OpenCVForUnityExample.unity`
    和 `OpenCVForUnity/Examples/Advanced/ComicFilterExample/ComicFilterExample.unity`，从项目 面板拖动到
    Build Settings 窗口中的 Scenes In Build 列表。列表中的第一个场景是启动场景。确保 `OpenCVForUnityExample`
    是列表中的第一个。（拖动并放下列表项以重新排序。）同时，确保所有场景的复选框都已勾选。点击 Android 平台，然后点击 Switch Platform
    按钮。窗口现在应该看起来类似于以下截图：
- en: '![](img/52291210-4d8e-41d0-8e2a-cb3c9db41479.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52291210-4d8e-41d0-8e2a-cb3c9db41479.png)'
- en: 'Click on the Player Settings... button. A list of settings should appear in
    the Inspector pane of the Unity editor. Fill in a Company Name, such as `Nummist
    Media Corporation Limited`, and a Product Name, such as `Rollingball`. Optionally,
    select a Default Icon (which must be an image file that you have added somewhere
    in the Project pane). Click on Resolution and Presentation to expand it, and then,
    for Default Orientation, select Portrait. So far, the PlayerSettings options should
    look similar to the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Player Settings... 按钮。Unity 编辑器的检查器面板中应该会显示一个设置列表。填写一个公司名称，例如 `Nummist 媒体有限公司`，以及一个产品名称，例如
    `Rollingball`。可选地，选择一个默认图标（必须是你在项目面板中添加的图像文件）。点击分辨率和展示以展开它，然后，对于默认方向，选择纵向。到目前为止，PlayerSettings
    选项应该看起来类似于以下截图：
- en: '![](img/1a93fd9b-ea54-4d00-8a0b-1c64814e7991.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a93fd9b-ea54-4d00-8a0b-1c64814e7991.png)'
- en: Click on Other Settings to expand it, and then fill out a Bundle Identifier
    with something like `com.nummist.rollingball`. Now, we have finished with the
    PlayerSettings options.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Other Settings 以展开它，然后填写一个 Bundle Identifier，例如 `com.nummist.rollingball`。现在，我们已经完成了
    PlayerSettings 选项。
- en: Ensure that an Android device is plugged in and that USB debugging is enabled
    on the device. Go back to the Build Settings window and click on Build and Run.
    Specify a path for the build. It is good practice to separate the build path from
    the Unity project folder, just as you would normally separate builds from source
    code. Once the build has begun, a progress bar should appear. Watch the Console
    pane of the Unity editor to be sure that no build errors occur. When the build
    has finished, it is copied onto the Android device, and then it runs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已连接 Android 设备，并且设备上启用了 USB 调试。返回到 Build Settings 窗口，并点击 Build and Run。指定构建路径。将构建路径与
    Unity 项目文件夹分开，就像你通常将构建与源代码分开一样。一旦开始构建，就会出现一个进度条。观察 Unity 编辑器的控制台面板，以确保没有构建错误发生。构建完成后，它将被复制到
    Android 设备上，然后运行。
- en: Enjoy the OpenCV for Unity samples! If you like, browse their source code and
    scenes in the Unity editor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 享受 OpenCV for Unity 的示例！如果你愿意，可以在 Unity 编辑器中浏览它们的源代码和场景。
- en: Next, we have our own scene to build!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有自己的场景要构建！
- en: Creating the Rollingball scene in Unity
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Unity 中创建 Rollingball 场景
- en: Let's create a directory, `Rollingball`, to contain our application-specific
    code and assets. Right-click in the Project pane and choose Create | Folder from
    the context menu. Rename the new folder `Rollingball`. Create a subfolder, `Rollingball/Scenes`,
    in a similar way.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个目录，`Rollingball`，以包含我们的应用程序特定代码和资源。在项目面板中右键单击，并从上下文菜单中选择 Create | Folder。将新文件夹重命名为
    `Rollingball`。以类似的方式创建一个子文件夹，`Rollingball/Scenes`。
- en: From the menu bar, select File | New Scene and then File | Save As.... Save
    the scene as `Rollingball/Scenes/Rollingball.unity`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单栏中选择 File | New Scene，然后选择 File | Save As.... 将场景保存为 `Rollingball/Scenes/Rollingball.unity`。
- en: 'By default, our newly created scene only contains a camera (that is, the virtual
    world''s camera, not a capture device) and a directional light. The light will
    illuminate the balls and lines in our physics simulation. We are going to add
    three more objects, in the following way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们新创建的场景只包含一个摄像机（即虚拟世界的摄像机，不是一个捕获设备）和一个方向光。这个光将照亮我们物理模拟中的球体和线条。我们将以以下方式添加三个更多对象：
- en: From the menu bar, select GameObject | 3D Object | Quad. An object called `Quad`
    should appear in the Hierarchy pane. Rename `Quad` to `VideoRenderer`. This object
    is going to represent the live video feed.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单栏中选择 GameObject | 3D Object | Quad。一个名为 `Quad` 的对象应该出现在 Hierarchy 面板中。将 `Quad`
    重命名为 `VideoRenderer`。这个对象将代表实时视频流。
- en: From the menu bar, select GameObject | Create Empty. An object called `GameObject`
    should appear in the Hierarchy pane. Rename `GameObject` to `QuitOnAndroidBack`.
    Later, it will hold a script component that responds to the standard back button
    on Android.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单栏中选择 GameObject | Create Empty。一个名为 `GameObject` 的对象应该出现在 Hierarchy 面板中。将
    `GameObject` 重命名为 `QuitOnAndroidBack`。稍后，它将包含一个响应 Android 标准返回按钮的脚本组件。
- en: Objects in the Hierarchy are called **game objects**, and the sections that
    are visible in their Inspector panes are called **components**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Hierarchy 中的对象被称为 **游戏对象**，它们在检查器面板中可见的部分被称为 **组件**。
- en: Drag the Main Camera onto the VideoRenderer to make the former a child of the
    latter. A child moves, rotates, and scales up or down when its parent does. The
    relevance is that we want our camera to maintain a predictable relationship with
    the live video background.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将主摄像机拖放到 VideoRenderer 上，使其成为后者的子对象。当父对象移动、旋转或缩放时，子对象也会移动、旋转和缩放。相关之处在于我们希望我们的摄像机与实时视频背景保持可预测的关系。
- en: Parent-child relationships in the Hierarchy do not represent object-oriented
    inheritance; in other words, a child does not have an **is** **a** relationship
    with its parent. Rather, a parent who has a one-to-many **has a **relationship
    with its children.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Hierarchy 中的父子关系不代表面向对象继承；换句话说，子对象与其父对象之间没有 **is a** 的关系。相反，一个具有一对多 **has a**
    关系的父对象与它的子对象相关。
- en: 'With the new objects created and the Main Camera reparented, the Hierarchy
    should look like the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了新对象并将主摄像机重新分配父级后，Hierarchy 应该看起来像以下截图：
- en: '![](img/0d1bae8f-c080-4dfc-89f2-cdb71e85aa4b.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d1bae8f-c080-4dfc-89f2-cdb71e85aa4b.png)'
- en: 'The VideoRenderer and Main Camera will be configured in code, based on the
    properties of the mobile device''s video camera. However, let''s set some reasonable
    defaults. Select the VideoRenderer in the Hierarchy, and then, in the Inspector
    pane, edit its Transform properties to match the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: VideoRenderer 和主摄像机将根据移动设备视频摄像机的属性进行配置。但是，让我们设置一些合理的默认值。在 Hierarchy 中选择 VideoRenderer，然后在检查器面板中编辑其变换属性，以匹配以下截图：
- en: '![](img/cbaee7bf-a058-4e31-a297-3ace58ef5cf3.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbaee7bf-a058-4e31-a297-3ace58ef5cf3.png)'
- en: 'Similarly, select Main Camera and edit its Transform and Camera properties
    to match the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，选择主摄像机并编辑其变换和摄像机属性，以匹配以下截图：
- en: '![](img/090ddbd6-3ecf-44c1-b4e5-b04cc88540e5.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/090ddbd6-3ecf-44c1-b4e5-b04cc88540e5.png)'
- en: Note that we have configured an orthographic projection, meaning that the objects'
    pixel sizes are constant, regardless of their distance from the camera. This configuration
    is appropriate for a two-dimensional game or simulation, such as `Rollingball`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经配置了正交投影，这意味着对象的像素大小是恒定的，无论它们与摄像机的距离如何。这种配置适用于二维游戏或模拟，例如 `Rollingball`。
- en: These four objects are the foundation of our scene. The rest of the project
    involves attaching custom properties to these objects and using C# scripts to
    control them and create new objects around them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个对象是我们场景的基础。项目的其余部分涉及将这些对象附加自定义属性，并使用 C# 脚本控制它们，并在它们周围创建新对象。
- en: Creating Unity assets and adding them to the scene
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Unity 资产并将它们添加到场景中
- en: 'The custom properties and behaviors in a Unity project are defined through
    various types of files that are generically called **assets**. Our project has
    four remaining questions and requirements that we must address by creating and
    configuring assets:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 项目中的自定义属性和行为是通过各种类型的文件定义的，这些文件统称为 **资产**。我们的项目还有四个剩余的问题和要求，我们必须通过创建和配置资产来解决：
- en: What is the appearance of the surfaces in the scene—namely, the video feed,
    the detected circles and lines, and the simulated balls and lines? We need to
    write *shader* code and create *Material* configurations to define the appearance
    of these surfaces.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景中表面的外观是什么——即视频流、检测到的圆圈和线条以及模拟的球和线条？我们需要编写 *着色器* 代码并创建 *材质* 配置来定义这些表面的外观。
- en: How bouncy are the balls? We need to create a *Physics Material* configuration
    to answer this all-important question.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球的弹跳性如何？我们需要创建一个 *物理材质* 配置来回答这个所有重要的问题。
- en: What objects represent a simulated ball and a simulated line? We need to create
    and configure *Prefab* objects that the simulation can instantiate.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些对象代表模拟的球体和模拟的线条？我们需要创建和配置模拟可以实例化的*预制件*对象。
- en: How does it all behave? We need to write Unity *scripts*—specifically, code
    that subclasses a Unity class called `MonoBehaviour`—in order to control objects
    in the scene at various stages in their life cycles.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些是如何表现的？我们需要编写Unity *脚本*——具体来说，是子类化名为`MonoBehaviour`的Unity类的代码——以控制场景中对象在其生命周期各个阶段的操作。
- en: The following subsections will tackle these requirements one by one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子节将逐一解决这些要求。
- en: Writing shaders and creating materials
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写着色器和创建材质
- en: A **shader** is a set of functions that run on the GPU. Although such functions
    can be applied to general-purpose computing, typically, they are used for graphics
    rendering—that is, to define the color of output pixels on the screen based on
    input that describes the lighting, geometry, surface texture, and perhaps other
    variables, such as time. Unity comes with many shaders for common styles of three-dimensional
    and two-dimensional rendering. We can also write our own shaders.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器**是一组在GPU上运行的函数。尽管这些函数可以应用于通用计算，但通常，它们用于图形渲染——即根据描述光照、几何、表面纹理以及其他变量（如时间）的输入来定义屏幕上输出像素的颜色。Unity附带了许多用于三维和二维渲染的常见风格的着色器。我们也可以编写自己的着色器。'
- en: For in-depth tutorials on shader scripting in Unity, see the *Unity 2018 Shaders
    and Effects Cookbook,* *by John P. Doran and Alan Zucconi* (*Packt Publishing,
    2018*).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Unity着色器脚本编写的深入教程，请参阅由John P. Doran和Alan Zucconi编写的《Unity 2018 Shaders and
    Effects Cookbook》（Packt Publishing，2018年）。
- en: 'Let''s create a folder, `Rollingball/Shaders`, and then create a shader in
    it (by clicking on Create |Shader | Standard Surface Shader in the Project pane''s
    context menu). Rename the shader `DrawSolidColor`. Double-click on it to edit
    it, and replace the contents with the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Rollingball/Shaders`文件夹中创建一个文件夹，并在其中创建一个着色器（通过在项目面板的上下文菜单中点击“创建”|“着色器”|“标准表面着色器”）。将着色器重命名为`DrawSolidColor`。双击它以编辑它，并用以下代码替换其内容：
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This humble shader has one parameter—a color. The shader renders pixels in this
    color regardless of conditions, such as lighting. For the purposes of the Inspector
    GUI, the shader's name is Draw | Solid Color, and its parameter's name is Main
    Color.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个朴素的着色器有一个参数——一个颜色。着色器以这种颜色渲染像素，无论条件如何，如光照。对于检查器GUI的目的，着色器的名称是Draw | Solid
    Color，其参数的名称是Main Color。
- en: A material has a shader and a set of parameter values for the shader. The same
    shader may be used by multiple materials, which may use different parameter values.
    Let's create a material that draws solid red. We will use this material to highlight
    detected circles and lines.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 材质具有着色器和一组着色器的参数值。相同的着色器可能被多个材质使用，这些材质可能使用不同的参数值。让我们创建一个绘制纯红色的材质。我们将使用这个材质来突出检测到的圆圈和线条。
- en: 'Create a new folder, `Rollingball/Materials`, and then create a material in
    it (by clicking on Create | Material in the context menu). Rename the material
    `DrawSolidRed`. Select it, and in the Inspector, set its shader to Draw | Solid
    Color and its Main Color to the RGBA value for red (`255`, `0`, `0`, `255`). The
    Inspector should now look as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Rollingball/Materials`文件夹中创建一个新文件夹，并在其中创建一个材质（通过在上下文菜单中点击“创建”|“材质”）。将材质重命名为`DrawSolidRed`。选择它，并在检查器中将其着色器设置为Draw
    | Solid Color，其主颜色设置为红色（`255`, `0`, `0`, `255`）的RGBA值。检查器现在应该如下所示：
- en: '![](img/296677c6-e4bd-4767-a931-726f5d53c06c.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/296677c6-e4bd-4767-a931-726f5d53c06c.png)'
- en: 'We are going to create two more materials using shaders that come with Unity.
    First, create a material, name it `Cyan`, and configure it so that its shader
    is Legacy Shaders | Diffuse and its Main Color is cyan (`0`, `255`, `255`, `255`).
    Leave the Base (RBG) texture as None. We will apply this material to the simulated
    balls and lines. Its Inspector should look as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Unity附带的一些着色器创建两个额外的材质。首先，创建一个材质，将其命名为`Cyan`，并配置其着色器为Legacy Shaders | Diffuse，其主颜色为青色（`0`,
    `255`, `255`, `255`）。将基础（RBG）纹理设置为无。我们将把这个材质应用到模拟的球体和线条上。其检查器应该如下所示：
- en: '![](img/cc6d7f0e-ff56-4b3f-9b80-5734b44d366e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc6d7f0e-ff56-4b3f-9b80-5734b44d366e.png)'
- en: 'Now, create a material named Video and configure it so that its shader is Unlit | Texture.
    Leave the Base (RBG) texture as None. Later, through code, we will assign the
    video texture to this material. Drag the Video material (from the Project pane)
    to VideoRenderer (in the Hierarchy pane) in order to assign the material to the
    quad. Select VideoRenderer and confirm that its Inspector includes the following
    items:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为Video的材质，并配置其着色器为Unlit | Texture。将Base (RBG)纹理设置为None。稍后，我们将通过代码将视频纹理分配给这个材质。将Video材质（从项目面板中）拖到层次结构面板中的VideoRenderer上，以将材质分配给四边形。选择VideoRenderer并确认其检查器包括以下项目：
- en: '![](img/bad6bd55-589a-42f9-bf97-b00382c86d8f.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bad6bd55-589a-42f9-bf97-b00382c86d8f.png)'
- en: We will assign the remaining materials once we have created prefabs and scripts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建预制件和脚本后分配剩余的材料。
- en: Now that we have made materials for rendering, let's look at the analogous concept
    of physics materials.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为渲染创建了材质，让我们看看物理材质的类似概念。
- en: Creating physics materials
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建物理材质
- en: Although Unity's rendering pipeline can run custom functions that we write in
    shaders, its physics pipeline runs fixed functions. Nonetheless, we can configure
    the parameters of those functions through physics materials.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity的渲染管线可以运行我们在着色器中编写的自定义函数，但其物理管线运行固定函数。尽管如此，我们可以通过物理材质来配置这些函数的参数。
- en: Unity's physics engine is based on NVIDIA PhysX. PhysX supports acceleration
    through CUDA on NVIDIA GeForce GPUs. However, on typical mobile devices, the physics
    calculations will run on the CPU.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理引擎基于NVIDIA PhysX。PhysX支持通过NVIDIA GeForce GPU上的CUDA进行加速。然而，在典型的移动设备上，物理计算将在CPU上运行。
- en: 'Let''s create a folder, `Rollingball/Physics Materials`, and in it, create
    a physics material (by clicking on Create | Physics Material in the context menu).
    Rename the physics material `Bouncy`. Select it, and note that it has the following
    properties in the Inspector:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Rollingball/Physics Materials`的文件夹，并在其中创建一个物理材质（通过在上下文菜单中点击创建 | 物理材质）。将物理材质重命名为`Bouncy`。选择它，并注意在检查器中它有以下属性：
- en: '**Dynamic Friction**: This is the ratio between the force that presses two
    objects together (for example, gravity) and the frictional force that resists
    continued motion along the surface.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态摩擦**：这是两个物体相互挤压（例如，重力）的力与抵抗沿表面继续运动的摩擦力之间的比率。'
- en: '**Static Friction**: This is the ratio between the force pressing two objects
    together (for example, gravity) and the frictional force that resists initial
    motion along the surface. Refer to Wikipedia ([https://en.wikipedia.org/wiki/Friction#Approximate_coefficients_of_friction](https://en.wikipedia.org/wiki/Friction#Approximate_coefficients_of_friction))
    for sample values. For static friction, a value of 0.04 is like Teflon on Teflon,
    a value of 1.0 is like rubber on concrete, and a value of 1.05 is like copper
    on cast iron.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静摩擦**：这是两个物体相互挤压（例如，重力）的力与抵抗沿表面初始运动的摩擦力之间的比率。参考维基百科（[https://en.wikipedia.org/wiki/Friction#Approximate_coefficients_of_friction](https://en.wikipedia.org/wiki/Friction#Approximate_coefficients_of_friction)）获取示例值。对于静摩擦，0.04的值类似于特氟龙在特氟龙上，1.0的值类似于橡胶在混凝土上，1.05的值类似于铜在铸铁上。'
- en: '**Bounciness**: This is the proportion of an object''s kinetic energy that
    it retains when it bounces off another surface. Here, a value of `0` means that
    the object doesn''t bounce. A value of `1` means that it bounces without a loss
    of energy. A value greater than 1 means that it (unrealistically) gains energy
    when it bounces.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这是物体在从另一个表面弹跳时保留的动能比例。在这里，`0`的值表示物体不会弹跳。`1`的值表示物体无能量损失地弹跳。大于`1`的值表示物体在弹跳时（不切实际地）获得了能量。'
- en: '**Friction Combine**: When objects collide, which object''s friction value
    affects this object? The options are Average, Minimum, Multiply, and Maximum.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩擦组合**：当物体碰撞时，哪个物体的摩擦值会影响这个物体？选项有平均值、最小值、乘法和最大值。'
- en: '**Bounce Combine**: When objects collide, which object''s bounciness value
    affects this object? The options are Average, Minimum, Multiply, and Maximum.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹跳组合**：当物体碰撞时，哪个物体的弹性值会影响这个物体？选项有平均值、最小值、乘法和最大值。'
- en: Careful! Are those physics materials explosive?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！那些物理材质是爆炸性的吗？
- en: A physics simulation is said to explode when the values grow continually and
    overflow the system's floating-point numeric limits. For example, if a collision's
    combined bounciness is greater than `1` and the collision occurs repeatedly, then
    over time, the forces tend toward infinity. Kaboom! We broke the physics engine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理模拟的值不断增长并超出系统的浮点数限制时，我们说它 **爆炸**。例如，如果一个碰撞的合并弹跳性大于 `1` 并且碰撞重复发生，那么随着时间的推移，力趋向于无穷大。嘭！我们破坏了物理引擎。
- en: Even without weird physics materials, numeric problems arise in scenes of an
    extremely large or small scale. For example, consider a multiplayer game that
    uses input from the **Global Positioning System** (**GPS**) so that objects in
    a Unity scene are positioned according to the players' real-world longitude and
    latitude. The physics simulation cannot handle a human-sized object in this scene,
    because the object and the forces acting on it are so small that they vanish inside
    the margin of floating-point error! This is a case where the simulation implodes (rather
    than explodes).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有奇怪的物理材质，在极端大或小规模的场景中也会出现数值问题。例如，考虑一个使用来自 **全球定位系统**（**GPS**）的输入的多玩家游戏，以便
    Unity 场景中的对象根据玩家的真实世界经纬度定位。物理模拟无法处理这个场景中的人形物体，因为物体及其作用力非常小，以至于它们在浮点误差的范围内消失！这是一个模拟内爆（而不是爆炸）的情况。
- en: 'Let''s set the Bounciness to `1` (very bouncy!) and leave the other values
    at their defaults. Later, you can adjust everything to your tastes, if you wish.
    The Inspector should look as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将弹跳性设置为 `1`（非常弹跳！）并将其他值保留在默认设置。稍后，如果您愿意，您可以调整一切以符合您的口味。检查器应该看起来如下：
- en: '![](img/b0fe9302-677d-4cf1-80bb-24e60d39a813.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0fe9302-677d-4cf1-80bb-24e60d39a813.png)'
- en: Our simulated lines will use default physics parameters, so they don't need
    a physics material.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟的线条将使用默认的物理参数，因此不需要物理材质。
- en: Now that we have our rendering materials and physics materials, let's create
    prefabs for an entire simulated ball and an entire simulated line.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了我们的渲染材质和物理材质，让我们为整个模拟球和整个模拟线条创建预制体。
- en: Creating prefabs
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建预制体
- en: A **prefab** is an object that isn't a part of a scene itself, but is designed
    to be copied into scenes during editing or at runtime. It can be copied many times
    to make many objects in the scene. At runtime, the copies have no special connection
    to the prefab or each other, and all copies can behave independently. Although
    the role of a prefab is sometimes likened to the role of a class, a prefab is
    not a type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**预制体**是一个不属于场景本身的物体，但设计用于在编辑或运行时被复制到场景中。它可以被复制多次以在场景中创建多个对象。在运行时，这些副本与预制体或彼此之间没有特殊连接，所有副本都可以独立行为。尽管预制体的作用有时被比作类的角色，但预制体并不是一个类型。'
- en: 'Even though prefabs are not part of a scene, they are created and typically
    edited through a scene. Let''s create a sphere in the scene by selecting GameObject | 3D
    Object | Sphere from the menu bar. An object named **Sphere** should appear in
    the Hierarchy. Rename it `SimulatedCircle`. Drag each of the following assets
    from the Project pane onto `SimulatedCircle` in the Hierarchy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管预制体不是场景的一部分，但它们通常是通过场景创建和编辑的。让我们通过从菜单栏中选择 GameObject | 3D Object | Sphere
    来在场景中创建一个球体。一个名为 **Sphere** 的对象应该出现在层次结构中。将其重命名为 `SimulatedCircle`。将以下资产从项目面板拖到层次结构中的
    `SimulatedCircle`：
- en: '**Cyan** (in `Rollingball/Materials`)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**青色**（在 `Rollingball/Materials` 中）'
- en: '**Bouncy** (in `Rollingball/PhysicsMaterials`)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bouncy** (在 `Rollingball/PhysicsMaterials` 中)'
- en: 'Now, select SimulatedCircle. In the Inspector, click on Add Component and select
    Physics | Rigidbody. A Rigidbody section should appear in the Inspector. In this
    section, expand the Constraints field and check Freeze Position | Z. The effect
    of this change is to constrain the sphere''s motion to two dimensions. Confirm
    that the Inspector looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择 SimulatedCircle。在检查器中，点击添加组件并选择 Physics | Rigidbody。检查器中应出现 Rigidbody
    部分。在此部分中，展开约束字段并勾选 Freeze Position | Z。这种变化的效果是将球体的运动限制在二维。确认检查器看起来如下：
- en: '![](img/bf5b268b-0e8a-496c-b5ab-dfcb42e8810d.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf5b268b-0e8a-496c-b5ab-dfcb42e8810d.png)'
- en: Create a folder, `Rollingball/Prefabs`, and drag `SimulatedCircle` from the Hierarchy
    into the folder in the Project pane. A prefab, also named `SimulatedCircle`, should
    appear in the folder. Meanwhile, the name of the `SimulatedCircle` object in the Hierarchy
    should turn blue to indicate that the object has a prefab connection. Changes
    to the object in the scene may be applied back to the prefab by clicking on the
    Apply button in the scene object's Inspector. Conversely, changes to the prefab
    (at edit time, not at runtime) are automatically applied to instances in scenes,
    except for properties in which an instance has unapplied changes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件夹，`Rollingball/Prefabs`，并将 Hierarchy 中的 `SimulatedCircle` 拖动到 Project
    窗格中的文件夹中。一个名为 `SimulatedCircle` 的预制件应该出现在文件夹中。同时，Hierarchy 中的 `SimulatedCircle`
    对象名称应该变为蓝色，以表示该对象具有预制件连接。可以通过在场景对象 Inspector 中的 Apply 按钮上单击将场景中对象的更改应用到预制件。相反，预制件（在编辑时，而不是在运行时）的更改会自动应用到场景中的实例，除非实例有未应用更改的属性。
- en: 'Now, let''s follow similar steps to create a prefab of a simulated line. Create
    a cube in the scene by selecting GameObject | 3D Object | Cube from the menu bar.
    An object named Cube should appear in the Hierarchy. Rename it `SimulatedLine`.
    Drag Cyan from the Project pane onto SimulatedLine in the Hierarchy. Select SimulatedLine,
    add a Rigidbody component, and, in the Rigidbody section of its Inspector, check
    Is Kinematic, which means that the object is not moved by the physics simulation
    (even though it is a part of the simulation for the purpose of other objects colliding
    with it). Recall that we want the lines to be stationary. They are just obstacles
    for the falling balls. The Inspector should now look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们遵循类似的步骤来创建一个模拟线的预制件。从菜单栏中选择 GameObject | 3D Object | Cube 创建场景中的一个立方体。一个名为
    Cube 的对象应该出现在 Hierarchy 中。将其重命名为 `SimulatedLine`。将 Project 窗格中的 Cyan 拖动到 Hierarchy
    中的 SimulatedLine 上。选择 SimulatedLine，添加一个 Rigidbody 组件，并在其 Inspector 的 Rigidbody
    部分中勾选 Is Kinematic，这意味着该对象不会被物理模拟移动（尽管它仍然是模拟的一部分，以便其他对象与之碰撞）。回想一下，我们希望线条保持静止。它们只是下落球体的障碍物。现在，Inspector
    应该看起来像这样：
- en: '![](img/3deaf9e6-9d68-4cd7-9796-6ab38e5a9496.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3deaf9e6-9d68-4cd7-9796-6ab38e5a9496.png)'
- en: Let's clean up our scene by deleting the instances of the prefabs from the Hierarchy so
    that we don't have any circles or lines in the scene when it opens. (However,
    we want to keep the prefabs themselves in the Project so that we can instantiate
    them later through our scripts.) Now, let's turn our attention to the writing
    of scripts, which, among other things, are able to copy prefabs at runtime.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清理场景，通过从 Hierarchy 中删除预制件的实例来删除场景中的任何圆或线。（然而，我们希望保留预制件本身在 Project 中，以便我们可以通过脚本稍后实例化它们。）现在，让我们将注意力转向脚本的编写，脚本能够复制预制件，这是其中之一。
- en: Writing our first Unity script
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个 Unity 脚本
- en: 'As we mentioned earlier, a Unity script is a subclass of `MonoBehaviour`. A
    `MonoBehaviour` object can obtain references to objects in the Hierarchy and components
    that we attach to these objects in the Inspector. A `MonoBehaviour` object also
    has its own Inspector, where we can assign additional references, including references
    to Project assets, such as prefabs. At runtime, Unity sends messages to all `MonoBehaviour`
    objects when certain events occur. A subclass of `MonoBehaviour` may implement
    callbacks for any of these messages. `MonoBehaviour` supports more than 60 standard
    message callbacks. Here are some examples:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Unity 脚本是 `MonoBehaviour` 的子类。一个 `MonoBehaviour` 对象可以获取对 Hierarchy
    中对象的引用以及我们在 Inspector 中附加到这些对象的组件。`MonoBehaviour` 对象还有一个自己的 Inspector，我们可以在这里分配额外的引用，包括对
    Project 资产（如预制件）的引用。在运行时，当某些事件发生时，Unity 会向所有 `MonoBehaviour` 对象发送消息。`MonoBehaviour`
    的子类可以为这些消息中的任何一种实现回调。`MonoBehaviour` 支持超过 60 种标准消息回调。以下是一些示例：
- en: '`Awake`: This is called during initialization.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Awake`：在初始化期间调用。'
- en: '`Start`: This is called after `Awake`, but before the first call to `Update`.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start`：在 `Awake` 之后，但在第一次调用 `Update` 之前被调用。'
- en: '`Update`: This is called every frame.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`：每帧都会调用。'
- en: '`OnGUI`: This is called when the GUI overlay is ready for rendering instructions
    and GUI events are ready to be handled.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnGUI`：当 GUI 投影层准备好渲染指令并且 GUI 事件准备好被处理时被调用。'
- en: '`OnPostRender`: This is called after the scene is rendered. This is an appropriate
    callback in which to implement post-processing effects.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPostRender`：在场景渲染后调用。这是一个实现后处理效果的适当回调。'
- en: '`OnDestroy`: This is called when this instance of the script is about to be
    destroyed. For example, this happens when the scene is about to end.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy`：当这个脚本的实例即将被销毁时调用。例如，当场景即将结束时会发生这种情况。'
- en: For more information on the standard message callbacks and the arguments that
    some callbacks' implementations may optionally take, see the official documentation
    at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
    Also, note that we can send custom messages to all `MonoBehaviour` objects by
    using the `SendMessage` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于标准消息回调以及一些回调实现可能可选接受的参数的信息，请参阅官方文档[http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html)。另外，请注意，我们可以通过使用`SendMessage`方法向所有`MonoBehaviour`对象发送自定义消息。
- en: Implementations of these and Unity's other callbacks may be `private`, `protected`,
    or `public`. Unity calls them regardless of the protection level.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现以及Unity的其他回调可以是`private`、`protected`或`public`。Unity会根据保护级别调用它们。
- en: To summarize, then, scripts are the glue—the game logic—connecting runtime events
    to various objects that we see in the Project, Hierarchy, and Inspector.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，脚本就像是胶水——游戏逻辑——将运行时事件连接到我们在项目、层次结构和检查器中看到的各个对象。
- en: 'Let''s create a folder, `Rollingball/Scripts`, and in that, create a script
    (by clicking on Create | C# Script in the context menu). Rename the script `QuitOnAndroidBack`
    and double-click on it to edit it. Replace its contents with the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个文件夹，`Rollingball/Scripts`，并在其中创建一个脚本（通过在上下文菜单中点击“创建”|“C# 脚本”）。将脚本重命名为`QuitOnAndroidBack`，双击它以编辑它。用以下代码替换其内容：
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are using a namespace, `com.nummist.rollingball`, to keep our code organized
    and to avoid potential conflicts between our type names and type names in other
    parties' code. Namespaces in C# are like packages in Java. Our class is called
    `QuitOnAndroidBack`. It extends Unity's `MonoBehaviour` class. We use the `sealed`
    modifier (similar to Java's `final` modifier) to indicate that we don't intend
    to create subclasses of `QuitOnAndroidBack`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命名空间`com.nummist.rollingball`来组织我们的代码，并避免我们的类型名称与其他方代码中的类型名称之间可能出现的潜在冲突。C#中的命名空间类似于Java中的包。我们的类名为`QuitOnAndroidBack`。它扩展了Unity的`MonoBehaviour`类。我们使用`sealed`修饰符（类似于Java的`final`修饰符）来表示我们不打算创建`QuitOnAndroidBack`的子类。
- en: Note that `MonoBehaviour` uses the UK English spelling of behavior.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`MonoBehaviour`使用的是英国英语拼写行为。
- en: Thanks to Unity's callback system, the script's `Start` method is called after
    the object is initialized—in this case, at the start of the scene. Our `Start`
    method ensures that the standard Android navigation bar is visible. After `Start`,
    the script's `Update` method gets called every frame. It checks whether the user
    has pressed a key (or button) that is mapped to the `Escape` keycode. On Android,
    the standard back button is mapped to `Escape`. When the key (or button) is pressed,
    the application quits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Unity的回调系统，脚本中的`Start`方法在对象初始化后调用——在这种情况下，是在场景开始时。我们的`Start`方法确保标准Android导航栏可见。在`Start`之后，脚本中的`Update`方法每帧都会被调用。它检查用户是否按下了映射到`Escape`键码的键（或按钮）。在Android上，标准返回按钮映射到`Escape`。当按键（或按钮）被按下时，应用程序将退出。
- en: 'Save the script and drag it from the **Project** pane to the `QuitOnAndroidBack`
    object in the Hierarchy. Click on the `QuitOnAndroidBack` object and confirm that
    its Inspector looks like the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，并将其从**项目**面板拖动到层次结构中的`QuitOnAndroidBack`对象。单击`QuitOnAndroidBack`对象，确认其检查器看起来如下截图所示：
- en: '![](img/2a6142e4-2d6c-46e6-8e48-b82452922c60.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a6142e4-2d6c-46e6-8e48-b82452922c60.png)'
- en: That was an easy script, right? The next one is a bit trickier, but more fun,
    because it handles everything except quitting.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段脚本很简单，对吧？下一个脚本稍微有点复杂，但更有趣，因为它处理了除了退出之外的所有事情。
- en: Writing the main Rollingball script
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Rollingball主脚本
- en: 'Let''s create a folder, `Rollingball/Scripts`, and in it, create a script (by
    clicking on Create | C# Script in the context menu). Rename the script `DetectAndSimulate`
    and double-click on it to edit it. Delete its default contents and begin the code
    with the following `import` statements:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个文件夹，`Rollingball/Scripts`，并在其中创建一个脚本（通过在上下文菜单中点击“创建”|“C# 脚本”）。将脚本重命名为`DetectAndSimulate`，双击它以编辑它。删除其默认内容，并从以下`import`语句开始编写代码：
- en: '[PRE2]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let''s declare our namespace and class with the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用以下代码声明我们的命名空间和类：
- en: '[PRE3]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the class has an attribute, `[RequireComponent (typeof(Camera))]`,
    which means that the script can only be attached to a game object that has a camera
    (not a video camera, but rather, a game-world camera representing the player's
    virtual eye in the scene). We specify this requirement because we are going to
    highlight the detected shapes through an implementation of the standard `OnPostRender`
    callback, and this callback only gets called for scripts attached to a game object
    with a camera.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该类有一个属性 `[RequireComponent (typeof(Camera))]`，这意味着脚本只能附加到具有摄像头的游戏对象（不是视频摄像头，而是一个代表场景中玩家虚拟眼睛的游戏世界摄像头）。我们指定这个要求是因为我们将通过实现标准的
    `OnPostRender` 回调来突出显示检测到的形状，而这个回调只为附加到具有摄像头的游戏对象的脚本调用。
- en: '`DetectAndSimulate` needs to store representations of circles and lines in
    both two-dimensional screen space and three-dimensional world space. Coordinates
    in screen space (that is, on the user''s screen) are measured in pixels, with
    the screen''s top-left pixel pixel being the origin. Coordinates in world space
    (that is, in the game scene where we recently positioned `VideoRenderer` and `Main
    Camera`) are measured in arbitrary units with an arbitrary origin. The representations
    of circles and lines don''t need to be visible to any other class in our application,
    so it is appropriate to define their types as private inner structs. Our `Circle`
    type stores two-dimensional coordinates representing the circle''s center in screen
    space, a float representing its radius in screen space, and three-dimensional
    coordinates representing the circle''s center in world space. A constructor accepts
    all of these values as arguments. Here is the `Circle` implementation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`DetectAndSimulate` 需要存储在二维屏幕空间和三维世界空间中圆形和线的表示。屏幕空间中的坐标（即在用户的屏幕上）以像素为单位测量，屏幕的左上角像素是原点。世界空间中的坐标（即在最近定位
    `VideoRenderer` 和 `Main Camera` 的游戏场景中）以任意单位测量，具有任意原点。圆形和线的表示不需要对应用程序中的任何其他类可见，因此将它们的类型定义为私有内部结构是合适的。我们的
    `Circle` 类型存储在屏幕空间中表示圆心的二维坐标、表示屏幕空间中半径的浮点数以及表示世界空间中圆心的三维坐标。构造函数接受所有这些值作为参数。以下是
    `Circle` 的实现：'
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We define another inner struct, `Line`, to store two sets of two-dimensional
    coordinates representing endpoints in screen space and two sets of three-dimensional
    coordinates representing the same endpoints in world space. A constructor accepts
    all of these values as arguments. Here is the implementation of `Line`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了另一个内部结构 `Line`，用于存储在屏幕空间中表示端点的两套二维坐标和在世界空间中表示相同端点的两套三维坐标。构造函数接受所有这些值作为参数。以下是
    `Line` 的实现：
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we define member variables that are editable in the Inspector. Such a
    variable is marked with the `[SerializeField]` attribute, which means that Unity
    serializes the variable, despite it being non-public. (Alternatively, public variables
    are also editable in the Inspector.) The following four variables describe our
    preferences for camera input, including the direction the camera faces, its resolution,
    and its frame rate:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了在检查器中可编辑的成员变量。这样的变量带有 `[SerializeField]` 属性，这意味着尽管它是非公共的，Unity 也会序列化该变量。（或者，公共变量也可以在检查器中编辑。）以下四个变量描述了我们对摄像头输入的偏好，包括摄像头面对的方向、其分辨率和帧率：
- en: '[PRE6]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At runtime, the camera devices and modes available to us may differ from these
    preferences.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，我们可用的摄像头设备和模式可能与这些偏好不同。
- en: 'We will also make several more variables editable in the Inspector—namely,
    a reference to the video background''s renderer, a reference to the material for
    highlighting detected shapes, a factor for adjusting the scale of the simulation''s
    gravity, references to the simulated shapes'' prefabs, and a font size for the
    button:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在检查器中使几个更多变量可编辑——具体来说，是视频背景渲染器的引用、用于突出显示检测到的形状的材料引用、调整模拟重力缩放因子的一个因子、模拟形状预制体的引用以及按钮的字体大小：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also have a number of member variables that don''t need to be editable in
    the Inspector. Among them are references to the game world''s camera, a reference
    to the real-world camera''s video texture, matrices to store images and intermediate
    processing results, and measurements relating to camera images, the screen, simulated
    objects, and the button:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些成员变量不需要在检查器中可编辑。其中包含对游戏世界摄像头的引用、对现实世界摄像头视频纹理的引用、用于存储图像和中间处理结果的矩阵以及与摄像头图像、屏幕、模拟对象和按钮相关的测量值：
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We store a matrix of Hough circle representations in OpenCV''s format (which
    has image coordinates for a landscape image, in this case) and a list of circle
    representations in our own `Circle` format (which has screen coordinates for a
    portrait screen, as well as three-dimensional coordinates for a game world):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 OpenCV 的格式存储霍夫圆表示的矩阵（在这种情况下，对于景观图像具有图像坐标）以及以我们自己的 `Circle` 格式存储的圆表示列表（对于肖像屏幕具有屏幕坐标，以及游戏世界的三维坐标）：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, we store a matrix of Hough line representations in OpenCV''s format
    and a list of line representations in our own `Line` format:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们以 OpenCV 的格式存储霍夫线表示的矩阵，以及以我们自己的 `Line` 格式存储的线表示列表：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We hold a reference to the gyroscope input device and we store the magnitude
    of gravity to be used in our physics simulation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们持有陀螺仪输入设备的引用，并将用于物理模拟的重力幅度存储起来：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We (and the Unity API) are using the terms **gyroscope** and **gyro** loosely.
    We are referring to a fusion of motion sensors that may or may not include a real
    gyroscope. A gyroscope can be simulated, albeit poorly, by using other real sensors,
    such as an accelerometer or gravity sensor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们（以及 Unity API）对 **陀螺仪** 和 **gyro** 术语的使用比较宽松。我们指的是可能包含或不包含真实陀螺仪的运动传感器的融合。陀螺仪可以通过使用其他真实传感器（如加速度计或重力传感器）来模拟，尽管模拟效果可能不佳。
- en: Unity provides a property, `SystemInfo.supportsGyroscope`, to indicate whether
    the device has a real gyroscope. However, this information doesn't concern us.
    We just use Unity's `Gyroscope.gravity` property, which might be derived from
    a real gravity sensor or might be simulated by using other real sensors, such
    as an accelerometer and/or gyroscope. Unity Android apps are configured to require
    an accelerometer by default, so we can safely assume that at least a simulated
    gravity sensor is available.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一个属性 `SystemInfo.supportsGyroscope`，用来指示设备是否具有真实的陀螺仪。然而，这个信息并不影响我们。我们只是使用
    Unity 的 `Gyroscope.gravity` 属性，这个属性可能来自真实的重力传感器，或者可能通过使用其他真实传感器（如加速度计和/或陀螺仪）来模拟。默认情况下，Unity
    Android 应用配置为需要加速度计，因此我们可以安全地假设至少有一个模拟的重力传感器可用。
- en: 'We keep track of a list of simulated objects, and we provide a property, `simulating`,
    that is `true` when the list is non-empty:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跟踪模拟对象的列表，并提供一个 `simulating` 属性，当列表非空时为 `true`：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s turn our attention to methods. We implement the standard `Start`
    callback. The implementation begins by getting a reference to the attached camera,
    initializing matrices, getting a reference to the gyro, and computing the magnitude
    of the game world''s gravity, as seen in the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向方法。我们实现了标准的 `Start` 回调。实现过程首先获取附加摄像机的引用，初始化矩阵，获取陀螺仪的引用，并计算游戏世界中重力的幅度，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `MonoBehaviour` object provides getters for many components that may be
    attached to the same game object as the script. Such components would appear alongside
    the script in the Inspector. For example, the `camera` getter returns a `Camera`
    object (or `null`, if none are present). These getters are expensive because they
    use introspection. Thus, if you need to refer to a component repeatedly, it is
    more efficient to store the reference in a member variable by using a statement
    such as `_camera = camera;`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour` 对象为可能附加到与脚本相同游戏对象的许多组件提供了获取器。这些组件将出现在检查器中与脚本并列。例如，`camera`
    获取器返回一个 `Camera` 对象（如果没有，则为 `null`）。这些获取器很昂贵，因为它们使用了反射。因此，如果你需要反复引用一个组件，使用如 `_camera
    = camera;` 这样的语句将引用存储在成员变量中会更高效。'
- en: You might be wondering why we initialize `Mat` objects in the `Start` method,
    instead of initializing them when we declare them or in a constructor for `DetectAndSimulate`.
    The reason is that the OpenCV libraries are not necessarily loaded until after
    scripts such as `DetectAndSimulate` have been constructed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在 `Start` 方法中初始化 `Mat` 对象，而不是在声明它们时或在 `DetectAndSimulate` 构造函数中初始化。原因是
    OpenCV 库不一定在 `DetectAndSimulate` 等脚本构建之后才被加载。
- en: 'The implementation of `Start` proceeds by finding a camera that faces the required
    direction (either front or rear, depending on the value of the preceding `useFrontFacingCamera`
    field). If we are playing the scene in the Unity editor (in order to debug the
    script and scene during development), we hardcode the camera direction to be front-facing,
    in order to support typical webcams. If no suitable camera is found, the method
    returns early, as seen in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start` 方法的实现继续通过查找面向所需方向（根据前面的 `useFrontFacingCamera` 字段值，可以是正面或背面）的摄像头。如果我们正在
    Unity 编辑器中播放场景（为了在开发期间调试脚本和场景），我们将摄像头方向硬编码为正面，以支持典型的网络摄像头。如果没有找到合适的摄像头，该方法会提前返回，如下面的代码所示：'
- en: '[PRE14]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Throughout our implementation of `DetectAndSimulate`, when we encounter an unrecoverable
    runtime problem, we call `Destroy(this);`, thereby deleting the instance of the
    script and preventing further messages from reaching its callbacks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现 `DetectAndSimulate` 的过程中，当我们遇到无法恢复的运行时问题时，我们会调用 `Destroy(this);`，从而删除脚本的实例，防止进一步的消息到达其回调函数。
- en: 'The `Start` callback concludes by activating the camera and gyroscope (including
    the gravity sensor) and launching a helper coroutine called `Init`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start` 回调通过激活摄像头和陀螺仪（包括重力传感器）并启动一个名为 `Init` 的辅助协程来结束：'
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A **coroutine** is a method that doesn't necessarily run to completion in one
    frame. Rather, it can `yield` for one or more frames, in order to wait for a certain
    condition to be fulfilled or to make something happen after a defined delay. Note
    that a coroutine runs on the main thread.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程** 是一种不一定在一个帧内运行到完成的方法。相反，它可以 `yield` 一个或多个帧，以等待某个条件得到满足或在一个定义的延迟后发生某些事情。请注意，协程在主线程上运行。'
- en: 'Our `Init` coroutine begins by waiting for the camera to capture the first
    frame. Then, we determine the frame''s dimensions and we create OpenCV matrices
    to match these dimensions. Here is the first part of the method''s implementation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Init` 协程首先等待摄像头捕获第一帧。然后，我们确定帧的尺寸并创建与这些尺寸匹配的 OpenCV 矩阵。以下是该方法实现的第一部分：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The coroutine proceeds by configuring the game world''s orthographic camera
    and video quad to match the capture resolution and to render the video texture:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 协程继续通过配置游戏世界的正交摄像头和视频四边形以匹配捕获分辨率并渲染视频纹理：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The device''s screen and captured camera images likely have different resolutions.
    Moreover, recall that our application is configured for portrait orientation (in
    PlayerSettings). This orientation affects screen coordinates, but not the coordinates
    in camera images, which will remain in landscape orientation. Thus, we need to
    calculate the conversion factors between image coordinates and screen coordinates,
    as seen in the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的屏幕和捕获的摄像头图像可能具有不同的分辨率。此外，回想一下，我们的应用程序配置为竖屏方向（在 PlayerSettings 中）。这种方向影响屏幕坐标，但不影响摄像头图像中的坐标，摄像头图像将保持横屏方向。因此，我们需要计算图像坐标和屏幕坐标之间的转换系数，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our conversions will be based on fitting the video background to the width of
    the portrait screen, while either letterboxing or cropping the video at the top
    and bottom, if necessary.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的转换将基于将视频背景适配到竖屏宽度，如果需要，则在顶部和底部进行信箱或裁剪视频。
- en: 'The thickness of the simulated lines and the dimensions of the button are based
    on the screen resolution, as seen in the following code, which concludes the `Init`
    coroutine:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟线的厚度和按钮的尺寸基于屏幕分辨率，如下面的代码所示，这标志着 `Init` 协程的结束：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We implement the standard `Update` callback by processing gravity sensor input
    and processing camera input, provided that certain conditions are met. At the
    beginning of the method, if OpenCV objects are not yet initialized, the method
    returns early. Otherwise, the game world''s direction of gravity is updated based
    on the real-world direction of gravity, as detected by the device''s gravity sensor.
    Here is the first part of the method''s implementation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过处理重力传感器输入和处理满足某些条件的摄像头输入来实现标准的 `Update` 回调。在方法开始时，如果 OpenCV 对象尚未初始化，该方法会提前返回。否则，根据设备重力传感器检测到的真实世界重力方向，更新游戏世界重力方向。以下是该方法实现的第一部分：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, if there is no new camera frame ready or if the simulation is currently
    running, the method returns early. Otherwise, we convert the frame into OpenCV''s
    format, convert it into gray, find the edges, and call two helper methods, `UpdateCircles`
    and `UpdateLines`, to perform shape detection. Here is the relevant code, which
    concludes the `Update` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果没有准备好新的相机帧或者当前正在运行模拟，该方法会提前返回。否则，我们将帧转换为OpenCV的格式，将其转换为灰度，找到边缘，并调用两个辅助方法，`UpdateCircles`和`UpdateLines`，以执行形状检测。以下是相关代码，它总结了`Update`方法：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our `UpdateCircles` helper method begins by performing Hough circle detection.
    We are looking for circles at least `10.0` pixels apart, with a radius of at least
    `5.0` pixels, and at most, `60` pixels. We specify that internally, `HoughCircles`
    should use a Canny upper threshold of `200`, down sample by a factor of `2`, and
    require `150.0` intersections to accept a circle. We clear the list of any previously
    detected circles. Then, we iterate over the results of the Hough circle detection.
    Here is the opening of the method''s implementation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UpdateCircles`辅助方法首先执行Hough圆检测。我们寻找至少`10.0`像素间隔的圆，半径至少`5.0`像素，最多`60`像素。我们指定内部`HoughCircles`应使用Canny上限阈值`200`，以`2`倍进行下采样，并需要`150.0`个交点来接受一个圆。我们清除之前检测到的任何圆的列表。然后，我们遍历Hough圆检测的结果。以下是方法实现的开始部分：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We use a helper method, `ConvertToScreenPosition`, to convert each circle''s
    center point from the image space to the screen space. We also convert its diameter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个辅助方法，`ConvertToScreenPosition`，将每个圆的中心点从图像空间转换为屏幕空间。我们还将它的直径进行转换：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We use another helper method, `ConvertToWorldPosition`, to convert the circle''s
    center point from the screen space to the world space. We also convert its diameter.
    Having done our conversions, we instantiate a `Circle` and add it to the list.
    Here is the code, which completes the `UpdateCircles` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个辅助方法，`ConvertToWorldPosition`，将圆的中心点从屏幕空间转换为世界空间。我们还将它的直径进行转换。完成转换后，我们实例化一个`Circle`并将其添加到列表中。以下是完成`UpdateCircles`方法的代码：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our `UpdateLines` helper method begins by performing probabilistic Hough line
    detection with step sizes of one pixel and one degree. For each line, we require
    at least `50` detected intersections with edge pixels, a length of at least `50`
    pixels, and no gaps of more than `10.0` pixels. We clear the list of any previously
    detected lines. Then, we iterate over the results of the Hough line detection.
    Here is the first part of the method''s implementation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UpdateLines`辅助方法首先执行概率Hough线检测，步长为每个像素和每个度。对于每条线，我们要求至少有`50`个与边缘像素的检测交点，长度至少`50`像素，并且没有超过`10.0`像素的间隙。我们清除之前检测到的任何线的列表。然后，我们遍历Hough线检测的结果。以下是方法实现的第一部分：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We use our `ConvertToScreenPosition` helper method to convert each line''s
    endpoints from the image space to the screen space:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ConvertToScreenPosition`辅助方法将每条线的端点从图像空间转换为屏幕空间：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, we use our `ConvertToWorldPosition` helper method to convert the
    line''s endpoints from the screen space to the world space. Having done our conversions,
    we instantiate a `Line` and add it to the list. Here is the code, which completes
    the `UpdateLines` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们使用`ConvertToWorldPosition`辅助方法将线的端点从屏幕空间转换为世界空间。完成转换后，我们实例化一个`Line`并将其添加到列表中。以下是完成`UpdateLines`方法的代码：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our `ConvertToScreenPosition` helper method takes into account the fact that
    our screen coordinates are in portrait format, whereas our image coordinates are
    in landscape format. The conversion from image space to screen space is implemented
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ConvertToScreenPosition`辅助方法考虑到我们的屏幕坐标是竖屏格式，而我们的图像坐标是横屏格式。图像空间到屏幕空间的转换实现如下：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our `ConvertToWorldPosition` helper method uses Unity''s built-in raycasting
    functionality and our specified target distance, `raycastDistance`, to convert
    the given two-dimensional screen coordinates into three-dimensional world coordinates:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ConvertToWorldPosition`辅助方法使用Unity内置的射线投射功能以及我们指定的目标距离`raycastDistance`，将给定的二维屏幕坐标转换为三维世界坐标：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We implement the standard `OnPostRender` callback by checking whether any simulated
    balls or lines are present, and, if not, by calling a helper method, `DrawPreview`.
    Here is the code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查是否有任何模拟的球或线存在，如果没有，则调用辅助方法`DrawPreview`来实现标准的`OnPostRender`回调。以下是代码：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `DrawPreview` helper method serves to show the positions and dimensions
    of detected circles and lines, if any. To avoid unnecessary draw calls, the method
    returns early if there are no objects to draw, as seen in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawPreview`辅助方法的作用是显示检测到的圆和线的位置和尺寸（如果有）。为了避免不必要的绘制调用，如果没有要绘制的对象，该方法会提前返回，如下面的代码所示：'
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Having determined that there are detected shapes to draw, the method proceeds
    by configuring the OpenGL context to draw in the screen space by using `drawPreviewMaterial`.
    This setup is seen in the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 确定有检测到的形状需要绘制后，该方法通过使用`drawPreviewMaterial`配置OpenGL上下文以在屏幕空间中绘制。这种设置如下面的代码所示：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If there are any detected circles, we do one draw call to highlight them all.
    Specifically, we tell OpenGL to begin drawing quads, we feed it the screen coordinates
    of squares that approximate the circles, and then we tell it to stop drawing quads.
    Here is the code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有检测到的圆，我们进行一次绘制调用以突出显示它们。具体来说，我们告诉OpenGL开始绘制四边形，我们给它提供近似圆的正方形屏幕坐标，然后我们告诉它停止绘制四边形。以下是代码：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similarly, if there are any detected lines, we do one draw call to highlight
    them all. Specifically, we tell OpenGL to begin drawing lines, we feed it the
    lines'' screen coordinates, and then we tell it to stop drawing lines. Here is
    the code, which completes the `DrawPreview` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果有检测到的线，我们进行一次绘制调用以突出显示它们。具体来说，我们告诉OpenGL开始绘制线，我们给它提供线的屏幕坐标，然后我们告诉它停止绘制线。以下是代码，它完成了`DrawPreview`方法：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We implement the standard `OnGUI` callback by drawing a button. Depending on
    whether simulated balls and lines are already present, the button says either
    Stop Simulation or Start Simulation. (However, if there are no simulated balls
    or lines, and there are also no detected balls or lines, then the button is not
    shown at all.) When the button is clicked, a helper method is called (either `StopSimulation`
    or `StartSimulation`). Here is the code for `OnGUI`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过绘制一个按钮来实现标准的`OnGUI`回调。根据是否有模拟的球和线存在，按钮上显示的是停止模拟或开始模拟。但是，如果没有模拟的球或线，也没有检测到的球或线，则按钮根本不会显示。当按钮被点击时，会调用一个辅助方法（`StopSimulation`或`StartSimulation`）。以下是`OnGUI`的代码：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `StartSimulation` helper method begins by pausing the video feed and placing
    copies of the `simulatedCirclePrefab` atop the detected circles. Each instance
    is scaled to match a detected circle''s diameter. Here is the first part of the
    method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartSimulation`辅助方法首先暂停视频流，并将`simulatedCirclePrefab`的副本放置在检测到的圆上。每个实例都按检测到的圆的直径进行缩放。以下是该方法的第一部分：'
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The method finishes by placing copies of `simulatedLinePrefab` atop the detected
    lines. Each instance is scaled to match a detected line''s length. Here is the
    rest of the method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过放置`simulatedLinePrefab`的副本在检测到的线上结束。每个实例都按检测到的线的长度进行缩放。以下是该方法的其他部分：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `StopSimulation` helper method simply serves to resume the video feed,
    delete all simulated balls and lines, and clear the list that contained these
    simulated objects. With the list empty, the conditions for the detectors to run
    (in the `Update` method) are fulfilled again. `StopSimulation` is implemented
    like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopSimulation`辅助方法简单地用于恢复视频流，删除所有模拟的球和线，并清除包含这些模拟对象的列表。列表为空时，检测器再次满足运行条件（在`Update`方法中）。`StopSimulation`的实现如下：'
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When the script''s instance is destroyed (at the end of the scene), we ensure
    that the webcam and gyroscope are released, as seen in the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本的实例被销毁（场景结束时），我们确保释放了摄像头和陀螺仪，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Save the script and drag it from the Project pane to the Main Camera object
    in the Hierarchy. Click on the Main Camera object, and, in the Detect And Simulate
    (Script) section of its Inspector, drag the following objects to the following
    fields:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，并将其从项目面板拖动到层次结构中的主摄像机对象。点击主摄像机对象，在其检查器的“检测和模拟（脚本）”部分，将以下对象拖到以下字段：
- en: Drag `VideoRenderer` (from the Hierarchy) to the Video Renderer field (in the
    Inspector)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`VideoRenderer`（来自层次结构）拖到检查器的视频渲染器字段
- en: Drag `DrawSolidRed` (from `Rollingball/Materials` in the Project pane) to the
    Draw Preview Material field (in the Inspector)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`DrawSolidRed`（来自项目面板中的`Rollingball/Materials`）拖到检查器的绘制预览材质字段
- en: Drag `SimulatedCircle` (from `Rollingball/Prefabs` in the Project pane) to the
    Simulated Circle Prefab field (in the Inspector)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`SimulatedCircle`（来自项目面板中的`Rollingball/Prefabs`）拖到检查器的模拟圆预制件字段
- en: Drag `SimulatedLine` (from `Rollingball/Prefabs` in the Project pane) to the
    Simulated Line Prefab field (in the Inspector)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“SimulatedLine”（从项目面板中的“Rollingball/Prefabs”）拖动到“模拟线预制体”字段（在检查器中）
- en: 'After these changes, the script''s section in the Inspector should look like
    the following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改后，脚本在“检查器”中的部分应如下截图所示：
- en: '![](img/bcfcbe15-3f81-4b7a-8c3a-cc50e7236ee6.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bcfcbe15-3f81-4b7a-8c3a-cc50e7236ee6.png)'
- en: Our main scene is complete! Now, we need a simple launcher scene that is responsible
    for obtaining the user's permission to access the camera and for launching the
    main scene.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要场景已完成！现在，我们需要一个简单的启动器场景，该场景负责获取用户访问摄像头的权限，并启动主要场景。
- en: Creating the launcher scene in Unity
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中创建启动器场景
- en: Our `Rollingball` scene, and specifically the `DetectAndSimulate` script, attempts
    to access a camera through Unity's `WebCamDevice` and `WebCamTexture` classes.
    Unity is somewhat smart about camera permissions on Android. At the start of the
    `Rollingball` scene (or any scene that requires camera access), Unity will automatically
    check whether the user has granted permission for camera access; if not, Unity
    will request permission. Unfortunately, this automatic request comes too late
    for `DetectAndSimulate` to properly access the camera in its `Start` and `Init`
    methods. To avoid this kind of problem, it is better to write a launcher scene
    with a script that explicitly requests camera access.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Rollingball”场景，特别是“DetectAndSimulate”脚本，试图通过Unity的“WebCamDevice”和“WebCamTexture”类访问摄像头。Unity在Android上的摄像头权限方面有些智能。在“Rollingball”场景开始时（或任何需要访问摄像头的场景），Unity会自动检查用户是否已授予摄像头访问权限；如果没有，Unity将请求权限。不幸的是，这种自动请求对于“DetectAndSimulate”在它的“Start”和“Init”方法中正确访问摄像头来说来得太晚了。为了避免这类问题，最好编写一个带有脚本的开机场景，该脚本明确请求摄像头访问权限。
- en: 'Create a new scene and save it as `Launcher` in the `Rollingball/Scenes` folder.
    Delete the Directional Light from the scene. Add an empty object and name it `Launcher`.
    Now, the scene''s Hierarchy should look like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并将其保存为“Launcher”在“Rollingball/Scenes”文件夹中。从场景中删除方向光。添加一个空对象并命名为“Launcher”。现在，场景的“层次结构”应如下所示：
- en: '![](img/82455710-cbb2-4a73-b14b-6a3caf0fbb74.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82455710-cbb2-4a73-b14b-6a3caf0fbb74.png)'
- en: 'Edit the Main Camera in the Inspector to give it a solid black background,
    as shown in the following screenshot:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中编辑“主摄像头”，给它一个实心的黑色背景，如下截图所示：
- en: '![](img/fde1c045-a75c-4933-b25a-5e2e9371555f.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fde1c045-a75c-4933-b25a-5e2e9371555f.png)'
- en: 'In `Rollingball/Scripts`, create a new script, rename it `Launcher`, edit it,
    and replace its contents with the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Rollingball/Scripts”中创建一个新的脚本，将其重命名为“Launcher”，编辑它，并用以下代码替换其内容：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Upon `Start`, this script checks whether the user has already granted permission
    to access the camera. If not, the script requests permission by showing a standard
    Android permission request dialog. The `Start` method finishes by loading the
    `Rollingball` scene that we created previously.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Start”时，此脚本检查用户是否已授予访问摄像头的权限。如果没有，脚本通过显示标准的Android权限请求对话框来请求权限。`Start`方法通过加载我们之前创建的“Rollingball”场景来完成。
- en: 'Save the script and drag it from the Project pane to the `Launcher` object
    in the Hierarchy. Click on the `Launcher` object and confirm that its Inspector
    looks like the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，并将其从“项目”面板拖动到“启动器”对象中。点击“启动器”对象，确认其“检查器”看起来如下：
- en: '![](img/e13afcc0-0c96-4270-949f-7be5ebd10dd5.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e13afcc0-0c96-4270-949f-7be5ebd10dd5.png)'
- en: Our launcher scene is complete. All that remains is to configure, build, and
    test our project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的启动器场景已完成。剩下的只是配置、构建和测试我们的项目。
- en: Tidying up and testing
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整理和测试
- en: 'Let''s return to the Build Settings window (File | Build Settings...). We no
    longer want the OpenCV for Unity demos in our build. Remove them by either unchecking
    them or selecting and deleting them (*Delete* on Windows or *Cmd* + *Del* on Mac).
    Then, add the `Launcher` and `Rollingball` scenes by dragging them from the Project
    pane into the Scenes In Build list. When you are finished, the Build Settings
    window should look like the following screenshot:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到“构建设置”窗口（文件 | 构建设置...）。我们不再希望在构建中包含OpenCV for Unity演示。通过取消选中它们或选择并删除它们（Windows上的*删除*或Mac上的*Cmd*
    + *Del*）来删除它们。然后，通过从“项目”面板拖动到“构建中的场景”列表中，添加“启动器”和“Rollingball”场景。完成时，“构建设置”窗口应如下截图所示：
- en: '![](img/49fa420d-dffc-41e7-bd5e-0c81926a40c8.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49fa420d-dffc-41e7-bd5e-0c81926a40c8.png)'
- en: Click on the Build and Run button, overwrite any previous builds, and let the
    good times roll!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“构建和运行”按钮，覆盖任何之前的构建，让好时光继续！
- en: If you are building for iOS, remember to follow the additional instructions
    in `OpenCVForUnity/ReadMe.pdf`. Particularly, ensure that the project's Camera
    Usage Description is set to a helpful descriptive string, for example `Rollingball`
    uses the camera to detect circles and lines (obviously!) and that the Target minimum
    iOS Version is set to `8.0`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在为iOS构建，请记住遵循`OpenCVForUnity/ReadMe.pdf`中的附加说明。特别是，确保项目的相机使用描述设置为有用的描述字符串，例如`Rollingball`使用相机来检测圆和线（显然！）并且将目标最低iOS版本设置为`8.0`。
- en: Test the app by drawing and scanning dots and lines of various sizes, with various
    styles of pen strokes. Also, try scanning some things that are not drawings. Feel
    free to go back to the code, edit the detectors' parameters, rebuild, and see
    how the sensitivity has changed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制和扫描各种大小、各种笔触风格的点和线来测试应用。也可以尝试扫描一些不是绘图的东西。随时可以回到代码中，编辑检测器的参数，重新构建，看看灵敏度是如何变化的。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has really rounded out our experience and has drawn a line under
    our accomplishments. You have learned how to detect primitive shapes by using
    the Hough transform. We have also used OpenCV and Unity together to turn a pen
    and paper drawing into a physics toy. We have even surpassed the things that Q
    can make a pen do!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章真正丰富了我们的经验，并为我们的成就划上了句号。你已经学会了如何通过使用霍夫变换来检测原始形状。我们还一起使用了OpenCV和Unity，将笔和纸的草图转换成了一个物理玩具。我们甚至超越了Q所能让笔做到的事情！
- en: Still, a secret agent cannot solve all problems with ink and paper alone. Next,
    we will take off our reading glasses, put down our physics simulations, and consider
    ways of deconstructing real motion in the world around us. Prepare to look through
    the kaleidoscope of the frequency domain!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个秘密特工不能仅凭墨水和纸张就能解决所有问题。接下来，我们将摘下我们的阅读眼镜，放下我们的物理模拟，并考虑分解我们周围世界中的真实运动的方法。准备好通过频率域的万花筒来观察！
