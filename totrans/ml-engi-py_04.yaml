- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Packaging Up
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包汇总
- en: In previous chapters, we introduced a lot of the tools and techniques you will
    need to use to successfully build working **machine learning** (**ML**) products.
    We also introduced a lot of example pieces of code that helped us to understand
    how to implement these tools and techniques. So far, this has all been about *what*
    we need to program, but this chapter will focus on *how* to program. In particular,
    we will introduce and work with a lot of the techniques, methodologies, and standards
    that are prevalent in the wider Python software development community and apply
    them to ML use cases. The conversation will be centered around the concept of
    developing *user-defined libraries and packages*, reusable pieces of code that
    you can use to deploy your ML solutions or develop new ones. It is important to
    note that everything we discuss here can be applied to all of your Python development
    activities across your ML project development life cycle. If you are working on
    some exploratory data analysis in a notebook or some modeling scripts for the
    research portion of your project, your work will still benefit immensely from
    the concepts we are about to introduce.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了很多你将需要使用以成功构建工作**机器学习**（**ML**）产品的工具和技术。我们也介绍了很多示例代码片段，帮助我们理解如何实现这些工具和技术。到目前为止，这一切都是关于**什么**我们需要编程，但这一章将专注于**如何**编程。特别是，我们将介绍并使用许多在更广泛的Python软件开发社区中普遍存在的技术、方法和标准，并将它们应用于ML用例。对话将围绕开发**用户定义的库和包**的概念展开，这些是你可以用来部署你的ML解决方案或开发新解决方案的可重用代码片段。重要的是要注意，我们在这里讨论的每一件事都可以应用于你ML项目开发生命周期中的所有Python开发活动。如果你在笔记本中做一些探索性数据分析，或者为项目的研究部分编写一些建模脚本，你的工作将从我们即将介绍的概念中受益匪浅。
- en: In this chapter, we will recap some of the basic points of programming in Python,
    before discussing the concept of coding standards and some pointers for writing
    high-quality Python code. We will also touch upon the difference between **object-oriented**
    and **functional** programming in Python, and where this has strengths and points
    of synergy with other tools that you may want to use in your solution. We will
    discuss some good use cases for writing your own ML packages and go through the
    options for packaging up. Next will be a discussion on testing, logging, and error
    handling in your code, which are important concepts for building code that can
    be trusted not just to work but also to be diagnosable when it doesn’t. This will
    be followed by a deep dive into the logical flow of our package. Finally, we will
    perform an exploration of how we ensure we do not reinvent the wheel and use functionality
    that already exists elsewhere.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些Python编程的基本要点，然后讨论编码标准和编写高质量Python代码的一些提示。我们还将简要介绍Python中的**面向对象**编程和**函数式**编程之间的区别，以及这些在其他你可能希望在其解决方案中使用的工具中的优势和协同作用。我们将讨论编写自己的ML包的一些良好用例，并探讨打包选项。接下来，我们将讨论代码中的测试、日志记录和错误处理，这些是构建既可信赖又能诊断当它不工作时的重要概念。然后，我们将深入探讨我们包的逻辑流程。最后，我们将探索如何确保我们不重新发明轮子，并使用其他地方已经存在的功能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing good Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写好的Python
- en: Choosing a style
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择风格
- en: Packaging your code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包你的代码
- en: Building your package
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的包
- en: Testing, logging, and error handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试、日志记录和错误处理
- en: Not reinventing the wheel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重新发明轮子
- en: IMPORTANT NOTE
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There isn’t a clearly defined difference between a package and a library in
    Python. The general consensus seems to be that *library* often refers to any collection
    of code you want to reuse in other projects, whereas *package* refers to a collection
    of Python modules (covered in this chapter). We will often use the two interchangeably
    here with the understanding that when we say library, we are usually referring
    to a bunch of code that is cleanly put together and contains at least one package.
    This means that we won’t count single scripts with some code you reuse later as
    a library for our purposes here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，包和库之间没有明确定义的区别。普遍的看法似乎是，**库**通常指的是你希望在其他项目中重用的任何代码集合，而**包**则指的是Python模块的集合（本章将涉及）。在这里，我们通常会互换使用这两个词，理解当我们说库时，我们通常指的是一组干净地组织在一起并至少包含一个包的代码。这意味着我们不会将包含你以后重用的一些代码的单个脚本视为我们的目的中的库。
- en: Who doesn’t want to write more robust, clean, readable, testable, and performant
    code that can be used by our colleagues, the ML community, or even our customers?
    Let’s get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 谁不想编写更健壮、干净、易于阅读、可测试和性能良好的代码，这些代码可以被我们的同事、机器学习社区甚至我们的客户使用？让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the other chapters, the dependencies required to run the examples in
    this chapter can be installed by navigating to the `Chapter 04` folder of the
    book repository and creating a new Conda environment:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节一样，运行本章示例所需的依赖项可以通过导航到书籍仓库中的`第四章`文件夹并创建一个新的Conda环境来安装：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should note that this chapter mainly focuses on Python fundamentals around
    packaging, so the requirements are a bit lighter than usual!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，本章主要关注Python的打包基础知识，因此要求比通常要轻一些！
- en: Writing good Python
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写好的Python代码
- en: As discussed throughout this book, Python is an extremely popular and very versatile
    programming language. Some of the most widely used software products in the world,
    and some of the most widely used ML engineering solutions in the world, use Python
    as a core language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中讨论的那样，Python是一种极其流行且非常灵活的编程语言。世界上一些最广泛使用的软件产品和一些最广泛使用的ML工程解决方案都使用Python作为核心语言。
- en: Given this scope and scale, it is clear that if we are to write similarly amazing
    pieces of ML-driven software, we should once again follow the best practices and
    standards already adopted by these solutions. In the following sections, we will
    explore what packaging up means in practice, and start to really level up our
    ML code in terms of quality and consistency.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个范围和规模下，很明显，如果我们想要编写同样出色的ML驱动软件，我们应该再次遵循这些解决方案已经采纳的最佳实践和标准。在接下来的章节中，我们将探讨实际中打包意味着什么，并开始真正提升我们的ML代码在质量和一致性方面的水平。
- en: Recapping the basics
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾基础知识
- en: Before we get stuck into some more advanced concepts, let’s make sure we are
    all on the same page and go over some of the basic terminology of the Python world.
    If you feel quite confident in the fundamentals of Python, then you can skip this
    section and carry on with the rest of the chapter. However, going over these fundamentals
    if you are a bit newer to Python or have not revised them in a while will ensure
    that you apply the right thought processes to the right things and that you can
    feel confident when writing your code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究更高级的概念之前，让我们确保我们都在同一页面上，并回顾一下Python世界的一些基本术语。如果你对Python的基础知识非常有信心，那么你可以跳过这一节，继续阅读本章的其余部分。然而，如果你是Python的新手或者有一段时间没有复习这些基础知识，那么回顾这些基础知识将确保你将正确的思维过程应用于正确的事物，并在编写代码时感到自信。
- en: 'In Python, we have the following objects:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们有以下对象：
- en: '**Variable**: An object that stores data of one of a variety of types. In Python,
    variables can be created through **assignment** without specifying the type, for
    example:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：存储一种或多钟类型数据的对象。在Python中，可以通过**赋值**创建变量，而不必指定类型，例如：'
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Function**: A unit of code that is self-contained and performs logical steps
    on variables (or another object). Defined by the `def` keyword in Python and can
    return any Python object. Functions are *first-class citizens* in Python, which
    means you can reference them using their object name (and re-reference them),
    and that functions can pass and return functions. So, for example, if we create
    a function that calculates some simple statistics from a pandas DataFrame, we
    can do the following. First, define it:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：一个自包含的代码单元，对变量（或另一个对象）执行逻辑步骤。在Python中，函数通过`def`关键字定义，可以返回任何Python对象。函数在Python中是**一等公民**，这意味着你可以使用它们的对象名称（并重新引用它们），并且函数可以传递和返回函数。例如，如果我们创建一个从pandas
    DataFrame计算一些简单统计数据的函数，我们可以这样做。首先，定义它：'
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then run it using the original name and a DataFrame called `X_train`:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用原始名称和一个名为`X_train`的DataFrame运行它：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then you can re-assign the function using a new name and similarly call it:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以使用新的名称重新分配函数并相应地调用它：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can then pass the function around even more. For example, if you pass the
    function into a new function that takes the result and returns a JSON object,
    then you can call that!
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以将函数传递给更多的函数。例如，如果你将函数传递给一个新函数，该函数接受结果并返回一个JSON对象，那么你可以调用它！
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This can help build up some simple pieces of code into something relatively
    complex quite quickly.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以帮助快速将一些简单的代码片段构建成相对复杂的结构。
- en: '**Module**: This is a file containing definitions and statements of functions,
    variables, and other objects where the contents can be imported into other Python
    code. For example, if we put the functions defined in the previous example into
    a file called `module.py`, we can then type the following in another Python program
    (or the Python interpreter) in order to use the functionality contained within
    it:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：这是一个包含函数、变量和其他对象定义和声明的文件，其内容可以被导入到其他Python代码中。例如，如果我们把之前示例中定义的函数放入一个名为`module.py`的文件中，我们就可以在另一个Python程序（或Python解释器）中输入以下内容，以便使用其中包含的功能：'
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Class**: We will discuss classes in detail in the *Object-oriented programming*
    section, but for now, just know that these are the basic units of object-oriented
    programming, and act as a nice way of containing logically related functionality.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：我们将在*面向对象编程*部分详细讨论类，但在此，只需知道这些是面向对象编程的基本单元，并且是包含逻辑上相关功能的好方法。'
- en: '**Package**: This is a collection of modules that are coupled together via
    their directory structure and is built such that modules in the package are accessed
    through the `dot` syntax. For example, if we have a package called `feature` that
    contains modules to help us to do feature engineering, it could be organized as
    follows:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包**：这是一个通过它们的目录结构相互关联的模块集合，并且构建得使得包中的模块可以通过`dot`语法访问。例如，如果我们有一个名为`feature`的包，它包含帮助我们进行特征工程的模块，它可以组织如下：'
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, if we wanted to use the functionality contained within the `numerical`
    or `categorical` sub-modules, we would use the `dot` syntax like so:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，如果我们想使用`numerical`或`categorical`子模块中包含的功能，我们会使用如下所示的`dot`语法：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let’s move on to discuss some general Python tips and tricks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论一些通用的Python小技巧。
- en: Tips and tricks
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小技巧
- en: 'Let’s now discuss some tips and tricks for using Python that can often be overlooked,
    even by those quite familiar with the language. The following concepts can help
    you write more compact and performant code, so it’s good to have them to hand.
    Note that this list is definitely not exhaustive:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论一些使用Python时常常被忽视的小技巧，即使是对这种语言相当熟悉的人也不例外。以下的概念可以帮助你编写更紧凑和高效的代码，所以最好手头上有这些技巧。请注意，这个列表绝对不是详尽的：
- en: '**Generators**: These are convenience functions for helping us create a syntax
    that iterates in some sense. They save us from writing a lot of boilerplate code,
    are memory efficient, and have very useful properties, such as the ability to
    pause execution and save the internal state automatically. Then you can resume
    iterating with it later in your program. Generators are created in Python whenever
    we define a function that uses the `yield` statement. For example, here we can
    define a generator that will filter a given list of values based on a predicate
    called `condition`:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器**：这些是帮助我们创建某种迭代语法的便利函数。它们让我们免于编写大量的模板代码，内存效率高，并且具有非常实用的特性，例如能够暂停执行并自动保存内部状态。然后你可以在程序中的稍后位置继续迭代。在Python中，每当定义一个使用`yield`语句的函数时，就会创建生成器。例如，在这里我们可以定义一个生成器，它将根据名为`condition`的谓词过滤给定的值列表：'
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In action, we could apply this to a simple list of the integers from zero to
    ninety-nine called `data_vals` and filter out values below a certain threshold:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际操作中，我们可以将这个技巧应用到从零到九十九的整数列表`data_vals`上，并过滤掉低于某个阈值的值：
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will return the integers from fifty to ninety-nine.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回从五十到九十九的整数。
- en: 'The other way to define a generator expression is by using an iterative statement
    in round brackets. For example, here we can define a generator that iterates over
    the squares from zero to nine:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义生成器表达式的另一种方式是使用圆括号中的迭代语句。例如，在这里我们可以定义一个生成器，它将遍历从零到九的平方：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that you can only execute your generators once; after that, they are *empty*.
    This is because they only store what they need in memory for each step of the
    iteration, so once it is complete, nothing is stored!
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你只能执行你的生成器一次；之后，它们就是空的。这是因为它们只为迭代的每一步存储所需的内存，所以一旦完成，就不会存储任何内容！
- en: Generators are really powerful ways of creating data manipulation steps that
    are memory efficient and can be used to define custom pipelines in frameworks
    such as Apache Beam. We will not cover this here, but it is definitely worth checking
    out. As an example, take a look at the article at [https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e](https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e).
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成器是创建内存高效的数据操作步骤的强大方式，可以用于在Apache Beam等框架中定义自定义管道。这里我们不会涉及这个话题，但它绝对值得一看。例如，可以查看[https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e](https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e)上的文章。
- en: '**List comprehension**: This is a syntax that allows us to take any iterable
    we have to hand (a `dict`, a `list`, a `tuple`, and a `str` are all examples)
    and build a list from it in an extremely compact way. This can save you from writing
    long, clunky loops and can help create some more elegant code. List comprehensions
    create the entire list in memory, so they are not as efficient as generators.
    So use them wisely, and only create small lists if you can. You perform list comprehension
    by writing your iteration logic in square brackets, as opposed to the round brackets
    of generators. As an example, we can create the data used in the first generator
    example:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表推导式**：这是一种语法，允许我们以极其紧凑的方式从任何可迭代的对象（例如`dict`、`list`、`tuple`和`str`）中构建一个列表。这可以让你避免编写冗长、笨拙的循环，并有助于创建更优雅的代码。列表推导式在内存中创建整个列表，因此它们不如生成器高效。所以请明智地使用它们，并且只在必要时创建小列表。你通过在方括号中编写迭代逻辑来执行列表推导式，而不是生成器的圆括号。例如，我们可以创建第一个生成器示例中使用的数据：'
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Containers and collections**: Python has a useful set of built-in types that
    are known as **containers**, these being `dict`, `set`, `list`, and `tuple`. Beginners
    in Python learn how to use these from their first time playing with the language,
    but what we can often forget is their augmented counterparts: **collections**.
    These allow for additional behavior on top of the standard containers, which can
    be useful. The table shown in *Figure 4.1* summarizes some useful containers mentioned
    in the Python 3 documentation on *python.org* at [https://docs.python.org/3/library/collections.xhtml](https://docs.python.org/3/library/collections.xhtml).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器和集合**：Python有一组有用的内置类型，被称为**容器**，包括`dict`、`set`、`list`和`tuple`。Python初学者从第一次接触这门语言开始就学习如何使用这些类型，但我们常常会忘记它们的增强版本：**集合**。这些集合在标准容器的基础上提供了额外的行为，这可能很有用。图4.1所示的表格总结了在*python.org*上Python
    3文档中提到的某些有用的集合。[https://docs.python.org/3/library/collections.xhtml](https://docs.python.org/3/library/collections.xhtml)'
- en: 'These are useful to have to hand when you are working through some data manipulations
    and can often save you a couple of lines of code:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你处理数据操作时，这些工具非常有用，可以节省几行代码：
- en: '| **Container** | **Description** |'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **容器** | **描述** |'
- en: '| deque | This is a double-ended queue and allows you to add and remove elements
    to either end of the object in a scalable way. It’s useful if you want to add
    to the beginning or end of large data lists or if you want to search for the last
    occurrences of X in your data. |'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| deque | 这是一个双端队列，允许你以可扩展的方式向对象的任一端添加和删除元素。如果你想在大型数据列表的开头或结尾添加元素，或者想要在数据中搜索X的最后出现位置，这将非常有用。|'
- en: '| Counter | Counters take in iterables such as dicts or lists and return the
    count of each of the elements. They’re really useful to get quick summaries of
    the content of these objects. |'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Counter | 计数器接受如dict或list之类的可迭代对象，并返回每个元素的计数。它们对于快速总结这些对象的内容非常有用。|'
- en: '| OrderedDict | The standard dict object does not maintain order, so OrderedDict
    introduces this functionality. This can be really useful if you need to loop back
    over a dictionary you have created in the same order as it was created for new
    processing. |'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| OrderedDict | 标准的dict对象不保持顺序，因此OrderedDict引入了这一功能。如果你需要以创建时的顺序遍历你创建的字典以进行新的处理，这将非常有用。|'
- en: 'Table 4.1: Some useful types in the collections module in Python 3.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表4.1：Python 3中集合模块中的一些有用类型。
- en: '***args** and ****kwargs**: When we want to call a function in Python, we often
    supply it with arguments. We have seen plenty of examples of this in this book
    already. But what happens if you define a function for which you would like to
    apply to a varying number of arguments? This is where the ***args** and ****kwargs**
    patterns come in. For example, imagine we want to initialize a class called `Address`
    that uses information gathered from an online web form to create a single string
    giving an address.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`***args**` 和 `****kwargs**`：当我们想在 Python 中调用一个函数时，我们通常会向它提供参数。在这本书中我们已经看到了很多这样的例子。但是，如果您定义了一个希望应用于可变数量参数的函数，会发生什么呢？这就是
    `***args**` 和 `****kwargs**` 模式发挥作用的地方。例如，想象一下我们想要初始化一个名为 `Address` 的类，该类使用从在线表单收集的信息创建一个包含地址的单个字符串。'
- en: 'We may not know how many elements are going to be in each text box used by
    the user for the address ahead of time. We could then use the ***args** pattern
    (you don’t have to call it **args**, so here we’ve called it `address`). Here’s
    the class:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可能无法提前知道用户用于地址的每个文本框将包含多少元素。然后我们可以使用 `***args**` 模式（您不必将其称为 **args**，所以在这里我们将其称为
    `address`）。以下是该类的代码：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then your code will work absolutely fine in both of these cases, even though
    there are a variable number of arguments to the constructor:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您的代码在这两种情况下都将工作得非常好，尽管构造函数的参数数量是可变的：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then `address1.address` will be given by `'62 Lochview Crescent'` and `address2.address`
    will be given by `'The Palm 1283 Royston Road'`.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后 `address1.address` 将由 `'62 Lochview Crescent'` 和 `address2.address` 将由 `'The
    Palm 1283 Royston Road'` 给出。
- en: '****kwargs** extends this idea to allow a variable number of keyword arguments.
    This is particularly useful if you have functions where you may want to define
    a variable number of parameters, but you need names attached to those parameters.
    For example, we may want to define a class for containing ML model hyperparameter
    values, the number and names of which will vary by algorithm. We can therefore
    do something like the following:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**kwargs**` 将这一想法扩展到允许一个可变数量的关键字参数。这在您有函数可能需要定义可变数量的参数，但需要将这些参数与名称关联时特别有用。例如，我们可能想要定义一个包含机器学习模型超参数值的类，其数量和名称将根据算法而变化。因此，我们可以做如下操作：'
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then the code will allow us to define instances such as the following:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，代码将允许我们定义如下实例：
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And then `hyp1.hyperparams` will be given by `{''eps'': 3, ''distance'': ''euclidean''}`
    and `hyp2.hyperparams` by `{''n_clusters'': 4, ''max_iter'': 100}`.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '然后 `hyp1.hyperparams` 将由 `{''eps'': 3, ''distance'': ''euclidean''}` 和 `hyp2.hyperparams`
    由 `{''n_clusters'': 4, ''max_iter'': 100}` 给出。'
- en: There are many more concepts that are important to understand for a detailed
    understanding of how Python works. For now, these pointers will be enough for
    us to build upon throughout the chapter.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于深入了解 Python 的工作原理，还有许多其他概念需要理解。目前，这些提示将足够我们构建本章的内容。
- en: Now we will consider how to define and organize these elements in a way that
    makes your code readable and consistent.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将考虑如何定义和组织这些元素，以便使您的代码可读且一致。
- en: Adhering to standards
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循标准
- en: When you say something like *adhering to standards*, in most contexts, you would
    be forgiven for half-expecting a sigh and a gigantic eye roll from whoever you
    were talking to. Standards sound boring and tedious, but they are in fact an extremely
    important part of making sure that your work is consistent and high quality.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当您提到像“遵循标准”这样的东西时，在大多数情况下，您可能会原谅对方发出一声叹息和巨大的眼神翻白。标准听起来无聊且乏味，但它们实际上是确保您的工作保持一致和高质量的一个极其重要的部分。
- en: 'In Python, the *de facto* standard for coding style is **Python Enhancement
    Proposal 8** (**PEP-8**), written by Guido Van Rossum (the creator of Python),
    Barry Warsaw, and Nick Coghlan ([https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)).
    It is essentially a collection of guidelines, tips, tricks, and suggestions for
    making code that is consistent and readable. Some of the benefits of adhering
    to the PEP-8 style guide in your Python projects are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，编码风格的**事实标准**是 **Python Enhancement Proposal 8**（**PEP-8**），由 Python
    的创造者 Guido Van Rossum、Barry Warsaw 和 Nick Coghlan 撰写（[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)）。它本质上是一系列指南、技巧、窍门和建议，旨在使代码保持一致和可读。遵循
    PEP-8 风格指南在您的 Python 项目中的好处如下：
- en: '**Greater consistency**: This will help you write code that is less likely
    to break once you have deployed it, as it is much easier to follow the flow of
    your programs and identify errors and bugs. Consistency also helps simplify the
    design of extensions and interfaces to your code.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的一致性**：这将帮助你编写在部署后不太可能出错的代码，因为跟踪程序的流程和识别错误和缺陷要容易得多。一致性还有助于简化代码的扩展和接口设计。'
- en: '**Improved readability**: This begets efficiency, as colleagues and even users
    of your solutions can understand what is being done and how to use it more effectively.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可读性**：这将带来效率，因为你的同事甚至解决方案的用户可以理解正在做什么以及如何更有效地使用它。'
- en: So, what is in the PEP-8 style guide? And how should you think about applying
    it to your ML project? For the full details, I recommend you read the PEP-8 documentation
    given earlier. But in the next few paragraphs, we will go into some of the details
    that will give you the greatest improvement to your code for the least effort.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，PEP-8风格指南中包含什么内容？你应该如何考虑将其应用到你的机器学习项目中？关于全部细节，我建议你阅读之前提供的PEP-8文档。但在接下来的几段中，我们将深入探讨一些细节，这些细节将使你在付出最少努力的情况下，对代码的改进最大。
- en: First, let’s cover **naming conventions**. When you write a piece of code, you
    will have to create several variables, files, and other objects, such as classes,
    and these all have to have a name. Making sure that these names are readable and
    consistent is the first part of making your code of a very high standard.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来谈谈**命名规范**。当你编写一段代码时，你需要创建几个变量、文件以及其他对象，比如类，所有这些都需要一个名字。确保这些名字可读且一致是使你的代码达到非常高标准的第一步。
- en: 'Some of the key pointers from PEP-8 are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-8的一些关键要点如下：
- en: '**Variables and function names**: It is recommended that these consist of all
    lowercase words, separated by underscores. They should also help us understand
    what they are for. As an example, if you are building a regression model and you
    want to put some of your feature engineering steps inside a function to simplify
    reuse and readability elsewhere in the code, you may call it something like `Makemydata()`:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量和函数名**：建议这些由全部小写单词组成，用下划线分隔。它们还应帮助我们理解它们的作用。例如，如果你正在构建一个回归模型，并且想在函数中放置一些特征工程步骤以简化代码其他部分的复用和可读性，你可以将其命名为`Makemydata()`：'
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Calling your function `Makemydata()` is not a great idea, whereas naming it
    something like `transform_features` is better:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将你的函数命名为`Makemydata()`不是一个好主意，而将其命名为`transform_features`则更好：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function name is compliant with PEP-8.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数名符合PEP-8规范。
- en: '**Modules and packages**: The recommendation is that these have all short lowercase
    names. Some great examples are ones you are familiar with, such as `pandas`, `numpy`,
    and `scipy`. **Scikit-learn** may seem like it breaks this rule, but it actually
    doesn’t as the package name is `sklearn`. The style guide mentions that modules
    can have underscores to improve readability, but packages should not. If we had
    a module in a package called `transform_helpers`, then this is acceptable, but
    an entire package called `marketing_outlier_detection` would be terrible!'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块和包**：建议这些都应该有简短的小写名字。一些你熟悉的例子，比如`pandas`、`numpy`和`scipy`。**Scikit-learn**可能看起来像是违反了这条规则，但实际上并没有，因为包名是`sklearn`。风格指南提到，模块可以有下划线以提高可读性，但包不应该。如果我们有一个名为`transform_helpers`的模块在包中，这是可以接受的，但一个整个名为`marketing_outlier_detection`的包就会很糟糕！'
- en: '**Classes**: Classes should have names such as `OutlierDetector`, `Transformer`,
    or `PipelineGenerator`, which clearly specify what they do and also follow the
    upper CamelCase or PascalCase (both mean the same thing) style.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：类应该有像`OutlierDetector`、`Transformer`或`PipelineGenerator`这样的名字，这些名字清楚地说明了它们的作用，并且遵循大驼峰式或帕斯卡式（两者意思相同）的风格。'
- en: These are some of the most commonly used naming conventions you should be aware
    of. The PEP-8 document also covers a lot of good points on whitespace and the
    formatting of lines that we will not go into here. We will finish this section
    with a discussion on some of the author’s favorite suggestions from the *programming
    recommendations* of PEP-8\. These are often overlooked and, if forgotten, can
    make for some code that is both horrible to read and likely to break, so take
    heed!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你应该了解的一些最常见的命名规范。PEP-8文档还涵盖了许多关于空白和行格式化的良好观点，我们在这里不会深入讨论。我们将以对作者从PEP-8的*编程建议*中喜欢的建议的讨论来结束本节。这些通常被忽视，如果忘记，可能会使代码既难以阅读又可能出错，所以请注意！
- en: A good point to remember in all of this talk about style is that at the top
    of the PEP-8 document, which states that *Foolish Consistency is the Hobgoblin
    of Little Minds* and that there are good reasons to ignore these style suggestions
    in certain circumstances. Again, read the PEP-8 document for the full works, but
    if you follow these points, then in general, you will write clean and readable
    code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有关于风格的讨论中，一个值得记住的好点是，在PEP-8文档的顶部，它指出“愚蠢的一致性是小智者的恶魔”，并且在某些情况下有很好的理由忽略这些风格建议。再次提醒，请阅读完整的PEP-8文档，但如果你遵循这些要点，那么一般来说，你会写出干净且易于阅读的代码。
- en: Next, we will cover how some of these rules do not really apply when we are
    using the Python API for Apache Spark.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一些规则在当我们使用Apache Spark的Python API时并不适用。
- en: Writing good PySpark
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写好的PySpark
- en: In this section, we draw attention to one particular flavor of Python that is
    very important in the world of data science and ML. PySpark code has already been
    used in examples throughout this book since it is the go-to tool for distributing
    your data workloads, including your ML models. In *Chapter 6*, *Scaling Up*, we
    will learn more about PySpark, but here we will just briefly mention some points
    on coding style.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们关注Python在数据科学和机器学习领域中的一个非常重要的特定版本。PySpark代码已经在本书的多个示例中使用，因为它是分发你的数据工作负载（包括你的机器学习模型）的首选工具。在第6章“扩展”中，我们将学习更多关于PySpark的知识，但在这里我们只是简要地提到一些关于编码风格的观点。
- en: 'As mentioned in the section on *Spark ML pipelines* in *Chapter 3*, *From Model
    to Model Factory*, since Spark is written in Scala, the syntax of PySpark (which
    is just the Python API for Spark) has inherited a lot of the syntactical style
    from that underlying language. This means in practice that many of the methods
    you use will be written in CamelCase, meaning that it also makes sense to define
    your variables using CamelCase rather than the standard Python PEP-8 naming convention
    of words separated by underscores. This is behavior that we should encourage as
    it helps people reading our code to clearly see which sections are PySpark code
    and which are (more) vanilla Python. To emphasize this, when we used the `StringIndexer`
    object from the `pyspark.ml` package before, we used `StringIndexer` instead of
    the more idiomatic Python, `string_indexer`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如第3章中关于*Spark ML管道*的章节“从模型到模型工厂”所述，由于Spark是用Scala编写的，PySpark（即Spark的Python API）的语法已经继承了许多底层语言的语法风格。这意味着在实践中，你使用的许多方法都将使用驼峰式命名，这意味着使用驼峰式定义变量而不是标准的Python
    PEP-8命名约定（单词由下划线分隔）也是合理的。这种行为是我们应该鼓励的，因为它有助于阅读我们代码的人清楚地看到哪些部分是PySpark代码，哪些是（更）纯Python代码。为了强调这一点，当我们之前从`pyspark.ml`包中使用`StringIndexer`对象时，我们使用了`StringIndexer`而不是更符合Python习惯的`string_indexer`：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another important point about PySpark code is that because Spark is written
    in a functional paradigm, it also makes sense that your code also follows this
    style. We will understand a bit more about what this means in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PySpark代码的另一个重要点是，由于Spark是用函数式范式编写的，因此你的代码也遵循这种风格也是合情合理的。我们将在下一节中更深入地了解这意味着什么。
- en: Choosing a style
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择风格
- en: This section will provide a summary of two coding styles or paradigms, which
    make use of different organizational principles and capabilities of Python. Whether
    you write your code in an object-oriented or functional style could just be an
    aesthetic choice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将总结两种编码风格或范式，它们利用了Python不同的组织原则和能力。你编写代码是面向对象还是函数式风格可能只是审美选择。
- en: This choice, however, can also provide other benefits, such as code that is
    more aligned with the logical elements of your problem, code that is easier to
    understand, or even more performant code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种选择也可以提供其他好处，例如与问题的逻辑元素更一致的代码、更容易理解的代码，甚至更高效的代码。
- en: In the following sections, we will outline the main principles of each paradigm
    and allow you to choose for yourself based on your use case.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将概述每个范式的核心原则，并允许你根据自己的用例自行选择。
- en: Object-oriented programming
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**Object-oriented programming** (**OOP**) is a style where the code is organized
    around, you guessed it, abstract objects with relevant attributes and data instead
    of around the logical flow of your solution. The subject of OOP is worth a book
    (or several books!) in itself, so we will focus on the key points that are relevant
    to our ML engineering journey.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是一种编程风格，其中代码是围绕，你猜对了，抽象对象及其相关属性和数据组织的，而不是围绕解决方案的逻辑流程。OOP的主题本身就值得一本（或几本！）书，所以我们将关注与我们机器学习工程之旅相关的关键点。'
- en: 'First, in OOP, you have to define your `objects`. This is done in Python through
    the core OOP principle of classes, which are definitions of structures in your
    program that keep together related data and logical elements. A class is a template
    for defining the objects in OOP. As an example, consider a very simple class that
    groups together some methods for calculating numerical outliers on a dataset.
    For example, if we consider the pipelines that we looked into in *Chapter 3*,
    *From Model to Model Factory*, we may want to have something that makes this even
    easier to apply in a production setting. We may therefore want to wrap up some
    of the functionality provided by tools such as Scikit-Learn into a class of its
    own that could have bespoke steps specific to our problem. In the simplest case,
    if we wanted a class to wrap the standardization of our data and then apply a
    generic outlier detection model, it could look something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在OOP中，你必须定义你的`对象`。这通过Python中的核心OOP原则——类来实现，类是程序中结构的定义，它将相关的数据和逻辑元素组合在一起。类是定义OOP中对象的模板。例如，考虑一个非常简单的类，它将一些用于在数据集上计算数值异常值的方法组合在一起。例如，如果我们考虑在*第3章*中探讨的管道，我们可能希望有一种使它在生产环境中应用得更简单的方法。因此，我们可能希望将Scikit-Learn等工具提供的一些功能封装到我们自己的类中，该类可以具有针对我们问题的特定步骤。在最简单的情况下，如果我们想要一个类来封装我们数据的标准化和应用通用的异常检测模型，它可能看起来像这样：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All this example does is allow a user to skip writing out some of the steps
    that they may have to otherwise write to get the job done. The code doesn’t disappear;
    it just gets placed inside a handy object with a clear logical definition. In
    this case, the pipeline shown is extremely simple, but we can imagine extending
    this to something very complex and containing logic that’s specific to our use
    case.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例所做的只是允许用户跳过编写一些可能需要编写的步骤，以便完成工作。代码并没有消失；它只是被放置在一个方便的对象中，具有清晰的逻辑定义。在这种情况下，显示的流水线非常简单，但我们可以想象将其扩展到非常复杂且包含针对我们特定用例的逻辑。
- en: 'Therefore, if we have already defined an outlier detection model (or retrieved
    it from a model store, such as MLflow, as discussed in *Chapter 3*, *From Model
    to Model Factory*), we can then feed this into this class and run quite complex
    pipelines just with a single line of code, no matter the complexity contained
    within the class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们已经定义了一个异常检测模型（或如*第3章*中讨论的，从模型存储库中检索它，例如MLflow），然后我们可以将其输入到这个类中，并仅用一行代码运行相当复杂的流水线，无论类中包含的复杂性如何：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see from the example, this pattern of implementation seems familiar,
    and it should! **Scikit-learn** has a lot of OOP in it, and you use this paradigm
    every time you create a model. The act of creating a model is a case of you instantiating
    a class object, and the process of you calling `fit` or `predict` on your data
    are examples of calling class methods. So, the reason the preceding code may not
    seem alien is that it shouldn’t! We’ve already been using OOP when working with
    ML with Scikit-Learn.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从示例中看到的，这种实现模式似乎很熟悉，而且应该是这样的！**Scikit-learn**中有很多OOP，每次您创建一个模型时，您都在使用这种范式。创建模型的行为是实例化一个类对象，您在数据上调用`fit`或`predict`的过程是调用类方法的例子。因此，前面的代码可能看起来不陌生，这是因为它不应该陌生！我们已经在使用Scikit-Learn进行机器学习时使用了OOP。
- en: Despite what we have just said, using objects and understanding how to build
    them are obviously two different challenges. So, let’s go through the core concepts
    of building your own classes. This will set us up later for building more classes
    of relevance for our own ML solutions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚才已经说过，使用对象和理解如何构建它们显然是两个不同的挑战。因此，让我们通过构建自己的类的核心概念来探讨。这将为我们后来构建与我们自己的机器学习解决方案相关的更多类打下基础。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, you can see that the functionality we want to group together is defined
    inside the class. Functions that live inside a class are called methods. You can
    see that `OutlierDetector` has only one method, called `detect`, but you are not
    limited in how many methods your class can have.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到我们想要组合的功能是在类内部定义的。存在于类内部的功能被称为方法。你可以看到`OutlierDetector`只有一个名为`detect`的方法，但你并不限制你的类可以有多少个方法。
- en: Methods contain your class’s abilities to interact with data and other objects,
    so their definition is where most of the work of building up your class goes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 方法包含了你的类与数据和其他对象交互的能力，因此它们的定义是构建类时大部分工作的所在。
- en: You might think we have missed a method, the one called `__init__()`. This is
    in fact not a method (or you can think of it as a very special method) and is
    called the *constructor*. The constructor does what it says—it constructs! Its
    job is to perform all of the relevant setup tasks (some of which occur in the
    background, such as memory allocation) for your class when it gets initialized
    as an object. When the example defines `detector`, the constructor is called.
    As you can see, you can pass variables and then these variables can be used within
    the class. Classes in Python can be created without defining an explicit constructor,
    but one will be created in the background. The final point we will make on constructors
    is that they are not allowed to return anything other than `None`, so it’s common
    to leave the `return` statement unwritten.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为我们遗漏了一个方法，即名为`__init__()`的方法。实际上，这并不是一个方法（或者你可以将其视为一个非常特殊的方法），它被称为*构造函数*。构造函数做它所说的——构建！它的任务是执行所有相关的设置任务（其中一些在后台发生，例如内存分配），当类作为对象初始化时。当示例定义`detector`时，构造函数被调用。正如你所见，你可以传递变量，然后这些变量可以在类内部使用。Python中的类可以不定义显式的构造函数，但后台会创建一个。关于构造函数的最后一个观点是，它们不允许返回除`None`之外的内容，因此通常不写`return`语句。
- en: You will also have seen in the example that there are variables inside the class
    and there is a somewhat mysterious `self` keyword. This allows methods and operations
    inside the class to refer to the particular instance of the class. So, if you
    define two or a hundred instances of the `OutlierDetector` object, it is possible
    for them all to have different values for their internal attributes but still
    have the same functionality.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能在示例中看到，类内部有变量，还有一个有些神秘的`self`关键字。这允许类内部的方法和操作引用类的特定实例。所以，如果你定义了两个或一百个`OutlierDetector`对象的实例，它们内部属性可能有不同的值，但仍然具有相同的功能。
- en: We will create some more involved OOP styles for your ML solution later, but
    for now, let’s discuss the other programming paradigm that we may want to use
    – functional programming.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后为你的机器学习解决方案创建一些更复杂的面向对象风格，但就目前而言，让我们讨论我们可能想要使用的另一种编程范式——函数式编程。
- en: Functional programming
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程
- en: '**Functional programming** is based on the concept of, you guessed it, functions.
    At its core, this programming paradigm is about trying to write pieces of code
    that only take in data and output data, doing so without creating any internal
    state that can be changed. One of the goals of functional programming is to write
    code that has no unintended side effects due to mismanagement of state. It also
    has the benefit of making sure that the data flow in your programs can be understood
    completely by looking at the `return` statements of the functions you have written.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**基于，你猜对了，函数的概念。在其核心，这种编程范式是尝试编写只接受数据并输出数据的代码片段，这样做而不创建任何可以改变的内部状态。函数式编程的一个目标是要编写没有由于状态管理不当而产生的意外副作用的代码。它还有确保你可以通过查看你编写的函数的`return`语句完全理解程序中的数据流的优点。'
- en: It uses the idea of the data in your program not being allowed to change in
    place. This concept is known as **immutability**. If your data (or any object)
    is immutable, it means that there is no internal state to modify, and if you want
    to do something with the data, you actually have to create new data. For example,
    in the section on *Object-oriented programming*, we again revisited the concept
    of standardizing data. In a functional program, standardized data cannot overwrite
    unstandardized data; you would need to store this new data somewhere, for example,
    in a new column in the same data structure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了程序中的数据不允许就地更改的想法。这个概念被称为**不可变性**。如果你的数据（或任何对象）是不可变的，这意味着没有内部状态可以修改，如果你想对数据进行操作，实际上你必须创建新的数据。例如，在*面向对象编程*部分，我们再次回顾了标准化数据的概念。在函数式程序中，标准化数据不能覆盖未标准化数据；你需要将新数据存储在某个地方，例如，在相同的数据结构中的新列中。
- en: Some programming languages are designed with functional principles at their
    core, such as F# and Haskell, but Python is a general-purpose language that can
    accommodate both paradigms quite nicely.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言的设计是以函数式原则为核心的，例如 F# 和 Haskell，但 Python 是一种通用语言，可以很好地容纳这两种范式。
- en: 'You will likely have seen some other functional programming concepts in other
    Python code. For example, if you have ever used a lambda function, then this can
    be a powerful aspect of a functionally programmed piece of code as it is how you
    define *anonymous functions* (those without a specified name). So, you may have
    seen code that looks something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在其他 Python 代码中见过一些其他函数式编程的概念。例如，如果你曾经使用过 lambda 函数，那么这可以是一个函数式编程代码片段的强大方面，因为这是你定义*匿名函数*（那些没有指定名称的函数）的方式。所以，你可能见过类似这样的代码：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code block, `df` is a pandas DataFrame and `data` is just a
    column of numbers. This is one of the tools that help make functional programming
    in Python easier. Other such tools are the built-in functions `map()`, `reduce()`,
    and `filter()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`df` 是一个 pandas DataFrame，而 `data` 只是一个数字列。这是帮助使 Python 中的函数式编程更简单的工具之一。其他此类工具包括内置函数
    `map()`、`reduce()` 和 `filter()`。
- en: 'As an example, imagine that we have some address data similar to that in the
    *Recapping the basics* section, where we discussed the concepts of **args** and
    ****kwargs**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，我们有一些类似*回顾基础知识*部分中讨论的地址数据，其中我们讨论了**args**和****kwargs**的概念：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we might want to write some code that returns a list of lists with the
    same shape as this data, but every entry now contains the number of characters
    in each string. This could be a stage in a data preparation step in one of our
    ML pipelines. If we wanted to write some code to do this functionally, we could
    define a function that takes a list and returns a new list with the string lengths
    for the entries like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可能想要编写一些代码，返回一个与该数据形状相同的列表的列表，但每个条目现在包含每个字符串中的字符数。这可能是我们机器学习管道中数据准备步骤的一个阶段。如果我们想要编写一些代码来实现这个功能，我们可以定义一个函数，它接受一个列表并返回一个新的列表，其中包含条目的字符串长度，如下所示：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This embodies functional programming because the data is immutable (there is
    no change of internal state) and the function is pure (it only uses data within
    the scope of the function). We can then use another concept from functional programming
    called higher-order functions, where you supply functions as the arguments of
    other functions. For example, we may want to define a function that can apply
    any list-based function but to a list of lists:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这体现了函数式编程，因为数据是不可变的（没有内部状态的变化）并且函数是纯的（它只使用函数作用域内的数据）。然后我们可以使用函数式编程的另一个概念，即高阶函数，其中你将函数作为其他函数的参数。例如，我们可能想要定义一个函数，它可以应用任何基于列表的函数，但应用于列表的列表：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that this is completely generic; as long as the `list_func()` can be applied
    to a list, this will work on a list of lists. We can therefore get the original
    result we wanted by calling the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是完全通用的；只要 `list_func()` 可以应用于一个列表，它就可以应用于列表的列表。因此，我们可以通过调用以下内容来获取我们想要的原结果：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This returns the desired result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了期望的结果：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Spark, a tool that’s already been used multiple times in this book, is written
    in the Scala language, which is also general-purpose and can accommodate both
    object-oriented and functional programming. Spark is predominantly written in
    a functional style; its aim of distributing computation is more easily accommodated
    if principles such as immutability are respected. This means that when we have
    been typing PySpark code through this book, we have subtly been picking up some
    functional programming practices (did you notice?).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Spark，这本书中已经多次使用过的工具，是用Scala语言编写的，Scala也是一种通用语言，可以容纳面向对象和函数式编程。Spark主要采用函数式风格；如果遵守诸如不可变性等原则，那么其分布计算的目标更容易得到满足。这意味着当我们通过这本书输入PySpark代码时，我们已经在不知不觉中学习了一些函数式编程实践（你注意到了吗？）。
- en: 'In fact, in *Chapter 3*, *From Model to Model Factory*, the example PySpark
    pipeline we built had code like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在*第3章*，*从模型到模型工厂*中，我们构建的示例PySpark管道中的代码是这样的：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is functional since the `data` object we create is actually a new DataFrame
    with the new column added—we can’t just add a column in place. There was also
    code that formed part of our pipelines from the Spark ML library:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数式的，因为我们创建的`data`对象实际上是一个添加了新列的新DataFrame——我们无法简单地就地添加列。还有代码构成了我们从Spark ML库中构建的管道的一部分：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is defining how to take a series of columns in a DataFrame and perform
    a scaling transformation on them. Note how you define input columns and output
    columns, and *these cannot be the same*. That’s immutability in action—you have
    to create new data rather than transform it in place.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在定义如何对一个DataFrame中的多个列进行缩放转换。注意您如何定义输入列和输出列，并且*它们不能相同*。这就是不可变性的体现——您必须创建新的数据而不是就地转换。
- en: Hopefully, this gives you a taste of functional programming in Python. This
    is not the main paradigm we will use in this book, but it will be used for some
    pieces of code, and, in particular, remember that when we use PySpark, we are
    often implicitly using functional programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能让您对Python中的函数式编程有所体会。这并不是本书中我们将主要使用的范式，但我们将用它来编写一些代码片段，特别是记住，当我们使用PySpark时，我们通常是在隐式地使用函数式编程。
- en: We will now discuss ways of packaging the code that you have written.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论如何打包您所编写的代码。
- en: Packaging your code
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包您的代码
- en: In some ways, it is interesting that Python has taken the world by storm. It
    is dynamically typed and non-compiled, so it can be quite different to work with
    compared to Java or C++. This particularly comes to the fore when we think about
    packaging our Python solutions. For a compiled language, the main target is to
    produce a compiled artifact that can run on the chosen environment – a Java `jar`,
    for example. Python requires that the environment you run in has an appropriate
    Python interpreter and the ability to install the libraries and packages you need.
    There is also no single compiled artifact created, so you often need to deploy
    your whole code base as is.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，Python席卷全球是有趣的。它是动态类型和非编译的，因此与Java或C++相比，它的工作方式可能相当不同。当我们思考如何打包我们的Python解决方案时，这一点尤其突出。对于编译型语言，主要目标是生成一个可以在所选环境中运行的编译工件——例如Java的`jar`文件。Python要求您运行的环境具有适当的Python解释器和安装所需库和包的能力。也没有创建单个编译工件，因此您通常需要以原样部署整个代码库。
- en: Despite this, Python has indeed taken the world by storm, especially for ML.
    As we are ML engineers thinking about taking models to production, we would be
    remiss to not understand how to package and share Python code in a way that helps
    others to avoid repetition, trust in the solution, and be able to easily integrate
    it with other projects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Python确实已经席卷全球，尤其是在机器学习领域。作为考虑将模型投入生产的机器学习工程师，如果我们不了解如何打包和共享Python代码，以便帮助他人避免重复、信任解决方案并能够轻松将其集成到其他项目中，那将是我们的失职。
- en: In the following sections, we are first going to discuss what we mean by a user-defined
    library and some of the advantages of packaging your code this way. We are then
    going to define the main ways you can do this so that you can run your ML code
    in production.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们首先将讨论我们所说的用户定义库以及以这种方式打包代码的一些优点。然后我们将定义您可以这样做的主要方式，以便您可以在生产中运行您的机器学习代码。
- en: Why package?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要打包？
- en: Before we discuss in detail exactly what a package or library is in Python,
    we can articulate the advantages by using a working definition of *a collection
    of Python code that can be run without detailed knowledge of its implementation*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细讨论Python中包或库的确切定义之前，我们可以通过使用一个工作定义来阐述其优势，即*一个可以在不了解其实施细节的情况下运行的Python代码集合*。
- en: 'You will have already picked up from this definition the nature of the first
    reason to do this: **abstraction**.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从这个定义中了解了这样做第一个原因的本质：**抽象**。
- en: Bringing together your code into a library or package that can be reused by
    other developers and data scientists in your team, organization, or the wider
    community allows these user groups to solve problems more quickly. Since the details
    of the work are abstracted away, anyone using your code can focus on implementing
    the capabilities of your solution, rather than trying to understand and dissect
    every line. This will lead to reduced development and deployment time in projects,
    as well as encourage the usage of your code in the first place!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的代码汇集到一个库或包中，以便其他开发人员和数据科学家可以在你的团队、组织或更广泛的社区中重用，这允许这些用户群体更快地解决问题。由于工作细节被抽象化，使用你代码的任何人都可以专注于实现你解决方案的功能，而不是试图理解并剖析每一行。这将导致项目开发和部署时间的减少，并鼓励首先使用你的代码！
- en: The second advantage is that, by consolidating the functionality you need into
    a library or package, you bring all of the implementation details to one place
    and therefore *improvements scale*. What we mean by this is if 40 projects are
    using your library and someone discovers a minor bug, you only need to patch it
    *once* and then redeploy or update the package in those 40 implementations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个优势是，通过将所需的功能整合到库或包中，你将所有实现细节集中在一个地方，因此*改进可以扩展*。我们这里的意思是，如果40个项目正在使用你的库，并且有人发现了一个小错误，你只需要修复一次，然后在这些40个实现中重新部署或更新包。
- en: This is way more scalable than explaining the issue to the relevant teams and
    getting 40 different fixes at the implementation end. This consolidation also
    means that once you have thoroughly tested all the components, you can more confidently
    assume that this solution will be running smoothly in those 40 different projects,
    without knowing anything about the details under the hood.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这比向相关团队解释问题并得到40个不同的实施端修复要可扩展得多。这种整合还意味着，一旦你彻底测试了所有组件，你就可以更有信心地假设这个解决方案将在那40个不同的项目中平稳运行，而不必了解任何底层的细节。
- en: '*Figure 4.1* helps to show how packages helpfully allow a *write once, use
    many* philosophy for your code, which is incredibly important if you want to engineer
    ML solutions that can solve multiple problems in a scalable fashion:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.1*有助于展示包如何有助于实现代码的*一次编写，多次使用*哲学，这对于你想要构建可以以可扩展方式解决多个问题的ML解决方案来说至关重要：'
- en: '![Figure 4.2 – Developing packages for your ML solutions allows you to write
    the code once but use it many times in different environments ](img/B19525_04_01.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 为你的ML解决方案开发包允许你一次编写代码，但在不同的环境中多次使用](img/B19525_04_01.png)'
- en: 'Figure 4.1: Developing packages for your ML solutions allows you to write the
    code once but use it many times in different environments.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：为你的ML解决方案开发包允许你一次编写代码，但在不同的环境中多次使用。
- en: The next section will build on these main ideas about packaging to discuss specified
    use cases in which packaging our code can be beneficial.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将基于这些关于打包的主要思想来讨论特定的用例，在这些用例中，打包我们的代码可以是有益的。
- en: Selecting use cases for packaging
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择打包用例
- en: First things first, not all of your solutions should be libraries. If you have
    an extremely simple use case, you may only need one simple script to run on a
    schedule for the core of your ML solution. You can still write a well-engineered
    system and performant code in this case, but it’s not a library. Similarly, if
    your problem is best solved by a web app, then although there will be lots of
    components, it will not naturally be a library.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，并不是所有的解决方案都应该成为库。如果你有一个极其简单的用例，你可能只需要一个简单的脚本来按计划运行你的ML解决方案的核心。在这种情况下，你仍然可以编写一个精心设计的系统和高性能的代码，但这不是库。同样，如果你的问题最好通过一个Web应用来解决，那么尽管会有很多组件，但这不会自然成为一个库。
- en: 'Some good reasons you may want to write up your solution as a library or package
    are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想将你的解决方案编写成库或包的一些良好理由如下：
- en: The problem your code solves is a common one that may come up in multiple projects
    or environments.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码解决的问题是一个常见问题，可能在多个项目或环境中出现。
- en: You want to abstract away implementation details so that execution and development
    are decoupled, making it easier for others to use your code.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要抽象出实现细节，以便执行和开发可以解耦，这样其他人使用你的代码就会更容易。
- en: To minimize the number of places and the number of times you need to change
    code to implement bug fixes.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了最小化你需要更改代码以实现错误修复的地方和次数。
- en: To make testing simpler.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使测试更加简单。
- en: To simplify your **continuous integration/continuous deployment** (**CI/CD**)
    pipeline.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化你的**持续集成/持续部署**（**CI/CD**）流程。
- en: We will now dive into how we might go about designing our packages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将深入探讨我们可能如何设计我们的包。
- en: Designing your package
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计你的包
- en: The layout of your code base is far more than just a stylistic consideration.
    It is something that will determine how your code is used in every instance of
    the project – no pressure!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码库布局远不止是风格上的考虑。它将决定你的代码在项目的每个实例中是如何被使用的——没有压力！
- en: This means that it is important to put some thought into how you want to lay
    out your code and how this influences usage patterns. You need to ensure that
    all of the main components you need have a presence in the code base and are easy
    to find.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要仔细思考你想要如何布局你的代码，以及这如何影响使用模式。你需要确保所有主要组件都在代码库中有存在感，并且容易找到。
- en: Let’s work this through with an example based on the outlier detection case
    we worked through in the previous sections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个基于我们在前几节中解决的异常值检测案例的示例来解决这个问题。
- en: First, we need to decide what kind of solution we want to create. Are we building
    something that will run a web application or a standalone executable with lots
    of functionality, or are we building a library for others to use in their ML projects?
    In fact, we can choose to do more than one thing! For this case, let’s build a
    package that can be imported for use in other projects but can also run in a standalone
    execution mode.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定我们想要创建什么样的解决方案。我们是在构建一个将运行Web应用程序或具有许多功能的独立可执行文件，还是在为其他人构建一个用于他们机器学习项目的库？实际上，我们可以选择做更多的事情！对于这个案例，让我们构建一个可以导入到其他项目中使用的包，也可以以独立执行模式运行。
- en: To set the context for the development of our package, imagine we have been
    asked to start building a solution that can run a set of selected unsupervised
    outlier detection models. The data scientists have found that, for the problem
    at hand, `Isolation` `Forest` models are the most performant, but they must be
    retrained on every run and the users of the package should be able to edit the
    configuration of the models through a config file. Only `sklearn` models have
    been studied so far, but the business and users of the package would like this
    functionality to be extensible to other modeling tools if needed. The technical
    requirements for this project mean we cannot use MLflow.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的包开发设定上下文，想象一下我们被要求开始构建一个解决方案，该解决方案可以运行一系列选定的无监督异常值检测模型。数据科学家发现，对于当前的问题，`Isolation`
    `Forest`模型性能最佳，但它们必须在每次运行时重新训练，并且包的用户应该能够通过配置文件编辑模型的配置。到目前为止，只研究了`sklearn`模型，但包的商业用户希望如果需要，这个功能可以扩展到其他建模工具。这个项目的技术要求意味着我们不能使用MLflow。
- en: 'Don’t worry; in later chapters when we build more examples, we will relax this
    constraint to show how it all fits together:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心；在后面的章节中，当我们构建更多示例时，我们会放宽这个限制，以展示它们是如何相互关联的：
- en: 'The package we are going to build is all about outliers, so let’s call it `outliers`
    (I know, inventive, right?). Just to make it clear how everything hangs together,
    we will start to build the `outliers` package in a folder called `outlier_package`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要构建的包全部关于异常值，所以让我们称它为`outliers`（我知道，有创意，对吧？）。为了清楚地展示所有内容是如何相互关联的，我们将从名为`outlier_package`的文件夹开始构建`outliers`包：
- en: '[PRE31]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our package design will be based on the functionality we want the solution
    to have; in this case, we want something that detects outliers, so let’s create
    a sub-package called `detectors`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的设计将基于我们希望解决方案拥有的功能；在这种情况下，我们想要一个可以检测异常值的工具，所以让我们创建一个名为`detectors`的子包：
- en: '[PRE32]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Within this, we will put some code that wraps (more on this later) around some
    basic models from external libraries. We will also want some code that gets data
    for us to analyze, so we will add a sub-package for that too:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将放置一些代码，这些代码将（稍后详细介绍）围绕外部库的一些基本模型进行包装。我们还将想要一些获取我们用于分析的数据的代码，因此我们也将为这个添加一个子包：
- en: '[PRE33]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can already see our package taking shape. Finally, we will want to have
    somewhere to store configuration information and somewhere to store helper functions
    that may be used across the package, so let’s add a directory and sub-package
    for those too:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经可以看到我们的包正在成形。最后，我们希望有一个地方来存储配置信息，以及一个地方来存储可能在整个包中使用的辅助函数，所以让我们也为这些添加一个目录和子包：
- en: '[PRE34]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, this layout is not sacrosanct or dictated in any way. We can create the
    layout however we want and do whatever we think makes sense.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，这种布局并不是神圣不可侵犯的，或者以任何方式被规定。我们可以以我们想要的方式创建布局，并做我们认为合理的事情。
- en: It is important when doing this, though, to always remember the principles of
    **Don’t Repeat Yourself** (**DRY**), **Keep It Simple, Stupid** (**KISS**), and
    the Python mantra of *there should preferably be only one way to do something*.
    If you stick to these principles, you will be fine. For more information on these
    principles, see [https://code.tutsplus.com/tutorials/3-key-software-principles-you-must-understand--net-25161](https://code.tutsplus.com/tutorials/3-key-software-principles-you-must-understand--net-25161)
    and [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/).
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在做这件事的时候，始终记住**不要重复自己**（**DRY**）、**保持简单，傻瓜**（**KISS**）以及Python的箴言“最好只有一种做某事的方式”是很重要的。如果你坚持这些原则，你将不会有问题。有关这些原则的更多信息，请参阅[https://code.tutsplus.com/tutorials/3-key-software-principles-you-must-understand--net-25161](https://code.tutsplus.com/tutorials/3-key-software-principles-you-must-understand--net-25161)和[https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)。
- en: So, what actually goes in each of these sub-packages? Well, the underlying code
    of course!
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么，这些子包中实际上有什么呢？当然，是底层代码！
- en: 'In this case, we will want something to provide an interface between our detector
    implementations and the syntax for creating a pipeline and calling them, so we
    will build a simple class and keep it in `pipelines.py`. The `pipelines.py` file
    contains the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望有一个接口，它可以在我们的检测实现和创建管道以及调用它们的语法之间提供接口，因此我们将构建一个简单的类并将其保存在`pipelines.py`中。`pipelines.py`文件包含以下代码：
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then also need something to define the models we want to interface with.
    In this case, we will create code that uses information stored in a configuration
    file to decide which of a select few models to instantiate. We put all this functionality
    in a class called `DetectionModels`. For brevity, we omit the details of each
    of the functions in the class in this first instance:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们还需要一些定义我们想要交互的模型的东西。在这种情况下，我们将创建使用配置文件中存储的信息来决定实例化几个选定模型之一的代码。我们将所有这些功能放入一个名为`DetectionModels`的类中。为了简洁，我们在此实例中省略了类中每个函数的详细信息：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The initialization method is expanded here. Notice that we wrote this code
    so that we could define a series of models in the `config` file:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化方法在这里进行了扩展。请注意，我们编写了这段代码，以便能够在`config`文件中定义一系列模型：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then the `create_model` method is able to instantiate the model based on parameter
    and model name information. We have also built this so that we can actually pull
    in configuration information for models from different libraries if we wanted
    to; we would just need to add the appropriate implementation logic in this `create_model`
    function, checking that `sklearn` or another model was defined and running the
    appropriate syntax in each case. We would also have to make sure the pipeline
    generated in `OutlierDetector` was appropriate in each case as well:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`create_model`方法可以根据参数和模型名称信息实例化模型。我们还构建了这个功能，以便如果我们想的话，实际上可以从不同的库中拉取模型的配置信息；我们只需在这个`create_model`函数中添加适当的实现逻辑，检查是否定义了`sklearn`或另一个模型，并在每种情况下运行适当的语法。我们还需要确保在`OutlierDetector`中生成的管道在每个情况下都是合适的：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we bring the preceding methods together through the `get_models` method,
    which returns a list of all models defined in the appropriate config file, instantiated
    as a `sklearn` object via the `create_model` method:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过`get_models`方法将前面提到的方法整合在一起，该方法返回一个包含在适当配置文件中定义的所有模型的列表，这些模型通过`create_model`方法实例化为`sklearn`对象：
- en: '[PRE39]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You may be thinking *why not just read in the appropriate model and apply it,
    no matter what it is?* That could be a viable solution, but what we have done
    here means that only model types and algorithms that have been approved by the
    team working on the project can make it through to production, as well as permitting
    the use of heterogeneous model implementations.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能正在想*为什么不直接读取适当的模型并应用它，无论它是什么？*这可能是一个可行的解决方案，但我们在这里所做的是意味着只有经过项目团队批准的模型类型和算法才能进入生产，同时允许使用异构模型实现。
- en: 'To see how this could all work in practice, let’s define a script called `__main__.py`
    at the uppermost level of the package, which can act as the main entry point for
    the execution of modeling runs:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到这一切在实际中是如何工作的，让我们在包的最高级别定义一个名为`__main__.py`的脚本，它可以作为建模运行执行的主要入口点：
- en: '[PRE40]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `model_config.json` file referred to here is given by the following code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里提到的`model_config.json`文件由以下代码提供：
- en: '[PRE41]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `definitions.py` file is a file that holds relevant paths and other variables
    that we want to make globally accessible in the package without polluting the
    namespace:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`definitions.py`文件是一个包含我们想要在包中全局访问的相关路径和其他变量的文件，而不会污染命名空间：'
- en: '[PRE42]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can see that we don’t really do anything with the results; we just print
    them to show that output is produced. But in reality, you will either push these
    results elsewhere or calculate statistics on them.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，我们实际上并没有对结果做任何事情；我们只是打印它们以显示生成了输出。但在现实中，您要么将这些结果推送到其他地方，要么对它们进行统计分析。
- en: 'This script can be run by typing this in your terminal:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过在终端中输入以下内容来运行此脚本：
- en: '[PRE43]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Alternatively, you could type the following:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您也可以输入以下内容：
- en: '[PRE44]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And that is how you can package functionality into classes, modules, and packages.
    The example given was relatively constrained, but it does give us an awareness
    of how the different pieces can be brought together and executed.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是您如何将功能打包到类、模块和包中的方法。给出的示例相对有限，但它确实让我们意识到不同的部分是如何组合在一起并执行的。
- en: IMPORTANT NOTE
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The example given here has been built up to show you how to hang your code together
    by using some of the techniques discussed in this chapter. It is not necessarily
    the only way to bring all of these bits together, but it does act as a good illustration
    of how to create your own package. So, just remember that if you see a way to
    improve this implementation or adapt it to your own purposes, then brilliant!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的示例是为了展示您如何通过使用本章讨论的一些技术将代码连接起来。这并不一定是将所有这些部分组合起来的唯一方法，但它确实很好地说明了如何创建自己的包。所以，请记住，如果您看到改进此实现或将其适应您自己的目的的方法，那么真是太棒了！
- en: In the next section, we will explore how to build distributions of this code
    and how to allow ourselves and users to install the `outliers` package as a normal
    Python package that we can use in other projects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何构建此代码的发行版，以及如何允许我们和用户将`outliers`包安装为正常的Python包，这样我们就可以在其他项目中使用了。
- en: Building your package
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的包
- en: 'In our example, we can package up our solution using the `setuptools` library.
    In order to do this, you must create a file called `setup.py` that contains the
    important metadata for your solution, including the location of the relevant packages
    it requires. An example of `setup.py` is shown in the following code block. This
    shows how to do this for a simple package that wraps some of the outlier detection
    functionality we have been mentioning in this chapter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以使用`setuptools`库将我们的解决方案打包起来。为了做到这一点，您必须创建一个名为`setup.py`的文件，该文件包含您解决方案的重要元数据，包括它所需的相关包的位置。以下代码块展示了如何为一个简单的包装本章提到的某些异常检测功能的包进行此操作：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can see that `setuptools` allows you to supply metadata such as the name
    of the package, the version number, and the software license. Once you have this
    file in the root directory of your project, you can then do a few things:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`setuptools`允许您提供元数据，例如包的名称、版本号和软件许可。一旦您在项目的根目录中有了这个文件，您就可以做几件事情：
- en: 'First, you can install the package locally as an executable. This will mean
    you can import your library like any other Python library in the code you want
    to run:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您可以将包本地安装为可执行文件。这意味着您可以在想要运行的代码中像导入其他Python库一样导入您的库：
- en: '[PRE46]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can create a source distribution of the package so that all of the code
    is bundled together efficiently. For example, if you run the following command
    at the root of your project, a `gzipped tarball` is created in a folder called
    `dist`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以创建一个源分布的包，这样所有的代码都可以高效地打包在一起。例如，如果你在你的项目根目录运行以下命令，就会在名为`dist`的文件夹中创建一个`gzipped
    tarball`：
- en: '[PRE47]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can create a built distribution of the package, which is an object that
    can be unpacked and used immediately by the user without them having to run the
    `setup.py` script as in a source distribution. The most appropriate built distribution
    is what is known as a Python `wheel`. Running the following command in the root
    directory of your project creates the `wheel` and puts it in the `dist` folder:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以创建一个打包的分布，这是一个可以被用户立即解包并使用的对象，而无需像源分布那样运行`setup.py`脚本。最合适的打包分布是众所周知的Python
    `wheel`。在你的项目根目录中运行以下命令将创建`wheel`并将其放入`dist`文件夹：
- en: '[PRE48]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you are going to distribute your code using pip, then it makes sense to
    package both a `source` distribution and a `wheel` and let the user decide what
    to do. So, you can build both and then use a package called `twine` to upload
    both distributions to PyPI. If you want to do this, then you need to register
    for a PyPI account at [https://pypi.org/account/register/](https://pypi.org/account/register/).
    Just run the previous two commands together in the root directory of your project
    and use the `twine upload` command:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打算使用pip分发你的代码，那么打包一个`source`分布和一个`wheel`，并让用户决定要做什么是有意义的。所以，你可以构建这两个，然后使用一个名为`twine`的包将这两个分布上传到PyPI。如果你想这样做，那么你需要注册一个PyPI账户，网址为[https://pypi.org/account/register/](https://pypi.org/account/register/)。只需在你的项目根目录中一起运行前两个命令，并使用`twine
    upload`命令：
- en: '[PRE49]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For a lot more information on packaging, you can read through the information
    and tutorials at [https://www.pypa.io/en/latest/](https://www.pypa.io/en/latest/),
    provided by the **Python Packaging Authority** (**PyPA**).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关于打包的更多信息，你可以阅读由**Python打包权威机构**（**PyPA**）提供的资料和教程，网址为[https://www.pypa.io/en/latest/](https://www.pypa.io/en/latest/)。
- en: The next section touches briefly on how we can automate a few of the steps around
    building and testing our packages using Makefiles.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节简要介绍了我们可以如何使用Makefile自动化围绕构建和测试我们的包的一些步骤。
- en: Managing your environment with Makefiles
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Makefile管理你的环境
- en: 'If we are on a UNIX system and we have the `make` utility installed, then we
    can further automate a lot of the steps we want to run for our solution in different
    scenarios using Makefiles. For example, in the following code block, we have a
    Makefile that allows us to run our module’s main entry point, run our test suite,
    or clean up any artifacts using the `run`, `test`, and `clean` targets:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在UNIX系统上并且安装了`make`实用程序，那么我们可以进一步自动化我们想要在不同场景下运行的解决方案的许多步骤。例如，在以下代码块中，我们有一个Makefile，允许我们运行我们模块的主入口点，运行我们的测试套件，或使用`run`、`test`和`clean`目标清理任何工件：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is a very simple Makefile, but we can make it as complex as needed by
    layering more and more commands. If we want to `run` a specific target set of
    commands, we simply call `make`, then the target name:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的Makefile，但我们可以通过分层添加更多命令使其变得尽可能复杂。如果我们想`运行`一组特定的命令，我们只需调用`make`，然后是目标名称：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is a powerful way to abstract out a lot of terminal commands you would
    otherwise have to manually enter in each case. It also acts as documentation for
    other users of the solution!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强大的方法，可以抽象出你通常必须手动输入的许多终端命令。它还充当了解决方案其他用户的文档！
- en: The example we have just gone through is quite simple; let’s now make things
    more sophisticated. We can actually use Makefiles to manage our environments and
    help streamline our development process so that it does not require lots of cognitive
    effort just to keep track of the state of our environment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才通过的这个例子相当简单；现在让我们使事情更加复杂。实际上，我们可以使用Makefile来管理我们的环境，并帮助简化我们的开发过程，这样就不需要大量的认知努力来跟踪我们环境的状态。
- en: The following examples leverage a lot of great work by Kjell Wooding, or *hackalog*
    on GitHub, specifically his repository [https://github.com/hackalog/make_better_defaults](https://github.com/hackalog/make_better_defaults).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例借鉴了Kjell Wooding或GitHub上的*hackalog*的大量优秀工作，具体是他的仓库[https://github.com/hackalog/make_better_defaults](https://github.com/hackalog/make_better_defaults)。
- en: 'This repository formed the basis of his talk at the 2021 PyData Global conference
    titled “Makefiles: One Great Trick for Making Your Conda Environments More Manageable.”'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仓库是他 2021 年 PyData 全球会议上的演讲的基础，该演讲的标题为“Makefiles：使你的 Conda 环境更易于管理的绝妙技巧”。
- en: First, the inclusion of a `Makefile.help` file allows for customizable help
    prompts when using the `make` command. If we run `make` in the terminal, assuming
    we are still in the main project directory, you will see the output in *Figure
    4.2*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，包含一个 `Makefile.help` 文件允许在使用 `make` 命令时提供可定制的帮助提示。如果我们假设我们仍然在主项目目录中，并在终端运行
    `make`，你将看到 *图 4.2* 中的输出。
- en: '![](img/B19525_04_02.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19525_04_02.png)'
- en: 'Figure 4.2: The help presented from the Makefile example.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：从 Makefile 示例中提供的帮助信息。
- en: 'This help message has been customized by using the `PROJECT_NAME` variable
    in the main Makefile, which has been set as `mlewp-ed2-ch4-outliers`. In fact,
    the top of the Makefile has several variables set for this project:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个帮助信息是通过在主 Makefile 中使用 `PROJECT_NAME` 变量进行定制的，该变量已被设置为 `mlewp-ed2-ch4-outliers`。实际上，Makefile
    的顶部为这个项目设置了几个变量：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `MODULE` variable is referring to the name of the package as before. `PYTHON_INTERPRETER`,
    `CONDA_EXE`, and `VIRTUALENV` are hopefully self-explanatory. `ARCH` is grabbing
    architecture information from the local system. `EASYDATA_LOCKFILE` refers to
    a file that will be created as we work that helps us track the full list of dependencies
    in our project.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`MODULE` 变量仍然是指之前提到的包名。`PYTHON_INTERPRETER`、`CONDA_EXE` 和 `VIRTUALENV` 应该是自我解释的。`ARCH`
    会从本地系统获取架构信息。`EASYDATA_LOCKFILE` 指的是在我们工作时创建的一个文件，它帮助我们跟踪项目中所有依赖项的完整列表。'
- en: 'You can see that the help message clearly refers to different targets for the
    Makefile, so let’s explore each of these in turn. First, in order to standardize
    the creation of a new Conda environment for the project, if one is required, there
    are a few steps that can be brought together:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到帮助信息清楚地指出了 Makefile 的不同目标，因此让我们逐一探索这些目标。首先，为了标准化为项目创建新的 Conda 环境（如果需要的话），有一些步骤可以合并在一起：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Walking through this step by step, this code states that if `conda` is the virtual
    environment, then proceed to create or update a Conda environment with the project
    name and then export the environment into the `environment.yml` file; then after
    that, export the environment configuration into the lock file. It works this way
    because `$<` refers to the first prerequisite (in this case, the `environment.yml`
    file), and `$@` refers to the name of the target (in this case, the `EASYDATA_LOCKFILE`
    variable). After this is triggered, the second block is checking if `conda` is
    the virtual env manager before removing the lock file and then providing some
    guides to the user in the terminal. Note that `@` here is referring to terminal
    commands.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步走过这个步骤，这段代码表明如果 `conda` 是虚拟环境，那么就继续创建或更新一个带有项目名称的 Conda 环境，然后将环境导出到 `environment.yml`
    文件中；然后在此之后，将环境配置导出到锁文件中。它之所以这样工作，是因为 `$<` 指的是第一个前提条件（在这种情况下，是 `environment.yml`
    文件），而 `$@` 指的是目标名称（在这种情况下，是 `EASYDATA_LOCKFILE` 变量）。触发此操作后，第二个块会检查 `conda` 是否是虚拟环境管理器，然后在删除锁文件之前，在终端为用户提供一些指导。注意，这里的
    `@` 指的是终端命令。
- en: 'The next important block in the Makefile is the one that handles updating the
    environment for you if required, which will often be the case during the “Develop”
    phase of your project:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 中下一个重要的部分是处理在需要时为你更新环境的部分，这在项目的“开发”阶段通常会是这种情况：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This block ensures that if you run the following command in your terminal:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块确保如果你在终端运行以下命令：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Then you will create a new `lockfile.yml` with all of the details of the latest
    version of the environment. There is also a `delete_environment` target that will
    clear out the lockfiles and remove the Conda environment, as well as some other
    helper targets that need not concern us here, but that you can explore in the
    book repository.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将创建一个新的 `lockfile.yml` 文件，其中包含环境的最新版本的所有详细信息。还有一个 `delete_environment` 目标，它将清除锁文件并删除
    Conda 环境，以及一些其他不需要在此处关心的辅助目标，但你可以在书籍仓库中探索它们。
- en: 'Bringing this all together, the workflow using this Makefile-based approach
    would be:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，使用基于 Makefile 的这种方法的工作流程将是：
- en: 'Create a starter `environment.yml` file for the project. This could be very
    simple; as an example, for the `outliers` package that we are building in the
    chapter, I started with an `environment.yml` file that looked something like this:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目创建一个初始的`environment.yml`文件。这可能非常简单；例如，对于我们在本章中构建的`outliers`包，我开始于一个看起来像这样的`environment.yml`文件：
- en: '[PRE56]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create the environment with:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建环境：
- en: '[PRE57]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Update the environment, which will create the first lockfile:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新环境，这将创建第一个锁文件：
- en: '[PRE58]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you develop your solution, if you need a new package, go into the `environment.yml`
    file and add the dependency you require before running `make update_environment`.
    The idea here is that by not installing the packages manually but by mandating
    them in the `environment.yml` file, you are creating a more repeatable and robust
    workflow.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你开发解决方案的过程中，如果你需要一个新的包，请进入`environment.yml`文件，在运行`make update_environment`之前添加你需要的依赖项。这里的理念是，通过在`environment.yml`文件中强制要求这些包，而不是手动安装它们，你可以创建一个更可重复和更健壮的工作流程。
- en: 'It becomes impossible for you to forget what you installed and what you haven’t!
    For example, if I wanted to add the `bandit` package to this environment, I would
    go into the `environment.yml` file using my text editor or IDE and would simply
    add that dependency in either the `conda` or `pip` dependency:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将无法忘记你安装了什么和没有安装什么！例如，如果我想向这个环境添加`bandit`包，我会使用我的文本编辑器或IDE进入`environment.yml`文件，并简单地在`conda`或`pip`依赖项中添加这个依赖项：
- en: '[PRE59]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And that’s it! This is how you can use Makefiles to manage your Conda environments
    in a far more repeatable way. As mentioned above, if you wanted to start again,
    you can delete the environment by running:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这就是你如何使用Makefiles以更可重复的方式管理你的Conda环境。如上所述，如果你想重新开始，你可以通过运行以下命令来删除环境：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That covers this particular method for managing your Python development environment
    when developing your packages. We will now move on to discuss one of the most
    popular tools for Python dependency management and packaging in use today, **Poetry**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了管理你的Python开发环境的方法。现在我们将讨论目前最流行的Python依赖项管理和打包工具之一，**Poetry**。
- en: Getting all poetic with Poetry
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用Poetry来诗意地表达
- en: Python package management is one of the things about the language that definitely
    does not have people screaming praise from the rooftops. It has been widely admitted
    by even the most ardent supporters of the language (myself included) that Python’s
    package management is, to put it bluntly, a bit of a mess. The examples we have
    walked through using `setup.py` and the production of wheels are some of the most
    accepted ways and, as mentioned, recommended by the PyPA. But they are still not
    the simplest or most intuitive approaches you would expect from a language that
    otherwise holds these as key design principles.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python包管理是关于这种语言的一些事情，肯定不会让人在屋顶上大声赞扬。甚至包括我最热情的支持者（包括我自己）在内的最热情的支持者都广泛承认，Python的包管理，坦白说，有点混乱。我们使用`setup.py`和制作轮子所经历的例子是一些最被接受的方式，正如提到的，由PyPA推荐。但它们仍然不是你期望从这个语言中得到的简单或最直观的方法，尽管它通常将这些作为关键设计原则。
- en: Thankfully, over the past few years, there have been a few major developments,
    one of which we will cover in detail here. This is the creation of the Python
    packaging and dependency management tool, Poetry. Poetry’s benefits include its
    ease of use and its drastic simplification of the packaging up and dependency
    management of your solution. Most visibly, it does this by requiring only one
    configuration file, the `pyproject.toml` file, rather than a potential setup including
    `setup.py`, `setup.cfg`, `MANIFEST.in`, or `Pipfile` configuration files. There
    is also a big advantage in the fact that the dependency file is locked so that
    auto-updates do not occur, which means the admin (you) has to explicitly call
    out changes in dependencies. This helps to make the project more stable.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在过去的几年里，已经有一些重大发展，其中之一我们将在此详细讨论。这是创建Python打包和依赖项管理工具Poetry。Poetry的好处包括其易用性和极大地简化了解决方案的打包和依赖项管理。最明显的是，它通过只要求一个配置文件，即`pyproject.toml`文件，而不是可能包括`setup.py`、`setup.cfg`、`MANIFEST.in`或`Pipfile`配置文件的潜在设置来实现这一点。还有一个很大的优势，即依赖项文件被锁定，因此不会自动更新，这意味着管理员（你）必须明确指出依赖项的变化。这有助于使项目更稳定。
- en: 'So, this sounds great, but how do we get started? Well, no surprise, we first
    install the tool using `pip`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这听起来很棒，但我们如何开始呢？嗯，毫不奇怪，我们首先使用`pip`安装这个工具：
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, if you wanted to start a new project that leveraged Poetry, you would
    go into the appropriate directory where you want your package to be and run the
    command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你想启动一个新的利用 Poetry 的项目，你将进入你希望你的包所在的适当目录，并运行以下命令：
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This would then create a sub-directory structure like:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个类似以下的子目录结构：
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `tests` folder will be where we place our unit tests, as covered in the
    *Testing* section of this chapter. `pyproject.toml` is the most important file
    in the directory. It specifies the main metadata concerning the project and is
    organized into blocks covering package dependencies for production and for development
    and testing.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests` 文件夹将是我们放置单元测试的地方，正如本章的 *测试* 部分所述。`pyproject.toml` 是目录中最重要的文件。它指定了与项目相关的所有主要元数据，并组织成包含生产环境和开发及测试的包依赖的块。'
- en: 'The file generated when I ran the previous commands was the one shown in *Figure
    4.3*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行前面的命令时生成的文件是 *图4.3* 中显示的：
- en: '![](img/B19525_04_03.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19525_04_03.png)'
- en: 'Figure 4.3: The pyproject.toml file created by Poetry when we create a new
    project.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：当我们创建新项目时，Poetry 创建的 pyproject.toml 文件。
- en: In the first case, this is given in a block under `[tool.poetry]`, which covers
    high-level information about the package. Then there is `[tool.poetry.dependencies]`,
    which currently only contains Python version 3.10 and nothing else, as I have
    not used it to install anything else yet. The `[build-system]` section contains
    details of the build-time dependencies, here only listing `poetry-core`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，这在一个 `[tool.poetry]` 块下给出，它涵盖了关于包的高级信息。然后是 `[tool.poetry.dependencies]`，目前它只包含
    Python 3.10 版本，没有其他内容，因为我还没有用它安装其他任何东西。`[build-system]` 部分包含构建时依赖的详细信息，这里只列出了
    `poetry-core`。
- en: 'If we then want to add a new dependency, such as `pytest`, we can run a command
    like:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加一个新的依赖项，例如 `pytest`，我们可以运行类似以下命令：
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will output in the terminal something like that shown in *Figure 4.4*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在终端输出类似于 *图4.4* 中显示的内容。
- en: '![](img/B19525_04_04.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19525_04_04.png)'
- en: 'Figure 4.4: Output from adding a new package to a Poetry-managed project.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：向 Poetry 管理的项目添加新包的输出。
- en: This will also update the `pyproject.toml` file with the new dependency, as
    shown in *Figure 4.5*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将更新 `pyproject.toml` 文件，添加新的依赖项，如图4.5所示。
- en: '![](img/B19525_04_05.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19525_04_05.png)'
- en: 'Figure 4.5: Updated pyproject.toml file after adding a new dependency.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：添加新依赖项后的更新 pyproject.toml 文件。
- en: Now, the `[tool.poetry.dependencies]` section is the place where you should
    define all of the packages you need to be installed at runtime for your package,
    so you do not necessarily want to bloat this with lots of testing packages.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`[tool.poetry.dependencies]` 部分是你应该定义所有需要在运行时安装到你的包中的包的地方，因此你并不想在这个部分添加大量的测试包。
- en: Instead, Poetry allows you to define a block that lists your development dependencies
    by specifying a `[tool.poetry.group.dev.dependencies]` block, like that shown
    in *Figure 4.6*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Poetry 允许你通过指定一个 `[tool.poetry.group.dev.dependencies]` 块来定义一个列出你的开发依赖项的块，就像
    *图4.6* 中显示的那样。
- en: '![](img/B19525_04_06.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19525_04_06.png)'
- en: 'Figure 4.6: The pyproject.toml file with a set of development dependencies.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：包含一组开发依赖项的 pyproject.toml 文件。
- en: 'When you install Poetry, it creates its own virtual environment in order to
    create appropriate isolation from the rest of your system. You can activate this
    environment if you are on a Linux system by running:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Poetry 时，它会为你创建一个自己的虚拟环境，以便从你的系统其他部分创建适当的隔离。如果你在 Linux 系统上，你可以通过运行以下命令来激活此环境：
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Or you can also run:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以运行：
- en: '[PRE66]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you already have a Python virtual environment running through Conda, `venv`,
    or some other tool, then Poetry is actually aware of this and works within it.
    This can be very helpful as you can use Poetry to manage that virtual environment,
    rather than starting completely from scratch. In this case, you may get some output
    in the terminal like that shown in *Figure 4.7*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经通过 Conda、`venv` 或其他工具运行了一个 Python 虚拟环境，那么 Poetry 实际上是知道这一点的，并在其中工作。这非常有帮助，因为你可以使用
    Poetry 来管理这个虚拟环境，而不是从头开始。在这种情况下，你可能会在终端中得到一些类似于 *图4.7* 中显示的输出。
- en: '![](img/B19525_04_07.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19525_04_07.png)'
- en: 'Figure 4.7: Output from poetry shell command if you are already working in
    a Python virtual environment.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：如果你已经在 Python 虚拟环境中工作，poetry 命令的输出。
- en: 'To close down this environment but not the shell you are running, you can use
    the command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭此环境但不是你正在运行的 shell，你可以使用以下命令：
- en: '[PRE67]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you want to close the environment and the shell (be warned, this will likely
    close your terminal), you can type the command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想关闭环境和shell（请注意，这可能会关闭你的终端），你可以输入以下命令：
- en: '[PRE68]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To install the dependencies you have been adding in the `pyproject.toml` file,
    you can run:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装你在`pyproject.toml`文件中添加的依赖项，你可以运行：
- en: '[PRE69]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This will either download and install all the dependencies listed in your `pyproject.toml`
    file, grabbing the latest versions from `pip`, or it will grab and install the
    versions of these packages as they are listed in the `.lock` file. This is to
    ensure that even if multiple people have been working in the environment and running
    `poetry install` commands, the environment is kept stable with consistent package
    versions. This is exactly the same reason for using a `.lock` file in the section
    on Makefiles earlier in this chapter. When the `install` command was run for this
    `my-ml-package` project, for example, the output was that shown in *Figure 4.8*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据你的`pyproject.toml`文件中列出的所有依赖项进行下载和安装，从`pip`获取最新版本，或者它会获取并安装这些包的版本，正如`.lock`文件中所列。这是为了确保即使有多个人在环境中工作并运行`poetry
    install`命令，环境也能保持稳定，包版本一致。这正是本章前面关于Makefile部分使用`.lock`文件的原因。例如，当为`my-ml-package`项目运行`install`命令时，输出显示在*图4.8*中。
- en: '![](img/B19525_04_08.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19525_04_08.png)'
- en: 'Figure 4.8: Poetry installing packages from the .lock file in order to maintain
    environment stability.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：Poetry从.lock文件中安装包以保持环境稳定性。
- en: 'All of the preceding commands are around the basic management of the environment,
    but what about when we want to do something with this environment? Well, if you
    have a script called `main.py`, you can run this using the Poetry-configured environment
    via the command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述命令都是关于环境的基本管理，但当我们想要对这个环境做些什么时怎么办呢？好吧，如果你有一个名为`main.py`的脚本，你可以通过以下命令使用Poetry配置的环境来运行它：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We do not have anything like this in the `my-ml-package`. Instead, since we
    are building a library, we can package and deploy the package by running:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在`my-ml-package`中我们没有类似的东西。相反，由于我们正在构建一个库，我们可以通过运行以下命令来打包和部署包：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This gives the output shown in *Figure 4.9*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示*图4.9*中所示的输出。
- en: '![](img/B19525_04_09.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19525_04_09.png)'
- en: 'Figure 4.9: The output when Poetry builds our simple package.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：Poetry构建我们的简单包时的输出。
- en: 'If you want to publish to PyPI, which only works if you are a registered user
    with the correct credentials configured, you can just run the command `poetry
    publish`. If you want to publish to some other private repository, you can run:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要发布到PyPI，这只有在你有正确配置的凭据并注册为用户时才有效，你可以直接运行`poetry publish`命令。如果你想要发布到其他私有仓库，你可以运行：
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After all of this, you can probably see how Poetry can make things a lot clearer
    when it comes to package development. We have been able to manage stable development
    and production (like Python environments that can be worked on by multiple developers
    without fear of corruption), build and publish our package, as well as run any
    scripts and processes we want to – all in a few commands!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，你可能已经看到了Poetry在包开发方面如何使事情变得更加清晰。我们已经能够管理稳定开发和生产（如可以由多个开发者工作而不用担心损坏的Python环境），构建和发布我们的包，以及运行我们想要的任何脚本和进程——所有这些只需几个命令即可完成！
- en: Next, let’s cover some of the steps we can take to ensure that our packages
    are robust and can be trusted to work or fail gracefully and be diagnosable if
    there is an issue.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论一些我们可以采取的步骤，以确保我们的包是健壮的，并且可以在出现问题时优雅地工作或失败，并且可诊断。
- en: Testing, logging, securing, and error handling
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、日志记录、安全性和错误处理
- en: Building code that performs an ML task may seem like the end goal, but it is
    only one piece of the puzzle. We also want to be confident that this code will
    work, and if it doesn’t, we will be able to fix it. This is where the concepts
    of testing, logging, and error handling come in, which the next few sections cover
    at a high level.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 构建执行ML任务的代码可能看起来像是最终目标，但它只是拼图中的一块。我们还希望对此代码能够正常工作有信心，如果它不能，我们能够修复它。这就是测试、日志记录和错误处理概念发挥作用的地方，接下来的几节将对此进行高层次概述。
- en: Testing
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: One of the most important features that sets your ML-engineered code apart from
    typical research scripts is the presence of robust testing. It is critical that
    any system you are designing for deployment can be trusted not to fall down all
    the time and that you can catch issues during the development process.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的机器学习工程代码与典型的研究脚本区分开来的最重要的特性之一是存在稳健的测试。对于你设计的任何部署系统来说，它必须能够被信任不会总是失败，而且你可以在开发过程中捕捉到问题。
- en: Luckily, since Python is a general-purpose programming language, it is replete
    with tools for performing tests on your software. In this chapter, we will use
    **pytest**, which is one of the most popular, powerful, and easy-to-use testing
    toolsets for Python code available. pytest is particularly useful if you are new
    to testing because it focuses on building tests as standalone Python functions
    that are quite readable, whereas other packages can sometimes lead to the creation
    of clunky testing classes and complex `assert` statements. Let’s dive into an
    example.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于Python是一种通用编程语言，它充满了用于对软件进行测试的工具。在本章中，我们将使用**pytest**，这是Python代码中最受欢迎、功能强大且易于使用的测试工具集之一。pytest特别适用于初学者，因为它专注于构建作为独立Python函数的测试，这些函数非常易于阅读，而其他包有时会导致创建笨拙的测试类和复杂的`assert`语句。让我们通过一个例子来深入了解。
- en: 'First, let’s start by writing tests for some pieces of code defined in the
    rest of this chapter from our `outliers` package. We can define a simple test
    to ensure that our data helper function actually creates some numerical data that
    can be used for modeling. To run this sort of test in pytest, we first create
    a file with `test_` or `_test` in the name somewhere in our test’s directory—pytest
    will automatically find files that have this in their name. So, for example, we
    may write a test script called `test_create_data.py` that contains the logic we
    need to test all of the functions that refer to creating data within our solution.
    Let’s make this explicit with an example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从这个章节的其余部分中定义的`outliers`包的一些代码片段开始编写测试。我们可以定义一个简单的测试来确保我们的数据辅助函数实际上创建了一些可以用于建模的数值数据。要在pytest中运行这种测试，我们首先在测试目录的某个位置创建一个名为`test_`或`_test`的文件——pytest将自动找到具有这种命名的文件。例如，我们可能编写一个名为`test_create_data.py`的测试脚本，其中包含我们需要测试的所有在解决方案中创建数据的函数的逻辑。让我们用一个例子来明确这一点：
- en: 'Import the relevant modules we will need from the package and anything else
    we need for testing. Here, we import `pytest` because we will use some functionality
    from it in later steps but, in general, you don’t need to import this:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从包中导入我们将需要的相关模块以及我们需要的其他测试相关内容。在这里，我们导入`pytest`，因为我们将在后续步骤中使用它的一些功能，但通常情况下，你不需要导入这个模块：
- en: '[PRE73]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, since we want to test the function for creating data, it would be good
    to only generate the data once, then test its attributes in a variety of ways.
    To do this, we employ the `fixture` decorator from pytest, which allows us to
    define an object that can be read into several of our tests. Here, we use this
    so that we can apply our tests using `dummy_data`, which is just the output of
    the `create_data` function:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，由于我们想要测试创建数据的函数，最好只生成一次数据，然后以各种方式测试其属性。为此，我们使用pytest的`fixture`装饰器，它允许我们定义一个可以被多个测试读取的对象。在这里，我们使用它，这样我们就可以使用`dummy_data`来应用我们的测试，`dummy_data`只是`create_data`函数的输出：
- en: '[PRE74]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, we can actually write the tests. Here are two examples that test if
    the dataset created by the function is a `numpy` array and if it has more than
    `100` rows of data:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实际上可以编写测试了。这里有两个示例，用于测试由函数创建的数据集是否是`numpy`数组，以及它是否有超过`100`行的数据：
- en: '[PRE75]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can write as many of these tests and as many of these types of test modules
    as we like. This allows us to create a high degree of **test coverage** across
    our package.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以编写尽可能多的这些测试和尽可能多的这些类型的测试模块。这使我们能够在我们整个包中创建高程度的**测试覆盖率**。
- en: 'You can then enter the following command in the terminal at the top level of
    your project in order to run all the tests in the package:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以在项目的顶层终端中输入以下命令来运行包中的所有测试：
- en: '[PRE76]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Then you will see a message like this, telling us what tests have run and which
    have passed and failed:![Figure 4.3 – The output of a successful unit test in
    PyTest ](img/B19525_04_10.png)
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你将看到一条类似的消息，告诉我们哪些测试已运行，哪些已通过和失败：![图4.3 – PyTest中成功单元测试的输出](img/B19525_04_10.png)
- en: 'Figure 4.10: The output of a successful unit test in pytest.'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.10：pytest中成功单元测试的输出。
- en: The previous example showed how to write and execute some basic tests on our
    data utilities. We can now expand on this by testing some of the more sophisticated
    functionality in the package – namely, the model creation process.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的例子展示了如何编写和执行一些基本的数据工具测试。现在，我们可以通过测试包中的一些更复杂的功能来扩展这一点——即模型创建过程。
- en: 'Similarly to the previous case, we create a script for holding our tests in
    `tests/test_detectors.py`. Since we are testing more complex functionality, we
    will have to import more pieces of the package into the script:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的案例类似，我们在 `tests/test_detectors.py` 中创建一个脚本来保存我们的测试。由于我们正在测试更复杂的功能，我们将在脚本中导入包的更多部分：
- en: '[PRE77]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We will have the same fixture for dummy data created as in *Step 2*, but now
    we also have a fixture for creating some example models to use in tests:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将会有与 *步骤 2* 中创建的虚拟数据相同的设置，但现在我们也有一个用于在测试中创建一些示例模型的设置：
- en: '[PRE78]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Our final fixture creates an example detector instance for us to use, based
    on the previous model’s fixture:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终的设置为我们创建了一个示例检测实例，基于之前的模型设置：
- en: '[PRE79]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And now we are ready to test some of the model creation functionality. First,
    we can test that the models we created are not empty `objects`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好测试一些模型创建功能。首先，我们可以测试我们创建的模型不是空的 `对象`：
- en: '[PRE80]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can then test that we can successfully retrieve models using the instance
    of `DetectionModels` created in *Step 6*:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以测试是否可以使用在 *步骤 6* 中创建的 `DetectionModels` 实例成功检索模型：
- en: '[PRE81]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we can test that the results found by applying the model pass some
    simple tests. This shows that the main pieces of our package are working for an
    end-to-end application:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以测试应用模型找到的结果是否通过一些简单的测试。这表明我们包的主要部分在端到端应用程序中正在正常工作：
- en: '[PRE82]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As in *Step 4*, we can run the full test suite from the command line. We add
    a verbosity flag to return more information and show the individual tests that
    pass. This helps confirm that both our data utility and our model tests are being
    triggered:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同 *步骤 4* 中所述，我们可以从命令行运行完整的测试套件。我们添加了一个详细程度标志来返回更多信息并显示通过的单个测试。这有助于确认我们的数据工具和模型测试正在被触发：
- en: '[PRE83]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The output is shown in the following screenshot:![Figure 4.4 – Output of successful
    tests on both data and model functionality ](img/B19525_04_11.png)
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出结果展示在下面的屏幕截图上：![图 4.4 – 数据和模型功能成功测试的输出](img/B19525_04_11.png)
- en: 'Figure 4.11: Output of successful tests on both data and model functionality.'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.11：数据和模型功能成功测试的输出。
- en: The running of these tests can be automated either via the inclusion of `githooks`
    in our repository or through the use of other tools, such as the `Makefile` used
    for the project.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的运行可以通过在我们的存储库中包含 `githooks` 或通过使用其他工具（如项目中使用的 `Makefile`）来自动化。
- en: We’ll now move on to consider how we can log information about our code as it
    runs, which can help with debugging and general monitoring of your solution.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续考虑如何记录代码运行时的信息，这有助于调试和一般监控你的解决方案。
- en: Securing your solutions
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护你的解决方案
- en: As software engineers of any kind, we should always be very cognizant of the
    fact that there is a flip-side to the joy of building products that people use.
    This flip-side is that it is then your job to make sure the solution is secure
    and safe for those users. In the words of Uncle Ben, “*With great power comes
    great responsibility*.”
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 作为任何类型的软件工程师，我们应始终非常清楚，使用人们使用的产品的喜悦背后有一个反面。这个反面是，确保解决方案对用户安全且安全是你的工作。用本叔叔的话说，“*能力越大，责任越大*。”
- en: Now, cybersecurity is a huge discipline in its own right, so we cannot do it
    justice here. The following sections will simply aim to introduce some useful
    tools and explain the basics of using them in order to make your solutions more
    secure and trustworthy.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，网络安全是一个独立的巨大学科，所以我们在这里无法做到公正。以下章节将简单地介绍一些有用的工具，并解释如何使用它们的基本原理，以使你的解决方案更加安全和可靠。
- en: 'First, we need to understand the different ways we can create secure solutions:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解我们可以创建安全解决方案的不同方式：
- en: Testing the application and code itself for internal bugs.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应用程序和代码本身是否存在内部错误。
- en: Screening packages and scanning other code used for security vulnerabilities.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 筛选软件包和扫描其他用于安全漏洞的代码。
- en: Testing for data leaks and data exposure.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数据泄露和数据暴露。
- en: Developing robust monitoring techniques, specifically with respect to the above
    points and less so about the monitoring of your ML models, which has been covered
    elsewhere in this book.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发稳健的监控技术，特别是针对上述要点，而不是特别关注您机器学习模型的监控，这在本书的其他地方已经讨论过。
- en: In the first case, this refers mostly to things like our unit-testing approaches,
    which, again, we have covered elsewhere, but in brief, this refers to the act
    of testing the functionality of the code you write in order to ensure it works
    as expected. In the section on model monitoring, it was mentioned that performing
    standard tests for the expected performance of a machine learning model can be
    difficult and so requires specific techniques.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，这主要指的是像我们的单元测试方法这样的东西，我们已经在其他地方讨论过，但简而言之，这指的是测试您编写的代码的功能，以确保它按预期工作。在模型监控的部分提到，对机器学习模型的预期性能进行标准测试可能很困难，因此需要特定的技术。
- en: Here, we are focused more on the general application code and the solution wrapping
    the main model.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们更关注通用应用代码和包装主要模型的解决方案。
- en: In the case of screening packages and code, this is a very pertinent and, thankfully,
    easy-to-implement challenge. The reader may recall that in 2022, there was a wave
    of activity across the world as organizations and software engineers tried to
    deal with the discovery of a bug in the Java-based Log4j library. Bugs and security
    flaws will always happen and not always be detected, but this point is all about
    having some system in place to automatically scan the code and packages you are
    using in your solution to find these proactively, saving major headaches (and
    far worse) for the users of your code.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在筛选包和代码的情况下，这是一个非常相关且幸运的是易于实施的挑战。读者可能还记得，在2022年，全球出现了一波活动，组织机构和软件工程师试图应对在基于Java的Log4j库中发现的一个错误的发现。错误和安全漏洞总会发生，并不总是被检测到，但这个要点是关于在您的解决方案中自动扫描您使用的代码和包以主动找到这些漏洞，从而为您的代码用户节省大量麻烦（以及更糟糕的事情）。
- en: Data leakage is an incredibly important topic now. Regulations like the **General
    Data Protection Regulation** (**GDPR**) in the European Union have placed a massive
    emphasis on the management and curation of customers’ data. Since machine learning
    systems are fundamentally data-driven applications, this means that concerns around
    privacy, usage, storage, and many other points become extremely important to consider
    in designs and implementations. It is important to note that what we are discussing
    here goes far beyond the “garbage in, garbage out” question of data quality, and
    really is about how securely you are holding and transferring the data required
    to make your machine learning system work.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 数据泄露现在是一个极其重要的话题。欧盟的**通用数据保护条例**（**GDPR**）对客户数据的管理和保养给予了极大的重视。由于机器学习系统本质上是以数据驱动的应用，这意味着围绕隐私、使用、存储以及许多其他点在设计实现中考虑变得极为重要。重要的是要注意，我们在这里讨论的内容远远超出了“垃圾输入，垃圾输出”的数据质量问题，实际上是在讨论您如何安全地持有和传输使您的机器学习系统工作的数据。
- en: Analyzing your own code for security issues
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析您的代码中的安全问题
- en: As you will have noticed throughout this book, the Python open-source community
    has almost every challenge you can think of covered in at least some way, and
    when it comes to security, this is no different. To perform static analysis of
    your own code and check for vulnerabilities that may have been introduced during
    development, you can use the open-source Bandit package, [https://bandit.readthedocs.io/en/latest/](https://bandit.readthedocs.io/en/latest/).
    This is a linter that is focused on finding security issues in source code, and
    it is extremely easy to run.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这本书的整个过程中所注意到的，Python开源社区几乎涵盖了您能想到的所有挑战，在安全方面也不例外。要执行您自己代码的静态分析并检查在开发过程中可能引入的漏洞，您可以使用开源的Bandit包，[https://bandit.readthedocs.io/en/latest/](https://bandit.readthedocs.io/en/latest/)。这是一个专注于在源代码中查找安全问题的linter，它运行起来非常简单。
- en: 'First, as always, we need to install Bandit. We can now do this using the Makefile
    magic we learned about in the earlier section on *Building your package*, so we
    add the Bandit package to the `pip` dependencies in the `environment.yml` file
    and run the command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像往常一样，我们需要安装Bandit。现在我们可以使用在早期关于*构建您的包*部分学到的Makefile魔法来完成这项工作，因此我们将Bandit包添加到`environment.yml`文件中的`pip`依赖项中，并运行命令：
- en: '[PRE84]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, to run Bandit on your source code, you simply run:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要在您的源代码上运行Bandit，您只需运行：
- en: '[PRE85]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As we mentioned in *Chapter 2*, *The Machine Learning Development Process*,
    it is always useful to automate any development steps that you will want to run
    again and again. We can do this with Bandit by adding the following to our `.pre-commit-config.yaml`
    in our Git directory:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This means that after every commit, we will run the `bandit` command as outlined
    in the previous two steps.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The output from running Bandit on some example code is given by a series of
    blocks like the following in *Figure 4.12*.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_04_12.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Bandit output on a typical piece of code.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: This is followed by a small summary report at the end of the output, shown in
    *Figure 4.13.*
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_04_13.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: The Bandit tool provides a high-level summary at the end of its
    output for diagnosing the state of your code base.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: There are many more features of Bandit but this shows how easy it is to get
    started and start analyzing the potential issues in your Python code base.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing dependencies for security issues
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have outlined, we don’t just want to scan the code we have written for
    security vulnerabilities; it is also important that we try and find any issues
    in the packages that we are using in our solution. This can be done using something
    like the Python `safety` tool, [https://pypi.org/project/safety/](https://pypi.org/project/safety/).
    Safety uses a standardized database containing known Python security issues and
    then compares any packages found in your solution against this database. Please
    note that, as the documentation for safety calls out:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: By default it uses the open Python vulnerability database Safety DB, which is
    licensed for non-commercial use only.
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For all commercial projects, Safety must be upgraded to use a PyUp API using
    the key option.
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Below is an example of using this on the same source code tree as in the example
    for using Bandit:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have safety installed, install it:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You then need to change into the top folder of your source code tree before
    running:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When I ran this on the folder containing the `outlier_package` we have been
    building, I got the terminal output shown in *Figure 4.14*:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_04_14.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: The output of safety on the outliers package.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from *Figure 4.15*, we are being warned that the current version
    cannot be used for scanning commercial software and that if this was needed, you
    should get an API key. For the project here, this is fine. One vulnerability has
    been found by the tool relating to the version of the `wheel` package. Upon inspection
    of the `environment.yml` file in the project, we see that we can update this to
    version 0.38.1 as the advisory note suggests. This is shown in *Figure 4.15*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_04_15.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Updating the environment.yml file in order to avoid the error
    produced by the safety tool.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Conda channels used in this `environment.yml` file did not have
    the `wheel` package in version 0.38.1 or greater so this was added to the `pip`
    dependencies instead, as shown in *Figure 4.16*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_04_16.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Updating the pip dependencies of the environment.yml file in the
    outliers package.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'After doing this and re-running the command:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The solution is given a clean bill of health, as shown in the report in *Figure
    4.17*.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19525_04_17.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: The safety tool returns zero security vulnerabilities after updating
    the identified package.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Although safety does require a commercial license in order to get the full set
    of features, it can still be extremely helpful for sniffing out issues in your
    dependencies.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, it is important to ensure that as your code is running, the status of
    the different operations is reported, as well as any errors that occur. This helps
    make your code more maintainable and helps you debug when there is an issue. For
    this, you can use the Python `logging` library.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Loggers can be instantiated in your code via logic like this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This code defines our format for the logging messages and specifies that logging
    messages of level `DEBUG` or higher will go to the `outliers.log` file. We can
    then log output and information relevant to our code’s running status using the
    very easy-to-use syntax that comes with the `logging` library:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: What we have shown so far is really the basics of logging and it so far assumes
    that, although things may not be going perfectly, nothing has errored. This is
    obviously not always the case! So, what if we want to log an exception or error
    to our logging file?
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is typically done with the `logging.error` syntax but with an important
    point we must consider, which is that it is often not enough to just log the fact
    we’ve raised an error; we would also like to log the details of the error. So,
    as discussed in the *Error handling* section, we know that we can execute a `try`
    `except` clause on some code and then raise an exception. What we want to do in
    this case is log the details of that exception to our logging target. To do this
    we need to know that the `logging.error` method (and the `logging.debug` method)
    have some important keyword arguments we can use. For more on keyword arguments,
    see the section on *Tips and tricks* in this chapter. According to the logging
    documentation, [https://docs.python.org/3/library/logging.xhtml#logging.debug](https://docs.python.org/3/library/logging.xhtml#logging.debug),
    the keyword arguments `exc_info` and `stack_info` are given as Booleans, and `extra`
    is a dictionary. The keyword argument `exc_info = True` specifies that we wish
    to return exception information in the logging call, `stack_info = True` will
    return far more detailed stack trace information for the exception (including
    the logger call), and `extra` can be set equal to a dictionary with extra information
    that the developer has defined.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: The extra information in this case is then provided with the initial part of
    the record, as part of the identifier of the event. This is a good way to provide
    some bespoke information to your logging calls.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let us consider a bespoke feature transformation function, which,
    in this case, will actually not do anything useful, just return the original DataFrame
    like so:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we want to raise an exception when this function failed and log details
    about the error, we could write something like this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If we run this code on a simple dummy pandas DataFrame like the one below,
    the code will execute without issue:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If, however, we do the same, but this time, we run the code on something that
    does not have the pandas DataFrame `mean()` syntax, like a list:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '![](img/B19525_04_18.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: The output to the log file when we use the exc_info = True flag.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last piece of *housekeeping* to cover in this section is error handling.
    It is important to remember that when you are an ML engineer, your aim is to build
    products and services that work, but an important part of this is recognizing
    that things do not always work! It is therefore important that you build in patterns
    that allow for the escalation of (inevitable) errors during runtime. In Python,
    this is typically done via the concept of *exceptions*. Exceptions can be raised
    by the core Python functions and methods you are using. For example, imagine you
    ran the following code without defining the variable `x`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following exception would be raised:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The important point for us as engineers is that we should build solutions in
    which we can confidently control the flow of errors. We may not always want our
    code to break when an error occurs, or we may want to ensure that very specific
    messages and logging occur upon certain expected edge cases. The simplest technique
    for doing this is via `try except` blocks, as seen in the following code block:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this case, `do_something_else()` is executed if `do_something()` runs into
    an error.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: We will now finish with a comment on how to be efficient when building your
    solutions.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in Python is often built around the idea of “exceptions,” which
    are just events that disrupt the expected functioning of the program.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'The full list of exceptions in Python contains around 50 different types. Below
    is an excerpt taken from the Python documentation, with ellipses highlighting
    where I have not shown the full details:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You can see from the exception list that these are organized in a hierarchy.
    This means that raising an exception at a lower level is simply a more specific
    instance of an exception at a higher level, so you can actually raise it at a
    higher level of the hierarchy and everything still works correctly. As a quick
    example, we can see from the `ArithmeticError` sub-hierarchy that there are three
    exceptions at a lower level in the hierarchy:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This then means that if we were to raise an exception for a piece of code we
    think may divide a number by zero, we can legally use `ZeroDivisionError` or `ArithmeticError`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In general, when you catch an exception, there are a few different routes you
    can go down to handle it. First, you could handle the exception and continue the
    program flow. You should do this when it is clear what will be causing the error
    and it can be handled within the logic of the code. Second, you could raise the
    exception again. You may want to do this for a few reasons:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to log the error but still allow the exception to propagate up the
    call stack. This can be useful for debugging purposes, as it allows you to log
    the error message and other details about the exception, while still allowing
    the calling code to handle the exception as appropriate. An example may look something
    like this:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In this example, the `process_data` function tries to process some data and
    returns the result. If an exception occurs while processing the data, the exception
    is logged using the `logging.exception` function, which logs the exception along
    with a stack trace. The exception is then re-raised using the `raise` statement,
    which allows the calling code to handle the exception as appropriate.
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You want to add additional context to the exception. For example, you might
    want to add information about the state of your application when the exception
    occurred, or about the input that led to the exception being raised. Adapting
    the previous example, we may then have something like:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In this example, if an exception occurs while processing the data, the exception
    message is modified to include the data that was being processed. A new exception
    is then raised using the modified message and the original exception as the cause
    (using the `from e` syntax).
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You want to handle an exception in a higher level of your code but still allow
    lower-level code to handle the exception if it is not appropriate to handle it
    at the higher level. This is a bit more complex, so we will try and walk through
    another adapted example step by step. First, this time, when we raise the exception,
    we call a function that handles the exception in a bespoke way, called `handle_exception`:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The code for `handle_exception` would look something like the following, where
    we have to determine if we want to handle the exception at this level of abstraction
    or pass it up the call stack, using another function called `should_handle`:'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `should_handle` function would then be where we define our bespoke logic
    for deciding if we handle the exception at the current level or use the raise
    syntax to escalate up the call stack. For example, if we want to handle an `ArithmeticError`
    at this level and otherwise we want to raise up the call stack, the logic would
    look like this:'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, you may raise a different exception, perhaps because you need to bring
    together a few different exceptions and deal with them together at a higher level
    of abstraction. Once again, adapting the previous examples, this may mean that
    you write some code that looks like this:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In this example, if a `ValueError` exception occurs while processing the data,
    it is caught and a new `MyCustomException` is raised with the same message. If
    a `MyCustomException` exception occurs, it is caught and a new `MyCustomException`
    is raised with a modified message that includes the `data` that was being processed.
    This allows you to deal with different types of exceptions together at a higher
    level of abstraction, by raising a single, custom exception type that can be handled
    in a consistent way.
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A third program flow that we can use is that we can raise a new exception from
    within the original exception. This can be helpful because we can provide more
    detailed information about the type of error that has occurred, and we can give
    more contextual information that will help us debug any issues down the line.
    To make this clearer, let’s define an example function to stand in for the function
    we’ve been using in the previous examples:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We will call this in the same function as we had in the first example of the
    list above but now we will add a new piece of syntax to raise an exception from
    the original exception:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The raising from the original exception now ensures that we have logged the
    fact that this was specifically a `ValueError` related to the input data, and
    it allows us to log a higher-level message that can give additional context in
    the stack trace. For example, if you use the above functions and run this function
    call:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We get an error, as expected, since we are supplying a string and then trying
    to add an integer to it. A snippet from the stack trace I got when I ran this
    is given below:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The above exception was the direct cause of the following exception:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: You can see how the exception we raised from the original exception calls out
    where in the `process_data` function the error has occurred, and it has also given
    us the information that this issue relates to the processing of the data. Both
    pieces of information help provide context and can help us debug. The more technical
    original exception, the `TypeError` referring to the operand types, is still useful
    but could be hard to digest and fully debug on its own.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: This only scratches the surface of what is possible when it comes to logging,
    but this will allow you to get started.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Now, we move on to what we need to do in our code to handle scenarios where
    things go wrong!
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Not reinventing the wheel
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will already have noticed through this chapter (or I hope you have!) that
    a lot of the functionality that you need for your ML and Python project has already
    been built. One of the most important things you can learn as an ML engineer is
    that you are not supposed to build everything from scratch. You can ensure you
    do not do this in a variety of ways, the most obvious of which is to use other
    packages in your own solution and then build a functionality that enriches what
    is already there. As an example, you do not need to build basic regression modeling
    capabilities since they exist in a variety of packages, but you might have to
    add a new type of regressor or use some specific domain knowledge or trick you
    have developed. In this case, you would be justified in writing your own code
    on top of the existing solution. You can also use a variety of concepts from Python,
    such as wrapper classes or decorators. The key message is that although there
    is a lot of work for you to do when building your ML solutions, it is important
    that you do not feel the need to build everything from scratch. It is far more
    efficient to focus on where you can create added value and build on what has gone
    before!
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been all about best practices for when you write your own Python
    packages for your ML solutions. We went over some of the basic concepts of Python
    programming as a refresher before covering some tips and tricks and good techniques
    to bear in mind. We covered the importance of coding standards in Python and PySpark.
    We then performed a comparison between object-oriented and functional programming
    paradigms for writing your code. We moved on to the details of taking the high-quality
    code you have written and packaging it up into something you can distribute across
    multiple platforms and use cases. To do this, we looked into different tools,
    designs, and setups you could use to make this a reality, including the use of
    Makefiles and Poetry. We continued with a summary of some housekeeping tips for
    your code, including how to test, log, and monitor your solution. This also included
    some detailed examples of exception handling and how you can develop more sophisticated
    control flows in your programs and packages. We finished with a brief *philosophical*
    point on the importance of not reinventing the wheel.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deep dive into the world of deployment.
    This will be all about how you take scripts, packages, libraries, and apps that
    you have written and run them on appropriate infrastructure and tools.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/mle](https://packt.link/mle)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code102810325355484.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
