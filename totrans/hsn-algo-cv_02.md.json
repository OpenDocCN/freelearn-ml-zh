["```py\n    make\n    make install\n```", "```py\n    pip install opencv-python\n```", "```py\n    pip install --upgrade opencv-python\n```", "```py\ncmake_minimum_required(VERSION 3.1) \n\nproject(HelloOpenCV) \n\nset(OpenCV_DIR \"path_to_opencv\") \nfind_package(OpenCV REQUIRED) \ninclude_directories(${OpenCV_INCLUDE_DIRS}) \n\nadd_executable(${PROJECT_NAME} \"main.cpp\") \n\ntarget_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS}) \n```", "```py\n#include <iostream> \n#include <opencv2/opencv.hpp> \n\nusing namespace std; \nusing namespace cv; \n\nint main() \n{ \n    Mat image = imread(\"MyImage.png\"); \n    if(!image.empty()) \n    { \n        imshow(\"image\", image); \n        waitKey(); \n    } \n    else \n    { \n        cout << \"Empty image!\" << endl; \n    } \n\n    return 0; \n} \n```", "```py\nimport cv2 \n\nimage = cv2.imread(\"MyImage.png\") \nif image is not None : \n    cv2.imshow(\"image\", image) \n    cv2.waitKey() \n\nelse: \n    print(\"Empty image!\") \n```", "```py\nMat image(1080, 1920, CV_32FC3); \n```", "```py\nCV_<depth><type>C<channels> \n```", "```py\nMat grayscaleImage(600, 800, CV_8UC1); \nMat colorImage(600, 800, CV_8UC3); \n```", "```py\nint W = 800, H = 600, R = 50, G = 150, B = 200; \nMat image(H, W, CV_8UC3, Scalar(R, G, B));\n```", "```py\nScalar(B, G, R) \n```", "```py\nconst int dimensions = 7; \nconst int sizes[dimensions] = {800, 600, 3, 2, 1, 1, 1}; \nMat hdm(7, sizes, CV_32FC2); \n```", "```py\nvector<int> sizes = {800, 600, 3, 2, 1, 1, 1}; \nMat hdm(sizes, CV_32FC2); \n```", "```py\nMat hdm(sizes, CV_32FC2, Scalar(1.25, 3.5)); \n```", "```py\nMat image(1080, 1920, CV_8UC3, data);\n```", "```py\nMat roi(image, Rect(240, 140, 300, 300)); \n```", "```py\nRect(240, 140, 300, 300)\n```", "```py\ndilate(roi, roi, Mat(), Point(-1,-1), 5); \n```", "```py\nMat roi(image, Range(140, 440), Range(240, 540)); \n```", "```py\nimage.at<TYPE>(R, C) \n```", "```py\nimage.at<uchar>(R, C)\n```", "```py\nimage.at<float>(R, C) \n```", "```py\nimage.at<Vec3b>(R, C) \n```", "```py\nVec<N><Type> \n```", "```py\nimage.at<Vec3b>(R, C)[1]\n```", "```py\nfor(int i=0; i<image.rows; i++) \n{ \n    for(int j=0; j<image.cols; j++) \n    { \n        int inputBlue = image.at<Vec3b>(i,j)[0]; \n        int inputGreen = image.at<Vec3b>(i,j)[1]; \n        int inputRed = image.at<Vec3b>(i,j)[2]; \n\n        int red = \n                inputRed * 0.393 + \n                inputGreen * 0.769 + \n                inputBlue * 0.189; \n\n        if(red > 255 ) red = 255; \n\n        int green = \n                inputRed * 0.349 + \n                inputGreen * 0.686 + \n                inputBlue * 0.168; \n\n        if(green > 255) green = 255; \n\n        int blue = \n                inputRed * 0.272 + \n                inputGreen * 0.534 + \n                inputBlue * 0.131; \n\n        if(blue > 255) blue = 255; \n\n        image.at<Vec3b>(i,j)[0] = blue; \n        image.at<Vec3b>(i,j)[1] = green; \n        image.at<Vec3b>(i,j)[2] = red; \n    } \n} \n```", "```py\nimage.forEach<uchar>([](uchar &p, const int *) \n{ \n    p /= 5; \n}); \n```", "```py\nfor(int i=0; i<image.rows; i++) \n    for(int j=0; j<image.cols; j++) \n        image.at<uchar>(i,j) /= 5; \n```", "```py\nMatIterator_<uchar> it_begin = image.begin<uchar>(); \nMatIterator_<uchar> it_end = image.end<uchar>(); \nfor( ; it_begin != it_end; it_begin++) \n{ \n    *it_begin /= 5; \n}\n```", "```py\nimage /= 5; \n```", "```py\nMat image = imread(\"MyImage.png\", \n    IMREAD_GRAYSCALE | IMREAD_IGNORE_ORIENTATION);\n```", "```py\nbool success = imwrite(\"c:/my_images/image1.png\", image); \ncout << (success ? \n            \"Image was saved successfully!\" \n          : \n            \"Image could not be saved!\") \n     << endl; \n```", "```py\nVideoCapture vid(\"MyVideo.mov\"); \n// check if video file was opened correctly \nif(!vid.isOpened()) \n{ \n    cout << \"Can't read the video file\"; \n    return -1; \n} \n// get frame rate per second of the video file \ndouble fps = vid.get(CAP_PROP_FPS); \nif(fps == 0) \n{ \n    cout << \"Can't get video FPS\"; \n    return -1; \n} \n// required delay between frames in milliseconds \nint delay_ms = 1000.0 / fps; \n// infinite loop \nwhile(true) \n{ \n    Mat frame; \n    vid >> frame; \n    if(frame.empty()) \n        break; \n    // process the frame if necessary ... \n    // display the frame \n    imshow(\"Video\", frame); \n    // stop playing if space is pressed \n    if(waitKey(delay_ms) == ' ') \n        break; \n} \n// release the video file \nvid.release(); \n```", "```py\nVideoWriter wrt(\"C:/output.avi\", \n                VideoWriter::fourcc('M','J','P','G'), \n                30, Size(1920, 1080)); \n```", "```py\nwrt << image; \n```", "```py\nvid.write(frame); \n```", "```py\nVideoCapture cam(0); \n// check if camera was opened correctly \nif(!cam.isOpened()) \n    return -1; \n\n// infinite loop \nwhile(true) \n{ \n    Mat frame; \n    cam >> frame; \n    if(frame.empty()) \n        break; \n\n    // process the frame if necessary ... \n\n    // display the frame \n    imshow(\"Camera\", frame); \n\n    // stop camera if space is pressed \n    if(waitKey(10) == ' ') \n        break; \n} \n\ncam.release(); \n```", "```py\nrtsp://user:password@website.com/somevideo \n```"]