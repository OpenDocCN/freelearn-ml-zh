- en: Chapter 10. Developing Segmentation Algorithms for Text Recognition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned about a wide range of image processing
    techniques, such as thresholding, contour descriptors, and mathematical morphology.
    In this chapter, we will discuss the common problems with dealing with scanned
    documents, such as identifying where the text is or adjusting its rotation. We
    will also learn how to combine techniques presented in the previous chapters to
    solve these problems. Finally, we'll have segmented regions of text that can be
    sent to an **OCR** (**optical character recognition**) library.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should be able to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What kind of OCR applications exist?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the common problems while writing an OCR application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we identify regions of documents?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we deal with problems such as skewing and other elements in the middle
    of the text?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we use Tesseract OCR to identify the text?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing optical character recognition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Identifying text in an image is a very popular application for Computer Vision.
    This process is commonly called OCR and divided into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text preprocessing and segmentation**: During this step, the computer must
    learn to deal with the image noise and rotation (skewing) and identify what areas
    are candidate text areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text identification**: This is a process used to identify each letter in
    a text. Although this is also a Computer Vision topic, we will not show you how
    to do this in this book using OpenCV. Instead, we will show you how to use the
    Tesseract library to do this step, since it was integrated with OpenCV 3.0\. If
    you are interested in learning how to do what Tesseract does all by yourself,
    take a look at *Mastering OpenCV*, *Packt Publishing*, which presents a chapter
    about car license plate recognition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preprocessing and segmentation phase can vary greatly depending on the
    source of the text. Let''s take a look at the common situations where preprocessing
    is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Production OCR applications with a scanner, which is a very reliable source
    of text: In this scenario, the background of the image is usually white and the
    document is almost aligned with the scanner margins. The content that is being
    scanned basically contains text with almost no noise. This kind of application
    relies on simple preprocessing techniques that can adjust the text quickly and
    maintain a fast scanning pace. When writing production OCR software, it is common
    to delegate identification of important text regions to the user and create a
    quality pipeline for text verification and indexing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scanning text in a casually taken picture or in a video: This is a much more
    complex scenario, as there''s no indication of where the text can be. This scenario
    is called *Scene text recognition*, and OpenCV 3.0 introduces a brand new library
    to deal with it, which we will cover in [Chapter 11](ch11.html "Chapter 11. Text
    Recognition with Tesseract"), *Text Recognition with Tesseract*. Usually, the
    preprocessor will use texture analysis techniques to identify the text patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a production quality OCR for historical texts: Historical texts are
    also scanned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, they have several additional problems, such as noise created by the
    old paper color and usage of ink. Other common problems are decorated letters,
    specific text fonts, and low-contrast content created by ink that has been degraded
    over time. It's not uncommon to write specific OCR software for documents at hand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Scanning maps, diagrams, and charts: Maps, diagrams, and charts pose a difficult
    scenario since the text is usually in any orientation and in the middle of an
    image''s content. For example, city names are often clustered, and ocean names
    often follow country shore contour lines. Some charts are heavily colored, with
    text appearing in both clear and dark tones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OCR application strategies also vary according to the objective of the identification.
    Will they be used for a full text search? Or should the text be separated in a
    logical field to index a database with information for a structured search?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on preprocessing scanned text or text photographed
    by a camera. We''ll assume that the text is the main purpose of the image, such
    as in a photograph, paper, or card; for example, take a look at the following
    parking ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing optical character recognition](img/B04283_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We'll try to remove the common noise, deal with text rotation (if any), and
    crop the possible text regions. While most OCR APIs already do these things automatically
    and probably with state-of-the-art algorithms, it still worth knowing how things
    happen under the hood. This will allow you to better understand most OCR APIs'
    parameters and will give you a better knowledge of potential OCR problems that
    you may face.
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessing step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software that identifies letters do so by comparing text with a previously recorded
    data. Classification results can be improved greatly if the input text is clear,
    if the letters are in a vertical position, and if there are no other elements,
    such as images that are sent to the classification software. In this section,
    we'll learn how to adjust text. This stage is called **preprocessing**.
  prefs: []
  type: TYPE_NORMAL
- en: Thresholding the image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We usually start the preprocessing stage by thresholding the image. This eliminates
    all the color information. Most OpenCV functions require information to be the
    written in white and the background to be black. So, let''s start with creating
    a threshold function to match this criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `binarize` function applies a threshold, similar to what we did in [Chapter
    4](ch04.html "Chapter 4. Delving into Histograms and Filters"), *Delving into
    Histograms and Filters*. However, we use the `Otsu` method by passing `THRESH_OTSU`
    to the fourth parameter of the function.
  prefs: []
  type: TYPE_NORMAL
- en: The `Otsu` method maximizes the inter-class variance. Since a threshold creates
    only two classes (the black and white pixels), this is the same as minimizing
    the intra-class variance. The method works using the image histogram. Then, it
    iterates through all the possible threshold values and calculates a measure of
    spread for the pixel values on each side of the threshold, that is, the pixels
    that are either in the background or in the foreground of the image. The purpose
    is to find the threshold value where the sum of both the spreads is at its minimum.
  prefs: []
  type: TYPE_NORMAL
- en: After the thresholding is done, the function counts the number of white pixels
    in the image. The black pixels are simply the total number of pixels in the image,
    given by the image area minus the white pixel count.
  prefs: []
  type: TYPE_NORMAL
- en: Since text is usually written on a plain background, we will check whether there
    are more white pixels than black. In this case, we are dealing with black text
    over a white background, so we invert the image for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the thresholding process with the parking ticket image is shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Thresholding the image](img/B04283_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Text segmentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to find where the text is located and extract it. There are
    two common strategies to do this, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the connected component analysis, we search for groups of connected pixels
    in the image. This is the technique that we will use in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use classifiers to search for a previously trained letter texture pattern. Texture
    features such as Haralick features and wavelet transforms are often used. The
    other option is to identify **maximally stable extremal regions** (**MSERs**)
    in this task. This approach is more robust for text in a complex background and
    will be studied in the next chapter. You can read about Haralick features on his
    own website at [http://haralick.org/journals/TexturalFeatures.pdf](http://haralick.org/journals/TexturalFeatures.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating connected areas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you take a closer look at the image, you'll notice that the letters are always
    grouped together in blocks that are formed by each of text paragraphs. So, how
    do we detect and remove these blocks?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to make these blocks even more evident. We can do this using
    the dilation morphological operator. In [Chapter 8](ch08.html "Chapter 8. Video
    Surveillance, Background Modeling, and Morphological Operations"), *Video Surveillance,
    Background Modeling, and Morphological Operations*, we learned how dilation makes
    the image elements thicker. Let''s take a look at the following code snippet that
    does the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we start by creating a 3 x 3 cross kernel that will be used in
    the morphological operation. Then, we apply the dilation five times, centered
    on this kernel. The exact kernel size and number of times vary according to the
    situation. Just make sure that the values glue all the letters in the same line
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating connected areas](img/B04283_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that now we have huge white blocks. They exactly match each paragraph
    of the text and also match other nontextual elements such as images or the border
    noise.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ticket image that comes with the code is a low resolution image. OCR engines
    usually work with high resolution images (200 or 300 DPI), so it may be necessary
    to apply dilation more than five times.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying paragraph blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step is to perform connect component analysis to find blocks that
    correspond to paragraphs. OpenCV has a function to do this, which we previously
    used in [Chapter 5](ch05.html "Chapter 5. Automated Optical Inspection, Object
    Segmentation, and Detection"), *Automated Optical Inspection, Object Segmentation,
    and Detection*. It''s the `findContours` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first parameter, we pass our dilated image. The second parameter is
    the vector of detected contours. Then we use the option to retrieve only external
    contours and use simple approximation. The image contours are presented in the
    following figure. Each tone of gray represents a different contour:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying paragraph blocks](img/B04283_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last step is to identify the minimum rotated bounding rectangle of each
    contour. OpenCV provides a handy function for this operation called `minAreaRect`.
    This function receives a vector of arbitrary points and returns a `RoundedRect`
    that contains the bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also a good opportunity to discard unwanted rectangles, that is, rectangles
    that are obviously **not** text. Since we are making a software for OCR, we''ll
    assume that the text contains a group of letters together. With this assumption,
    we''ll discard text in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The rectangle width or size is too small, that is, smaller than 20 pixels. This
    will help you discard border noise and other small artifacts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rectangles of the images that have a width/height proportion smaller than
    two. That is, rectangles that resemble a square, such as image icons, or ones
    that are much taller and larger will also be discarded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s a little caveat in the second condition. Since we are dealing with
    rotated bounding boxes, we must check whether the bounding box angle is not smaller
    than 45 degrees. If that''s the case, the text will be vertically rotated, so
    the proportion that must be taken into account is the height/width. Let''s take
    a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the boxes that are selected by this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying paragraph blocks](img/B04283_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is certainly a good result!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the algorithm described in condition 2 will also discard single
    letters. This is not a big issue, since we are creating an OCR preprocessor, and
    single symbols are usually meaningless with the context information. One example
    of such a case is the page numbers. They will be discarded with this process since
    they usually appear alone at the bottom of the page and will definitely fail the
    size or proportion text. However, this will not be a problem, as after the text
    passes through the OCR, there will be a huge text file with no page division at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll place this code in a function with this signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Text extraction and skew adjustment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, all we need to do is extract the text and adjust text skew. This is done
    by the `deskewAndCrop` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we start by reading the desired region, angle, and size. As mentioned
    earlier, the angle can be less than 45 degrees. This means that the text is vertically
    aligned, so we need to add 90 degrees to the rotation angle and switch the width
    and height properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to rotate the text. First, we start by creating a 2D affine transformation
    matrix that describes the rotation. We do this using the `getRotationMatrix2D`
    OpenCV function. This function takes the following three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CENTER`: This is the central position of the rotation. The rotation will pivot
    around this center. In our case, we use the box center.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANGLE`: This is the rotation angle. If the angle is negative, the rotation
    will occur in the clockwise direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCALE`: This is an isotropic scale factor. We use 1.0 as we want to keep the
    box''s original scale untouched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rotation itself is made using the `warpAffine` function. This function
    takes four mandatory arguments, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SRC`: This is the input `mat` array to be transformed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DST`: This is the destination `mat` array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: This is a transformation matrix. This matrix is a 2 x 3 affine transformation
    matrix. This may be a translation, scale, or rotation matrix. In our case, we
    just use the matrix that we recently created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIZE`: This is the size of the output image. We will generate an image with
    the same size as that of our input image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other three optional arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLAGS`: This indicates how the image should be interpolated. We use `BICUBIC_INTERPOLATION`
    for better quality. The default value is `LINEAR_INTERPOLATION`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BORDER`: This is the border mode. We use the default `BORDER_CONSTANT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BORDER VALUE`: This is the color of the border. We use the default value,
    which is black.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we use the `getRectSubPix` function. After we rotate our image, we need
    to crop the rectangular area of our bounding box. This function takes four mandatory
    arguments and one optional, and returns the cropped image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IMAGE`: This is the image to be cropped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIZE`: This is a `cv::Size` object that describes the width and height of
    the box to be cropped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CENTER`: This is the central pixel of the area to be cropped. Notice that
    as we rotate around the center, this point remains the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: This is the destination image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH_TYPE`: This is the depth of the destination image. We use the default
    value, representing the same depth as that of the source image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final step is done by the `copyMakeBorder` function. This function adds
    a border around the image. This is important because the classification stage
    usually expects a margin around the text. The function parameters are very simple:
    the input and output images, the border thickness around the top, bottom, left,
    and right of the image, and the color of the new border.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the card image, the following images will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text extraction and skew adjustment](img/B04283_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it''s time to put every function together. Let''s present the main method
    that will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the ticket image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call our `binarization` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find all text regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Show each region in a window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the complete source code, take a look at the `segment.cpp` file that comes
    along with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Tesseract OCR on your operating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tesseract is an open source OCR engine originally developed by *Hewlett-Packard
    Laboratories, Bristol* and *Hewlett-Packard Co*. It has all the code licenses
    under the Apache License and is hosted on GitHub at [https://github.com/tesseract-ocr](https://github.com/tesseract-ocr).
  prefs: []
  type: TYPE_NORMAL
- en: It is considered one of the most accurate OCR engines that is available. It
    can read a wide variety of image formats and can convert text written in more
    than 60 languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this session, we will teach you how to install Tesseract on Windows or Mac.
    Since there are lots of Linux distributions, we will not teach you how to install
    on this operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, Tesseract offers installation packages in your package repository,
    so before you compile Tesseract, just search there.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Tesseract on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Tesseract is hosted on GitHub, its latest Windows installer is still
    available in the old repository on Google Code. The latest installer version is
    3.02.02, and it's recommended that you use the installer. Download the installer
    from [https://code.google.com/p/tesseract-ocr/downloads/list](https://code.google.com/p/tesseract-ocr/downloads/list).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the installer, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Look for the `tesseract-ocr-setup-3.02.02.exe` and `tesseract-3.02.02-win32-lib-include-dirs.zip`
    files, and download and run the executable installer![Installing Tesseract on
    Windows](img/B04283_10_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get past the **welcome screen**, read and accept the license agreement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose between installing for all users in the computer or just for your user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, choose a suitable location for your installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the folder of the installation. Tesseract points to the `program files`
    folder by default, since it has a command-line interface. You can change it to
    a more suitable folder, if you want. Then, go to the next screen:![Installing
    Tesseract on Windows](img/B04283_10_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you select **Tesseract development files**. This will install the
    `Leptonica` library files and source code. You can also choose language data for
    your native language. Tesseract has English selected by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The installer will download and set up Tesseract dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test the Tesseract installation, you can run it via the command line. For
    example, to run Tesseract on the `parkingTicket.png` file, you can run the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, go back to the downloaded `tesseract-3.02.02-win32-lib-include-dirs.zip`
    file. Unzip this file and copy the `lib` and `add` folders to your `tesseract`
    installation folder. There will be folders with the same name in this folder,
    but that's normal. This file will include `tesseract` files and libraries in the
    Tesseract installation. Ironically, Tesseract `libs` and `dlls` do not come with
    the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up Tesseract in Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Visual Studio 2010 is the recommended IDE for Windows developers with
    Tesseract, it's important to set this up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup process is quite simple, and it''s divided into the following three
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the import and library paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the libraries to the linker input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Tesseract `dlls` to the windows path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see each of these steps in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the import and library paths
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The import path tells Visual Studio where to search for the `.h` files that
    will be available when an `#include` directive is performed in your code.
  prefs: []
  type: TYPE_NORMAL
- en: In solution explorer, right-click on your **project** and click on **properties**.
    Then, select **configuration properties** and **VC++ Directories**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have created a new project from scratch, make sure you added at least
    one `c++` file to the project to let Visual know that this is a `C++` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click on **Include Directories**. An arrow appears. Click on this arrow
    and then click on **Edit**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the import and library paths](img/B04283_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You must add two directories to this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `TesseractInstallPath` with your Tesseract installation path; for
    example, `c:\Program Files\Tesseract-OCR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click on **Library Directories**, click on the arrow, and then on `Edit`,
    just like you did for **Include Directories**. You must add one directory to the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the linker
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While still on the Property page, go to **Linker** | **Input**. Edit the **Additional
    Dependencies** row and include two libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the numbers in the `lib` name refer to the file version, the library names
    can change if you install a different version of Tesseract. To do this, just open
    the `lib` path in Windows Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the debug libraries (the ones that end with a *d* letter) do
    not work out of the box with Tesseract. If you really need to use them, you need
    to compile Tesseract and Leptonica yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the libraries to the windows path
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You must add two library files to the windows path. The first is located directly
    in `TesseractInstallPath` and it is called `liblept168.dll`. The second one is
    in `TesseractInstallPath\lib` and it is called `libtesseract302.dll`. There are
    two ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy these files to a location where Visual Studio generates your executable
    file. This will not add the files to the Windows path but will allow the application
    to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy these files to a folder that is configured in the Windows path. You can
    configure a new folder in the Windows path by changing the environment variables
    in **System Properties**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Some internet tutorials teach you to include these files in folders, such as
    `Windows\System32`. Do not do this. If you do this, it can be hard to change the
    library version in the future, since this folder has a lot of other `dlls` systems,
    and you may lose track of what you already placed in there. Also, you can always
    disable a custom path to test an installer and check whether you forgot to pack
    a `dll` in your installation bundle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing Tesseract on Mac
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to install Tesseract OCR on Mac is using Homebrew. If you don't
    have Homebrew installed, just go to the Homebrew site ([http://brew.sh/](http://brew.sh/)),
    open your console, and run the Ruby script that is on the front page. You may
    be required to type your administrator password.
  prefs: []
  type: TYPE_NORMAL
- en: 'After `homebrew` is installed, just type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The English language is already included in this installation. If you want
    to install other language packs, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will install all language packs. Then, just go to the Tesseract installation
    directory and delete all unwanted languages. Homebrew usually installs stuff in
    `/usr/local/`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Tesseract OCR library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Tesseract OCR is already integrated with OpenCV 3.0, it still worth studying
    its API since it allows a finer-grained control over Tesseract parameters. The
    integration will be studied in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a OCR function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll change the previous example to work with Tesseract. We will start with
    adding `baseapi` and `fstream tesseracts` to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll create a global `TessBaseAPI` object that represents our Tesseract
    OCR engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ocr` engine is completely self-contained. If you want to create multithreaded
    OCR software, just add a different `TessBaseAPI` object to each thread, and the
    execution will be fairly thread-safe. You just need to guarantee that file writing
    is not done over the same file; otherwise, you'll need to guarantee safety for
    this operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a function called `identify` text that will run the OCR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain this function line by line. In the first line, we start initializing
    Tesseract. This is done by calling the `init` function. This function has the
    following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain each parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Datapath**: This is the path to the `tessdata` files of the root directory.
    The path must end with a backslash / character. The `tessdata` directory contains
    the language files that you installed. Passing `NULL` to this parameter will make
    Tesseract search in its installation directory, which is the location where this
    folder is normally present. It''s common to change this value to `args[0]` when
    deploying an application and include the `tessdata` folder in your application
    path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: This is a three-letter word with the language code (for example,
    eng for English, por for Portuguese, or hin for Hindi). Tesseract supports loading
    of multiple language code using the `+` sign. So, passing *eng* + *por* will load
    both English and Portuguese. Of course, you can only use languages that you have
    previously installed; otherwise, the loading will fail. A language `config` file
    can specify that two or more languages must be loaded together. To prevent this,
    you can use a tilde `~`. For example, you can use `hin+~eng` to guarantee that
    English is not loaded with Hindi, even if it is configured to do so.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OcrEngineMode**: These are OCR algorithms that will be used. They can have
    one of the following values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OEM_TESSERACT_ONLY`: This uses just Tesseract. It''s the fastest method, but
    it also has less precision.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OEM_CUBE_ONLY`: This uses cube engine. It''s slower, but it''s more precise.
    This will only work if your language was trained to support this engine mode.
    To check whether that''s the case, look for `.cube` files for your language in
    the `tessdata` folder. The support for English is guaranteed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OEM_TESSERACT_CUBE_COMBINED`: This combines both Tesseract and Cube in order
    to achieve the best possible OCR classification. This engine has the best accuracy
    and the slowest execution time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OEM_DEFAULT`: This tries to infer the strategy based on the language `config`
    file and the command line `config` file, or in the absence of both, uses `OEM_TESSERACT_ONLY`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to emphasize that the `init` function *can* be executed many
    times. If a different language or engine mode is provided, Tesseract will clear
    the previous configuration and start again. If the same parameters are provided,
    Tesseract is smart enough to simply ignore the command. The `init` function returns
    `0` for success and `-1` for failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program then proceeds by setting the page segmentation mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several segmentation modes available, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PSM_OSD_ONLY`: Using this mode, Tesseract just runs its preprocessing algorithms
    to detect the orientation and script detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_AUTO_OSD`: This tells Tesseract to perform automatic page segmentation
    with orientation and script detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_AUTO_ONLY`: This does page segmentation, but avoids doing orientation,
    script detection, or OCR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_AUTO`: This does page segmentation and OCR, but avoids doing orientation
    or script detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_SINGLE_COLUMN`: This assumes that the text of variable sizes is displayed
    in a single column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_SINGLE_BLOCK_VERT_TEXT`: This treats the image as a single uniform block
    of a vertically aligned text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_SINGLE_BLOCK`: This is a single block of text. This is the default configuration.
    We will use this flag since our preprocessing phase guarantees this condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_SINGLE_LINE`: This indicates that the image contains only one line of
    text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_SINGLE_WORD`: This indicates that the image contains just one word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_SINGLE_WORD_CIRCLE`: This indicates that the image is just one word that
    is disposed in a circle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSM_SINGLE_CHAR`: This indicates that the image contains a single character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that Tesseract has already implemented `deskewing` and text segmentation
    algorithms, as most OCR libraries do. But it's interesting to know such algorithms
    as you can provide your own preprocessing phase for specific needs. This allows
    you to improve text detection is many cases. For example, if you are creating
    an OCR application for old documents, the default threshold used by Tesseract
    can create a dark background. Tesseract may also be confused by borders or severe
    text skewing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we call the `SetImage` method with the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are almost self-explanatory, and most of them can be read directly
    from our `mat` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: This is a raw byte array that contains the image data. OpenCV contains
    a function called `data()` in the `Mat` class that provides a direct pointer to
    the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: This is the image width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This is the image height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes_per_pixel`: This is the number of bytes per pixel. We use `1`, since
    we are dealing with a binary image. If you want to allow the code to be more generic,
    you can also use the `Mat::elemSize()` function that provides the same information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes_per_line`: This is the number of bytes in a single line. We use the
    `Mat::step` property since some images add trailing bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we call `GetUTF8Text` to run the recognition itself. The recognized text
    is returned, encoded with UTF8 without BOM (byte order mark). Before we return
    it, we also print some debug information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MeanTextConf` returns a confidence index, which can be a number from `0`
    to `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Sending the output to a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s change our `main` method to send the recognized output to a file. We
    do this using a standard `ofstream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This opens the file in binary mode. This is important since Tesseract returns
    a text encoded in UTF-8, taking into account the special characters available
    in Unicode. We also write the output directly using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this sample, we called `identify` using Portuguese as the input language
    (this is the language in which the ticket was written). You can use another photo,
    if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete source file is provided in the `segmentOcr.cpp` file, which comes
    along with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ticket.png` is a low resolution image, since we imagined that you would want
    to display a window with the image while studying this code. For this image, Tesseract
    results are rather poor. If you want to test it with a higher resolution image,
    the code is provided with a `ticketHigh.png` image. To test this image, change
    the dilation repetitions to 12 and the minimum box size from 20 to 60\. You''ll
    get a much higher confidence rate (about 87%) and the resulting text will be fully
    readable. The `segmentOcrHigh.cpp` file contains these modifications.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented a brief introduction to OCR applications. We saw
    that the preprocessing phase of such systems must be adjusted according to the
    type of documents that we are planning to identify. We learned the common operations
    while preprocessing text files, such as thresholding, cropping, skewing, and text
    region segmentation. Finally, we learned how to install and use Tesseract OCR
    to convert our image to text.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll use a more sophisticated OCR technique to identify
    text in a casually taken picture or video—a situation known as scene text recognition.
    This is a much more complex scenario, since the text can be anywhere, in any font,
    and with different illuminations and orientations. There can be no text at all!
    We'll also learn how to use the OpenCV 3.0 text contribution module, which is
    fully integrated with Tesseract.
  prefs: []
  type: TYPE_NORMAL
