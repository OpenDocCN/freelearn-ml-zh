- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Tools of the Trade in Quantum Computing
  prefs: []
  type: TYPE_NORMAL
- en: '*Give us the tools, and we will finish the job.*'
  prefs: []
  type: TYPE_NORMAL
- en: — Winston Churchill
  prefs: []
  type: TYPE_NORMAL
- en: We are all very much looking forward to having a ”Q1 Pro” quantum chip in our
    laptops, but — much to our regret — the technology is not there just yet. Nevertheless,
    we do have some actual quantum computers that, with their limitations, are able
    to execute quantum algorithms. And, furthermore, our good old classical computers
    can actually do a very decent job at simulating ideal quantum computers, at least
    for a low number of qubits.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the tools that allow us to implement quantum
    algorithms using the quantum circuit model and run them on simulators or on real
    quantum hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by going through some of the most widely-used quantum software
    frameworks and platforms out there. Then, we will see how to work with the two
    software frameworks that we are going to use more extensively throughout this
    book: Qiskit and PennyLane.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools for quantum computing: a non-exhaustive overview'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Qiskit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with PennyLane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will have a broad perspective on the range of
    software tools and platforms available for quantum computing. Moreover, you will
    know how to implement and execute quantum algorithms — both on simulators and
    real quantum hardware — using Qiskit and PennyLane.
  prefs: []
  type: TYPE_NORMAL
- en: '2.1 Tools for quantum computing: a non-exhaustive overview'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this book, we will work mostly with two quantum frameworks: **Qiskit** and
    **PennyLane**. These frameworks are powerful, very widely used, and are backed
    by strong user communities, but they are by no means the only interesting options
    available. There is currently a plethora of wonderful software frameworks for
    quantum computing, so much so that it can sometimes feel overwhelming!'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1 A non-exhaustive survey of frameworks and platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will briefly go through some of the most popular frameworks
    out there. Most of these frameworks are free, both as in *free beer* and as in
    *free* *speech*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quirk**: We can begin with a simple yet powerful simulator of quantum circuits:
    Quirk ([https://algassert.com/quirk](https://algassert.com/quirk)). Unlike all
    the other frameworks that we will discuss, this one does not work with code, but
    with a graphical user interface that runs as a web application. This makes it
    ideal for running demonstrations of algorithms or for quick prototyping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: file:///C:/Users/ketank/AppData/Local/Temp/sigil-PiDscY/file290.png![PIC](img/file285.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With Quirk, you can build quantum circuits arranging gates with a **drag-and-drop
    interface**. It includes the most common quantum gates, in addition to a handful
    of custom gates that are used for the demonstration of some algorithms. You can
    have a look at *Figure* [*2.1.1*](#a-non-exhaustive-survey-of-frameworks-and-platforms)
    to see Quirk in action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Q# and Microsoft’s QDK**: Most quantum software frameworks rely on a **host**
    classical programming language (usually **Python**). **Q#** (read as ”*Q* *sharp*”)
    is an exception to this rule: it is a purpose-built programming language for quantum
    computing developed at Microsoft. This language is used in Microsoft’s **Quantum
    Development Kit** (**QDK**) ([https://azure.microsoft.com/en-us/resources/development-kit/quantum-computing/](https://azure.microsoft.com/en-us/resources/development-kit/quantum-computing/)),
    which includes several simulators for running quantum algorithms and assessing
    their performance. With the QDK, you can also send your quantum algorithms to
    real quantum computers using **Azure** **Quantum**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to this, Microsoft provides solutions that enable Q# to run interactively
    and to be inter-operable with other programming languages such as Python. Moreover,
    the Azure Quantum service, which allows you to run quantum algorithms on real
    hardware, also works with other quantum software frameworks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**QuEST**. The **Quantum Exact Simulation Toolkit** (**QuEST**) ([https://quest.qtechtheory.org/](https://quest.qtechtheory.org/))
    is a simulation framework written in **C++** and built with performance in mind.
    With it, you can write a single implementation of a quantum algorithm that can
    be compiled into binary code, yielding a program that will simulate the algorithm.
    Using this framework, you can be *closer to the metal* and make sure that all
    the hardware resources available are used in an optimal way. This makes QuEST
    a very interesting choice for hardware-intensive simulations with a large number
    of qubits. In other words, if you ever wanted to test how many qubits your computer
    was able to handle, QuEST might be the way to go (you might want to have a fire
    extinguisher at hand though, just in case things get hot!).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code for QuEST is freely available online: ([https://github.com/quest-kit/QuEST](https://github.com/quest-kit/QuEST)).
    It is mostly C and C++ code that you can use on any device.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cirq** ([https://quantumai.google/cirq](https://quantumai.google/cirq)) is
    a quantum software framework developed at **Google** that uses Python as a host
    language. It can be used to design quantum algorithms and to simulate them on
    a classical device or send them to real quantum hardware. Furthermore, Cirq is
    integrated in [TensorFlow Quantum](https://www.tensorflow.org/quantum) ([https://www.tensorflow.org/quantum](https://www.tensorflow.org/quantum)),
    Google’s framework for quantum machine learning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qiskit** ([https://qiskit.org/](https://qiskit.org/)) is **IBM**’s quantum
    framework. It relies on Python as a host language and provides a wide range of
    simulators as well as allowing the submission of algorithms to IBM’s real quantum
    hardware. In addition to this, Qiskit provides an extensive library of quantum
    circuits and algorithms, many of which we will use in this book!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, when it comes to machine learning, Qiskit includes some interesting
    models with the tools necessary to train and execute them; and it also provides
    a **PyTorch** interface for the training of quantum machine learning models (we
    will explore Qiskit and all its secrets in detail in the following section).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**PennyLane** ([https://pennylane.ai/](https://pennylane.ai/)) is a quantum
    framework built specifically for quantum machine learning, but it can perfectly
    be used as a general-purpose quantum computing framework. It is quite a newcomer
    to the quantum programming scene and it is being developed at **Xanadu**. Like
    Qiskit, it uses Python as a host language. Any quantum algorithms written in PennyLane
    can be sent to real quantum computers and executed in a broad collection of simulators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PennyLane is one of the best frameworks out there when it comes to inter-operability.
    Thanks to a wide collection of **plugins**, you can export PennyLane circuits
    to other frameworks and execute them there — taking advantage of some of the features
    that these other frameworks may have.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When it comes to machine learning, PennyLane provides some built-in tools, but
    it is also highly inter-operable with classical machine learning frameworks such
    as **scikit-learn**, **Keras**, **TensorFlow**, and **PyTorch**. We will discuss
    this framework in detail later in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Ocean** ([https://docs.ocean.dwavesys.com/en/stable/](https://docs.ocean.dwavesys.com/en/stable/))
    is a Python library developed by the Canadian company **D-Wave**. In contrast
    with the other software packages that we have mentioned so far, Ocean’s goal is
    not the implementation and execution of quantum circuits. Instead, this library
    allows you to define instances of combinatorial optimization problems of different
    types and to solve them both with classical algorithms and on D-Wave’s **quantum
    annealers** (special quantum computers that are not general-purpose but oriented
    to solving optimization problems).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starting in *Chapter* *[*3*](ch011.xhtml#x1-590003), *QUBO: Quadratic Unconstrained
    Binary* *Optimization*, we will introduce the concepts that we will need in order
    to understand how to define problems with Ocean. And in *Chapter* *[*4*](ch012.xhtml#x1-750004),
    *Quantum Adiabatic Computing and Quantum Annealing*, we will learn how to use
    Ocean in all its glory, both to solve these optimization problems with classical
    algorithms and, of course, with quantum algorithms in actual quantum computers!**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**To learn more…'
  prefs: []
  type: TYPE_NORMAL
- en: The source code (and binaries, if any) for these frameworks can be downloaded
    from their official websites. For detailed installation instructions for Qiskit,
    Pennylane, and Ocean, you can refer to *Appendix* *[*D*](ch027.xhtml#x1-240000D),
    *Installing the Tools*.*
  prefs: []
  type: TYPE_NORMAL
- en: '**   **Amazon Braket**: Amazon Web Services offers Amazon Braket ([https://aws.amazon.com/braket/](https://aws.amazon.com/braket/)),
    a paid cloud service that makes it possible to use a wide range of implementations
    of real quantum computers. In order to execute code on these computers, they provide
    their own *device-agnostic SDK*, but they also fully support PennyLane and Qiskit,
    and there are even plugins to work with Ocean ([https://amazon-braket-ocean-plugin-python.readthedocs.io/](https://amazon-braket-ocean-plugin-python.readthedocs.io/)).'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.2 Qiskit, PennyLane, and Ocean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have just seen, there is an abundant range of choices when it comes to
    software frameworks for quantum computing, and this might make you wonder why
    we are going to stick with Qiskit, PennyLane, and Ocean. Of course, this is not
    a choice made at random; we have a bunch of good reasons!
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding Qiskit, it is just massive: the level of built-in algorithms and
    functionalities that it includes is simply unmatched. And not only that, but it
    also has a very strong community of users and it is supported by most quantum
    hardware providers out there. In other words, Qiskit could easily be considered
    a *lingua franca* of quantum computing.'
  prefs: []
  type: TYPE_NORMAL
- en: PennyLane, on the contrary, is not as widely used a framework as Qiskit (at
    least for now), but we believe that it is one of the most promising newcomers
    to the world of quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, when it comes to quantum machine learning, it is very hard to
    say that there is anything better than PennyLane. On the one hand, PennyLane simply
    runs very smoothly and is beautifully documented and, on the other, its interoperability
    with other quantum and **Machine Learning** (**ML**) frameworks knows no rival.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we believe that Qiskit and PennyLane are better choices than, for
    instance, **Q#** or **Cirq** (which, of course, are also great frameworks on their
    own). Regarding QuEST, it is true that the performance of the simulators provided
    by Qiskit and PennyLane may not be as good as the performance that QuEST would
    yield. But we should also take into account that QuEST is not nearly as user-friendly
    as Qiskit or PennyLane, and it lacks many of their features; for instance, QuEST
    does not have any built-in tools or interfaces for training quantum machine learning
    models. In any case, we should remark that while running circuits on the simulators
    bundled in Qiskit and PennyLane may not be as efficient as running them in QuEST,
    for our purposes, the performance that we can get with them is more than good
    enough! Nevertheless, if you are still eager to get the performance boost that
    QuEST could give you, you should know that there is a community plugin that allows
    PennyLane to work with the QuEST simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have chosen Ocean because it is completely unique in that it probably
    is the only software package that lets you work with **quantum** **annealers**,
    both to define problems and to run them on actual quantum hardware. It is also
    very easy to learn…at least once you understand how to define combinatorial optimization
    problems in the **Ising** and QUBO models. But don’t worry; we will extensively
    study those frameworks in *Chapter* *[*3*](ch011.xhtml#x1-590003), *QUBO:* *Quadratic
    Unconstrained Binary Optimization*, and, by *Chapter* *[*4*](ch012.xhtml#x1-750004),
    *Quantum* *Adiabatic Computing and Quantum Annealing*, we will be more than ready
    to write our very first programs using Ocean.**
  prefs: []
  type: TYPE_NORMAL
- en: '**At this point, we have a good global understanding of the current landscape
    of tools for quantum computing. In the upcoming sections, we will take our first
    steps in using them, and we shall begin with Qiskit.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Working with Qiskit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to work with the Qiskit framework. We will
    first discuss the general structure of Qiskit, and then we will study how to implement
    quantum circuits in Qiskit using quantum gates and measurements. Then, we will
    explore how to run these circuits using the simulators provided by Qiksit and
    also real quantum computers available for free thanks to IBM. This section is
    key, for we will use Qiskit extensively in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing is a rapidly-evolving field…and so are its software frameworks!
    We are going to work with **version 0.39.2** of Qiskit. Keep in mind that, if
    you are using a different version, things may have changed. In case of doubt,
    you should always refer to the documentation ([https://qiskit.org/documentation/](https://qiskit.org/documentation/)).
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1 An overview of the Qiskit framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Qiskit framework [[102](ch030.xhtml#XQiskit)] consists of the components
    depicted in *Figure* [*2.1*](#Figure2.1). At the very foundation of Qiskit lies
    **Qiskit Terra**. This package is responsible for handling quantum circuits and
    providing the necessary tools for constructing them. It also includes a basic
    Python-based simulator (**BasicAer**) and it can work with the **IBM Quantum provider**
    to execute circuits on IBM’s quantum hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Components of the Qiskit framework](img/file286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.1**: Components of the Qiskit framework'
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit Aer is built on top of Qiskit Terra, and it provides a suite of high-performance
    quantum simulators written in **C++** and designed to use hardware resources more
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of Qiskit Aer and Terra as the core of the Qiskit framework; they
    are included when you do a simple installation of Qiskit. In addition to these
    components, however, there are still a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Qiskit Machine Learning** implements some well-known quantum machine learning
    algorithms that are suitable for **NISQ** devices. We will extensively work with
    this package in *Part* *[*III*](ch016.xhtml#x1-138000III), *A Match Made in* *Heaven:
    Quantum Machine Learning*, of this book. This package also provides an optional
    interface with **PyTorch** that can be utilized in the training of quantum machine
    learning models.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   **Qiskit Optimization** implements some quantum optimization algorithms.
    We will work with them in *Part* *[*II*](ch010.xhtml#x1-58000II), *When Time is
    Gold:* *Tools for Quantum Optimization*, of this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**   This book focuses on quantum machine learning and quantum optimization,
    but quantum computing has more exciting applications in other specific fields.
    Two good examples are the natural sciences, in particular, quantum physics and
    chemistry, and finance. You can find some algorithms related to problems in these
    fields in the **Qiskit** **Nature** and **Qiskit Finance** packages. As an interesting
    fact, you should know that the possibility of doing more efficient computations
    for quantum-mechanical systems was one of the initial motivations for exploring
    the idea of quantum computing in the first place. We will briefly explore some
    of these applications in *Chapter* *[*7*](ch015.xhtml#x1-1190007), *VQE:* *Variational
    Quantum Eigensolver*.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**   **Qiskit Experiments** provides a range of tools for working with noisy
    quantum computers, that is, current quantum devices that are subject to different
    types of errors and external noise, to characterize, benchmark, and calibrate
    them.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lastly, **Qiskit Metal** and **Qiskit Dynamics** are the most recent additions
    to Qiskit. Qiskit Metal can be used to design real quantum devices, while Qiskit
    Dynamics provides tools to work with models of quantum systems.***
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exercise 2.1'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the instructions in *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing
    the Tools*, to do a full installation of **version 0.39.2** of the Qiskit package.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Once you have installed Qiskit, you can load it in Python running `import`
    `qiskit`. If you want to check the version of Qiskit that you are running, you
    might be tempted to look for it in `qiskit``.``__version__`, but that would give
    you the version of the Qiskit Terra package, not that of Qiskit itself! If you
    want to find the version of the Qiskit framework, you will have to access `qiskit``.``__qiskit_version__`.
    That will give you a dictionary with the versions of all the components of Qiskit
    (including Qiskit itself). Hence, the version of Qiskit will be `qiskit``.``__qiskit_version__``[``’``qiskit``’``]`.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit is updated quite frequently. To stay up to date with the new features,
    we recommend you visit [https://qiskit.org/documentation/release_notes.html](https://qiskit.org/documentation/release_notes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are all set up, it is time for us to build some circuits with our
    feet on the Terra!
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2 Using Qiskit Terra to build quantum circuits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to get started, let us, first of all, import Qiskit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice how in the preceding subsection we imported Qiskit with `import` `qiskit`
    to be able to check its version number. For the remainder of this chapter, we
    will assume that Qiskit has been imported as `from` `qiskit` `import` `*`.
  prefs: []
  type: TYPE_NORMAL
- en: We will now explore how to implement quantum algorithms (in the form of quantum
    circuits) using Qiskit.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing circuits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Qiskit, circuits are represented as objects of the `QuantumCircuit` class.
    When we initialize such an object, we may give some optional arguments depending
    on how many qubits and bits we want our circuit to have. For example, if we want
    our circuit to have `n` qubits, we may invoke `QuantumCircuit``(``n``)`. If we
    also want it to have `m` classical bits to store the results of measuring our
    qubits, we can run `QuantumCircuit``(``n``,` `m``)`. Once we have a quantum circuit
    object, we can get an ASCII representation of it in the terminal by calling the
    `draw` method. For instance, if we executed `QuantumCircuit``(2,2).``draw``()`,
    we would get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, in this representation we can only see the names of the qubits and
    the bits that we have created, for that is all that we have in our circuit so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: These ASCII representations are fine, but we can all agree that they are not
    necessarily very stylish. If you want to get something more fancy, you can pass
    the optional argument `’``mpl``’` (short for **matplotlib**) to `draw`. Keep in
    mind that, if you use Python on your terminal rather than in a **Jupyter notebook**
    (old school for the win!), you might also have to use `draw``(``’``mpl``’``,`
    `interactive` `=` `True``)`. However, this might not work if your environment
    doesn’t support graphical user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qubits and classical bits in Qiskit are grouped in quantum and classical **registers**.
    By default, when you create a circuit `QuantumCircuit``(``n``,` `m``)`, Qiskit
    groups your qubits in a quantum register `q` and your bits in a classical register
    `c`. You may however want to have a different arrangement of registers or you
    may want to give them different names. In order to do this, you can create your
    own registers, which will be objects of the `QuantumRegister` and `ClassicalRegister`
    classes. When initializing these registers, you are free to specify some `size`
    and `name` parameters. Once you have created some quantum and classical registers
    `reg_1`,…,`reg_n`, you can stack them in a circuit with a call of the form `QuantumCircuit``(``reg_1``,...,``reg_n``)`.
    In this way, we could execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And we would get the following result if we ran `qc``.``draw``()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Quantum gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have a circuit with a bunch of qubits — not a bad way to get started!
    By default, all those qubits will be initialized to a state, ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"), but, of course, if we want to get some computing done,
    we better be able to bring some quantum gates to the table.
  prefs: []
  type: TYPE_NORMAL
- en: The way you add quantum gates to a circuit `qc` is by executing methods of that
    circuit. For instance, if you want to apply an ![X](img/file9.png "X") gate on
    the first qubit of the circuit `qc`, you can just run `qc``.``x``(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case in Python, quantum bits in a circuit are 0-indexed! This
    means that the first qubit will be labeled as 0, the second as 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When we have different quantum registers in a circuit, we can still refer to
    qubits by their indices. The qubits of the first register that we added will have
    the first indices, the subsequent indices will correspond to the qubits of the
    second register, and so on and so forth. Classical registers and quantum registers
    are fully independent in this matter.
  prefs: []
  type: TYPE_NORMAL
- en: This, however, can be somewhat inconvenient if we have many registers, but don’t
    worry, Qiskit has got you covered. While referring to gates by their index can
    be convenient, we can also refer to them directly! Let us say that we have a setup
    like the previous one, with the circuit `qc` with quantum registers `qreg1` and
    `qreg2`. Running `qc``.``x``(2)` would have the same effect as executing `qc``.``x``(``qreg2``[0])`.
    Moreover, if we called `qc``.``x``(``qreg1``)`, that would be the same as applying
    both `qc``.``x``(0)` and `qc``.``x``(1)` one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the Qiskit methods for applying some of the most common one-qubit
    gates (the ones that we studied in *Sections* *[*1.3.3*](ch008.xhtml#x1-240001.3.3)
    and *[*1.3.4*](ch008.xhtml#x1-250001.3.4)) on a qubit `q0`:**
  prefs: []
  type: TYPE_NORMAL
- en: '***   In order to apply one of the Pauli gates, ![X](img/file9.png "X"), ![Y](img/file11.png
    "Y"), or ![Z](img/file8.png "Z"), we can call `x``(``q0``)`, `y``(``q0``)`, or
    `z``(``q0` `)` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The method `h``(``q0` `)` can be used to apply a Hadamard gate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can apply rotation gates ![R_{X}](img/file118.png "R_{X}"), ![R_{Y}](img/file119.png
    "R_{Y}"), or ![R_{Z}](img/file120.png "R_{Z}") parametrized by `theta` with the
    `rx``(``theta``,``q0``)`, `ry``(``theta``,``q0``)`, or `rz``(``theta``,``q0` `)`
    methods respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can apply the universal one-qubit gate ![U(\theta,\varphi,\lambda)](img/file287.png
    "U(\theta,\varphi,\lambda)") parametrized by `theta`, `phi`, and `lambd` as `u``(``theta``,`
    `phi``,` `lambd``,` `q0` `)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, we also have methods for multi-qubit gates. Most notably, a controlled
    ![X](img/file9.png "X"), ![Y](img/file11.png "Y"), ![Z](img/file8.png "Z"), or
    ![H](img/file10.png "H") gate with control qubit `q0` on a target `qt` can be
    applied with the `cx``(``q0``,` `qt``)`, `cy``(``q0``,` `qt``)`, `cz``(``q0``,`
    `qt``)`, and `ch``(``q0``,` `qt``)` methods respectively. In full analogy, a controlled
    rotation gate ![R_{X}](img/file118.png "R_{X}"), ![R_{Y}](img/file119.png "R_{Y}"),
    or ![R_{Z}](img/file120.png "R_{Z}") parametrized by a value `theta` can be added
    with the `crx``(``theta``,` `q0``,` `qt``)`, `cry``(``theta``,` `q0``,` `qt``)`,
    and `crz``(``theta``,` `q0``,` `qt``)` methods, where, as before, `q0` represents
    the control qubit and `qt` the target one.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the controlled ![X](img/file9.png "X") gate is the famous **CNOT**.
    We love entangling qubits, so we will certainly be using that `cx` method a lot!
  prefs: []
  type: TYPE_NORMAL
- en: '![(a)](img/file288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**(a)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![(b)](img/file289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**(b)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 2.2**: Sample quantum circuits that we can construct in Qiskit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now might be a good moment to step back for a second and see all that we have
    done come alive. For example, let us try to construct the circuit depicted in
    *Figure* [*2.2a*](#Figure2.2a). Using all that we have learned, we could implement
    this circuit in Qiskit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And now if we run `qc``.``draw``(``"``mpl``"``)` to verify that our implementation
    is correct, we will get the output shown in *Figure* [*2.3*](#Figure2.3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Qiskit output for the circuit in Figure 2.2a.](img/file290.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.3**: Qiskit output for the circuit in *Figure* [*2.2a*](#Figure2.2a)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.2
  prefs: []
  type: TYPE_NORMAL
- en: Construct the circuit in *Figure* [*2.2b*](#Figure2.2b). Draw the result and
    use the output to verify whether your circuit implementation is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Measurements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now know how to add quantum gates to a circuit, so there is only one ingredient
    that we are missing: measurement operators. It turns out that this couldn’t be
    easier. If you want to perform a measurement (in the computational basis) at any
    point in a circuit, you can do so by calling the `measure``(``qbits``,``bits``)`
    method, where `qbits` should be a list with all the qubits that you want to measure
    and `bits` should be a list with all the classical bits on which you want the
    measurements to be stored. Of course, the lists must be of the same length.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to measure all the qubits and do not want to bother with creating
    a classical register of the appropriate size, you can just call the `measure_all`
    method. This will add as many bits to your circuit as qubits it has, and it will
    measure each qubit and send the results to these bits. If you have already added
    classical bits to store the measurement results, you can still use them with the
    `measure_all` method: all you have to do is set the `add_bits` parameter to `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.3
  prefs: []
  type: TYPE_NORMAL
- en: Implement your own version of the `measure_all` method. You may need to use
    the `add_register` method of the `QuantumCircuit` class, which takes some register
    objects as arguments and appends them to the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: So now we can construct our own quantum circuits, but we still need to find
    a way to run them using Qiskit. We will do that in the next subsection. Let’s
    fly in the Aer!
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.3 Using Qiskit Aer to simulate quantum circuits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned when we introduced the `Qiskit` framework, the `Terra` package
    includes a Python-based simulator, **BasicAer**. While this simulator is good
    enough for most basic tasks, it is largely out-powered by the simulators included
    in the `Aer` package, so we will only discuss these here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use the Aer simulator, it will not suffice to import Qiskit.
    This time, we will also have to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have done the necessary imports, we can create an Aer simulator object
    in one of the following ways, depending on whether or not we have configured our
    system to use a GPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you have a GPU and have configured your Qiskit installation properly (see
    *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing the Tools*, for some instructions),
    using the GPU-powered simulator will yield much better results for demanding simulation
    tasks. Nevertheless, you should keep in mind that for less resource-intensive
    simulations, using the GPU may actually lead to worse performance because of the
    communication overhead. For the remainder of this section, we will use the simulator
    without a GPU. If we were to use `sim_GPU`, everything would be fully analogous.*
  prefs: []
  type: TYPE_NORMAL
- en: '*To learn more…'
  prefs: []
  type: TYPE_NORMAL
- en: To simulate circuits using a GPU, you will need the `qiskit``-``aer``-` `gpu`
    package. This package is written using CUDA. For this reason, it only supports
    NVIDIA GPUs.
  prefs: []
  type: TYPE_NORMAL
- en: As we already know, when we measure a quantum state the result is probabilistic.
    For that reason, we usually run several executions or **shots** of a given circuit
    and then compute some statistics on the results. If we wanted to simulate the
    execution of `nshots` shots of a circuit `qc`, we would have to run `job` `=`
    `execute``(``qc``,` `sim``,` `shots` `=` `nshots``)`, and we could retrieve a
    *result* object by calling `result` `=` `job``.``result``()`; by the way, the
    default value for `shots` is `1024`. With this result object, we could get the
    simulated frequency counts using `result``.``get_counts``()`, which would give
    us a dictionary with the absolute frequencies of each outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to make this more clear with an example. We will consider a very
    simple two-qubit circuit with a single Hadamard gate in the top qubit. We will
    then measure both qubits in the circuit and simulate ![1024](img/file291.png "1024")
    shots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: If you have a job running, in an object called `job`, and you want to check
    its status, you can import `job_monitor` from `qiskit``.``providers``.``ibmq``.``job`
    and run `job_monitor``(``job` `)`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When getting results for measurements in Qiskit, you need to keep in mind that
    the top qubit becomes the least significant bit, and so on. This is, if you have
    two qubits and, when measured, the top one (qubit ![0](img/file12.png "0")) has
    value ![0](img/file12.png "0") and the bottom one (qubit ![1](img/file13.png "1"))
    has value ![1](img/file13.png "1"), the result will be interpreted as `10`, not
    as `01`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the opposite of what we have been doing so far — and also the opposite
    of what most of the world agrees on. Thus, what we call state ![10](img/file161.png
    "10"), Qiskit will call `01`.
  prefs: []
  type: TYPE_NORMAL
- en: For most practical purposes, we can simply ignore this issue and assume that
    when we have to access qubit ![q](img/file292.png "q") in a circuit with ![n](img/file244.png
    "n") qubits, we need to use the index ![n - q - 1](img/file293.png "n - q - 1")
    (remember that we start counting qubits at ![0](img/file12.png "0")). This is
    what we will do implicitly when we use Qiskit in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theoretically, we know that the state before the measurement is ![\sqrt{\left.
    1\slash 2 \right.}(\left| {00} \right\rangle + \left| {10} \right\rangle)](img/file204.png
    "\sqrt{\left. 1\slash 2 \right.}(\left| {00} \right\rangle + \left| {10} \right\rangle)"),
    so we would expect an even distribution of frequencies for the (Qiskit) outcomes
    ![01](img/file159.png "01") and ![00](img/file157.png "00"), and we should not
    see any occurrences of other results. Indeed, when we ran the code, we got the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Needless to say, you will not get the same results! But you will certainly get
    something with the same flavor.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, in the preceding measurement, we have labeled as ![10](img/file161.png
    "10") the state with ![1](img/file13.png "1") in the first qubit (qubit ![0](img/file12.png
    "0")) (which is consistent with the notation that we have been using). Nonetheless,
    Qiskit, being consistent with its own notation, has labeled its corresponding
    outcome as ![01](img/file159.png "01").
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to obtain reproducible results when executing circuits in Qiskit,
    you need to use two parameters of the `execute` function: `seed_transpiler` and
    `seed_simulator`. They are used to set the initial values for the pseudo-random
    number generators that are used in the process of transpiling the circuit — we
    will talk about this later in this section — and when sampling from the results
    of the measurements. If you use some fixed seeds, you will always get the same
    results. This can be useful, for instance, for debugging purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these numbers are good, but we all know that a picture is worth a thousand
    words. Thankfully, the folks at IBM agree, and they have been thoughtful enough
    to bundle some fancy visualization tools right into Qiskit. For instance, we could
    run these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And we would get the plot shown in *Figure* [*2.4*](#Figure2.4). This function
    admits the optional argument `filename`, which, if provided, will lead to the
    figure being saved with the given string as the filename.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Histogram generated by Qiskit](img/file294.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.4**: Histogram generated by Qiskit'
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting fact, you should know that the Aer simulator can simulate
    the execution of circuits using different methods. Nevertheless, unless we ask
    otherwise, our circuits will always be simulated using the **statevector** method,
    which — as the name suggests — computes the exact quantum state (or state vector)
    of the system through the circuit in order to generate results.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the simulator does compute the quantum state of the system, why settle
    for some simulated samples when we could be getting the actual state? Of course,
    the state of a circuit is something we don’t have access to when working with
    real quantum computers (we can only obtain results by performing measurements),
    but, hey, simulating circuits should have its own perks too!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to access the state vector at any point in a quantum circuit `qc`,
    all we have to do is call `qc``.``save_statevector``()`, just as if we were adding
    another gate. Then, once the circuit has been simulated and we have gotten our
    results from the execution job, we can get the state vector using the `get_statevector`
    method, just as we would use `get_counts`. Actually, if our circuit also has measurements,
    we could do both at the same time. For instance, we can consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how, in this piece of code, we have measured the two qubits in the circuit
    using two individual instructions instead of just calling `qc``.``measure``(``range``(2),`
    `range``(2)`. When we run that, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That is exactly what we should have expected. We just need to remember that
    ![\left. 1\slash\sqrt{2} \approx 0.7071\ldots \right.](img/file295.png "\left.
    1\slash\sqrt{2} \approx 0.7071\ldots \right.")! In the output given by Qiskit,
    the first element of the state vector array is the amplitude of the basis state
    ![\left| {00} \right\rangle](img/file198.png "\left| {00} \right\rangle"), the
    second element is the amplitude of ![\left| {10} \right\rangle](img/file200.png
    "\left| {10} \right\rangle") (remember the Qiskit convention for naming basis
    states, so for Qiskit, the label of this state would be `01`), and the following
    ones are the amplitudes of ![\left| {01} \right\rangle](img/file199.png "\left|
    {01} \right\rangle") and ![\left| {11} \right\rangle](img/file201.png "\left|
    {11} \right\rangle") respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to save multiple state vectors in order to retrieve them later.
    For this, one needs to pass the optional argument `label` to `save_statevector`,
    specifying a label that uniquely identifies the state vector in the circuit. Then,
    the state vectors can be extracted as a dictionary from the results object `result`
    using `result``.``data` `()`.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility that the Aer simulator offers us is computing the unitary
    matrix that would represent, up to any given point, the transformations that have
    been performed by the circuit. In order to get this matrix, we could use the `save_unitary`
    and `get_unitary` methods, which would work in full analogy to `save_statevector`
    and `get_statevector`. As wonderful as this may seem, there is a small caveat,
    which is that these matrices cannot be computed with the statevector method; instead,
    one needs to use the **unitary** method, which does not support measurements and
    does not allow access to the state vector of the circuit. In any case, this is
    not a big deal, for one can always combine different methods of simulation provided
    the simulated circuits are tweaked accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let us run the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this code, this is the output that we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That is, just as it should be, the matrix of the Hadamard gate.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, by the way, how we have used the optional argument `decimals` to limit
    the precision of the output. This can also be used in the `get_statevector` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now able to use Qiskit to construct and simulate circuits, but there’s
    something we are missing: how to actually run them on real quantum hardware. That’s
    what the next subsection is all about.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.2.4 Let’s get real: using IBM Quantum'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we know how to use the tools provided by Qiskit Aer in order to perform
    ideal simulations of quantum circuits, but we know that real quantum computers,
    even if with limitations, exist and are actually accessible, so why not give them
    a shot (pun intended)?
  prefs: []
  type: TYPE_NORMAL
- en: IBM provides, for free, access to some of its real quantum computers. In order
    to gain access, all you have to do is sign up for a free IBM ID account. With
    it, you can log into the IBM Quantum website ([https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/))
    and get your API token (refer to *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing
    the Tools*, for more details).*
  prefs: []
  type: TYPE_NORMAL
- en: '*Once you have your token, the next thing you should do is head to your local
    environment and execute the instruction `IBMQ``.``save_account``(``"``TOKEN``"``)`,
    where, of course, you should replace `TOKEN` with your actual token. With that
    out of the way, we may run the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to load our account details and get a list of all the available
    real quantum devices. If you have an ordinary free account, you could expect to
    get something like this as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we used the argument `simulator` `=` `True`, we would get a list of all the
    available cloud simulators. Their main advantage is that some of them are capable
    of running circuits with many more qubits than an ordinary computer can handle.
  prefs: []
  type: TYPE_NORMAL
- en: A naive way of picking any of these providers would be just choosing one element
    in the list, for instance, taking `dev` `=` `provider``.``backends``(``simulator`
    `=` `False``)[0]`. Alternatively, if you knew the name of the device that you
    want to use (let it be `ibmq_lima`, for instance), you could simply run `dev`
    `=` `provider``.``get_backend``(``’``ibmq_lima``’``)`. Once you have chosen a
    device, that is, a backend object, you can get some of its configuration details
    by calling the `configuration` method (with no arguments). This will return an
    object with information about the device. For instance, in order to know how many
    qubits a provider `dev` has, we could just access `dev``.``configuration``().``n_qubits`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, rather than picking a device at random or by a fancy location
    name, we can try to do some filtering first. When calling `get_backend`, we can
    pass an optional `filters` parameter. This should be a one-argument function that
    would only return `True` for the devices that we want to pick. For instance, if
    we wanted to get a list of all the real devices with at least ![5](img/file296.png
    "5") qubits, we could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Out of all of these devices, maybe it is wise to just use the one that is the
    least busy. For this, we can simply execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: The `least_busy` accepts an optional parameter called `reservation_lookahead`.
    This is the number of minutes for which a device needs to be free of reservations
    to be considered as a candidate for being the least busy one. The default value
    of the parameter is ![60](img/file297.png "60"). So if it ever happens to you
    that `least_busy` does not return a suitable device, you may set `reservation_lookahead``=`
    `None` to also consider computers that are under reservation.
  prefs: []
  type: TYPE_NORMAL
- en: And now, running a circuit on the device that we have selected with a certain
    number of shots will be completely analogous to running it on a simulator. Actually,
    we can run it on both and compare the results!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It will probably take a while to get the results (you will get status updates
    thanks to the `job_monitor``(``job``)` instruction). In fact, sometimes, you can
    experience quite long waiting times because many users are submitting jobs at
    the same time. But with a little bit of patience, the results will eventually
    come! Once the execution has finished, we can print the results, and we could
    get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That is close, but far from ideal! We can see how in the execution on real hardware,
    we get some outputs — namely, `10` and 01 — that should not even be allowed in
    the first place. This is the effect of the **noise** of real quantum computers,
    which makes them deviate from perfect mathematical simulations.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have only worked with ideal simulations. You can also perform noisy
    simulations in Qiskit, which can more faithfully resemble the behavior of the
    quantum computers that are at our disposal today. Moreover, you could configure
    these simulations to use the same noise parameters as those measured in the real
    quantum devices owned by IBM. We will learn how to do this in *Chapter* *[*7*](ch015.xhtml#x1-1190007),
    *VQE: Variational Quantum Eigensolver*.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Important note'
  prefs: []
  type: TYPE_NORMAL
- en: When executing quantum circuits on actual quantum hardware, you have to be aware
    of the fact that real quantum systems only implement certain gates, and thus some
    of the gates that make up the circuit may have to be decomposed using the gates
    available. For instance, it is typical to decompose multi-qubit gates into qubits
    that act on just one or two qubits or to simulate CNOT gates between qubits that
    are not directly connected in the quantum computer by first swapping the qubits,
    then applying an actually existing CNOT gate, and then swapping back the qubits.
  prefs: []
  type: TYPE_NORMAL
- en: This process is called **transpilation**, and, using the code that we have considered,
    we have let Qiskit take care of all its details automatically. However, it is
    possible to dive deeper into this and to hack it as much as one could want! For
    instance, you can use the `transpile` method to manually define a transpilation,
    specifying the gates that are present in the computer or the qubits that are actually
    connected, among other things. See the documentation at [https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html](https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we have gained a good understanding of the general structure
    of the Qiskit framework, we have learned how to implement circuits in it, and
    how to simulate them and run them on real hardware through IBM Quantum. In the
    following section, we will do the same for another very interesting framework:
    PennyLane. Let’s get to it!'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Working with PennyLane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of PennyLane [[103](ch030.xhtml#XPennyLane)] is more simple than
    that of Qiskit. PennyLane mainly consists of a core software package, which comes
    with all the features that you would expect: it allows you to implement quantum
    circuits, it comes with some wonderful built-in simulators, and it also allows
    you to train quantum machine learning models (both with native tools and with
    a **TensorFlow** interface).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this core package, PennyLane can be extended with a wide selection
    of plugins that provide interfaces to other quantum computing frameworks and platforms.
    At the time of writing, these include **Qiskit**, **Amazon Braket**, the **Microsoft
    QDK**, and **Cirq**, among many others that we have not mentioned in our introduction.
    In addition, there is a community plugin, **PyQuest**, that makes PennyLane interoperable
    with the QuEST simulator ([https://github.com/johannesjmeyer/pennylane-pyquest](https://github.com/johannesjmeyer/pennylane-pyquest)).
  prefs: []
  type: TYPE_NORMAL
- en: In short, with PennyLane, it’s not that you get the best of both worlds. You
    truly can get the best of any world!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We are going to work with **version 0.26** of PennyLane. If you are using a
    different version, some things may be different. If in doubt, you should always
    check the documentation ([https://pennylane.readthedocs.io/en/stable/](https://pennylane.readthedocs.io/en/stable/)).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.4
  prefs: []
  type: TYPE_NORMAL
- en: Follow the instructions in *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing
    the Tools*, to install **version 0.26** of PennyLane and its Qiskit plugin.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Once you have installed PennyLane, you can import it. Following the conventions
    set out in PennyLane’s documentation, we will do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After running this instruction, you can check which version of PennyLane you
    are running by printing the string `qml``.``__version__`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are all set up, let’s build our first circuit, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1 Circuit engineering 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way quantum circuits are built in PennyLane is fundamentally different to
    the way they are constructed in Qiskit.
  prefs: []
  type: TYPE_NORMAL
- en: In Qiskit, if we wanted to implement a quantum circuit, we would initialize
    a `QuantumCircuit` object and manipulate it with some methods; some of these methods
    would be used to add gates to the circuit, some to perform measurements, and some
    to specify where we wanted to extract information about the state of the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PennyLane, on the other hand, if you want to run a circuit, you need two
    elements: a `Device` object and a function that specifies the circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To put it in simple terms, a `Device` object is PennyLane’s virtual analog
    of a quantum device. It is an object with methods that allow it to run any circuit
    that it is given (through a simulator, through an interface with other platforms,
    or however it may be!). For example, if we have a circuit and we want to run it
    on the `default``.``qubit` simulator (more on that later in this section) using
    two qubits, we will need to use this device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice, by the way, how the number of qubits available is a property of the
    device object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a device, we need to define the specification of our circuit.
    As we mentioned earlier, that is as easy as defining a function. In this function,
    we will execute instructions that will correspond to the actions of the quantum
    gates that we want to use. Lastly, the output of the function will be whichever
    information we want to get out of the circuit — whether it be the state of the
    circuit, some measurement samples, or whatever it may be. Of course, the output
    that we can get will depend on the device that we are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us illustrate this with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a very basic circuit specification. In this circuit, we get the
    state vector (with `qml``.``state``()`), after we first apply an ![X](img/file9.png
    "X") gate on the first qubit and then an ![H](img/file10.png "H") gate on the
    first qubit too. We do this by calling, in sequence, `qml``.``PauliX` and `qml``.``Hadamard`,
    specifying the wires on which we want the gates to act. In most non-parametrized
    gates, `wires` is the first positional argument, and it does not have a default
    value, so you need to provide one. In the case of single-qubit gates, this value
    must be an integer representing the qubit on which the gate is meant to act. Analogously,
    for multi-qubit gates, `wires` must be a list of integers.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the naming conventions for gate classes in PennyLane
    differ from those for gate methods in Qiskit. The functions for the ![X](img/file9.png
    "X"), ![Y](img/file11.png "Y"), and ![Z](img/file8.png "Z") Pauli gates are, respectively,
    `qml``.``PauliX`, `qml``.``PauliY`, and `qml``.``PauliZ`. Also, as we have just
    seen, the function for the Hadamard gate is `qml``.``Hadamard`.
  prefs: []
  type: TYPE_NORMAL
- en: In regard to rotation gates, we can apply ![R_{X}](img/file118.png "R_{X}"),
    ![R_{Y}](img/file119.png "R_{Y}"), and ![R_{Z}](img/file120.png "R_{Z}") parametrized
    by `theta` on a wire `w` using the instructions `qml``.``RX``(``phi``=``theta``,`
    `wires``=``w``)`, `qml``.``RY``(``phi``=``theta``,` `wires``=``w``)`, and `qml``.``RZ``(``phi``=``theta``,`
    `wires``=``w``)` respectively. In addition, the universal single-qubit gate ![U(\theta,\varphi,\lambda)](img/file287.png
    "U(\theta,\varphi,\lambda)") can be applied on a wire `w` calling `qml``.``U3``(``theta``,`
    `phi``,` `lambd``,` `w``)`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the controlled Pauli gates can be applied on a pair of qubits `w` `=`
    `[``w0``,` `w1``]` using the instructions `qml``.``CNOT``(``w``)`, `qml``.``CY``(``w``)`
    and `qml``.``CZ``(``w``)`. The first wire, `w0`, is meant to be the control qubit,
    while the second one must be the target. Controlled ![X](img/file9.png "X"), ![Y](img/file11.png
    "Y"), and ![Z](img/file8.png "Z") rotations parametrized by an angle `theta` can
    be added with the instructions `qml``.``CRX``(``theta``,` `w``)`, `qml``.``CRY``(``theta``,`
    `w``)`, and `qml``.``CRZ``(``theta``,` `w``)` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, we now have a two-qubit device `dev` and we have a circuit function
    `qc`. How do we assemble these two together and run the circuit? Easy, all we
    have to do is execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we run this, we will get the following result,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: which makes perfect sense, for we know that
  prefs: []
  type: TYPE_NORMAL
- en: '| ![(HX \otimes I)\left&#124; {00} \right\rangle = (H \otimes I)\left&#124;
    {10} \right\rangle = \frac{1}{\sqrt{2}}\left( {\left&#124; {00} \right\rangle
    - \left&#124; {10} \right\rangle} \right) \approx (0.7071\ldots)\left( {\left&#124;
    {00} \right\rangle - \left&#124; {10} \right\rangle} \right).](img/file298.png
    "(HX \otimes I)\left&#124; {00} \right\rangle = (H \otimes I)\left&#124; {10}
    \right\rangle = \frac{1}{\sqrt{2}}\left( {\left&#124; {00} \right\rangle - \left&#124;
    {10} \right\rangle} \right) \approx (0.7071\ldots)\left( {\left&#124; {00} \right\rangle
    - \left&#124; {10} \right\rangle} \right).") |'
  prefs: []
  type: TYPE_TB
- en: As a fun fact, the result of assembling a circuit function and a device is known,
    in PennyLane jargon, as a **Quantum Node** (or **QNode**, for short).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'PennyLane, unlike Qiskit, labels state like most people do: assigning to the
    first qubit the most significant bit. Thus, a PennyLane output of `10` corresponds
    to the state ![\left| {10} \right\rangle](img/file200.png "\left| {10} \right\rangle").'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how, consistent with PennyLane’s convention for labeling states, the
    state vector is returned as a list with the amplitudes of the states in the computational
    basis. The first element corresponds to the amplitude state ![\left| {0\cdots
    0} \right\rangle](img/file299.png "\left| {0\cdots 0} \right\rangle"), the second
    one to that of ![\left| {0\cdots 01} \right\rangle](img/file300.png "\left| {0\cdots
    01} \right\rangle"), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we should remark that at no point in the definition
    of the function `qc` did we specify the number of qubits of the circuit — we left
    that to the device. When we create a QNode, PennyLane assumes that the device
    has enough qubits to execute the circuit specification. If that isn’t the case,
    we will encounter a `WireError` exception when executing the corresponding QNode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you — like most of us! — are lazy, all this process of defining a function
    and assembling it with a device might seem overwhelmingly exhausting. Thankfully,
    the folks at PennyLane were kind enough to provide a shortcut. If you have a device
    `dev` and want to define a circuit for it, you could just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that is much cuter! By placing the `@qml``.``qnode``(``dev``)` decorator
    before the definition of our circuit function, it automatically became a QNode
    without us having to do anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how circuits in PennyLane are implemented as simple functions,
    and this begs the question: are we allowed then to use parameters in these functions?
    The answer is a resounding yes. Let us say that we want to construct a one-qubit
    circuit, parametrized by a certain `theta`, which performs an ![X](img/file9.png
    "X")-rotation by this parameter. Doing so is as easy as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And, with this, for any value `theta` of our choice, we can run `qcirc``(``theta``)`
    and get our result. This way of handling parameters is very handy and convenient.
    Of course, you can use loops and conditionals dependent on circuit parameters
    within the definition of a circuit. The possibilities are endless!
  prefs: []
  type: TYPE_NORMAL
- en: 'If at any point you need to draw a circuit in PennyLane, that is not an issue:
    it is fairly straightforward. Once you have a quantum node `qcirc`, you can pass
    this node to the `qml``.``draw` function. This will itself return a function,
    `qml``.``draw``(``qcirc``)`, which will take the same arguments as `qcirc` and
    will give you a string that *draws* the circuit for each choice of those arguments.
    We may see this more clearly with an example. Let us execute the following piece
    of code to draw the `qcirc` circuit that we’ve just considered for ![\theta =
    2](img/file301.png "\theta = 2"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running that, we get the following representation of the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have only performed simulations that return the state vector of
    the circuit at the end of its executions, but, naturally, that is just one of
    the many options that PennyLane provides. These are some, but not all, of the
    return values that we can have in a circuit function:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to get the state of the circuit at the end of its execution, we can,
    as we have seen, return `qml``.``state` `()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we wish to get a list with the probabilities of each state in the computational
    basis of a list of wires `w`, we can return `qml``.``probs``(``wires` `=` `w``)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can get a sample of measurements in the computational basis of some wires
    `w` by returning `qml``.``sample``(``wires` `=` `w``)`; the `wires` argument is
    optional (if no value is provided, all qubits are measured). When we get a sample,
    we have to specify its size by either setting a `shots` argument when invoking
    the device or by setting it when calling the QNode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore some additional possibilities for return values in *Chapter*
    *[*10*](ch019.xhtml#x1-18100010), *Quantum Neural Networks*. We already know how
    to get the state of the circuit. In order to illustrate the other return values
    that we may use, let us execute the following piece of code:*
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE30]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output we got with this execution is the following (the samples returned
    in your case will probably be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There might be a bit to unpack here. So, first of all, we are returned a list
    of probabilities; these are, in accordance with PennyLane’s conventions, the probabilities
    of getting ![00](img/file157.png "00"), ![01](img/file159.png "01"), ![10](img/file161.png
    "10"), and ![11](img/file163.png "11"). In these possible outcomes, the first
    (leftmost) bit represents the outcome of the first measured qubit: in our case,
    since we are measuring wires `[1,` `2]`, the second wire of the circuit, wire
    ![1](img/file13.png "1"). The second (rightmost) bit represents the outcome of
    the second measured qubit: in our case, the third wire of the circuit. For example,
    the first number in the list of probabilities represents the probability of getting
    ![00](img/file157.png "00") (that is, ![0](img/file12.png "0") in both wires).
    The second number in the list would be the probability of getting ![01](img/file159.png
    "01") (![0](img/file12.png "0") in wire ![1](img/file13.png "1") and ![1](img/file13.png
    "1") in wire ![2](img/file302.png "2")). And so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the next two examples, we are getting some measurement samples. In
    the first case, we specify that we want to measure only the first qubit (wire
    ![0](img/file12.png "0")), and, when we call the QNode, we ask for ![4](img/file143.png
    "4") shots; since we hadn’t specified a default number of shots when defining
    the device, we need to do it in the execution. And with that, we have a sample
    of the first qubit. In our case, the results were first 0, then 1, and then two
    more zeros.
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, we define a two-qubit circuit and we measure all the wires.
    We already specified a default number of shots (![4](img/file143.png "4")) when
    we defined the device, so we don’t need to do it when calling the QNode. And,
    upon execution, we are given a sample of measurements. Each item in the list corresponds
    to a sample. Within each sample, the first element gives the result of measuring
    the first qubit of the circuit, the second element the result of measuring the
    second qubit, and so on it would go. For example, in our case, we see that in
    the first measurement we obtained ![1](img/file13.png "1") on the first qubit
    and ![0](img/file12.png "0") on the second one.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.5
  prefs: []
  type: TYPE_NORMAL
- en: Implement the circuits in *Figure* [*2.2*](#Figure2.2) and verify that you get
    the same state vector that we get when simulating with Qiskit Aer.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, as we have mentioned before, Qiskit and PennyLane use different
    conventions when naming basis states. Be careful with that!
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get reproducible results using PennyLane’s simulator, you can
    set a seed `s` using the instruction `np``.``random``.``seed``(``s` `)` after
    importing the `numpy` package as `np`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been working with devices based on the `default``.``qubit` simulator,
    which is a Python-based simulator with some basic functionalities. We will introduce
    more simulators when we dive into the world of quantum machine learning. For now,
    however, you should at least know about the existence of the `lightning``.``qubit`
    simulator, which relies on a C++ backend and provides a significant boost in performance,
    especially for circuits with a large number of qubits. Its usage is analogous
    to that of the `default``.``qubit` simulator. Furthermore, there is a `lightning``.``gpu`
    simulator that can enable the Lightning simulator to rely on your GPU. It can
    be installed as a plugin. As in the case of Qiskit, at the time of writing this
    book, it only supports NVIDIA GPUs (and mainly just quite modern ones!).
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2 PennyLane’s interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have mentioned plenty of times how one of PennyLane’s virtues is its ability
    to communicate with other quantum frameworks. We will now try to demonstrate this
    with PennyLane’s Qiskit interface. Parlez-vous Qiskit?
  prefs: []
  type: TYPE_NORMAL
- en: 'When you install the Qiskit plugin for PennyLane, you gain access to a new
    set of devices: most notably, a `qiskit``.``aer` device that allows you to use
    the Aer simulator directly from PennyLane, and a `qiskit``.``ibmq` device that
    enables you to run circuits on the real quantum computers available from IBM Quantum.'
  prefs: []
  type: TYPE_NORMAL
- en: Love is in the Aer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to simulate a circuit in PennyLane using Aer, all we have to do
    is use a device with the `qiskit``.``aer` simulator — and, of course, having installed
    the appropriate plugin (refer to *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing
    the Tools*). This will allow us to get measurement samples and also measurement
    probabilities (through `qml``.``sample` and `qml``.``probs` respectively). Actually,
    the measurement probabilities returned by these Aer devices are approximations
    of the exact probabilities: they are obtained by sampling and returning the empirical
    probabilities. By default, in an Aer device, the number of shots is fixed at ![1024](img/file291.png
    "1024"), following Qiskit’s conventions. Of course, the number of shots can be
    adjusted as with any other PennyLane device.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*We can see a `qiskit``.``aer` device in action with the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, we can get something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that, indeed, the result is not analytical, but empirical and extracted
    from a sample. If you want to obtain the state vector, you need to use the following
    instruction when creating the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to use `qml``.``state``()` to retrieve the state amplitudes,
    as we did with the PennyLane devices. Moreover, if you try to get probabilities
    using `qml``.``probs` with this device object, you will now get analytical results.
    For example, if you run the previous example on this device, you will always obtain
    `[0.5,` `0.5]`.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to IBMQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ability to (partially) use the Aer simulator is probably not the most appealing
    feature of PennyLane’s Qiskit interface. Nevertheless, being able to connect to
    IBM’s quantum computers is a more exciting possibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to connect to an IBM Quantum device, we will first load Qiskit and
    get the name of the least busy hardware backend, just as we did in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing the preceding code, we get our desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And that’s how you can send jobs to IBM Quantum using PennyLane!
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can use any quantum device that is accessible with your IBM account,
    not just the least busy one. You only need to replace the definition of the backend
    in the previous code with a direct specification of a particular computer as we
    did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: With this introduction to the workings of Qiskit and PennyLane and all the mathematical
    concepts that we studied in *Chapter* *[*1*](ch008.xhtml#x1-180001), *Foundations
    of Quantum* *Computing*, we are now ready to begin solving problems with actual
    quantum algorithms. And that is exactly what we will do, starting in the next
    chapter. Let the quantum games begin — and may the shots be ever in your favor!*
  prefs: []
  type: TYPE_NORMAL
- en: '*# Summary'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we have explored some of the frameworks and platforms that
    can enable us to implement, simulate, and run quantum algorithms. We have also
    learned how to work with two of these frameworks: Qiskit and PennyLane, which
    are very widely used. In addition to this, we have learned how to use the IBM
    Quantum platform to execute quantum circuits on real hardware, sending them from
    either Qiskit or PennyLane.'
  prefs: []
  type: TYPE_NORMAL
- en: With the skills that you have gained in this chapter, you are now able to implement
    and execute your own circuits. Moreover, you are now well-prepared to read the
    rest of the book, since we will be using Qiskit and PennyLane extensively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our first steps in putting all this knowledge
    into practice. We shall dive into the world of quantum optimization!*****************
  prefs: []
  type: TYPE_NORMAL
