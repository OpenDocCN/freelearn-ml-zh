- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extracting Features from Date and Time Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Date and time variables contain information about dates, times, or both, and
    in programming, we refer to them collectively as `datetime` features. Date of
    birth, the time of an event, and the date and time of the last payment are examples
    of `datetime` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Because of their nature, `datetime` features typically exhibit high cardinality.
    This means that they contain a huge number of unique values, each corresponding
    to a specific date and/or time combination. We don’t normally use `datetime` variables
    for machine learning models in their raw format. Instead, we enrich the dataset
    by extracting multiple features from these variables. These new features will
    typically have reduced cardinality, and allow us to capture meaningful information,
    such as trends, seasonality, and important events and tendencies.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how to extract features from dates and time
    by utilizing the `pandas` `dt` module, and then automate this procedure with `feature-engine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting features from dates with `pandas`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting features from time with `pandas`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing elapsed time between `datetime` variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with time in different time zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating `datetime` feature extraction with `feature-engine`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use the `pandas`, `numpy`, and `feature-engine` Python
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting features from dates with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The values of `datetime` variables can be dates, time, or both. We’ll begin
    by focusing on those variables that contain dates. We rarely use raw dates with
    machine learning algorithms. Instead, we extract simpler features, such as the
    year, month, or day of the week, that allow us to capture insights such as seasonality,
    periodicity, and trends.
  prefs: []
  type: TYPE_NORMAL
- en: The `pandas` Python library is great for working with date and time. Utilizing
    the `pandas` `dt` module, we can access the `datetime` properties of a `pandas`
    Series to extract many features. However, to leverage this functionality, the
    variables need to be cast into a data type that supports these operations, such
    as `datetime` or `timedelta`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `datetime` variables can be cast as objects, particularly when we load the
    data from a CSV file. To extract the date and time features that we will discuss
    throughout this chapter, it is necessary to recast the variables as `datetime`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to extract features from dates by utilizing
    `pandas`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the features that we can extract from the `date`
    part of the `datetime` variable off the shelf using `pandas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.year`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.quarter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.month`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.isocalendar().week`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.day`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.day_of_week`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.weekday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.dayofyear`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.day_of_year`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the features we’ve obtained with `pandas` to create even more features,
    such as the semester or whether it is a weekend. We will learn how to do this
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To proceed with the recipe, let’s import `pandas` and `numpy`, and create a
    sample DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll start by creating 20 `datetime` values beginning from `2024-05-17` at
    midnight and followed by increments of 1 day. Then, we’ll capture those values
    in a `DataFrame` instance and display the top five rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following output, we see the variable containing dates that we created
    in *Step 2*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Top rows of a DataFrame with a datetime variable containing
    only dates](img/B22396_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Top rows of a DataFrame with a datetime variable containing only
    dates
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can check the data format of the variable by executing `data["date"].dtypes`.
    If the variable is cast as an object, we can convert it into `datetime` format
    by executing `data["date_dt"] =` `pd.to_datetime(data["date"])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract the year part of the date in a new column and display the top
    five rows of the resulting DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the new `year` variable in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.2 – First five rows of the DataFrame with the year variable extracted
    from the date](img/B22396_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – First five rows of the DataFrame with the year variable extracted
    from the date
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract the quarter of the year out of the date into a new column and
    display the top five rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the new `quarter` variable in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The first five rows of a DataFrame with the quarter variable
    extracted from the date](img/B22396_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The first five rows of a DataFrame with the quarter variable extracted
    from the date
  prefs: []
  type: TYPE_NORMAL
- en: 'With `quarter`, we can now create the `semester` feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can explore the distinct values of the new variables utilizing `pandas`’
    `unique()`, for example, by executing `df["quarter"].unique()` or `df["semester"].unique()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract the `month` part of the date in a new column and display the
    top five rows of the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the new `month` variable in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 6.4 – The first five rows of a DataFrame with the new month vari\uFEFF\
    able](img/B22396_06_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The first five rows of a DataFrame with the new month variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract the week number (a year has 52 weeks) from the date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the `week` variable in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The first five rows of a DataFrame with the new week variable](img/B22396_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The first five rows of a DataFrame with the new week variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract the day of the month, which can take values between `1` and `31`,
    into a new column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the `day_mo` variable in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 6.6 – The top rows of a DataFrame with the new variable capturing\
    \ the day of the \uFEFFmonth](img/B22396_06_6.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The top rows of a DataFrame with the new variable capturing the
    day of the month
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract the day of the week, with values between `0` and `6` (from Monday
    to Sunday), in a new column, then display the top rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the `day_week` variable in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The top rows of a DataFrame with a new variable representing
    days of a week](img/B22396_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The top rows of a DataFrame with a new variable representing days
    of a week
  prefs: []
  type: TYPE_NORMAL
- en: 'With the variable from *Step 9*, we can create a binary variable that indicates
    whether it was a weekend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the new `is_weekend` variable in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The first five rows of a DataFrame with the new is_weekend variable](img/B22396_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The first five rows of a DataFrame with the new is_weekend variable
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can automate the extraction of all these features by using `feature-engine`.
    Check out the *Automating datetime feature extraction with feature-engine* recipe
    in this chapter for more details.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have extracted many new features from the date part of a `datetime`
    variable using `pandas`. These features are useful for data analysis, visualization,
    and predictive modelling.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we extracted many date-related features from a `datetime` variable
    by using the `dt` module from `pandas`. First, we created a sample DataFrame with
    a variable that contained dates. We used `pandas`’ `date_range()` to create a
    range of values starting from an arbitrary date and increasing the time by intervals
    of `1` day. With the `periods` argument, we indicated the number of values to
    create in the range – that is, the number of dates. With the `freq` argument,
    we indicated the size of the steps between the dates. We used `D` for days in
    our example. Finally, we transformed the date range into a DataFrame with `pandas`
    `DataFrame()`.
  prefs: []
  type: TYPE_NORMAL
- en: To extract the different parts of a date, we used `pandas`’ `dt` to access the
    `datetime` properties of a `pandas` Series and then utilized the different properties.
    We used `year`, `month`, and `quarter` to capture the year, month, and quarter
    into new columns of the DataFrame. To find the semester, we created a Boolean
    using NumPy’s `where()` in combination with the newly created `quarter` variable.
    NumPy’s `where()` scanned the values of the `quarter` variable; if they were smaller
    than `3`, it returned the value of `1` for the first semester; otherwise, it returned
    the value of `2`, corresponding to the second semester.
  prefs: []
  type: TYPE_NORMAL
- en: To extract the different representations of days and weeks, we used the `isocalender().week`,
    `day`, and `dayofweek` properties. With the day of the week, we went ahead and
    created a binary variable to indicate whether it was a weekend. We used `where()`
    to scan the day of the week, and if the value was greater than `4`, which corresponds
    to Saturday and Sunday, the function returned `True` and otherwise `False`. Finally,
    we cast this Boolean vector as an integer to have a binary variable with 1s and
    0s. With that, we created multiple features from dates that we can use for data
    analysis and predictive modelling.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `pandas`’ `dt` module, we can extract many more features from dates out
    of the box. For example, we can extract the beginning and end of a month, quarter,
    or year, whether it is a leap year, and the number of days in a month. These are
    the functions that allow you to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.is_month_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.is_month_end`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.is_quarter_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.is_quarter_end`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.is_year_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.is_year_end`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.is_leap_year`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.days_in_month`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also return the number of days in a specific month with `pd.dt.days_in_month`
    and the day in a year (from `1` to `365`) with `pd.dt.dayofyear`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details, visit the `pandas`’ `datetime` documentation: [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn how to create different `datetime` ranges with `pandas`’ `date_ranges()`,
    visit [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases).
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about `pandas`’ `dt`, visit [https://pandas.pydata.org/pandas-docs/stable/reference/series.html#datetime-properties](https://pandas.pydata.org/pandas-docs/stable/reference/series.html#datetime-properties).
  prefs: []
  type: TYPE_NORMAL
- en: Extracting features from time with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some events occur more often at certain times of the day – for example, fraudulent
    activity is more likely to occur during the night or early morning. Air pollutant
    concentration also changes with the time of the day, with peaks at rush hour when
    there are more vehicles on the streets. Therefore, deriving time features is extremely
    useful for data analysis and predictive modelling. In this recipe, we will extract
    different time parts of a `datetime` variable by utilizing `pandas` and NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can extract hours, minutes, and seconds using the following `pandas`’ `datetime`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.hour`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.minute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.second`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll extract the `hour`, `minute`, and `second` part of a
    `time` variable. Let’s begin by importing the libraries and creating a sample
    dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import `pandas` and `numpy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s begin by creating 20 `datetime` observations, starting on `2024-05-17`
    at midnight and followed by increments of 1 hour, 15 minutes, and 10 seconds.
    Next, we’ll capture the time range in a DataFrame and display the top five rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following output, we see the variable from *Step 2*, with a `date` part
    and a `time` part, and the values increasing by intervals of 1 hour, 15 minutes,
    and 10 seconds:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The first five rows of a sample DataFrame with a datetime variable](img/B22396_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – The first five rows of a sample DataFrame with a datetime variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract the `hour`, `minute`, and `second` part and capture them into
    three new columns, then display the DataFrame’s top five rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following output, we see the three `time` features that we extracted
    in *Step 3*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The first five rows of a DataFrame with three variables derived
    from time](img/B22396_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The first five rows of a DataFrame with three variables derived
    from time
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `pandas`’ `dt` needs a `datetime` object to work. You can change
    the data type of an object variable into `datetime` by using `pandas` `to_datetime()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s perform the same operations that we did in *Step 3* but now in one line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the newly created variables in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The first five rows of a DataFrame with the variables derived
    from time](img/B22396_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – The first five rows of a DataFrame with the variables derived
    from time
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can inspect the unique values of the new variables with `pandas`’ `unique()`,
    for example, by executing `df['hour'].unique()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s create a binary variable that flags events that occurred in
    the morning, between 6 A.M. and 12 P.M.:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the `is_morning` variable in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.12 – The top rows of a DataFrame with the new variables derived
    from time](img/B22396_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – The top rows of a DataFrame with the new variables derived from
    time
  prefs: []
  type: TYPE_NORMAL
- en: With that, we extracted multiple features from the time part of a `datetime`
    variable. These features can be used for data analysis and predictive modelling.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created features that capture representations of time. First,
    we created a sample DataFrame with a `datetime` variable. We used `pandas` `date_range()`to
    create a range of 20 values starting from an arbitrary date and increasing by
    intervals of 1 hour, 15 minutes, and 10 seconds. We used the `1h15min10s` string
    as the frequency term for the `freq` argument to indicate the desired increments.
    Next, we transformed the date range into a DataFrame with `pandas`’ `DataFrame()`.
  prefs: []
  type: TYPE_NORMAL
- en: To extract the different time parts, we used `pandas`’ `dt` to access the `hour`,
    `minute`, and `second` `time` properties. After extracting `hour` from `time`,
    we used it to create a new feature that indicated whether it was morning by using
    NumPy’s `where()`. NumPy’s `where()` scanned the `hour` variable; if its values
    were smaller than 12 and greater than 6, it assigned a value of `1`; otherwise,
    it assigned a value of `0`. With these operations, we added several features to
    the DataFrame that can be used for data analysis and to train machine learning
    models.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also extract microseconds and nanoseconds with the following `pandas`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.microsecond`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.Series.dt.nanosecond`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details, visit [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components).
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the elapsed time between datetime variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extract powerful features from each `datetime` variable individually,
    as we did in the previous two recipes. We can create additional features by combining
    multiple `datetime` variables. A common example consists of extracting the **age**
    at the time of an event by comparing the **date of birth** with the **date of**
    **the event**.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to capture the time between two `datetime`
    variables by utilizing `pandas` and `feature-engine`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To proceed with this recipe, we’ll create a DataFrame containing two `datatime`
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by importing `pandas`, `numpy`, and `datetime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll start by creating two `datetime` variables with 20 values each; the values
    start from `2024-05-17` and increase in intervals of `1` hour for the first variable,
    and `1` month for the second. Then, we‘ll capture the variables in a DataFrame,
    add column names, and display the top rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the first five rows of the DataFrame from *Step 2* in the following
    output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 6.13 – The first five rows of a DataFrame wit\uFEFFh two datetime\
    \ variables](img/B22396_06_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – The first five rows of a DataFrame with two datetime variables
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s capture the difference in days between the two variables in a new feature,
    and then display the DataFrame’s top rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the difference in days in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Top rows of a DataFrame with a new variable capturing the time
    difference between the two datetime features](img/B22396_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Top rows of a DataFrame with a new variable capturing the time
    difference between the two datetime features
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s capture the difference in weeks between the two `datetime` variables
    and then display the DataFrame’s top rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the difference in weeks between the variables in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 6.15 – A DataFrame with the time difference between the datetime variables\
    \ expressed in number \uFEFFof days and number of weeks](img/B22396_06_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – A DataFrame with the time difference between the datetime variables
    expressed in number of days and number of weeks
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s calculate the time in between the variables in minutes and seconds
    and then display the DataFrame’s top rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the new variables in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.16 – A DataFrame with the time difference between the two datetime
    variables expressed in different time units](img/B22396_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – A DataFrame with the time difference between the two datetime
    variables expressed in different time units
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s calculate the difference between one variable and the current
    day, expressed in number of days, and then display the first five rows of the
    DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can find the new variable in the final column of the DataFrame in the following
    output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.17 – A DataFrame with the new variable containing the difference
    between date1 and the day this code was executed](img/B22396_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – A DataFrame with the new variable containing the difference between
    date1 and the day this code was executed
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `to_today` variable on your computer will be different from the one in this
    book, due to the difference between the current date (at the time of writing)
    and when you execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! We’ve now enriched our dataset with new features that were created
    by comparing two `datetime` variables.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we captured different representations of the time between two
    `datetime` variables. To proceed with this recipe, we created a sample DataFrame
    with two variables, each with 20 dates starting at an arbitrary date. The first
    variable increased in intervals of `1` hour, while the second variable increased
    in intervals of `1` month. We created the variables with `pandas`’ `date_range()`,
    which we discussed in the previous two recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the difference between the variables – that is, to determine the
    time between them – we directly subtracted one `datetime` variable from the other
    – that is, one `pandas` Series from the other. The difference between the two
    `pandas` Series returned a new `pandas` Series. To capture the difference in days,
    we used `pandas`’ `dt`, followed by `days`. To convert the time difference into
    months, we used `timedelta()` from NumPy, indicating that we wanted the difference
    in weeks by passing `W` in the second argument of the method. To capture the difference
    in seconds and minutes, we passed the `s` and `m` strings to `timedelta()`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The arguments for NumPy’s `timedelta` are a number, `– 1`, in our example, to
    represent the number of units, and a `datetime` unit, such as day (`D`), week
    (`W`), hours (`h`), minutes (`m`), or seconds (`s`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we captured the difference from one `datetime` variable to today’s
    date. We obtained the date and time of today (at the time of writing) by using
    `today()` from the built-in `datetime` Python library.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can automate the creation of features that capture the time between variables
    by using the `feature-engine`‘s transformer `DatetimeSubstraction()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import `pandas` and `feature-engine`’s transformer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s re-create the sample dataset that we described in *Step 2* of the *How
    to do* *it…* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s set up `DatetimeSubstraction()`to return the time difference between
    the second date and the first date expressed in days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can obtain the difference between more than two variables by passing variable
    lists in the `variables` and `reference` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create and then display the new feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following output, we see the variable that captures the time difference
    between the two `datetime` variables in days:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.18 – A DataFrame with the new variable containing the difference
    between the two datetime variables](img/B22396_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – A DataFrame with the new variable containing the difference between
    the two datetime variables
  prefs: []
  type: TYPE_NORMAL
- en: For more details, check out [https://feature-engine.trainindata.com/en/latest/api_doc/datetime/DatetimeSubtraction.html](https://feature-engine.trainindata.com/en/latest/api_doc/datetime/DatetimeSubtraction.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about NumPy’s `timedelta`, visit [https://numpy.org/devdocs/reference/arrays.datetime.html#datetime-and-timedelta-arithmetic](https://numpy.org/devdocs/reference/arrays.datetime.html#datetime-and-timedelta-arithmetic).
  prefs: []
  type: TYPE_NORMAL
- en: Working with time in different time zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some organizations operate internationally; therefore, the information they
    collect about events may be recorded alongside the time zone of the area where
    the event took place. To be able to compare events that occurred across different
    time zones, we typically have to set all of the variables within the same zone.
    In this recipe, we will learn how to unify the time zones of a `datetime` variable
    and how to reassign a variable to a different time zone using `pandas`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To proceed with this recipe, we’ll create a sample DataFrame containing two
    variables in different time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import `pandas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create a DataFrame containing one variable with values in different time
    zones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add another `datetime` variable to the DataFrame, which also contains
    values in different time zones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we now execute `df`, we’ll see the DataFrame with the variables in the different
    time zones like in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.19 – A DataFrame with two datetime variables in different time zones](img/B22396_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – A DataFrame with two datetime variables in different time zones
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The time zone is indicated with the `+02` and `-05` values, respectively, which
    indicates the time difference to the **Coordinated Universal** **Time** (**UTC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with different time zones, we typically set the variables in the same
    time zone, in this case, we chose the UTC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we now execute `df`, we’ll see the new variables, which have a difference
    of `00` hours with respect to UTC:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.20 – A DataFrame\uFEFF containing the new variables in the UTC](img/B22396_06_20.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – A DataFrame containing the new variables in the UTC
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s calculate the difference in days between the variables and then display
    the first five rows of the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the time difference between the variables in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: df['time1_london'] = df[
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ‹time1_utc›].dt.tz_convert('Europe/London')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: df['time2_berlin'] = df[
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ‹time1_utc›].dt.tz_convert('Europe/Berlin')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: df[['time1_london', 'time2_berlin']]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.21 – Variables reformatted into different time zones](img/B22396_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Variables reformatted into different time zones
  prefs: []
  type: TYPE_NORMAL
- en: When changing time zones, not only do the values of the zone change – that is,
    the `+01` and `+02` values in the previous image – but the value of the hour changes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we changed time zones and performed operations between variables
    in different time zones. To begin, we created a DataFrame with two variables,
    the values of which started at an arbitrary date and increased hourly; these were
    set in different time zones. To combine the different time zone variables in one
    DataFrame column, we concatenated the series returned by `pandas`’ `date_range()`
    by utilizing `pandas`’ `concat()`. We set the `axis` argument to `0` to indicate
    we wanted to concatenate the series vertically in one column. We covered the arguments
    of `pandas`’ `date_range()` extensively in former recipes in this chapter; see
    the *Extracting features from dates with pandas* and *Extracting features from
    time with pandas* recipes for more details.
  prefs: []
  type: TYPE_NORMAL
- en: To reset the time zone of the variables to the central zone, we used `pandas`’
    `to_datetime()`, passing `utc=True`. Finally, we determined the time difference
    between the variables by subtracting one series from the other and capturing the
    difference in days. To reassign a different time zone, we used `pandas`’ `tz_convert()`,
    indicating the new time zone as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about `pandas`’ `to_datetime()`, visit [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html).
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about `pandas`’ `tz_convert()`, visit [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_convert.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_convert.html).
  prefs: []
  type: TYPE_NORMAL
- en: Automating the datetime feature extraction with Feature-engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`feature-engine` is a Python library for feature engineering and selection
    that is well suited to working with `pandas` DataFrames. The `DatetimeFeatures()`
    class can extract features from date and time automatically by using `pandas`’
    `dt` under the hood. `DatetimeFeatures()` allows you to extract the following
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quarter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semester
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Week
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day of the week
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day of the month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day of the year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weekend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quarter start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quarter end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Year start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Year end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leap year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Days in a month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will automatically create features from date and time by
    utilizing `feature-engine`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To showcase `feature-engine`’s functionality, we’ll create a sample DataFrame
    with a `datetime` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by importing `pandas` and `DatetimeFeatures()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create a `datetime` variable with 20 values, beginning from `2024-05-17`
    at midnight and followed by increments of `1` day. Then, we store this variable
    in a DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll start by setting up the transformer to extract all supported `datetime`
    features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`DatetimeFeatures()` automatically finds the variables of the `datetime` type,
    or that could be parsed as `datetime` when the `variables` parameter is set to
    `None`. Alternatively, you can pass a list with the names of the variables from
    which you want to extract `date` and `time` features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the `date` and `time` features to the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `DatetimeFeatures()` extracts the following features from each
    `datetime` variable: `month`, `year`, `day_of_week`, `day_of_month`, `hour`, `minute`,
    and `second`. We can modify this behavior through the `features_to_extract` parameter
    as we did in *Step 3*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s capture the names of the new variables in a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`DatetimeFeatures()` names the new variables with the original variable name
    (in this case, `date`) followed by an underscore and then the type of feature
    created, for example, `date_day_of_week` contains the day of the week extracted
    from the `date` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute `vars_`, we’ll see the names of the features that were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: df = pd.DataFrame()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: df["time"] = pd.concat(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pd.Series(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pd.date_range(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: start="2024-08-01 09:00",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: freq="h",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: periods=3,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tz="Europe/Berlin"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pd.Series(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pd.date_range(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: start="2024-08-01 09:00",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: freq="h",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: periods=3, tz="US/Central"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '],'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: axis=0,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: dfts = DatetimeFeatures(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: features_to_extract=
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '["day_of_week", "hour","minute"],'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drop_original=False,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: utc=True,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: dft = dfts.fit_transform(df)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
