<html><head></head><body>
			<h1 id="_idParaDest-86" class="chapter-number"><a id="_idTextAnchor086"/>8</h1>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>The Role of DevOps in Building Intelligent MSA Enterprise Systems</h1>
			<p>In previous chapters, we covered what MSA is and the advantages of MSA over monolithic architecture. Then, we discussed, with examples, how to refactor a monolithic application into an MSA, and then talked about different patterns and techniques to enhance the performance of an <span class="No-Break">MSA system.</span></p>
			<p>We also discussed the different ML and DL algorithms with hands-on examples, how they can be optimized, and how these ML and DL algorithms can help further enhance the stability, resilience, and supportability of an MSA system in order to build a “smart MSA” or “intelligent <span class="No-Break">MSA” system.</span></p>
			<p>Over the next few chapters, we will further enhance our ABC-MSA system and try to apply what has been learned so far using some hands-on installations and code examples. However, before we do so, we need to discuss the different concepts of DevOps in this chapter, and how to apply the DevOps process to building and running an <span class="No-Break">MSA system.</span></p>
			<p>In <a href="B18934_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, we briefly talked about DevOps in MSA. In this chapter, we will expand on the subject and dive into the details of the role of DevOps in building <span class="No-Break">intelligent MSA.</span></p>
			<p>The following topics are covered in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>DevOps and organizational <span class="No-Break">structure alignment</span></li>
				<li>DevOps processes in enterprise MSA <span class="No-Break">system operations</span></li>
				<li>Applying DevOps from the beginning to operations <span class="No-Break">and maintenance</span></li>
			</ul>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>DevOps and organizational structure alignment</h1>
			<p>In a traditional <a id="_idIndexMarker428"/>software development organization, the software delivery process is matured and built according to how that traditional organization is structured. Typically, we have a business team that defines the core business specifications and requirements, followed by another team of architects that builds how the system is supposed to be structured. In the traditional software model, we also have design engineers who write the functional specs, a development team responsible for writing the code, a QA team to test the code quality, then a release team, an operations team for post-release operations, a support team, and <span class="No-Break">so on.</span></p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B18934_08_1.jpg" alt="Figure 8.1: Traditional development structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Traditional development structure</p>
			<p>With all <a id="_idIndexMarker429"/>these teams involved in the pipeline in the traditional software release cycle, mostly sequential hand-offs between teams, silos, dependencies in between, cross-communication issues, and the possibility of finger-pointing during the process, the release cycle can take weeks or months to finish. For an MSA, this is <span class="No-Break">not acceptable.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The whole purpose of MSA is to simplify, speed up, and optimize software releases and updates. Applying the traditional methodology to MSA system development just doesn’t work and defeats the purpose of adopting an MSA to <span class="No-Break">begin with.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/>DevOps</h2>
			<p>DevOps is one <a id="_idIndexMarker430"/>of the major processes adopted in modern software development organizations to help streamline the release process and optimize it so that an organization can make multiple seamless release updates every day with no service <span class="No-Break">interruption whatsoever.</span></p>
			<p>DevOps is a combination of processes that allow you to take an application from development to operation smoothly. Enterprises need dedicated and well-defined DevOps processes to manage their solution development, hosting, <span class="No-Break">and operations.</span></p>
			<p>The primary need of a DevOps team is to implement engineering techniques in managing the operations of applications. While this sounds simple to do, several mundane and random activities are carried out by the operations teams. Streamlining these tasks is the biggest challenge in <span class="No-Break">adopting DevOps.</span></p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B18934_08_2.jpg" alt="Figure 8.2: Teams working together in a DevOps fashion"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: Teams working together in a DevOps fashion</p>
			<p>The primary responsibility of the development team is to build the application. However, they also need to take care of other aspects of the application, such as the application performance, usage analytics, code quality, activity logging, and solving <span class="No-Break">code-level errors.</span></p>
			<p>On the other hand, the operations team faces a completely different set of problems. Their concerns include managing the availability of the applications, ensuring performance through higher scalability, and improving the monitoring of the solution ecosystem, the allocation of resources, and the overall system analytics. DevOps processes handle all of these concerns for all parties involved in <span class="No-Break">the process.</span></p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/B18934_08_3.jpg" alt="Figure 8.3: DevOps life cycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: DevOps life cycle</p>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em> is similar to what we discussed in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.11</em>. One new thing to add here is that the <strong class="bold">PLAN</strong> stage is where the software roadmap is defined and gets broken down into major requirements, called <strong class="bold">epics</strong>. These epics <a id="_idIndexMarker431"/>are broken down into a collection of short end user requirements, called <strong class="bold">user stories</strong>. More info on that will come in the <span class="No-Break">next section.</span></p>
			<p>Well, OK then, if an organization is to adopt an MSA, they should embrace a DevOps culture as well.Simple, right? <span class="No-Break">Not quite!</span></p>
			<p>Adopting a DevOps <a id="_idIndexMarker432"/>culture within a traditional organizational structure would have many misalignments that are guaranteed to hinder the DevOps cycle. The efficiency and speed of your release cycle will be as fast as the slowest process in your cycle. The software development organization itself has to shift its culture to align with DevOps, not the other way around. Many other methodologies and technologies will need to be adopted as part of the new shift to DevOps. The organizational structure itself may also need to be tweaked to align with the new <span class="No-Break">DevOps methodologies.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>The DevOps team structure</h2>
			<p>Setting up a DevOps team is the first step toward organizational transformation. However, you cannot expect to have a fully-fledged DevOps team without considering the existing <a id="_idIndexMarker433"/>organizational structure and how the organization is aligned with the existing <span class="No-Break">development cycle.</span></p>
			<p>It is imperative to have an interim phase in which the development and operations teams can function reasonably within the existing traditional organization. Both traditional Dev and Ops teams then slowly morph themselves into a true DevOps structure as the organization modernizes its structure to fit into the <span class="No-Break">new culture.</span></p>
			<p>One of the recommended approaches in the organizational transformation scenario is to develop a small DevOps team to work as a link between the existing development team and the operations team. The DevOps team’s main objective in this particular case is to cross-function between both Dev and Ops teams to map deliverables in between, slowly familiarize both teams with the new methodology, and start applying basic DevOps methodologies within both teams so that they can be unified in <span class="No-Break">the future.</span></p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/B18934_08_4.jpg" alt="Figure 8.4: The DevOps team as a link between Dev and Ops during the organizational transition"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4: The DevOps team as a link between Dev and Ops during the organizational transition</p>
			<p>Team communication, collaboration, energy, trust, and a solid understanding of the entire development cycle are all paramount to the new DevOps team’s success. Therefore, you must identify the right skills and people who can push the activities of the DevOps team forward. These skills may include, but are not limited to, coding skills, mastering <a id="_idIndexMarker434"/>DevOps and <strong class="bold">Continuous Integration/Continuous Development</strong> (<strong class="bold">CI/CD</strong>) tools, <span class="No-Break">and automation.</span></p>
			<p>As the organizational structure and the teams mature and become more familiar with the new methodologies, merging the old Dev, old Ops, and the interim DevOps teams into a single new DevOps team becomes essential. Staying in the interim stage too long is likely to create even more disruptions than using the traditional development cycle for developing the <span class="No-Break">MSA system.</span></p>
			<p>The size of <a id="_idIndexMarker435"/>the DevOps team can be as small as 3 engineers, and as large as 12, depending on the organization’s size, existing structure, and the effort being put into the organizational transformation. Usually, a number between 3 and 12 is ideal. Having a larger team is likely to create more challenges than benefits and start negatively impacting the team’s <span class="No-Break">overall performance.</span></p>
			<p>Begin the process of transformation in a step-by-step manner, starting with infrastructure codification, the automation of infrastructure provisioning, source code version control, infrastructure monitoring, code build automation, deployment automation, test orchestration, cloud service management, and <span class="No-Break">so on.</span></p>
			<p>We know now how the organizational structure is relevant and important when embracing DevOps. We still need to understand some other details on the processes that will complement DevOps in order to achieve our goal of developing an efficient, high-quality MSA system with a short time-to-market and <span class="No-Break">seamless updates.</span></p>
			<p>In the following section, we will examine some other considerations that need to be taken into account when developing an <span class="No-Break">MSA system.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>DevOps processes in enterprise MSA system operations</h1>
			<p>Microservices development is a fast-paced process and requires all other development processes <a id="_idIndexMarker436"/>to run at the same <a id="_idIndexMarker437"/>pace. Right from the beginning of the development of the MSA system, source code management and configuration management are needed to provide the correct support to the DevOps team. This is followed by code scans and unit test orchestration in the <span class="No-Break">development environment.</span></p>
			<p>Having <a id="_idIndexMarker438"/>specific standard methodologies <a id="_idIndexMarker439"/>and best practices applied among the different team members is essential to manage the efficiency and fast pace of the development cycle. The following discusses what <strong class="bold">the Agile methodology of development</strong> is and how it helps in DevOps operations, and the importance of automation <span class="No-Break">in DevOps.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>The Agile methodology of development</h2>
			<p>Defining and accomplishing DevOps processes go hand in hand with adopting a development <a id="_idIndexMarker440"/>methodology that can fully support and leverage the power of DevOps. Although there are many ways to apply DevOps methodologies within your organization, the Agile methodology is the one best suited <span class="No-Break">for DevOps.</span></p>
			<p>The Agile development methodology breaks down the main requirements into small consumable changes – stories and epics. These small, consumable increments help the team achieve short wins throughout the journey of handling the project from start <span class="No-Break">to end.</span></p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.5</em>, the Agile team members meet periodically, typically every week or two, to plan, define, and agree on the epics and stories. These requirements are then put into a backlog and, until the next Agile team meeting, the team members work to deliver the requirements from <span class="No-Break">that backlog:</span></p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B18934_08_5.jpg" alt="Figure 8.5: Sprint cycle in Agile development"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5: Sprint cycle in Agile development</p>
			<p>In Agile <a id="_idIndexMarker441"/>development, the weekly or biweekly recurring meetings <a id="_idIndexMarker442"/>are called <strong class="bold">Sprint Planning Meetings</strong>, and the time between these meetings when developers are working on the backlog is <a id="_idIndexMarker443"/>called <span class="No-Break">a </span><span class="No-Break"><strong class="bold">sprint</strong></span><span class="No-Break">.</span></p>
			<p>In order for team members to check on the status of each defined epic and story, they usually meet daily to examine the sprint backlog and refine whatever needs to be refined to ensure timely delivery. This daily meeting is called a <span class="No-Break"><strong class="bold">Daily Scrum</strong></span><span class="No-Break">.</span></p>
			<p>The Agile team handles continuously evolving user stories and requirements within a <span class="No-Break">sprint cycle.</span></p>
			<p>In an endeavor to deliver a high-quality product at a fast pace and low cost, Agile teams apply the <span class="No-Break">following principles:</span></p>
			<ul>
				<li>No blocking time for day-end activities, such as building and deploying the <span class="No-Break">latest code</span></li>
				<li>Immediate feedback on the code quality and functional quality of the <span class="No-Break">latest code</span></li>
				<li>Strong control, precision monitoring, and continuous improvement of the daily activities of the <span class="No-Break">development team</span></li>
				<li>Faster decision-making for accepting new stories, releasing developed stories, and <span class="No-Break">mitigating risks</span></li>
				<li>A reduced feedback loop with the testers, end users, <span class="No-Break">and customers</span></li>
				<li>Regular review and introspection of the development and <span class="No-Break">delivery processes</span></li>
			</ul>
			<p>A development <a id="_idIndexMarker444"/>team abiding by the Agile manifesto and following all the Agile principles should always look for ways to remove unwanted roadblocks from their <span class="No-Break">process model.</span></p>
			<p>The Agile methodology of development can be applied to develop and deliver all types of software projects; however, it is more suited to the development of microservices-based applications. It is important to view the scope and structure of microservices to align them with Agile and <span class="No-Break">DevOps practices.</span></p>
			<p>One of the most important pillars of the Agile and DevOps process is the use of on-demand, needs-based resources. This is usually catered to by the use of a cloud-based infrastructure. All the resources required by the Agile teams developing microservices need to be provisioned promptly and in the right quantity or with enough capacity. Cloud infrastructure is best suited to these requirements. Resources can be scaled up and down based on need <span class="No-Break">and demand.</span></p>
			<p>On-demand cloud workloads needed during the DevOps cycles are not necessarily deployed on the organization’s private infrastructure; they may very well be deployed using a public cloud provider, or they may be deployed in a hybrid <span class="No-Break">cloud fashion.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Automation</h2>
			<p>With the increase in the complexity of the IT infrastructure and MSA adoption and the demand for an Agile development cycle and short time-to-market, the need to streamline <a id="_idIndexMarker445"/>the infrastructure management processes becomes the most pressing need for any organization. A big part of managing an MSA’s infrastructure, DevOps, CI/CD, and Agile development <span class="No-Break">is automation.</span></p>
			<p>Automation provides immense benefits to modern organizations. A few of these benefits include, but are not limited to, <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Better human resource utilization</strong>: With automation in place, staff can focus on other activities that may not be automatable, hence optimizing the use of the organization’s workforce, scaling better on other projects, and distributing responsibilities according to the available and required <span class="No-Break">skill sets.</span></li>
				<li><strong class="bold">Better time-to-market and better business agility</strong>: An automated process can certainly save a lot of time that would be otherwise consumed by manual repetitive work and potential dependencies. A job that may traditionally take days can be done in minutes when automation is <span class="No-Break">in place.</span></li>
				<li><strong class="bold">Higher reliability and greater business continuity</strong>: Complex and time-consuming tasks are simplified into simple keystrokes or mouse clicks. Accordingly, human error is significantly minimized, and operational reliability is <span class="No-Break">largely increased.</span></li>
				<li><strong class="bold">Better compliance</strong>: Compliance can be built into automation tools, providing better policy enforcement with minimum effort. Compliance includes industry compliance, best <a id="_idIndexMarker446"/>practices, and <a id="_idIndexMarker447"/>organizational <a id="_idIndexMarker448"/>standards <a id="_idIndexMarker449"/>as well. Industry standards may include the <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>), <strong class="bold">Payment Card Industry Data Security Standard</strong> (<strong class="bold">PCI DSS</strong>), <strong class="bold">Health Insurance Portability and Accountability Act</strong> (<strong class="bold">HIPAA</strong>), and <strong class="bold">Safeguard Computer Security Evaluation </strong><span class="No-Break"><strong class="bold">Matrix</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SCSEM</strong></span><span class="No-Break">).</span></li>
			</ul>
			<p>Automation is often used for the fast-paced and high-quality delivery of applications. DevOps is the key process that helps automate various phases of development and delivery. In fact, DevOps is the culture that helps organizations avoid repeated, time-consuming manual steps and efforts. There are various tools, frameworks, and processes within the ambit of DevOps that are needed for <span class="No-Break">successful automation.</span></p>
			<p>Most of the <a id="_idIndexMarker450"/>challenges within DevOps and MSA operations cannot be addressed manually – hence, the need for automation in DevOps and MSA is extremely high. Automation is needed in every area of delivery, from the time the microservice is developed to the time the microservice is deployed in the <span class="No-Break">production environment.</span></p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B18934_08_6.jpg" alt="Figure 8.6: The four pillars of DevOps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6: The four pillars of DevOps</p>
			<p>In essence, modern enterprise system development needs DevOps to be able to respond to the dynamic and constantly growing needs of organizations, and DevOps depends heavily on four pillars: <strong class="bold">MSA</strong>, <strong class="bold">Agile Development</strong>, <strong class="bold">CI/CD</strong>, and <strong class="bold">Automation</strong>. These four pillars, as shown in the preceding diagram, play a significant part in DevOps success, and hence, in the success of modern enterprise <span class="No-Break">system development.</span></p>
			<p>Moreover, as we will discuss later in this chapter, AI applications are very hard to test and manage manually, and automation plays a big part in managing the entire DevOps cycle of <span class="No-Break">AI applications.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Applying DevOps from the start to operations and maintenance</h1>
			<p>Every step <a id="_idIndexMarker451"/>of a microservices rollout requires <a id="_idIndexMarker452"/>a corresponding DevOps step. The confluence of the microservices development process with the DevOps process helps empower the Dev and Ops teams. The following is a detailed look at different facets of the <span class="No-Break">DevOps process.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Source code version control</h2>
			<p>The Agile <a id="_idIndexMarker453"/>teams working on microservices require specific version control to be in place. Three aspects of version control need to be carefully defined for <span class="No-Break">each microservice:</span></p>
			<ul>
				<li>The setup and management of version control tools, such as Git, SVN, CVS, <span class="No-Break">and Mercurial.</span></li>
				<li>The version format and nomenclature for the application, such as a format to indicate the application version, the major-change version, the minor-change version, and the build or patch number – for example, <span class="No-Break">version 2.3.11.7.</span></li>
				<li>The branching strategy for the source code. This is extremely important for microservices development with multiple teams working on separate microservices. Teams need to create separate repositories for each microservice and fork out different branches for each major or <span class="No-Break">minor enhancement.</span></li>
			</ul>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Configuration management and everything as a code</h2>
			<p>Configuration <a id="_idIndexMarker454"/>management is the practice of managing changes systematically across various environments so that the functional and technical performance of the system is at its best. This includes all the environments needed to develop, test, deploy, and run the MSA <span class="No-Break">system components.</span></p>
			<p>With so many moving parts in an MSA enterprise system, it is essential to identify which parts of the system need their configuration to be maintained and managed. Once these parts have been identified, their configuration will need to be controlled and regularly audited to maintain the overall health of the entire <span class="No-Break">MSA system.</span></p>
			<p>As the DevOps process matures, and as the MSA system components mature, things become very complex to manage and configure manually, and automation becomes critical for smooth and successful <span class="No-Break">configuration management.</span></p>
			<p>Configuration <a id="_idIndexMarker455"/>management tools can automatically and seamlessly manage the different aspects of the system components. These tools make adjustments as needed during runtime and whenever else, and in accordance with the version of the application, the type of change, and the <span class="No-Break">system load.</span></p>
			<p>One of the objectives of DevOps is to codify all the aspects of development as well as deployment, including the infrastructure and the configuration. The entire environment can be <a id="_idIndexMarker456"/>built from the ground up and quickly provisioned <a id="_idIndexMarker457"/>using <strong class="bold">Infrastructure-as-a-Code</strong> (<strong class="bold">IaaC</strong>) and <span class="No-Break"><strong class="bold">Configuration-as-a-Code</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CaaC</strong></span><span class="No-Break">).</span></p>
			<p>IaaC and CaaC are essential components of configuration management. Both are descriptive files typically written in languages such as Ansible, Terraform, Puppet, Chef, <span class="No-Break">or CloudFormation.</span></p>
			<p>With IaaC and CaaC, DevOps teams can easily spin up new workloads for different purposes. Workloads can, for example, be configured for testing, specify the properties of each workload based on the test cases involved, and control deviations from the main <span class="No-Break">workload parameters.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>CI/CD</h2>
			<p>As pointed <a id="_idIndexMarker458"/>out earlier in <a href="B18934_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, CI/CD is an integral part of DevOps and plays the most important role in releasing MSA system updates. CI/CD ensures that the code is immediately and periodically built and pushed into the CI/CD pipeline for quick testing <span class="No-Break">and feedback.</span></p>
			<p>As shown in the following CI/CD pipeline diagram, developers focus primarily on working on the sprint backlog and push the code updates to the team repository, and it gets downloaded from there to the <span class="No-Break">CI server.</span></p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B18934_08_7.jpg" alt="Figure 8.7: CI/CD pipeline and process flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7: CI/CD pipeline and process flow</p>
			<p>The CI server automatically runs preset test cases against the code and then pushes the code to the <a id="_idIndexMarker459"/>testers upon it passing all the test cases. Should any of the automated tests fail, the code doesn’t move further along the pipeline, and an error report of all the test failures is sent back to <span class="No-Break">the developers.</span></p>
			<p>In contrast to the traditional development cycle, in which developers may find out about their code test results days or weeks after their code has been submitted for testing, in CI/CD, developers will get a report of their code problems within minutes. This early visibility into code errors gives developers the chance to immediately work on fixing these errors while working on the original code. Hence, they can continuously enhance the code for release <span class="No-Break">and deployment.</span></p>
			<p>Upon the code successfully passing all CI server tests, the code is tested further by the DevOps team testers. Testers then either push the code to release and deployment if no errors are found or return it for further fixes <span class="No-Break">and enhancements.</span></p>
			<p>This CI/CD pipeline enables developers to make frequent code merges; do unit testing, integration testing, code scans, and smoke testing; release; and deploy multiple times every single day – something that is not remotely possible using a traditional <span class="No-Break">development cycle.</span></p>
			<p>The DevOps <a id="_idIndexMarker460"/>team needs to identify a tool that can manage the entire CI/CD pipeline. DevOps helps add hooks and steps to include external executables and scripts for performing additional activities during the code build and deployment. Some of the most common and widely used CI/CD tools include Jenkins, Bamboo, <span class="No-Break">and CircleCI.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>Code quality assurance</h2>
			<p>Ensuring high-quality code, both in terms of coding standards and security vulnerabilities, is another important activity within DevOps. This is in addition to ensuring the accuracy of the application’s business <span class="No-Break">logic itself.</span></p>
			<p>Code quality <a id="_idIndexMarker461"/>touches upon the concept of static and dynamic analysis of the code. Static analysis of the code is performed on the code itself before it gets executed. It is meant to uncover code smells, dirty code, vulnerable libraries, malicious openings in the code, and violations of code standards or <span class="No-Break">best practices.</span></p>
			<p>Dynamic code analysis is performed on the application during or after its execution. It is meant to uncover runtime errors due to the load, unexpected input, or unexpected runtime conditions <span class="No-Break">in general.</span></p>
			<p>Many tools that help perform code scans as part of CI/CD are available. These include, but are not limited to, SonarQube, Fortify SCA, <span class="No-Break">and Raxis.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Testing AI applications is more challenging than testing regular applications. Certain aspects of AI applications do not exist in <span class="No-Break">regular applications.</span></p>
			<p>AI applications are non-deterministic –  how they will behave in real situations is somewhat uncertain. Accordingly, expecting a specific outcome during AI application testing may not be viable. It may very well happen that the application being tested produces different outcomes with the same input or <span class="No-Break">test criteria.</span></p>
			<p>Most AI applications are as good as their training data quality, which makes AI applications subject to training data bias or unconscious bias. Imagine, for example, you are writing an AI module to predict home prices in any part of the United States, but your training data is 90% from a specific region within a specific state. Your AI model will accordingly be biased toward the area from which 90% of the training data came, so testing the AI application may require running tests against the training data itself. This may sound easy in this home price prediction case, but how would you make sense of other pieces of training data in more <span class="No-Break">complex situations?</span></p>
			<p>Let’s assume <a id="_idIndexMarker462"/>that we can accurately test AI/DL applications despite all the training data challenges and their non-deterministic behavior. AI/DL applications constantly learn, train, and change their behavior, so by the time the code is running in production, the application is already learning and changing its behavior. The tests that have been completed a day or a couple of days earlier may not be <span class="No-Break">valid anymore.</span></p>
			<p>There are, of course, ways to overcome all these challenges. First of all, you will need to curate and validate the training data. You may need to perform both automated and manual tasks to validate the training data, including checking for data biases, data skews, distribution levels, and <span class="No-Break">so on.</span></p>
			<p>We will also need to test the AI algorithm and how the regression model performs against different sets of test data. The variance and mean square error of the model will also need to be examined <span class="No-Break">and analyzed.</span></p>
			<p>AI application testing tools are available on the market today and grow in number every day. The quality of these tools is constantly improving and can be a huge help to DevOps teams. AI testing tools are usually specialized based on the AI algorithms being used. Examples of different AI test tools include, but are not limited to, Applitools, Sauce Labs, <span class="No-Break">and Testim.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Monitoring</h2>
			<p>With the <a id="_idIndexMarker463"/>advent of DevOps, standard monitoring has upgraded to continuous monitoring and covers the entire development cycle, from planning to deployment <span class="No-Break">and operations.</span></p>
			<p>Monitoring covers different aspects of the DevOps process and the components needed for the entire application to be developed, tested, deployed, and released, as well as for post-release operations to ensue. This includes infrastructure monitoring and the <span class="No-Break">application itself.</span></p>
			<p>Infrastructure monitoring includes the on-premises infrastructure, virtual cloud environments, networks, communications, and security. Application monitoring, on the other hand, involves performance, scalability, availability, and reliability. Resource monitoring includes the management and distribution of resources across multiple pod replicas within and beyond the physical or <span class="No-Break">virtual workloads.</span></p>
			<p>DevOps <a id="_idIndexMarker464"/>monitoring helps team members respond to any operational issues that arise during the DevOps pre-release or post-release cycles, hence enabling the DevOps team to be able to rectify, readjust, and make any necessary changes during the <span class="No-Break">CI/CD pipeline.</span></p>
			<p>Ideally, monitoring alerts trigger automatic actions to try to respond and fix a problem that has been detected. However, knowing that’s not always possible, manual intervention is usually needed. Monitoring helps the DevOps team shift left to earlier stages in the development cycle to enhance their test cases, and accordingly, increase the application quality and minimize operational problems later on in the <span class="No-Break">development cycle.</span></p>
			<p>AI algorithms, as discussed earlier in <a href="B18934_07.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, and as we will give more examples of later in this book, can detect any application behavior anomalies and automatically try to self-heal to prevent application operations from <span class="No-Break">being disrupted.</span></p>
			<p>There are many environment-specific tools available for DevOps monitoring, including Nagios, Prometheus, Splunk, Dynatrace, and AWS CloudWatch for AWS <span class="No-Break">cloud environments.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Disaster management</h2>
			<p>Disaster management is an important yet often overlooked part of the DevOps process. In most cases, application recovery is seen as an extended part of the deployment process. In the <a id="_idIndexMarker465"/>cloud, it is generally considered to be an offshoot of configuring availability zones and regions for hosting an application instead of a full-fledged <span class="No-Break">environment challenge.</span></p>
			<p>In the case of microservices, identifying a disaster is a greater challenge than averting, mitigating, or managing it. Luckily, the CI/CD environment itself can be leveraged to test and simulate disaster scenarios. Moreover, the use of external repositories can be leveraged to recover code down to specific <span class="No-Break">version numbers.</span></p>
			<p>Nevertheless, setting up a completely separate set of environment replicas in different geographical locations, setting automatic failover, and load balancers in between can be great ways of maintaining business continuity and an uninterrupted <span class="No-Break">CI/CD pipeline.</span></p>
			<p>Using IaaC and CaaC tools to automate recovery is extremely helpful in bringing your applications and systems back online in minimal time in case <span class="No-Break">of interruption.</span></p>
			<p>You still need <a id="_idIndexMarker466"/>to define an incident response playbook as part of your DevOps. This playbook should include a detailed plan of what should be executed in each scenario. For example, a response to a natural disaster is likely different from a response to a data breach incident. The playbook needs to have different scenarios and a list of roles and procedures that need to be taken to prevent or minimize system interruptions or <span class="No-Break">data loss.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Summary</h1>
			<p>For MSA systems to achieve the goals for which they were created, a certain set of methodologies will need to go hand in hand with developing an MSA system. In this chapter, we discussed a few of the most critical practices to embrace when developing an MSA system: the Agile methodology of development, DevOps processes and practices, and CI/CD <span class="No-Break">pipeline management.</span></p>
			<p>We also discussed how important it is to set up a DevOps team for managing microservices. We have given examples of tools to use to apply and manage DevOps when building our <span class="No-Break">MSA system.</span></p>
			<p>In the next chapter, we will take our first step in building an intelligent MSA system. We will talk about Docker, what it is, and why it’s relevant. We will also create isolated and independent virtual environments using Docker and then link these environments (or containers) together to deliver a simple functional part of our <span class="No-Break">MSA system.</span></p>
</body></html>