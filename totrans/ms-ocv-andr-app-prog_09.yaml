- en: Chapter 9. Developing a Document Scanning App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 开发文档扫描应用
- en: In this chapter, we will build a document scanning app similar to Microsoft's
    Office Lens. This app could cause a huge increase in productivity. For example,
    you can write down notes on paper and then just click on the image of it, not
    worrying about aligning it with the device. Then, using some of the algorithms
    we learned in the earlier chapters, we can detect the page and just grab that
    portion of the image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个类似于微软的Office Lens的文档扫描应用。这个应用可能会大幅提高生产力。例如，你可以在纸上写下笔记，然后只需点击它的图片，无需担心与设备对齐。然后，使用我们在前面章节中学到的一些算法，我们可以检测页面并仅抓取图像的这部分。
- en: 'In this chapter, we will directly jump on to the code, and we will see the
    outputs at every step. To get an idea of what we will achieve at the end of this
    chapter, let''s take a look at the following figure. The following image shows
    a screenshot of Microsoft''s Office Lens in action:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将直接进入代码，并在每一步看到输出。为了了解本章结束时我们将实现什么，让我们看一下以下图。下面的图像显示了微软的Office Lens的实际操作截图：
- en: '![Developing a Document Scanning App](img/B02052_09_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![开发文档扫描应用](img/B02052_09_01.jpg)'
- en: Let's begin
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始
- en: First, we need to set up our Android project just like how we did in the previous
    chapters. We will use the project ID `com.masteringopencvandroid.chapter9`. We
    won't be writing any C++ code for this app as this is not a very computationally
    intensive task that relies a lot on speed. However, if you require, this project
    can be done using the native C++ code, as we did in the previous chapters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置我们的Android项目，就像我们在前面的章节中所做的那样。我们将使用项目ID `com.masteringopencvandroid.chapter9`。对于这个应用，我们不会编写任何C++代码，因为这个任务不是非常计算密集型，它依赖于速度。然而，如果你需要，这个项目可以使用我们前面章节中使用的原生C++代码来完成。
- en: 'First, we will declare the required permissions in our `AndroidManifest.xml`
    file. We will require the camera permission and the permission to save the resulting
    image to the memory for this project. So, in the manifest tag, add the following
    lines:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在我们的 `AndroidManifest.xml` 文件中声明所需的权限。我们需要这个项目的相机权限和将结果图像保存到内存的权限。因此，在清单标签中添加以下行：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will declare the activities that we have in our project. We need only
    one activity for the purpose of demonstration. We will call it `LensActivity`.
    So, we will add the following to our application tag:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明我们项目中的活动。为了演示目的，我们只需要一个活动。我们将称之为 `LensActivity`。因此，我们将向我们的应用程序标签中添加以下内容：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we will set up our layout file. We will call it `activity_lens.xml`.
    Our layout will have two buttons: one of which can be used to call the camera
    intent of the Android system and the other one will be used to choose an image
    from a file. Then, we will process the image that is returned by the system to
    detect and extract the page from the image. It will also have an `ImageView` tag
    to display the resulting image, as shown in the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置我们的布局文件。我们将称之为 `activity_lens.xml`。我们的布局将有两个按钮：一个可以用来调用Android系统的相机意图，另一个将用于从文件中选择图像。然后，我们将处理系统返回的图像以检测和提取图像中的页面。它还将有一个
    `ImageView` 标签来显示结果图像，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have our layout ready, we can dive deep into the Java code. In the
    next section, we will see a step-by-step explanation of the algorithm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了布局，我们可以深入到Java代码中。在下一节中，我们将看到算法的逐步解释。
- en: The algorithm
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法
- en: In this section, let's look at the steps we will take to achieve our results.
    Our first task is to detect the paper from the background. For this, we will apply
    the k-means algorithm with two cluster centers. With the two cluster centers,
    we can detect which one of them represents the page and which one corresponds
    to the background, and create a binary image.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看我们将采取的步骤以实现我们的结果。我们的第一个任务是检测纸张与背景。为此，我们将应用具有两个聚类中心的k-means算法。通过这两个聚类中心，我们可以检测哪一个代表页面，哪一个对应于背景，并创建一个二值图像。
- en: Now, we will use the cluster representing the paper and try to remove some noise
    and fill in some gaps with morphological opening and closing using a rectangular
    kernel.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用代表纸张的聚类并尝试使用矩形核进行形态学开闭操作来去除一些噪声和填补一些空隙。
- en: Next, we will try to find the outer boundary of the page and use it to detect
    the corners. For this, we will detect the contours in the binary image and then
    identify the contour with the largest area.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试找到页面的外边界并使用它来检测角落。为此，我们将检测二值图像中的轮廓，然后识别面积最大的轮廓。
- en: Once we have the largest contour, we will detect the lines using a probabilistic
    Hough transformation. Then, we will join the lines and detect the corners.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了最大的轮廓，我们将使用概率霍夫变换检测线条。然后，我们将连接这些线条并检测角落。
- en: Once we have the corners, we will detect which corner corresponds to which other
    corner, and then apply a perspective transformation to get just the page from
    the whole image.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了角落，我们将检测哪个角落对应于哪个其他角落，然后应用透视变换以仅从整个图像中获取页面。
- en: 'The following image shows the steps in the form of a flowchart for a quick
    reference:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下图以流程图的形式展示了快速参考的步骤：
- en: '![The algorithm](img/B02052_09_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![算法](img/B02052_09_02.jpg)'
- en: Some of the assumptions and limitations of this process are that the page has
    to be white in color and must also be easily distinguishable from the background.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的某些假设和限制是页面必须是白色的，并且必须容易与背景区分开来。
- en: Implementing on Android
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上实现
- en: 'Open the `LensActivity.java` file. First, we will declare and initialize our
    `Button` and `ImageView`. Then, will add `onClickListener` to the button. We will
    call the `ImageCapture` intent, which will open the camera app to click on the
    image as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LensActivity.java`文件。首先，我们将声明并初始化我们的`Button`和`ImageView`。然后，我们将为按钮添加`onClickListener`。我们将调用`ImageCapture`意图，这将打开相机应用以点击图片，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we will add the part where the result of these intent calls is received,
    by our activity:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加接收这些意图调用结果的代码部分，由我们的活动来处理：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we have a function called `getScaleFactor`. Due to the limited
    memory and processing power of handheld devices, we will reduce our images at
    a maximum resolution of 240x320\. The `getPage` function is where our main algorithm
    is located. In this function, we have `AsyncTask` to perform our computations,
    so as to not block our UI thread and thereby preventing Android from crashing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个名为`getScaleFactor`的函数。由于手持设备的内存和处理能力有限，我们将以最大分辨率240x320来减小我们的图像。`getPage`函数是我们主要算法所在的位置。在这个函数中，我们使用`AsyncTask`来执行我们的计算，这样就不会阻塞我们的UI线程，从而防止Android崩溃。
- en: 'First of all, we will make our image in the desired form to perform a k-means
    clustering with two clusters. The intuition behind applying k-means is that the
    background and foreground will be quite distinct from the background and most
    of the area will be occupied by the page:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使我们的图像以所需的形式呈现，以便进行具有两个聚类的k-means聚类。应用k-means的直觉是背景和前景将与背景截然不同，并且大部分区域将被页面占据：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we will apply the k-means algorithm as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将如下应用k-means算法：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we have the two cluster centers and the labels for each pixel in the original
    image. We will use the two cluster centers to detect which one corresponds to
    the paper. For this, we will find the Euclidian distance between the color of
    both the centers and the color pure white. The one which is closer to the color
    pure white will be considered as the foreground:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了两个簇中心和原始图像中每个像素的标签。我们将使用两个簇中心来检测哪一个对应于纸张。为此，我们将找到两个中心颜色和纯白色颜色之间的欧几里得距离。离纯白色颜色更近的一个将被认为是前景：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to define two Mat objects that we will use in the next step:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义两个Mat对象，我们将在下一步中使用它们：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we will perform a segmentation where we will display all the foreground
    pixels as white and all the background pixels as black:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将执行一个分割，我们将显示所有前景像素为白色，所有背景像素为黑色：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we will move on to the next step; that is, detecting contours in this
    image. First, we will apply the Canny edge detector to detect just the edges and
    then apply a contouring algorithm:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进行下一步；即检测图像中的轮廓。首先，我们将应用Canny边缘检测器来检测边缘，然后应用轮廓算法：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now make an assumption that the page occupies the biggest part of the foreground
    and so it corresponds to the biggest contour we find:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们假设页面占据了前景的最大部分，因此它对应于我们找到的最大轮廓：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we will detect the lines in this image, which contain only the biggest
    contours. We will try to find the point of intersection of these lines, and use
    this to detect the corners of the page in the image:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检测图像中的线条，这些线条只包含最大的轮廓。我们将尝试找到这些线条的交点，并使用这个点来检测图像中纸张的角：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The intersection point of the two lines made by joining the points (*x1*, *y1*)
    and (*x2*, *y2*) (forming the first line), and (*x3*, *y3*) and (*x4*, *y4*) (forming
    the second line) can be calculated using the following formula:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接点(*x1*, *y1*)和(*x2*, *y2*)（形成第一条线），以及(*x3*, *y3*)和(*x4*, *y4*)（形成第二条线）形成的两条线的交点可以使用以下公式计算：
- en: '![Implementing on Android](img/B02052_09_03.jpg)![Implementing on Android](img/B02052_09_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![在Android上实现](img/B02052_09_03.jpg)![在Android上实现](img/B02052_09_04.jpg)'
- en: If the denominator is 0, we can say that the lines are parallel.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分母为0，我们可以说这些线是平行的。
- en: 'Once we have the intersection points, we will try to remove some of the redundant
    points. For this, we say that the points need to have at least a 10-pixel gap
    between them for them to be distinct. This number should be modified when modifying
    the resolution you are working with. To check this, we have added a function called
    `exists` as shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了交点，我们将尝试移除一些冗余点。为此，我们说点之间至少需要有一个10像素的间隔，这样它们才能被认为是不同的。当修改你正在使用的分辨率时，这个数字应该被修改。为了检查这一点，我们添加了一个名为`exists`的函数，如下所示：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we will check whether we were able to detect the four corners perfectly.
    If not, the algorithm returns an error message:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查我们是否完美地检测到了四个角。如果没有，算法将返回一个错误信息：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have detected the four corners, we will try to identify their locations
    on a quadrilateral. For this, we will compare the location of each corner with
    the center of the quadrilateral, which we obtain by taking the average of the
    coordinates of each of the corners:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检测到了四个角，我们将尝试在四边形上确定它们的相对位置。为此，我们将比较每个角的位置与四边形的中心，该中心是通过取每个角坐标的平均值得到的：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we have multiplied the scale factor of the corner values, as those will
    most likely be the location of the corners in the original image. Now, we just
    want the page in the resulting image. We need to determine the size of the resulting
    image. For this, we will use the coordinates of the corners calculated in the
    earlier step:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们乘以了角值的缩放因子，因为这些很可能是原始图像中角的位置。现在，我们只想得到结果图像中的纸张。我们需要确定结果图像的大小。为此，我们将使用之前步骤中计算的角坐标：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need to use a perspective transformation to warp the image in order
    to occupy the entire image. For this, we need to create reference corners, corresponding
    to each corner in the `corners` array:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用透视变换来扭曲图像，以便占据整个图像。为此，我们需要创建参考角，对应于`corners`数组中的每个角：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice how the elements in the corners are in the same order as they are in
    `result_pts`. This is required so as to perform a proper perspective transformation.
    Next, we will perform the perspective transformation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`corners`中的元素与`result_pts`中的顺序相同。这是为了执行适当的透视变换。接下来，我们将执行透视变换：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that you have the resulting image with just the page in it, you can perform
    any more processing that is required by your application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了只包含纸张的结果图像，你可以执行应用程序所需的任何更多处理。
- en: 'All we need to do now is to display the resulting image in `ImageView`. In
    `onPostExecute`, add the following lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的只是将结果图像显示在`ImageView`中。在`onPostExecute`中添加以下行：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This ends our algorithm to segment out a page of paper from a scene and warp
    it to form a perfect rectangle. You can see the result of the algorithm on the
    images, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了从场景中分割出一张纸并扭曲成完美矩形的算法。您可以在以下屏幕截图中看到算法的结果：
- en: '![Implementing on Android](img/B02052_09_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![在Android上实现](img/B02052_09_05.jpg)'
- en: The original image (L) and the resulting image (R)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像（L）和结果图像（R）
- en: Summary
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how we could use multiple computer vision algorithms
    to perform a bigger task and implemented a system similar to Microsoft's Office
    Lens. This algorithm can be extended and made better using better segmentation
    and corner detection algorithms. Also, once you have the page in the resulting
    image, you can apply machine learning algorithms to detect the text on the page.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用多个计算机视觉算法来完成更大的任务，并实现了一个类似于微软的Office Lens的系统。这个算法可以通过更好的分割和角点检测算法进行扩展和改进。此外，一旦你得到了最终图像中的页面，你就可以应用机器学习算法来检测页面上的文本。
