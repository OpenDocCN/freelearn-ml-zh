<html><head></head><body><div class="calibre1" title="Chapter&#xA0;2.&#xA0;Manipulating Pixels"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title"><a id="ch02" class="calibre6"/>Chapter 2. Manipulating Pixels</h1></div></div></div><p class="calibre8">In this chapter, we will cover the following recipes:</p><div class="calibre1"><ul class="itemizedlist"><li class="listitem">Accessing pixel values</li><li class="listitem">Scanning an image with pointers</li><li class="listitem">Scanning an image with iterators</li><li class="listitem">Writing efficient image-scanning loops</li><li class="listitem">Scanning an image with neighbor access</li><li class="listitem">Performing simple image arithmetic</li><li class="listitem">Remapping an image</li></ul></div><div class="calibre1" title="Introduction"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch02lvl1sec13" class="calibre6"/>Introduction</h1></div></div></div><p class="calibre8">In order to build computer vision applications, you need to be able to access the image content and eventually modify or create images. This chapter will teach you how to manipulate the picture elements (also known as <span><strong class="calibre15">pixels</strong></span>). You will learn how to scan an image and process each of its pixels. You will also learn how to do this efficiently, since even images of modest dimensions can contain hundreds of thousands of pixels.</p><p class="calibre8">Fundamentally, an image is a matrix of numerical values. This is why, as we learned in <a href="ch01.html" title="Chapter 1. Playing with Images">
Chapter 1
</a>, <span><em class="calibre16">Playing with Images</em></span>, OpenCV manipulates them using the <code class="literal">cv::Mat</code> data structure. Each element of the matrix represents one pixel. For a gray-level image (a black-and-white image), pixels are unsigned 8-bit values (that is, of type <code class="literal">unsigned char</code>) where <code class="literal">0</code> corresponds to black and <code class="literal">255</code> corresponds to white.</p><p class="calibre8">In the case of color images, three primary color values are required in order to reproduce the different visible colors. This is a consequence of the fact that our human visual system is trichromatic; three types of cone cells on our retinae convey the color information to our brain. This means that for a color image, three values must be associated to each pixel. In photography and digital imaging, the commonly used primary color channels are red, green, and blue. A matrix element is, therefore, made of a triplet of 8-bit values in this case. Note that even if 8-bit channels are generally sufficient, there are specialized applications where 16-bit channels are required (medical imaging, for example).</p><p class="calibre8">As we saw in the previous chapter, OpenCV also allows you to create matrices (or images) with pixel values of other types, for example, integer (<code class="literal">CV_32U</code> or <code class="literal">CV_32S</code>) and floating point (<code class="literal">CV_32F</code>) numbers. These are very useful to store, for example, intermediate values in some image-processing tasks. Most operations can be applied on matrices of any type; others require a specific type or work only with a given number of channels. Therefore, a good understanding of a function's precondition is essential in order to avoid common programming errors.</p><p class="calibre8">Throughout this chapter, we use the following color image as the input (refer to the book's graphics PDF or to the book's website to view this image in color):</p><p class="calibre8">
</p><div class="mediaobject"><img alt="Introduction" src="graphics/image_02_001.jpg" class="calibre17"/></div><p class="calibre8">
</p></div></div>
<div class="calibre1" title="Accessing pixel values"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch02lvl1sec14" class="calibre6"/>Accessing pixel values</h1></div></div></div><p class="calibre8">In order to access each individual element of a matrix, you just need to specify its row and column numbers. The corresponding element, which can be a single numerical value or a vector of values in the case of a multi-channel image, will be returned.</p><div class="calibre1" title="Getting ready"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec32" class="calibre6"/>Getting ready</h2></div></div></div><p class="calibre8">To illustrate the direct access to pixel values, we will create a simple function that adds <span><strong class="calibre15">salt-and-pepper</strong></span> noise to an image. As the name suggests, salt-and-pepper noise is a particular type of noise in which some randomly selected pixels are replaced by a white or a black pixel. This type of noise can occur in faulty communications when the value of some pixels is lost during the transmission. In our case, we will simply randomly select a few pixels and assign them a white color.</p></div><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec33" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">We create a function that receives an input image. This is the image that will be modified by our function. The second parameter is the number of pixels on which we want to overwrite white values:</p><pre class="programlisting">    void salt(cv::Mat image, int n) { 
 
      // C++11 random number generator 
      std::default_random_engine generator; 
      std::uniform_int_distribution&lt;int&gt;  
                   randomRow(0, image.rows - 1); 
      std::uniform_int_distribution&lt;int&gt;  
                   randomCol(0, image.cols - 1); 
 
      int i,j; 
      for (int k=0; k&lt;n; k++) { 
 
        // random image coordinate 
        i= randomCol(generator); 
        j= randomRow(generator); 
  
        if (image.type() == CV_8UC1) { // gray-level image 
 
          // single-channel 8-bit image 
          image.at&lt;uchar&gt;(j,i)= 255;  
  
        } else if (image.type() == CV_8UC3) { // color image 
 
          // 3-channel image 
          image.at&lt;cv::Vec3b&gt;(j,i)[0]= 255;  
          image.at&lt;cv::Vec3b&gt;(j,i)[1]= 255;  
          image.at&lt;cv::Vec3b&gt;(j,i)[2]= 255;  
        } 
      } 
    } 
</pre><p class="calibre8">The preceding function is made of a single loop that assigns <code class="literal">n</code> times the value <code class="literal">255</code> to randomly selected pixels. Here, the pixel column <code class="literal">i</code> and row <code class="literal">j</code> are selected using a random number generator. Note that using the <code class="literal">type</code> method, we distinguish the two cases of gray-level and color images. In the case of a gray-level image, the number <code class="literal">255</code> is assigned to the single 8-bit value. For a color image, you need to assign <code class="literal">255</code> to the three primary color channels in order to obtain a white pixel.</p><p class="calibre8">You can call this function by passing it an image you have previously opened. Refer to the following code:</p><pre class="programlisting">      // open the image 
      cv::Mat image= cv::imread("boldt.jpg",1); 
   
      // call function to add noise 
      salt(image,3000); 
 
      // display result 
      cv::namedWindow("Image"); 
      cv::imshow("Image",image); 
</pre><p class="calibre8">The resulting image will look as follows:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_02_002.jpg" class="calibre17"/></div><p class="calibre8">
</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec34" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">The <code class="literal">cv::Mat</code> class includes several methods to access the different attributes of an image. The public member variables, <code class="literal">cols</code> and <code class="literal">rows</code>, give you the number of columns and rows in the image. For element access, <code class="literal">cv::Mat</code> has the <code class="literal">at (int y, int x)</code> method, in which <code class="literal">x</code> is the column number and <code class="literal">y</code> is the row number. However, the type returned by a method must be known at compile time, and since <code class="literal">cv::Mat</code> can hold elements of any type, the programmer needs to specify the return type that is expected. This is why the <code class="literal">at</code> method has been implemented as a template method. So, when you call it, you must specify the image element type as follows:</p><pre class="programlisting">         image.at&lt;uchar&gt;(j,i)= 255; 
</pre><p class="calibre8">It is important to note that it is the programmer's responsibility to make sure that the type specified matches the type contained in the matrix. The <code class="literal">at</code> method does not perform any type conversion.</p><p class="calibre8">In color images, each pixel is associated with three components: the red, green, and blue channels. Therefore, a <code class="literal">cv::Mat</code> class that contains a color image will return a vector of three 8-bit values. OpenCV has defined a type for such short vectors, and it is called <code class="literal">cv::Vec3b</code>. This is a vector of three unsigned characters. This explains why the element access to the pixels of a color pixel is written as follows:</p><pre class="programlisting">    image.at&lt;cv::Vec3b&gt;(j,i)[channel]= value; 
</pre><p class="calibre8">The <code class="literal">channel</code> index designates one of the three color channels. OpenCV stores the <code class="literal">channel</code> values in the order blue, green, and red (blue is, therefore, channel <code class="literal">0</code>). You can also use the short vector data structure directly and write:</p><pre class="programlisting">    image.at&lt;cv::Vec3b&gt;(j, i) = cv::Vec3b(255, 255, 255); 
</pre><p class="calibre8">Similar vector types also exist for 2-element and 4-element vectors (<code class="literal">cv::Vec2b</code> and <code class="literal">cv::Vec4b</code>) as well as for other element types. For example, for a 2-element float vector, the last letter of the type name would be replaced by an <code class="literal">f</code>, that is, <code class="literal">cv::Vec2f</code>. In the case of a short integer, the last letter is replaced with <code class="literal">s</code>. This letter is an <code class="literal">i</code> for an integer, and a <code class="literal">d</code> for a double precision floating point vector. All of these types are defined using the <code class="literal">cv::Vec&lt;T,N&gt;</code> template class, where <code class="literal">T</code> is the type and <code class="literal">N</code> is the number of vector elements.</p><p class="calibre8">As a last note, you might have been surprised by the fact that our image-modifying function uses a pass-by-value image parameter. This works because when images are copied, they still share the same image data. So, you do not necessarily have to transmit images by references when you want to modify their content. Incidentally, pass-by-value parameters often make code optimization easier for the compiler.</p></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec35" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">The <code class="literal">cv::Mat</code> class has been made generic by defining it using C++ templates.</p><div class="calibre1" title="The cv::Mat_ template class"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch02lvl3sec7" class="calibre6"/>The cv::Mat_ template class</h3></div></div></div><p class="calibre8">Using the <code class="literal">at</code> method of the <code class="literal">cv::Mat</code> class can sometimes be cumbersome because the returned type must be specified as a template argument in each call. In cases where the matrix type is known, it is possible to use the <code class="literal">cv::Mat_</code> class, which is a template subclass of <code class="literal">cv::Mat</code>. This class defines a few extra methods but no new data attributes so that pointers or references to one class can be directly converted to another class. Among the extra methods, there is <code class="literal">operator()</code>, which allows direct access to matrix elements. Therefore, if image is a <code class="literal">cv::Mat</code> variable that corresponds to a <code class="literal">uchar</code> matrix, then you can write the following code:</p><pre class="programlisting">    // use image with a Mat_ template 
    cv::Mat_&lt;uchar&gt; img(image); 
    img(50,100)= 0; // access to row 50 and column 100 
</pre><p class="calibre8">Since the type of the <code class="literal">cv::Mat_</code> elements is declared when the variable is created, the <code class="literal">operator()</code> method knows at compile time which type is to be returned. Other than the fact that it is shorter to write, using the <code class="literal">operator()</code> method provides exactly the same result as the <code class="literal">at</code> method.</p></div></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec36" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The <span><em class="calibre16">There's more...</em></span> section of the <span><em class="calibre16">Scanning an image with pointers</em></span> recipe explains how to create a function with input and output parameters</li><li class="listitem">The <span><em class="calibre16">Writing efficient image-scanning loops</em></span> recipe proposes a discussion on the efficiency of the <code class="literal">at</code> method</li></ul></div></div></div>
<div class="calibre1" title="Scanning an image with pointers"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch02lvl1sec15" class="calibre6"/>Scanning an image with pointers</h1></div></div></div><p class="calibre8">In most image-processing tasks, you need to scan all pixels of the image in order to perform a computation. Considering the large number of pixels that will need to be visited, it is essential that you perform this task in an efficient way. This recipe, and the next one, will show you different ways of implementing efficient scanning loops. This recipe uses the pointer arithmetic.</p><div class="calibre1" title="Getting ready"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec37" class="calibre6"/>Getting ready</h2></div></div></div><p class="calibre8">We will illustrate the image-scanning process by accomplishing a simple task: reducing the number of colors in an image.</p><p class="calibre8">Color images are composed of 3-channel pixels. Each of these channels corresponds to the intensity value of one of the three primary colors, red, green, and blue. Since each of these values is an 8-bit unsigned character, the total number of colors is <code class="literal">256x256x256</code>, which is more than 16 million colors. Consequently, to reduce the complexity of an analysis, it is sometimes useful to reduce the number of colors in an image. One way to achieve this goal is to simply subdivide the RGB space into cubes of equal sizes. For example, if you reduce the number of colors in each dimension by <code class="literal">8</code>, then you would obtain a total of <code class="literal">32x32x32</code> colors. Each color in the original image is then assigned a new color value in the color-reduced image that corresponds to the value in the center of the cube to which it belongs.</p><p class="calibre8">Therefore, the basic color reduction algorithm is simple. If <code class="literal">N</code> is the reduction factor, divide by <code class="literal">N</code> the value of each pixel (integer division is assumed here, therefore, the reminder is lost) then multiply the result by <code class="literal">N</code>. This will give you the multiple of <code class="literal">N</code> just below the input pixel value. Add <code class="literal">N/2</code> and you obtain the central position of the interval between two adjacent multiples of <code class="literal">N</code>. If you repeat this process for each 8-bit channel value, then you will obtain a total of <code class="literal">256/N x 256/N x 256/N</code> possible color values.</p></div><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec38" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">The signature of our color reduction function will be as follows:</p><pre class="programlisting">    void colorReduce(cv::Mat image, int div=64); 
</pre><p class="calibre8">The user provides an image and the per-channel reduction factor. Here, the processing is done in-place, that is, the pixel values of the input image are modified by the function. See the <span><em class="calibre16">There's more...</em></span> section of this recipe for a more general function signature with input and output arguments.</p><p class="calibre8">The processing is simply done by creating a double loop that goes over all pixel values as follows:</p><pre class="programlisting">    void colorReduce(cv::Mat image, int div=64) { 
 
      int nl= image.rows; // number of lines 
      // total number of elements per line 
      int nc= image.cols * image.channels();  
              
      for (int j=0; j&lt;nl; j++) { 
 
        // get the address of row j 
        uchar* data= image.ptr&lt;uchar&gt;(j); 
 
        for (int i=0; i&lt;nc; i++) { 
 
          // process each pixel --------------------- 
 
          data[i]= data[i]/div*div + div/2; 
 
          // end of pixel processing ---------------- 
    
        } // end of line 
      } 
    } 
</pre><p class="calibre8">This function can be tested using the following code snippet:</p><pre class="programlisting">    // read the image 
    image= cv::imread("boldt.jpg"); 
    // process the image 
    colorReduce(image,64); 
    // display the image 
    cv::namedWindow("Image"); 
    cv::imshow("Image",image); 
</pre><p class="calibre8">This will give you, for example, the following image:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_02_003.jpg" class="calibre17"/></div><p class="calibre8">
</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec39" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">In a color image, the first three bytes of the image data buffer are the 3 channel values of the upper-left pixel, the next three bytes are the values of the second pixel of the first row, and so on (remember that OpenCV uses, by default, the BGR channel order). An image of width <code class="literal">W</code> and height <code class="literal">H</code> would then require a memory block of <code class="literal">WxHx3</code> uchars. However, for efficiency reasons, the length of a row can be padded with a few extra pixels. This is because image processing can sometimes be made more efficient when rows are multiples of 8 for example; this way they better align with the local memory configuration. Obviously, these extra pixels are not displayed or saved; their exact values are ignored. OpenCV designates the length of a padded row as the effective width. Obviously, if the image has not been padded with extra pixels, the effective width will be equal to the real image width. We have already learned that the <code class="literal">cols</code> and <code class="literal">rows</code> attributes give you the image's width and height; similarly, the step data attribute gives you the effective width in number of bytes. Even if your image is of a type other than <code class="literal">uchar</code>, the step data will still give you the number of bytes in a row. The size of a pixel element is given by the <code class="literal">elemSize</code> method (for example, for a 3-channel short integer matrix (<code class="literal">CV_16SC3</code>), <code class="literal">elemSize</code> will return <code class="literal">6</code>). Recall that the number of channels in the image is given by the <code class="literal">nchannels</code> method (which will be <code class="literal">1</code> for a gray-level image and <code class="literal">3</code> for a color image). Finally, the <code class="literal">total</code> method returns the total number of pixels (that is, the matrix entries) in the matrix.</p><p class="calibre8">The number of pixel values per row is then given by the following code:</p><pre class="programlisting">    int nc= image.cols * image.channels(); 
</pre><p class="calibre8">To simplify the computation of the pointer arithmetic, the <code class="literal">cv::Mat</code> class offers a method that directly gives you the starting address of an image row. This is the <code class="literal">ptr</code> method. It is a template method that returns the address of row number <code class="literal">j</code>:</p><pre class="programlisting">    uchar* data= image.ptr&lt;uchar&gt;(j); 
</pre><p class="calibre8">Note that in the processing statement, we could have equivalently used the pointer arithmetic to move from column to column. So, we could have written the following code:</p><pre class="programlisting">    *data++= *data/div*div + div2;  
</pre></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec40" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">The color reduction function presented in this recipe provides just one way of accomplishing this task. You could also use other color reduction formulas. A more general version of the function would also allow the specification of distinct input and output images. The image scanning can also be made more efficient by taking into account the continuity of the image data. Finally, it is also possible to use regular low-level pointer arithmetic to scan the image buffer. All of these elements are discussed in the following subsections.</p><div class="calibre1" title="Other color reduction formulas"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch02lvl3sec8" class="calibre6"/>Other color reduction formulas</h3></div></div></div><p class="calibre8">In our example, color reduction is achieved by taking advantage of integer division that floors the division result to the nearest lower integer as follows:</p><pre class="programlisting">    data[i]= (data[i]/div)*div + div/2; 
</pre><p class="calibre8">The reduced color could have also been computed from the modulo operator using which we can obtain the multiple of <code class="literal">div</code> immediately below as follows:</p><pre class="programlisting">    data[i]= data[i] - data[i]%div + div/2; 
</pre><p class="calibre8">Another option would be to use bitwise operators. Indeed, if we restrict the reduction factor to a power of <code class="literal">2</code>, that is, <code class="literal">div=pow(2,n)</code>, then masking the first <code class="literal">n</code> bits of the pixel value would give us the nearest lower multiple of <code class="literal">div</code>. This mask would be computed by a simple bit shift as follows:</p><pre class="programlisting">    // mask used to round the pixel value 
    uchar mask= 0xFF&lt;&lt;n; // e.g. for div=16, mask= 0xF0 
</pre><p class="calibre8">The color reduction would be given by the following code:</p><pre class="programlisting">    *data &amp;= mask;      // masking 
    *data++ += div&gt;&gt;1;  // add div/2;  
    // bitwise OR could also be used above instead of + 
</pre><p class="calibre8">In general, bitwise operations might lead to very efficient code, so they could constitute a powerful alternative when efficiency is a requirement.</p></div><div class="calibre1" title="Having input and output arguments"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch02lvl3sec9" class="calibre6"/>Having input and output arguments</h3></div></div></div><p class="calibre8">In our color reduction example, the transformation is directly applied to the input image, which is called an in-place transformation. This way, no extra image is required to hold the output result, which could save on the memory usage when this is a concern. However, in some applications, the user might want to keep the original image intact. The user would then be forced to create a copy of the image before calling the function. Note that the easiest way to create an identical deep copy of an image is to call the <code class="literal">clone()</code> method; for example, take a look at the following code:</p><pre class="programlisting">    // read the image 
    image= cv::imread("boldt.jpg"); 
    // clone the image 
    cv::Mat imageClone= image.clone(); 
    // process the clone 
    // orginal image remains untouched 
    colorReduce(imageClone); 
    // display the image result 
    cv::namedWindow("Image Result"); 
    cv::imshow("Image Result",imageClone); 
</pre><p class="calibre8">This extra overhead can be avoided by defining a function that gives the user the option to either use or not use in-place processing. The signature of the method would then be as follows:</p><pre class="programlisting">  void colorReduce(const cv::Mat &amp;image, // input image  
                   cv::Mat &amp;result,      // output image 
                   int div=64); 
</pre><p class="calibre8">Note that the input image is now passed as a <code class="literal">const</code> reference, which means that this image will not be modified by the function. The output image is passed as a reference such that the calling function will see the output argument modified by this call. When in-place processing is preferred, the same image is specified as the input and output:</p><pre class="programlisting">    colorReduce(image,image); 
</pre><p class="calibre8">If not, another <code class="literal">cv::Mat</code> instance can be provided:</p><pre class="programlisting">    cv::Mat result;    
    colorReduce(image,result); 
</pre><p class="calibre8">The key here is to first verify whether the output image has an allocated data buffer with a size and pixel type that matches the one of the input image. Very conveniently, this check is encapsulated inside the <code class="literal">create</code> method of <code class="literal">cv::Mat</code>. This is the method that is to be used when a matrix must be reallocated with a new size and type. If, by chance, the matrix already has the size and type specified, then no operation is performed and the method simply returns without touching the instance.</p><p class="calibre8">Therefore, our function should simply start with a call to <code class="literal">create</code> that builds a matrix (if necessary) of the same size and type as the input image:</p><pre class="programlisting">    result.create(image.rows,image.cols,image.type()); 
</pre><p class="calibre8">The allocated memory block has a size of <code class="literal">total()*elemSize()</code>. The scanning is then done with two pointers:</p><pre class="programlisting">    for (int j=0; j&lt;nl; j++) { 
 
      // get the addresses of input and output row j 
      const uchar* data_in= image.ptr&lt;uchar&gt;(j); 
      uchar* data_out= result.ptr&lt;uchar&gt;(j); 
 
      for (int i=0; i&lt;nc*nchannels; i++) { 
 
        // process each pixel --------------------- 
 
        data_out[i]= data_in[i]/div*div + div/2; 
 
        // end of pixel processing ---------------- 
 
      } // end of line 
    } 
</pre><p class="calibre8">In cases where the same image is provided as the input and output, this function becomes completely equivalent to the first version presented in this recipe. If another image is provided as the output, the function will work correctly, irrespective of whether the image has or has not been allocated prior to the function call.</p><p class="calibre8">Finally, note that the two parameters of this new function could have been declared as <code class="literal">cv::InputArray</code> and <code class="literal">cv::OutputArray</code>. As discussed in <a href="ch01.html" title="Chapter 1. Playing with Images">
Chapter 1
</a>, <span><em class="calibre16">Playing with Images</em></span>, these would provide the same behavior but bring extra flexibility in terms of the argument type they can accept.</p></div><div class="calibre1" title="Efficient scanning of continuous images"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch02lvl3sec10" class="calibre6"/>Efficient scanning of continuous images</h3></div></div></div><p class="calibre8">We previously explained that, for efficiency reasons, an image can be padded with extra pixels at the end of each row. However, it is interesting to note that when the image is unpadded, it can also be seen as a long one-dimensional array of <code class="literal">WxH</code> pixels. A convenient <code class="literal">cv::Mat</code> method can tell us whether the image has been padded or not. This is the <code class="literal">isContinuous</code> method that returns <code class="literal">true</code> if the image does not include padded pixels. Note that we could also check the continuity of the matrix by writing the following test:</p><pre class="programlisting">    // check if size of a line (in bytes) 
    // equals the number of columns times pixel size in bytes 
    image.step == image.cols*image.elemSize(); 
</pre><p class="calibre8">To be complete, this test should also check whether the matrix has only one line; in which case, it is continuous by definition. Nevertheless, always use the <code class="literal">isContinuous</code> method to test the continuity condition. In some specific processing algorithms, you can take advantage of the continuity of the image by processing it in one single (longer) loop. Our processing function would then be written as follows:</p><pre class="programlisting">    void colorReduce(cv::Mat image, int div=64) { 
 
      int nl= image.rows; // number of lines 
      // total number of elements per line 
      int nc= image.cols * image.channels();  
 
      if (image.isContinuous())  { 
        // then no padded pixels 
        nc= nc*nl; 
        nl= 1;  // it is now a 1D array 
      } 
   
        int n= staic_cast&lt;int&gt;( 
          log(static_cast&lt;double&gt;(div))/log(2.0) + 0.5); 
        // mask used to round the pixel value 
        uchar mask= 0xFF&lt;&lt;n; // e.g. for div=16, mask= 0xF0 
        uchar div2 = div &gt;&gt; 1; // div2 = div/2 
 
        // this loop is executed only once 
        // in case of continuous images 
        for (int j=0; j&lt;nl; j++) { 
 
          uchar* data= image.ptr&lt;uchar&gt;(j); 
 
          for (int i=0; i&lt;nc; i++) { 
 
            *data &amp;= mask; 
            *data++ += div2; 
          } // end of line 
        } 
    } 
</pre><p class="calibre8">Now, when the continuity test tells us that the image does not contain padded pixels, we eliminate the outer loop by setting the width to <code class="literal">1</code> and the height to <code class="literal">WxH</code>. Note that there is also a <code class="literal">reshape</code> method that could have been used here. You would write the following in this case:</p><pre class="programlisting">      if (image.isContinuous())  
      { 
        // no padded pixels 
        image.reshape(1,   // new number of channels 
                      1);  // new number of rows 
      } 
 
      int nl= image.rows; // number of lines 
      int nc= image.cols * image.channels();  
</pre><p class="calibre8">The <code class="literal">reshape()</code> method changes the matrix dimensions without requiring any memory copying or reallocation. The first parameter is the new number of channels and the second one is the new number of rows. The number of columns is readjusted accordingly.</p><p class="calibre8">In these implementations, the inner loop processes all image pixels in a sequence.</p></div><div class="calibre1" title="Low-level pointer arithmetic"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch02lvl3sec11" class="calibre6"/>Low-level pointer arithmetic</h3></div></div></div><p class="calibre8">In the <code class="literal">cv::Mat</code> class, the image data is contained in a memory block of unsigned chars. The address of the first element of this memory block is given by the data attribute that returns an unsigned char pointer. So, to start your loop at the beginning of the image, you could have written the following code:</p><pre class="programlisting">    uchar *data= image.data; 
</pre><p class="calibre8">And moving from one row to the next could have been done by moving your row pointer using the effective width as follows:</p><pre class="programlisting">    data+= image.step;  // next line 
</pre><p class="calibre8">The <code class="literal">step</code> attribute gives you the total number of bytes (including the padded pixels) in a line. In general, you can obtain the address of the pixel at row <code class="literal">j</code> and column <code class="literal">i</code> as follows:</p><pre class="programlisting">    // address of pixel at (j,i) that is &amp;image.at(j,i)      
    data= image.data+j*image.step+i*image.elemSize();     
</pre><p class="calibre8">However, even if this would work in our example, it is not recommended that you proceed this way.</p></div></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec41" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The <span><em class="calibre16">Writing efficient image-scanning loops</em></span> recipe in this chapter proposes a discussion on the efficiency of the scanning methods presented here</li><li class="listitem">The <span><em class="calibre16">Exploring the cv::Mat data structure</em></span> recipe in <a href="ch01.html" title="Chapter 1. Playing with Images">
Chapter 1
</a>, <span><em class="calibre16">Playing with Images</em></span> contains more information on the attributes and methods of the <code class="literal">cv::Mat</code> class. It also discusses the related classes such as the <code class="literal">cv::InputArray</code> and <code class="literal">cv::OutputArray</code> classes.</li></ul></div></div></div>
<div class="calibre1" title="Scanning an image with iterators"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch02lvl1sec16" class="calibre6"/>Scanning an image with iterators</h1></div></div></div><p class="calibre8">In object-oriented programming, looping over a data collection is usually done using iterators. Iterators are specialized classes that are built to go over each element of a collection, hiding how the iteration over each element is specifically done for a given collection. This application of the information-hiding principle makes scanning a collection easier and safer. In addition, it makes it similar in form no matter what type of collection is used. The <span><strong class="calibre15">Standard Template Library</strong></span> (<span><strong class="calibre15">STL</strong></span>) has an iterator class associated with each of its collection classes. OpenCV then offers a <code class="literal">cv::Mat</code> iterator class that is compatible with the standard iterators found in the C++ STL.</p><div class="calibre1" title="Getting ready"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec42" class="calibre6"/>Getting ready</h2></div></div></div><p class="calibre8">In this recipe, we again use the color reduction example described in the previous recipe.</p></div><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec43" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">An iterator object for a <code class="literal">cv::Mat</code> instance can be obtained by first creating a <code class="literal">cv::MatIterator_</code> object. As is the case with <code class="literal">cv::Mat_</code>, the underscore indicates that this is a template subclass. Indeed, since image iterators are used to access the image elements, the return type must be known at the time of compilation. The iterator for a color image is then declared as follows:</p><pre class="programlisting">      cv::MatIterator_&lt;cv::Vec3b&gt; it; 
</pre><p class="calibre8">Alternatively, you can also use the <code class="literal">iterator</code> type defined inside the <code class="literal">Mat_</code> template class as follows:</p><pre class="programlisting">     cv::Mat_&lt;cv::Vec3b&gt;::iterator it; 
</pre><p class="calibre8">You then loop over the pixels using the usual <code class="literal">begin</code> and <code class="literal">end</code> iterator methods, except that these ones are, again, template methods. Consequently, our color reduction function is now written as follows:</p><pre class="programlisting">    void colorReduce(cv::Mat image, int div=64) { 
  
      // div must be a power of 2 
      int n= staic_cast&lt;int&gt;( 
    log(static_cast&lt;double&gt;(div))/log(2.0) + 0.5); 
      // mask used to round the pixel value 
      uchar mask= 0xFF&lt;&lt;n; // e.g. for div=16, mask= 0xF0 
      uchar div2 = div &gt;&gt; 1; // div2 = div/2 
   
      // get iterators 
      cv::Mat_&lt;cv::Vec3b&gt;::iterator it= image.begin&lt;cv::Vec3b&gt;(); 
      cv::Mat_&lt;cv::Vec3b&gt;::iterator itend= image.end&lt;cv::Vec3b&gt;(); 
 
      // scan all pixels 
      for ( ; it!= itend; ++it) { 
 
        (*it)[0]&amp;= mask; 
        (*it)[0]+= div2; 
        (*it)[1]&amp;= mask; 
        (*it)[1]+= div2; 
        (*it)[2]&amp;= mask; 
        (*it)[2]+= div2; 
      } 
    } 
</pre><p class="calibre8">Remember that the iterator here returns a <code class="literal">cv::Vec3b</code> instance because we are processing a color image. Each color channel element is accessed using the dereferencing operator <code class="literal">[]</code>. Note that you could also rely on the <code class="literal">cv::Vec3b</code> overloaded operators and simply write:</p><pre class="programlisting">      *it= *it/div*div+offset; 
</pre><p class="calibre8">This will apply the operations on each element of the short vector.</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec44" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">Working with iterators always follows the same pattern no matter what kind of collection is scanned.</p><p class="calibre8">First, you create your iterator object using the appropriate specialized class, which in our example is <code class="literal">cv::Mat_&lt;cv::Vec3b&gt;::iterator</code> (or <code class="literal">cv::MatIterator_&lt;cv::Vec3b&gt;</code>).</p><p class="calibre8">You then obtain an iterator initialized at the starting position (in our example, the upper-left corner of the image). This is done using a <code class="literal">begin</code> method. With a <code class="literal">cv::Mat</code> instance of a color image, you obtain it as <code class="literal">image.begin&lt;cv::Vec3b&gt;()</code>. You can also use arithmetic on the iterator. For example, if you wish to start at the second row of an image, you can initialize your <code class="literal">cv::Mat</code> iterator at <code class="literal">image.begin&lt;cv::Vec3b&gt;()+image.cols</code>. The end position of your collection is obtained similarly but using the <code class="literal">end</code> method. However, the iterator thus obtained is just outside your collection. This is why your iterative process must stop when it reaches the end position. You can also use arithmetic on this iterator; for example, if you wish to stop before the last row, your final iteration would stop when the iterator reaches <code class="literal">image.end&lt;cv::Vec3b&gt;()-image.cols</code>.</p><p class="calibre8">Once your iterator is initialized, you create a loop that goes over all elements until the end is reached. A typical <code class="literal">while</code> loop will look like the following code:</p><pre class="programlisting">    while (it!= itend) {  
 
      // process each pixel --------------------- 
 
      ... 
 
      // end of pixel processing ---------------- 
 
      ++it; 
    } 
</pre><p class="calibre8">The <code class="literal">++</code> operator is the one that is to be used to move to the next element. You can also specify a larger step size. For example, <code class="literal">it+=10</code> would process the image every <code class="literal">10</code> pixels.</p><p class="calibre8">Finally, inside the processing loop, you use the dereferencing <code class="literal">operator*</code> in order to access the current element, using which, you can read (for example, <code class="literal">element= *it;</code>) or write (for example, <code class="literal">*it= element;</code>). Note that it is also possible to create constant iterators that you use if you receive a reference to <code class="literal">const cv::Mat</code> or if you wish to signify that the current loop does not modify the <code class="literal">cv::Mat</code> instance. These are declared as follows:</p><pre class="programlisting">    cv::MatConstIterator_&lt;cv::Vec3b&gt; it; 
</pre><p class="calibre8">Or, they can be declared as follows:</p><pre class="programlisting">    cv::Mat_&lt;cv::Vec3b&gt;::const_iterator it; 
</pre></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec45" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">In this recipe, the start and end positions of the iterator were obtained using the <code class="literal">begin</code> and <code class="literal">end</code> template methods. As we did in the first recipe of this chapter, we could have also obtained them using a reference to a <code class="literal">cv::Mat_</code> instance. This would avoid the need to specify the iterator type in the <code class="literal">begin</code> and <code class="literal">end</code> methods since this one is specified when the <code class="literal">cv::Mat_</code> reference is created.</p><pre class="programlisting">    cv::Mat_&lt;cv::Vec3b&gt; cimage(image); 
    cv::Mat_&lt;cv::Vec3b&gt;::iterator it= cimage.begin(); 
    cv::Mat_&lt;cv::Vec3b&gt;::iterator itend= cimage.end(); 
</pre></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec46" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The <span><em class="calibre16">Writing efficient image-scanning loops</em></span> recipe proposes a discussion on the efficiency of iterators when scanning an image.</li><li class="listitem">Also, if you are not familiar with the concept of iterators in object-oriented programming and how they are implemented in ANSI C++, you should read a tutorial on STL iterators. Simply search the Web with the keywords <span><strong class="calibre15">STL Iterator</strong></span> and you will find numerous references on the subject.</li></ul></div></div></div>
<div class="calibre1" title="Writing efficient image-scanning loops"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch02lvl1sec17" class="calibre6"/>Writing efficient image-scanning loops</h1></div></div></div><p class="calibre8">In the previous recipes of this chapter, we presented different ways of scanning an image in order to process its pixels. In this recipe, we will compare the efficiency of these different approaches.</p><p class="calibre8">When you write an image-processing function, efficiency is often a concern. When you design your function, you will frequently need to check the computational efficiency of your code in order to detect any bottleneck in your processing that might slow down your program.</p><p class="calibre8">However, it is important to note that unless necessary, optimization should not be done at the price of reducing code clarity. Simple code is indeed, always easier to debug and maintain. Only code portions that are critical to a program's efficiency should be heavily optimized.</p><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec47" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">In order to measure the execution time of a function or a portion of code, there exists a very convenient OpenCV function called <code class="literal">cv::getTickCount()</code>. This function gives you the number of clock cycles that have occurred since the last time you started your computer. Since we want to evaluate the execution time, the idea is to get this number of clock cycles before and after the execution of some code. To get the execution time in seconds, we use another method, <code class="literal">cv::getTickFrequency()</code>. This gives us the number of cycles per second, assuming your CPU has a fixed frequency (which is not necessarily the case for more recent processors). The usual pattern to be used in order to obtain the computational time of a given function (or portion of code) would then be as follows:</p><pre class="programlisting">    const int64 start = cv::getTickCount(); 
    colorReduce(image); // a function call 
    // elapsed time in seconds 
    double duration = (cv::getTickCount()-start)/ 
                               cv::getTickFrequency(); 
</pre></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec48" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">The execution times of the different implementations of the <code class="literal">colorReduce</code> function from this chapter are reported here. The absolute runtime numbers would differ from one machine to another (here, we used a 2.40 GHz machine equipped with a 64-bit Intel Core i7). It is rather interesting to look at their relative difference. These results are also dependent on the specific compiler that is used to produce the executable file. Our tests report the average time to reduce the colors of our test image that has a resolution of <code class="literal">320x240</code> pixels. We performed these tests on three different configurations:</p><div class="calibre1"><ol class="orderedlist"><li class="listitem1">A 2.5 GHz machine equipped with a 64-bit Intel i5 and the Visual Studio 14 2015 compiler under Windows 10</li><li class="listitem1">A 3.6 GHz machine 64-bit Intel i7 and gcc 4.9.2 under Ubuntu Linux</li><li class="listitem1">A 2011 MacBook Pro 2.3 GHz Intel i5 and clang++ 7.0.2</li></ol></div><p class="calibre8">First, we compare the three ways of computing the color reduction as presented in the <span><em class="calibre16">There's more...</em></span> section of the <span><em class="calibre16">Scanning an image with pointers</em></span> recipe.</p><div class="informaltable"><table border="1" class="calibre9"><colgroup class="calibre10"><col class="calibre11"/><col class="calibre11"/><col class="calibre11"/><col class="calibre11"/></colgroup><tbody class="calibre12"><tr class="calibre13"><td class="calibre14">
</td><td class="calibre14">
<p class="calibre8"><span><strong class="calibre15">Configuration 1</strong></span></p>
</td><td class="calibre14">
<p class="calibre8"><span><strong class="calibre15">Configuration 2</strong></span></p>
</td><td class="calibre14">
<p class="calibre8"><span><strong class="calibre15">Configuration 3</strong></span></p>
</td></tr><tr class="calibre13"><td class="calibre14">
<p class="calibre8">Integer division</p>
</td><td class="calibre14">
<p class="calibre8">0.867 ms</p>
</td><td class="calibre14">
<p class="calibre8">0.586 ms</p>
</td><td class="calibre14">
<p class="calibre8">1.119 ms</p>
</td></tr><tr class="calibre13"><td class="calibre14">
<p class="calibre8">Modulo operator</p>
</td><td class="calibre14">
<p class="calibre8">0.774 ms</p>
</td><td class="calibre14">
<p class="calibre8">0.527 ms</p>
</td><td class="calibre14">
<p class="calibre8">1.106 ms</p>
</td></tr><tr class="calibre13"><td class="calibre14">
<p class="calibre8">Bitwise operator</p>
</td><td class="calibre14">
<p class="calibre8">0.015 ms</p>
</td><td class="calibre14">
<p class="calibre8">0.013 ms</p>
</td><td class="calibre14">
<p class="calibre8">0.066 ms</p>
</td></tr></tbody></table></div><p class="calibre8">It is interesting to observe that the formula that uses the bitwise operator is much faster than the others. The other two methods have similar running times. It is therefore important to take the time to identify the most efficient way of computing a result in an image loop, as the net impact can be very significant.</p><p class="calibre8">In a loop, you should avoid repetitive computations of values that could be precomputed instead. This consumes time, obviously. For example, it would be a bad idea to write the inner of our color reduction function as follows:</p><pre class="programlisting">    for (int i=0; i&lt;image.cols * image.channels(); i++) { 
      *data &amp;= mask; 
      *data++ += div/2; 
</pre><p class="calibre8">Indeed, in this preceding code, the loop needs to compute the total number of elements in a line and the <code class="literal">div/2</code> result again and again. A better code is then the following:</p><pre class="programlisting">    int nc= image.cols * image.channels(); 
    uchar div2= div&gt;&gt;1;  
 
    for (int i=0; i&lt;nc; i++) { 
      *(data+i) &amp;= mask; 
      *(data+i) += div2; 
</pre><p class="calibre8">On average, the code with re-computations is 10 times slower than the more optimal solution. Note, however, that some compilers might be able to optimize these kinds of loops and still obtain efficient code.</p><p class="calibre8">The version of the color reduction function that uses iterators (and bitwise operators), as shown in the <span><em class="calibre16">Scanning an image with iterators</em></span> recipe, gives slower results at 0.480 ms, 0.320 ms, and 0.655 ms for our three configurations. The main objective of iterators is to simplify the image-scanning process and make it less prone to errors.</p><p class="calibre8">For completeness, we also implemented a version of the function that uses the <code class="literal">at</code> method for pixel access. The main loop of this implementation would then simply read as follows:</p><pre class="programlisting">    for (int j=0; j&lt;nl; j++) { 
      for (int i=0; i&lt;nc; i++) { 
  
        image.at&lt;cv::Vec3b&gt;(j,i)[0]= 
               image.at&lt;cv::Vec3b&gt;(j,i)[0]/div*div + div/2; 
        image.at&lt;cv::Vec3b&gt;(j,i)[1]=     
              image.at&lt;cv::Vec3b&gt;(j,i)[1]/div*div + div/2; 
        image.at&lt;cv::Vec3b&gt;(j,i)[2]=     
              image.at&lt;cv::Vec3b&gt;(j,i)[2]/div*div + div/2; 
 
      } // end of line 
    } 
</pre><p class="calibre8">This implementation has a slower runtime of 0.925 ms, 0.580 ms, and 1.128 ms. This method should then be used only for the random access of image pixels but never when scanning an image.</p><p class="calibre8">Also, a shorter loop with few statements is generally more efficiently executed than a longer loop over a single statement, even if the total number of elements processed is the same. Similarly, if you have <code class="literal">N</code> different computations to apply to a pixel, apply all of them in one loop rather than writing <code class="literal">N</code> successive loops, one for each computation.</p><p class="calibre8">We also performed the continuity test that produces one loop in the case of continuous images instead of the regular double loop over lines and columns. We obtained a slight reduction in the runtime by an average factor of 10%. In general, it is a good practice to use this strategy, since it can lead to a significant gain in speed.</p></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec49" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">Multithreading is another way to increase the efficiency of your algorithms, especially since the advent of multicore processors. <span><strong class="calibre15">OpenMP</strong></span>, the <span><strong class="calibre15">Intel Threading Building Blocks</strong></span> (<span><strong class="calibre15">TBB</strong></span>) and <span><strong class="calibre15">Posix</strong></span> are popular APIs that are used in concurrent programming to create and manage your threads. In addition, C++11 now offers built-in support for threads.</p></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec50" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The <span><em class="calibre16">Performing simple image arithmetic</em></span> recipe presents an implementation of the color-reduction function (described in the <span><em class="calibre16">There's more...</em></span> section) that uses the OpenCV arithmetic image operators and has a runtime of 0.091 ms, 0.047 ms, and 0.087 for the three test configurations.</li><li class="listitem">The <span><em class="calibre16">Applying look-up tables to modify the image's appearance</em></span> recipe of <a href="ch04.html" title="Chapter 4. Counting the Pixels with Histograms">Chapter 4</a>, <span><em class="calibre16">Counting the Pixels with Histograms</em></span> describes an implementation of the color-reduction function based on a look-up table. The idea is to precompute all intensity reduction values that lead to a runtime of 0.129 ms, 0.098 ms, and 0.206 ms.</li></ul></div></div></div>
<div class="calibre1" title="Scanning an image with neighbor access"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch02lvl1sec18" class="calibre6"/>Scanning an image with neighbor access</h1></div></div></div><p class="calibre8">In image processing, it is common to have a processing function that computes a value at each pixel location based on the value of the neighboring pixels. When this neighborhood includes pixels of the previous and next lines, you then need to simultaneously scan several lines of the image. This recipe shows you how to do it.</p><div class="calibre1" title="Getting ready"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec51" class="calibre6"/>Getting ready</h2></div></div></div><p class="calibre8">To illustrate this recipe, we will apply a processing function that sharpens an image. It is based on the Laplacian operator (which will be discussed in 
<a href="ch06.html" title="Chapter 6. Filtering the Images">Chapter 6</a>
, <span><em class="calibre16">Filtering the Images</em></span>). It is indeed, a well-known result in image processing that if you subtract the Laplacian from an image, the image edges are amplified, thereby giving a sharper image.</p><p class="calibre8">This sharpened value is computed as follows:</p><pre class="programlisting">    sharpened_pixel= 5*current-left-right-up-down; 
</pre><p class="calibre8">Here, <code class="literal">left</code> is the pixel that is immediately on the left-hand side of the current one, <code class="literal">up</code> is the corresponding one on the previous line, and so on.</p></div><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec52" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">This time, the processing cannot be accomplished in-place. Users need to provide an output image. The image scanning is done using three pointers, one for the current line, one for the line above, and another one for the line below. Also, since each pixel computation requires access to the neighbors, it is not possible to compute a value for the pixels of the first and last row of the image as well as the pixels of the first and last column. The loop can then be written as follows:</p><pre class="programlisting">    void sharpen(const cv::Mat &amp;image, cv::Mat &amp;result) { 
 
      // allocate if necessary 
      result.create(image.size(), image.type());  
      int nchannels= image.channels(); // get number of channels 
  
      // for all rows (except first and last) 
      for (int j= 1; j&lt;image.rows-1; j++) {  
 
        const uchar* previous= image.ptr&lt;const uchar&gt;(j-1);// previous row 
        const uchar* current= image.ptr&lt;const uchar&gt;(j);   // current row 
        const uchar* next= image.ptr&lt;const uchar&gt;(j+1);    // next row 
 
        uchar* output= result.ptr&lt;uchar&gt;(j); // output row 
 
        for (int i=nchannels; i&lt;(image.cols-1)*nchannels; i++) { 
 
          // apply sharpening operator 
          *output++= cv::saturate_cast&lt;uchar&gt;( 
                  5*current[i]-current[i-nchannels]- 
                  current[i+nchannels]-previous[i]-next[i]);  
        } 
      } 
 
      // Set the unprocessed pixels to 0 
      result.row(0).setTo(cv::Scalar(0)); 
      result.row(result.rows-1).setTo(cv::Scalar(0)); 
      result.col(0).setTo(cv::Scalar(0)); 
      result.col(result.cols-1).setTo(cv::Scalar(0)); 
    } 
</pre><p class="calibre8">Note how we wrote the function such that it would work on both gray-level and color images. If we apply this function on a gray-level version of our test image, the following result is obtained:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_02_004.jpg" class="calibre17"/></div><p class="calibre8">
</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec53" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">In order to access the neighboring pixels of the previous and next row, you must simply define additional pointers that are jointly incremented. You then access the pixels of these lines inside the scanning loop.</p><p class="calibre8">In the computation of the output pixel value, the <code class="literal">cv::saturate_cast</code> template function is called on the result of the operation. This is because, often,  a mathematical expression applied on pixels leads to a result that goes outside the range of the permitted pixel values (that is, below <code class="literal">0</code> or over <code class="literal">255</code>). The solution is then to bring the values back inside this 8-bit range. This is done by changing negative values to <code class="literal">0</code> and values over <code class="literal">255</code> to <code class="literal">255</code>. This is exactly what the <code class="literal">cv::saturate_cast&lt;uchar&gt;</code> function is doing. In addition, if the input argument is a floating point number, then the result is rounded to the nearest integer. You can obviously use this function with other types in order to guarantee that the result will remain within the limits defined by this type.</p><p class="calibre8">Border pixels that cannot be processed because their neighborhood is not completely defined need to be handled separately. Here, we simply set them to <code class="literal">0</code>. In other cases, it could be possible to perform a special computation for these pixels, but most of the time, there is no point in spending time to process these very few pixels. In our function, these border pixels are set to <code class="literal">0</code> using two special methods, <code class="literal">row</code> and <code class="literal">col</code>. They return a special <code class="literal">cv::Mat</code> instance composed of a single-line ROI (or a single-column ROI) as specified in a parameter (remember, we discussed region of interest in the previous chapter). No copy is made here; therefore if the elements of this 1D matrix are modified, they will also be modified in the original image. This is what we do when the <code class="literal">setTo</code> method is called. This method assigns a value to all elements of a matrix, as follows:</p><pre class="programlisting">    result.row(0).setTo(cv::Scalar(0)); 
</pre><p class="calibre8">The preceding statement assigns the value of <code class="literal">0</code> to all pixels of the first line of the result image. In the case of a 3-channel color image, you would use <code class="literal">cv::Scalar(a,b,c)</code> to specify the three values to be assigned to each channel of the pixel.</p></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec54" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">When a computation is done over a pixel neighborhood, it is common to represent this with a kernel matrix. This kernel describes how the pixels involved in the computation are combined in order to obtain the desired result. For the sharpening filter used in this recipe, the kernel would be as follows:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="There's more..." src="graphics/table.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">Unless stated otherwise, the current pixel corresponds to the center of the kernel. The value in each cell of the kernel represents a factor that multiplies the corresponding pixel. The result of the application of the kernel on a pixel is then given by the sum of all these multiplications. The size of the kernel corresponds to the size of the neighborhood (here, <code class="literal">3x3</code>).</p><p class="calibre8">Using this representation, it can be seen that, as required by the sharpening filter, the four horizontal and vertical neighbors of the current pixel are multiplied by <code class="literal">-1</code>, while the current pixel is multiplied by <code class="literal">5</code>. Applying a kernel to an image is more than a convenient representation; it is the basis for the concept of convolution in signal processing. The kernel defines a filter that is applied to the image.</p><p class="calibre8">Since filtering is a common operation in image processing, OpenCV has defined a special function that performs this task: the <code class="literal">cv::filter2D</code> function. To use this, you just need to define a kernel (in the form of a matrix). The function is then called with the image and the kernel, and it returns the filtered image. Using this function, it is therefore easy to redefine our sharpening function as follows:</p><pre class="programlisting">    void sharpen2D(const cv::Mat &amp;image, cv::Mat &amp;result) { 
 
      // Construct kernel (all entries initialized to 0) 
      cv::Mat kernel(3,3,CV_32F,cv::Scalar(0)); 
      // assigns kernel values 
      kernel.at&lt;float&gt;(1,1)= 5.0; 
      kernel.at&lt;float&gt;(0,1)= -1.0; 
      kernel.at&lt;float&gt;(2,1)= -1.0; 
      kernel.at&lt;float&gt;(1,0)= -1.0; 
      kernel.at&lt;float&gt;(1,2)= -1.0; 
 
      //filter the image 
      cv::filter2D(image,result,image.depth(),kernel); 
    } 
</pre><p class="calibre8">This implementation produces exactly the same result as the previous one (and with the same efficiency). If you input a color image, then the same kernel will be applied to all three channels. Note that it is particularly advantageous to use the <code class="literal">filter2D</code> function with a large kernel, as it uses, in this case, a more efficient algorithm.</p></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec55" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem"><a href="ch06.html" title="Chapter 6. Filtering the Images">Chapter 6</a>, <span><em class="calibre16">Filtering the Images</em></span>, provides more explanations on the concept of image filtering</li></ul></div></div></div>
<div class="calibre1" title="Performing simple image arithmetic"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch02lvl1sec19" class="calibre6"/>Performing simple image arithmetic</h1></div></div></div><p class="calibre8">Images can be combined in different ways. Since they are regular matrices, they can be added, subtracted, multiplied, or divided. OpenCV offers various image arithmetic operators, and their use is discussed in this recipe.</p><div class="calibre1" title="Getting ready"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec56" class="calibre6"/>Getting ready</h2></div></div></div><p class="calibre8">Let's work with a second image that we will combine with our input image using an arithmetic operator. The following represents this second image:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="Getting ready" src="graphics/image_02_005.jpg" class="calibre17"/></div><p class="calibre8">
</p></div><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec57" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">Here, we add two images. This is useful when we want to create some special effects or to overlay information over an image. We do this by calling the <code class="literal">cv::add</code> function, or more precisely here, the <code class="literal">cv::addWeighted</code> function, since we want a weighted sum as follows:</p><pre class="programlisting">  cv::addWeighted(image1,0.7,image2,0.9,0.,result); 
</pre><p class="calibre8">The operation results in a new image:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_02_006.jpg" class="calibre17"/></div><p class="calibre8">
</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec58" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">All binary arithmetic functions work the same way. Two inputs are provided and a third parameter specifies the output. In some cases, weights that are used as scalar multipliers in the operation can be specified. Each of these functions comes in several flavors; <code class="literal">cv::add</code> is a good example of a function that is available in many forms:</p><pre class="programlisting">    // c[i]= a[i]+b[i]; 
    cv::add(imageA,imageB,resultC);  
    // c[i]= a[i]+k; 
    cv::add(imageA,cv::Scalar(k),resultC);  
    // c[i]= k1*a[i]+k2*b[i]+k3;  
    cv::addWeighted(imageA,k1,imageB,k2,k3,resultC); 
    // c[i]= k*a[i]+b[i];  
    cv::scaleAdd(imageA,k,imageB,resultC); 
</pre><p class="calibre8">For some functions, you can also specify a mask:</p><pre class="programlisting">    // if (mask[i]) c[i]= a[i]+b[i]; 
    cv::add(imageA,imageB,resultC,mask); 
</pre><p class="calibre8">If you apply a mask, the operation is performed only on pixels for which the mask value is not null (the mask must be 1-channel). Have a look at the different forms of <code class="literal">cv::subtract</code>, <code class="literal">cv::absdiff</code>, <code class="literal">cv::multiply</code>, and <code class="literal">cv::divide</code> functions. Bitwise operators (operators applied to each individual bit of the pixels' binary representation) are also available: <code class="literal">cv::bitwise_and</code>, <code class="literal">cv::bitwise_or</code>, <code class="literal">cv::bitwise_xor</code>, and <code class="literal">cv::bitwise_not</code>. The <code class="literal">cv::min</code> and <code class="literal">cv::max</code> operators, which find the per-element maximum or minimum pixel value, are also very useful.</p><p class="calibre8">In all cases, the <code class="literal">cv::saturate_cast</code> function (see the preceding recipe) is always used to make sure that the results stay within the defined pixel value domain (that is, to avoid overflow or underflow).</p><p class="calibre8">The images must have the same size and type (the output image will be reallocated if it does not match the input size). Also, since the operation is performed per-element, one of the input images can be used as the output.</p><p class="calibre8">Several operators that take a single image as the input are also available: <code class="literal">cv::sqrt</code>, <code class="literal">cv::pow</code>, <code class="literal">cv::abs</code>, <code class="literal">cv::cuberoot</code>, <code class="literal">cv::exp</code>, and <code class="literal">cv::log</code>. In fact, there exists an OpenCV function for almost any operation you have to apply on image pixels.</p></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec59" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">It is also possible to use the usual C++ arithmetic operator on the <code class="literal">cv::Mat</code> instances or on the individual channels of <code class="literal">cv::Mat</code> instances. The two following subsections explain how to do this.</p><div class="calibre1" title="Overloaded image operators"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch02lvl3sec12" class="calibre6"/>Overloaded image operators</h3></div></div></div><p class="calibre8">Very conveniently, most arithmetic functions have their corresponding operator overloaded in OpenCV. Consequently, the call to <code class="literal">cv::addWeighted</code> can instead be written as follows:</p><pre class="programlisting">    result= 0.7*image1+0.9*image2; 
</pre><p class="calibre8">The preceding code is a more compact form that is also easier to read. These two ways of writing the weighted sum are equivalent. In particular, the <code class="literal">cv::saturate_cast</code> function will still be called in both cases.</p><p class="calibre8">Most C++ operators have been overloaded. Among them are the bitwise operators <code class="literal">&amp;</code>, <code class="literal">|</code>, <code class="literal">^</code>, and <code class="literal">~</code>; the <code class="literal">min</code>, <code class="literal">max</code>, and <code class="literal">abs</code> functions. The comparison operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">==</code>, <code class="literal">!=</code>, <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code> have also been overloaded, and they return an 8-bit binary image. You will also find the <code class="literal">m1*m2</code> matrix multiplication (where <code class="literal">m1</code> and <code class="literal">m2</code> are both <code class="literal">cv::Mat</code> instances), the <code class="literal">m1.inv()</code> matrix inversion, the <code class="literal">m1.t()</code> transpose, the <code class="literal">m1.determinant()</code> determinant, the <code class="literal">v1.norm()</code> vector norm, the <code class="literal">v1.cross(v2)</code> cross-product, the <code class="literal">v1.dot(v2)</code> dot product, and so on. When this makes sense, you also have the corresponding compound assignment operator defined (the <code class="literal">+=</code> operator, as an example).</p><p class="calibre8">In the <span><em class="calibre16">Writing efficient image-scanning loops</em></span> recipe, we presented a color-reduction function that was written using loops that scan the image pixels to perform some arithmetic operations on them. From what we learned here, this function could be rewritten simply using arithmetic operators on the input image as follows:</p><pre class="programlisting">     image=(image&amp;cv::Scalar(mask,mask,mask)) 
                  +cv::Scalar(div/2,div/2,div/2); 
</pre><p class="calibre8">The use of <code class="literal">cv::Scalar</code> is due to the fact that we are manipulating a color image. Using the image operators makes the code so simple, and the programmer so productive, that you should consider their use in most situations.</p></div><div class="calibre1" title="Splitting the image channels"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch02lvl3sec13" class="calibre6"/>Splitting the image channels</h3></div></div></div><p class="calibre8">Sometimes you want to process the different channels of an image independently. For example, you might want to perform an operation only on one channel of the image. You can, of course, achieve this in an image-scanning loop. However, you can also use the <code class="literal">cv::split</code> function that will copy the three channels of a color image into three distinct <code class="literal">cv::Mat</code> instances. Suppose we want to add our rain image to the blue channel only. The following is how we would proceed:</p><pre class="programlisting">    // create vector of 3 images 
    std::vector&lt;cv::Mat&gt; planes; 
    // split 1 3-channel image into 3 1-channel images 
    cv::split(image1,planes); 
    // add to blue channel 
    planes[0]+= image2; 
    // merge the 3 1-channel images into 1 3-channel image 
    cv::merge(planes,result); 
</pre><p class="calibre8">The <code class="literal">cv::merge</code> function performs the inverse operation, that is, it creates a color image from three 1-channel images.</p></div></div></div>
<div class="calibre1" title="Remapping an image"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch02lvl1sec20" class="calibre6"/>Remapping an image</h1></div></div></div><p class="calibre8">In the recipes of this chapter, you learned how to read and modify the pixel values of an image. The last recipe will teach you how to modify the appearance of an image by moving its pixels. The pixel values are not changed by this process; it is rather the position of each pixel that is remapped to a new location. This is useful in order to create special effects on an image or to correct image distortions caused, for example, by a lens.</p><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec60" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">In order to use the OpenCV <code class="literal">remap</code> function, you simply have to first define the map to be used in the remapping process. Second, you have to apply this map on an input image. Obviously, it is the way you define your map that will determine the effect that will be produced. In our example, we define a transformation function that will create a wavy effect on the image:</p><pre class="programlisting">    // remapping an image by creating wave effects 
    void wave(const cv::Mat &amp;image, cv::Mat &amp;result) { 
 
      // the map functions 
      cv::Mat srcX(image.rows,image.cols,CV_32F); 
      cv::Mat srcY(image.rows,image.cols,CV_32F); 
 
      // creating the mapping 
      for (int i=0; i&lt;image.rows; i++) { 
        for (int j=0; j&lt;image.cols; j++) { 
 
          // new location of pixel at (i,j) 
          srcX.at&lt;float&gt;(i,j)= j; // remain on same column 
                                  // pixels originally on row i are now 
                                  // moved following a sinusoid 
          srcY.at&lt;float&gt;(i,j)= i+5*sin(j/10.0); 
        } 
      } 
 
      // applying the mapping 
      cv::remap(image,                // source image 
                result,               // destination image 
                srcX,                 // x map 
                srcY,                 // y map 
                cv::INTER_LINEAR);    // interpolation method 
    } 
</pre><p class="calibre8">The result is as follows:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/B05388_02_07.jpg" class="calibre17"/></div><p class="calibre8">
</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec61" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">The objective of remapping is to produce a new version of an image in which pixels have changed in position. To construct this new image, we need to know what the original position is for each pixel in the destination image. The mapping function that is needed is therefore the one that will give us the original pixel positions as a function of the new pixel positions. This is called <span><strong class="calibre15">backward mapping</strong></span> because the transformation describes how the pixels of the new images are mapped back to the original image. In OpenCV, backward mapping is described using two maps: one for the <span><em class="calibre16">x</em></span>-coordinates and one for the <span><em class="calibre16">y</em></span>-coordinates. They are both represented by floating point <code class="literal">cv::Mat</code> instances:</p><pre class="programlisting">    // the map functions 
    cv::Mat srcX(image.rows,image.cols,CV_32F); // x-map 
    cv::Mat srcY(image.rows,image.cols,CV_32F); // y-map 
</pre><p class="calibre8">The size of these matrices will define the size of the destination image. The value of the <code class="literal">(i,j)</code> pixel of the destination image can then be read in the source image using the following line of code:</p><pre class="programlisting">    ( srcX.at&lt;float&gt;(i,j) , srcY.at&lt;float&gt;(i,j) ) 
</pre><p class="calibre8">For example, a simple image flip effect like the one we demonstrated in <a href="ch01.html" title="Chapter 1. Playing with Images">
Chapter 1
</a>, <span><em class="calibre16">Playing with Images</em></span>, can be created by the following maps:</p><pre class="programlisting">    // creating the mapping 
    for (int i=0; i&lt;image.rows; i++) { 
      for (int j=0; j&lt;image.cols; j++) { 
 
        // horizontal flipping 
        srcX.at&lt;float&gt;(i,j)= image.cols-j-1; 
        srcY.at&lt;float&gt;(i,j)= i; 
      } 
    } 
</pre><p class="calibre8">To generate the resulting image, you simply call the OpenCV <code class="literal">remap</code> function:</p><pre class="programlisting">    // applying the mapping 
    cv::remap(image,             // source image
              result,            // destination image 
              srcX,              // x map 
              srcY,              // y map 
              cv::INTER_LINEAR); // interpolation method 
</pre><p class="calibre8">It is interesting to note that the two maps contain floating-point values. Consequently, a pixel in the destination can map back to a non-integral value (that is, a location between pixels). This is very convenient because this allows us to define the mapping function of our choice. For instance, in our remapping example, we used a <code class="literal">sinusoidal</code> function to define our transformation. However, this also means that we have to interpolate the value of virtual pixels in between real pixels. There exist different ways of performing pixel interpolation, and the last parameter of the <code class="literal">remap</code> function allows us to select the method that will be used. Pixel interpolation is an important concept in image processing; this subject will be discussed in 
<a href="ch06.html" title="Chapter 6. Filtering the Images">Chapter 6</a>
, <span><em class="calibre16">Filtering the Images</em></span>.</p></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch02lvl2sec62" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The <span><em class="calibre16">There's more...</em></span> section of the <span><em class="calibre16">Filtering images using low-pass filters</em></span> recipe of <a href="ch06.html" title="Chapter 6. Filtering the Images">Chapter 6</a>, <span><em class="calibre16">Filtering the Images</em></span>, explains the concept of pixel interpolation</li><li class="listitem">The <span><em class="calibre16">Calibrating a camera</em></span> recipe of <a href="ch11.html" title="Chapter 11. Reconstructing 3D Scenes">
Chapter 11
</a>, <span><em class="calibre16">Reconstructing 3D Scenes</em></span>, uses remapping to correct lens distortions in an image</li><li class="listitem">The <span><em class="calibre16">Computing a homography between two images</em></span> recipe of <a href="ch10.html" title="Chapter 10. Estimating Projective Relations in Images">
Chapter 10
</a>, <span><em class="calibre16">Estimating Projective Relations in Images</em></span>, uses perspective image warping to build an image panorama</li></ul></div></div></div></body></html>