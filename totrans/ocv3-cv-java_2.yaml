- en: Chapter 2. Handling Matrices, Files, Cameras, and GUIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：处理矩阵、文件、摄像头和 GUI
- en: This chapter will enable you to perform basic operations required in computer
    vision, such as dealing with matrices, opening files, capturing videos from a
    camera, playing videos, and creating GUIs for prototype applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使你能够执行计算机视觉中所需的基本操作，例如处理矩阵、打开文件、从摄像头捕获视频、播放视频以及为原型应用程序创建 GUI。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Basic matrix manipulation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本矩阵操作
- en: Pixel manipulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素操作
- en: How to load and display images from files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从文件中加载和显示图像
- en: How to capture a video from a camera
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从摄像头捕获视频
- en: Video playback
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频播放
- en: Swing GUI's integration with OpenCV
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swing GUI 与 OpenCV 的集成
- en: By the end of this chapter, you should be able to get this computer vision application
    started by loading images and creating nice GUIs to manipulate them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够通过加载图像并创建用于操作它们的良好 GUI 来启动这个计算机视觉应用程序。
- en: Basic matrix manipulation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本矩阵操作
- en: 'From a computer vision background, we can see an image as a matrix of numerical
    values, which represents its pixels. For a gray-level image, we usually assign
    values ranging from 0 (black) to 255 (white) and the numbers in between show a
    mixture of both. These are generally 8-bit images. So, each element of the matrix
    refers to each pixel on the gray-level image, the number of columns refers to
    the image width, as well as the number of rows refers to the image''s height.
    In order to represent a color image, we usually adopt each pixel as a combination
    of three basic colors: red, green, and blue. So, each pixel in the matrix is represented
    by a triplet of colors.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算机视觉的背景来看，我们可以将图像视为数值矩阵，它代表其像素。对于灰度图像，我们通常将值分配为从 0（黑色）到 255（白色），中间的数字表示两者的混合。这些通常是
    8 位图像。因此，矩阵中的每个元素都对应于灰度图像上的每个像素，列数代表图像宽度，行数代表图像高度。为了表示彩色图像，我们通常将每个像素视为红色、绿色和蓝色三种基本颜色的组合。因此，矩阵中的每个像素由一个颜色三元组表示。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to observe that with 8 bits, we get 2 to the power of eight
    (*2**⁸*), which is 256\. So, we can represent the range from 0 to 255, which includes,
    respectively the values used for black and white levels in 8-bit grayscale images.
    Besides this, we can also represent these levels as floating points and use 0.0
    for black and 1.0 for white.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，使用 8 位，我们得到 2 的 8 次方 (*2**⁸*)，即 256。因此，我们可以表示从 0 到 255 的范围，包括用于 8 位灰度图像的黑白级别值。除此之外，我们还可以将这些级别表示为浮点数，并使用
    0.0 表示黑色和 1.0 表示白色。
- en: 'OpenCV has a variety of ways to represent images, so you are able to customize
    the intensity level through the number of bits considering whether one wants signed,
    unsigned, or floating point data types, as well as the number of channels. OpenCV''s
    convention is seen through the following expression:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 有多种表示图像的方法，因此你可以通过位数来定制强度级别，考虑是否需要有符号、无符号或浮点数据类型，以及通道数。OpenCV 的约定可以通过以下表达式看到：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `U` stands for unsigned, *S* for signed, and *F* stands for floating
    point. For instance, if an 8-bit unsigned single-channel image is required, the
    data type representation would be `CV_8UC1`, while a colored image represented
    by 32-bit floating point numbers would have the data type defined as `CV_32FC3`.
    If the number of channels is omitted, it evaluates to 1\. We can see the ranges
    according to each bit depth and data type in the following list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`U` 代表无符号，`S` 代表有符号，`F` 代表浮点。例如，如果需要一个 8 位无符号单通道图像，数据类型表示将是 `CV_8UC1`，而由
    32 位浮点数表示的彩色图像的数据类型定义将为 `CV_32FC3`。如果省略通道数，则默认为 1。我们可以在以下列表中看到根据每个位深度和数据类型的范围： '
- en: '`CV_8U`: These are the 8-bit unsigned integers that range from 0 to 255'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_8U`: 这些是范围从 0 到 255 的 8 位无符号整数'
- en: '`CV_8S`: These are the 8-bit signed integers that range from -128 to 127'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_8S`: 这些是范围从 -128 到 127 的 8 位有符号整数'
- en: '`CV_16U`: These are the 16-bit unsigned integers that range from 0 to 65,535'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_16U`: 这些是范围从 0 到 65,535 的 16 位无符号整数'
- en: '`CV_16S`: These are the 16-bit signed integers that range from -32,768 to 32,767'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_16S`: 这些是范围从 -32,768 到 32,767 的 16 位有符号整数'
- en: '`CV_32S`: These are the 32-bit signed integers that range from -2,147,483,648
    to 2,147,483,647'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_32S`: 这些是范围从 -2,147,483,648 到 2,147,483,647 的 32 位有符号整数'
- en: '`CV_32F`: These are the 32-bit floating-point numbers that range from `-FLT_MAX`
    to `FLT_MAX` and include `INF` and `NAN` values'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_32F`: 这些是范围从 `-FLT_MAX` 到 `FLT_MAX` 的 32 位浮点数，包括 `INF` 和 `NAN` 值'
- en: '`CV_64F`: These are the 64-bit floating-point numbers that range from `-DBL_MAX`
    to `DBL_MAX` and include `INF` and `NAN` values'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_64F`: 这些是范围从 `-DBL_MAX` 到 `DBL_MAX` 的 64 位浮点数，包括 `INF` 和 `NAN` 值'
- en: 'You will generally start the project from loading an image, but it is important
    to know how to deal with these values. Make sure you import `org.opencv.core.CvType`
    and `org.opencv.core.Mat`. Several constructors are available for matrices as
    well, for instance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常从加载图像开始项目，但了解如何处理这些值是很重要的。确保你导入了 `org.opencv.core.CvType` 和 `org.opencv.core.Mat`。矩阵也有几个构造函数可用，例如：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both of the preceding constructors will construct a matrix suitable to fit
    an image with 640 pixels of width and 480 pixels of height. Note that width is
    to columns as height is to rows. Also pay attention to the constructor with the
    `Size` parameter, which expects the width and height order. In case you want to
    check some of the matrix properties, the methods `rows()`, `cols()`, and `elemSize()`
    are available:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个构造函数都将构建一个适合 640 像素宽和 480 像素高的图像的矩阵。请注意，宽度对应于列，高度对应于行。还要注意带有 `Size` 参数的构造函数，它期望宽度和高度的顺序。如果你想要检查一些矩阵属性，可以使用
    `rows()`、`cols()` 和 `elemSize()` 方法：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the preceding line is:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行输出的结果是：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `isCont` property tells us whether this matrix uses extra padding when representing
    the image, so that it can be hardware-accelerated in some platforms; however,
    we won't cover it in detail right now. The `isSubmat` property refers to fact
    whether this matrix was created from another matrix and also whether it refers
    to the data from another matrix. The `nativeObj` object refers to the native object
    address, which is a **Java Native Interface** (**JNI**) detail, while `dataAddr`
    points to an internal data address. The element size is measured in the number
    of bytes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`isCont` 属性告诉我们这个矩阵在表示图像时是否使用额外的填充，以便在某些平台上进行硬件加速；然而，我们目前不会详细讨论它。`isSubmat`
    属性指的是这个矩阵是否由另一个矩阵创建，以及它是否引用另一个矩阵的数据。`nativeObj` 对象指的是原生对象地址，这是一个 **Java Native
    Interface** (**JNI**) 的细节，而 `dataAddr` 指向内部数据地址。元素大小以字节数衡量。'
- en: 'Another matrix constructor is the one that passes a scalar to be filled as
    one of its elements. The syntax for this looks like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个矩阵构造函数是传递一个标量作为其元素之一。这个语法的样子如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This constructor will initialize each element of the matrix with the triple
    `{128, 3, 4}`. A very useful way to print a matrix''s contents is using the auxiliary
    method `dump()` from `Mat`. Its output will look similar to the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数将使用三元组 `{128, 3, 4}` 初始化矩阵的每个元素。打印矩阵内容的一个非常有用方法是使用 `Mat` 的辅助方法 `dump()`。其输出将类似于以下内容：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is important to note that while creating the matrix with a specified size
    and type, it will also immediately allocate memory for its contents.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在创建具有指定大小和类型的矩阵时，它也会立即为其内容分配内存。
- en: Pixel manipulation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素操作
- en: 'Pixel manipulation is often required for one to access pixels in an image.
    There are several ways to do this and each one has its advantages and disadvantages.
    A straightforward method to do this is the `put(row, col, value)` method. For
    instance, in order to fill our preceding matrix with `values {1, 2, 3}`, we will
    use the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 像素操作通常需要一个人访问图像中的像素。有几种方法可以做到这一点，每种方法都有其优点和缺点。一个直接的方法是使用 `put(row, col, value)`
    方法。例如，为了用 `values {1, 2, 3}` 填充我们前面的矩阵，我们将使用以下代码：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that in the array of bytes `{1, 2, 3}`, for our matrix, `1` stands for
    the blue channel, `2` for the green, and `3` for the red channel, as OpenCV stores
    its matrix internally in the **BGR** (**blue, green, and red**) format.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在字节数组 `{1, 2, 3}` 中，对于我们的矩阵，`1` 代表蓝色通道，`2` 代表绿色，`3` 代表红色通道，因为 OpenCV 在内部以
    **BGR** （**蓝色、绿色和红色**）格式存储其矩阵。
- en: It is okay to access pixels this way for small matrices. The only problem is
    the overhead of JNI calls for big images. Remember that even a small 640 x 480
    pixel image has 307,200 pixels and if we think about a colored image, it has 921,600
    values in a matrix. Imagine that it might take around 50ms to make an overloaded
    call for each of the 307,200 pixels. On the other hand, if we manipulate the whole
    matrix on the Java side and then copy it to the native side in a single call,
    it will take around 13ms.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小矩阵，以这种方式访问像素是可以的。唯一的问题是大型图像JNI调用的开销。记住，即使是640 x 480像素的小图像也有307,200个像素，如果我们考虑彩色图像，它在一个矩阵中有921,600个值。想象一下，为每个307,200个像素进行过载调用可能需要大约50毫秒。另一方面，如果我们在一个Java侧上操作整个矩阵，然后在一个调用中将其复制到本地侧，它将需要大约13毫秒。
- en: 'If you want to manipulate the pixels on the Java side, perform the following
    steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Java侧操作像素，请执行以下步骤：
- en: Allocate memory with the same size as the matrix in a byte array.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在字节数组中分配与矩阵相同大小的内存。
- en: Put the image contents into that array (optional).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像内容放入该数组中（可选）。
- en: Manipulate the byte array contents.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作字节数组内容。
- en: Make a single `put` call, copying the whole byte array to the matrix.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行单个`put`调用，将整个字节数组复制到矩阵中。
- en: 'A simple example that will iterate all image pixels and set the blue channel
    to zero, which means that we will set to zero every element whose modulo is 3
    equals zero, that is {0, 3, 6, 9, …}, as shown in the following piece of code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子将迭代所有图像像素并将蓝色通道设置为0，这意味着我们将设置模3等于0的每个元素的值为0，即{0, 3, 6, 9, …}，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we find out the number of bytes in the image by multiplying the total
    number of pixels (`image.total`) with the element size in bytes (`image.elemenSize`).
    Then, we build a byte array with that size. We use the `get(row, col, byte[])`method
    to copy the matrix contents in our recently created byte array. Then, we iterate
    all bytes and check the condition that refers to the blue channel (`i%3==0`).
    Remember that OpenCV stores colors internally as {Blue, Green, Red}. We finally
    make another JNI call to `image.put`, which copies the whole byte array to OpenCV''s
    native storage. An example of this filter can be seen in the following image,
    which was uploaded by Mromanchenko, licensed under CC BY-SA 3.0:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将图像的总像素数（`image.total`）乘以字节数（`image.elemenSize`）来找出图像中的字节数。然后，我们使用该大小构建一个字节数组。我们使用`get(row,
    col, byte[])`方法将矩阵内容复制到我们最近创建的字节数组中。然后，我们迭代所有字节并检查与蓝色通道相关的条件（`i%3==0`）。记住，OpenCV将颜色内部存储为{Blue,
    Green, Red}。我们最终再次调用JNI的`image.put`，将整个字节数组复制到OpenCV的本地存储。以下图像是Mromanchenko上传的，许可协议为CC
    BY-SA 3.0，展示了此过滤器的示例：
- en: '![Pixel manipulation](img/3972OS_02_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![像素操作](img/3972OS_02_01.jpg)'
- en: Be aware that Java does not have any unsigned byte data type, so be careful
    when working with it. The safe procedure is to cast it to an integer and use the
    And operator (`&`) with `0xff`. A simple example of this would be `int unsignedValue
    = myUnsignedByte & 0xff;`. Now, `unsignedValue` can be checked in the range of
    0 to 255.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Java没有无符号字节数据类型，所以在处理它时要小心。安全的方法是将它转换为整数，并使用与`0xff`的按位与操作符（`&`）。一个简单的例子是`int
    unsignedValue = myUnsignedByte & 0xff;`。现在，`unsignedValue`可以在0到255的范围内进行检查。
- en: Loading and displaying images from files
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件加载和显示图像
- en: 'Most computer vision applications need to retrieve images from some where.
    In case you need to get them from files, OpenCV comes with several image file
    loaders. Unfortunately, some loaders depend on codecs that sometimes aren''t shipped
    with the operating system, which might cause them not to load. From the documentation,
    we see that the following files are supported with some caveats:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机视觉应用都需要从某处检索图像。如果你需要从文件中获取它们，OpenCV提供了几个图像文件加载器。不幸的是，一些加载器依赖于有时不随操作系统一起提供的编解码器，这可能导致它们无法加载。从文档中我们可以看到，以下文件得到了一些限制的支持：
- en: '**Windows bitmaps**: `*.bmp`, `*.dib`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows位图**: `*.bmp`, `*.dib`'
- en: '**JPEG files**: `*.jpeg`, `*.jpg`, `*.jpe`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JPEG文件**: `*.jpeg`, `*.jpg`, `*.jpe`'
- en: '**JPEG 2000 files**: `*.jp2`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JPEG 2000文件**: `*.jp2`'
- en: '**Portable Network Graphics**: `*.png`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植网络图形**: `*.png`'
- en: '**Portable image format**: `*.pbm`, `*.pgm`, `*.ppm`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植图像格式**: `*.pbm`, `*.pgm`, `*.ppm`'
- en: '**Sun rasters**: `*.sr`, `*.ras`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sun光栅**: `*.sr`, `*.ras`'
- en: '**TIFF files**: `*.tiff`, `*.tif`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TIFF文件**: `*.tiff`, `*.tif`'
- en: Note that Windows bitmaps, the portable image format, and sun raster formats
    are supported by all platforms, but the other formats depend on a few details.
    In Microsoft Windows and Mac OS X, OpenCV can always read the *jpeg*, *png*, and
    *tiff* formats. In Linux, OpenCV will look for codecs supplied with the OS, as
    stated by the documentation, so remember to *install the relevant packages (do
    not forget the development files, for example, "libjpeg-dev" in Debian* and Ubuntu*)
    to get the codec support or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake*,
    as pointed out in imread's official documentation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Windows 位图、可移植图像格式和 Sun 光栅格式在所有平台上都受支持，但其他格式则取决于一些细节。在 Microsoft Windows
    和 Mac OS X 上，OpenCV 总是能够读取 *jpeg*、*png* 和 *tiff* 格式。在 Linux 上，OpenCV 将寻找操作系统提供的编解码器，如文档所述，因此请记住安装相关的包（例如，在
    Debian 和 Ubuntu 中不要忘记开发文件，例如 "libjpeg-dev"），以获得编解码器支持，或者在 CMake 中打开 OPENCV_BUILD_3RDPARTY_LIBS
    标志，正如 imread 的官方文档中指出的。
- en: The `imread` method is supplied to get access to images through files. Use `Imgcodecs.imread`
    (name of the file) and check whether `dataAddr()` from the read image is different
    from zero to make sure the image has been loaded correctly, that is, the filename
    has been typed correctly and its format is supported.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`imread` 方法提供了一种通过文件访问图像的方式。使用 `Imgcodecs.imread`（文件名）并检查读取的图像的 `dataAddr()`
    是否与零不同，以确保图像已正确加载，也就是说，文件名已正确输入且其格式被支持。'
- en: 'A simple method to open a file could look like the one shown in the following
    code. Make sure you import `org.opencv.imgcodecs.Imgcodecs` and `org.opencv.core.Mat`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件的一个简单方法可能看起来像以下代码所示。确保你已导入 `org.opencv.imgcodecs.Imgcodecs` 和 `org.opencv.core.Mat`：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Displaying an image with Swing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swing 显示图像
- en: OpenCV developers are used to a simple cross-platform GUI by OpenCV, which was
    called as HighGUI, and a handy method called `imshow`. It constructs a window
    easily and displays an image within it, which is nice to create quick prototypes.
    As Java comes with a popular GUI API called **Swing**, we had better use it. Besides,
    no `imshow` method was available for Java until its 2.4.7.0 version was released.
    On the other hand, it is pretty simple to create such functionality. Refer to
    the reference code in `chapter2/swing-imageshow`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 开发者习惯于使用 OpenCV 提供的简单跨平台 GUI，称为 HighGUI，以及一个方便的方法 `imshow`。它可以轻松构建一个窗口并在其中显示图像，这对于创建快速原型来说很方便。由于
    Java 拥有一个流行的 GUI API，称为 **Swing**，我们最好使用它。此外，Java 2.4.7.0 版本之前没有提供 `imshow` 方法。另一方面，创建这样的功能相当简单。请参考
    `chapter2/swing-imageshow` 中的参考代码。
- en: 'Let''s break down the work in to two classes: `App` and `ImageViewer`. The
    `App` class will be responsible for loading the file, while `ImageViewer` will
    display it. The application''s work is simple and will only need to use Imgcodecs''s
    `imread` method, which is shown as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把工作分解为两个类：`App` 和 `ImageViewer`。`App` 类将负责加载文件，而 `ImageViewer` 将负责显示它。应用程序的工作很简单，只需使用
    Imgcodecs 的 `imread` 方法，如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the `App` class will only read an example image file in the `Mat`
    object and it will call the `ImageViewer` method to display it. Now, let''s see
    how the `ImageViewer''s show` method works:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`App` 类只会读取 `Mat` 对象中的示例图像文件，并且它会调用 `ImageViewer` 方法来显示它。现在，让我们看看 `ImageViewer`
    的 `show` 方法是如何工作的：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Pay attention to the `show` and `toBufferedImage` methods. `Show` will try
    to set Swing''s look and feel to the default native look, which is cosmetic. Then,
    it will create `JFrame` with `JScrollPane` and `JLabel` inside it. It will then
    call `toBufferedImage`, which will convert an OpenCV Mat object to a `BufferedImage`
    AWT. This conversion is made through the creation of a byte array that will store
    matrix contents. The appropriate size is allocated through the multiplication
    of the number of channels by the number of columns and rows. The `matrix.get`
    method puts all the elements into the byte array. Finally, the image''s raster
    data buffer is accessed through the `getDataBuffer()` and `getData()` methods.
    It is then filled with a fast system call to the `System.arraycopy` method. The
    resulting image is then assigned to `JLabel` and then it is easily displayed.
    Note that this method expects a matrix that is either stored as one channel''s
    unsigned 8-bit or three channel''s unsigned 8-bit. In case your image is stored
    as a floating point, you should convert it using the following code before calling
    this method, supposing that the image you need to convert is a `Mat` object called
    `originalImage`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `show` 和 `toBufferedImage` 方法。`Show` 将尝试将 Swing 的外观和感觉设置为默认的本地外观，这是装饰性的。然后，它将创建一个包含
    `JScrollPane` 和 `JLabel` 的 `JFrame`。然后它将调用 `toBufferedImage`，该函数将 OpenCV Mat 对象转换为
    AWT 的 `BufferedImage`。这种转换是通过创建一个存储矩阵内容的字节数组来完成的。通过将通道数乘以列数和行数来分配适当的大小。`matrix.get`
    方法将所有元素放入字节数组中。最后，通过 `getDataBuffer()` 和 `getData()` 方法访问图像的栅格数据缓冲区。然后通过对 `System.arraycopy`
    方法的快速系统调用进行填充。生成的图像随后被分配给 `JLabel`，然后它很容易地显示出来。请注意，此方法期望一个存储为单通道无符号 8 位或三通道无符号
    8 位的矩阵。如果你的图像存储为浮点数，你应该在调用此方法之前使用以下代码将其转换，假设你需要转换的图像是一个名为 `originalImage` 的 `Mat`
    对象：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This way, you can call `toBufferedImage` from your converted `byteImage` property.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以从你的转换后的 `byteImage` 属性中调用 `toBufferedImage` 方法。
- en: 'The image viewer can be easily installed in any Java OpenCV project and it
    will help you to show your images for debugging purposes. The output of this program
    can be seen in the next screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图像查看器可以轻松地安装在任何 Java OpenCV 项目中，并且它将帮助你显示图像以进行调试。这个程序的输出可以在下一张屏幕截图中看到：
- en: '![Displaying an image with Swing](img/3972OS_02_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Swing 显示图像](img/3972OS_02_02.jpg)'
- en: Capturing a video from a camera
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从摄像头捕获视频
- en: The process of capturing frames from a webcam is very complex and it involves
    hardware details as well as heavy decoding or decompression algorithms. Fortunately,
    OpenCV has wrapped it all in a simple, yet powerful class called `VideoCapture`.
    This class not only grabs an image from a webcam, but also reads video files.
    In case more advanced access to a camera is required, you may want to use its
    specialized drivers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络摄像头捕获帧的过程非常复杂，它涉及到硬件细节以及大量的解码或解压缩算法。幸运的是，OpenCV 将所有这些封装在一个简单而强大的类中，称为 `VideoCapture`。这个类不仅可以从网络摄像头抓取图像，还可以读取视频文件。如果需要更高级的相机访问，你可能想使用它的专用驱动程序。
- en: You can think of a video stream as a series of pictures and you can retrieve
    each image in `Mat` and process it as you like. In order to use the `VideoCapture`
    class to capture a webcam stream, you need to instantiate it using the `VideoCapture(int
    device)` constructor. Note that the constructor parameter refers to the `camera`
    index in case you have several cameras. So, if you have one built-in camera and
    one USB camera and you create a `videocapture` object, such as `new` `VideoCapture(1)`,
    then this object will refer to your built-in camera, while `new VideoCapture(0)`
    will refer to your just-plugged-in USB camera or the other way around. Make sure
    the cameras work in a manufacturer test application and check whether the camera's
    drivers are also installed before you try to capture images in OpenCV.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将视频流视为一系列图片，并且你可以检索每个 `Mat` 中的图像并按你喜欢的方式处理它。为了使用 `VideoCapture` 类捕获网络摄像头流，你需要使用
    `VideoCapture(int device)` 构造函数实例化它。请注意，构造函数参数指的是 `camera` 索引，如果你有多个摄像头。所以，如果你有一个内置摄像头和一个
    USB 摄像头，并且创建一个 `videocapture` 对象，例如 `new VideoCapture(1)`，那么这个对象将指向你的内置摄像头，而 `new
    VideoCapture(0)` 将指向你刚刚插入的 USB 摄像头或相反。在尝试在 OpenCV 中捕获图像之前，确保摄像头在制造商测试应用程序中工作，并检查摄像头驱动程序是否也已安装。
- en: After instantiating your `VideoCapture` class, check whether it is instantiated
    with the `isOpened()` method. This will be `false` in case something went wrong
    while accessing your camera. Unfortunately, there won't be much more info, so
    double-check your drivers. Now that everything is working, call the `read()` method
    to retrieve each captured frame in a loop. Note that this method combines the
    `VideoCapture grab()` and `retrieve()` methods. The `grab()` method only captures
    the next frame, which is fast, while the `retrieve()` method decodes and returns
    the captured frame. These methods make more sense when synchronization is important
    or when you use several cameras, as it will be easier to capture frames that are
    as close as possible, firstly by calling `grab()` for all cameras and then calling
    `retrieve()`. In case things go wrong while using the `read()` method, that is,
    the camera gets disconnected, then the method returns `false`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化你的`VideoCapture`类之后，使用`isOpened()`方法检查它是否已成功实例化。如果访问相机时出现问题，这将返回`false`。不幸的是，不会有更多的信息，所以请仔细检查你的驱动程序。现在一切正常，调用`read()`方法以循环检索每个捕获的帧。请注意，此方法结合了`VideoCapture
    grab()`和`retrieve()`方法。`grab()`方法仅捕获下一个帧，这很快，而`retrieve()`方法解码并返回捕获的帧。当同步很重要或使用多个相机时，这些方法更有意义，因为这将更容易捕获尽可能接近的帧，首先通过为所有相机调用`grab()`，然后调用`retrieve()`。如果在使用`read()`方法时出现问题，即相机断开连接，则该方法返回`false`。
- en: 'Another important point that you need to remember when using the `VideoCapture`
    class is setting the desired camera resolution. This is possible through the `set()`
    property setting method, which requires the `Videoio.CAP_PROP_FRAME_WIDTH` and
    `Videoio.CAP_PROP_FRAME_WIDTH` parameters. In case you want a 640 x 480 resolution,
    you would have to make two calls, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`VideoCapture`类时，你需要记住的一个重要点是设置所需的相机分辨率。这可以通过`set()`属性设置方法实现，它需要`Videoio.CAP_PROP_FRAME_WIDTH`和`Videoio.CAP_PROP_FRAME_HEIGHT`参数。如果你想设置640
    x 480的分辨率，你需要进行两次调用，如下所示：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before attempting to set the new resolutions, check your device's capabilities.
    If you set a resolution the camera can't handle, this might hang the camera or
    fallback to a resolution where it can capture an image.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试设置新分辨率之前，检查你的设备功能。如果你设置了一个相机无法处理的分辨率，这可能会导致相机挂起或回退到一个可以捕获图像的分辨率。
- en: 'The `videocapture` project available in this chapter''s sample code shows how
    to retrieve a webcam stream and display it in the screen pretty much like what
    happens in the previous `swing-imageshow` example. In this project, the `toBufferedImage`
    method has been refactored to an `ImageProcessor` class, which deals only with
    the conversion from `Mat`—retrieved from the `VideoCapture` class—to `BufferedImage`,
    which is required to display the image in Swing. The `main` class is also very
    simple; it only builds a window, instantiates a `VideoCapture` class, sets its
    properties, and goes to a main loop. This will grab a frame from the camera, convert
    it to `BufferedImage` and display it in `JLabel`, as shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例代码中可用的`videocapture`项目展示了如何检索网络摄像头流并将其显示在屏幕上，这与前面的`swing-imageshow`示例中的情况类似。在这个项目中，`toBufferedImage`方法已经被重构为一个`ImageProcessor`类，该类仅处理从`VideoCapture`类检索的`Mat`到`BufferedImage`的转换，这是在Swing中显示图像所必需的。`main`类也非常简单；它只构建一个窗口，实例化一个`VideoCapture`类，设置其属性，并进入主循环。这将从相机捕获一个帧，将其转换为`BufferedImage`并在`JLabel`中显示，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that calling `frame.pack()` will realize the captured frame size and fit
    the window according to it. The following screenshot shows a successful execution
    of the preceding code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用`frame.pack()`将实现捕获的帧大小，并根据它调整窗口大小。以下截图显示了前面代码的成功执行：
- en: '![Capturing a video from a camera](img/3972OS_02_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![从相机捕获视频](img/3972OS_02_03.jpg)'
- en: Be aware that when you open a `VideoCapture` device, it might not release the
    process gracefully, so your Java application might still be running when you close
    it. You might need to kill your process (according to your platform) as a last
    resort. In Windows, this is as easy as opening the Task Manager, which you can
    open by pressing *CTRL* + *ALT* + *DEL* and locating your Java process. To do
    this, OS X users need to press *CMD* + *ALT* + *ESC*, while Linux users can just
    issue a `kill` command. For troubleshooting, if you are having problems starting
    your capture device after using it for a while, reconnecting your USB plug can
    make it work.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你打开`VideoCapture`设备时，它可能不会优雅地释放进程，所以当你关闭它时，你的Java应用程序可能仍在运行。作为最后的手段，你可能需要根据你的平台杀死你的进程。在Windows上，这就像打开任务管理器一样简单，你可以通过按*CTRL*
    + *ALT* + *DEL*打开它，并定位你的Java进程。为了做到这一点，OS X用户需要按*CMD* + *ALT* + *ESC*，而Linux用户只需发出一个`kill`命令。对于故障排除，如果你在使用了一段时间后遇到启动捕获设备的问题，重新连接你的USB插头可以使它工作。
- en: Video playback
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频播放
- en: Another important I/O task in computer vision is being able to open and process
    a video file. Fortunately, OpenCV can easily deal with videos through the `VideoCapture`
    class. Instead of constructing it with a device number, as was done previously,
    we need to create it with the file path. We can also use the empty constructor
    and make the `open(String filename)` method responsible for pointing to the file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉中另一个重要的I/O任务是能够打开和处理视频文件。幸运的是，OpenCV可以通过`VideoCapture`类轻松处理视频。与之前使用设备号构建不同，我们需要使用文件路径来创建它。我们还可以使用空构造函数，并让`open(String
    filename)`方法负责指向文件。
- en: 'The `videoplayback` project available in the chapter''s source code has the
    same structure as the `swing-imageshow` project, explained previously. It only
    differs when you initialize the `VideoCapture` instance:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本章源代码中提供的`videoplayback`项目结构与之前解释的`swing-imageshow`项目相同。它只是在初始化`VideoCapture`实例时有所不同：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have also put a 50ms delay between each frame so that the whole video doesn't
    play too fast. There is also code that you can use to manipulate `InterruptedException`.
    Note that the video files won't play with the same velocity as seen in a video
    player device. This is because the `capture.read(webcamMatImage);` method is called
    as quickly as possible. You can also add delays to the code so that it plays slower
    than the usual pace. Although it is not covered in this section, the `get` method
    from the `VideoCapture` class when called with the `CV_CAP_PROP_FPS` parameter
    should return the video frames per second, so that you can play it in the original
    frame rate.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在每帧之间加入了50ms的延迟，这样整个视频就不会播放得太快。还有可以用来操作`InterruptedException`的代码。请注意，视频文件不会以与视频播放器设备中相同的速度播放。这是因为`capture.read(webcamMatImage);`方法尽可能地快速调用。你还可以在代码中添加延迟，使其播放速度比正常速度慢。尽管这在本节中没有涉及，但当你使用`CV_CAP_PROP_FPS`参数调用`VideoCapture`类的`get`方法时，应该返回视频每秒的帧数，这样你就可以以原始帧率播放它。
- en: In case your video is not loaded, it might be an uninstalled codec issue. Try
    installing it or looking for other codecs so that this bug is finished. Another
    option to do this is to use tools to convert your video to supported codecs. It
    might also be the case where the `opencv_ffmpeg300` dynamic link library goes
    missing from your path environmental variable. Try copying it to your project
    home folder or adding it to your path variable. That should work. Make sure you
    point your java.library.path to the folder that contains this library, in the
    same way you configured your projects to find native OpenCV libraries, as described
    in [Chapter 1](ch01.html "Chapter 1. Setting Up OpenCV for Java"), *Setting Up
    OpenCV for Java*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的视频没有加载，可能是因为未安装的编解码器问题。尝试安装它或寻找其他编解码器，以便结束这个错误。另一种方法是使用工具将你的视频转换为支持的编解码器。也可能的情况是，`opencv_ffmpeg300`动态链接库从你的路径环境变量中丢失。尝试将其复制到你的项目主文件夹或添加到你的路径变量中。这应该会起作用。确保你的java.library.path指向包含此库的文件夹，就像你配置项目以查找原生OpenCV库一样，如[第1章](ch01.html
    "第1章。为Java设置OpenCV")中所述，*为Java设置OpenCV*。
- en: Swing GUI's integration with OpenCV
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swing GUI与OpenCV的集成
- en: It is important to have rich graphical user interfaces while debugging or experimenting
    with computer vision projects, since some tasks might require a lot of tuning.
    This way, dealing with sliders, buttons, labels, and mouse events should be in
    the backpack of any computer vision researcher. Thankfully, you can work with
    all of these components in a relatively easy way in Swing. In this section, we
    will cover the most important parts of creating an application that loads an image
    and blurs it at several levels through a slider. This application also makes use
    of mouse events to highlight details in the image as well as a nice button to
    click and clear everything. The next screenshot gives us a good idea of how the
    application works. The code can be found in the `opencv-gui` project within the
    code bundle for this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试或实验计算机视觉项目时，拥有丰富的图形用户界面非常重要，因为一些任务可能需要大量的调整。这样，处理滑块、按钮、标签和鼠标事件应该是任何计算机视觉研究者的基本技能。幸运的是，你可以在Swing中以相对简单的方式使用所有这些组件。在本节中，我们将介绍创建一个应用程序的重要部分，该应用程序通过滑块在多个级别上加载并模糊图像。此应用程序还利用鼠标事件来突出图像中的细节，以及一个漂亮的按钮来点击并清除所有内容。下一张截图为我们提供了一个关于应用程序工作原理的好主意。代码可以在本书代码包中的`opencv-gui`项目中找到。
- en: '![Swing GUI''s integration with OpenCV](img/3972OS_02_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Swing GUI与OpenCV的集成](img/3972OS_02_04.jpg)'
- en: 'The code to load an image is not new to us and can be found in the *Displaying
    an image with Swing* section. We will pay closer attention to the `setupSlider()`,
    `setupImage()`, and `setupButton()` methods. Read the `setupSlider` method and
    we will then cover it in detail later:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像的代码对我们来说并不陌生，可以在*使用Swing显示图像*部分找到。我们将更仔细地关注`setupSlider()`、`setupImage()`和`setupButton()`方法。阅读`setupSlider`方法，我们将在稍后详细讨论它：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that a slider is simply a `Jslider` class and we need to set its minimum,
    maximum, and initial values through the constructor. We also set whether it's
    a vertical or horizontal slider. Some cosmetic details, such as the major and
    minor tick spacing and whether to paint or not labels and ticks are also set.
    A key method in the slider is its `stateChanged` listener provided by the anonymous
    class, which implements the `ChangeListener` interface. This is basically what
    happens when the user changes the slider. In our case, we will blur the image
    the number of times set by the slider. This is done through our implemented `ImageProcessor`
    class, which basically calls the `Imgproc blur` method, a very simple filter that
    only calculates the mean of a number of neighbor pixels. The value addressed by
    the slider is obtained through a call to `source.getValue()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，滑块只是一个`JSlider`类，我们需要通过构造函数设置其最小值、最大值和初始值。我们还需要设置它是垂直还是水平滑块。一些外观细节，如主刻度和副刻度间距以及是否绘制标签和刻度，也进行了设置。滑块中的一个关键方法是它提供的匿名类中的`stateChanged`监听器，这基本上是用户更改滑块时发生的事情。在我们的情况下，我们将根据滑块设置的次数模糊图像。这是通过我们实现的`ImageProcessor`类完成的，该类基本上调用`Imgproc.blur`方法，这是一个非常简单的过滤器，它只计算一定数量相邻像素的平均值。滑块的值通过调用`source.getValue()`获得。
- en: 'Another important task is being responsive to the mouse click events. This
    is achieved by adding `MouseListener` to our `JLabel` image view. The following
    is the `setupImage` method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的任务是响应用户的鼠标点击事件。这是通过向我们的`JLabel`图像视图添加`MouseListener`来实现的。以下是`setupImage`方法：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `mousePressed()`method implemented in the preceding code is responsible
    for answering all the mousedown events. We can get local coordinates through the
    `getX()` and `getY()` event methods. Note that we call `Imgproc.circle`, which
    is an OpenCV function that will draw a circle in the desired matrix, in the desired
    position, and we can define its radius, color, and thickness.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中实现的`mousePressed()`方法负责响应用户的所有鼠标按下事件。我们可以通过`getX()`和`getY()`事件方法获取局部坐标。请注意，我们调用`Imgproc.circle`，这是一个OpenCV函数，它将在所需的矩阵中绘制一个圆，在所需的位置，并且我们可以定义其半径、颜色和粗细。
- en: 'The last GUI component explored in this example is a button that is created
    through the `JButton` component, which implements the `actionPerformed` interface.
    As we have previously stored the original image, it''s easy to clear the image
    by just copying the original one back:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中最后探索的GUI组件是通过`JButton`组件创建的按钮，该组件实现了`actionPerformed`接口。因为我们之前已经存储了原始图像，所以只需将原始图像复制回来就可以轻松清除图像：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow! A lot of details have been covered in this chapter, but we have finally
    grasped the development of a complete application for computer vision. We touched
    on the topic of core structure from OpenCV, which is the `Mat` class for basic
    pixel manipulation, and its close relation to Swing's `BufferedImage` class. Besides
    this, we covered important tasks such as opening image files and displaying them
    in a Swing application. The important area of live video streaming has been covered
    with the `VideoCapture` class, which shows you how to obtain frames from a webcam
    as well as from video files. Finally, we created a rich graphical user interface
    application with sliders, labels, buttons and by handling mouse events in Java.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！本章涵盖了大量的细节，但我们终于掌握了计算机视觉完整应用程序的开发。我们触及了 OpenCV 的核心结构主题，即用于基本像素操作的 `Mat` 类，以及它与
    Swing 的 `BufferedImage` 类的紧密关系。除此之外，我们还涵盖了打开图像文件并在 Swing 应用程序中显示它们等重要任务。使用 `VideoCapture`
    类涵盖了实时视频流的重要领域，它展示了如何从摄像头以及视频文件中获取帧。最后，我们通过在 Java 中处理鼠标事件，创建了一个具有滑块、标签、按钮的丰富图形用户界面应用程序。
- en: The foundations of working with a Java OpenCV API have been set and we are ready
    to go on to the next chapter, which will deal with core operators in image processing,
    such as smoothing filters to remove noise, using morphological operators to isolate
    elements, using bucket fill for segmentation, image pyramids, and the essential
    task of thresholding. Be sure to check them out.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java OpenCV API 的工作基础已经奠定，我们现在可以继续进入下一章，本章将涉及图像处理的核心操作，例如使用平滑滤波器去除噪声，使用形态学运算符隔离元素，使用桶填充进行分割，图像金字塔，以及阈值化的基本任务。务必查看这些内容。
