- en: Chapter 2. Handling Matrices, Files, Cameras, and GUIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will enable you to perform basic operations required in computer
    vision, such as dealing with matrices, opening files, capturing videos from a
    camera, playing videos, and creating GUIs for prototype applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic matrix manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pixel manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load and display images from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to capture a video from a camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video playback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swing GUI's integration with OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to get this computer vision application
    started by loading images and creating nice GUIs to manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: Basic matrix manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From a computer vision background, we can see an image as a matrix of numerical
    values, which represents its pixels. For a gray-level image, we usually assign
    values ranging from 0 (black) to 255 (white) and the numbers in between show a
    mixture of both. These are generally 8-bit images. So, each element of the matrix
    refers to each pixel on the gray-level image, the number of columns refers to
    the image width, as well as the number of rows refers to the image''s height.
    In order to represent a color image, we usually adopt each pixel as a combination
    of three basic colors: red, green, and blue. So, each pixel in the matrix is represented
    by a triplet of colors.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to observe that with 8 bits, we get 2 to the power of eight
    (*2**⁸*), which is 256\. So, we can represent the range from 0 to 255, which includes,
    respectively the values used for black and white levels in 8-bit grayscale images.
    Besides this, we can also represent these levels as floating points and use 0.0
    for black and 1.0 for white.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV has a variety of ways to represent images, so you are able to customize
    the intensity level through the number of bits considering whether one wants signed,
    unsigned, or floating point data types, as well as the number of channels. OpenCV''s
    convention is seen through the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `U` stands for unsigned, *S* for signed, and *F* stands for floating
    point. For instance, if an 8-bit unsigned single-channel image is required, the
    data type representation would be `CV_8UC1`, while a colored image represented
    by 32-bit floating point numbers would have the data type defined as `CV_32FC3`.
    If the number of channels is omitted, it evaluates to 1\. We can see the ranges
    according to each bit depth and data type in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CV_8U`: These are the 8-bit unsigned integers that range from 0 to 255'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_8S`: These are the 8-bit signed integers that range from -128 to 127'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_16U`: These are the 16-bit unsigned integers that range from 0 to 65,535'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_16S`: These are the 16-bit signed integers that range from -32,768 to 32,767'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_32S`: These are the 32-bit signed integers that range from -2,147,483,648
    to 2,147,483,647'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_32F`: These are the 32-bit floating-point numbers that range from `-FLT_MAX`
    to `FLT_MAX` and include `INF` and `NAN` values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CV_64F`: These are the 64-bit floating-point numbers that range from `-DBL_MAX`
    to `DBL_MAX` and include `INF` and `NAN` values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will generally start the project from loading an image, but it is important
    to know how to deal with these values. Make sure you import `org.opencv.core.CvType`
    and `org.opencv.core.Mat`. Several constructors are available for matrices as
    well, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of the preceding constructors will construct a matrix suitable to fit
    an image with 640 pixels of width and 480 pixels of height. Note that width is
    to columns as height is to rows. Also pay attention to the constructor with the
    `Size` parameter, which expects the width and height order. In case you want to
    check some of the matrix properties, the methods `rows()`, `cols()`, and `elemSize()`
    are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding line is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `isCont` property tells us whether this matrix uses extra padding when representing
    the image, so that it can be hardware-accelerated in some platforms; however,
    we won't cover it in detail right now. The `isSubmat` property refers to fact
    whether this matrix was created from another matrix and also whether it refers
    to the data from another matrix. The `nativeObj` object refers to the native object
    address, which is a **Java Native Interface** (**JNI**) detail, while `dataAddr`
    points to an internal data address. The element size is measured in the number
    of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another matrix constructor is the one that passes a scalar to be filled as
    one of its elements. The syntax for this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor will initialize each element of the matrix with the triple
    `{128, 3, 4}`. A very useful way to print a matrix''s contents is using the auxiliary
    method `dump()` from `Mat`. Its output will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that while creating the matrix with a specified size
    and type, it will also immediately allocate memory for its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pixel manipulation is often required for one to access pixels in an image.
    There are several ways to do this and each one has its advantages and disadvantages.
    A straightforward method to do this is the `put(row, col, value)` method. For
    instance, in order to fill our preceding matrix with `values {1, 2, 3}`, we will
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in the array of bytes `{1, 2, 3}`, for our matrix, `1` stands for
    the blue channel, `2` for the green, and `3` for the red channel, as OpenCV stores
    its matrix internally in the **BGR** (**blue, green, and red**) format.
  prefs: []
  type: TYPE_NORMAL
- en: It is okay to access pixels this way for small matrices. The only problem is
    the overhead of JNI calls for big images. Remember that even a small 640 x 480
    pixel image has 307,200 pixels and if we think about a colored image, it has 921,600
    values in a matrix. Imagine that it might take around 50ms to make an overloaded
    call for each of the 307,200 pixels. On the other hand, if we manipulate the whole
    matrix on the Java side and then copy it to the native side in a single call,
    it will take around 13ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to manipulate the pixels on the Java side, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocate memory with the same size as the matrix in a byte array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the image contents into that array (optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manipulate the byte array contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a single `put` call, copying the whole byte array to the matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A simple example that will iterate all image pixels and set the blue channel
    to zero, which means that we will set to zero every element whose modulo is 3
    equals zero, that is {0, 3, 6, 9, …}, as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we find out the number of bytes in the image by multiplying the total
    number of pixels (`image.total`) with the element size in bytes (`image.elemenSize`).
    Then, we build a byte array with that size. We use the `get(row, col, byte[])`method
    to copy the matrix contents in our recently created byte array. Then, we iterate
    all bytes and check the condition that refers to the blue channel (`i%3==0`).
    Remember that OpenCV stores colors internally as {Blue, Green, Red}. We finally
    make another JNI call to `image.put`, which copies the whole byte array to OpenCV''s
    native storage. An example of this filter can be seen in the following image,
    which was uploaded by Mromanchenko, licensed under CC BY-SA 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pixel manipulation](img/3972OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Be aware that Java does not have any unsigned byte data type, so be careful
    when working with it. The safe procedure is to cast it to an integer and use the
    And operator (`&`) with `0xff`. A simple example of this would be `int unsignedValue
    = myUnsignedByte & 0xff;`. Now, `unsignedValue` can be checked in the range of
    0 to 255.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and displaying images from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most computer vision applications need to retrieve images from some where.
    In case you need to get them from files, OpenCV comes with several image file
    loaders. Unfortunately, some loaders depend on codecs that sometimes aren''t shipped
    with the operating system, which might cause them not to load. From the documentation,
    we see that the following files are supported with some caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows bitmaps**: `*.bmp`, `*.dib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JPEG files**: `*.jpeg`, `*.jpg`, `*.jpe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JPEG 2000 files**: `*.jp2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portable Network Graphics**: `*.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portable image format**: `*.pbm`, `*.pgm`, `*.ppm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sun rasters**: `*.sr`, `*.ras`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TIFF files**: `*.tiff`, `*.tif`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that Windows bitmaps, the portable image format, and sun raster formats
    are supported by all platforms, but the other formats depend on a few details.
    In Microsoft Windows and Mac OS X, OpenCV can always read the *jpeg*, *png*, and
    *tiff* formats. In Linux, OpenCV will look for codecs supplied with the OS, as
    stated by the documentation, so remember to *install the relevant packages (do
    not forget the development files, for example, "libjpeg-dev" in Debian* and Ubuntu*)
    to get the codec support or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake*,
    as pointed out in imread's official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The `imread` method is supplied to get access to images through files. Use `Imgcodecs.imread`
    (name of the file) and check whether `dataAddr()` from the read image is different
    from zero to make sure the image has been loaded correctly, that is, the filename
    has been typed correctly and its format is supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple method to open a file could look like the one shown in the following
    code. Make sure you import `org.opencv.imgcodecs.Imgcodecs` and `org.opencv.core.Mat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Displaying an image with Swing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV developers are used to a simple cross-platform GUI by OpenCV, which was
    called as HighGUI, and a handy method called `imshow`. It constructs a window
    easily and displays an image within it, which is nice to create quick prototypes.
    As Java comes with a popular GUI API called **Swing**, we had better use it. Besides,
    no `imshow` method was available for Java until its 2.4.7.0 version was released.
    On the other hand, it is pretty simple to create such functionality. Refer to
    the reference code in `chapter2/swing-imageshow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the work in to two classes: `App` and `ImageViewer`. The
    `App` class will be responsible for loading the file, while `ImageViewer` will
    display it. The application''s work is simple and will only need to use Imgcodecs''s
    `imread` method, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `App` class will only read an example image file in the `Mat`
    object and it will call the `ImageViewer` method to display it. Now, let''s see
    how the `ImageViewer''s show` method works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the `show` and `toBufferedImage` methods. `Show` will try
    to set Swing''s look and feel to the default native look, which is cosmetic. Then,
    it will create `JFrame` with `JScrollPane` and `JLabel` inside it. It will then
    call `toBufferedImage`, which will convert an OpenCV Mat object to a `BufferedImage`
    AWT. This conversion is made through the creation of a byte array that will store
    matrix contents. The appropriate size is allocated through the multiplication
    of the number of channels by the number of columns and rows. The `matrix.get`
    method puts all the elements into the byte array. Finally, the image''s raster
    data buffer is accessed through the `getDataBuffer()` and `getData()` methods.
    It is then filled with a fast system call to the `System.arraycopy` method. The
    resulting image is then assigned to `JLabel` and then it is easily displayed.
    Note that this method expects a matrix that is either stored as one channel''s
    unsigned 8-bit or three channel''s unsigned 8-bit. In case your image is stored
    as a floating point, you should convert it using the following code before calling
    this method, supposing that the image you need to convert is a `Mat` object called
    `originalImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can call `toBufferedImage` from your converted `byteImage` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image viewer can be easily installed in any Java OpenCV project and it
    will help you to show your images for debugging purposes. The output of this program
    can be seen in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying an image with Swing](img/3972OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Capturing a video from a camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of capturing frames from a webcam is very complex and it involves
    hardware details as well as heavy decoding or decompression algorithms. Fortunately,
    OpenCV has wrapped it all in a simple, yet powerful class called `VideoCapture`.
    This class not only grabs an image from a webcam, but also reads video files.
    In case more advanced access to a camera is required, you may want to use its
    specialized drivers.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a video stream as a series of pictures and you can retrieve
    each image in `Mat` and process it as you like. In order to use the `VideoCapture`
    class to capture a webcam stream, you need to instantiate it using the `VideoCapture(int
    device)` constructor. Note that the constructor parameter refers to the `camera`
    index in case you have several cameras. So, if you have one built-in camera and
    one USB camera and you create a `videocapture` object, such as `new` `VideoCapture(1)`,
    then this object will refer to your built-in camera, while `new VideoCapture(0)`
    will refer to your just-plugged-in USB camera or the other way around. Make sure
    the cameras work in a manufacturer test application and check whether the camera's
    drivers are also installed before you try to capture images in OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: After instantiating your `VideoCapture` class, check whether it is instantiated
    with the `isOpened()` method. This will be `false` in case something went wrong
    while accessing your camera. Unfortunately, there won't be much more info, so
    double-check your drivers. Now that everything is working, call the `read()` method
    to retrieve each captured frame in a loop. Note that this method combines the
    `VideoCapture grab()` and `retrieve()` methods. The `grab()` method only captures
    the next frame, which is fast, while the `retrieve()` method decodes and returns
    the captured frame. These methods make more sense when synchronization is important
    or when you use several cameras, as it will be easier to capture frames that are
    as close as possible, firstly by calling `grab()` for all cameras and then calling
    `retrieve()`. In case things go wrong while using the `read()` method, that is,
    the camera gets disconnected, then the method returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important point that you need to remember when using the `VideoCapture`
    class is setting the desired camera resolution. This is possible through the `set()`
    property setting method, which requires the `Videoio.CAP_PROP_FRAME_WIDTH` and
    `Videoio.CAP_PROP_FRAME_WIDTH` parameters. In case you want a 640 x 480 resolution,
    you would have to make two calls, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Before attempting to set the new resolutions, check your device's capabilities.
    If you set a resolution the camera can't handle, this might hang the camera or
    fallback to a resolution where it can capture an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `videocapture` project available in this chapter''s sample code shows how
    to retrieve a webcam stream and display it in the screen pretty much like what
    happens in the previous `swing-imageshow` example. In this project, the `toBufferedImage`
    method has been refactored to an `ImageProcessor` class, which deals only with
    the conversion from `Mat`—retrieved from the `VideoCapture` class—to `BufferedImage`,
    which is required to display the image in Swing. The `main` class is also very
    simple; it only builds a window, instantiates a `VideoCapture` class, sets its
    properties, and goes to a main loop. This will grab a frame from the camera, convert
    it to `BufferedImage` and display it in `JLabel`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that calling `frame.pack()` will realize the captured frame size and fit
    the window according to it. The following screenshot shows a successful execution
    of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing a video from a camera](img/3972OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Be aware that when you open a `VideoCapture` device, it might not release the
    process gracefully, so your Java application might still be running when you close
    it. You might need to kill your process (according to your platform) as a last
    resort. In Windows, this is as easy as opening the Task Manager, which you can
    open by pressing *CTRL* + *ALT* + *DEL* and locating your Java process. To do
    this, OS X users need to press *CMD* + *ALT* + *ESC*, while Linux users can just
    issue a `kill` command. For troubleshooting, if you are having problems starting
    your capture device after using it for a while, reconnecting your USB plug can
    make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Video playback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important I/O task in computer vision is being able to open and process
    a video file. Fortunately, OpenCV can easily deal with videos through the `VideoCapture`
    class. Instead of constructing it with a device number, as was done previously,
    we need to create it with the file path. We can also use the empty constructor
    and make the `open(String filename)` method responsible for pointing to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `videoplayback` project available in the chapter''s source code has the
    same structure as the `swing-imageshow` project, explained previously. It only
    differs when you initialize the `VideoCapture` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have also put a 50ms delay between each frame so that the whole video doesn't
    play too fast. There is also code that you can use to manipulate `InterruptedException`.
    Note that the video files won't play with the same velocity as seen in a video
    player device. This is because the `capture.read(webcamMatImage);` method is called
    as quickly as possible. You can also add delays to the code so that it plays slower
    than the usual pace. Although it is not covered in this section, the `get` method
    from the `VideoCapture` class when called with the `CV_CAP_PROP_FPS` parameter
    should return the video frames per second, so that you can play it in the original
    frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: In case your video is not loaded, it might be an uninstalled codec issue. Try
    installing it or looking for other codecs so that this bug is finished. Another
    option to do this is to use tools to convert your video to supported codecs. It
    might also be the case where the `opencv_ffmpeg300` dynamic link library goes
    missing from your path environmental variable. Try copying it to your project
    home folder or adding it to your path variable. That should work. Make sure you
    point your java.library.path to the folder that contains this library, in the
    same way you configured your projects to find native OpenCV libraries, as described
    in [Chapter 1](ch01.html "Chapter 1. Setting Up OpenCV for Java"), *Setting Up
    OpenCV for Java*.
  prefs: []
  type: TYPE_NORMAL
- en: Swing GUI's integration with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to have rich graphical user interfaces while debugging or experimenting
    with computer vision projects, since some tasks might require a lot of tuning.
    This way, dealing with sliders, buttons, labels, and mouse events should be in
    the backpack of any computer vision researcher. Thankfully, you can work with
    all of these components in a relatively easy way in Swing. In this section, we
    will cover the most important parts of creating an application that loads an image
    and blurs it at several levels through a slider. This application also makes use
    of mouse events to highlight details in the image as well as a nice button to
    click and clear everything. The next screenshot gives us a good idea of how the
    application works. The code can be found in the `opencv-gui` project within the
    code bundle for this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Swing GUI''s integration with OpenCV](img/3972OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to load an image is not new to us and can be found in the *Displaying
    an image with Swing* section. We will pay closer attention to the `setupSlider()`,
    `setupImage()`, and `setupButton()` methods. Read the `setupSlider` method and
    we will then cover it in detail later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that a slider is simply a `Jslider` class and we need to set its minimum,
    maximum, and initial values through the constructor. We also set whether it's
    a vertical or horizontal slider. Some cosmetic details, such as the major and
    minor tick spacing and whether to paint or not labels and ticks are also set.
    A key method in the slider is its `stateChanged` listener provided by the anonymous
    class, which implements the `ChangeListener` interface. This is basically what
    happens when the user changes the slider. In our case, we will blur the image
    the number of times set by the slider. This is done through our implemented `ImageProcessor`
    class, which basically calls the `Imgproc blur` method, a very simple filter that
    only calculates the mean of a number of neighbor pixels. The value addressed by
    the slider is obtained through a call to `source.getValue()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important task is being responsive to the mouse click events. This
    is achieved by adding `MouseListener` to our `JLabel` image view. The following
    is the `setupImage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `mousePressed()`method implemented in the preceding code is responsible
    for answering all the mousedown events. We can get local coordinates through the
    `getX()` and `getY()` event methods. Note that we call `Imgproc.circle`, which
    is an OpenCV function that will draw a circle in the desired matrix, in the desired
    position, and we can define its radius, color, and thickness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last GUI component explored in this example is a button that is created
    through the `JButton` component, which implements the `actionPerformed` interface.
    As we have previously stored the original image, it''s easy to clear the image
    by just copying the original one back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! A lot of details have been covered in this chapter, but we have finally
    grasped the development of a complete application for computer vision. We touched
    on the topic of core structure from OpenCV, which is the `Mat` class for basic
    pixel manipulation, and its close relation to Swing's `BufferedImage` class. Besides
    this, we covered important tasks such as opening image files and displaying them
    in a Swing application. The important area of live video streaming has been covered
    with the `VideoCapture` class, which shows you how to obtain frames from a webcam
    as well as from video files. Finally, we created a rich graphical user interface
    application with sliders, labels, buttons and by handling mouse events in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The foundations of working with a Java OpenCV API have been set and we are ready
    to go on to the next chapter, which will deal with core operators in image processing,
    such as smoothing filters to remove noise, using morphological operators to isolate
    elements, using bucket fill for segmentation, image pyramids, and the essential
    task of thresholding. Be sure to check them out.
  prefs: []
  type: TYPE_NORMAL
