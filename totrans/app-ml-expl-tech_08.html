<html><head></head><body>
		<div id="_idContainer127">
			<h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor107"/>Chapter 6</em>: Model Interpretability Using SHAP</h1>
			<p>In the previous two chapters, we explored model-agnostic local explainability using the <strong class="bold">LIME</strong> framework to explain black-box models. We also discussed certain limitations of the LIME approach, even though it remains one of the most popular <strong class="bold">Explainable AI</strong> (<strong class="bold">XAI</strong>) algorithms. In this chapter, we will cover <strong class="bold">SHapley Additive exPlanation</strong> (<strong class="bold">SHAP</strong>), which is another popular XAI framework that can provide model-agnostic local explainability for tabular, image, and text datasets.</p>
			<p><strong class="bold">SHAP</strong> is <a id="_idIndexMarker368"/>based <a id="_idIndexMarker369"/>on <strong class="bold">Shapley values</strong>, which is a concept popularly used in <strong class="bold">Game Theory</strong> (<a href="https://c3.ai/glossary/data-science/shapley-values/">https://c3.ai/glossary/data-science/shapley-values/</a>). Although the mathematical understanding of Shapley values can be complicated, I will provide a simple, intuitive understanding of Shapley values and SHAP and focus more on the practical aspects of the framework. Similar to LIME, SHAP also has its pros and cons, which we are going to discuss in this chapter. This chapter will cover one practical tutorial that will explain regression models using SHAP. Later, in <a href="B18216_07_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Practical Exposure to Using SHAP in ML</em>, we will cover other practical applications of the SHAP framework.</p>
			<p>So, here is a list of the main topics of discussion for this chapter:</p>
			<ul>
				<li>An intuitive understanding of the SHAP and Shapley values</li>
				<li>Model explainability approaches using SHAP</li>
				<li>Advantages and limitations</li>
				<li>Using SHAP to explain regression models</li>
			</ul>
			<p>Now, let's begin!</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor108"/>Technical requirements </h1>
			<p>The code tutorial with the necessary resources can be downloaded or cloned from the GitHub repository for this chapter: <a href="https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/tree/main/Chapter06">https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/tree/main/Chapter06</a>. Python and Jupyter notebooks are used to implement the practical application of the theoretical concepts that are covered in this chapter. But I recommend that you only run the notebooks after you go through this chapter for a better understanding. Additionally, please look at the <em class="italic">SHAP Errata</em> section before proceeding with the practical tutorial part of this chapter: <a href="https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/blob/main/Chapter06/SHAP_ERRATA/ReadMe.md">https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/blob/main/Chapter06/SHAP_ERRATA/ReadMe.md</a>.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor109"/>An intuitive understanding of the SHAP and Shapley values</h1>
			<p>As discussed in <a href="B18216_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Foundational Concepts of Explainability Techniques</em>, explaining black-box models is a necessity for increasing AI adoption. Algorithms that are model-agnostic and can provide local explainability with a global perspective are the ideal choice of explainability technique in <strong class="bold">machine learning (ML) </strong>. That is why LIME is a popular choice in XAI. SHAP is another popular choice of explainability technique in ML and, in certain scenarios, is more effective than LIME. In this section, we will discuss about the intuitive understanding of the SHAP framework along with how it functions for providing model explainability.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor110"/>Introduction to SHAP and Shapley values</h2>
			<p>The <a id="_idIndexMarker370"/>SHAP framework was introduced by <em class="italic">Scott Lundberg</em> and <em class="italic">Su-In Lee</em> in their research work, <em class="italic">A Unified Approach of Interpreting Model Predictions</em> (<a href="https://arxiv.org/abs/1705.07874">https://arxiv.org/abs/1705.07874</a>). This was published in 2017. SHAP is based on the concept of Shapley values from cooperative game theory, but unlike the LIME framework, it considers <em class="italic">additive feature importance</em>. By definition, the Shapley value is <em class="italic">the mean marginal contribution of each feature value across all possible values in the feature space</em>. The mathematical understanding of <a id="_idIndexMarker371"/>Shapley values is complicated and might confuse most readers. That said, if you are interested in getting an in-depth mathematical understanding of Shapley values, we recommend that you take a look at the research paper called <em class="italic">"A Value for n-Person Games." Contributions to the Theory of Games 2.28 (1953), by Lloyd S. Shapley</em>. In the next section, we will gain an intuitive understanding of Shapley values with a very simple example. </p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor111"/>What are Shapley values?</h2>
			<p>In this section, I <a id="_idIndexMarker372"/>will explain Shapley values using a very simple and easy-to-understand example. Let's suppose that Alice, Bob, and Charlie are three friends who are taking part, as a team, in a Kaggle competition to solve a given problem with ML, for a certain cash prize. Their collective goal is to win the competition and get the prize money. All three of them are equally not good in all areas of ML and, therefore, have <a id="_idIndexMarker373"/>contributed in different ways. Now, if they win the competition and earn their prize money, <em class="italic">how will they ensure a fair distribution of the prize money considering their individual contributions?</em> <em class="italic">How will they measure their individual contributions for the same goal?</em> The answer to these questions can be given by Shapley values, which were introduced in 1951 by Lloyd Shapley. </p>
			<p>The following diagram gives us a visual illustration of the scenario:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B18216_06_001.jpg" alt="Figure 6.1 – Visual illustration of the scenario discussed in the What are Shapley values? section&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Visual illustration of the scenario discussed in the What are Shapley values? section</p>
			<p>So, in this scenario, Alice, Bob, and Charlie are part of the same team, playing the same game (which is the Kaggle competition). In game theory, this is referred to as a <strong class="bold">Coalition Game</strong>. The <a id="_idIndexMarker374"/>prize<a id="_idIndexMarker375"/> money for the competition is their <em class="italic">payout</em>. So, Shapley values tell us the average contribution of each player to the payout ensuring a fair distribution. But <em class="italic">why not just equally distribute the prize money between all the players</em>? Well, since the contributions are not equal, it is not <em class="italic">fair</em> to distribute the money equally. </p>
			<h3>Deciding the payouts</h3>
			<p>Now, how<a id="_idIndexMarker376"/> do we decide the fairest way to distribute the payout? One way is to assume that Alice, Bob, and Charlie joined the game in a sequence in which Alice started first, followed by Bob, and then followed by Charlie. Let's suppose that if Alice, Bob, and Charlie had participated alone, they would have gained 10 points, 20 points, and 25 points, respectively. But if only Alice and Bob teamed up, they might have received 40 points. While Alice and Charlie together could get 30 points, Bob and Charlie together could get 50 points. When all three of them collaborate together, only then do they get 90 points, which is sufficient for them to win the competition. </p>
			<p><em class="italic">Figure 6.2</em> illustrates the point values for each condition. We will make use of these values to calculate the average marginal contribution of each player:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B18216_06_002.jpg" alt="Figure 6.2 – The contribution values for all possible combinations of all the players&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – The contribution values for all possible combinations of all the players</p>
			<p>Mathematically, if we assume that there are <em class="italic">N</em> players, where <em class="italic">S</em> is the coalition subset of players and <img src="image/B18216_06_001.png" alt=""/> is the total value of <em class="italic">S</em> players, then by the formula of Shapley values, the marginal contribution of player <em class="italic">i</em> is given as follows:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B18216_06_0021.jpg" alt=""/>
				</div>
			</div>
			<p>The <a id="_idIndexMarker377"/>equation of Shapley value might look complicated, but let's simplify this with our example. Please note that the order in which each player starts the game is important to consider as Shapley values try to account for the order of each player to calculate the marginal contribution. </p>
			<p>Now, for our example, the contribution of Alice can be calculated by calculating the difference that Alice can cause to the final score. So, the contribution is calculated by taking the difference in the points scored when Alice is in the game and when she is not. Also, when Alice is playing, she can either play alone or team up with others. When Alice is playing, the value that she can create can be represented as <img src="image/B18216_06_003.png" alt=""/>. Likewise, <img src="image/B18216_06_004.png" alt=""/> and <img src="image/B18216_06_005.png" alt=""/> denote individual values created by Bob and Charlie. Now, when Alice and Bob are teaming up, we can calculate only Alice's contribution by removing Bob's contribution from the overall contribution. This can be represented as <img src="image/B18216_06_006.png" alt=""/>. And if all three are playing together, Alice's contribution is given as <img src="image/B18216_06_007.png" alt=""/>. </p>
			<p>Considering all possible permutations of the sequences by which Alice, Bob, and Charlie play the game, the marginal contribution of Alice is the average of her individual contributions in all possible scenarios. This is illustrated in <em class="italic">Figure 6.3</em>:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B18216_06_003.jpg" alt="Figure 6.3 – The Shapley value of Alice is her marginal contribution considering all possible scenarios&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The Shapley value of Alice is her marginal contribution considering all possible scenarios</p>
			<p>So, the <a id="_idIndexMarker378"/>overall contribution of Alice will be her marginal contribution across all possible scenarios, which also happens to be the Shapley value. For Alice, the Shapley value is <em class="italic">20.83</em>. Similarly, we can calculate the marginal contribution for Bob and Charlie, as shown in <em class="italic">Figure 6.4</em>:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B18216_06_004.jpg" alt="Figure 6.4 – Marginal contribution for Alice, Bob, and Charlie&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Marginal contribution for Alice, Bob, and Charlie</p>
			<p>I hope this wasn't too difficult to understand! One thing to note is that the sum of marginal contributions of Alice, Bob, and Charlie should be equal to the total contribution made by all three of them together. Now, let's try to understand Shapley values in the context of ML.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor112"/>Shapley values in ML</h2>
			<p>In order to understand<a id="_idIndexMarker379"/> the importance of Shapley values in ML to explain model predictions, we will try to modify the example about Alice, Bob, and Charlie that we used for understanding Shapley values. We can consider Alice, Bob, and Charlie to be <em class="italic">three different features present in a dataset used for training a model</em>. So, in this case, the <em class="italic">player contributions</em> will be the <em class="italic">contribution of each feature</em>. <em class="italic">The game</em> or the Kaggle competition will be the<em class="italic"> black-box ML model</em> and the <em class="italic">payout</em> will be the <em class="italic">prediction</em>. So, if we want to know the <em class="italic">contribution of each feature toward the model prediction</em>, we will use <em class="italic">Shapley values</em>.</p>
			<p>The modification of <em class="italic">Figure 6.1</em> to represent Shapley values in the context of ML is illustrated in <em class="italic">Figure 6.5</em>:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B18216_06_005.jpg" alt="Figure 6.5 – Understanding Shapley values in the context of ML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Understanding Shapley values in the context of ML</p>
			<p>Therefore, Shapley values help us to understand the collective contribution of each feature toward the outcome predicted by black-box ML models. By using Shapley values, we can explain the working of black-box models by estimating the feature contributions.</p>
			<h3>Properties of Shapley values</h3>
			<p>Now that we have an intuitive understanding of Shapley values and we have learned how to calculate Shapley values, we should also<a id="_idIndexMarker380"/> gain an understanding of the properties of Shapley values:</p>
			<ul>
				<li><strong class="bold">Efficiency</strong>: The <a id="_idIndexMarker381"/>total sum of Shapley values or the marginal contribution of each feature should be equal to the value of the total coalition. For example, in <em class="italic">Figure 6.4</em>, we can see that sum of individual Shapley values for Alice, Bob, and Charlie are equal to the total coalition value obtained when Alice, Bob, and Charlie team up together.</li>
				<li><strong class="bold">Symmetry</strong>: Each <a id="_idIndexMarker382"/>player has a fair chance of joining the game in any order. in <em class="italic">Figure 6.4</em>, we can see that all permutations of the sequences for all the players are considered.</li>
				<li><strong class="bold">Dummy</strong>: If a<a id="_idIndexMarker383"/> particular feature does not change the predicted value regardless of the coalition group, then the Shapley value for the feature is <em class="italic">0</em>. </li>
				<li><strong class="bold">Additivity</strong>: For<a id="_idIndexMarker384"/> any game with a combined payout, the Shapley values are also combined. This is denoted as <img src="image/B18216_06_008.png" alt=""/>, then <img src="image/B18216_06_009.png" alt=""/>. For example, for the random forest algorithm in ML, Shapley values can be calculated for a particular feature by calculating it for each individual tree and then averaging them to find the additive Shapley value for the entire random forest.</li>
			</ul>
			<p>So, these are the important properties of Shapley values. Next, let's discuss the SHAP framework and understand how it is much more than just the usage of Shapley values.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor113"/>The SHAP framework</h2>
			<p>Previously, we <a id="_idIndexMarker385"/>discussed what Shapley values are and how they are used in ML. Now, let's cover the SHAP framework. Although SHAP is popularly used as an XAI tool for providing local explainability to individual predictions, SHAP can also provide a global explanation by aggregating the individual predictions. Additionally, SHAP is <em class="italic">model-agnostic</em>, which means that it does not make any assumptions about the algorithm used in black-box models. The creators of the framework broadly came up with two <a id="_idIndexMarker386"/>model-agnostic approximation methods, which are as follows:</p>
			<ul>
				<li><strong class="bold">SHAP Explainer</strong>: This <a id="_idIndexMarker387"/>is based on <em class="italic">Shapley sampling values</em>.</li>
				<li><strong class="bold">KernelSHAP Explainer</strong>: This<a id="_idIndexMarker388"/> is based on the <em class="italic">LIME approach</em>.</li>
			</ul>
			<p>The framework <a id="_idIndexMarker389"/>also<a id="_idIndexMarker390"/> includes <em class="italic">model-specific</em> explainability methods such as the following:</p>
			<ul>
				<li><strong class="bold">Linear SHAP</strong>: This is<a id="_idIndexMarker391"/> for linear models with independent features.</li>
				<li><strong class="bold">Tree SHAP</strong>: This is <a id="_idIndexMarker392"/>an algorithm that is faster than SHAP explainers to compute SHAP values for tree algorithms and tree-based ensemble learning algorithms.</li>
				<li><strong class="bold">Deep SHAP</strong>: This is<a id="_idIndexMarker393"/> an algorithm that is faster than SHAP explainers to compute SHAP values for deep learning models.</li>
			</ul>
			<p>Apart from these approaches, SHAP also uses interesting visualization methods to explain AI models. We will cover these methods in more detail in the next section. But one point to note is that the calculation of Shapley values is computationally very expensive, and the algorithm is of the order of <img src="image/B18216_06_010.png" alt=""/>, where <em class="italic">n</em> is the number of features. So, if the dataset has many features, calculating Shapley values might take forever! However, the SHAP framework uses an approximation technique to calculate Shapley values efficiently. The explanation provided by SHAP is more robust as compared to the LIME framework. Let's proceed to the next section, where we will discuss the various model explainability approaches used by SHAP on various types of data.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor114"/>Model explainability approaches using SHAP</h1>
			<p>After <a id="_idIndexMarker394"/>reading the previous section, you have gained an understanding of SHAP and Shapley values. In this section, we will discuss various model-explainability approaches using SHAP. Data visualization is an important method to explain the working of complex algorithms. SHAP makes use of various interesting data visualization techniques to represent the approximated Shapley values to explain black-box models. So, let's discuss some of the popular visualization methods used by the SHAP framework.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor115"/>Visualizations in SHAP</h2>
			<p>As <a id="_idIndexMarker395"/>mentioned previously, SHAP <a id="_idIndexMarker396"/>can be used for both the global interpretability of<a id="_idIndexMarker397"/> the model and the local interpretability of the inference data instance. Now, the values generated by the SHAP algorithm are quite difficult to understand unless we make use of intuitive visualizations. The choice of visualization depends on the choice of global interpretability or local interpretability, which we will cover in this section.</p>
			<h3>Global interpretability with feature importance bar plots</h3>
			<p>Analyzing the <a id="_idIndexMarker398"/>most influential features present in a dataset always helps us to understand the <a id="_idIndexMarker399"/>functioning of an algorithm with respect to the underlying data. SHAP provides an effective way in which to find feature importance using Shapley values. So, the feature importance bar <a id="_idIndexMarker400"/>plot displays the important features in descending order of their importance. Additionally, SHAP provides a unique way to show feature interactions using <strong class="bold">hierarchical clustering</strong> (<a href="https://www.displayr.com/what-is-hierarchical-clustering/">https://www.displayr.com/what-is-hierarchical-clustering/</a>). These feature clustering methods help us to visualize a group of features that collectively impacts the model's outcome. This is very interesting since one of the core benefits of using Shapley values is to analyze the additive influence of multiple features together. However, there is one drawback of the feature importance plot for global interpretability. Since this method only considers mean absolute Shapley values to estimate feature importance, it doesn't show whether collectively certain features are impacting the model in a negative way or not. </p>
			<p>The following <a id="_idIndexMarker401"/>diagram illustrates the visualizations for a feature importance plot and a feature <a id="_idIndexMarker402"/>clustering plot using SHAP:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B18216_06_006.jpg" alt="Figure 6.6 –A feature importance plot for global interpretability (left-hand side) and a feature clustering plot for global interpretability (right-hand side)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 –A feature importance plot for global interpretability (left-hand side) and a feature clustering plot for global interpretability (right-hand side)</p>
			<p>Next, let's explore SHAP Cohort plots.</p>
			<h3>Global interpretability with the Cohort plot</h3>
			<p>Sometimes, analyzing subgroups of data is an important part of data analysis. SHAP provides a very <a id="_idIndexMarker403"/>interesting way<a id="_idIndexMarker404"/> of grouping the data into certain defined cohorts to analyze feature importance. I found this to be a unique option in SHAP, which can be really helpful! This is an extension of the existing feature importance visualization, and it highlights feature importance for each of the cohorts for a better comparison.</p>
			<p><em class="italic">Figure 6.7</em> shows us the cohort plot to compare two cohorts that are defined from the data:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B18216_06_007.jpg" alt="Figure 6.7 – A cohort plot visualization to compare feature importance between two cohorts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – A cohort plot visualization to compare feature importance between two cohorts</p>
			<p>Next, we<a id="_idIndexMarker405"/> will <a id="_idIndexMarker406"/>explore SHAP heatmap plots.</p>
			<h3>Global interpretability with heatmap plots</h3>
			<p>To <a id="_idIndexMarker407"/>understand the overall impact of all features on the model at a more granular level, heatmap visualizations are extremely useful. The SHAP heatmap visualization <a id="_idIndexMarker408"/>shows how every feature value can positively or negatively impact the outcome. Additionally, the plot also includes a line plot to show how the model prediction varies with the positive or negative impact of feature values. However, for non-technical users, this visualization can be really challenging to interpret. This is one of the drawbacks of this visualization method.</p>
			<p><em class="italic">Figure 6.8</em> illustrates a <em class="italic">SHAP heatmap visualization</em>:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B18216_06_008.jpg" alt="Figure 6.8 – A SHAP heatmap plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – A SHAP heatmap plot</p>
			<p>Another<a id="_idIndexMarker409"/> popular choice<a id="_idIndexMarker410"/> of visualization for global interpretability using SHAP is summary plots. Let's discuss summary plots in the next section.</p>
			<h3>Global interpretability with summary plots</h3>
			<p>A <a id="_idIndexMarker411"/>summary plot is<a id="_idIndexMarker412"/> another visualization method in SHAP for providing global explainability of black-box models. It is a good replacement for the feature importance plot, which not only includes the important features but also the range of effects of these features present in the dataset. The color bar indicates the impact of the features. The features that influence the model's outcome in a positive way are highlighted in a particular color, whereas the features that impact the model's outcome negatively are represented in another contrasting color. The<a id="_idIndexMarker413"/> horizontal violin plot for each feature shows the distribution of the Shapley values of the features for each data instance. </p>
			<p>The following screenshot illustrates a <em class="italic">SHAP summary plot</em>:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B18216_06_009.jpg" alt="Figure 6.9 – A SHAP violin summary plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – A SHAP violin summary plot</p>
			<p>In the next <a id="_idIndexMarker414"/>section, we<a id="_idIndexMarker415"/> will discuss SHAP dependence plots.</p>
			<h3>Global interpretability with dependence plots</h3>
			<p>In <a id="_idIndexMarker416"/>certain scenarios, it is important to analyze interactions between the features and how this interaction influences the model outcome. So, SHAP feature dependence plots show the variation of<a id="_idIndexMarker417"/> the model outcome by specific features. These plots are similar to the <em class="italic">partial dependence plots</em>, which were covered in <a href="B18216_02_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Model Explainability Methods</em>. This plot can help to pick up interesting interaction patterns or trends between the feature values. The features used for selecting the color map are automatically picked up by <a id="_idIndexMarker418"/>the algorithm, based on the interaction with a specific selected feature.</p>
			<p><em class="italic">Figure 6.10</em> illustrates a SHAP dependence plot: </p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B18216_06_010.jpg" alt="Figure 6.10 – A SHAP dependence plot for the pH feature&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – A SHAP dependence plot for the pH feature</p>
			<p>In this example, the selected feature is <em class="italic">pH</em>, and the feature used for selecting the colormap is <em class="italic">alcohol</em>. So, the plot tells us that with an increase in <em class="italic">pH</em>, the <em class="italic">alcohol</em> value also increases. This will be covered in greater detail in the next section.</p>
			<p>In <a id="_idIndexMarker419"/>the<a id="_idIndexMarker420"/> next section, let's explore the SHAP visualization methods used for local explainability.</p>
			<h3>Local interpretability with bar plots</h3>
			<p>So far, we have<a id="_idIndexMarker421"/> covered various<a id="_idIndexMarker422"/> visualization techniques offered by SHAP for providing a global overview of the model. However, similar to LIME, SHAP is also model-agnostic that is<a id="_idIndexMarker423"/> designed to provide local explainability. SHAP provides certain visualization methods that can be applied to inference data for local explainability. Local feature importance using SHAP bar plots is one such local explainability method. This plot can help us analyze the positive and negative impact of the features that are present in the data. The features that impact the model's outcome positively are highlighted in one color (pinkish-red by default), and the features having a negative impact on the model outcome are represented using another color (blue by default). Also, as we have discussed before, if the Shapley value is zero for any feature, this indicates that the feature does not influence the model outcome at all. Additionally, the bar plot centers at zero to show the contribution of the features present in the data.</p>
			<p>The <a id="_idIndexMarker424"/>following diagram shows a <em class="italic">SHAP feature importance bar plot</em> for local interpretability:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B18216_06_011.jpg" alt="Figure 6.11 – A SHAP feature importance bar plot for local interpretability&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – A SHAP feature importance bar plot for local interpretability</p>
			<p>Next, let's cover<a id="_idIndexMarker425"/> another SHAP visualization that is used for local interpretability.</p>
			<h3>Local interpretability with waterfall plots</h3>
			<p>Bar charts<a id="_idIndexMarker426"/> are not <a id="_idIndexMarker427"/>the only visualization provided by SHAP for local interpretability. The same information can be displayed using a waterfall plot, which might look more attractive. Perhaps, the only difference is that waterfall plots are not centered at zero, whereas bar plots are <a id="_idIndexMarker428"/>centered at zero. Otherwise, we get the same feature importance based on Shapley values and the positive or the negative impact of the specific features on the model outcome.</p>
			<p><em class="italic">Figure 6.12</em> illustrates a <em class="italic">SHAP waterfall plot</em> for local interpretability:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B18216_06_012.jpg" alt="Figure 6.12 – A SHAP waterfall plot for local interpretability&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – A SHAP waterfall plot for local interpretability</p>
			<p>Next, we will <a id="_idIndexMarker429"/>discuss force plot visualization in SHAP.</p>
			<h3>Local interpretability with force plot</h3>
			<p>We<a id="_idIndexMarker430"/> can also use force plots instead of waterfall or bar plots to explain local inference data. With force plots, we can see the <a id="_idIndexMarker431"/>model prediction, which is denoted by <em class="italic">f(x)</em>, as shown in <em class="italic">Figure 6.13</em>. The <em class="italic">base value</em> in the following diagram represents the average predicted outcome of the model. The base value is actually used when the features<a id="_idIndexMarker432"/> present in the local data instance are not considered. So, using the force plot, we can also see how far the predicted outcome is from the base value. Additionally, we can see the feature impacts as the visual highlights certain features that try to increase the model prediction (which is represented in pink in <em class="italic">Figure 6.13</em>) along with other important features that have a negative influence on the model as it tries to lower the prediction value (which is represented in green in <em class="italic">Figure 6.13</em>).</p>
			<p>So, <em class="italic">Figure 6.13</em> illustrates a sample force plot visualization in SHAP: </p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B18216_06_013.jpg" alt="Figure 6.13 – A SHAP force plot for local interpretability&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – A SHAP force plot for local interpretability</p>
			<p>Although force plots might visually look very interesting, we would recommend using bar plots or <a id="_idIndexMarker433"/>waterfall plots if the dataset<a id="_idIndexMarker434"/> contains many features affecting the model outcome in a positive or a negative way.</p>
			<h3>Local interpretability with decision plots</h3>
			<p>The <a id="_idIndexMarker435"/>easiest way to explain<a id="_idIndexMarker436"/> something is by comparing it with a reference value. So far, in bar plots, waterfall plots, and even force plots, we do not see any reference values for the underlying features used. However, in order to find out whether the feature values are positively or negatively influencing the model outcome, the algorithm is actually trying to compare the feature values of the inference data with the mean of the feature values of the trained model. So, this<a id="_idIndexMarker437"/> is the reference value that is not displayed in the three local explainability visualization plots that we covered. But SHAP decision plots help us to compare the feature values of the local data instance with the mean feature values of the training dataset. Additionally, decision plots show the deviation of the feature values, the model prediction, and the direction of deviation of features from the reference values. If the direction of deviation is toward the right, this indicates that the feature is positively influencing the model outcome; if the direction of deviation is toward the left, this represents the negative influence of the feature on the model outcome. Different colors are used to highlight positive or negative influences. If there is no deviation, then the features are actually not influencing the model outcome. </p>
			<p>The following diagram illustrates the use of decision plots to compare two different data instances for providing local explainability:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B18216_06_014.jpg" alt="Figure 6.14 – SHAP decision plots for local interpretability&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – SHAP decision plots for local interpretability</p>
			<p>So far, you <a id="_idIndexMarker438"/>have seen the variety <a id="_idIndexMarker439"/>of visualization methods provided in SHAP for the global and local explainability of ML models. Now, let's discuss the various types of explainers in SHAP.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor116"/>Explainers in SHAP</h2>
			<p>In the<a id="_idIndexMarker440"/> previous section, we looked at how the data visualization techniques that are available in SHAP can be used to provide<a id="_idIndexMarker441"/> explainability. But<a id="_idIndexMarker442"/> the choice of the visualization method might also depend on the choice of the explainer algorithm. As we discussed earlier, SHAP provides both model-specific and model-agnostic explainability. But the framework has multiple explainer algorithms that can be applied with different models and with different types of datasets. In this section, we will cover the various explainer algorithms provided in SHAP.</p>
			<h3>TreeExplainer</h3>
			<p>TreeExplainer is a fast<a id="_idIndexMarker443"/> implementation<a id="_idIndexMarker444"/> of the <strong class="bold">Tree SHAP algorithm</strong> (<a href="https://arxiv.org/pdf/1802.03888.pdf">https://arxiv.org/pdf/1802.03888.pdf</a>) for<a id="_idIndexMarker445"/> computing Shapley values for trees and tree-based ensemble learning algorithms. The algorithm makes many diverse possible assumptions about the feature dependence of the features present in the dataset. Only tree-based algorithms are supported such as <em class="italic">Random Forest</em>, <em class="italic">XGBoost</em>,<em class="italic"> LightGBM</em>, and <em class="italic">CatBoost</em>. The algorithm relies on fast C++ implementations <a id="_idIndexMarker446"/>in either the<a id="_idIndexMarker447"/> local compiled C extension or inside an external model package, but it is faster than conventional Shapley value-based explainers. Generally, it is used for tree-based models trained on structured data for both classification and regression problems. </p>
			<h3>DeepExplainer</h3>
			<p>Similar to LIME, SHAP <a id="_idIndexMarker448"/>can also be applied to deep learning <a id="_idIndexMarker449"/>models trained on unstructured data, such as images and texts. SHAP uses DeepExplainer, which is based on the <strong class="bold">Deep SHAP algorithm</strong> for explaining <a id="_idIndexMarker450"/>deep learning models. The DeepExplainer algorithm is designed for deep learning models to approximate SHAP values. The algorithm is a modified version <a id="_idIndexMarker451"/>of the <strong class="bold">DeepLIFT algorithm</strong> (<a href="https://arxiv.org/abs/1704.02685">https://arxiv.org/abs/1704.02685</a>). The developers of the framework have mentioned that the implementation of the Deep SHAP algorithm differs slightly from the original DeepLIFT algorithm. It uses a distribution of background samples rather than a single reference value. Additionally, the Deep SHAP algorithm also uses Shapley equations to linearize computations such as products, division, max, softmax, and more. The framework mostly supports deep learning frameworks such as TensorFlow, Keras, and PyTorch.</p>
			<h3>GradientExplainer</h3>
			<p>DeepExplainer <a id="_idIndexMarker452"/>is not the only explainer in SHAP that <a id="_idIndexMarker453"/>can be used with deep learning models. GradientExplainer can also work with deep learning models. The algorithm explains models using the concept<a id="_idIndexMarker454"/> of <strong class="bold">expected gradients</strong>. The expected gradient is an<a id="_idIndexMarker455"/> extension of <strong class="bold">Integrated Gradients</strong> (<a href="https://arxiv.org/abs/1703.01365">https://arxiv.org/abs/1703.01365</a>), SHAP, and <strong class="bold">SmoothGrad</strong> (<a href="https://arxiv.org/abs/1706.03825">https://arxiv.org/abs/1706.03825</a>), which <a id="_idIndexMarker456"/>combines the ideas of these algorithms into a single expected value equation. Consequently, similar to DeepExplainer, the entire dataset can be used as the background distribution sample instead of a single reference sample. This allows the model to be approximated with a linear function between individual samples of the data and the current input data instance that is to be explained. Since the input features are assumed to be independent, the expected gradients will calculate the approximate SHAP values.</p>
			<p>For model <a id="_idIndexMarker457"/>explainability, the feature values with higher SHAP values are highlighted, as these features have a positive contribution toward the model's outcome. For unstructured<a id="_idIndexMarker458"/> data such as images, pixel positions that have the maximum contribution toward the model prediction are highlighted. Usually, GradientExplainer is slower than DeepExplainer as it makes different approximation assumptions. </p>
			<p>The following diagram shows a sample GradientExplainer visualization for the local explainability of a classification model trained on images:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B18216_06_015.jpg" alt="Figure 6.15 – Visualizations used by SHAP GradientExplainers for local explainability &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – Visualizations used by SHAP GradientExplainers for local explainability </p>
			<p>Next, let's discuss SHAP KernelExplainers.</p>
			<h3>KernelExplainer</h3>
			<p>KernelExplainers <a id="_idIndexMarker459"/>in SHAP<a id="_idIndexMarker460"/> use the <strong class="bold">Kernel SHAP</strong> method<a id="_idIndexMarker461"/> to provide model-agnostic explainability. To estimate the SHAP values for any model, the Kernel SHAP algorithm utilizes a specifically weighted local linear regression approach to compute feature importance. The approach is similar to the LIME algorithm that we have discussed in <a href="B18216_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">LIME for Model Interpretability</em>. The major difference between Kernel SHAP and LIME is the approach that is adopted to assign weights to the<a id="_idIndexMarker462"/> instances in a regression model. </p>
			<p>In LIME, the weights are assigned based on how close the local data instances are to the original instance. Whereas in Kernel SHAP, the weights are assigned based on the estimated Shapley <a id="_idIndexMarker463"/>values of the coalition of features used. In simple words, LIME assigns weights based on isolated features, whereas SHAP considers the combined effect of the features for assigning the weights. KernelExplainer is slower than model-specific algorithms as it does not make any assumptions about the model type.</p>
			<h3>LinearExplainer</h3>
			<p>SHAP<a id="_idIndexMarker464"/> LinearExplainer is designed for computing SHAP <a id="_idIndexMarker465"/>values for linear models to analyze inter-feature correlations. LinearExplainer also supports the estimation of the feature covariance matrix for coalition feature importance. However, finding feature correlations for a high-dimensional dataset can be com<a id="_idTextAnchor117"/>putationally expensive. But LinearExplainers are fast and efficient as they use sampling to estimate a transformation. This is then used for explaining any outcome of linear models.</p>
			<p>Therefore, we have discussed the theoretical aspect of various explainers in SHAP. For more information about <a id="_idIndexMarker466"/>these explainers, I do recommend checking out <a href="https://shap-lrjball.readthedocs.io/en/docs_update/api.html">https://shap-lrjball.readthedocs.io/en/docs_update/api.html</a>. In the next chapter, we will cover the practical implementation of the SHAP explainers using the code tutorials on GitHub in which we will implement the SHAP explainers for explaining models trained on different types of datasets. In the next section, we will cover a practical tutorial on how to use SHAP for explaining regression models to give you a glimpse of how to apply SHAP for model explainability.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor118"/>Using SHAP to explain regression models</h1>
			<p>In the previous section, we learned about different visualizations and explainers in SHAP for explaining ML models. Now, I will give you practical exposure to using SHAP for providing <a id="_idIndexMarker467"/>model <a id="_idIndexMarker468"/>explainability. The framework is available as an open source project on GitHub: <a href="https://github.com/slundberg/shap">https://github.com/slundberg/shap</a>. You can get the API documentation at <a href="https://shap-lrjball.readthedocs.io/en/docs_update/index.html">https://shap-lrjball.readthedocs.io/en/docs_update/index.html</a>. The complete tutorial is provided in the GitHub repository at <a href="https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/blob/main/Chapter06/Intro_to_SHAP.ipynb">https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/blob/main/Chapter06/Intro_to_SHAP.ipynb</a>. I strongly recommend that you read this section and execute the code side by side. </p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor119"/>Setting up SHAP</h2>
			<p>Installing <a id="_idIndexMarker469"/>SHAP in Python can be done easily using the pip installer by using the following command in your console:</p>
			<p class="source-code">pip install shap</p>
			<p>Since the tutorial requires you to have other Python frameworks installed, you can also try the following command to install all the necessary modules for the tutorial from the Jupyter notebook itself if it is not installed already:</p>
			<pre class="source-code">!pip install --upgrade pandas numpy matplotlib seaborn scikit-learn shap</pre>
			<p>Now, let's import SHAP and check its version:</p>
			<pre class="source-code">import shap</pre>
			<pre class="source-code">print(f"Shap version used: {shap.__version__}")</pre>
			<p>The version that I have used for this tutorial is <em class="italic">0.40.0</em>. </p>
			<p>Please note that with different versions, there can be different changes to the API or different errors that you might face. So, I will recommend you to look at the latest documentation of the<a id="_idIndexMarker470"/> framework if you encounter any such issues. I have also added a <strong class="bold">SHAP Errata</strong> (<a href="https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/tree/main/Chapter06/SHAP_ERRATA">https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/tree/main/Chapter06/SHAP_ERRATA</a>) in the repository for providing solutions to existing known issues with the SHAP framework.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor120"/>Inspecting the dataset</h2>
			<p>For this tutorial, we will use the <em class="italic">Red Wine Quality Dataset</em> from <em class="italic">Kaggle</em>: <a href="https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009">https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009</a>. The dataset has already been added <a id="_idIndexMarker471"/>to the code repository so that it is easy for you to access the data. This particular dataset contains information about the red variant of the Portuguese <em class="italic">Vinho Verde</em> wine, and it is derived from the original UCI source at <a href="https://archive.ics.uci.edu/ml/datasets/wine+quality">https://archive.ics.uci.edu/ml/datasets/wine+quality</a>. </p>
			<p class="callout-heading">Wine Quality Data Set</p>
			<p class="callout">The credit for this dataset goes to <em class="italic">P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis. Modeling wine preferences by data mining from physicochemical properties.</em></p>
			<p>We will use this dataset to solve a regression problem. We will load the data as a pandas DataFrame and perform an initial inspection:</p>
			<pre class="source-code">data = pd.read_csv('dataset/winequality-red.csv')</pre>
			<pre class="source-code">data.head()</pre>
			<p><em class="italic">Figure 6.16</em> illustrates a snapshot of the data:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B18216_06_016.jpg" alt="Figure 6.16 – Snapshot of the pandas DataFrame of the Wine Quality dataset&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – Snapshot of the pandas DataFrame of the Wine Quality dataset</p>
			<p>We can check some quick information about the dataset using the following command:</p>
			<pre class="source-code">data.info()</pre>
			<p>This gives the following output:</p>
			<pre class="source-code">RangeIndex: 1599 entries, 0 to 1598</pre>
			<pre class="source-code">Data columns (total 12 columns):</pre>
			<pre class="source-code"> #   Column                Non-Null Count  Dtype  </pre>
			<pre class="source-code">---  ------                --------------  -----  </pre>
			<pre class="source-code"> 0   fixed acidity         1599 non-null   float64</pre>
			<pre class="source-code"> 1   volatile acidity      1599 non-null   float64</pre>
			<pre class="source-code"> 2   citric acid           1599 non-null   float64</pre>
			<pre class="source-code"> 3   residual sugar        1599 non-null   float64</pre>
			<pre class="source-code"> 4   chlorides             1599 non-null   float64</pre>
			<pre class="source-code"> 5   free sulfur dioxide   1599 non-null   float64</pre>
			<pre class="source-code"> 6   total sulfur dioxide  1599 non-null   float64</pre>
			<pre class="source-code"> 7   density               1599 non-null   float64</pre>
			<pre class="source-code"> 8   pH                    1599 non-null   float64</pre>
			<pre class="source-code"> 9   sulphates             1599 non-null   float64</pre>
			<pre class="source-code"> 10  alcohol               1599 non-null   float64</pre>
			<pre class="source-code"> 11  quality               1599 non-null   int64  </pre>
			<pre class="source-code">dtypes: float64(11), int64(1)</pre>
			<pre class="source-code">memory usage: 150.0 KB</pre>
			<p>As <a id="_idIndexMarker472"/>you can see, our dataset consists of <em class="italic">11 numerical features</em> and <em class="italic">1,599</em> records of data. The target outcome that the regression model will be learning is the <em class="italic">quality</em> of the wine, which is an <em class="italic">integer feature</em>. Although we are using this dataset for solving a regression problem, the same problem can be viewed as a classification problem and the same underlying data can be used.</p>
			<p>The purpose of the tutorial is not for building an extremely efficient model, but rather to consider any model and use SHAP to explain the workings of the model. So, we will skip the EDA, data normalization, outlier detection, and even feature engineering steps, which are, otherwise, crucial steps for building a robust ML model. But missing values in the dataset can create problems for the SHAP algorithm. Therefore, I would suggest doing a quick check of missing values at the very least:</p>
			<pre class="source-code">sns.displot(</pre>
			<pre class="source-code">    data=data.isna().melt(value_name="missing"),</pre>
			<pre class="source-code">    y="variable",</pre>
			<pre class="source-code">    hue="missing",</pre>
			<pre class="source-code">    multiple="fill",</pre>
			<pre class="source-code">    aspect=1.5</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">plt.show()</pre>
			<p>The preceding<a id="_idIndexMarker473"/> lines of code will result in the following plot as its output:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B18216_06_017.jpg" alt="Figure 6.17 – The missing plot visualization for the dataset&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – The missing plot visualization for the dataset</p>
			<p>Fortunately, the dataset doesn't have any missing values; otherwise, we might have to handle this before proceeding further. But we are good to proceed with the modeling step as there are no significant issues with the data.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Training the model</h2>
			<p>Since I do<a id="_idIndexMarker474"/> not have any pretrained model for this dataset, I thought of building a simple random forest model. We can divide the model into a training and a testing set using the 80:20 split ratio:</p>
			<pre class="source-code">features = data.drop(columns=['quality'])</pre>
			<pre class="source-code">labels = data['quality']</pre>
			<pre class="source-code"># Dividing the data into training-test set with 80:20 split ratio</pre>
			<pre class="source-code">x_train,x_test,y_train,y_test = train_test_split(</pre>
			<pre class="source-code">    features,labels,test_size=0.2, random_state=123)</pre>
			<p>To use the<a id="_idIndexMarker475"/> random forest algorithm, we would need to import this algorithm from the scikit-learn module and then fit the regression model on the training data:</p>
			<pre class="source-code">from sklearn.ensemble import RandomForestRegressor</pre>
			<pre class="source-code">model = RandomForestRegressor(n_estimators=2000, </pre>
			<pre class="source-code">                              max_depth=30, </pre>
			<pre class="source-code">                              random_state=123)</pre>
			<pre class="source-code">model.fit(x_train, y_train)</pre>
			<p class="callout-heading">Important Note </p>
			<p class="callout">Considering the objective of this notebook, we are not doing an extensive hyperparameter tuning process. But I would strongly recommend you to perform all necessary best practices like<em class="italic"> EDA, feature engineering, hyperparameter tuning, cross-validation</em>, and others for your use cases. </p>
			<p>Once the trained model is ready, we will do a quick evaluation of the model using the metric <a id="_idIndexMarker476"/>of <strong class="bold">coefficient of determination</strong> (<strong class="bold">R2 coefficient</strong>): </p>
			<pre class="source-code">model.score(x_test, y_test)</pre>
			<p>The model score obtained is just around 0.5, which indicates that the model is not very efficient. So, model explainability is even more important for such models. Now, let's use SHAP to explain the model.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Application of SHAP</h2>
			<p>Applying SHAP<a id="_idIndexMarker477"/> is very easy and can be done in a few lines of code. First, we will use the Shapley value-based explainer on the test dataset:</p>
			<pre class="source-code">explainer = shap.Explainer(model)</pre>
			<pre class="source-code">shap_values = explainer(x_test)</pre>
			<p>Then, we can use the SHAP values for the various visualization techniques discussed earlier. The choice of the visualizations depends on whether we want to go for global explainability or local explainability. For example, for the summary plot shown in <em class="italic">Figure 6.9</em>, we can use the following code:</p>
			<pre class="source-code">plt.title('Feature Importance using SHAP')</pre>
			<pre class="source-code">shap.plots.bar(shap_values, show=True, max_display=12)</pre>
			<p>To provide local explainability, if we want to use the decision plot shown in <em class="italic">Figure 6.14</em>, we can try the following code:</p>
			<pre class="source-code">expected_value = explainer.expected_value</pre>
			<pre class="source-code">shap_values = explainer.shap_values(x_test)[0]</pre>
			<pre class="source-code">shap.decision_plot(expected_value, shap_values, x_test)</pre>
			<p>To use a different explainer algorithm, we just need to select the appropriate explainer. For Tree Explainers, we can try the following code:</p>
			<pre class="source-code">explainer = shap.TreeExplainer(model)</pre>
			<pre class="source-code">shap_values = explainer.shap_values(x_test)</pre>
			<p>The usage of this framework to explain the regression model while considering various aspects has already been covered in the notebook tutorial: <a href="https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/blob/main/Chapter06/Intro_to_SHAP.ipynb">https://github.com/PacktPublishing/Applied-Machine-Learning-Explainability-Techniques/blob/main/Chapter06/Intro_to_SHAP.ipynb</a>.</p>
			<p>In the next chapter, we will cover more interesting use cases. Next, let's discuss some advantages and disadvantages of this framework.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor123"/>Advantages and limitations of SHAP</h1>
			<p>In the previous section, we discussed the practical application of SHAP for explaining a regression model with just a few lines of code. However, since SHAP is not the only explainability framework, we should be aware of the specific advantages and disadvantages of SHAP, too.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor124"/>Advantages </h2>
			<p>The following is a list of <a id="_idIndexMarker478"/>some of the advantages of SHAP:</p>
			<ul>
				<li><strong class="bold">Local explainability</strong>: Since SHAP provides local explainability to inference data, it enables users to analyze key factors that are positively or negatively affecting the model's decision-making process. As SHAP provides local explainability, it is useful for production-level ML systems, too.</li>
				<li><strong class="bold">Global explainability</strong>: Global explainability provided in SHAP helps to extract key information about the model and the training data, especially from the collective feature importance plots. I think SHAP is better than LIME for getting a global perspective on the model. SP-LIME in LIME is good for getting an example-driven global perspective of the model, but I think SHAP provides a generalized global understanding of trained models.</li>
				<li><strong class="bold">Model-agnostic and model-specific</strong>: SHAP can be model-agnostic and model-specific. So, it can work with black-box models and also work with complex deep learning models to provide explainability.</li>
				<li><strong class="bold">Theoretical robustness</strong>: The concept of using Shapley values for model explainability, which is based on the principles of coalition game theory, captures feature interaction very well. Also, the properties of SHAP regarding <em class="italic">efficiency</em>, <em class="italic">symmetry</em>, <em class="italic">dummy</em>, and <em class="italic">additivity</em> are formulated on a robust theoretical foundation. Unlike SHAP, LIME is not based on a solid theory as it assumes ML models will behave linearly for some local data points. But there is not much theoretical evidence that proves why this assumption is true for all cases. That is why I would say SHAP is based on ideas that are theoretically more robust than LIME.</li>
			</ul>
			<p>These advantages make SHAP one of the most popular choices of the XAI framework. Unfortunately, applying SHAP can be really challenging for high-dimensional datasets as it does not provide actionable explanations. Let's look at some of the limitations of SHAP.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor125"/>Limitations</h2>
			<p>Here is a list of some <a id="_idIndexMarker479"/>of the limitations of SHAP:</p>
			<ul>
				<li><strong class="bold">SHAP is not the preferred choice for high-dimensional data</strong>: Computing Shapley values on high-dimensional data can be computationally more challenging, as the time complexity of the algorithm is <img src="image/B18216_06_011.png" alt=""/>, where <em class="italic">n</em> is the total number of features in the dataset. </li>
				<li><strong class="bold">Shapley values are ineffective for selective explanation</strong>: Shapley values try to consider all the features for providing explainability. The explanations can be incorrect for sparse explanations, in which only selected features are considered. But usually, human-friendly explanations consider selective features. So, I would say that LIME is better than SHAP when you seek a selective explanation. However, more recent versions of the SHAP framework do include the same ideas as LIME and can be almost equally effective for sparse explanations.</li>
				<li><strong class="bold">SHAP cannot be used for prescriptive insights</strong>: SHAP computes the Shapley values for each feature and does not build a prediction model like LIME. So, it cannot be used for analyzing any <em class="italic">what-if scenario</em> or for providing any <em class="italic">counter-factual example</em> for suggesting actionable insights. </li>
				<li><strong class="bold">KernelSHAP can be slow</strong>: Although KernelSHAP is model-agnostic, it can be very slow and, thus, might not be suitable for production-level ML systems for models trained on high-dimensional data.</li>
				<li><strong class="bold">Not extremely human-friendly</strong>: Apart from analyzing feature importance through feature interactions, SHAP visualizations can be complicated to interpret for any non-technical user. Often, non-technical users prefer simple selective actionable insights, recommendations, or justifications from ML models. Unfortunately, SHAP requires another layer of abstraction for human-friendly <a id="_idIndexMarker480"/>explanations when used in production systems.</li>
			</ul>
			<p>As we can see from the points discussed in this section, SHAP might not be the most ideal framework for explainability, and there is a lot of space for improvement to make it more human-friendly. However, it is indeed an important and very useful framework for explaining black-box algorithms, especially for technical users. This brings us to the end of the chapter. Let's summarize what we have learned in the chapter.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor126"/>Summary</h1>
			<p>In this chapter, we focused on understanding the importance of the SHAP framework for model explainability. By now, you have a good understanding of Shapley values and SHAP. We have covered how to use SHAP for model explainability through a variety of visualization and explainer methods. Also, we have covered a code walk-through for using SHAP to explain regression models. Finally, we discussed some advantages and limitations of the framework. </p>
			<p>In the next chapter, we will cover more interesting practical use cases for applying SHAP on different types of datasets. </p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor127"/>References</h1>
			<p>For additional information, please refer to the following resources:</p>
			<ul>
				<li><em class="italic">Shapley, Lloyd S. "A Value for n-Person Games." Contributions to the Theory of Games 2.28 (1953)</em>: <a href="https://doi.org/10.1515/9781400881970-018">https://doi.org/10.1515/9781400881970-018</a></li>
				<li>The Red Wine Quality dataset from Kaggle: <a href="https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009">https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009</a></li>
				<li>The SHAP GitHub project: <a href="https://github.com/slundberg/shap">https://github.com/slundberg/shap</a></li>
				<li>The official SHAP documentation: <a href="https://shap.readthedocs.io/en/latest/index.html">https://shap.readthedocs.io/en/latest/index.html</a></li>
			</ul>
		</div>
	</body></html>