["```py\n\n#include<iostream>\n#include <cuda.h>\n#include <cuda_runtime.h>\n//Defining number of elements in Array\n#define N 50000\n//Defining Kernel function for vector addition\n__global__ void gpuAdd(int *d_a, int *d_b, int *d_c) {\n //Getting Thread index of current kernel\n int tid = threadIdx.x + blockIdx.x * blockDim.x;\n while (tid < N)\n {\n d_c[tid] = d_a[tid] + d_b[tid];\n tid += blockDim.x * gridDim.x;\n }\n}\n```", "```py\nint main(void) \n{\n //Defining host arrays\n int h_a[N], h_b[N], h_c[N];\n //Defining device pointers\n int *d_a, *d_b, *d_c;\n cudaEvent_t e_start, e_stop;\n cudaEventCreate(&e_start);\n cudaEventCreate(&e_stop);\n cudaEventRecord(e_start, 0);\n // allocate the memory\n cudaMalloc((void**)&d_a, N * sizeof(int));\n cudaMalloc((void**)&d_b, N * sizeof(int));\n cudaMalloc((void**)&d_c, N * sizeof(int));\n //Initializing Arrays\n for (int i = 0; i < N; i++) {\n h_a[i] = 2 * i*i;\n h_b[i] = i;\n }\n // Copy input arrays from host to device memory\n cudaMemcpy(d_a, h_a, N * sizeof(int), cudaMemcpyHostToDevice);\n cudaMemcpy(d_b, h_b, N * sizeof(int), cudaMemcpyHostToDevice);\n //Calling kernels passing device pointers as parameters\n gpuAdd << <1024, 1024 >> >(d_a, d_b, d_c);\n //Copy result back to host memory from device memory\n cudaMemcpy(h_c, d_c, N * sizeof(int), cudaMemcpyDeviceToHost);\n cudaDeviceSynchronize();\n cudaEventRecord(e_stop, 0);\n cudaEventSynchronize(e_stop);\n float elapsedTime;\n cudaEventElapsedTime(&elapsedTime, e_start, e_stop);\n printf(\"Time to add %d numbers: %3.1f ms\\n\",N, elapsedTime);\n\n```", "```py\n int Correct = 1;\n printf(\"Vector addition on GPU \\n\");\n //Printing result on console\n for (int i = 0; i < N; i++) {\n if ((h_a[i] + h_b[i] != h_c[i]))\n {\n  Correct = 0;\n }\n\n }\n if (Correct == 1)\n {\n printf(\"GPU has computed Sum Correctly\\n\");\n }\n else\n {\n printf(\"There is an Error in GPU Computation\\n\");\n }\n //Free up memory\n cudaFree(d_a);\n cudaFree(d_b);\n cudaFree(d_c);\n return 0;\n}\n```", "```py\n$ nvcc 01_performance_cuda_events.cu -o gpu_add\n$ ./gpu_add\n```", "```py\n$ sudo apt-get purge libopencv*\n```", "```py\n$ sudo apt-get update\n$ sudo apt-get dist-upgrade\n```", "```py\n$ sudo apt-get install --only-upgrade gcc-5 cpp-5 g++-5\n$ sudo apt-get install build-essential make cmake cmake-curses-gui libglew-dev libgtk2.0-dev\n```", "```py\nsudo apt-get install libdc1394-22-dev libxine2-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev\n```", "```py\n$ wget https://github.com/opencv/opencv/archive/3.4.0.zip -O opencv.zip\n$ unzip opencv.zip\n```", "```py\n$ cd opencv\n$ mkdir build\n$ cd build \n```", "```py\ncmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local \\\n -D WITH_CUDA=ON -D CUDA_ARCH_BIN=\"5.3\" -D CUDA_ARCH_PTX=\"\" \\\n -D WITH_CUBLAS=ON -D ENABLE_FAST_MATH=ON -D CUDA_FAST_MATH=ON \\\n -D ENABLE_NEON=ON -D WITH_LIBV4L=ON -D BUILD_TESTS=OFF \\\n -D BUILD_PERF_TESTS=OFF -D BUILD_EXAMPLES=OFF \\\n -D WITH_QT=ON -D WITH_OPENGL=ON ..\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main()\n{\n Mat img = imread(\"images/cameraman.tif\",0);\n if (img.empty()) \n {\n cout << \"Could not open an image\" << endl;\n return -1;\n }\n imshow(\"Image Read on Jetson TX1\"; , img); \n waitKey(0); \n return 0;\n}\n```", "```py\nFor compilation:\n$ g++ -std = c++11 image_read.cpp 'pkg_config --libs --cflags opencv' -o image_read\nFor execution:\n$./image_read\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\n#include \"opencv2/core/cuda.hpp\"\n\nint main (int argc, char* argv[])\n{\n //Read Two Images \n cv::Mat h_img1 = cv::imread(\"images/cameraman.tif\");\n cv::Mat h_img2 = cv::imread(\"images/circles.png\");\n int64 work_begin = cv::getTickCount(); \n //Create Memory for storing Images on device\n cv::cuda::GpuMat d_result1,d_img1, d_img2;\n cv::Mat h_result1;\n //Upload Images to device \n d_img1.upload(h_img1);\n d_img2.upload(h_img2);\n\n cv::cuda::add(d_img1,d_img2, d_result1);\n //Download Result back to host\n d_result1.download(h_result1);\n cv::imshow(\"Image1 \", h_img1);\n cv::imshow(\"Image2 \", h_img2);\n cv::imshow(\"Result addition \", h_result1);\n int64 delta = cv::getTickCount() - work_begin;\n //Frequency of timer\n double freq = cv::getTickFrequency();\n double work_fps = freq / delta;\n std::cout<<\"Performance of Addition on Jetson TX1: \" <<std::endl;\n std::cout <<\"Time: \" << (1/work_fps) <<std::endl;\n std::cout <<\"FPS: \" <<work_fps <<std::endl;\n\n cv::imshow(\"result_add.png\", h_result1);\n cv::waitKey();\n return 0;\n}\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\nusing namespace cv;\nint main (int argc, char* argv[])\n{\n cv::Mat h_img1 = cv::imread(\"images/cameraman.tif\", 0);\n cv::cuda::GpuMat d_result1,d_result2,d_result3,d_result4,d_result5, d_img1;\n //Measure initial time ticks\n int64 work_begin = getTickCount(); \n d_img1.upload(h_img1);\n cv::cuda::threshold(d_img1, d_result1, 128.0, 255.0, cv::THRESH_BINARY);\n cv::cuda::threshold(d_img1, d_result2, 128.0, 255.0, cv::THRESH_BINARY_INV);\n cv::cuda::threshold(d_img1, d_result3, 128.0, 255.0, cv::THRESH_TRUNC);\n cv::cuda::threshold(d_img1, d_result4, 128.0, 255.0, cv::THRESH_TOZERO);\n cv::cuda::threshold(d_img1, d_result5, 128.0, 255.0, cv::THRESH_TOZERO_INV);\n\n cv::Mat h_result1,h_result2,h_result3,h_result4,h_result5;\n d_result1.download(h_result1);\n d_result2.download(h_result2);\n d_result3.download(h_result3);\n d_result4.download(h_result4);\n d_result5.download(h_result5);\n //Measure difference in time ticks\n int64 delta = getTickCount() - work_begin;\n double freq = getTickFrequency();\n //Measure frames per second\n double work_fps = freq / delta;\n std::cout <<\"Performance of Thresholding on GPU: \" <<std::endl;\n std::cout <<\"Time: \" << (1/work_fps) <<std::endl;\n std::cout <<\"FPS: \" <<work_fps <<std::endl;\n return 0;\n}\n```", "```py\n#include <iostream>\n#include <string>\n#include \"opencv2/opencv.hpp\"\n\nusing namespace std;\nusing namespace cv;\nusing namespace cv::cuda;\n\nint main()\n{\n Mat h_img1;\n cv::cuda::GpuMat d_img1,d_blur,d_result3x3;\n h_img1 = imread(\"images/blobs.png\",1);\n\n int64 start = cv::getTickCount();\n d_img1.upload(h_img1);\n cv::cuda::cvtColor(d_img1,d_img1,cv::COLOR_BGR2GRAY);\n cv::Ptr<cv::cuda::Filter> filter3x3;\n filter3x3 = cv::cuda::createGaussianFilter(CV_8UC1,CV_8UC1,cv::Size(3,3),1);\n filter3x3->apply(d_img1, d_blur);\n\n cv::Ptr<cv::cuda::Filter> filter1;\n filter1 = cv::cuda::createLaplacianFilter(CV_8UC1,CV_8UC1,1);\n filter1->apply(d_blur, d_result3x3);\n\n cv::Mat h_result3x3,h_blur;\n d_result3x3.download(h_result3x3);\n d_blur.download(h_blur);\n\n double fps = cv::getTickFrequency() / (cv::getTickCount() - start);\n std::cout << \"FPS : \" << fps << std::endl;\n imshow(\"Laplacian\", h_result3x3);\n imshow(\"Blurred\", h_blur);\n cv::waitKey();\n return 0;\n}\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <stdio.h>\nusing namespace cv;\nusing namespace std;\n\nint main(int, char**)\n{\n Mat frame;\n // open the default camera using default API\n VideoCapture cap(\"nvcamerasrc ! video/x-raw(memory:NVMM), width=(int)1280, height=(int)720, format=(string)I420, framerate=(fraction)24/1 ! nvvidconv flip-method=0 ! video/x-raw, format=(string)I420 ! videoconvert ! video/x-raw, format=(string)BGR ! appsink\"); \n if (!cap.isOpened()) {\n cout << \"Unable to open camera\\n\";\n return -1;\n }\n while (1)\n {\n int64 start = cv::getTickCount();\n cap.read(frame);\n // check if we succeeded\n if (frame.empty()) {\n  cout << \"Can not read frame\\n\";\n  break;\n }\n double fps = cv::getTickFrequency() / (cv::getTickCount() - start);\n std::cout << \"FPS : \" << fps << std::endl;\n\n imshow(\"Live\", frame);\n if (waitKey(30) == 'q')\n  break;\n }\n\n return 0;\n}\n```", "```py\nVideoCapture cap(\"nvcamerasrc ! video/x-raw(memory:NVMM), width=(int)1280, height=(int)720, format=(string)I420, framerate=(fraction)24/1 ! nvvidconv flip-method=0 ! video/x-raw, format=(string)I420 ! videoconvert ! video/x-raw, format=(string)BGR ! appsink\");\n```", "```py\n#include <iostream>\n#include <opencv2/opencv.hpp>\nusing namespace cv;\nusing namespace std;\n\nint main()\n{\n VideoCapture cap(\"images/output.avi\");\n//cv::VideoCapture cap(\"nvcamerasrc ! video/x-raw(memory:NVMM), width=(int)1280, height=(int)720, format=(string)I420, framerate=(fraction)24/1 ! nvvidconv flip-method=0 ! video/x-raw, format=(string)I420 ! videoconvert ! video/x-raw, format=(string)BGR ! appsink\"); \n if (!cap.isOpened()) {\n   cout << \"Can not open video source\";\n   return -1;\n }\n std::vector<cv::Rect> h_found;\n cv::Ptr<cv::cuda::CascadeClassifier> cascade = cv::cuda::CascadeClassifier::create(\"haarcascade_frontalface_alt2.xml\");\n cv::cuda::GpuMat d_frame, d_gray, d_found;\n while(1)\n {\n Mat frame;\n if ( !cap.read(frame) ) {\n   cout << \"Can not read frame from webcam\";\n   return -1;\n }\n int64 start = cv::getTickCount();\n d_frame.upload(frame);\n cv::cuda::cvtColor(d_frame, d_gray, cv::COLOR_BGR2GRAY);\n\n cascade->detectMultiScale(d_gray, d_found);\n cascade->convert(d_found, h_found);\n\n for(int i = 0; i < h_found.size(); ++i)\n {\n   rectangle(frame, h_found[i], Scalar(0,255,255), 5);\n }\n double fps = cv::getTickFrequency() / (cv::getTickCount() - start);\n std::cout << \"FPS : \" << fps << std::endl;\n imshow(\"Result\", frame);\n if (waitKey(1) == 'q') {\n   break;\n }\n }\n\n return 0;\n}\n```", "```py\n#include \"opencv2/objdetect/objdetect.hpp\"\n#include \"opencv2/highgui/highgui.hpp\"\n#include \"opencv2/imgproc/imgproc.hpp\"\n#include \"opencv2/cudaobjdetect.hpp\" \n#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\nusing namespace cv;\n\nint main( )\n{\n  Mat h_image;\n  h_image = imread(\"images/lena_color_512.tif\", 0); \n  Ptr<cuda::CascadeClassifier> cascade =       cuda::CascadeClassifier::create(\"haarcascade_eye.xml\");\n  cuda::GpuMat d_image;\n  cuda::GpuMat d_buf;\n  int64 start = cv::getTickCount();\n  d_image.upload(h_image);\n  cascadeGPU->setMinNeighbors(0);\n  cascadeGPU->setScaleFactor(1.02);\n  cascade->detectMultiScale(d_image, d_buf);\n  std::vector<Rect> detections;\n  cascade->convert(d_buf, detections);\n if (detections.empty())\n   std::cout << \"No detection.\" << std::endl;\n   cvtColor(h_image,h_image,COLOR_GRAY2BGR);\n for(int i = 0; i < detections.size(); ++i)\n {\n   rectangle(h_image, detections[i], Scalar(0,255,255), 5);\n }\n double fps = cv::getTickFrequency() / (cv::getTickCount() - start);\n std::cout << \"FPS : \" << fps << std::endl;\n imshow(\"Result image on Jetson TX1\", h_image);\n\n waitKey(0); \n return 0;\n}\n```", "```py\n#include <iostream>\n#include <string>\n#include \"opencv2/opencv.hpp\"\n\nusing namespace std;\nusing namespace cv;\nusing namespace cv::cuda;\nint main()\n{\n\n VideoCapture cap(\"nvcamerasrc ! video/x-raw(memory:NVMM), width=(int)1280, height=(int)720, format=(string)I420, framerate=(fraction)24/1 ! nvvidconv flip-method=0 ! video/x-raw, format=(string)I420 ! videoconvert ! video/x-raw, format=(string)BGR ! appsink\");\n if (!cap.isOpened())\n {\n cout << \"Can not open camera or video file\" << endl;\n return -1;\n }\n Mat frame;\n cap.read(frame);\n GpuMat d_frame;\n d_frame.upload(frame);\n Ptr<BackgroundSubtractor> mog = cuda::createBackgroundSubtractorMOG();\n GpuMat d_fgmask,d_fgimage,d_bgimage;\n Mat h_fgmask,h_fgimage,h_bgimage;\n mog->apply(d_frame, d_fgmask, 0.01);\n namedWindow(\"image\", WINDOW_NORMAL);\n namedWindow(\"foreground mask\", WINDOW_NORMAL);\n namedWindow(\"foreground image\", WINDOW_NORMAL);\n namedWindow(\"mean background image\", WINDOW_NORMAL);\n\n while(1)\n {\n cap.read(frame);\n if (frame.empty())\n  break;\n d_frame.upload(frame);\n int64 start = cv::getTickCount();\n mog->apply(d_frame, d_fgmask, 0.01);\n mog->getBackgroundImage(d_bgimage);\n double fps = cv::getTickFrequency() / (cv::getTickCount() - start);\n std::cout << \"FPS : \" << fps << std::endl;\n d_fgimage.create(d_frame.size(), d_frame.type());\n d_fgimage.setTo(Scalar::all(0));\n d_frame.copyTo(d_fgimage, d_fgmask);\n d_fgmask.download(h_fgmask);\n d_fgimage.download(h_fgimage);\n d_bgimage.download(h_bgimage);\n imshow(\"image\", frame);\n imshow(\"foreground mask\", h_fgmask);\n imshow(\"foreground image\", h_fgimage);\n imshow(\"mean background image\", h_bgimage);\n if (waitKey(1) == 'q')\n  break;\n }\n\n return 0;\n}\n```", "```py\nimport numpy as np\nimport cv2\nimg = cv2.imread('images/cameraman.tif',0)\ncv2.imshow(\"Image read in Python\", img)\nk = cv2.waitKey(0) & 0xFF\nif k == 27: # wait for ESC key to exit\n cv2.destroyAllWindows()\n```", "```py\n# For Python2.7\n$ python image_read.py\n# For Python 3\n$ python image_read.py\n```"]