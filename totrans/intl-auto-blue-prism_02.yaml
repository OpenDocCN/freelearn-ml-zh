- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Predicting from Command Prompt and PowerShell
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令提示符和PowerShell进行预测
- en: Web APIs are the most common way to communicate with **ML** services. However,
    there are many reasons why you might not be able to use *external* web APIs. For
    example, compliance and regulatory requirements may prevent you from sending data
    outside your firm, or there might not be a suitable ML service for your use case.
    Even for *internally* developed ML models, there are reasons to not use web APIs
    as the communication method. An example is to run models directly on the Digital
    Worker API as this doesn’t require additional web server infrastructure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web API是与机器学习服务通信的最常见方式。然而，有许多原因可能无法使用*外部* Web API。例如，合规性和监管要求可能阻止你将数据发送到公司外部，或者可能没有适合你用例的机器学习服务。即使是*内部*开发的机器学习模型，也有不使用Web
    API作为通信方式的原因。一个例子是直接在Digital Worker API上运行模型，因为这不需要额外的Web服务器基础设施。
- en: This chapter shows you some different ways that an ML model can be run *locally*
    through **BP**. We’ll go through examples of how this can be done using **Windows
    Command Prompt** (**WCP**) and **PowerShell** (**PS**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了如何通过**BP**以不同的方式在本地运行机器学习模型。我们将通过使用**Windows命令提示符**（**WCP**）和**PowerShell**（**PS**）的示例来展示如何做到这一点。
- en: During my research on **IA**, I tried to discover what underlying technologies,
    libraries, and ML algorithms were being used. *Python* was the only programming
    language that was being used in production (outside of the built-in C# and VB.NET
    used in **RPA**), despite R and Julia being popular languages used to teach ML
    in schools. In the final example of this chapter, we’ll be calling a Python script
    in BP.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我对**IA**的研究过程中，我试图发现正在使用的底层技术、库和机器学习算法。*Python*是唯一在生产环境中使用的编程语言（除了在**RPA**中使用的内置C#和VB.NET），尽管R和Julia是学校中用来教授机器学习的流行语言。在本章的最终示例中，我们将在BP中调用一个Python脚本。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Command-line basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行基础
- en: Predicting from the command line using the **Object Utility -** **Environment**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Object Utility -** **Environment**从命令行进行预测
- en: Getting prediction results back into BP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将预测结果返回到BP
- en: Timing out long-running predictions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间预测超时
- en: '**DX VBOs** – **Utility PowerShell** and **Script** **Execution VBO**'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DX VBOs** – **Utility PowerShell**和**Script** **Execution VBO**'
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we get started, please ensure that the following requirements are met:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保满足以下要求：
- en: 'Download and import the **Utility - Powershell** asset from DX: [https://digitalexchange.blueprism.com/dx/entry/9648/solution/utility---powershell](https://digitalexchange.blueprism.com/dx/entry/9648/solution/utility---powershell)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从DX下载并导入**Utility - Powershell**资产：[https://digitalexchange.blueprism.com/dx/entry/9648/solution/utility---powershell](https://digitalexchange.blueprism.com/dx/entry/9648/solution/utility---powershell)
- en: 'Download and import the **Script Execution VBO** asset from DX: [https://digitalexchange.blueprism.com/dx/entry/3439/solution/blue-prism---script-execution-vbo-2](https://digitalexchange.blueprism.com/dx/entry/3439/solution/blue-prism---script-execution-vbo-2)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从DX下载并导入**Script Execution VBO**资产：[https://digitalexchange.blueprism.com/dx/entry/3439/solution/blue-prism---script-execution-vbo-2](https://digitalexchange.blueprism.com/dx/entry/3439/solution/blue-prism---script-execution-vbo-2)
- en: 'Install Python version 3+: [https://www.python.org/downloads](https://www.python.org/downloads)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Python 3+：[https://www.python.org/downloads](https://www.python.org/downloads)
- en: 'Download and import the examples for this chapter from GitHub, which are contained
    in a single Release: [https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch2](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch2)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub下载并导入本章的示例，这些示例包含在一个单独的版本中：[https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch2](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch2)
- en: Command-line basics
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行基础
- en: When making a prediction on the Digital Worker machine, you’ll need to invoke
    the command line, unless you’re able to interact with it programmatically through
    a *Code Stage* (the topic of the next chapter) or through a graphical interface.
    BP is able to start standalone programs or scripts through both WCP and PS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Digital Worker机器上进行预测时，你需要调用命令行，除非你能够通过*Code Stage*（下一章的主题）或通过图形界面以编程方式与之交互。BP能够通过WCP和PS启动独立程序或脚本。
- en: WCP can be launched by running the *Command Prompt* application, or `cmd.exe`
    from the Windows **Start** menu. It can be started as the current user that’s
    logged in to Windows, or an administrator user, by right-clicking Command Prompt
    and choosing **Run** **as administrator**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行*命令提示符*应用程序或从Windows**开始**菜单中的`cmd.exe`来启动WCP。它可以以当前登录到Windows的用户身份启动，也可以以管理员用户身份启动，通过右键单击命令提示符并选择**以管理员身份运行**。
- en: PS can be started by running the PS application, or `powershell.exe`/`pwsh.exe`
    from the Windows `pwsh.exe` is the executable for PS Core, which is the newer,
    cross-platform version of PS (v6 and above) that must be installed manually as
    it doesn’t come installed on Windows by default. `powershell.exe` is the legacy
    version (v5.1 and under), which does come pre-installed with Windows.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行PS应用程序或从Windows的`pwsh.exe`来启动PS，或`powershell.exe`/`pwsh.exe`。`pwsh.exe`是PS
    Core的可执行文件，它是PS的新版本，是一个跨平台版本（v6及以上），必须手动安装，因为它默认情况下并未安装在Windows上。`powershell.exe`是旧版本（v5.1及以下），它是预安装在Windows上的。
- en: For IA purposes, there aren’t really any strong arguments for choosing WCP over
    PS, or the other way around. WCP is overall simpler with less functionality, whereas
    PS is more complex and more fully featured. However, these details are internal
    to the command-line scripts themselves, which will likely be provided to you by
    the developers of the ML solution. BP can mostly treat these scripts as black
    boxes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IA目的，没有强有力的论据来选择WCP而不是PS，或者反过来。WCP总体上更简单，功能更少，而PS更复杂，功能更全面。然而，这些细节是命令行脚本内部的，这些脚本可能会由ML解决方案的开发者提供。BP可以主要将这些脚本视为黑盒。
- en: When predicting locally, you’ll likely be required to deploy the ML model through
    a standalone executable, a batch script, a PS script, or by running the source
    code (most commonly Python) directly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当本地预测时，你可能会需要通过一个独立的可执行文件、批处理脚本、PS脚本或直接运行源代码（通常是Python）来部署ML模型。
- en: Next, let’s look at three concepts that are important to connecting command-line
    programs to BP. These are **output streams**, **output redirection**, and **blocking
    execution**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看三个对于将命令行程序连接到BP非常重要的概念。这些是**输出流**、**输出重定向**和**阻塞执行**。
- en: Output streams
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出流
- en: Programs that are executed from WCP and PS can output text to two different
    streams. The first stream is called `STDERR` is used depends on the authors of
    the script. Sometimes, developers will decide to print error messages to `STDOUT`
    instead of using `STDERR`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从WCP和PS中执行的程序可以将文本输出到两个不同的流。第一个流被称为`STDERR`，它被使用取决于脚本的作者。有时，开发者会决定将错误消息打印到`STDOUT`而不是使用`STDERR`。
- en: Important note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: PS has more output streams available, such as for warning and debug messages,
    but STDOUT and STDERR are by far the most commonly used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PS有更多的输出流可用，例如警告和调试消息，但STDOUT和STDERR是最常用的。
- en: 'For example, let’s open `cmd.exe` and type the following (without the `>` character):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们打开`cmd.exe`并输入以下内容（不包含`>`字符）：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will see `"Hello Blue Prism"` printed back onto the screen through STDOUT:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过STDOUT在屏幕上看到“Hello Blue Prism”被打印出来：
- en: '![Figure 2.1 – Output that is displayed in the command-line window is STDOUT](img/B18416_02_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 命令行窗口中显示的输出是STDOUT](img/B18416_02_1.jpg)'
- en: Figure 2.1 – Output that is displayed in the command-line window is STDOUT
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 命令行窗口中显示的输出是STDOUT
- en: 'Let’s try a different command that we know will generate an error. Let’s print
    out the contents of a non-existent file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个我们知道会生成错误的命令。让我们打印一个不存在文件的目录内容：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This gives a `The system cannot find the file specified.` error message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示“系统找不到指定的文件。”错误消息：
- en: '![Figure 2.2 – Is this message STDOUT or STDERR?](img/B18416_02_2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 这条消息是STDOUT还是STDERR？](img/B18416_02_2.jpg)'
- en: Figure 2.2 – Is this message STDOUT or STDERR?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 这条消息是STDOUT还是STDERR？
- en: The intention of the text displayed is to show an error, but was it written
    to the STDOUT stream or STDERR? We can’t tell based on the printed words shown
    in the window, but we can figure this out by **redirecting** STDOUT and STDERR
    into files.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文本的目的是为了展示一个错误，但它是否被写入到STDOUT流或STDERR流？仅凭窗口中显示的打印文字，我们无法判断，但我们可以通过将STDOUT和STDERR重定向到文件来找出这一点。
- en: Output redirection
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出重定向
- en: Both STDOUT and STDERR can be redirected to one another, and written out to
    files as well. *This is a primary way to capture command-line output into BP*.
    This is done in part by using the redirection, or the “greater-than” character
    (`>`) in WCP and PS. The most common way you’ll see this being used in BP is to
    redirect STDOUT into a file so that it can be read using the **File -** **Management**
    VBO.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'STDOUT和STDERR都可以相互重定向，并且可以将它们写入文件。*这是将命令行输出捕获到BP的主要方法之一*。这部分是通过使用重定向，即WCP和PS中的“大于”字符（`>`）来实现的。在BP中，你最常见的使用方式是将STDOUT重定向到文件，以便可以使用**文件管理**VBO来读取。 '
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `>` character redirects and overwrites any previous content, whereas `>>`
    redirection appends content. We’ll use `>` much more often than `>>` for the purpose
    of getting STDOUT and STDERR into BP since appending requires more development
    logic to differentiate previous content from current content.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`字符用于重定向并覆盖任何之前的内容，而`>>`重定向则用于追加内容。由于追加内容需要更多的开发逻辑来区分之前和当前的内容，因此我们更频繁地使用`>`来将STDOUT和STDERR重定向到BP。'
- en: 'Let’s redirect STDOUT from one of the previous commands into a file and print
    out the contents of that file in `cmd.exe`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前命令中的一个STDOUT重定向到文件，并在`cmd.exe`中打印该文件的目录内容：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first command no longer prints `"Hello Blue Prism"` into the console window.
    The output was redirected into a file. Text is only printed after the second command,
    which does not have any redirection:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令不再将`"Hello Blue Prism"`打印到控制台窗口。输出被重定向到了一个文件。只有在第二个命令执行后，文本才会被打印出来，而这个命令没有进行任何重定向：
- en: '![Figure 2.3 – Redirecting STDOUT to a file](img/B18416_02_3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 将STDOUT重定向到文件](img/B18416_02_3.jpg)'
- en: Figure 2.3 – Redirecting STDOUT to a file
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 将STDOUT重定向到文件
- en: 'Let’s try printing the contents of the non-existent file again, except this
    time, we’ll redirect STDOUT to a file. Then, we’ll print the output of the redirected
    file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试打印不存在文件的目录内容，但这次我们将STDOUT重定向到文件。然后，我们将打印重定向文件的输出：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You’ll see that the error text is printed to the screen, unlike our previous
    example. Why wasn’t this redirected? It’s because the `The system cannot find
    the file specified.` message is not from STDOUT, so redirecting STDOUT has no
    effect:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到错误文本被打印到屏幕上，这与我们之前的例子不同。为什么没有重定向？这是因为“系统找不到指定的文件。”消息不是来自STDOUT，所以重定向STDOUT没有效果：
- en: '![Figure 2.4 – Redirecting STDOUT did not capture the message](img/B18416_02_4.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 重定向STDOUT未捕获消息](img/B18416_02_4.jpg)'
- en: Figure 2.4 – Redirecting STDOUT did not capture the message
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 重定向STDOUT未捕获消息
- en: 'Since the message wasn’t STDOUT, we can reasonably guess that it was STDERR.
    STDERR can be redirected using `2>` instead of `>` (which is for STDOUT). Let’s
    try redirecting STDERR:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息不是STDOUT，我们可以合理地猜测它是STDERR。STDERR可以使用`2>`而不是`>`（这是用于STDOUT的）进行重定向。让我们尝试重定向STDERR：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now see that the first command prints nothing to the screen, whereas the
    second does. This confirms that the `The system cannot find the file specified.`
    message is written to STDERR and not STDOUT:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到第一个命令没有在屏幕上打印任何内容，而第二个命令则打印了内容。这证实了“系统找不到指定的文件。”消息被写入STDERR而不是STDOUT：
- en: '![Figure 2.5 – Redirecting STDERR captures the message](img/B18416_02_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 重定向STDERR捕获消息](img/B18416_02_5.jpg)'
- en: Figure 2.5 – Redirecting STDERR captures the message
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 重定向STDERR捕获消息
- en: So far, we’ve only seen examples of redirecting one of the STDOUT or STDERR
    streams, but not both. There are two ways of redirecting both streams. The first
    choice is to combine both STDOUT and STDERR into one stream and redirect that
    single stream into a *single file*. The second choice is to redirect both streams
    into *separate files*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了重定向STDOUT或STDERR流中的一个示例，但没有同时重定向两个流。有两种方法可以同时重定向两个流。第一种选择是将STDOUT和STDERR合并到一个流中，并将该单个流重定向到*单个文件*。第二种选择是将两个流重定向到*单独的文件*。
- en: 'Let’s look at how to do both of these, this time using PS instead of WCP. Luckily,
    all of the redirection commands that we’ve seen are interchangeable between WCP
    and PS. Using PS also has the small benefit of changing STDERR messages to a red-colored
    font so that they are immediately recognizable. Open `powershell.exe` and enter
    the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用PS而不是WCP来完成这两件事。幸运的是，我们之前看到的所有重定向命令在WCP和PS之间都是可互换的。使用PS还有一个小的优点，就是将STDERR消息的字体改为红色，以便立即识别。打开`powershell.exe`并输入以下命令：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is actually two commands separated by a semicolon. The first `echo` command
    writes to STDOUT, whereas the second `Write-Error` command writes to STDERR. The
    surrounding `&{…}` characters mean to execute it as a single scriptblock in PS.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是两个由分号分隔的命令。第一个`echo`命令写入STDOUT，而第二个`Write-Error`命令写入STDERR。周围的`&{…}`字符表示在PS中将其作为单个脚本块执行。
- en: 'Running this produces the following output. We see the STDOUT message, `Blue
    Prism`, and the STDERR message (in red) on the PS console screen:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会产生以下输出。我们在PS控制台屏幕上看到STDOUT消息“Blue Prism”和STDERR消息（红色）：
- en: '![Figure 2.6 – The red text is STDERR, whereas the normal-colored text is STDOUT](img/B18416_02_6.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 红色文本是STDERR，而正常颜色的文本是STDOUT](img/B18416_02_6.jpg)'
- en: Figure 2.6 – The red text is STDERR, whereas the normal-colored text is STDOUT
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 红色文本是STDERR，而正常颜色的文本是STDOUT
- en: 'Next, let’s combine STDERR into the STDOUT stream, redirect that into a *single
    file*, and print out the contents of that file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将STDERR合并到STDOUT流中，将其重定向到**单个文件**，并打印该文件的内容：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the first `>` instance, we specify the file path that STDOUT should be
    redirected to. `2>&1` means that we want to redirect STDERR into the STDOUT stream.
    When printing out the file, we see that both the STDOUT and STDERR messages are
    present:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`>`实例之后，我们指定STDOUT应该重定向到的文件路径。`2>&1`表示我们想要将STDERR重定向到STDOUT流。在打印文件时，我们可以看到STDOUT和STDERR消息都存在：
- en: '![Figure 2.7 – Redirecting both STDOUT and STDERR into a single file](img/B18416_02_7.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 将STDOUT和STDERR重定向到单个文件](img/B18416_02_7.jpg)'
- en: Figure 2.7 – Redirecting both STDOUT and STDERR into a single file
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 将STDOUT和STDERR重定向到单个文件
- en: Next, let’s redirect STDERR and STDOUT into *separate files*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将标准错误输出（STDERR）和标准输出（STDOUT）重定向到**单独的文件**。
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, `>` let us specify the path we want STDOUT redirected to. Following
    `2>` is where we want STDERR redirected to. When the files are printed out, only
    the content from their corresponding stream is shown:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`>`让我们指定我们想要STDOUT重定向到的路径。在`2>`之后是我们想要STDERR重定向到的位置。当文件被打印出来时，只会显示它们对应流的内容：
- en: '![Figure 2.8 – Redirecting STDOUT and STDERR to different files](img/B18416_02_8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 将STDOUT和STDERR重定向到不同的文件](img/B18416_02_8.jpg)'
- en: Figure 2.8 – Redirecting STDOUT and STDERR to different files
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 将STDOUT和STDERR重定向到不同的文件
- en: Given the choice between combining streams and redirecting them into a single
    file versus redirecting STDOUT and STDERR into separate files, it makes much more
    sense to do the *latter*. This allows us to isolate error messages from non-error
    messages. It’s also the reason why we prefer to overwrite previous output (`>`)
    versus append (`>>`). Appending requires us to add more logic, to split the output
    from the latest command run from previous ones.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择将流合并并重定向到单个文件与将STDOUT和STDERR重定向到单独文件之间，后者**更合理**。这允许我们将错误消息与非错误消息隔离开来。这也是我们为什么更喜欢覆盖之前的输出（`>`）而不是追加（`>>`）的原因。追加需要我们添加更多逻辑，以将最新运行的命令的输出与之前的输出分开。
- en: We’ve now covered the different ways of redirecting output from the command
    line into files. This makes it easy for us to receive the output of command-line-based
    ML programs into BP. Next, let’s look at the final topic of this *Command-line
    basics* section, blocking versus non-blocking execution.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了将命令行输出重定向到文件的不同方法。这使得我们能够轻松地将基于命令行的机器学习（ML）程序的输出接收进BP。接下来，让我们看看本节**命令行基础**的最后一个主题，即阻塞与非阻塞执行。
- en: Blocking versus non-blocking execution
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞与非阻塞执行
- en: 'When BP starts a command-line program, the execution in BP can either **block**
    or **not block**. If the execution blocks, BP will wait until the program exits
    before moving on to the next Stage:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当BP启动一个命令行程序时，BP中的执行可以是**阻塞**或**非阻塞**。如果执行被阻塞，BP将在程序退出之前等待，然后继续到下一个阶段：
- en: '![Figure 2.9 – BP waits for a blocking program to complete](img/B18416_02_9.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – BP等待阻塞程序完成](img/B18416_02_9.jpg)'
- en: Figure 2.9 – BP waits for a blocking program to complete
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – BP等待阻塞程序完成
- en: 'If the script doesn’t block, it will continue to run in the background while
    BP progresses. BP won’t know when the script actually completes, unless it can
    explicitly wait and check for an external condition, such as the presence of a
    file written to disk:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本不阻塞，它将在BP进展的同时在后台继续运行。除非脚本可以显式等待并检查外部条件，例如磁盘上写入的文件的存在，否则BP将不知道脚本何时实际完成：
- en: '![Figure 2.10 – BP continues to run while a non-blocking program executes](img/B18416_02_10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 在非阻塞程序执行时BP继续运行](img/B18416_02_10.jpg)'
- en: Figure 2.10 – BP continues to run while a non-blocking program executes
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – BP 在非阻塞程序执行时继续运行
- en: As a BP developer, it’s crucial to decide whether you want the triggered program
    to run in a blocking or non-blocking manner. In almost every case, we prefer BP
    to wait for a script to finish, even when a non-blocking script is running. This
    makes the development and debugging of the process simpler. The different ways
    of achieving this will be discussed later in this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 BP 开发者，决定你希望触发的程序以阻塞或非阻塞方式运行至关重要。在几乎所有情况下，我们更喜欢 BP 等待脚本完成，即使非阻塞脚本正在运行。这使得过程开发和调试变得更加简单。本章后面将讨论实现这一点的不同方法。
- en: The concept of *blocking versus non-blocking* is similar to the *synchronous
    versus asynchronous* discussion that we had for web APIs. Web API calls have a
    built-in concept of timing out. If an API request takes too long in BP, it will
    eventually be terminated, with an exception being thrown. Similarly, we also need
    to think about how to **time out** a program that is triggered from the command
    line, if it takes too long to run. We’ll see an example of how this can be done
    later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*阻塞与非阻塞* 的概念类似于我们在讨论 Web API 时提到的 *同步与异步*。Web API 调用有一个内置的超时概念。如果一个 API 请求在
    BP 中运行时间过长，它最终会被终止，并抛出一个异常。同样，我们还需要考虑如果从命令行触发的程序运行时间过长，我们应该如何**超时**。我们将在本章后面看到如何实现这个功能的示例。'
- en: In this section, we looked at the fundamentals of the command line as it relates
    to BP. First was the concept of output streams. STDOUT is used to show regular
    output to the console screen and STDERR is used to show error messages. Next,
    we discussed how these two streams can be redirected into files, in both WCP and
    PS, using the `>` redirection operator. Redirection allows us to capture the output
    of command-line programs in BP.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了与 BP 相关的命令行基础知识。首先是输出流的概念。STDOUT 用于向控制台屏幕显示常规输出，而 STDERR 用于显示错误消息。接下来，我们讨论了如何使用
    `>` 重定向运算符在 WCP 和 PS 中将这两个流重定向到文件中。重定向使我们能够在 BP 中捕获命令行程序输出。
- en: Then, we looked at the difference between blocking and non-blocking scripts,
    and stated that we’d prefer to pause BP execution until the script completes for
    predictability reasons. Finally, we introduced the concept of timeouts, in order
    to stop a command-line process from running for too long.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了阻塞与非阻塞脚本之间的区别，并指出我们更喜欢暂停 BP 执行直到脚本完成，这是出于可预测性的原因。最后，我们介绍了超时的概念，以停止命令行进程运行时间过长。
- en: 'In the next section, we’ll be answering the following questions, using examples:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过示例回答以下问题：
- en: Which VBO and Action should I use to trigger the prediction?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我应该使用哪个 VBO 和操作来触发预测？
- en: How can I get the predicted results back into BP?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我如何将预测结果返回到 BP？
- en: How can I stop a script that is running for too long?
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我如何停止运行时间过长的脚本？
- en: Predicting from the command line using Utility – Environment
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Utility – Environment 从命令行进行预测
- en: 'The **Utility - Environment** VBO, found in the VBO sub-folder where BP is
    installed, has three Actions that can be used to launch command-line scripts and
    external programs: **Start Process**, **Start Process Read Stderr and Stdout**,
    and **Run Process** **Until Ended**.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BP 安装子文件夹中的 VBO 子文件夹中找到的 **Utility - Environment** VBO 有三个可以用来启动命令行脚本和外部程序的操作：**启动进程**、**启动进程读取
    Stderr 和 Stdout** 和 **运行进程** **直到结束**。
- en: Regardless of which Action you use, you will have to fill in at minimum two
    different input parameters in BP. One input parameter specifies *what program
    you want to run*, and another input parameter specifies *additional arguments
    to* *that program*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪个操作，你都必须在 BP 中至少填写两个不同的输入参数。一个输入参数指定你想要运行的 *程序*，另一个输入参数指定 *该程序的附加参数*。
- en: Let’s see two different ways of running a simple batch script, using the **Start
    Process** and **Run Process Until** **Ended** Actions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 **Start Process** 和 **Run Process Until** **Ended** 操作运行简单批处理脚本的两种不同方法。
- en: Example 1 – Running a program using the Start Process
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1 – 使用 Start Process 运行程序
- en: 'Let’s run a batch file that takes in two numbers as parameters from BP. To
    make setting up the example simpler, the batch file contents are saved to disk
    at the beginning of the Process. This batch file itself is responsible for writing
    two input parameters into an output file, `C:\Users\Public\ch2_ex1_output.txt`,
    so that we don’t need to do any redirection. At the end of the Process, we delete
    the batch file that was created. Follow these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个从BP接收两个参数作为参数的批处理文件。为了简化示例设置，批处理文件内容在流程开始时保存在磁盘上。这个批处理文件本身负责将两个输入参数写入输出文件，`C:\Users\Public\ch2_ex1_output.txt`，这样我们就不需要进行任何重定向。流程结束时，我们删除创建的批处理文件。按照以下步骤操作：
- en: Open the `Ch2` Group, in Process Studio.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在流程工作室中打开`Ch2`组。
- en: 'Open the **Utility Environment::Start Process** Action, in the orange Block.
    See that we’re providing the path of the batch file as the **Application** Input
    Parameter, and two Data Items, separated by a space, as the **Arguments** Value:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在橙色块中打开**Utility Environment::Start Process**操作。注意我们提供批处理文件的路径作为**应用程序**输入参数，以及两个通过空格分隔的数据项作为**参数**值：
- en: '![Figure 2.11 – Passing in the script path as the Application and the two parameters
    separated by a space as the Arguments](img/B18416_02_11.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 将脚本路径作为应用程序，并将两个参数通过空格分隔作为参数](img/B18416_02_11.jpg)'
- en: Figure 2.11 – Passing in the script path as the Application and the two parameters
    separated by a space as the Arguments
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 将脚本路径作为应用程序，并将两个参数通过空格分隔作为参数
- en: Run the example once by pressing the **Go** button or *F5*.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下**Go**按钮或*F5*来运行示例一次。
- en: 'Verify that the batch script ran correctly by verifying the contents of the
    output text file, `C:\Users\Public\ch2_ex1_output.txt`. It should contain the
    text `1234` and `5`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过验证输出文本文件的内容，`C:\Users\Public\ch2_ex1_output.txt`来验证批处理脚本是否正确运行。它应包含文本`1234`和`5`：
- en: '![Figure 2.12 – The expected output file](img/B18416_02_12.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 预期的输出文件](img/B18416_02_12.jpg)'
- en: Figure 2.12 – The expected output file
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 预期的输出文件
- en: We’ve finished the most basic example of running a batch file and retrieving
    its output. Since the batch file itself wrote data into files, we didn’t have
    to do any redirection ourselves. Notice that there is a **Sleep 1 second** Action
    in our process diagram. This is needed because the **Utility -** **Environment**
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了运行批处理文件并检索其输出的最基本示例。由于批处理文件本身将数据写入文件，我们不需要自己进行任何重定向。注意，我们的流程图中有一个**睡眠1秒**操作。这是必需的，因为**Utility
    -** **Environment**
- en: '**::Start Process** Action is *non-blocking*. If the sleep Action isn’t there,
    it’s possible for the batch file to be deleted before it’s even finished executing!'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**::Start Process**操作是*非阻塞*的。如果没有睡眠操作，批处理文件可能在完成执行之前就被删除了！'
- en: Example 2 - Running a program using Run Process Until Ended
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2 - 使用运行进程直到结束运行程序
- en: 'Now, let’s modify the previous example, to get rid of the potentially unreliable
    1-second sleep, and make the script *block*. This time, our output file will be
    saved in `C:\Users\Public\ch2_ex2_output.txt`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改之前的示例，以去除可能不可靠的1秒睡眠，并使脚本*阻塞*。这次，我们的输出文件将保存在`C:\Users\Public\ch2_ex2_output.txt`：
- en: Open the **Example 2 – Running a program using Run Process Until Ended** BP
    Process in Process Studio.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在流程工作室中打开**示例2 – 使用运行进程直到结束运行程序** BP流程。
- en: 'Open the **Utility - Environment::Run Process Until Ended** Action, in the
    orange Block. Note that the **Arguments** and **Application** inputs are identical
    to *Example 1*. The difference is that the Action has changed from **Start Process**
    to **Run Process Until Ended**. Also, see that the **Timeout** input is blank.
    When blank, the default is 10 seconds:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在橙色块中打开**Utility - Environment::Run Process Until Ended**操作。注意**参数**和**应用程序**输入与*示例1*相同。不同之处在于操作已从**Start
    Process**更改为**Run Process Until Ended**。此外，请注意**超时**输入为空。当为空时，默认为10秒：
- en: '![Figure 2.13 – This Action is configured identically to Example 1](img/B18416_02_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 此操作配置与示例1](img/B18416_02_13.jpg)'
- en: Figure 2.13 – This Action is configured identically to Example 1
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 此操作配置与示例1相同
- en: Verify that the sleep Stage has been removed from the Process diagram.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证流程图中已移除睡眠阶段。
- en: Run the example once by pressing the **Go** button or F5.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下**Go**按钮或F5来运行示例一次。
- en: Verify that the script was correctly run by opening Windows File Explorer and
    seeing that the `C:\Users\Public\ch2_ex2_output.txt` file contains the text `abcd`
    and `e`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证脚本是否正确运行，请打开 Windows 文件资源管理器，查看 `C:\Users\Public\ch2_ex2_output.txt` 文件是否包含文本
    `abcd` 和 `e`。
- en: We’ve switched the Action from **Start Process** in *Example 1* to **Run Process
    Until Ended** in *Example 2*. In *Example 1* using **Start Process**, BP executes
    both the Process steps and the batch script in a non-blocking manner. With **Run
    Process Until Ended** in *Example 2*, BP waits for a maximum of 10 seconds for
    the script to complete, before continuing with the Process steps. Despite preferring
    blocking execution most of the time, there might be situations where non-blocking
    is desired.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将动作从 *示例 1* 中的 **启动进程** 更改为 *示例 2* 中的 **运行进程直到结束**。在 *示例 1* 中使用 **启动进程**，BP
    以非阻塞方式执行进程步骤和批处理脚本。在 *示例 2* 中使用 **运行进程直到结束**，BP 等待最多 10 秒脚本完成，然后继续执行进程步骤。尽管大多数时候更喜欢阻塞执行，但可能存在需要非阻塞执行的情况。
- en: 'There’s still a third Action in **Utility - Environment** that we haven’t seen
    an example of yet: **Start Process Read Stderr and Stdout**. As you can guess
    by the name, this Action allows us to directly capture the two output streams,
    STDOUT, and STDERR, as Data Items in BP. Next, we will discuss the different ways
    of capturing output from command-line scripts back into BP.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **实用工具 - 环境** 中还有一个我们尚未看到示例的动作：**启动进程读取 Stderr 和 Stdout**。正如其名称所暗示的，此动作允许我们直接捕获两个输出流，STDOUT
    和 STDERR，作为 BP 中的数据项。接下来，我们将讨论从命令行脚本捕获输出到 BP 的不同方法。
- en: Getting prediction results back into BP
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将预测结果返回到 BP
- en: 'ML programs started from the command line will likely provide output in one
    of two ways: either by *printing the prediction output to the screen* or *writing
    the results to a file*. There are, of course, other options, such as sending the
    result to a separate system for you to retrieve, but those are outside the scope
    of this chapter. *Table 2.1* lists the most common ways of getting ML prediction
    output, and which Objects/Actions you can use to read it back into BP:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行启动的 ML 程序可能会以两种方式提供输出：要么是将预测输出打印到屏幕上，要么是将结果写入文件。当然，还有其他选项，例如将结果发送到单独的系统供您检索，但这些选项超出了本章的范围。*表
    2.1* 列出了获取 ML 预测输出的最常见方式，以及您可以使用哪些对象/操作将其读取回 BP：
- en: '| **Prediction** **Output Method** | **Input Method** **into BP** | **Object**
    **to Use** | **Action** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **预测输出方法** | **输入方法到 BP** | **使用对象** | **操作** |'
- en: '| Written to screen | Use VBO Action that directly reads screen output | **Utility
    -** **Environment** | **Start Process Read Stderr** **and Stdout** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 写入屏幕 | 使用直接读取屏幕输出的 VBO 动作 | **实用工具 –** **环境** | **启动进程读取 Stderr** **和 Stdout**
    |'
- en: '| **Utility -** **PowerShell** | **Run Script** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **实用工具 –** **PowerShell** | **运行脚本** |'
- en: '| **Script** **Execution VBO** | **Execute Script** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **脚本执行 VBO** | **执行脚本** |'
- en: '| Written to screen | Redirect to a file and read the file | **Utility - Environment**
    | **Start Process** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 写入屏幕 | 重定向到文件并读取文件 | **实用工具 - 环境** | **启动进程** |'
- en: '| **Utility - Environment** | **Run Process** **Until Ended** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **实用工具 - 环境** | **运行进程直到结束** |'
- en: '| Written to file | Read the file | **Utility –** **Environment** | **Start
    Process** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 写入文件 | 读取文件 | **实用工具 –** **环境** | **启动进程** |'
- en: '| **Utility - Environment** | **Run Process** **Until Ended** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **实用工具 - 环境** | **运行进程直到结束** |'
- en: Table 2.1 – The different ways of reading prediction outputs back into BP
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 将预测输出读取回 BP 的不同方式
- en: If the prediction is printed to the console screen, there are two ways to get
    the result back into BP. The first, and simplest way is to **use a VBO Action
    that directly captures output** as Data Items in BP. The second way is to **redirect**
    the printed output into a file and then read the file into BP. Let’s look at an
    example of the first case.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预测结果打印到控制台屏幕，有两种方法可以将结果返回到 BP。第一种，也是最简单的方法是**使用 VBO 操作直接捕获输出**作为 BP 中的数据项。第二种方法是将打印的输出重定向到一个文件，然后读取该文件到
    BP 中。让我们看看第一种情况的一个例子。
- en: Example 3 – Saving STDOUT and STDERR as Data Items
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 3 – 将 STDOUT 和 STDERR 保存为数据项
- en: In this example, we’ll build a Process from scratch that uses the **Start Process
    Read Stderr and Stdout** Action from the **Utility - Environment** VBO. This Action
    allows us to directly save STDERR and STDOUT as Data Items. A completed version
    of this example is available in this chapter’s Release for your reference.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将从头开始构建一个进程，该进程使用来自**实用工具 - 环境** VBO的**启动进程读取标准错误和标准输出**动作。此动作允许我们直接将标准错误和标准输出保存为数据项。本章节的发布中提供了此示例的完整版本供您参考。
- en: 'This example also shows off the special syntax needed to run *internal commands*
    of Command Prompt from BP, in case you ever need to do so in the future. Follow
    these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还展示了从BP运行命令提示符的**内部命令**所需的特殊语法，以防您将来需要这样做。请按照以下步骤操作：
- en: Create a new Process named **Example 3** in the *Ch2* Group. Open it in Process
    Studio.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Ch2**组中创建一个名为**示例3**的新进程。在Process Studio中打开它。
- en: Add an *Action* Stage to the diagram. Choose **Utility - Environment** as the
    *Business Object* and **Start Process Read Stderr and Stdout** as the *Action*.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中添加一个**动作**阶段。选择**实用工具 - 环境**作为**业务对象**，并将**启动进程读取标准错误和标准输出**作为**动作**。
- en: Set the `"cmd.exe"` (including the double quotation marks) and the `"/c dir"`.
    The `dir` command lists out all of the files and directories inside of the BP
    installation folder. The BP installation folder is where the `cmd.exe` Command
    Prompt will be started from when we’re inside Process Studio. `/c` means terminate
    `cmd.exe` after the `dir` command is finished executing.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`"cmd.exe"`（包括双引号）和`"/c dir"`。`dir`命令列出了BP安装文件夹内的所有文件和目录。BP安装文件夹是我们从Process
    Studio内部启动`cmd.exe`命令提示符的位置。`/c`表示在`dir`命令执行完毕后终止`cmd.exe`。
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In order to run *internal commands* from WCP using the `dir`, `echo`, `copy`,
    and so on, we need to put `cmd.exe` as the *Process name* and the command we want
    to run inside of WCP as the *Arguments*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从WCP使用`dir`、`echo`、`copy`等内部命令，我们需要将`cmd.exe`作为**进程名称**，而我们要在WCP中运行的命令作为**参数**。
- en: Click on the Action’s `Standard Output` and `Standard Error` Data Items.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击动作的`标准输出`和`标准错误`数据项。
- en: 'Link the Action between the Start and End Stages. The completed Process should
    look like the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始和结束阶段之间链接动作。完成的进程应如下所示：
- en: '![Figure 2.14 – The completed test Process for Example 3](img/B18416_02_14.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 示例3的完成测试进程](img/B18416_02_14.jpg)'
- en: Figure 2.14 – The completed test Process for Example 3
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 示例3的完成测试进程
- en: 'Run the Process from Process Studio. The `Standard Output` Data Item will have
    content, whereas the `Standard Error` Data Item will stay empty. This is because
    the `dir` command succeeds with no errors:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Process Studio运行进程。`标准输出`数据项将包含内容，而`标准错误`数据项将保持为空。这是因为`dir`命令成功执行且无错误：
- en: '![Figure 2.15 – Standard Output is populated](img/B18416_02_15.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – 标准输出已填充](img/B18416_02_15.jpg)'
- en: Figure 2.15 – Standard Output is populated
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 标准输出已填充
- en: Modify the Action’s `"/c dir *.xyz"`. This change means that we want to list
    all of the files with the `.xyz` file extension, which shouldn’t exist in the
    BP installation folder.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改动作的`"/c dir *.xyz"`。此更改意味着我们想要列出所有具有`.xyz`文件扩展名的文件，这些文件不应存在于BP安装文件夹中。
- en: 'Run the test Process again. Both `Standard Output` and `Standard Error` Data
    Items should be populated, as there is an error:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试进程。`标准输出`和`标准错误`数据项都应填充，因为有错误：
- en: '![Figure 2.16 – Both Standard Output and Standard Error are populated](img/B18416_02_16.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16 – 标准输出和标准错误都已填充](img/B18416_02_16.jpg)'
- en: Figure 2.16 – Both Standard Output and Standard Error are populated
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – 标准输出和标准错误都已填充
- en: Notice that the actual console window did not pop up when running *Example 3*,
    yet we were able to capture the data that was printed to the console’s screen.
    Assuming that the ML prediction prints its output to the screen, a second way
    of capturing this data is to redirect the STDOUT and STDERR streams into files
    that can be read by BP. Let’s see how this can be done in the next example.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在运行**示例3**时，实际的控制台窗口没有弹出，但我们能够捕获打印到控制台屏幕上的数据。假设ML预测将输出打印到屏幕上，捕获这些数据的第二种方法是重定向STDOUT和STDERR流到BP可以读取的文件。让我们看看在下一个示例中如何做到这一点。
- en: Example 4 – Redirecting an internal command (dir) to files
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例4 – 将内部命令（dir）重定向到文件
- en: We’ve already used the **Run Process Until Ended** Action from the **Utility
    - Environment** VBO, in *Example 2*. This Action doesn’t let us capture the STDOUT
    and STDERR directly as Data Items; however, the batch script itself in *Example
    2* created a file that can be read back into BP.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*示例2*中使用了**实用工具 - 环境** VBO中的**运行进程直到结束**操作。这个操作不允许我们直接将STDOUT和STDERR捕获为数据项；然而，*示例2*中的批处理脚本本身创建了一个可以读入BP的文件。
- en: 'In this example, we’ll create a new Process using this Object and Action again,
    except the batch script will print output to STDOUT and STDERR. We’ll need to
    redirect the STDOUT and STDERR streams to files so that they can be read into
    BP. A completed version of this example is available in this chapter’s Release
    for your reference. Follow these steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将再次使用此对象和操作创建一个新的进程，除了批处理脚本将输出打印到STDOUT和STDERR。我们需要将STDOUT和STDERR流重定向到文件，以便它们可以被读入BP。本章节的发布中提供了此示例的完整版本，供您参考。请按照以下步骤操作：
- en: Create a new Process named **Example 4**, in the *Ch2* Group. Open it in Process
    Studio.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*Ch2*组中创建一个名为**示例4**的新进程。在流程工作室中打开它。
- en: 'Create two Data Items with a `Text` Data Type. These are the file paths where
    our redirected outputs will be saved. Set them up as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个具有`Text`数据类型的数据项。这些是我们重定向输出将保存的文件路径。按照以下设置：
- en: '| **Data** **Item Name** | **Initial Value** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **数据项名称** | **初始值** |'
- en: '| `Stdout File` | `C:\Users\Public\ch2_ex4_stdout.txt` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `Stdout File` | `C:\Users\Public\ch2_ex4_stdout.txt` |'
- en: '| `Stderr File` | `C:\Users\Public\ch4_ex4_stderr.txt` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `Stderr File` | `C:\Users\Public\ch4_ex4_stderr.txt` |'
- en: Table 2.2 – Configuring two Data Items to hold our file paths
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 – 配置两个数据项以保存我们的文件路径
- en: Add an *Action* Stage to the diagram. Choose Utility - Environment as the *Business
    Object* and `"cmd.exe"` (including the double quotation marks) and the `"/c dir
    *.xyz > " & Chr(34) & [Stdout File] & Chr(34) & " 2>" & Chr(34) & [Stderr File]
    &` `Chr(34)`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**操作**阶段添加到图中。选择**实用工具 - 环境**作为**业务对象**，并选择`"cmd.exe"`（包括双引号）和`"/c dir *.xyz
    > " & Chr(34) & [Stdout File] & Chr(34) & " 2>" & Chr(34) & [Stderr File] & Chr(34)`。
- en: The `"/c dir *.xyz`, tries to list out a file that does not exist. The next
    part, `> " & Chr(34) & [Stdout File] & Chr(34)`, redirects STDOUT to the file
    that we’ve defined. The `>` character, as you know, means redirect. The `Chr(34)`
    instances are used to put double quotations around the file path, in case there
    are spaces. The last part, `" 2>" & Chr(34) & [Stderr File] & Chr(34)`, redirects
    STDERR to a different file.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"/c dir *.xyz"`尝试列出不存在的文件。下一部分`> " & Chr(34) & [Stdout File] & Chr(34)`将STDOUT重定向到我们定义的文件。正如你所知，`>`字符表示重定向。`Chr(34)`实例用于在文件路径周围放置双引号，以防有空格。最后一部分`"
    2>" & Chr(34) & [Stderr File] & Chr(34)`将STDERR重定向到不同的文件。'
- en: 'Link the Action between the Start and End Stages. The completed Process should
    look like the following:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将操作阶段之间的动作链接起来。完成的流程应如下所示：
- en: '![Figure 2.17 – The completed test Process for Example 4](img/B18416_02_17.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17 – 示例4的完成测试流程](img/B18416_02_17.jpg)'
- en: Figure 2.17 – The completed test Process for Example 4
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – 示例4的完成测试流程
- en: Run the Process in Process Studio.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在流程工作室中运行进程。
- en: Check the `C:\Users\Public` folder, and verify that the two output files have
    been created, from redirection.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`C:\Users\Public`文件夹，并验证是否已从重定向创建了两个输出文件。
- en: In this example, we redirected the STDOUT and STDERR streams of a command internal
    to WCP, `dir`, to two separate files. Since the command is internal, we had to
    put `"cmd.exe"` as the **Application** Input. To perform the redirection, we simply
    added the necessary redirection syntax at the end of the **Arguments** Input.
    To actually get the output into BP, we would read the files that were created.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将WCP内部命令`dir`的STDOUT和STDERR流重定向到两个单独的文件。由于该命令是内部的，我们必须将`"cmd.exe"`作为**应用程序**输入。为了执行重定向，我们只需在**参数**输入的末尾添加必要的重定向语法。要将实际输出放入BP中，我们需要读取创建的文件。
- en: 'So far, we’ve covered all three of the Actions in **Utility - Environment**
    that allow us to start external programs from the command line. We’ve seen how
    they differ in terms of blocking and capturing output. This is summarized in the
    following table:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了**实用工具 - 环境**中允许我们从命令行启动外部程序的三个操作。我们看到了它们在阻塞和捕获输出方面的不同。以下表格对此进行了总结：
- en: '| **Action** | **Does** **it Block?** | **Output** **Saving Method** | **Is
    There** **Timeout Functionality?** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **是否阻塞？** | **输出保存方法** | **是否有超时功能？** |'
- en: '| **Start Process** | No | None. Must use redirection and read the files in
    BP. | No |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **启动进程** | 否 | 无。必须使用重定向并在BP中读取文件。 | 否 |'
- en: '| **Run Process Until** **Ended** | Yes | None. Must use redirection and read
    the files in BP. | Yes |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **运行进程直到** **结束** | 是 | 无。必须使用重定向并在BP中读取文件。 | 是 |'
- en: '| **Start Process Read Stderr** **and Stdout** | Yes | Outputs are saved as
    Data Items. | No |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **启动进程读取Stderr** **和Stdout** | 是 | 输出以数据项的形式保存。 | 否 |'
- en: Table 2.3 – A summary of the three Actions used to start command-line programs
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3 – 使用三个动作启动命令行程序的总结
- en: The last column of the table, *Is There Timeout Functionality?*, is the topic
    of the next section. This refers to whether there’s a built-in method to stop
    the external program from running if it’s taking too long.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的最后一列，*是否存在超时功能？*是下一节的主题。这指的是是否存在内置方法来停止外部程序运行时间过长。
- en: Timing out long-running predictions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时长时间运行的预测
- en: 'If the command-line script encounters a problem, it might hang and stall the
    BP Process forever if it’s blocking. Only one of the Actions has built-in functionality
    to time out a script that is running for too long: **Run Process** **Until Ended**.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令行脚本遇到问题，它可能会挂起并永久阻止BP流程。只有一个动作具有内置功能来超时运行时间过长的脚本：**运行进程** **直到结束**。
- en: Important note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It’s possible to add timeout functionality to any command-line script or program
    by wrapping it in other scripts and using the `start`, `timeout`, and `taskkill`
    commands. However, these methods are more complex compared to just using **Run
    Process Until Ended** plus redirection.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将其他脚本包装在脚本中并使用`start`、`timeout`和`taskkill`命令来向任何命令行脚本或程序添加超时功能。然而，与仅使用**运行进程直到结束**加上重定向相比，这些方法更为复杂。
- en: Example 5 – PS script timeout
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例5 – PS脚本超时
- en: 'Let’s look at a more realistic ML example. Here, we have a PS script that calls
    an algorithm to predict whether a customer will cancel a retail store’s membership
    plan. Inputs are passed in from BP to the PS script, and then to the mock ML program.
    The mock ML program returns confidence scores for two labels: `churn` and `no
    churn`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更现实的机器学习例子。在这里，我们有一个PS脚本，它调用一个算法来预测客户是否会取消零售店的会员计划。输入从BP传递到PS脚本，然后到模拟的ML程序。模拟的ML程序为两个标签返回置信度分数：`流失`和`不流失`。
- en: In this example, we have a collection of eight customers, along with some of
    their defining characteristics, such as age, job category, days since the last
    transaction, and average purchase size in dollars. Our Process will loop through
    all of the customers, call the PS script, and read the predicted confidence score
    of the *churn* label.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个包含八个客户的集合，以及一些定义性的特征，例如年龄、职业类别、自上次交易以来的天数以及平均购买金额（美元）。我们的流程将遍历所有客户，调用PS脚本，并读取预测的*流失*标签的置信度分数。
- en: The goal of this example is to examine and run this PS script and see how we
    can time it out if it takes too long.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的目标是检查并运行此PS脚本，并查看如果它运行时间过长我们如何超时。
- en: Open **Example 5 – PowerShell Script Timeout** BP Process in the *Ch2* Group.
    We will look at the important details together.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*Ch2*组中打开**示例5 – PowerShell脚本超时** BP流程。我们将一起查看重要细节。
- en: Open the `powershell.exe`. Trying to put the PS script path into the **Application**
    Input won’t actually execute the script, but instead open the file using the default
    application, which is usually Notepad. The **Arguments** Input should look familiar
    to you as it contains the PS script parameters and the redirection file path.
    Also, note that the **Timeout** Input is empty, meaning that the script can run
    for at most 10 seconds.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`powershell.exe`。尝试将PS脚本路径放入**应用程序**输入实际上不会执行脚本，而是使用默认应用程序打开文件，这通常是记事本。**参数**输入应该对你来说很熟悉，因为它包含PS脚本参数和重定向文件路径。此外，请注意**超时**输入为空，这意味着脚本最多可以运行10秒。
- en: Run the example once by pressing **Play to Go**. You’ll see that the PS window
    will pop up while the script is running and close afterward.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按**播放以运行**来运行示例一次。你会看到当脚本运行时PS窗口会弹出，之后会关闭。
- en: 'Open the `Predictions` Collection and see that it contains the confidence scores
    of the eight customers:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`预测`集合，查看它包含八个客户的置信度分数：
- en: '![Figure 2.18 – The confidence scores of the successful predictions](img/B18416_02_18.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18 – 成功预测的置信度分数](img/B18416_02_18.jpg)'
- en: Figure 2.18 – The confidence scores of the successful predictions
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 – 成功预测的置信度分数
- en: 'Open the `MakeTimeSpan(0, 0, 0, 3)` into the **Timeout** Input. The maximum
    time we allow the script to run is now 3 seconds:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MakeTimeSpan(0, 0, 0, 3)`打开到**Timeout**输入。现在我们允许脚本运行的最大时间是3秒：
- en: '![Figure 2.19 – Adding MakeTimeSpan(0, 0, 0, 3) to the Timeout input](img/B18416_02_19.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19 – 将MakeTimeSpan(0, 0, 0, 3)添加到Timeout输入](img/B18416_02_19.jpg)'
- en: Figure 2.19 – Adding MakeTimeSpan(0, 0, 0, 3) to the Timeout input
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 – 将MakeTimeSpan(0, 0, 0, 3)添加到Timeout输入
- en: 'Reset, and then run the example again. While the PS window is open, you should
    see an exception shown on screen, confirming that the timeout is working:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置，然后再次运行示例。当PS窗口打开时，您应该在屏幕上看到异常显示，确认超时正在工作：
- en: '![Figure 2.20 – The PS script has timed out](img/B18416_02_20.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20 – PS脚本已超时](img/B18416_02_20.jpg)'
- en: Figure 2.20 – The PS script has timed out
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 – PS脚本已超时
- en: '**Run Process Until Ended** is the only Action that blocks and has timeout
    functionality. While it doesn’t have the ability to automatically read STDOUT
    and STDERR into Data Items, we can get around that using redirection. Because
    of this, **Run Process Until Ended** is the **preferred Action to use for IA**,
    assuming that you don’t want to custom-build a new Action or use third-party VBOs.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行进程直到结束**是唯一一个具有阻塞和超时功能的操作。虽然它没有自动将STDOUT和STDERR读取到数据项中的能力，但我们可以通过重定向来解决这个问题。因此，**运行进程直到结束**是用于IA的**首选操作**，假设您不想自定义构建新的操作或使用第三方VBO。'
- en: The other two Actions for triggering command-line processes are more situational.
    The **Start Process Read Stderr and Stdout** Action can be used if the command-line
    program that you’re starting has built-in methods to time out itself or whichever
    underlying processes it creates.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 用于触发命令行进程的其他两个操作更为特定。如果启动的命令行程序具有内置的超时方法或它创建的任何底层进程，可以使用**启动进程读取Stderr和Stdout**操作。
- en: You may also encounter cases where there isn’t a good estimate for an appropriate
    timeout value. For example, if you’re predicting in batches, where some batches
    can take seconds while others can take hours, it makes sense to use the non-blocking
    **Start Process** Action and to check that the predictions are complete through
    some other method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会遇到没有良好估计的适当超时值的情况。例如，如果您在批量预测，其中一些批次可能需要几秒钟，而其他批次可能需要几小时，那么使用非阻塞的**启动进程**操作并检查预测是否完成通过其他方法是有意义的。
- en: Important note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Deployed ML models are not *build once, run forever*. As with all software,
    they should be updated and redeployed; for instance, to update the model with
    more training data, to tune model parameters differently, to apply security fixes
    to libraries used, and so on. Since the ML model can change independently of the
    BP solution, the timeout value should be changed outside of the Process or Object
    diagram as well. I’d recommend storing the timeout as *Environment Variables*
    in a real solution.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的机器学习模型并非**一次性构建，永久运行**。与所有软件一样，它们应该被更新和重新部署；例如，用更多的训练数据更新模型，以不同的方式调整模型参数，应用对所使用的库的安全修复，等等。由于机器学习模型可以独立于BP解决方案而改变，因此超时值也应该在进程或对象图中进行更改。我建议在真实解决方案中将超时值存储为*环境变量*。
- en: Now that we’ve covered the three Actions of the in-built **Utility - Environment**
    VBO, let’s look at two other VBOs that can be used to start command-line programs.
    Both are available for download on DX.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了内置的**实用工具 - 环境** VBO的三个操作，让我们看看其他两个可以用来启动命令行程序的VBO。它们都可以在DX上下载。
- en: DX VBOs – Utility - PowerShell and Script Execution VBO
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DX VBOs – 实用工具 - PowerShell和脚本执行VBO
- en: There are two notable assets available on DX that can be used to call command-line
    programs. They offer simplified interfaces to trigger programs, and other nice-to-have
    features that may make you want to choose them over **Utility -** **Environment**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在DX上有两个显著的资产可用于调用命令行程序。它们提供了简化接口以触发程序，以及其他一些您可能希望选择它们的附加功能，例如，与**实用工具 - 环境**相比。
- en: Utility – PowerShell
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用工具 – PowerShell
- en: This first VBO is specifically for PS, and it contains two Actions, **Run Script**
    and **Run Script with PowerShell Core**. PS Core is the latest version of PS;
    however, it’s not 100% backward compatible with older versions of PS. Older PS
    scripts might not run correctly under PS Core. PS Core is also not installed by
    default on most Windows versions. To avoid compatibility issues, we will be using
    the **Run Script** Action in the next example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个 VBO 专门用于 PS，并包含两个动作，**运行脚本** 和 **使用 PowerShell Core 运行脚本**。PS Core 是 PS
    的最新版本；然而，它并不完全与旧版本的 PS 兼容。旧版本的 PS 脚本可能在 PS Core 下无法正确运行。PS Core 也不是大多数 Windows
    版本默认安装的。为了避免兼容性问题，我们将在下一个示例中使用 **运行脚本** 动作。
- en: Example 6 – Utility – PowerShell Run Script
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 6 – 通用 – PowerShell 运行脚本
- en: 'Let’s revisit *Example 5*, where we triggered a PS script that gave us a prediction
    for user churn. This time, we’ll use the DX VBO instead:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 *示例 5*，在那里我们触发了一个 PS 脚本，它为我们提供了用户流失的预测。这次，我们将使用 DX VBO：
- en: Open the **Example 6 – Utility PowerShell Run Script** BP Process in the *Ch2*
    Group. This example has already been built for you, but we’ll look at the important
    details together.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *Ch2* 组中打开 **示例 6 – 通用 PowerShell 运行脚本** BP 流程。此示例已经为您构建好了，但我们将一起查看重要细节。
- en: Open the `parameter_name=parameter_value`. Multiple parameters should be separated
    by commas. Also, notice that this Action directly saves the output streams as
    Data Items, so redirection isn’t needed.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `parameter_name=parameter_value`。多个参数应以逗号分隔。请注意，此动作直接将输出流保存为数据项，因此不需要重定向。
- en: Run the example once in Process Studio. Unlike running the PS script in *Example
    5*, you won’t notice any PS windows pop up!
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Process Studio 中运行此示例一次。与在 *示例 5* 中运行 PS 脚本不同，你不会注意到任何 PS 窗口弹出！
- en: Verify that the `Predictions` Collection contains the confidence scores of the
    eight customers for *churn* and *no churn*. These should be the same as in *Figure
    2**.18*.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `Predictions` 集合是否包含八个客户的 *churn* 和 *no churn* 的置信度分数。这些分数应与 *图 2**.18* 中的相同。
- en: With the **Run Script** Action of this DX VBO, you gain the benefit of not needing
    output redirection and not seeing a pop-up window over using the Actions in **Utility
    - Environment**, which might be important for your use case. However, there’s
    also no built-in timeout functionality (although there is in **Run Script with
    PowerShell Core**). If you have the ability to install PS Core, I would recommend
    doing so that you can use the Action with timeout functionality.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 DX VBO 的 **运行脚本** 动作，你将获得不需要输出重定向且不会在 **Utility - 环境** 中的动作上看到弹出窗口的好处，这可能对您的用例很重要。然而，也没有内置的超时功能（尽管在
    **使用 PowerShell Core 运行脚本** 中有）。如果您有能力安装 PS Core，我建议您这样做，这样您就可以使用具有超时功能的动作。
- en: Script Execution VBO
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本执行 VBO
- en: The second asset available on DX is the **Script Execution VBO**. Two Objects
    are included in this Release. The first, **Script Execution VBO**, is implemented
    in C#, and the second, **Script Execution VBO Visual Basic**, is implemented in
    VB. There’s no functional difference between the two, so we’ll use the C# version
    in our next example. Each VBO contains only one Action, **Execute Script**.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: DX 上可用的第二个资源是 **脚本执行 VBO**。本版本包含两个对象。第一个，**脚本执行 VBO**，是用 C# 实现的，第二个，**脚本执行 VBO
    Visual Basic**，是用 VB 实现的。这两个对象在功能上没有区别，所以我们将使用 C# 版本在我们的下一个示例中。每个 VBO 只包含一个动作，**执行脚本**。
- en: One superficial reason why you might want to use this VBO is that your BP Action
    Inputs will look cleaner. As you’ll have noticed, adding redirection and full
    file paths, surrounding them with double quotation characters, `Chr(34)`, and
    so on, can make for messy, and hard-to-understand input arguments to the Action.
    This VBO minimizes this somewhat as it provides separate input parameters for
    the script engine, the script path, and the script name. A more practical reason
    for using this is that it starts external programs using desirable defaults, such
    as blocking, not popping up a command window, and capturing output into Data Items.
    However, it lacks timeout functionality.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要使用此 VBO 的一个表面原因是你的 BP 动作输入将看起来更整洁。正如你所注意到的，添加重定向和完整文件路径，用双引号 `Chr(34)`
    包围等，可以使动作的输入参数变得混乱且难以理解。此 VBO 通过为脚本引擎、脚本路径和脚本名称提供单独的输入参数来在一定程度上减少这种混乱。更实际的原因是，它使用期望的默认值启动外部程序，例如阻塞、不弹出命令窗口并将输出捕获到数据项中。然而，它缺少超时功能。
- en: Example 7 – Calling a Python program
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 7 – 调用一个 Python 程序
- en: 'Let’s call a Python script that predicts the selling price of a house based
    on square footage, number of bedrooms, number of bathrooms, previous selling price,
    and age in years. Since this is a *regression* problem, the Python script returns
    a numerical prediction, as opposed to labels and confidence scores. Follow these
    steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称一个基于面积、卧室数量、浴室数量、先前售价和年龄（年）预测房屋售价的Python脚本。由于这是一个*回归*问题，Python脚本返回一个数值预测，而不是标签和置信度分数。按照以下步骤操作：
- en: Open the **Example 7 – Script Execution VBO Calling a Python Script** BP Process
    in the *Ch2* Group. This example has already been built for you, but we’ll look
    at the important details together.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*Ch2*组中打开**示例7 – 脚本执行VBO调用Python脚本** BP过程。这个示例已经为您构建好了，但我们将一起查看重要细节。
- en: 'Open the command line, `cmd.exe`, and find the location of your Python executable.
    This might be named `py.exe` or `python.exe`. In WCP, type the following (or substitute
    `py.exe` with `python.exe` if you don’t find a result):'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行，`cmd.exe`，并找到您的Python可执行文件位置。这可能被命名为`py.exe`或`python.exe`。在WCP中，输入以下内容（或者如果您找不到结果，将`py.exe`替换为`python.exe`）：
- en: '[PRE8]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure 2.21 – Making the Python Executable Full Path Data Item match your
    Python location](img/B18416_02_21.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21 – 使Python可执行完整路径数据项与您的Python位置匹配](img/B18416_02_21.jpg)'
- en: Figure 2.21 – Making the Python Executable Full Path Data Item match your Python
    location
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – 使Python可执行完整路径数据项与您的Python位置匹配
- en: 'Open the **Script Execution VBO::Execute Script** Action, in the orange Block.
    Notice that it looks relatively cleaner, due to the separation of inputs, and
    that redirection isn’t needed:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在橙色块中打开**Script Execution VBO::Execute Script** Action，注意它看起来相对更干净，因为输入被分离，并且不需要重定向：
- en: '![Figure 2.22 – The input parameters are nicely separated](img/B18416_02_22.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图2.22 – 输入参数被很好地分隔](img/B18416_02_22.jpg)'
- en: Figure 2.22 – The input parameters are nicely separated
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 – 输入参数被很好地分隔
- en: Run the Process once in Process Studio. Notice that the Action *blocks* and
    doesn’t pop up any windows.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Process Studio中运行一次Process。注意，Action *blocks* 并且不会弹出任何窗口。
- en: 'Verify that the values predicted from Python are saved as Data Items:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证从Python预测的值是否已保存为数据项：
- en: '![Figure 2.23 – The predicted property price](img/B18416_02_23.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图2.23 – 预测的房产价格](img/B18416_02_23.jpg)'
- en: Figure 2.23 – The predicted property price
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 – 预测的房产价格
- en: 'We’ve now covered seven examples of how to start command-line programs in this
    chapter. Each example was designed to show something different in terms of:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在本章中介绍了如何启动命令行程序的七个示例。每个示例都旨在展示以下方面的不同：
- en: The type of script that is run
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行的脚本类型
- en: Which VBO and Action are used
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个VBO和Action被使用
- en: How output is read back into BP
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将输出读回到BP中
- en: Whether the Action blocks or does not block
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Action是否阻止或不阻止
- en: Whether the Action allows for timeout
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Action是否允许超时
- en: 'A table that summarizes all of the examples is shown next:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个表格总结了所有示例：
- en: '| **Example** | **Script Type** | **Call** **Script VBO/Action** | **Read**
    **Output Method** | **Blocking?** | **Timeout?** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **示例** | **脚本类型** | **调用** **脚本VBO/Action** | **读取** **输出方法** | **阻塞？** |
    **超时？** |'
- en: '| 1 | `.``bat` | **Utility -** **Environment**/ **Start Process** | The script
    writes output to a file | N | N |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `.``bat` | **实用工具 - 环境**/ **启动过程** | 脚本将输出写入文件 | N | N |'
- en: '| 2 | `.``bat` | **Utility -** **Environment**/ **Run Process Until** **Ended**
    | The script writes output to a file | Y | N (although leaving the parameter blank
    means 10 seconds) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `.``bat` | **实用工具 - 环境**/ **运行过程直到结束** | 脚本将输出写入文件 | Y | N (尽管留空参数意味着10秒)
    |'
- en: '| 3 | Internal command (`dir`) | **Utility - Environment**/**Start Process
    Read Stderr** **and Stdout** | VBO Action saves output as Data Items | Y | N |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 内部命令（`dir`） | **实用工具 - 环境**/**启动过程读取标准错误** **和标准输出** | VBO Action将输出保存为数据项
    | Y | N |'
- en: '| 4 | Internal command (`dir`) | **Utility - Environment**/**Run Process**
    **Until Ended** | Redirection into files | Y | N (although leaving the parameter
    blank means 10 seconds) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 内部命令（`dir`） | **实用工具 - 环境**/**运行过程直到结束** | 文件重定向 | Y | N (尽管留空参数意味着10秒)
    |'
- en: '| 5 | `.``ps1` | **Utility - Environment**/**Run Process** **Until Ended**
    | Redirection into files | Y | Y |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `.``ps1` | **实用工具 - 环境**/**运行过程** **直到结束** | 文件重定向 | Y | Y |'
- en: '| 6 | `.``ps1` | **Utility - PowerShell**/ **Run Script** | VBO Action saves
    output as Data Items | Y | N (although the PS Core Action has timeout) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `.``ps1` | **实用工具 - PowerShell**/ **运行脚本** | VBO Action将输出保存为数据项 | Y
    | N (尽管PS Core Action有超时) |'
- en: '| 7 | `.``py` | **Script Execution** **VBO**/**Execute Script** | VBO Action
    saves output as Data Items | Y | N |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `.``py` | **脚本执行** **VBO**/**执行脚本** | VBO 动作将输出保存为数据项 | 是 | 否 |'
- en: Table 2.4 – A summary of how all of the examples differ
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.4 – 所有示例差异的总结
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You may be required to connect BP to ML through an executable, a batch script,
    a PS script, or to directly execute source code. This chapter covered three important
    concepts that underlie running programs through the command line in BP. The first
    is the concept of *output streams*. STDOUT is used for displaying regular output
    to the command-line window, and STDERR is used for displaying errors. The second
    concept is *redirection*, which allows us to capture STDOUT and STDERR into files
    so that they can be read back into BP. The third concept is *blocking versus non-blocking*
    execution. BP will wait for blocking programs to complete before proceeding with
    further automation steps. Process logic is simpler to understand if we can trigger
    external programs to run in a blocking manner.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要通过可执行文件、批处理脚本、PS 脚本或直接执行源代码将 BP 连接到 ML。本章介绍了在 BP 中通过命令行运行程序背后的三个重要概念。第一个是
    *输出流* 的概念。STDOUT 用于在命令行窗口显示常规输出，而 STDERR 用于显示错误。第二个概念是 *重定向*，它允许我们将 STDOUT 和 STDERR
    捕获到文件中，以便可以在 BP 中读取它们。第三个概念是 *阻塞与非阻塞* 执行。BP 将在继续进行进一步的自动化步骤之前等待阻塞程序完成。如果我们能够以阻塞方式触发外部程序运行，进程逻辑将更容易理解。
- en: 'We also covered three VBOs: one built into BP and two from DX. The built-in
    VBO, **Utility - Environment**, has three Actions that can be used, but **Run
    Process Until Ended** is preferred as it’s the only Action that can natively time
    out long-running scripts. The other two Actions have more niche use cases. **Start
    Process** can be used if blocking is not desired, and **Start Process Read Stderr
    and Stdout** can be used if the script knows how to time itself out.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了三个 VBO：一个内置在 BP 中，两个来自 DX。内置的 VBO，**实用工具 - 环境**，有三个可用的动作，但**运行进程直到结束**
    是首选的，因为它是唯一一个可以原生超时长时间运行的脚本的动作。其他两个动作有更专业的用途。**启动进程** 可以在不希望阻塞的情况下使用，而**启动进程读取
    Stderr 和 Stdout** 可以在脚本知道如何超时的情况下使用。
- en: The **Utility - PowerShell** DX asset can be used specifically with PS scripts.
    It’s able to execute scripts without showing the PS window on the screen, and
    the **Run Script with PowerShell Core** Action also has timeout capability. **Script
    Execution VBO** is more oriented to starting programs with complicated executable
    input parameters, such as those from Python.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**实用工具 - PowerShell** DX 资产可以专门用于 PS 脚本。它能够在不显示 PS 窗口的情况下执行脚本，并且 **使用 PowerShell
    Core 运行脚本** 动作也具有超时功能。**脚本执行 VBO** 更倾向于启动具有复杂可执行输入参数的程序，例如来自 Python 的那些。'
- en: In *Chapters 1* and *2*, we covered how to connect BP to ML through web APIs
    and the command-line interface. In the next chapter, we’ll look at the third way
    of connecting BP to ML, which is through Code Stages.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 1 章* 和 *第 2 章* 中，我们介绍了如何通过 Web API 和命令行界面将 BP 连接到 ML。在下一章中，我们将探讨将 BP 连接到
    ML 的第三种方式，即通过代码阶段。
