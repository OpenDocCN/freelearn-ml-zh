- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Predicting from Command Prompt and PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web APIs are the most common way to communicate with **ML** services. However,
    there are many reasons why you might not be able to use *external* web APIs. For
    example, compliance and regulatory requirements may prevent you from sending data
    outside your firm, or there might not be a suitable ML service for your use case.
    Even for *internally* developed ML models, there are reasons to not use web APIs
    as the communication method. An example is to run models directly on the Digital
    Worker API as this doesn’t require additional web server infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows you some different ways that an ML model can be run *locally*
    through **BP**. We’ll go through examples of how this can be done using **Windows
    Command Prompt** (**WCP**) and **PowerShell** (**PS**).
  prefs: []
  type: TYPE_NORMAL
- en: During my research on **IA**, I tried to discover what underlying technologies,
    libraries, and ML algorithms were being used. *Python* was the only programming
    language that was being used in production (outside of the built-in C# and VB.NET
    used in **RPA**), despite R and Julia being popular languages used to teach ML
    in schools. In the final example of this chapter, we’ll be calling a Python script
    in BP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predicting from the command line using the **Object Utility -** **Environment**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting prediction results back into BP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing out long-running predictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DX VBOs** – **Utility PowerShell** and **Script** **Execution VBO**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, please ensure that the following requirements are met:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and import the **Utility - Powershell** asset from DX: [https://digitalexchange.blueprism.com/dx/entry/9648/solution/utility---powershell](https://digitalexchange.blueprism.com/dx/entry/9648/solution/utility---powershell)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download and import the **Script Execution VBO** asset from DX: [https://digitalexchange.blueprism.com/dx/entry/3439/solution/blue-prism---script-execution-vbo-2](https://digitalexchange.blueprism.com/dx/entry/3439/solution/blue-prism---script-execution-vbo-2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install Python version 3+: [https://www.python.org/downloads](https://www.python.org/downloads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download and import the examples for this chapter from GitHub, which are contained
    in a single Release: [https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch2](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When making a prediction on the Digital Worker machine, you’ll need to invoke
    the command line, unless you’re able to interact with it programmatically through
    a *Code Stage* (the topic of the next chapter) or through a graphical interface.
    BP is able to start standalone programs or scripts through both WCP and PS.
  prefs: []
  type: TYPE_NORMAL
- en: WCP can be launched by running the *Command Prompt* application, or `cmd.exe`
    from the Windows **Start** menu. It can be started as the current user that’s
    logged in to Windows, or an administrator user, by right-clicking Command Prompt
    and choosing **Run** **as administrator**.
  prefs: []
  type: TYPE_NORMAL
- en: PS can be started by running the PS application, or `powershell.exe`/`pwsh.exe`
    from the Windows `pwsh.exe` is the executable for PS Core, which is the newer,
    cross-platform version of PS (v6 and above) that must be installed manually as
    it doesn’t come installed on Windows by default. `powershell.exe` is the legacy
    version (v5.1 and under), which does come pre-installed with Windows.
  prefs: []
  type: TYPE_NORMAL
- en: For IA purposes, there aren’t really any strong arguments for choosing WCP over
    PS, or the other way around. WCP is overall simpler with less functionality, whereas
    PS is more complex and more fully featured. However, these details are internal
    to the command-line scripts themselves, which will likely be provided to you by
    the developers of the ML solution. BP can mostly treat these scripts as black
    boxes.
  prefs: []
  type: TYPE_NORMAL
- en: When predicting locally, you’ll likely be required to deploy the ML model through
    a standalone executable, a batch script, a PS script, or by running the source
    code (most commonly Python) directly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at three concepts that are important to connecting command-line
    programs to BP. These are **output streams**, **output redirection**, and **blocking
    execution**.
  prefs: []
  type: TYPE_NORMAL
- en: Output streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs that are executed from WCP and PS can output text to two different
    streams. The first stream is called `STDERR` is used depends on the authors of
    the script. Sometimes, developers will decide to print error messages to `STDOUT`
    instead of using `STDERR`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: PS has more output streams available, such as for warning and debug messages,
    but STDOUT and STDERR are by far the most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s open `cmd.exe` and type the following (without the `>` character):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see `"Hello Blue Prism"` printed back onto the screen through STDOUT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Output that is displayed in the command-line window is STDOUT](img/B18416_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Output that is displayed in the command-line window is STDOUT
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a different command that we know will generate an error. Let’s print
    out the contents of a non-existent file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives a `The system cannot find the file specified.` error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Is this message STDOUT or STDERR?](img/B18416_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Is this message STDOUT or STDERR?
  prefs: []
  type: TYPE_NORMAL
- en: The intention of the text displayed is to show an error, but was it written
    to the STDOUT stream or STDERR? We can’t tell based on the printed words shown
    in the window, but we can figure this out by **redirecting** STDOUT and STDERR
    into files.
  prefs: []
  type: TYPE_NORMAL
- en: Output redirection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both STDOUT and STDERR can be redirected to one another, and written out to
    files as well. *This is a primary way to capture command-line output into BP*.
    This is done in part by using the redirection, or the “greater-than” character
    (`>`) in WCP and PS. The most common way you’ll see this being used in BP is to
    redirect STDOUT into a file so that it can be read using the **File -** **Management**
    VBO.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `>` character redirects and overwrites any previous content, whereas `>>`
    redirection appends content. We’ll use `>` much more often than `>>` for the purpose
    of getting STDOUT and STDERR into BP since appending requires more development
    logic to differentiate previous content from current content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s redirect STDOUT from one of the previous commands into a file and print
    out the contents of that file in `cmd.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command no longer prints `"Hello Blue Prism"` into the console window.
    The output was redirected into a file. Text is only printed after the second command,
    which does not have any redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Redirecting STDOUT to a file](img/B18416_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Redirecting STDOUT to a file
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try printing the contents of the non-existent file again, except this
    time, we’ll redirect STDOUT to a file. Then, we’ll print the output of the redirected
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see that the error text is printed to the screen, unlike our previous
    example. Why wasn’t this redirected? It’s because the `The system cannot find
    the file specified.` message is not from STDOUT, so redirecting STDOUT has no
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Redirecting STDOUT did not capture the message](img/B18416_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Redirecting STDOUT did not capture the message
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the message wasn’t STDOUT, we can reasonably guess that it was STDERR.
    STDERR can be redirected using `2>` instead of `>` (which is for STDOUT). Let’s
    try redirecting STDERR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now see that the first command prints nothing to the screen, whereas the
    second does. This confirms that the `The system cannot find the file specified.`
    message is written to STDERR and not STDOUT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Redirecting STDERR captures the message](img/B18416_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Redirecting STDERR captures the message
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve only seen examples of redirecting one of the STDOUT or STDERR
    streams, but not both. There are two ways of redirecting both streams. The first
    choice is to combine both STDOUT and STDERR into one stream and redirect that
    single stream into a *single file*. The second choice is to redirect both streams
    into *separate files*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how to do both of these, this time using PS instead of WCP. Luckily,
    all of the redirection commands that we’ve seen are interchangeable between WCP
    and PS. Using PS also has the small benefit of changing STDERR messages to a red-colored
    font so that they are immediately recognizable. Open `powershell.exe` and enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is actually two commands separated by a semicolon. The first `echo` command
    writes to STDOUT, whereas the second `Write-Error` command writes to STDERR. The
    surrounding `&{…}` characters mean to execute it as a single scriptblock in PS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this produces the following output. We see the STDOUT message, `Blue
    Prism`, and the STDERR message (in red) on the PS console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The red text is STDERR, whereas the normal-colored text is STDOUT](img/B18416_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The red text is STDERR, whereas the normal-colored text is STDOUT
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s combine STDERR into the STDOUT stream, redirect that into a *single
    file*, and print out the contents of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After the first `>` instance, we specify the file path that STDOUT should be
    redirected to. `2>&1` means that we want to redirect STDERR into the STDOUT stream.
    When printing out the file, we see that both the STDOUT and STDERR messages are
    present:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Redirecting both STDOUT and STDERR into a single file](img/B18416_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Redirecting both STDOUT and STDERR into a single file
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s redirect STDERR and STDOUT into *separate files*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, `>` let us specify the path we want STDOUT redirected to. Following
    `2>` is where we want STDERR redirected to. When the files are printed out, only
    the content from their corresponding stream is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Redirecting STDOUT and STDERR to different files](img/B18416_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Redirecting STDOUT and STDERR to different files
  prefs: []
  type: TYPE_NORMAL
- en: Given the choice between combining streams and redirecting them into a single
    file versus redirecting STDOUT and STDERR into separate files, it makes much more
    sense to do the *latter*. This allows us to isolate error messages from non-error
    messages. It’s also the reason why we prefer to overwrite previous output (`>`)
    versus append (`>>`). Appending requires us to add more logic, to split the output
    from the latest command run from previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now covered the different ways of redirecting output from the command
    line into files. This makes it easy for us to receive the output of command-line-based
    ML programs into BP. Next, let’s look at the final topic of this *Command-line
    basics* section, blocking versus non-blocking execution.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking versus non-blocking execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When BP starts a command-line program, the execution in BP can either **block**
    or **not block**. If the execution blocks, BP will wait until the program exits
    before moving on to the next Stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – BP waits for a blocking program to complete](img/B18416_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – BP waits for a blocking program to complete
  prefs: []
  type: TYPE_NORMAL
- en: 'If the script doesn’t block, it will continue to run in the background while
    BP progresses. BP won’t know when the script actually completes, unless it can
    explicitly wait and check for an external condition, such as the presence of a
    file written to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – BP continues to run while a non-blocking program executes](img/B18416_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – BP continues to run while a non-blocking program executes
  prefs: []
  type: TYPE_NORMAL
- en: As a BP developer, it’s crucial to decide whether you want the triggered program
    to run in a blocking or non-blocking manner. In almost every case, we prefer BP
    to wait for a script to finish, even when a non-blocking script is running. This
    makes the development and debugging of the process simpler. The different ways
    of achieving this will be discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of *blocking versus non-blocking* is similar to the *synchronous
    versus asynchronous* discussion that we had for web APIs. Web API calls have a
    built-in concept of timing out. If an API request takes too long in BP, it will
    eventually be terminated, with an exception being thrown. Similarly, we also need
    to think about how to **time out** a program that is triggered from the command
    line, if it takes too long to run. We’ll see an example of how this can be done
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at the fundamentals of the command line as it relates
    to BP. First was the concept of output streams. STDOUT is used to show regular
    output to the console screen and STDERR is used to show error messages. Next,
    we discussed how these two streams can be redirected into files, in both WCP and
    PS, using the `>` redirection operator. Redirection allows us to capture the output
    of command-line programs in BP.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at the difference between blocking and non-blocking scripts,
    and stated that we’d prefer to pause BP execution until the script completes for
    predictability reasons. Finally, we introduced the concept of timeouts, in order
    to stop a command-line process from running for too long.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we’ll be answering the following questions, using examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Which VBO and Action should I use to trigger the prediction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can I get the predicted results back into BP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can I stop a script that is running for too long?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Predicting from the command line using Utility – Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Utility - Environment** VBO, found in the VBO sub-folder where BP is
    installed, has three Actions that can be used to launch command-line scripts and
    external programs: **Start Process**, **Start Process Read Stderr and Stdout**,
    and **Run Process** **Until Ended**.'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which Action you use, you will have to fill in at minimum two
    different input parameters in BP. One input parameter specifies *what program
    you want to run*, and another input parameter specifies *additional arguments
    to* *that program*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see two different ways of running a simple batch script, using the **Start
    Process** and **Run Process Until** **Ended** Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – Running a program using the Start Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s run a batch file that takes in two numbers as parameters from BP. To
    make setting up the example simpler, the batch file contents are saved to disk
    at the beginning of the Process. This batch file itself is responsible for writing
    two input parameters into an output file, `C:\Users\Public\ch2_ex1_output.txt`,
    so that we don’t need to do any redirection. At the end of the Process, we delete
    the batch file that was created. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Ch2` Group, in Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Utility Environment::Start Process** Action, in the orange Block.
    See that we’re providing the path of the batch file as the **Application** Input
    Parameter, and two Data Items, separated by a space, as the **Arguments** Value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Passing in the script path as the Application and the two parameters
    separated by a space as the Arguments](img/B18416_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Passing in the script path as the Application and the two parameters
    separated by a space as the Arguments
  prefs: []
  type: TYPE_NORMAL
- en: Run the example once by pressing the **Go** button or *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the batch script ran correctly by verifying the contents of the
    output text file, `C:\Users\Public\ch2_ex1_output.txt`. It should contain the
    text `1234` and `5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12 – The expected output file](img/B18416_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – The expected output file
  prefs: []
  type: TYPE_NORMAL
- en: We’ve finished the most basic example of running a batch file and retrieving
    its output. Since the batch file itself wrote data into files, we didn’t have
    to do any redirection ourselves. Notice that there is a **Sleep 1 second** Action
    in our process diagram. This is needed because the **Utility -** **Environment**
  prefs: []
  type: TYPE_NORMAL
- en: '**::Start Process** Action is *non-blocking*. If the sleep Action isn’t there,
    it’s possible for the batch file to be deleted before it’s even finished executing!'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 - Running a program using Run Process Until Ended
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s modify the previous example, to get rid of the potentially unreliable
    1-second sleep, and make the script *block*. This time, our output file will be
    saved in `C:\Users\Public\ch2_ex2_output.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Example 2 – Running a program using Run Process Until Ended** BP
    Process in Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Utility - Environment::Run Process Until Ended** Action, in the
    orange Block. Note that the **Arguments** and **Application** inputs are identical
    to *Example 1*. The difference is that the Action has changed from **Start Process**
    to **Run Process Until Ended**. Also, see that the **Timeout** input is blank.
    When blank, the default is 10 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.13 – This Action is configured identically to Example 1](img/B18416_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – This Action is configured identically to Example 1
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the sleep Stage has been removed from the Process diagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the example once by pressing the **Go** button or F5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the script was correctly run by opening Windows File Explorer and
    seeing that the `C:\Users\Public\ch2_ex2_output.txt` file contains the text `abcd`
    and `e`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve switched the Action from **Start Process** in *Example 1* to **Run Process
    Until Ended** in *Example 2*. In *Example 1* using **Start Process**, BP executes
    both the Process steps and the batch script in a non-blocking manner. With **Run
    Process Until Ended** in *Example 2*, BP waits for a maximum of 10 seconds for
    the script to complete, before continuing with the Process steps. Despite preferring
    blocking execution most of the time, there might be situations where non-blocking
    is desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s still a third Action in **Utility - Environment** that we haven’t seen
    an example of yet: **Start Process Read Stderr and Stdout**. As you can guess
    by the name, this Action allows us to directly capture the two output streams,
    STDOUT, and STDERR, as Data Items in BP. Next, we will discuss the different ways
    of capturing output from command-line scripts back into BP.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting prediction results back into BP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ML programs started from the command line will likely provide output in one
    of two ways: either by *printing the prediction output to the screen* or *writing
    the results to a file*. There are, of course, other options, such as sending the
    result to a separate system for you to retrieve, but those are outside the scope
    of this chapter. *Table 2.1* lists the most common ways of getting ML prediction
    output, and which Objects/Actions you can use to read it back into BP:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Prediction** **Output Method** | **Input Method** **into BP** | **Object**
    **to Use** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| Written to screen | Use VBO Action that directly reads screen output | **Utility
    -** **Environment** | **Start Process Read Stderr** **and Stdout** |'
  prefs: []
  type: TYPE_TB
- en: '| **Utility -** **PowerShell** | **Run Script** |'
  prefs: []
  type: TYPE_TB
- en: '| **Script** **Execution VBO** | **Execute Script** |'
  prefs: []
  type: TYPE_TB
- en: '| Written to screen | Redirect to a file and read the file | **Utility - Environment**
    | **Start Process** |'
  prefs: []
  type: TYPE_TB
- en: '| **Utility - Environment** | **Run Process** **Until Ended** |'
  prefs: []
  type: TYPE_TB
- en: '| Written to file | Read the file | **Utility –** **Environment** | **Start
    Process** |'
  prefs: []
  type: TYPE_TB
- en: '| **Utility - Environment** | **Run Process** **Until Ended** |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – The different ways of reading prediction outputs back into BP
  prefs: []
  type: TYPE_NORMAL
- en: If the prediction is printed to the console screen, there are two ways to get
    the result back into BP. The first, and simplest way is to **use a VBO Action
    that directly captures output** as Data Items in BP. The second way is to **redirect**
    the printed output into a file and then read the file into BP. Let’s look at an
    example of the first case.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3 – Saving STDOUT and STDERR as Data Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’ll build a Process from scratch that uses the **Start Process
    Read Stderr and Stdout** Action from the **Utility - Environment** VBO. This Action
    allows us to directly save STDERR and STDOUT as Data Items. A completed version
    of this example is available in this chapter’s Release for your reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example also shows off the special syntax needed to run *internal commands*
    of Command Prompt from BP, in case you ever need to do so in the future. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Process named **Example 3** in the *Ch2* Group. Open it in Process
    Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an *Action* Stage to the diagram. Choose **Utility - Environment** as the
    *Business Object* and **Start Process Read Stderr and Stdout** as the *Action*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `"cmd.exe"` (including the double quotation marks) and the `"/c dir"`.
    The `dir` command lists out all of the files and directories inside of the BP
    installation folder. The BP installation folder is where the `cmd.exe` Command
    Prompt will be started from when we’re inside Process Studio. `/c` means terminate
    `cmd.exe` after the `dir` command is finished executing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In order to run *internal commands* from WCP using the `dir`, `echo`, `copy`,
    and so on, we need to put `cmd.exe` as the *Process name* and the command we want
    to run inside of WCP as the *Arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Action’s `Standard Output` and `Standard Error` Data Items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Link the Action between the Start and End Stages. The completed Process should
    look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The completed test Process for Example 3](img/B18416_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – The completed test Process for Example 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Process from Process Studio. The `Standard Output` Data Item will have
    content, whereas the `Standard Error` Data Item will stay empty. This is because
    the `dir` command succeeds with no errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Standard Output is populated](img/B18416_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Standard Output is populated
  prefs: []
  type: TYPE_NORMAL
- en: Modify the Action’s `"/c dir *.xyz"`. This change means that we want to list
    all of the files with the `.xyz` file extension, which shouldn’t exist in the
    BP installation folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the test Process again. Both `Standard Output` and `Standard Error` Data
    Items should be populated, as there is an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Both Standard Output and Standard Error are populated](img/B18416_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Both Standard Output and Standard Error are populated
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the actual console window did not pop up when running *Example 3*,
    yet we were able to capture the data that was printed to the console’s screen.
    Assuming that the ML prediction prints its output to the screen, a second way
    of capturing this data is to redirect the STDOUT and STDERR streams into files
    that can be read by BP. Let’s see how this can be done in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4 – Redirecting an internal command (dir) to files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already used the **Run Process Until Ended** Action from the **Utility
    - Environment** VBO, in *Example 2*. This Action doesn’t let us capture the STDOUT
    and STDERR directly as Data Items; however, the batch script itself in *Example
    2* created a file that can be read back into BP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ll create a new Process using this Object and Action again,
    except the batch script will print output to STDOUT and STDERR. We’ll need to
    redirect the STDOUT and STDERR streams to files so that they can be read into
    BP. A completed version of this example is available in this chapter’s Release
    for your reference. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Process named **Example 4**, in the *Ch2* Group. Open it in Process
    Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create two Data Items with a `Text` Data Type. These are the file paths where
    our redirected outputs will be saved. Set them up as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Data** **Item Name** | **Initial Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `Stdout File` | `C:\Users\Public\ch2_ex4_stdout.txt` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stderr File` | `C:\Users\Public\ch4_ex4_stderr.txt` |'
  prefs: []
  type: TYPE_TB
- en: Table 2.2 – Configuring two Data Items to hold our file paths
  prefs: []
  type: TYPE_NORMAL
- en: Add an *Action* Stage to the diagram. Choose Utility - Environment as the *Business
    Object* and `"cmd.exe"` (including the double quotation marks) and the `"/c dir
    *.xyz > " & Chr(34) & [Stdout File] & Chr(34) & " 2>" & Chr(34) & [Stderr File]
    &` `Chr(34)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `"/c dir *.xyz`, tries to list out a file that does not exist. The next
    part, `> " & Chr(34) & [Stdout File] & Chr(34)`, redirects STDOUT to the file
    that we’ve defined. The `>` character, as you know, means redirect. The `Chr(34)`
    instances are used to put double quotations around the file path, in case there
    are spaces. The last part, `" 2>" & Chr(34) & [Stderr File] & Chr(34)`, redirects
    STDERR to a different file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Link the Action between the Start and End Stages. The completed Process should
    look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.17 – The completed test Process for Example 4](img/B18416_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – The completed test Process for Example 4
  prefs: []
  type: TYPE_NORMAL
- en: Run the Process in Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the `C:\Users\Public` folder, and verify that the two output files have
    been created, from redirection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example, we redirected the STDOUT and STDERR streams of a command internal
    to WCP, `dir`, to two separate files. Since the command is internal, we had to
    put `"cmd.exe"` as the **Application** Input. To perform the redirection, we simply
    added the necessary redirection syntax at the end of the **Arguments** Input.
    To actually get the output into BP, we would read the files that were created.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve covered all three of the Actions in **Utility - Environment**
    that allow us to start external programs from the command line. We’ve seen how
    they differ in terms of blocking and capturing output. This is summarized in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **Does** **it Block?** | **Output** **Saving Method** | **Is
    There** **Timeout Functionality?** |'
  prefs: []
  type: TYPE_TB
- en: '| **Start Process** | No | None. Must use redirection and read the files in
    BP. | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Run Process Until** **Ended** | Yes | None. Must use redirection and read
    the files in BP. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **Start Process Read Stderr** **and Stdout** | Yes | Outputs are saved as
    Data Items. | No |'
  prefs: []
  type: TYPE_TB
- en: Table 2.3 – A summary of the three Actions used to start command-line programs
  prefs: []
  type: TYPE_NORMAL
- en: The last column of the table, *Is There Timeout Functionality?*, is the topic
    of the next section. This refers to whether there’s a built-in method to stop
    the external program from running if it’s taking too long.
  prefs: []
  type: TYPE_NORMAL
- en: Timing out long-running predictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the command-line script encounters a problem, it might hang and stall the
    BP Process forever if it’s blocking. Only one of the Actions has built-in functionality
    to time out a script that is running for too long: **Run Process** **Until Ended**.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to add timeout functionality to any command-line script or program
    by wrapping it in other scripts and using the `start`, `timeout`, and `taskkill`
    commands. However, these methods are more complex compared to just using **Run
    Process Until Ended** plus redirection.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5 – PS script timeout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a more realistic ML example. Here, we have a PS script that calls
    an algorithm to predict whether a customer will cancel a retail store’s membership
    plan. Inputs are passed in from BP to the PS script, and then to the mock ML program.
    The mock ML program returns confidence scores for two labels: `churn` and `no
    churn`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have a collection of eight customers, along with some of
    their defining characteristics, such as age, job category, days since the last
    transaction, and average purchase size in dollars. Our Process will loop through
    all of the customers, call the PS script, and read the predicted confidence score
    of the *churn* label.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this example is to examine and run this PS script and see how we
    can time it out if it takes too long.
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 5 – PowerShell Script Timeout** BP Process in the *Ch2* Group.
    We will look at the important details together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `powershell.exe`. Trying to put the PS script path into the **Application**
    Input won’t actually execute the script, but instead open the file using the default
    application, which is usually Notepad. The **Arguments** Input should look familiar
    to you as it contains the PS script parameters and the redirection file path.
    Also, note that the **Timeout** Input is empty, meaning that the script can run
    for at most 10 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the example once by pressing **Play to Go**. You’ll see that the PS window
    will pop up while the script is running and close afterward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Predictions` Collection and see that it contains the confidence scores
    of the eight customers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – The confidence scores of the successful predictions](img/B18416_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – The confidence scores of the successful predictions
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MakeTimeSpan(0, 0, 0, 3)` into the **Timeout** Input. The maximum
    time we allow the script to run is now 3 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Adding MakeTimeSpan(0, 0, 0, 3) to the Timeout input](img/B18416_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Adding MakeTimeSpan(0, 0, 0, 3) to the Timeout input
  prefs: []
  type: TYPE_NORMAL
- en: 'Reset, and then run the example again. While the PS window is open, you should
    see an exception shown on screen, confirming that the timeout is working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.20 – The PS script has timed out](img/B18416_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – The PS script has timed out
  prefs: []
  type: TYPE_NORMAL
- en: '**Run Process Until Ended** is the only Action that blocks and has timeout
    functionality. While it doesn’t have the ability to automatically read STDOUT
    and STDERR into Data Items, we can get around that using redirection. Because
    of this, **Run Process Until Ended** is the **preferred Action to use for IA**,
    assuming that you don’t want to custom-build a new Action or use third-party VBOs.'
  prefs: []
  type: TYPE_NORMAL
- en: The other two Actions for triggering command-line processes are more situational.
    The **Start Process Read Stderr and Stdout** Action can be used if the command-line
    program that you’re starting has built-in methods to time out itself or whichever
    underlying processes it creates.
  prefs: []
  type: TYPE_NORMAL
- en: You may also encounter cases where there isn’t a good estimate for an appropriate
    timeout value. For example, if you’re predicting in batches, where some batches
    can take seconds while others can take hours, it makes sense to use the non-blocking
    **Start Process** Action and to check that the predictions are complete through
    some other method.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Deployed ML models are not *build once, run forever*. As with all software,
    they should be updated and redeployed; for instance, to update the model with
    more training data, to tune model parameters differently, to apply security fixes
    to libraries used, and so on. Since the ML model can change independently of the
    BP solution, the timeout value should be changed outside of the Process or Object
    diagram as well. I’d recommend storing the timeout as *Environment Variables*
    in a real solution.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the three Actions of the in-built **Utility - Environment**
    VBO, let’s look at two other VBOs that can be used to start command-line programs.
    Both are available for download on DX.
  prefs: []
  type: TYPE_NORMAL
- en: DX VBOs – Utility - PowerShell and Script Execution VBO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two notable assets available on DX that can be used to call command-line
    programs. They offer simplified interfaces to trigger programs, and other nice-to-have
    features that may make you want to choose them over **Utility -** **Environment**.
  prefs: []
  type: TYPE_NORMAL
- en: Utility – PowerShell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This first VBO is specifically for PS, and it contains two Actions, **Run Script**
    and **Run Script with PowerShell Core**. PS Core is the latest version of PS;
    however, it’s not 100% backward compatible with older versions of PS. Older PS
    scripts might not run correctly under PS Core. PS Core is also not installed by
    default on most Windows versions. To avoid compatibility issues, we will be using
    the **Run Script** Action in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6 – Utility – PowerShell Run Script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s revisit *Example 5*, where we triggered a PS script that gave us a prediction
    for user churn. This time, we’ll use the DX VBO instead:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Example 6 – Utility PowerShell Run Script** BP Process in the *Ch2*
    Group. This example has already been built for you, but we’ll look at the important
    details together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `parameter_name=parameter_value`. Multiple parameters should be separated
    by commas. Also, notice that this Action directly saves the output streams as
    Data Items, so redirection isn’t needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the example once in Process Studio. Unlike running the PS script in *Example
    5*, you won’t notice any PS windows pop up!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the `Predictions` Collection contains the confidence scores of the
    eight customers for *churn* and *no churn*. These should be the same as in *Figure
    2**.18*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Run Script** Action of this DX VBO, you gain the benefit of not needing
    output redirection and not seeing a pop-up window over using the Actions in **Utility
    - Environment**, which might be important for your use case. However, there’s
    also no built-in timeout functionality (although there is in **Run Script with
    PowerShell Core**). If you have the ability to install PS Core, I would recommend
    doing so that you can use the Action with timeout functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Script Execution VBO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second asset available on DX is the **Script Execution VBO**. Two Objects
    are included in this Release. The first, **Script Execution VBO**, is implemented
    in C#, and the second, **Script Execution VBO Visual Basic**, is implemented in
    VB. There’s no functional difference between the two, so we’ll use the C# version
    in our next example. Each VBO contains only one Action, **Execute Script**.
  prefs: []
  type: TYPE_NORMAL
- en: One superficial reason why you might want to use this VBO is that your BP Action
    Inputs will look cleaner. As you’ll have noticed, adding redirection and full
    file paths, surrounding them with double quotation characters, `Chr(34)`, and
    so on, can make for messy, and hard-to-understand input arguments to the Action.
    This VBO minimizes this somewhat as it provides separate input parameters for
    the script engine, the script path, and the script name. A more practical reason
    for using this is that it starts external programs using desirable defaults, such
    as blocking, not popping up a command window, and capturing output into Data Items.
    However, it lacks timeout functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7 – Calling a Python program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s call a Python script that predicts the selling price of a house based
    on square footage, number of bedrooms, number of bathrooms, previous selling price,
    and age in years. Since this is a *regression* problem, the Python script returns
    a numerical prediction, as opposed to labels and confidence scores. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Example 7 – Script Execution VBO Calling a Python Script** BP Process
    in the *Ch2* Group. This example has already been built for you, but we’ll look
    at the important details together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the command line, `cmd.exe`, and find the location of your Python executable.
    This might be named `py.exe` or `python.exe`. In WCP, type the following (or substitute
    `py.exe` with `python.exe` if you don’t find a result):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 2.21 – Making the Python Executable Full Path Data Item match your
    Python location](img/B18416_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – Making the Python Executable Full Path Data Item match your Python
    location
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Script Execution VBO::Execute Script** Action, in the orange Block.
    Notice that it looks relatively cleaner, due to the separation of inputs, and
    that redirection isn’t needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.22 – The input parameters are nicely separated](img/B18416_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – The input parameters are nicely separated
  prefs: []
  type: TYPE_NORMAL
- en: Run the Process once in Process Studio. Notice that the Action *blocks* and
    doesn’t pop up any windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the values predicted from Python are saved as Data Items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.23 – The predicted property price](img/B18416_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – The predicted property price
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now covered seven examples of how to start command-line programs in this
    chapter. Each example was designed to show something different in terms of:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of script that is run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which VBO and Action are used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How output is read back into BP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the Action blocks or does not block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the Action allows for timeout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A table that summarizes all of the examples is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example** | **Script Type** | **Call** **Script VBO/Action** | **Read**
    **Output Method** | **Blocking?** | **Timeout?** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `.``bat` | **Utility -** **Environment**/ **Start Process** | The script
    writes output to a file | N | N |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `.``bat` | **Utility -** **Environment**/ **Run Process Until** **Ended**
    | The script writes output to a file | Y | N (although leaving the parameter blank
    means 10 seconds) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Internal command (`dir`) | **Utility - Environment**/**Start Process
    Read Stderr** **and Stdout** | VBO Action saves output as Data Items | Y | N |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Internal command (`dir`) | **Utility - Environment**/**Run Process**
    **Until Ended** | Redirection into files | Y | N (although leaving the parameter
    blank means 10 seconds) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `.``ps1` | **Utility - Environment**/**Run Process** **Until Ended**
    | Redirection into files | Y | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `.``ps1` | **Utility - PowerShell**/ **Run Script** | VBO Action saves
    output as Data Items | Y | N (although the PS Core Action has timeout) |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `.``py` | **Script Execution** **VBO**/**Execute Script** | VBO Action
    saves output as Data Items | Y | N |'
  prefs: []
  type: TYPE_TB
- en: Table 2.4 – A summary of how all of the examples differ
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may be required to connect BP to ML through an executable, a batch script,
    a PS script, or to directly execute source code. This chapter covered three important
    concepts that underlie running programs through the command line in BP. The first
    is the concept of *output streams*. STDOUT is used for displaying regular output
    to the command-line window, and STDERR is used for displaying errors. The second
    concept is *redirection*, which allows us to capture STDOUT and STDERR into files
    so that they can be read back into BP. The third concept is *blocking versus non-blocking*
    execution. BP will wait for blocking programs to complete before proceeding with
    further automation steps. Process logic is simpler to understand if we can trigger
    external programs to run in a blocking manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also covered three VBOs: one built into BP and two from DX. The built-in
    VBO, **Utility - Environment**, has three Actions that can be used, but **Run
    Process Until Ended** is preferred as it’s the only Action that can natively time
    out long-running scripts. The other two Actions have more niche use cases. **Start
    Process** can be used if blocking is not desired, and **Start Process Read Stderr
    and Stdout** can be used if the script knows how to time itself out.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Utility - PowerShell** DX asset can be used specifically with PS scripts.
    It’s able to execute scripts without showing the PS window on the screen, and
    the **Run Script with PowerShell Core** Action also has timeout capability. **Script
    Execution VBO** is more oriented to starting programs with complicated executable
    input parameters, such as those from Python.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapters 1* and *2*, we covered how to connect BP to ML through web APIs
    and the command-line interface. In the next chapter, we’ll look at the third way
    of connecting BP to ML, which is through Code Stages.
  prefs: []
  type: TYPE_NORMAL
