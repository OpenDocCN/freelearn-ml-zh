["```py\n// Install-Package Deedle\n// Install-Package FSharp.Core\nusing Deedle;\n// if you don't have EAGetMail package already, install it \n// via the Package Manager Console by typing in \"Install-Package EAGetMail\"\nusing EAGetMail;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EmailParser\n{\n    class Program\n    {\n        private static Frame<int, string> ParseEmails(string[] files)\n        {\n            // we will parse the subject and body from each email\n            // and store each record into key-value pairs\n            var rows = files.AsEnumerable().Select((x, i) =>\n            {\n                // load each email file into a Mail object\n                Mail email = new Mail(\"TryIt\");\n                email.Load(x, false);\n\n                // extract the subject and body\n                string emailSubject = email.Subject;\n                string textBody = email.TextBody;\n\n                // create key-value pairs with email id (emailNum), subject, and body\n                return new { emailNum = i, subject = emailSubject, body = textBody };\n            });\n\n            // make a data frame from the rows that we just created above\n            return Frame.FromRecords(rows);\n        }\n\n        static void Main(string[] args)\n        {\n            // Get all raw EML-format files\n            // TODO: change the path to point to your data directory\n            string rawDataDirPath = \"<path-to-data-directory>\";\n            string[] emailFiles = Directory.GetFiles(rawDataDirPath, \"*.eml\");\n\n            // Parse out the subject and body from the email files\n            var emailDF = ParseEmails(emailFiles);\n            // Get the labels (spam vs. ham) for each email\n            var labelDF = Frame.ReadCsv(rawDataDirPath + \"\\\\SPAMTrain.label\", hasHeaders: false, separators: \" \", schema: \"int,string\");\n            // Add these labels to the email data frame\n            emailDF.AddColumn(\"is_ham\", labelDF.GetColumnAt<String>(0));\n            // Save the parsed emails and labels as a CSV file\n            emailDF.SaveCsv(\"transformed.csv\");\n\n            Console.WriteLine(\"Data Preparation Step Done!\");\n            Console.ReadKey();\n        }\n    }\n}\n```", "```py\nprivate static Frame<int, string> CreateWordVec(Series<int, string> rows)\n{\n    var wordsByRows = rows.GetAllValues().Select((x, i) =>\n    {\n        var sb = new SeriesBuilder<string, int>();\n\n        ISet<string> words = new HashSet<string>(\n            Regex.Matches(\n                // Alphanumeric characters only\n                x.Value, \"\\\\w+('(s|d|t|ve|m))?\"\n            ).Cast<Match>().Select(\n                // Then, convert each word to lowercase\n                y => y.Value.ToLower()\n            ).ToArray()\n        );\n\n        // Encode words appeared in each row with 1\n        foreach (string w in words)\n        {\n            sb.Add(w, 1);\n        }\n\n        return KeyValue.Create(i, sb.Series);\n    });\n\n    // Create a data frame from the rows we just created\n    // And encode missing values with 0\n    var wordVecDF = Frame.FromRows(wordsByRows).FillMissing(0);\n\n    return wordVecDF;\n}\n```", "```py\nvar hamTermFrequencies = subjectWordVecDF.Where(\n    x => x.Value.GetAs<int>(\"is_ham\") == 1\n).Sum().Sort().Reversed.Where(x => x.Key != \"is_ham\");\n\nvar spamTermFrequencies = subjectWordVecDF.Where(\n    x => x.Value.GetAs<int>(\"is_ham\") == 0\n).Sum().Sort().Reversed;\n\n// Look at Top 10 terms that appear in Ham vs. Spam emails\nvar topN = 10;\n\nvar hamTermProportions = hamTermFrequencies / hamEmailCount;\nvar topHamTerms = hamTermProportions.Keys.Take(topN);\nvar topHamTermsProportions = hamTermProportions.Values.Take(topN);\n\nSystem.IO.File.WriteAllLines(\n    dataDirPath + \"\\\\ham-frequencies.csv\",\n    hamTermFrequencies.Keys.Zip(\n        hamTermFrequencies.Values, (a, b) => string.Format(\"{0},{1}\", a, b)\n    )\n);\n\nvar spamTermProportions = spamTermFrequencies / spamEmailCount;\nvar topSpamTerms = spamTermProportions.Keys.Take(topN);\nvar topSpamTermsProportions = spamTermProportions.Values.Take(topN);\n\nSystem.IO.File.WriteAllLines(\n    dataDirPath + \"\\\\spam-frequencies.csv\",\n    spamTermFrequencies.Keys.Zip(\n        spamTermFrequencies.Values, (a, b) => string.Format(\"{0},{1}\", a, b)\n    )\n);\n```", "```py\nvar barChart = DataBarBox.Show(\n    new string[] { \"Ham\", \"Spam\" },\n    new double[] {\n        hamEmailCount,\n        spamEmailCount\n    }\n);\nbarChart.SetTitle(\"Ham vs. Spam in Sample Set\");\n```", "```py\nvar hamBarChart = DataBarBox.Show(\n    topHamTerms.ToArray(),\n    new double[][] {\n        topHamTermsProportions.ToArray(),\n        spamTermProportions.GetItems(topHamTerms).Values.ToArray()\n    }\n);\nhamBarChart.SetTitle(\"Top 10 Terms in Ham Emails (blue: HAM, red: SPAM)\");\n\nvar spamBarChart = DataBarBox.Show(\n    topSpamTerms.ToArray(),\n    new double[][] {\n        hamTermProportions.GetItems(topSpamTerms).Values.ToArray(),\n        topSpamTermsProportions.ToArray()\n    }\n);\nspamBarChart.SetTitle(\"Top 10 Terms in Spam Emails (blue: HAM, red: SPAM)\");\n```", "```py\nprivate static Frame<int, string> ParseEmails(string[] files)\n{\n    // we will parse the subject and body from each email\n    // and store each record into key-value pairs\n    var rows = files.AsEnumerable().Select((x, i) =>\n    {\n        // load each email file into a Mail object\n        Mail email = new Mail(\"TryIt\");\n        email.Load(x, false);\n\n        // REMOVE \"(Trial Version)\" flags\n        string EATrialVersionRemark = \"(Trial Version)\"; // EAGetMail appends subjects with \"(Trial Version)\" for trial version\n        string emailSubject = email.Subject.EndsWith(EATrialVersionRemark) ? \n            email.Subject.Substring(0, email.Subject.Length - EATrialVersionRemark.Length) : email.Subject;\n        string textBody = email.TextBody;\n\n        // create key-value pairs with email id (emailNum), subject, and body\n        return new { emailNum = i, subject = emailSubject, body = textBody };\n    });\n\n    // make a data frame from the rows that we just created above\n    return Frame.FromRecords(rows);\n}\n```", "```py\n// Read in stopwords list\nISet<string> stopWords = new HashSet<string>(\n    File.ReadLines(\"<path-to-your-stopwords.txt>\")\n);\n// Filter out stopwords from the term frequency series\nvar spamTermFrequenciesAfterStopWords = spamTermFrequencies.Where(\n    x => !stopWords.Contains(x.Key)\n);\n```", "```py\nprivate static Frame<int, string> CreateWordVec(Series<int, string> rows)\n{\n    var wordsByRows = rows.GetAllValues().Select((x, i) =>\n    {\n        var sb = new SeriesBuilder<string, int>();\n\n        ISet<string> words = new HashSet<string>(\n            Regex.Matches(\n                // Alphabetical characters only\n                x.Value, \"[a-zA-Z]+('(s|d|t|ve|m))?\"\n            ).Cast<Match>().Select(\n                // Then, convert each word to lowercase\n                y => y.Value.ToLower()\n            ).ToArray()\n        );\n\n        // Encode words appeared in each row with 1\n        foreach (string w in words)\n        {\n            sb.Add(w, 1);\n        }\n\n        return KeyValue.Create(i, sb.Series);\n    });\n\n    // Create a data frame from the rows we just created\n    // And encode missing values with 0\n    var wordVecDF = Frame.FromRows(wordsByRows).FillMissing(0);\n\n    return wordVecDF;\n}\n```", "```py\nvar cvLogisticRegressionClassifier = CrossValidation.Create<LogisticRegression, IterativeReweightedLeastSquares<LogisticRegression>, double[], int>(\n    // number of folds\n    k: numFolds,\n    // Learning Algorithm\n    learner: (p) => new IterativeReweightedLeastSquares<LogisticRegression>()\n    {\n        MaxIterations = 100,\n        Regularization = 1e-6\n    },\n    // Using Zero-One Loss Function as a Cost Function\n    loss: (actual, expected, p) => new ZeroOneLoss(expected).Loss(actual),\n    // Fitting a classifier\n    fit: (teacher, x, y, w) => teacher.Learn(x, y, w),\n    // Input with Features\n    x: input,\n    // Output\n    y: output\n);\n\n// Run Cross-Validation\nvar result = cvLogisticRegressionClassifier.Learn(input, output);\n```", "```py\nvar cvNaiveBayesClassifier = CrossValidation.Create<NaiveBayes<BernoulliDistribution>, NaiveBayesLearning<BernoulliDistribution>, double[], int>(\n    // number of folds\n    k: numFolds,\n    // Naive Bayes Classifier with Binomial Distribution\n    learner: (p) => new NaiveBayesLearning<BernoulliDistribution>(),\n    // Using Zero-One Loss Function as a Cost Function\n    loss: (actual, expected, p) => new ZeroOneLoss(expected).Loss(actual),\n    // Fitting a classifier\n    fit: (teacher, x, y, w) => teacher.Learn(x, y, w),\n    // Input with Features\n    x: input,\n    // Output\n    y: output\n);\n\n// Run Cross-Validation\nvar result = cvNaiveBayesClassifier.Learn(input, output);\n```", "```py\n// Change number of features to reduce overfitting\nint minNumOccurrences = 1;\nstring[] wordFeatures = indexedSpamTermFrequencyDF.Where(\n    x => x.Value.GetAs<int>(\"num_occurences\") >= minNumOccurrences\n).RowKeys.ToArray();\nConsole.WriteLine(\"Num Features Selected: {0}\", wordFeatures.Count());\n```", "```py\n// Run Cross-Validation\nvar result = cvNaiveBayesClassifier.Learn(input, output);\n\n// Training Error vs. Test Error\ndouble trainingError = result.Training.Mean;\ndouble validationError = result.Validation.Mean;\n```", "```py\n// Confusion Matrix\nGeneralConfusionMatrix gcm = result.ToConfusionMatrix(input, output);\n\nfloat truePositive = (float)gcm.Matrix[1, 1];\nfloat trueNegative = (float)gcm.Matrix[0, 0];\nfloat falsePositive = (float)gcm.Matrix[1, 0];\nfloat falseNegative = (float)gcm.Matrix[0, 1];\n```", "```py\n// Accuracy vs. Precision vs. Recall\nfloat accuracy = (truePositive + trueNegative) / numberOfSamples;\nfloat precision = truePositive / (truePositive + falsePositive);\nfloat recall = truePositive / (truePositive + falseNegative);\n```"]