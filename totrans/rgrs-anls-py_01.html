<html><head></head><body>
<div class="book" title="Chapter&#xA0;1.&#xA0;Regression &#x2013; The Workhorse of Data Science"><div class="book" id="DB7S2-a2faae6898414df7b4ff4c9a487a20c6"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Regression – The Workhorse of Data Science</h1></div></div></div><p class="calibre8">Welcome to this presentation on the workhorse of data science, linear regression, and its related family of linear models.</p><p class="calibre8">Nowadays, interconnectivity and data explosion are realities that open a world of new opportunities for every business that can read and interpret data in real time. Everything is facilitating the production and diffusion of data: the omnipresent Internet diffused both at home and at work, an army of electronic devices in the pockets of large portions of the population, and the pervasive presence of software producing data about every process and event. So much data is generated daily that humans cannot deal with it because of its volume, velocity, and variety. Thus, machine learning and AI are on the rise.</p><p class="calibre8">Coming from a long and glorious past in the field of statistics and econometrics, linear regression, and its derived methods, can provide you with a simple, reliable, and effective tool to learn from data and act on it. If carefully trained with the right data, linear methods can compete well against the most complex and fresh AI technologies, offering you unbeatable ease of implementation and scalability for increasingly large problems.</p><p class="calibre8">In this chapter, we will explain:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Why linear models can be helpful as models to be evaluated in a data science pipeline or as a shortcut for the immediate development of a scalable minimum viable product</li><li class="listitem">Some quick indications for installing Python and setting it up for data science tasks</li><li class="listitem">The necessary modules for implementing linear models in Python</li></ul></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Regression &#x2013; The Workhorse of Data Science">
<div class="book" title="Regression analysis and data science"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Regression analysis and data science</h1></div></div></div><p class="calibre8">Imagine you are<a id="id0" class="calibre1"/> a developer hastily working on a very cool application<a id="id1" class="calibre1"/> that is going to serve thousands of customers using your company's website everyday. Using the available information about customers in your data warehouse, your application is expected to promptly provide a pretty smart and not-so-obvious answer. The answer unfortunately cannot easily be programmatically predefined, and thus will require you to adopt a <span class="strong"><em class="calibre9">learning-from-data</em></span> approach, typical of data science or predictive analytics.</p><p class="calibre8">In this day and age, such applications are quite frequently found assisting numerous successful ventures on the Web, for instance:</p><div class="book"><ul class="itemizedlist"><li class="listitem">In the advertising business, an application delivering targeted advertisements</li><li class="listitem">In e-commerce, a batch application filtering customers to make more relevant commercial offers or an online app recommending products to buy on the basis of ephemeral data such as navigation records</li><li class="listitem">In the credit or insurance business, an application selecting whether to proceed with online inquiries from users, basing its judgment on their credit rating and past relationship with the company</li></ul></div><p class="calibre8">There are numerous other possible examples, given the constantly growing number of use cases about machine learning applied to business problems. The core idea of all these applications is that you don't need to program how your application should behave, but you just set some desired behaviors by providing useful examples. The application will learn by itself what to do in any circumstance.</p><p class="calibre8">After you are clear about the purpose of your application and decide to use the learning-from-data approach, you are confident that you don't have to reinvent the wheel. Therefore, you jump into reading tutorials and documentation about data science and machine learning solutions applied to problems similar to yours (they could be papers, online blogs, or books talking about data science, machine learning, statistical learning, and predictive analytics).</p><p class="calibre8">After reading a few pages, you will surely be exposed to the wonders of many complex machine learning algorithms you likely have never heard of before.</p><p class="calibre8">However, you start being puzzled. It isn't simply because of the underlying complex mathematics; it is mostly because of the large amount of possible solutions based on very different techniques. You also often notice the complete lack of any discussion about how to deploy such algorithms in a production environment and whether they would scale up to real-time server requests.</p><p class="calibre8">At this point, you are completely unsure where should you start. This is when this book will come to your rescue.</p><p class="calibre8">Let's start from the beginning.</p></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Regression &#x2013; The Workhorse of Data Science">
<div class="book" title="Regression analysis and data science">
<div class="book" title="Exploring the promise of data science"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec07" class="calibre1"/>Exploring the promise of data science</h2></div></div></div><p class="calibre8">Given a more interconnected world and the growing availability of data, data science has become quite a<a id="id2" class="calibre1"/> hot topic in recent years.</p><p class="calibre8">In the past, analytical solutions had strong constrains: the availability of data. Useful data was generally scarce and always costly to obtain and store. Given the current data explosion, now abundant and cheaper information at hand makes learning from data a reality, thus opening the doors to a wide range of predictive applications that were simply impractical before.</p><p class="calibre8">In addition, being in an interconnected world, most of your customers are now reachable (and susceptible of being influenced) through the Internet or through mobile devices. This simply means that being smart in developing automated solutions based on data and its predictive powers can directly and almost instantaneously affect how your business works and performs. Being able to reach your customers instantly everywhere, 24 hours a day, 365 days a year, enables your company to turn data into profits, if you know the right things to be done. In the 21st century, <span class="strong"><em class="calibre9">data is the new oil of the digital economy,</em></span> as a memorable and still undisputed article on Wired stated not too long ago (<a class="calibre1" href="http://www.wired.com/insights/2014/07/data-new-oil-digital-economy/">http://www.wired.com/insights/2014/07/data-new-oil-digital-economy/</a>).However, as with oil, data has to be extracted, refined, and distributed.</p><p class="calibre8">Being at the intersection of substantive expertise (knowing how to do business and make profits), machine learning (learning from data), and hacking skills (integrating various systems and data sources), data science promises to find the mix of tools to leverage your available data and turn it into profits.</p><p class="calibre8">However, there's another side to the coin.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Regression &#x2013; The Workhorse of Data Science">
<div class="book" title="Regression analysis and data science">
<div class="book" title="The challenge"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec08" class="calibre1"/>The challenge</h2></div></div></div><p class="calibre8">Unfortunately, there<a id="id3" class="calibre1"/> are quite a few challenging issues in applying data science to a business problem:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Being able to process unstructured data or data that has been modeled for completely different purposes</li><li class="listitem">Figuring out how to extract such data from heterogeneous sources and integrate it in a timely manner</li><li class="listitem">Learning (from data) some effective general rules allowing you to correctly predict your problem</li><li class="listitem">Understanding what has been learned and being able to effectively communicate your solution to a non-technical managerial audience</li><li class="listitem">Scaling to real-time predictions given big data inputs</li></ul></div><p class="calibre8">The first two points are mainly problems that require data manipulation skills, but from the third point onwards, we really need a data science approach to solve the problem.</p><p class="calibre8">The data science <a id="id4" class="calibre1"/>approach, based on machine learning, requires careful testing of different algorithms, estimating their predictive capabilities with respect to the problem, and finally selecting the best one to implement. This is exactly what the science in <span class="strong"><em class="calibre9">data science</em></span> means: coming up with various different hypotheses and experimenting with them to find the one that best fits the problem and allows generalization of the results.</p><p class="calibre8">Unfortunately, there is no white unicorn in data science; there is no single hypothesis that can successfully fit all the available problems. In other words, we say that there is <span class="strong"><em class="calibre9">no free lunch</em></span> (the name of a famous theorem from the optimization domain), meaning that <a id="id5" class="calibre1"/>there are no algorithms or procedures in data science that can always assure you the best results; each algorithm can be less or more successful, depending on the problem.</p><p class="calibre8">Data comes in all shapes and forms and reflects the complexity of the world we live in. The existing algorithms should have certain sophistication in order to deal with the complexity of the world, but don't forget that they are just models. Models are nothing but simplifications and approximations of the system of rules and laws we want to successfully represent and replicate for predictive reasons since <span class="strong"><em class="calibre9">you can control only what you can measure</em></span>, as Lord Kelvin said. An approximation should be evaluated based on its effectiveness, and the efficacy of learning algorithms applied to real problems is dictated by so many factors (type of problem, data quality, data quantity, and so on) that you really cannot tell in advance what will work and what won't. Under such premises, you always want to test the simpler solutions first, and follow the principle of <a id="id6" class="calibre1"/>
<span class="strong"><em class="calibre9">Occam's razor</em></span> as much as possible, favoring simpler models against more complex ones when their performances are comparable.</p><p class="calibre8">Sometimes, even when the situation allows the introduction of more complex and more performant models, other factors may still favor the adoption of simpler yet less performant solutions. In fact, the best model is not always necessarily the most performant one. Depending on the problem and the context of application, issues such as ease of implementation in production systems, scalability to growing volumes of data, and performance in live settings, may deeply redefine how important the role of predictive performance is in the choice of the best solution.</p><p class="calibre8">In such situations, it is still advisable to use simpler, well-tuned models or easily explainable ones, if they provide an acceptable solution to the problem.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Regression &#x2013; The Workhorse of Data Science">
<div class="book" title="Regression analysis and data science">
<div class="book" title="The linear models"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec09" class="calibre1"/>The linear models</h2></div></div></div><p class="calibre8">In your initial<a id="id7" class="calibre1"/> overview of the problem of what machine learning <a id="id8" class="calibre1"/>algorithm to use, you may have also stumbled upon linear models, namely linear regression and logistic regression. They both have been presented as basic tools, building blocks of a more sophisticated knowledge that you should achieve before hoping to obtain the best results.</p><p class="calibre8">Linear models have been known and studied by scholars and practitioners for a long time. Before being promptly adopted into data science, linear models were always among the basic statistical models to start with in predictive analytics and data mining. They also have been a prominent and relevant tool part of the body of knowledge of statistics, economics, and many other quantitative subjects.</p><p class="calibre8">By a simple<a id="id9" class="calibre1"/> check (via a query from an online bookstore, from a library, or just from Google Books—<a class="calibre1" href="https://books.google.com/">https://books.google.com/</a>), you will discover there is quite a vast availability of publications about linear regression. There is also quite an abundance of publications about logistic regression, and about other different variants of the regression algorithm, the so-called generalized linear models, adapted in their formulation to face and solve more complex problems.</p><p class="calibre8">As practitioners ourselves, we are well aware of the limits of linear models. However, we cannot ignore their strong positive key points: simplicity and efficacy. We also cannot ignore that linear models are indeed among the most used learning algorithms in applied data science, making them real workhorses in data analysis (in business as well as in many scientific domains).</p><p class="calibre8">Far from being the best tool at hand, they are always a good starting point in a data science path of discovery because they don't require hacking with too many parameters and they are very fast to train. Thus, linear models can point out the predictive power of your data at hand, identify the most important variables, and allow you to quickly test useful transformations of your data before applying more complex algorithms.</p><p class="calibre8">In the course of this book, you will learn how to build prototypes based on linear regression models, keeping your data treatment and handling pipeline prompt for possible development reiterations of the initial linear model into more powerful and complex ones, such as neural networks or support vector machines.</p><p class="calibre8">Moreover, you will learn that you maybe don't even need more complex models, sometimes. If you are really working with lots of data, after having certain volumes of input data feed into a model, using simple or complex algorithms won't matter all that much anymore. They will all perform to the best of their capabilities.</p><p class="calibre8">The capability of big data to make even simpler models as effective as a complex one has been pointed out by a famous paper co-authored by Alon Halevy, Peter Norvig, and Fernando Pereira from Google about <span class="strong"><em class="calibre9">The Unreasonable Effectiveness of Data</em></span> (<a class="calibre1" href="http://static.googleusercontent.com/media/research.google.com/it//pubs/archive/35179.pdf">http://static.googleusercontent.com/media/research.google.com/it//pubs/archive/35179.pdf</a>). Before that, the idea was already been known because of a less popular scientific paper by Microsoft researchers, Michele Banko and Eric Brill, <span class="strong"><em class="calibre9">Scaling to Very Very Large Corpora for Natural Language Disambiguation</em></span> (<a class="calibre1" href="http://ucrel.lancs.ac.uk/acl/P/P01/P01-1005.pdf">http://ucrel.lancs.ac.uk/acl/P/P01/P01-1005.pdf</a>).</p><p class="calibre8">In simple and short words, the algorithm with more data wins most of the time over other algorithms (no matter their complexity); in such a case, it could well be a linear model.</p><p class="calibre8">However, linear models can be also helpful downstream in the data science process and not just<a id="id10" class="calibre1"/> upstream. As they are fast to train, they are also fast to be<a id="id11" class="calibre1"/> deployed and you do not need coding complex algorithms to do so, allowing you to write the solution in any script or programming language you like, from SQL to JavaScript, from Python to C/C++.</p><p class="calibre8">Given their ease of implementation, it is not even unusual that, after building complex solutions using neural networks or ensembles, such solutions are reverse-engineered to find a way to make them available in production as a linear model and achieve a simpler and scalable implementation.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Regression &#x2013; The Workhorse of Data Science">
<div class="book" title="Regression analysis and data science">
<div class="book" title="What you are going to find in the book"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec10" class="calibre1"/>What you are going to find in the book</h2></div></div></div><p class="calibre8">In the following pages, the book will explain algorithms as well as their implementation in Python to solve practical real-world problems.</p><p class="calibre8">Linear models can be counted among supervised algorithms, which are those algorithms that can formulate predictions on numbers and classes if previously given some correct examples to learn from. Thanks to a series of examples, you will immediately distinguish if a problem could be tractable using this algorithm or not.</p><p class="calibre8">Given the statistical origins of the linear models family, we cannot neglect starting from a statistical perspective. After contextualizing the usage of linear models, we will provide all the essential elements for understanding on what statistical basis and for what purpose the algorithm has been created. We will use Python to evaluate the statistical outputs of a linear model, providing information about the different statistical tests used.</p><p class="calibre8">The data science approach is quite practical (to solve a problem for its business impact), and many limitations of the statistical versions of linear models actually do not apply. However, knowing how the R-squared coefficient works or being able to evaluate the residuals of a regression or highlighting the collinearity of its predictors, can provide you with more means to obtain good results from your work in regression modeling.</p><p class="calibre8">Starting from regression models involving a single predictive variable, we will move on to consider multiple variables, and from predicting just numbers we will progress to estimating the probability of there being a certain class among two or many.</p><p class="calibre8">We will particularly emphasize how to prepare data, both the target variable (a number or a class) to be predicted and the predictors; variables contributing to a correct prediction. No matter what your data is made of, numbers, nouns, text, images, or sounds, we will provide you with the method to correctly prepare your data and transform it in such a way that your models will perform the best.</p><p class="calibre8">You will also be introduced to the scientific methodology at the very foundations of data science, which will help you understand why the data science approach is not just simply theoretical but also quite practical, since it allows obtaining models that can really work when applied to real-world problems.</p><p class="calibre8">The last pages of the book will cover some of the more advanced techniques for handling big data and complexity in models. We will also provide you with a few examples from relevant business domains and offer plenty of details about how to proceed to build a linear model, validate it, and later on implement it into a production environment.</p></div></div></div>

<div class="book" title="Python for data science"><div class="book" id="E9OE2-a2faae6898414df7b4ff4c9a487a20c6"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Python for data science</h1></div></div></div><p class="calibre8">Given the availability of many useful packages for creating linear models and given the fact that it is a<a id="id12" class="calibre1"/> programming language quite popular among <a id="id13" class="calibre1"/>developers, Python is our language of choice for all the code presented in this book.</p><p class="calibre8">Created in 1991 as a general-purpose, interpreted, object-oriented language, Python has slowly and steadily conquered the scientific community and grown into a mature ecosystem of specialized packages for data processing and analysis. It allows you to perform uncountable and fast experiments, easy theory development, and prompt deployments of scientific applications.</p><p class="calibre8">As a developer, you will find using Python interesting for various reasons:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It offers a large, mature system of packages for data analysis and machine learning. It guarantees that you will get all that you need in the course of a data analysis, and sometimes even more.</li><li class="listitem">It is very versatile. No matter what your programming background or style is (object-oriented or procedural), you will enjoy programming with Python.</li><li class="listitem">If you don't know it yet, but you know other languages well such as C/C++ or Java, it is very simple to learn and use. After you grasp the basics, there's no better way to learn more than by immediately starting to code.</li><li class="listitem">It is cross-platform; your solutions will work perfectly and smoothly on Windows, Linux, and Mac OS systems. You won't have to worry about portability.</li><li class="listitem">Although interpreted, it is undoubtedly fast compared to other mainstream data analysis languages such as R and MATLAB (though it is not comparable to C, Java, and the newly emerged Julia language).</li><li class="listitem">There are packages that allow you to call other platforms, such as R and Julia, outsourcing some of the computations to them and improving your script performance. Moreover, there are also static compilers such as Cython or just-in-time compilers such as PyPy that can transform Python code into C for higher performance.</li><li class="listitem">It can work<a id="id14" class="calibre1"/> better than other platforms with in-memory<a id="id15" class="calibre1"/> data because of its minimal memory footprint and excellent memory management. The memory garbage collector will often save the day when you load, transform, dice, slice, save, or discard data using the various iterations and reiterations of data wrangling.</li></ul></div></div>

<div class="book" title="Python for data science">
<div class="book" title="Installing Python"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec11" class="calibre1"/>Installing Python</h2></div></div></div><p class="calibre8">As a first step, we are going to create a fully working data science environment you can use to replicate<a id="id16" class="calibre1"/> and test the examples in the book and prototype your own models.</p><p class="calibre8">No matter in what language you are going to develop your application, Python will provide an easy way to access your data, build your model from it, and extract the right parameters you need to make predictions in a production environment.</p><p class="calibre8">Python is an open source, object-oriented, cross-platform programming language that, compared with its direct competitors (for instance, C/C++ and Java), produces very concise and very readable code. It allows you to build a working software prototype in a very short time, to maintain it easily, and to scale it to larger quantities of data. It has become the most used language in the data scientist's toolbox because it is a general-purpose language made very flexible thanks to a large variety of available packages that can easily and rapidly help you solve a wide spectrum of both common and niche problems.</p></div></div>

<div class="book" title="Python for data science">
<div class="book" title="Choosing between Python 2 and Python 3"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec12" class="calibre1"/>Choosing between Python 2 and Python 3</h2></div></div></div><p class="calibre8">Before starting, it is important to know that there are two main branches of Python: version 2 and 3. Since<a id="id17" class="calibre1"/> many core functionalities have changed, scripts built for one versions are often incompatible (they won't work without raising errors and warnings) with the other one. Although the third version is the newest, the older one is still the most used version in the scientific area, and the default version for many operating systems (mainly for compatibility in upgrades). When version 3 was released in 2008, most scientific packages weren't ready, so the scientific community was stuck with the previous version. Fortunately, since then, almost all packages have been<a id="id18" class="calibre1"/> updated, leaving just a few orphans of Python 3 compatibility (see <a class="calibre1" href="http://py3readiness.org/">http://py3readiness.org/</a> for a compatibility overview).</p><p class="calibre8">In this book, which should address a large audience of developers, we agreed that it would have<a id="id19" class="calibre1"/> been better to work with Python 3 rather than the older version. Python 3 is the future of Python; in fact, it is the only version that will be further developed and improved by the Python foundation. It will be the default version of the future. If you are currently working with version 2 and you prefer to keep on working with it, we suggest you to run these following few lines of code at the beginning every time you start  the interpreter. By doing so, you'll render Python 2 capable of executing most version 3 code with minimal or no problems at all (the code will patch just a few basic incompatibilities, after installing the future package using the command <code class="email">pip install future</code>, and let you safely run all the code in this book):</p><div class="informalexample"><pre class="programlisting">from __future__ import unicode_literals 
# to make all string literals into unicode strings
from __future__ import print_function # To print multiple strings
from six import reraise as raise_ # Raising exceptions with a traceback
from __future__ import division # True division
from __future__ import absolute_import # Flexible Imports</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">The <code class="email">from __future__ import</code> commands should always occur at the beginning of your script or you may experience Python reporting an error.</p></div></div></div>

<div class="book" title="Python for data science">
<div class="book" title="Step-by-step installation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec13" class="calibre1"/>Step-by-step installation</h2></div></div></div><p class="calibre8">If you have never used Python (but that doesn't mean that you may not already have it installed on your machine), you need to first download the installer from the main website of the<a id="id20" class="calibre1"/> project, <a class="calibre1" href="https://www.python.org/downloads/">https://www.python.org/downloads/</a> (remember, we are using version 3), and then install it on your local machine.</p><p class="calibre8">This section <a id="id21" class="calibre1"/>provides you with full control over what can be installed on your machine. This is very useful when you are going to use Python as both your prototyping and production language. Furthermore, it could help you keep track of the versions of packages you are using. Anyway, please be warned that a step-by-step installation really takes time and effort. Instead, installing a ready-made scientific distribution will lessen the burden of installation procedures and may well facilitate initial learning because it can save you quite a lot of time, though it will install a large number of packages (that for the most part you may never use) on your computer all at once. Therefore, if you want to start immediately and don't need to control your installation, just skip this part and proceed to the next section about scientific distributions.</p><p class="calibre8">As Python is a multiplatform programming language, you'll find installers for computers that either run on Windows or Linux/Unix-like operating systems. Please remember that some Linux distributions (such as Ubuntu) already have Python packed in the repository, which makes the<a id="id22" class="calibre1"/> installation process even easier:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a Python shell, type <code class="email">python</code> in the terminal or click on the Python <span class="strong"><strong class="calibre2">IDLE</strong></span> icon. Then, to test the installation, run the following code in the Python interactive shell or REPL:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; import sys</strong></span>
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; print (sys.version)</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre2">Downloading the example code</strong></span></p><p class="calibre8">You can download the example code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><div class="mediaobject"><img src="../images/00002.jpeg" alt="Step-by-step installation" class="calibre10"/></div><p class="calibre19"> </p></li></ol><div class="calibre18"/></div><p class="calibre8">If a syntax error is raised, it means that you are running Python 2 instead of Python 3. Otherwise, if you don't experience an error and you read that your Python version is 3.x (at the time of writing this book, the latest version was 3.5.0), then congratulations on running the version of Python we elected for this book.</p><p class="calibre8">To clarify, when a command is given in the terminal command line, we prefix the command with <code class="email">$&gt;</code>. Otherwise, if it's for the Python REPL, it's preceded by <code class="email">&gt;&gt;&gt;</code>.</p></div></div>

<div class="book" title="Python for data science">
<div class="book" title="Installing packages"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec14" class="calibre1"/>Installing packages</h2></div></div></div><p class="calibre8">Depending<a id="id23" class="calibre1"/> on your system and past installations, Python may not come bundled with all you need, unless you have installed a distribution (which, on the other hand, is usually stuffed with much more than you may need).</p><p class="calibre8">To install any packages you need, you can use the commands <code class="email">pip</code> or <code class="email">easy_install</code>; however, <code class="email">easy_install</code> is going to be dropped in the future and <code class="email">pip</code> has important advantages over it. It is preferable to install everything using <code class="email">pip</code> because:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It is the preferred package manager for Python 3 and, starting with Python 2.7.9 and Python 3.4, it is included by default with the Python binary installers</li><li class="listitem">It provides an uninstall functionality</li><li class="listitem">It rolls back and leaves your system clear if, for whatever reason, the package installation fails</li></ul></div><p class="calibre8">The command <code class="email">pip</code> runs on the command line and makes the process of installing, upgrading, and removing Python packages simply a breeze.</p><p class="calibre8">As we mentioned, if you're running at least Python 2.7.9 or Python 3.4 the <code class="email">pip</code> command should already be there. To verify which tools have been installed on your local machine, directly test with the following command if any error is raised:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; pip -V</strong></span>
</pre></div><p class="calibre8">In some Linux and Mac installations, the command is present as <code class="email">pip3</code> (more likely if you have both Python 2 and 3 on your machine), so, if you received an error when looking for <code class="email">pip</code>, also try running the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; pip3 -V</strong></span>
</pre></div><p class="calibre8">Alternatively, you can also test if the old command <code class="email">easy_install</code> is available:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; easy_install --version</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">Using <code class="email">easy_install</code> in spite of pip's advantages makes sense if you are working on Windows because <code class="email">pip</code> will not install binary packages (it will try to build them); therefore, if you are experiencing unexpected difficulties installing a package, <code class="email">easy_install</code> can save your day.</p></div><p class="calibre8">If your test ends with an error, you really need to install <code class="email">pip</code> from scratch (and in doing so, also <code class="email">easy_install</code> at the same time).</p><p class="calibre8">To <a id="id24" class="calibre1"/>install <code class="email">pip</code>, simply<a id="id25" class="calibre1"/> follow the instructions given at <a class="calibre1" href="https://pip.pypa.io/en/stable/installing/">https://pip.pypa.io/en/stable/installing/</a>. The safest way is to download the <code class="email">get-pi.py</code> script from <a class="calibre1" href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a> and then run it using<a id="id26" class="calibre1"/> the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; python get-pip.py</strong></span>
</pre></div><p class="calibre8">By the way, the script<a id="id27" class="calibre1"/> will also install the setup tool from <a class="calibre1" href="https://pypi.python.org/pypi/setuptools">https://pypi.python.org/pypi/setuptools</a>, which contains <code class="email">easy_install</code>.</p><p class="calibre8">As an alternative, if you are running a Debian/Ubuntu Unix-like system, then a fast shortcut would be to install everything using <code class="email">apt-get</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; sudo apt-get install python3-pip</strong></span>
</pre></div><p class="calibre8">After <a id="id28" class="calibre1"/>checking this basic requirement, you're now ready to install all the packages you need to run the examples provided in this book. To install a generic package, <code class="email">&lt;pk&gt;</code>, you just need to run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; pip install &lt;pk&gt;</strong></span>
</pre></div><p class="calibre8">Alternatively, if you prefer to use <code class="email">easy_install</code>, you can also run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; easy_install &lt;pk&gt;</strong></span>
</pre></div><p class="calibre8">After that, the <code class="email">&lt;pk&gt;</code>package and all its dependencies will be downloaded and installed.</p><p class="calibre8">If you are not sure whether a library has been installed or not, just try to import a module inside it. If the Python interpreter raises an <code class="email">Import Error</code> error, it can be concluded that the package has not been installed.</p><p class="calibre8">Let's take an example. This is what happens when the NumPy library has been installed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; import numpy</strong></span>
</pre></div><p class="calibre8">This is what happens if it is not installed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; import numpy </strong></span>
<span class="strong"><strong class="calibre2">Traceback (most recent call last):</strong></span>
<span class="strong"><strong class="calibre2">File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong class="calibre2">ImportError: No module named numpy</strong></span>
</pre></div><p class="calibre8">In the latter case, before importing it, you'll need to install it through <code class="email">pip</code> or <code class="email">easy_install</code>.</p><p class="calibre8">Take care that you don't confuse packages with modules. With <code class="email">pip</code>, you install a package; in Python, you import a module. Sometimes, the package and the module have the same name, but in many cases they don't match. For example, the <code class="email">sklearn</code> module is included in the package named <code class="email">Scikit-learn</code>.</p></div></div>

<div class="book" title="Python for data science">
<div class="book" title="Package upgrades"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec15" class="calibre1"/>Package upgrades</h2></div></div></div><p class="calibre8">More often than not, you will find yourself in a situation where you have to upgrade a package because the new version either is required by a dependency or has additional features that <a id="id29" class="calibre1"/>you would like to use. To do so, first check the version of the library you have installed by glancing at the <code class="email">__version__</code> attribute, as shown in the following example using the NumPy package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; numpy.__version__ # 2 underscores before and after</strong></span>
<span class="strong"><strong class="calibre2">'1.9.2'</strong></span>
</pre></div><p class="calibre8">Now, if you want to update it to a newer release, say the 1.10.1 version, you can run the following command from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; pip install -U numpy==1.10.1</strong></span>
</pre></div><p class="calibre8">Alternatively, but we do not recommend it unless it proves necessary, you can also use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; easy_install --upgrade numpy==1.10.1</strong></span>
</pre></div><p class="calibre8">Finally, if you are just interested in upgrading it to the latest available version, simply run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; pip install -U numpy</strong></span>
</pre></div><p class="calibre8">You can alternatively also run the <code class="email">easy_install</code> alternative:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$&gt; easy_install --upgrade numpy</strong></span>
</pre></div></div></div>

<div class="book" title="Python for data science">
<div class="book" title="Scientific distributions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec16" class="calibre1"/>Scientific distributions</h2></div></div></div><p class="calibre8">As you've read so far, creating a working environment is a time-consuming operation for a data scientist. You first need to install Python and then, one by one, you can install all the libraries that <a id="id30" class="calibre1"/>you will need (sometimes, the installation procedures may not go as smoothly as you'd hoped for earlier).</p><p class="calibre8">If you want to save time and effort and want to ensure that you have a working Python environment that is ready to use, you can just download, install, and use a scientific Python distribution. Apart from Python itself, distributions also include a variety of preinstalled packages, and sometimes they even have additional tools and an IDE set up for your usage. A few of them are very well known among data scientists and, in the sections that follow, you will find some of the key features for two of these packages that we found most useful and practical.</p><p class="calibre8">To immediately focus on the contents of the book, we suggest that you first download and install a scientific distribution, such as Anaconda (which is the most complete one around, in our opinion). Then, after practicing the examples in the book, we suggest you to decide to fully uninstall the distribution and set up Python alone, which can be accompanied by just the packages you need for your projects.</p><p class="calibre8">Again, if<a id="id31" class="calibre1"/> possible, download and install the version containing Python 3.</p><p class="calibre8">The first package that<a id="id32" class="calibre1"/> we would recommend you try is Anaconda (<a class="calibre1" href="https://www.continuum.io/downloads">https://www.continuum.io/downloads</a>), which is a Python distribution offered by Continuum Analytics that includes nearly 200 packages, including NumPy, SciPy, Pandas, IPython, Matplotlib, Scikit-learn, and Statsmodels. It's a cross-platform distribution that can be installed on machines with other existing Python distributions and versions, and its base version is free. Additional add-ons that contain advanced features are charged separately. Anaconda introduces conda, a binary package manager, as a command-line tool to manage your package installations. As stated on its website, Anaconda's goal is to provide enterprise-ready Python distribution for large-scale processing, predictive analytics, and scientific computing.</p><p class="calibre8">As a second <a id="id33" class="calibre1"/>suggestion, if you are working on Windows, WinPython (<a class="calibre1" href="http://winpython.sourceforge.net">http://winpython.sourceforge.net</a>) could be a quite interesting alternative (sorry, no Linux or MacOS versions). WinPython is also a free, open source Python distribution maintained by the community. It is designed with scientists in mind, and it includes many essential packages such as NumPy, SciPy, Matplotlib, and IPython (the same as Anaconda's). It also includes Spyder as an IDE, which can be helpful if you have experience using the MATLAB language and interface. A crucial advantage is that it is portable (you can put it into any directory, or even on a USB flash drive, without the need for any administrative elevation). Using WinPython, you can have different versions present on your computer, move a version from a Windows computer to another, and you can easily replace an older version with a newer one just by replacing its directory. When you run WinPython or its shell, it will automatically set all the environment variables necessary for running Python as it were regularly installed and registered on your system.</p><p class="calibre8">Finally, another <a id="id34" class="calibre1"/>good choice for a distribution that works on Windows could be Python(x,y). Python(x,y) (<a class="calibre1" href="http://python-xy.github.io">http://python-xy.github.io</a>) is a free, open source Python distribution maintained by the scientific community. It includes a number of packages, such as NumPy, SciPy, NetworkX, IPython, and Scikit-learn. It also features Spyder, the interactive development environment inspired by the MATLAB IDE.</p></div></div>

<div class="book" title="Python for data science">
<div class="book" title="Introducing Jupyter or IPython"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch01lvl2sec17" class="calibre1"/>Introducing Jupyter or IPython</h2></div></div></div><p class="calibre8"><span class="strong"><strong class="calibre2">IPython</strong></span> was<a id="id35" class="calibre1"/> initiated in 2001 as a free project by Fernando Perez. It addressed a<a id="id36" class="calibre1"/> lack in the Python stack for scientific investigations. The author felt that Python lacked a user programming interface that could incorporate the scientific approach (mainly meaning experimenting and interactively discovering) in the process of software development.</p><p class="calibre8">A scientific approach implies fast experimentation with different hypotheses in a reproducible fashion (as do data exploration and analysis tasks in data science), and when using IPython you will be able to more naturally implement an explorative, iterative, trial-and-error research strategy in your code writing.</p><p class="calibre8">Recently, a large<a id="id37" class="calibre1"/> part of the IPython project has been moved to a new<a id="id38" class="calibre1"/> one<a id="id39" class="calibre1"/> called <span class="strong"><strong class="calibre2">Jupyter</strong></span> (<a class="calibre1" href="http://jupyter.org">http://jupyter.org</a>):</p><div class="mediaobject"><img src="../images/00003.jpeg" alt="Introducing Jupyter or IPython" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">This new project extends the potential usability of the original IPython interface to a wide range of<a id="id40" class="calibre1"/> programming <a id="id41" class="calibre1"/>languages <a id="id42" class="calibre1"/>such as the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">R (<a class="calibre1" href="https://github.com/IRkernel/IRkernel">https://github.com/IRkernel/IRkernel</a>)</li><li class="listitem">Julia (<a class="calibre1" href="https://github.com/JuliaLang/IJulia.jl">https://github.com/JuliaLang/IJulia.jl</a>)</li><li class="listitem">Scala (<a class="calibre1" href="https://github.com/mattpap/IScala">https://github.com/mattpap/IScala</a>)</li></ul></div><p class="calibre8">For a complete list of <a id="id43" class="calibre1"/>available kernels, please visit: <a class="calibre1" href="https://github.com/ipython/ipython/wiki/IPython-kernels-for-other-languages">https://github.com/ipython/ipython/wiki/IPython-kernels-for-other-languages</a>.</p><p class="calibre8">You can use the same IPython-like interface and interactive programming style no matter what language you are developing in, thanks to the powerful idea of kernels, which are programs that run the user's code, as communicated by the frontend interface; they then provide feedback on the results of the executed code to the interface itself.</p><p class="calibre8">IPython (Python is the zero kernel, the original starting point) can be simply described as a tool for interactive tasks operable by a console or by a web-based notebook, which offers special commands that help developers to better understand and build the code currently being written.</p><p class="calibre8">Contrary to an IDE interface, which is built around the idea of writing a script, running it afterwards, and finally evaluating its results, IPython lets you write your code in chunks, run each of them sequentially, and evaluate the results of each one separately, examining both textual and graphic outputs. Besides graphical integration, it provides further help, thanks to customizable commands, a rich history (in the JSON format), and computational parallelism for enhanced performance when dealing with heavy numeric computations.</p><p class="calibre8">In IPython, you <a id="id44" class="calibre1"/>can easily combine code, comments, formulas, charts and interactive <a id="id45" class="calibre1"/>plots, and rich media such as images and videos, making it a complete scientific sketchpad for all your experimentations and their results together. Moreover, IPython allows reproducible research, allowing any data analysis and model building to be recreated easily under different circumstances:</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Introducing Jupyter or IPython" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">IPython works on your favorite browser (which could be Explorer, Firefox, or Chrome, for instance) and when started presents a cell waiting for code to written in. Each block of code enclosed in a cell can be run and its results are reported in the space just after the cell. Plots can be represented in the notebook (inline plot) or in a separate window. In our example, we decided to plot our chart inline.</p><p class="calibre8">Notes can be written easily <a id="id46" class="calibre1"/>using the Markdown language, a very easy and accessible markup language (<a class="calibre1" href="http://daringfireball.net/projects/markdown">http://daringfireball.net/projects/markdown</a>).</p><p class="calibre8">Such an approach is also particularly fruitful for tasks involving developing code based on data, since it automatically accomplishes the often-neglected duty of documenting and illustrating how data analysis has been done, as well as its premises, assumptions, and intermediate/final results. If part of your job is also to present your work and attract internal or external stakeholders to the project, IPython can really perform the magic of storytelling for you with little additional effort. On the web page <a class="calibre1" href="https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks">https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks</a>, there are many examples, some of which you may find inspiring for your work as we did.</p><p class="calibre8">Actually, we have to confess that keeping a clean, up-to-date IPython Notebook has saved us uncountable times when meetings with managers/stakeholders have suddenly popped up, requiring us to hastily present the state of our work.</p><p class="calibre8">As an additional <a id="id47" class="calibre1"/>resource, IPython offers you a complete library of many magic <a id="id48" class="calibre1"/>commands that allow you to execute some useful actions such as measuring the time it takes for a command to execute, or creating a text file with the output of a cell. We distinguish between line magic and cell magic, depending on whether they operate a single line of code or the code contained in an entire cell. For instance, the magic command <code class="email">%timeit</code> measures the time it takes to execute the command on the same line of the line magic, whereas <code class="email">%%time</code> is a cell magic that measures the execution time of an entire cell.</p><p class="calibre8">If you want to explore more about magic commands, just type <code class="email">%quickref</code> into an IPython cell and run it: a complete guide will appear to illustrate all available commands.</p><p class="calibre8">In short, IPython lets you:</p><div class="book"><ul class="itemizedlist"><li class="listitem">See intermediate (debugging) results for each step of the analysis</li><li class="listitem">Run only some sections (or cells) of the code</li><li class="listitem">Store intermediate results in JSON format and have the ability to version-control them</li><li class="listitem">Present your work (this will be a combination of text, code, and images), share it via<a id="id49" class="calibre1"/> the IPython Notebook Viewer service (<a class="calibre1" href="http://nbviewer.ipython.org/">http://nbviewer.ipython.org/</a>), and easily export it into HTML, PDF, or even slide shows</li></ul></div><p class="calibre8">IPython is our favored choice throughout this book, and it is used to clearly and effectively illustrate operations with scripts and data and their consequent results.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">For a complete treatise on the full range of IPython functionalities, please refer to the two Packt Publishing books <span class="strong"><em class="calibre9">IPython Interactive Computing and Visualization Cookbook</em></span>, <span class="strong"><em class="calibre9">Cyrille Rossant</em></span>, <span class="strong"><em class="calibre9">Packt Publishing</em></span>, September 25 2014, and <span class="strong"><em class="calibre9">Learning IPython for Interactive Computing and Data Visualization</em></span>, <span class="strong"><em class="calibre9">Cyrille Rossant</em></span>, <span class="strong"><em class="calibre9">Packt Publishing</em></span>, April 25 2013.</p></div><p class="calibre8">For our illustrative purposes, just consider that every IPython block of instructions has a numbered input statement and an output one, so you will find the code presented in this book structured in two blocks, at least when the output is not at all trivial; otherwise just expect only the input part:</p><div class="informalexample"><pre class="programlisting">In:  &lt;the code you have to enter&gt;
Out: &lt;the output you should get&gt;</pre></div><p class="calibre8">Please notice that we do not number the inputs or the outputs.</p><p class="calibre8">Though we <a id="id50" class="calibre1"/>strongly recommend using IPython, if you are using a REPL approach <a id="id51" class="calibre1"/>or an IDE interface, you can use the same instructions and expect identical results (but for print formats and extensions of the returned results).</p></div></div>

<div class="book" title="Python packages and functions for linear models" id="F8901-a2faae6898414df7b4ff4c9a487a20c6"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Python packages and functions for linear models</h1></div></div></div><p class="calibre8">Linear models <a id="id52" class="calibre1"/>diffuse in many different scientific and<a id="id53" class="calibre1"/> business applications and can be found, under different functions, in quite a number of different Python packages. We have selected a few for use in this book. Among them, Statsmodels is our choice for illustrating the statistical properties of models, and Scikit-learn is instead the package we recommend for easily and seamlessly preparing data, building models, and deploying them. We will present models built with Statsmodels exclusively to illustrate the statistical properties of the linear models, resorting to Scikit-learn to demonstrate how to approach modeling from a data science point of view.</p></div>

<div class="book" title="Python packages and functions for linear models" id="F8901-a2faae6898414df7b4ff4c9a487a20c6">
<div class="book" title="NumPy"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec18" class="calibre1"/>NumPy</h2></div></div></div><p class="calibre8">NumPy, which<a id="id54" class="calibre1"/> is Travis Oliphant's creation, is at the core of every analytical <a id="id55" class="calibre1"/>solution in the Python language. It provides the user with multidimensional arrays, along with a large set of functions to operate multiple mathematical operations on these arrays. Arrays are blocks of data arranged along multiple dimensions and that implement mathematical vectors and matrices. Arrays are useful not just for storing data, but also for fast matrix operations (vectorization), which are indispensable when you wish to solve ad hoc data science problems.</p><p class="calibre8">In the book, we are primarily going to use the module <code class="email">linalg</code> from NumPy; being a collection of linear algebra functions, it will provide help in explaining the nuts and bolts of the<a id="id56" class="calibre1"/> algorithm:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Website: <a class="calibre1" href="http://www.numpy.org/">http://www.numpy.org/</a></li><li class="listitem">Import conventions: <code class="email">import numpy as np</code></li><li class="listitem">Version at the time of print: <code class="email">1.9.2</code></li><li class="listitem">Suggested install command: <code class="email">pip install numpy</code></li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">As a convention largely adopted by the Python community, when importing NumPy, it is suggested that you alias it as <code class="email">np</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">import numpy as np</strong></span>
</pre></div><p class="calibre8">There are<a id="id57" class="calibre1"/> importing conventions also for other<a id="id58" class="calibre1"/> Python features that we will be using in the code presented in this book.</p></div></div></div>

<div class="book" title="Python packages and functions for linear models" id="F8901-a2faae6898414df7b4ff4c9a487a20c6">
<div class="book" title="SciPy"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec19" class="calibre1"/>SciPy</h2></div></div></div><p class="calibre8">An original<a id="id59" class="calibre1"/> project by Travis Oliphant, Pearu Peterson, and Eric Jones, SciPy<a id="id60" class="calibre1"/> completes NumPy's functionalities, offering a larger variety of scientific algorithms for linear algebra, sparse matrices, signal and image processing, optimization, fast Fourier transformation, and much more.</p><p class="calibre8">The <code class="email">scipy.optimize</code> package provides several commonly used optimization algorithms, used to detail how a linear model can be estimated using different optimization<a id="id61" class="calibre1"/> approaches:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Website: <a class="calibre1" href="http://www.scipy.org/">http://www.scipy.org/</a></li><li class="listitem">Import conventions: <code class="email">import scipy as sp</code></li><li class="listitem">Version at time of print: <code class="email">0.16.0</code></li><li class="listitem">Suggested install command: <code class="email">pip install scipy</code></li></ul></div></div></div>

<div class="book" title="Python packages and functions for linear models" id="F8901-a2faae6898414df7b4ff4c9a487a20c6">
<div class="book" title="Statsmodels"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec20" class="calibre1"/>Statsmodels</h2></div></div></div><p class="calibre8">Previously<a id="id62" class="calibre1"/> part of Scikit, Statsmodels has been thought to be a <a id="id63" class="calibre1"/>complement to SciPy statistical functions. It features generalized linear models, discrete choice models, time series analysis, and a series of descriptive statistics as well as parametric and nonparametric tests.</p><p class="calibre8">In Statsmodels, we will use the <code class="email">statsmodels.api</code> and <code class="email">statsmodels.formula.api</code> modules, which provide functions for fitting linear models by providing both input matrices and <a id="id64" class="calibre1"/>formula's specifications:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Website: <a class="calibre1" href="http://http:/statsmodels.sourceforge.net/">http:/statsmodels.sourceforge.net/</a></li><li class="listitem">Import conventions: <code class="email">import statsmodels.api as sm</code> and <code class="email">import statsmodels.formula.api as smf</code></li><li class="listitem">Version at the time of print: <code class="email">0.6.1</code></li><li class="listitem">Suggested install command: <code class="email">pip install statsmodels</code></li></ul></div></div></div>

<div class="book" title="Python packages and functions for linear models" id="F8901-a2faae6898414df7b4ff4c9a487a20c6">
<div class="book" title="Scikit-learn"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec21" class="calibre1"/>Scikit-learn</h2></div></div></div><p class="calibre8">Started as part of <a id="id65" class="calibre1"/>the <span class="strong"><strong class="calibre2">SciPy Toolkits</strong></span> (<span class="strong"><strong class="calibre2">SciKits</strong></span>), Scikit-learn is the core of data science operations on Python. It offers all that you may need in terms of data preprocessing, supervised and unsupervised learning, model selection, validation, and error metrics. Expect us to talk at length about this package throughout the book.</p><p class="calibre8">Scikit-learn <a id="id66" class="calibre1"/>started in 2007 as a Google Summer of Code project by <a id="id67" class="calibre1"/>David Cournapeau. Since 2013, it has been taken over by the researchers at INRA (French Institute for Research in Computer Science and Automation).</p><p class="calibre8">Scikit-learn offers modules for data processing (<code class="email">sklearn.preprocessing</code>, <code class="email">sklearn.feature_extraction</code>), model selection, and validation (<code class="email">sklearn.cross_validation</code>, <code class="email">sklearn.grid_search</code>, and <code class="email">sklearn.metrics</code>) and a complete set of methods (<code class="email">sklearn.linear_model</code>) in which the target value, being both a number or a <a id="id68" class="calibre1"/>probability, is expected to be a linear combination of the input variables:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Website: <a class="calibre1" href="http://scikit-learn.org/stable/">http://scikit-learn.org/stable/</a></li><li class="listitem">Import conventions: None; modules are usually imported separately</li><li class="listitem">Version at the time of print: <code class="email">0.16.1</code></li><li class="listitem">Suggested install command: <code class="email">pip install scikit-learn</code></li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre8">Note that the imported module is named <code class="email">sklearn</code>.</p></div></div></div>
<div class="book" title="Summary" id="G6PI1-a2faae6898414df7b4ff4c9a487a20c6"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we glanced at the usefulness of linear models under the data science perspective and we introduced some basic concepts of the data science approach that will be explained in more detail later and will be applied to linear models. We have also provided detailed instructions on how to set up the Python environment; these will be used throughout the book to present examples and provide useful code snippets for the fast development of machine learning hypotheses.</p><p class="calibre8">In the next chapter, we will begin presenting linear regression from its statistical foundations. Starting from the idea of correlation, we will build up the simple linear regression (using just one predictor) and provide the algorithm's formulations.</p></div></body></html>