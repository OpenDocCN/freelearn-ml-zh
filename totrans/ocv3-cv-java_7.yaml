- en: Chapter 7. OpenCV on the Server Side
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：服务器端的 OpenCV
- en: As the Internet gets more and more interactive, a subject of great interest
    is how to deal with image processing on the server side that enables you to create
    web applications dealing with OpenCV. As Java is among the languages of choice
    when developing web apps, this chapter shows the entire architecture of an application
    that lets users upload an image and add a fedora hat on top of detected faces
    using techniques learned throughout the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网越来越互动，一个令人感兴趣的主题是如何处理服务器端的图像处理，以便你可以创建处理 OpenCV 的 Web 应用程序。由于 Java 是开发
    Web 应用程序时选择的语言之一，本章展示了整个应用程序的架构，允许用户上传图像，并在检测到的面部上方添加一顶 fedora 帽子，使用的是本书中学到的技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up an OpenCV web application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 OpenCV Web 应用程序
- en: Mixed reality
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合现实
- en: Image uploading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像上传
- en: Dealing with HTTP requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求
- en: By the end of this chapter you will know how to create a complete web application
    with image processing, obtain input from the user, process the image on the server
    side, and return the processed image to the user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何创建一个完整的带有图像处理的 Web 应用程序，从用户那里获取输入，在服务器端处理图像，并将处理后的图像返回给用户。
- en: Setting up an OpenCV web application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 OpenCV Web 应用程序
- en: Since this chapter covers the development of a web application using Java OpenCV,
    it is important to address a couple of differences when going to the server side.
    The first thing is to tell the web container, generally Tomcat, Jetty, JBoss,
    or Websphere, about the location of native libraries. Other details deal with
    loading the native code. This should happen as soon as the web server goes up
    and should not occur again.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涵盖了使用 Java OpenCV 开发 Web 应用程序的开发，因此在转向服务器端时，解决一些差异是很重要的。首先，需要告诉 Web 容器（通常是
    Tomcat、Jetty、JBoss 或 Websphere）关于本地库的位置。其他细节涉及加载本地代码。这应该在 Web 服务器启动时立即发生，并且不应再次发生。
- en: The advantages of using the web architecture are significant. As certain image-processing
    tasks are compute intensive, they could easily drain the device's battery in no
    time, so, taking them to a more robust hardware on the cloud would relieve local
    processing. Besides that, there's no need for users to install anything more than
    the web browser, and the updates happening on the server side are also very handy.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Web 架构的优势是显著的。由于某些图像处理任务计算密集，它们可能会在短时间内迅速耗尽设备的电池，因此，将它们转移到云上的更强大的硬件上可以减轻本地处理。此外，用户无需安装除网络浏览器之外的其他任何东西，服务器端发生的更新也非常方便。
- en: On the other hand, there are a few drawbacks. If, instead of hosting the web
    application on the administrator infrastructure, one intends to host it on Java
    servers online, it should be clear whether it allows native code to be run or
    not. At the time of writing, Google's App Engine does not allow it, but it is
    easy to set up a Linux server on Amazon EC2 or Google's Compute Engine that smoothly
    runs it although this won't be covered in this book. Another thing to be considered
    is that several computer vision applications need to be run in real time, even
    at the rate of 20 frames per second, for instance, which would be impractical
    in a web architecture, due to long upload times, and this type of application
    should be run locally.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，也有一些缺点。如果，不是在管理员基础设施上托管 Web 应用程序，而是打算在在线 Java 服务器上托管它，那么应该清楚它是否允许运行本地代码。在撰写本文时，Google
    的 App Engine 不允许这样做，但很容易在 Amazon EC2 或 Google 的 Compute Engine 上设置一个 Linux 服务器，使其顺利运行，尽管这不会在本书中涵盖。另一件需要考虑的事情是，一些计算机视觉应用程序需要实时运行，例如，以每秒
    20 帧的速度，这在 Web 架构中是不切实际的，因为上传时间过长，这类应用程序应该本地运行。
- en: 'In order to create our web application, we will go through the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的 Web 应用程序，我们将按照以下步骤进行：
- en: Creating a Maven-based web application.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于 Maven 的 Web 应用程序。
- en: Adding OpenCV dependencies.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 OpenCV 依赖项。
- en: Running the web application.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Web 应用程序。
- en: Importing the project to Eclipse.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目导入 Eclipse。
- en: In the following sections, we will cover these steps in detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将详细说明这些步骤。
- en: Creating a Maven-based web application
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基于 Maven 的 Web 应用程序
- en: There are several ways to create web applications in Java. Spring MVC, Apache
    Wicket, and Play Framework are all great options among others. Also, on top of
    these frameworks, we can put JavaServer Faces, PrimeFaces, or RichFaces as component-based
    user interfaces for these web applications. For this chapter though, instead of
    addressing all these technologies, the approach will be to only use servlets for
    you to choose your frameworks. You should notice that a servlet is simply a Java
    class used to extend the capabilities of a server, and this is generally used
    to process or store data that was submitted through an HTML form. The servlet
    API has been around since 1997, so it has been exhaustively used, and there are
    several books and samples about it. Although this chapter focuses on Servlet 2.x
    for simplicity, we need to be aware that the API is synchronous and that it might
    be better to use an asynchronous one, such as Servlet 3.x, for applications that
    will receive several clients together.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中创建 Web 应用程序有几种方法。Spring MVC、Apache Wicket 和 Play Framework 等都是不错的选择。此外，在这些框架之上，我们可以使用
    JavaServer Faces、PrimeFaces 或 RichFaces 作为基于组件的用户界面为这些 Web 应用程序。然而，对于本章，我们不会涉及所有这些技术，而是只使用
    servlets 来供你选择框架。你应该注意到，servlet 简单来说是一个用于扩展服务器功能的 Java 类，这通常用于处理或存储通过 HTML 表单提交的数据。servlet
    API 自 1997 年以来一直存在，因此已被广泛使用，关于它的书籍和示例有很多。尽管本章专注于 Servlet 2.x 以保持简单，但我们仍需意识到 API
    是同步的，并且对于将接收多个客户端的应用程序，可能更好的选择是使用异步的 Servlet 3.x。
- en: 'Although any IDE can easily generate a web application through a wizard—such
    as going to Eclipse and navigating to **File** | **New** | **Project…** | **Web**
    | **Dynamic Web Project**—we''ll focus on starting it with the help of Maven since
    we can easily get native dependencies. As long as it has been installed correctly
    according to instructions in [Chapter 1](ch01.html "Chapter 1. Setting Up OpenCV
    for Java"), *Setting Up OpenCV for Java*, Maven can set up a web application through
    the use of a prototype. This is achieved through the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管任何 IDE 都可以通过向导轻松生成 Web 应用程序——例如，在 Eclipse 中导航到 **文件** | **新建** | **项目…** |
    **Web** | **动态 Web项目**——但我们将专注于使用 Maven 来启动它，因为我们可以轻松获取原生依赖项。只要它根据 [第 1 章](ch01.html
    "第 1 章。为 Java 设置 OpenCV") 中的说明正确安装，Maven 就可以通过使用原型来设置 Web 应用程序。这是通过以下命令实现的：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will call the `generate` goal from the `archetype` plugin. Think
    of `archetype` as a project template. This Maven plugin will generate a web application
    from a template because we have set `archetypeArtifactId` as `maven-archetype-webapp`
    through the `-DarchetypeArtifactId=maven-archetype-webapp` option. The other option,
    `DartifactId=my-webapp`, will simply set the folder name of the web application
    as defined in this option, while `groupId` is Maven's universally unique identifier
    for a project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从 `archetype` 插件调用 `generate` 目标。将 `archetype` 视为一个项目模板。这个 Maven 插件将根据我们通过
    `-DarchetypeArtifactId=maven-archetype-webapp` 选项设置的 `archetypeArtifactId` 为 `maven-archetype-webapp`
    从模板生成一个 Web 应用程序。另一个选项 `DartifactId=my-webapp` 将简单地设置 Web 应用程序的文件夹名称，如该选项中定义的那样，而
    `groupId` 是 Maven 为项目提供的通用唯一标识符。
- en: 'Note that the following structure will be created:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下结构将被创建：
- en: '![Creating a Maven-based web application](img/3972OS_07_06.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建基于 Maven 的 Web 应用程序](img/3972OS_07_06.jpg)'
- en: 'The preceding is a simple structure for a web application. You should pay attention
    to the `web.xml` file, which is used for mapping servlets, as well as `index.jsp`,
    which is a simple Java Server Page file. By now you should be able to run this
    web application in Tomcat, for instance, with little effort. Simply type the following
    command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面是一个 Web 应用的简单结构。你应该注意 `web.xml` 文件，它用于映射 servlets，以及 `index.jsp`，这是一个简单的 Java
    服务器页面文件。到目前为止，你应该能够轻松地在 Tomcat 等服务器上运行这个 Web 应用程序。只需输入以下命令：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if the you access the address `http://localhost:8080/my-webapp/`, the
    following response should be seen in the browser:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你访问地址 `http://localhost:8080/my-webapp/`，浏览器中应该看到以下响应：
- en: '![Creating a Maven-based web application](img/3972OS_07_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![创建基于 Maven 的 Web 应用程序](img/3972OS_07_01.jpg)'
- en: Notice that it means that we have successfully created a web project, we are
    running it through a Tomcat web container, and it is available through `localhost`
    server, in port `8080`, through the name `my-webapp`. The `Hello World!` message
    can be seen in `index.jsp`. In the following section, you are going to customize
    the `pom` file in order to add OpenCV dependencies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这意味着我们已经成功创建了一个Web项目，我们正在通过Tomcat Web容器运行它，并且它可以通过 `localhost` 服务器，在端口 `8080`，通过名称
    `my-webapp` 访问。您可以在 `index.jsp` 中看到 `Hello World!` 消息。在下一节中，您将自定义 `pom` 文件以添加OpenCV依赖项。
- en: Adding OpenCV dependencies
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加OpenCV依赖项
- en: 'Since the web application archetype has created a project structure for us,
    we are going to add OpenCV dependencies for the generated `pom.xml`. If you open
    it, you will see the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Web应用程序存档已经为我们创建了一个项目结构，我们将为生成的 `pom.xml` 添加OpenCV依赖项。如果您打开它，您将看到以下代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that the only dependency is on `junit`. Now add the following to the
    dependencies tag:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，唯一的依赖项是 `junit`。现在将以下内容添加到依赖项标签中：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first two dependencies, `opencvjar` and `opencvjar-runtime`, are the same
    ones that have been discussed in [Chapter 1](ch01.html "Chapter 1. Setting Up
    OpenCV for Java"), *Setting Up OpenCV for Java*. Now, the dependency on `javax.servlet-api`
    refers to the servlet API version 3.0.1, which is used to make files upload more
    easily. Besides using these dependencies, all other configurations are mentioned
    in [Chapter 1](ch01.html "Chapter 1. Setting Up OpenCV for Java"), *Setting Up
    OpenCV for Java*, such as adding the `JavaOpenCVBook` repository, `maven-jar-plugin`,
    `maven-dependency-plugin`, and `maven-nativedependencies-plugin`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个依赖项，`opencvjar` 和 `opencvjar-runtime`，与在[第1章](ch01.html "第1章. 为Java设置OpenCV")中讨论的相同，即*为Java设置OpenCV*。现在，对
    `javax.servlet-api` 的依赖指的是3.0.1版本的servlet API，它用于使文件上传更加容易。除了使用这些依赖项之外，所有其他配置都在[第1章](ch01.html
    "第1章. 为Java设置OpenCV")中提到，*为Java设置OpenCV*，例如添加 `JavaOpenCVBook` 仓库、`maven-jar-plugin`、`maven-dependency-plugin`
    和 `maven-nativedependencies-plugin`。
- en: 'The only new plugin is `tomcat7` as we would require it to use the file upload
    API from `servlet 3.0`. In order to add the `tomcat7` plugin, look for the `<plugins>`
    section in `pom.xml` and add the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新插件是 `tomcat7`，因为我们需要使用来自 `servlet 3.0` 的文件上传API。为了添加 `tomcat7` 插件，在 `pom.xml`
    中查找 `<plugins>` 部分，并添加以下代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Besides adding the ability to run `tomcat7` from Maven, it will also configure
    port `9090` as the default port for our server, but you can use another one. The
    final `pom.xml` file can be found in this chapter's source code project. Running
    an `mvn package` command will show that everything's been fine in the project
    setup. In the next section, we are going to check all the processes through a
    simple OpenCV call from the .`jsp` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够从Maven运行 `tomcat7` 之外，它还将配置端口 `9090` 作为我们服务器的默认端口，但您可以使用另一个端口。最终的 `pom.xml`
    文件可以在本章的源代码项目中找到。运行 `mvn package` 命令将显示项目设置一切正常。在下一节中，我们将通过从 `.jsp` 文件中的简单OpenCV调用检查所有过程。
- en: Running the web application
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Web应用程序
- en: 'Now that all the dependencies have been set up, it should be straightforward
    to run our web application. One detail should be noticed, though. Since our application
    relies on native code, the `opencv_java300.dll` file, or the shared object, we
    should put it in the Java library path prior to running the Tomcat server. There
    are several approaches to doing this, depending on your deployment strategy, but
    a simple one could be setting the path through the `MAVEN_OPTS` environment variable.
    You should type the following command in the terminal:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有依赖项都已设置，运行我们的Web应用程序应该很简单。但有一个细节需要注意。由于我们的应用程序依赖于本地代码，即 `opencv_java300.dll`
    文件或共享对象，我们应该在运行Tomcat服务器之前将其放在Java库路径中。根据您的部署策略，有几种方法可以做到这一点，但一种简单的方法是通过 `MAVEN_OPTS`
    环境变量设置路径。您应该在终端中输入以下命令：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Please remember to change `your_path` to the place you are setting up your
    project, the parent folder of `my-webapp`. In order to check that the application
    server can correctly load OpenCV native libraries, we are going to set up a simple
    servlet which is able to output the correct installed version. Change the `index.jsp`
    file generated in your `my-webapp\src\main\webapp` folder to the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住将 `your_path` 更改为您设置项目的地方，即 `my-webapp` 的父文件夹。为了检查应用程序服务器是否可以正确加载OpenCV本地库，我们将设置一个简单的servlet，该servlet能够输出正确的已安装版本。将您在
    `my-webapp\src\main\webapp` 文件夹中生成的 `index.jsp` 文件更改为以下代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, run your server typing `mvn tomcat7:run`. Try loading your application
    in your web browser at the address `http://localhost:9090`, and you should see
    the page outputting your loaded OpenCV version. Although this code doesn't really
    load native libraries, since `Core.VERSION` can be retrieved from pure Java JAR,
    it's not a good practice to mix business code—the one that really does your image
    processing—with your presentation code, that is, the Java Server Page we just
    edited. In order to deal with image processing, we are going to concentrate the
    code in a servlet that only deals with it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过输入 `mvn tomcat7:run` 运行您的服务器。尝试在您的网页浏览器中加载您的应用程序，地址为 `http://localhost:9090`，您应该会看到输出您加载的
    OpenCV 版本的页面。尽管这段代码实际上并没有加载本地库，因为 `Core.VERSION` 可以从纯 Java JAR 中检索，但将业务代码（真正进行图像处理的代码）与表示代码（我们刚刚编辑的
    Java 服务器页面）混合在一起并不是一个好的做法。为了处理图像处理，我们将集中代码在一个只处理它的 servlet 中。
- en: Importing the project to Eclipse
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将项目导入到 Eclipse
- en: 'Now that the project is all set up with Maven, it should be easy to import
    it to Eclipse. Simply issue the following Maven command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经使用 Maven 设置好了，将其导入到 Eclipse 应该很容易。只需发出以下 Maven 命令：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember to add the `-Dwtpversion=2.0` flag to add support for WTP version
    2.0, which is Eclipse''s Web Tools platform. If you have not set up your `M2_REPO`
    as explained in [Chapter 1](ch01.html "Chapter 1. Setting Up OpenCV for Java"),
    *Setting Up OpenCV for Java*, a simple trick can automate it for you. Type the
    following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记得添加 `-Dwtpversion=2.0` 标志以支持 WTP 版本 2.0，这是 Eclipse 的 Web 工具平台。如果您没有按照 [第 1
    章](ch01.html "第 1 章。设置 OpenCV for Java") 中所述设置 `M2_REPO`，有一个简单的技巧可以自动完成它。输入以下命令：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `YOUR_WORKSPACE_PATH` path should be changed to something similar to `C:\Users\baggio\workspace`
    if that is where your Eclipse workspace is located.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Eclipse 工作区位于 `C:\Users\baggio\workspace`，则应将 `YOUR_WORKSPACE_PATH` 路径更改为类似
    `C:\Users\baggio\workspace` 的路径。
- en: 'In Eclipse, navigate through **File** | **Import** | **General** | **Existing
    Projects** into the workspace and point to your `my-webapp` folder. Notice that
    your Eclipse should have WTP support. In case you receive a `Java compiler level
    does not match the version of the installed Java project facet` message, simply
    right-click it and in the **Quick Fix** menu, choose **Change Java Project Facet
    version to Java 1.8**. Now you can run it by right-clicking in your project, navigating
    to **Run as** | **Run on Server**, selecting **Apache** | **Tomcat v7.0 Server**,
    and hitting **Next**. If you don''t have an existing Tomcat 7 installation, select
    **Download and Install**, as shown in the next screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse 中，通过 **File** | **Import** | **General** | **Existing Projects** 导航到工作区，并指向您的
    `my-webapp` 文件夹。请注意，您的 Eclipse 应该有 WTP 支持。如果您收到 "Java compiler level does not
    match the version of the installed Java project facet" 信息，只需右键单击它，然后在 **Quick
    Fix** 菜单中选择 **Change Java Project Facet version to Java 1.8**。现在您可以通过右键单击项目，导航到
    **Run as** | **Run on Server**，选择 **Apache** | **Tomcat v7.0 Server**，然后点击 **Next**
    来运行它。如果您没有现有的 Tomcat 7 安装，请选择 **Download and Install**，如下一张截图所示：
- en: '![Importing the project to Eclipse](img/3972OS_07_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![将项目导入到 Eclipse](img/3972OS_07_02.jpg)'
- en: 'Select a folder for your Tomcat7 installation and click on **Next** and **Finish**.
    Now, you can run your application directly from Eclipse, by right-clicking on
    your project and clicking on **Run as** | **Run on Server**. In case you receive
    a "java.lang.UnsatisfiedLinkError: no opencv_java300 in java.library.path", right-click
    your project, "Run As ->Run Configurations..." and in the Arguments tab, in the
    VM arguments text box, add the -Djava.library.path="C:\path_to_your\target\natives".
    Click in "Apply" and restart your server by going to the Server tab and right-clicking
    your Tomcat7 execution -> Restart.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '选择一个文件夹用于您的 Tomcat7 安装，然后点击 **Next** 和 **Finish**。现在，您可以直接从 Eclipse 运行您的应用程序，通过在您的项目上右键单击并选择
    **Run as** | **Run on Server**。如果您收到 "java.lang.UnsatisfiedLinkError: no opencv_java300
    in java.library.path" 错误，请右键单击您的项目，选择 "Run As ->Run Configurations..."，然后在 Arguments
    选项卡中，在 VM arguments 文本框中添加 `-Djava.library.path="C:\path_to_your\target\natives"`。点击
    "Apply"，然后通过转到 Server 选项卡并右键单击您的 Tomcat7 执行 -> Restart 来重启您的服务器。'
- en: Mixed reality web applications
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合现实网络应用程序
- en: The web application we are going to develop draws Fedora hats on top of the
    detected heads in a given image. In order to do this, the user uploads the image
    through a simple form, and then it is converted to an OpenCV matrix in memory.
    After conversion, a cascade classifier looking for faces is run over the matrix.
    A simple scale and a translation are applied to estimate the hat's position and
    scale. A transparent fedora image is then drawn on the specified position for
    each of the detected faces. The result is then returned through HTTP by giving
    the mixed reality picture to the user. Notice that all the processing happens
    on the server side, so the client is only left to upload and download the image,
    which is very useful for clients that rely on batteries, such as smartphones.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发的一个网络应用程序将在给定图像中检测到的头部上方绘制费德里亚帽。为了做到这一点，用户通过一个简单的表单上传图片，然后它在内存中转换为OpenCV矩阵。转换后，在矩阵上运行一个寻找脸部的级联分类器。应用简单的缩放和平移来估计帽子的位置和大小。然后在每个检测到的脸部指定位置绘制一个透明的费德里亚帽图像。然后通过将混合现实图片提供给用户，通过HTTP返回结果。请注意，所有处理都在服务器端进行，因此客户端只需上传和下载图片，这对于依赖电池的客户端非常有用，例如智能手机。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Mixed reality (MR), sometimes referred to as hybrid reality (encompassing
    both augmented reality and augmented virtuality), refers to the merging of real
    and virtual worlds to produce new environments and visualisations where physical
    and digital objects co-exist and interact in real time. Not taking place only
    in the physical world or the virtual world, but a mix of reality and virtual reality,
    encompassing augmented reality and augmented virtuality.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*混合现实（MR），有时也称为混合现实（包括增强现实和增强虚拟性），是指现实世界和虚拟世界的融合，产生新的环境和可视化，其中物理对象和数字对象在实时共存和交互。它不仅仅发生在物理世界或虚拟世界中，而是现实和虚拟的混合，包括增强现实和增强虚拟性。*'
- en: '*Source: Fleischmann, Monika; Strauss, Wolfgang (eds.) (2001). Proceedings
    of »CAST01//Living in Mixed Realities« Intl. Conf. On Communication of Art, Science
    and Technology, Fraunhofer IMK 2001, 401\. ISSN 1618–1379 (Print), ISSN 1618–1387
    (Internet).*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源：Fleischmann, Monika; Strauss, Wolfgang (eds.) (2001). "CAST01//Living in
    Mixed Realities" 国际会议关于艺术、科学和技术传播的论文集，弗劳恩霍夫IMK 2001，第401页。ISSN 1618–1379（印刷版），ISSN
    1618–1387（网络版）。*'
- en: 'This web application can be divided into a couple of simpler steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络应用程序可以分解为几个更简单的步骤：
- en: Image upload.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片上传。
- en: Image processing.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片处理。
- en: Response image.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应图片。
- en: The following sections will cover these steps in detail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将详细说明这些步骤。
- en: Image upload
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片上传
- en: 'Firstly, we are going to turn our dummy Java Server Page into a form that will
    require the user to choose a local file, similar to the one seen in the following
    screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把我们的模拟Java服务器页面转换成一个需要用户选择本地文件的表单，类似于以下截图所示：
- en: '![Image upload](img/3972OS_07_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片上传](img/3972OS_07_03.jpg)'
- en: 'The following code shows the complete Java Server Page. Note the form element,
    which states that it will call a `post` method being processed in the `doPost`
    part of the servlet and requests that the web server to accept the data enclosed
    in the form for storage. The `enctype= "multipart/form-data"` states that no characters
    are going to be encoded, as can be seen in the `"text/plain"` encryption type,
    which converts spaces to `+` symbols. Another important attribute is `action="upload"`.
    It makes sure that the data encoded in the form is sent to the "`/upload`" URL.
    The input element with the type "file" simply works as a call to the operating
    system''s file dialog, which pops up and lets the user specify the file location.
    Finally, the input element with the "submit" type deals with sending the request
    with form data when the button is clicked:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了完整的Java服务器页面。注意表单元素，它表明它将在servlet的`doPost`部分调用`post`方法，并要求网络服务器接受表单中包含的数据以进行存储。`enctype=
    "multipart/form-data"`表示不会对字符进行编码，正如在`"text/plain"`加密类型中可以看到的，它将空格转换为`+`符号。另一个重要属性是`action="upload"`。它确保表单中编码的数据被发送到"`/upload`"
    URL。类型为"file"的输入元素简单地作为对操作系统文件对话框的调用，该对话框弹出并允许用户指定文件位置。最后，当按钮被点击时，类型为"submit"的输入元素处理带有表单数据的请求发送：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When pressing the **Submit** button, a stream of bytes is sent to the server,
    which will forward them to a servlet called `Upload`. Note that mapping from the
    `/upload` URL to the `Upload` servlet happens in the `/src/main/webapp/WEB-INF/web.xml`
    file, as shown in the following lines:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**提交**按钮时，一个字节流被发送到服务器，服务器将它们转发到名为`Upload`的servlet。请注意，从`/upload` URL映射到`Upload`
    servlet的操作发生在`/src/main/webapp/WEB-INF/web.xml`文件中，如下所示：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Pay attention to the fact that, when the user hits the **Submit** button from
    the form, the `doPost` method from the mapped servlet class, `UploadServlet`,
    is called. This method is the core of this web application, and we are going to
    see it in detail in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当用户从表单中点击**提交**按钮时，映射的servlet类`UploadServlet`的`doPost`方法被调用。这个方法是这个Web应用的核心，我们将在下面的代码中详细查看它：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The main action in the `doPost` method starts by loading the OpenCV library,
    as seen in the previous chapters, and then loading the cascade which will be used
    later for face detection. For the sake of brevity, the initialization is made
    here, but in actual code, you should use `ServletContextListener` in order to
    initialize it. Then, the `receiveImage` method deals with receiving bytes from
    the upload and converting it to an OpenCV matrix. So, the other methods take care
    of loading the fedora hat image and detecting people''s faces so that the overlay
    can be drawn through the `detectFaceAndDrawHat` method. Finally, the `writeResponse`
    method answers the request. We will cover `receiveImage` in more detail in the
    following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`doPost`方法中的主要操作首先是通过加载OpenCV库开始的，正如前几章所看到的，然后加载稍后用于人脸检测的级联分类器。为了简洁起见，初始化在这里进行，但在实际代码中，你应该使用`ServletContextListener`来初始化它。然后，`receiveImage`方法处理从上传接收字节并将其转换为OpenCV矩阵。因此，其他方法负责加载费多拉帽子的图像并检测人脸，以便可以通过`detectFaceAndDrawHat`方法绘制叠加图像。最后，`writeResponse`方法响应请求。我们将在下面的代码中更详细地介绍`receiveImage`：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that `receiveImage` simply grabs bytes from an upload request in `receiveImageBytes`
    and then converts them to a matrix. The following is the code for `receiveImageBytes`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`receiveImage`只是从上传请求的`receiveImageBytes`中抓取字节，然后将其转换为矩阵。以下是`receiveImageBytes`的代码：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the default code to receive an upload. It accesses the "file" field
    from the form and gets its stream through `request.getPart("file").getInputStream()`.
    Then, a buffer is created, so all data from the input stream is written through
    the `write()` method as long as there''s data from the upload. The byte array
    is then returned through the `ByteArrayOutputStream` class''s `toByteArray()`
    method. Since what we have received at this point is just a bunch of bytes, there
    is a need to decode the image format and convert it to an OpenCV matrix. Fortunately,
    there''s already a method that does that, `imdecode`, from the `Imgcodecs` package,
    the signature of which is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接收上传的默认代码。它从表单的"文件"字段中访问，并通过`request.getPart("file").getInputStream()`获取其流。然后创建一个缓冲区，只要上传中有数据，所有来自输入流的数据都通过`write()`方法写入。然后，通过`ByteArrayOutputStream`类的`toByteArray()`方法返回字节数组。由于此时我们接收到的只是一堆字节，因此需要解码图像格式并将其转换为OpenCV矩阵。幸运的是，已经有一个方法可以做到这一点，即来自`Imgcodecs`包的`imdecode`方法，其签名如下：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `buf` argument is a `Mat` buffer that we will create from the byte array,
    and `flags` is an option used to convert the `Mat` buffer returned to grayscale
    or color, for instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf`参数是一个`Mat`缓冲区，我们将从字节数组中创建它，而`flags`是一个选项，用于将返回的`Mat`缓冲区转换为灰度或彩色，例如。'
- en: 'The complete code for the decoding can be seen in the following lines:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解码的完整代码可以在以下行中看到：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now it's done, we have received the user's image upload, and it is converted
    to our well-known `Mat` class. It's now time to create the mixed reality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了，我们已经接收到了用户的图像上传，并且它已被转换为我们的熟知的`Mat`类。现在是时候创建混合现实了。
- en: Image processing
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像处理
- en: 'In this section, we are going to describe how to process the received image
    in order to draw an image file on top of it. Now, a cascade classifier is run
    just as in the previous chapter. It is important to pay attention to the XML cascade
    file location. Throughout the code, we have used a helper function called `getResourcePath`,
    and we have used the convention of storing all the resources in the `src/main/resources/`
    folder. This way, the helper function works in a manner similar to that of the
    following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述如何处理接收到的图像，以便在其上方绘制图像文件。现在，级联分类器就像在上一章中一样运行。注意XML级联文件的位置很重要。在整个代码中，我们使用了一个名为`getResourcePath`的辅助函数，并且我们使用了将所有资源存储在`src/main/resources/`文件夹中的约定。这样，辅助函数的工作方式类似于以下代码：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using this function, one can load a cascade through the following call:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，可以通过以下调用加载级联：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the cascade has been correctly loaded, we are all set, and now it is
    time to explain how the hat''s position is estimated. When running the face classifier,
    we have a good idea not only of the face''s position, but also of the face''s
    bounding rectangle. We will use this width to estimate the width of the hat. We
    can suppose that the width of the hat would be three times the face''s bounding
    rectangle width. This way, we still need to keep the hat''s aspect ratio. This
    is done with a simple rule of three, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在级联被正确加载后，我们一切准备就绪，现在是时候解释如何估计帽子的位置了。当运行人脸分类器时，我们不仅对脸的位置有很好的了解，而且对脸的边界矩形也有很好的了解。我们将使用这个宽度来估计帽子的宽度。我们可以假设帽子的宽度将是脸的边界矩形宽度的三倍。这样，我们仍然需要保持帽子的宽高比。这是通过一个简单的三比规则来实现的，如下所示：
- en: '![Image processing](img/3972OS_07_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图像处理](img/3972OS_07_07.jpg)'
- en: Now that the virtual hat's dimensions are defined, we still need to estimate
    its location. From a couple of tests, we could infer that 60 percent above the
    face's bounding rectangle should be fine for most of the pictures. Now, we have
    the hat's dimensions and position. In the end, instead of using the hat's width
    as three times the face's width, a value of 2.3 times the face's width seemed
    to work better. The following code shows the math used to set the **region of
    interest** (**ROI**) to draw the fedora as implemented in the method `detectFaceAndDrawHat`.
    A simple adjustment is made to the hat's dimensions when it goes beyond the bounds.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在虚拟帽子的尺寸已经定义，我们仍然需要估计其位置。从一些测试中，我们可以推断出，对于大多数图片来说，在脸的边界矩形上方60%的位置应该是合适的。现在，我们有了帽子的尺寸和位置。最后，我们不再使用帽子的宽度是脸宽度的三倍，而是使用2.3倍脸宽度的值似乎效果更好。以下代码显示了在`detectFaceAndDrawHat`方法中设置**感兴趣区域**（**ROI**）以绘制礼帽所使用的数学方法。当帽子尺寸超出边界时，对其进行简单调整。
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot gives us an overview of the widths and the process
    of drawing the fedora overlay:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图为我们提供了宽度和绘制礼帽叠加过程的概述：
- en: '![Image processing](img/3972OS_07_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图像处理](img/3972OS_07_04.jpg)'
- en: 'It is time to draw the hat! This should be as simple as locating the hat''s
    position in the picture and copying the submatrix. We need to be careful, though,
    to correctly draw transparent pixels and not draw outside the picture. Mat''s
    `copyTo` method is used to copy a submatrix into another one. This method also
    accepts a mask Mat parameter, the nonzero elements of which indicate which matrix
    elements must be copied. Notice that the hat image itself is passed as the mask
    parameter, and it actually works because all transparent pixels are made zero
    in all channels and all other pixels will have some value, working like a mask.
    The code to resize the fedora and copy it to the main image is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候画帽子了！这应该就像在图片中找到帽子的位置并复制子矩阵一样简单。不过，我们需要小心，确保正确地绘制透明像素，不要超出图片范围。Mat的`copyTo`方法用于将子矩阵复制到另一个矩阵中。此方法还接受一个掩码Mat参数，其中非零元素指示必须复制的矩阵元素。请注意，帽子图像本身被作为掩码参数传递，并且它实际上工作得很好，因为所有透明像素在所有通道中都变为零，而所有其他像素都将具有某些值，就像一个掩码一样。调整礼帽大小并将其复制到主图像的代码如下：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The response image
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应图像
- en: 'We have successfully received an image and drawn hats over identified faces.
    Now, it''s time to send the result back to the user. We do this by setting the
    content type of our response as `image/jpeg`, for instance. We then encode our
    response with the same format as defined in our header—if it is jpeg, we will
    encode it in JPEG—and write the bytes in our response servlet object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功接收到了一张图像，并在识别到的面部上绘制了帽子。现在，是时候将结果发送回用户了。我们通过将响应的内容类型设置为`image/jpeg`（例如）来完成这项工作。然后我们使用在头部中定义的相同格式来编码我们的响应——如果它是jpeg，我们将使用JPEG进行编码——并将字节写入我们的响应servlet对象：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The input image and the output result appear in the following screenshot. Some
    fedora hats are distributed to Einstein and his friends in our augmented reality
    web application. The left-hand side photo is the uploaded image, while the right-hand
    side photo shows the hats drawn over the detected faces. According to our loop,
    hats will be drawn in the same order that detected faces are returned. This way,
    we can''t grant a correct Z-order, which is what hat is drawn on top of another
    although we could try to infer it from face size. This is shown in the following
    images:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输入图像和输出结果如下截图所示。在我们的增强现实网络应用程序中，一些费多拉帽被分配给了爱因斯坦和他的朋友们。左侧的照片是上传的图像，而右侧的照片显示了在检测到的面部上绘制的帽子。根据我们的循环，帽子的绘制顺序与检测到的面部的返回顺序相同。这样，我们无法保证正确的Z顺序，即帽子绘制在另一个帽子之上，尽管我们可以尝试从面部大小中推断它。以下图片展示了这一点：
- en: '![The response image](img/3972OS_07_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![响应图像](img/3972OS_07_05.jpg)'
- en: '[http://www.nobelprize.org/nobel_prizes/physics/laureates/1921/einstein-photo.html](http://www.nobelprize.org/nobel_prizes/physics/laureates/1921/einstein-photo.html)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[阿尔伯特·爱因斯坦1921年诺贝尔物理学奖获奖照片](http://www.nobelprize.org/nobel_prizes/physics/laureates/1921/einstein-photo.html)'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we sent our computer vision applications to the server-side
    world. We started covering the basics of a simple servlet-based web application
    configuration using Maven, which provided us with a general application structure.
    We then added OpenCV dependencies to our `pom.xml` configuration file as used
    in a standard OpenCV desktop application. We then checked other runtime configurations
    as we deployed our web server using Maven.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的计算机视觉应用程序发送到了服务器端的世界。我们开始介绍使用Maven配置简单servlet基于的Web应用程序的基础，它为我们提供了一个通用应用程序结构。然后我们将OpenCV依赖项添加到我们的`pom.xml`配置文件中，就像在标准的OpenCV桌面应用程序中使用的那样。然后我们检查了其他运行时配置，因为我们使用Maven部署了我们的Web服务器。
- en: With every webapp configuration aspect solved, we moved on to the development
    of our mixed reality application that explored the details of image uploading,
    converting it to an OpenCV Mat object and then writing a response to our clients
    with a processed image.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了每个Web应用程序配置方面的问题后，我们继续开发我们的混合现实应用程序，该应用程序探讨了图像上传的细节，将其转换为OpenCV Mat对象，然后向客户端发送处理后的图像的响应。
- en: It seems that all aspects of creating basic computer vision applications have
    been covered now. We dealt with setting up OpenCV for Java and then learned how
    to work with matrices. We then touched on the basics of creating Java Swing desktop
    applications and worked with image-processing algorithms to filter, change image
    morphology, and do essential thresholding. You also learned tools that are in
    every computer vision researcher's toolkit, such as Hough transformations to find
    lines and circles as well as special kernel convolution. We covered the important
    Fourier transform and warp operations. We then dived into machine learning and
    used handy OpenCV cascades, and you also learned how to create new object classifiers.
    Besides this, we studied certain background removal approaches and tested the
    incredible Kinect device to perform depth-based processing. We finally finished
    the book with a complete server-side example, and now, you are ready to count
    on Java for your own computer vision projects!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，创建基本计算机视觉应用的各个方面都已经涵盖了。我们处理了为Java设置OpenCV，然后学习了如何处理矩阵。然后我们接触到了创建Java Swing桌面应用程序的基础，并使用图像处理算法进行过滤、改变图像形态和进行基本阈值处理。你还学习了每个计算机视觉研究人员工具箱中的工具，例如霍夫变换来寻找线和圆以及特殊的核卷积。我们还涵盖了重要的傅里叶变换和变换操作。然后我们深入到机器学习，并使用了方便的OpenCV级联，你还学习了如何创建新的对象分类器。除此之外，我们还研究了某些背景移除方法，并测试了令人难以置信的Kinect设备以执行基于深度的处理。最后，我们用完整的服务器端示例完成了这本书，现在，你可以为你的计算机视觉项目信赖Java了！
