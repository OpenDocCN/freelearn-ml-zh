<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Quantum Computing – The Future</h1>
                </header>
            
            <article>
                
<p>We will end this series with the beginning of another topic, <strong>quantum computing</strong>. Quantum computing is the future, it's coming, and it's real. It uses quantum-mechanical phenomena, such as superposition and entanglement, and bases its computations on something called <strong>quantum bits</strong> (<strong>qubits</strong>). Where normal computers are transistor-based and use the ever-famous one and zero, quantum computing uses qubits, which can be in superpositions of a state, not just on or off.</p>
<p>At the time of writing, quantum computing is still in its infancy, but progress is being made. As such, this chapter will be short, but we want to expose you to the future so that you are aware.</p>
<p>In this chapter, we will cover:</p>
<ul>
<li>Superposition</li>
<li>Teleportation</li>
</ul>
<p>Many experiments are being run, and Microsoft has released its quantum computing <strong>Software Development Kit</strong> (<strong>SDK</strong>). Both Microsoft and IBM are developing their own versions of quantum computers. But before we get to that, let's go over a few terms you'll need to know. These will go into your super buzzword-compliant checklist!</p>
<p>Here is a <strong>Bloch sphere</strong>, which is a qubit representation in <strong>Hilbert space</strong>, and it is the most fundamental component of quantum computing:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/60afb700-6c6f-4139-b162-ea478afc2470.png" style=""/></div>
<p>A classical computer has its memory made up of bits—ones and zeros. A quantum computer, however, is comprised of a series of qubits. A single qubit can represent a one, a zero, or any quantum superposition of these two qubit states. A single qubit can be in any one of two states. A pair of qubits can be in any superposition of two states, and three qubits can be in any superposition of eight states. So, quantum computers can be in superpositions of many different states, whereas conventional computers can only be in one of those states at any given moment in time.</p>
<p>A quantum computer operates using quantum gates and quantum logic gates (similar to logic gates for a conventional computer), and the problem it is trying to solve is encoded by setting the initial values of the qubits, just like a conventional computer does. Quantum algorithms are considered mostly probabilistic, in that they provide a correct solution only with a known probability:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ac1d09ff-d2d3-416c-bc7a-145518ef28ab.png" style=""/></div>
<p>Qubits are made up of controlled particles and the means of control (for example, devices that trap particles and switch them from one state to another).<strong><br/></strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Superposition</h1>
                </header>
            
            <article>
                
<p>Wikipedia defines <strong>superposition</strong> as:</p>
<div class="packt_quote">"... a fundamental principle of quantum mechanics. It states that, much like waves in classical physics, any two (or more) quantum states can be added together ("superposed") and the result will be another valid quantum state; and conversely, every quantum state can be represented as a sum of two or more other distinct states. Mathematically, it refers to a property of solutions to the Schrodinger equation; since the Schrodinger equation is linear, any linear combination of solutions will also be a solution."</div>
<p>What that really means is that a quantum system can be in multiple states at the same time when not being observed. They can exist across all possible states simultaneously. Think of a windy day on a pond with lots of waves. No doubt you've seen them overlapping at some point. That is a brutally simplistic explanation of superposition in a nutshell.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teleportation</h1>
                </header>
            
            <article>
                
<p>In quantum computing, <strong>teleportation</strong> refers to the method of moving a quantum state from one location to another without having to move any physical particles. This process is usually accompanied by <strong>entanglement</strong> between the sending and receiving locations. <span>Teleportation of a quantum state uses the phenomenon of quantum entanglement (our next topic) as a means of transmission. When two or more particles are entangled, their quantum states are interdependent, no matter how far apart they are. In effect, they act as a single quantum object.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entanglement</h1>
                </header>
            
            <article>
                
<p>Quantum entanglement is a physical phenomenon that occurs when pairs or groups of particles are generated or interact in ways such that the state of each particle cannot be described independently of the state of the other, even when the particles are separated by a large distance—instead, a quantum state must be described for the system as a whole.</p>
<p>Maybe a more visual example is in order. Let say that you have todays newspaper, and that it's 100 pages in length. If you ready 10 pages, you would know 10% of the content. If you read another 10 pages, you'd now know 20% of the content, and so on. However, if the newspaper was highly entangled, if you read 10 pages you would know almost nothing. Why, because the information is in between those pages, not on them. So you'd have to figure out a way to read all of the pages at once.</p>
<p>Now that we've described those terms, let's show you a quick sample from Microsoft's quantum computing SDK. As we mentioned, quantum computing is in its infancy at the time of writing, so the best we can do is show you where it's heading. We'll do that with a very brief example, and then leave it up to you if you wish to learn more.</p>
<p>So what does a quantum computing program look like? Like this:</p>
<pre>class Program<br/>{<br/>static void Main(string[] args)<br/>{<br/>using (var sim = new QuantumSimulator())<br/>{<br/>var rand = new System.Random();<br/>foreach (var idxRun in Enumerable.Range(0, 8))<br/>{<br/>var sent = rand.Next(2) == 0;<br/>var received = TeleportClassicalMessage.Run(sim, sent).Result;<br/>System.Console.WriteLine($"Round {idxRun}:tSent {sent},tgot<br/>  {received}.");<br/>System.Console.WriteLine(sent == received ? "Teleportation<br/>  successful!!n" : "n");<br/>}<br/>}<br/>System.Console.WriteLine("nnPress Enter to continue...nn");<br/>System.Console.ReadLine();<br/>}<br/>}</pre>
<p class="mce-root">Yep, that's it! Well, sort of. You see, a quantum computing program using the Microsoft quantum SDK is comprised of two parts. The first is the C# component you see here. Actually, it can be C#, Python, and several other languages on the frontend. On the backend, which we will see in a moment, is the quantum side of things, written in Q#; that's Microsoft's new language for quantum computing. Each Q# operation generates a corresponding C# class of the same name, which will have a <kbd>Run</kbd> method. This method is asynchronous because the operation will run asynchronously on the quantum computer.</p>
<p>According to the Microsoft documentation on Q#:</p>
<p class="x-hidden-focus">"Q# (Q-sharp) is a domain-specific programming language used for expressing quantum algorithms. It is to be used for writing sub-programs that execute on an adjunct quantum processor, under the control of a classical host program and computer.</p>
<p class="x-hidden-focus">Q# provides a small set of primitive types, along with two ways (arrays and tuples) for creating new, structured types. It supports a basic procedural model for writing programs, with loops and if/then statements. The top-level constructs in Q# are user defined types, operations, and functions."</p>
<p>So let's talk about what our C# code does. It simply sends a message using teleportation (and now you know why we started with terminology!). Let's take a look at the backend and see what's going on:</p>
<pre>operation Teleport(msg : Qubit, there : Qubit) : ()<br/>{<br/>body<br/>{<br/>using (register = Qubit[1])<br/>{<br/>// Ask for an auxillary qubit that we can use to prepare<br/>// for teleportation.<br/><strong>let here = register[0];</strong><br/>// Create some entanglement that we can use to send our message.\<br/><strong>H(here);</strong><br/><strong>CNOT(here, there);</strong><br/>// Move our message into the entangled pair.<br/><strong>CNOT(msg, here);</strong><br/><strong>H(msg);</strong><br/>// Measure out the entanglement.<br/><strong>if (M(msg) == One) { Z(there); }</strong><br/><strong>if (M(here) == One) { X(there); }</strong><br/>// Reset our "here" qubit before releasing it.<br/><strong>Reset(here);</strong><br/>}<br/>}<br/>}</pre>
<p>And now there are many thoughts running through your head. More questions than answers, right? Fear not; it's a bit more of a technical approach to writing software for sure, but we'll give you a little bit of insight so that it will all make sense.</p>
<p><kbd>H</kbd>, <kbd>CNOT</kbd>, <kbd>M</kbd>, what is going on? These are all Q#-defined functions and will exist in the Q# component file of your project. Let's take a look at one of them and explain what's going on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CNOT</h1>
                </header>
            
            <article>
                
<p>This applies the <kbd>CNOT</kbd> gate (a controlled NOT gate) to a qubit. <span>The CNOT gate is the "quantization" of a classical gate</span>, and <span>can be used to entangle and disentangle</span> EPR states. For those interested in EPR, I would recommend reading up on <span>The </span>Einstein–Podolsky–Rosen paradox (EPR)<span>.</span></p>
<p>A <kbd>CNOT</kbd> gate is a set of rows and columns, similar to this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/20e9ba8b-72f2-465d-8ff5-d0b5bed1c76c.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">H</h1>
                </header>
            
            <article>
                
<p>This function applies the <strong>Hadamard</strong> transformation to a single qubit. It will basically flip the qubit halfway instead of all the way. The Haramard transform is used in data encryption, as well as signal processing algorithms such as JPEG XR and MPEG-4 Audio Video Codec. In video compression it is usually used in order to for the sum of absolute transformed differences. The Hadamard transformation is also used in scientific methods such as mass spectroscopy and crystallography among others.</p>
<p>Currently, the Hadamard function is defined as:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d9cda2d4-9664-4781-a145-b5f5402bd087.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">M</h1>
                </header>
            
            <article>
                
<p>This measures a single qubit in the <strong>Pauli-Z</strong> basis such that the output result is given by the distribution. The <kbd>M</kbd> operation is defined as:</p>
<pre><span class="mjx-char">Pr(Zero||ψ</span><br/> <span class="mjx-char">⟩</span><br/> <span class="mjx-char">)=</span><br/> <span class="mjx-char">⟨</span><br/> <span class="mjx-char">ψ|0</span><br/> <span class="mjx-char">⟩⟨</span><br/> <span class="mjx-char">0|ψ</span><br/> <span class="mjx-char">⟩</span></pre>
<p>How does the Q# language differ from C#? Here are a few points.</p>
<p>The <kbd>using</kbd> statement is different from that of C#. It's used to allocate an array of qubits for processing. Like the <kbd>using</kbd> statement in C#, the qubits are released at the end of the <kbd>using</kbd> statement. There are no qubits that are used for the entire lifetime of the application.</p>
<p>Q# has a different <kbd>for</kbd> loop that is used to iterate through a range. There is no direct equivalent of a C# <kbd>for</kbd> loop.</p>
<p>Q#, by default, has all variables as immutable, meaning that once they are assigned, they cannot be changed. There is a <kbd>let</kbd> keyword that will allow binding of the variable. Operational arguments are always immutable regardless. That being said, there is (at the time of writing) the ability to declare a variable with the <kbd>mutable</kbd> keyword and set the value later using the <kbd>set</kbd> statement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Well folks, I hope you enjoyed reading this book as much as I did writing it. Remember, there is so much to cover, and things expand/change on a daily basis! For the next book in our series, I plan on diving deeper into the world of deep learning and really explore the internals of some interesting things.</p>
<p>For now, I hope you've found a way to take up these invaluable open source projects and make them a part of your daily life. Whether you are a machine learning developer, a data scientist, or just a regular C# developer interested in all of the previous, there's something for everyone in this book. Explore the open source projects, their samples, and test cases; build a framework that allows you to integrate these into your daily life.</p>
<p>For now, thank you so very much for reading this book, and I wish you all the best in your future endeavors of machine learning! I want to thank all those involved in creating this book and bringing it to market. The Packt team has been so amazingly helpful and courteous, and has made the process easy and fun. To all the proofreaders out there, thank you so much for your time and effort. Your comments have helped to make this book so much better.</p>


            </article>

            
        </section>
    </body></html>