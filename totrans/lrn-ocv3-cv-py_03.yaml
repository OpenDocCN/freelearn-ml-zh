- en: Chapter 3. Processing Images with OpenCV 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用OpenCV 3处理图像
- en: 'Sooner or later, when working with images, you will find yourself in need of
    altering images: be it applying artistic filters, extrapolating certain sections,
    cutting, pasting, or whatever else your mind can conjure. This chapter presents
    some techniques to alter images, and by the end of it, you should be able to perform
    tasks, such as detecting skin tone in an image, sharpening an image, mark contours
    of subjects, and detecting crosswalks using a line segment detector.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理图像的过程中，迟早你会发现自己需要修改图像：无论是应用艺术滤镜、扩展某些部分、剪切、粘贴，还是你心中能想到的其他任何操作。本章将介绍一些修改图像的技术，到本章结束时，你应该能够执行诸如在图像中检测肤色、锐化图像、标记主题轮廓以及使用线段检测器检测人行横道等任务。
- en: Converting between different color spaces
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同色彩空间之间转换
- en: 'There are literally hundreds of methods in OpenCV that pertain to the conversion
    of color spaces. In general, three color spaces are prevalent in modern day computer
    vision: gray, BGR, and **Hue, Saturation, Value** (**HSV**).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中实际上有数百种方法与色彩空间的转换相关。一般来说，在现代计算机视觉中，三种色彩空间最为常见：灰度、BGR和**色调、饱和度、明度**（**HSV**）。
- en: 'Gray is a color space that effectively eliminates color information translating
    to shades of gray: this color space is extremely useful for intermediate processing,
    such as face detection.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰度是一种能够有效消除颜色信息，转换为灰度色调的色彩空间：这种色彩空间在中间处理中极为有用，例如人脸检测。
- en: 'BGR is the blue-green-red color space, in which each pixel is a three-element
    array, each value representing the blue, green, and red colors: web developers
    would be familiar with a similar definition of colors, except the order of colors
    is RGB.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BGR是蓝绿红色彩空间，其中每个像素是一个包含三个元素的数组，每个值代表蓝色、绿色和红色：网络开发者对颜色的类似定义应该很熟悉，只是颜色的顺序是RGB。
- en: In HSV, hue is a color tone, saturation is the intensity of a color, and value
    represents its darkness (or brightness at the opposite end of the spectrum).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HSV色彩空间中，色调代表一种颜色调，饱和度是颜色的强度，而明度则表示其暗度（或光谱另一端的亮度）。
- en: A quick note on BGR
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于BGR的简要说明
- en: 'When I first started dealing with the BGR color space, something wasn''t adding
    up: the `[0 255 255]` value (no blue, full green, and full red) produces the yellow
    color. If you have an artistic background, you won''t even need to pick up paints
    and brushes to witness green and red mix into a muddy shade of brown. That is
    because the color model used in computing is called an **additive** and deals
    with lights. Lights behave differently from paints (which follow the **subtractive**
    color model), and—as software runs on computers whose medium is a monitor that
    emits light—the color model of reference is the additive one.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初开始处理BGR色彩空间时，发现有些事情并不符合预期：`[0 255 255]`的值（没有蓝色，全绿色和全红色）产生了黄色。如果你有艺术背景，你甚至不需要拿起画笔和画布就能看到绿色和红色混合成一种泥泞的棕色。这是因为计算机中使用的颜色模型被称为**加色**模型，并且与光有关。光的行为与颜料（遵循**减色**颜色模型）不同，并且——由于软件在以显示器为媒介的计算机上运行，而显示器会发出光——参考的颜色模型是加色模型。
- en: The Fourier Transform
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 傅里叶变换
- en: Much of the processing you apply to images and videos in OpenCV involves the
    concept of Fourier Transform in some capacity. Joseph Fourier was an 18th century
    French mathematician who discovered and popularized many mathematical concepts,
    and concentrated his work on studying the laws governing heat, and in mathematics,
    all things waveform. In particular, he observed that all waveforms are just the
    sum of simple sinusoids of different frequencies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV中对图像和视频应用的大部分处理都涉及到以某种形式的概念——傅里叶变换。约瑟夫·傅里叶是一位18世纪的法国数学家，他发现了许多数学概念并使之流行，他的工作主要集中在研究热量和数学中的波形规律。特别是，他观察到所有波形都是不同频率的简单正弦波的叠加。
- en: In other words, the waveforms you observe all around you are the sum of other
    waveforms. This concept is incredibly useful when manipulating images, because
    it allows us to identify regions in images where a signal (such as image pixels)
    changes a lot, and regions where the change is less dramatic. We can then arbitrarily
    mark these regions as noise or regions of interests, background or foreground,
    and so on. These are the frequencies that make up the original image, and we have
    the power to separate them to make sense of the image and extrapolate interesting
    data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你周围观察到的所有波形都是其他波形的总和。这个概念在处理图像时非常有用，因为它允许我们识别图像中信号（如图像像素）变化很大的区域，以及变化不那么剧烈的区域。然后我们可以任意标记这些区域作为噪声或感兴趣的区域，背景或前景等。这些就是构成原始图像的频率，我们有能力将它们分离，以便理解图像并推断有趣的数据。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In an OpenCV context, there are a number of algorithms implemented that enable
    us to process images and make sense of the data contained in them, and these are
    also reimplemented in NumPy to make our life even easier. NumPy has a **Fast Fourier
    Transform** (**FFT**) package, which contains the `fft2()` method. This method
    allows us to compute **Discrete Fourier Transform** (**DFT**) of the image.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV的上下文中，实现了一些算法，使我们能够处理图像并理解其中的数据，这些算法也在NumPy中重新实现，使我们的工作更加容易。NumPy有一个**快速傅里叶变换**（**FFT**）包，其中包含`fft2()`方法。此方法允许我们计算图像的**离散傅里叶变换**（**DFT**）。
- en: 'Let''s examine the **magnitude spectrum** concept of an image using Fourier
    Transform. The magnitude spectrum of an image is another image, which gives a
    representation of the original image in terms of its changes: think of it as taking
    an image and dragging all the brightest pixels to the center. Then, you gradually
    work your way out to the border where all the darkest pixels have been pushed.
    Immediately, you will be able to see how many light and dark pixels are contained
    in your image and the percentage of their distribution.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用傅里叶变换来考察图像的**幅度谱**概念。图像的幅度谱是另一个图像，它以变化的形式表示原始图像：可以想象成将图像中的所有最亮的像素拖到中心。然后，你逐渐向外工作，直到所有最暗的像素都被推到边缘。立即，你将能够看到图像中包含了多少亮暗像素以及它们分布的百分比。
- en: The concept of Fourier Transform is the basis of many algorithms used for common
    image processing operations, such as edge detection or line and shape detection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶变换的概念是许多用于常见图像处理操作（如边缘检测或线形和形状检测）的算法的基础。
- en: 'Before examining these in detail, let''s take a look at two concepts that—in
    conjunction with the Fourier Transform—form the foundation of the aforementioned
    processing operations: high pass filters and low pass filters.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细探讨这些内容之前，让我们先看看两个概念，这两个概念与傅里叶变换结合，构成了上述处理操作的基础：高通滤波器和低通滤波器。
- en: High pass filter
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高通滤波器
- en: A **high pass filter** (**HPF**) is a filter that examines a region of an image
    and boosts the intensity of certain pixels based on the difference in the intensity
    with the surrounding pixels.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**高通滤波器**（**HPF**）是一种检查图像某个区域的滤波器，根据与周围像素强度的差异来增强某些像素的强度。'
- en: 'Take, for example, the following kernel:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下核为例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **kernel** is a set of weights that are applied to a region in a source image
    to generate a single pixel in the destination image. For example, a `ksize` of
    `7` implies that `49 (7 x 7)` source pixels are considered in generating each
    destination pixel. We can think of a kernel as a piece of frosted glass moving
    over the source image and letting through a diffused blend of the source's light.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**核**是一组应用于源图像某个区域的权重，用于生成目标图像的单个像素。例如，`ksize`为`7`意味着在生成每个目标像素时考虑了`49 (7 x
    7)`个源像素。我们可以将核想象成一块磨砂玻璃在源图像上移动，并让源的光线通过扩散混合。'
- en: After calculating the sum of differences of the intensities of the central pixel
    compared to all the immediate neighbors, the intensity of the central pixel will
    be boosted (or not) if a high level of changes are found. In other words, if a
    pixel stands out from the surrounding pixels, it will get boosted.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算中心像素与所有直接邻居像素强度差异之和后，如果发现强度变化很大，则中心像素的强度将被增强（或不会增强）。换句话说，如果一个像素与周围像素不同，它将被增强。
- en: This is particularly effective in edge detection, where a common form of HPF
    called high boost filter is used.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这在边缘检测中特别有效，其中使用了一种称为高增强滤波器的高通滤波器。
- en: Both high pass and low pass filters use a property called `radius`, which extends
    the area of the neighbors involved in the filter calculation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 高通滤波器和低通滤波器都使用一个名为 `radius` 的属性，它扩展了参与滤波器计算的邻居区域。
- en: 'Let''s go through an example of an HPF:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个 HPF 的例子来了解：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that both filters sum up to `0`, the reason for this is explained in detail
    in the *Edge detection* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个滤波器的总和为 `0`，其原因在 *边缘检测* 部分有详细解释。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the initial imports, we define a `3x3` kernel and a `5x5` kernel, and
    then we load the image in grayscale. Normally, the majority of image processing
    is done with NumPy; however, in this particular case, we want to "convolve" an
    image with a given kernel and NumPy happens to only accept one-dimensional arrays.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始导入之后，我们定义了一个 `3x3` 的核和一个 `5x5` 的核，然后以灰度形式加载图像。通常，大多数图像处理都是使用 NumPy 完成的；然而，在这个特定的情况下，我们想要“卷积”一个图像和一个给定的核，而
    NumPy 只接受一维数组。
- en: This does not mean that the convolution of deep arrays can't be achieved with
    NumPy, just that it would be a bit complex. Instead, `ndimage` (which is a part
    of SciPy, so you should have it installed as per the instructions in [Chapter
    1](part0014.xhtml#aid-DB7S2 "Chapter 1. Setting Up OpenCV"), *Setting Up OpenCV*),
    makes this trivial, through its `convolve()` function, which supports the classic
    NumPy arrays that the `cv2` modules use to store images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着不能使用 NumPy 实现深度数组的卷积，只是这可能会稍微复杂一些。相反，`ndimage`（它是 SciPy 的一部分，因此您应按照 [第
    1 章](part0014.xhtml#aid-DB7S2 "第 1 章。设置 OpenCV") 中 *设置 OpenCV* 的说明进行安装），通过其 `convolve()`
    函数使这变得简单，该函数支持 `cv2` 模块使用的经典 NumPy 数组来存储图像。
- en: We apply two HPFs with the two convolution kernels we defined. Lastly, we also
    implement a differential method of obtaining a HPF by applying a low pass filter
    and calculating the difference with the original image. You will notice that the
    third method actually yields the best result, so let's also elaborate on low pass
    filters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们定义的两个卷积核应用两个 HPF。最后，我们还实现了一种通过应用低通滤波器并计算与原始图像的差异来获取 HPF 的微分方法。您将注意到第三种方法实际上效果最好，所以让我们也详细说明低通滤波器。
- en: Low pass filter
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低通滤波器
- en: If an HPF boosts the intensity of a pixel, given its difference with its neighbors,
    a **low pass filter** (**LPF**) will smoothen the pixel if the difference with
    the surrounding pixels is lower than a certain threshold. This is used in denoising
    and blurring. For example, one of the most popular blurring/smoothening filters,
    the Gaussian blur, is a low pass filter that attenuates the intensity of high
    frequency signals.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 HPF 增强了像素的强度，考虑到它与邻居的差异，那么一个 **低通滤波器**（**LPF**）如果与周围像素的差异低于某个阈值，将会平滑该像素。这在去噪和模糊中得到了应用。例如，最流行的模糊/平滑滤波器之一，高斯模糊，就是一个低通滤波器，它衰减高频信号的强度。
- en: Creating modules
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: As in the case of our `CaptureManager` and `WindowManager` classes, our filters
    should be reusable outside Cameo. Thus, we should separate the filters into their
    own Python module or file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的 `CaptureManager` 和 `WindowManager` 类一样，我们的过滤器应该在 Cameo 之外可重用。因此，我们应该将过滤器分离到它们自己的
    Python 模块或文件中。
- en: 'Let''s create a file called `filters.py` in the same directory as `cameo.py`.
    We need the following `import` statements in `filters.py`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `cameo.py` 同一目录下创建一个名为 `filters.py` 的文件。在 `filters.py` 中，我们需要以下 `import`
    语句：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s also create a file called `utils.py` in the same directory. It should
    contain the following `import` statements:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在同一目录下也创建一个名为 `utils.py` 的文件。它应该包含以下 `import` 语句：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will be adding filter functions and classes to `filters.py`, while more general-purpose
    math functions will go in `utils.py`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `filters.py` 中添加滤波函数和类，而更通用的数学函数将放在 `utils.py` 中。
- en: Edge detection
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘检测
- en: Edges play a major role in both human and computer vision. We, as humans, can
    easily recognize many object types and their pose just by seeing a backlit silhouette
    or a rough sketch. Indeed, when art emphasizes edges and poses, it often seems
    to convey the idea of an archetype, such as Rodin's *The Thinker* or Joe Shuster's
    *Superman*. Software, too, can reason about edges, poses, and archetypes. We will
    discuss these kinds of reasonings in later chapters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘在人类和计算机视觉中都起着重要作用。作为人类，我们只需通过看到背光轮廓或粗糙草图，就能轻松识别许多物体类型及其姿态。确实，当艺术强调边缘和姿态时，它往往传达出原型的概念，比如罗丹的《思想者》或乔·舒斯特的《超人》。软件也可以对边缘、姿态和原型进行推理。我们将在后面的章节中讨论这些推理。
- en: OpenCV provides many edge-finding filters, including `Laplacian()`, `Sobel()`,
    and `Scharr()`. These filters are supposed to turn non-edge regions to black while
    turning edge regions to white or saturated colors. However, they are prone to
    misidentifying noise as edges. This flaw can be mitigated by blurring an image
    before trying to find its edges. OpenCV also provides many blurring filters, including
    `blur()` (simple average), `medianBlur()`, and `GaussianBlur()`. The arguments
    for the edge-finding and blurring filters vary but always include `ksize`, an
    odd whole number that represents the width and height (in pixels) of a filter's
    kernel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了许多边缘检测过滤器，包括`Laplacian()`、`Sobel()`和`Scharr()`。这些过滤器本应将非边缘区域变为黑色，而将边缘区域变为白色或饱和颜色。然而，它们容易将噪声误识别为边缘。这种缺陷可以通过在尝试寻找边缘之前对图像进行模糊来减轻。OpenCV还提供了许多模糊过滤器，包括`blur()`（简单平均）、`medianBlur()`和`GaussianBlur()`。边缘检测和模糊过滤器的参数各不相同，但总是包括`ksize`，这是一个表示过滤器核宽度和高度的奇数整数。
- en: For blurring, let's use `medianBlur()`, which is effective in removing digital
    video noise, especially in color images. For edge-finding, let's use `Laplacian()`,
    which produces bold edge lines, especially in grayscale images. After applying
    `medianBlur()`, but before applying `Laplacian()`, we should convert the image
    from BGR to grayscale.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模糊，让我们使用`medianBlur()`，它在去除数字视频噪声方面非常有效，尤其是在彩色图像中。对于边缘检测，让我们使用`Laplacian()`，它在灰度图像中产生粗壮的边缘线。在应用`Laplacian()`之前，但在应用`medianBlur()`之后，我们应该将图像从BGR转换为灰度。
- en: 'Once we have the result of `Laplacian()`, we can invert it to get black edges
    on a white background. Then, we can normalize it (so that its values range from
    0 to 1) and multiply it with the source image to darken the edges. Let''s implement
    this approach in `filters.py`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了`Laplacian()`的结果，我们可以将其反转以在白色背景上得到黑色边缘。然后，我们可以将其归一化（使其值范围从0到1）并与源图像相乘以加深边缘。让我们在`filters.py`中实现这种方法：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we allow kernel sizes to be specified as arguments for `strokeEdges()`.
    The `blurKsize` argument is used as `ksize` for `medianBlur()`, while `edgeKsize`
    is used as `ksize` for `Laplacian()`. With my webcams, I find that a `blurKsize`
    value of `7` and an `edgeKsize` value of `5` looks best. Unfortunately, `medianBlur()`
    is expensive with a large `ksize`, such as `7`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们允许将核大小作为`strokeEdges()`的参数指定。`blurKsize`参数用作`medianBlur()`的`ksize`，而`edgeKsize`用作`Laplacian()`的`ksize`。在我的网络摄像头中，我发现`blurKsize`值为`7`和`edgeKsize`值为`5`看起来最佳。不幸的是，当`ksize`较大，如`7`时，`medianBlur()`会变得很昂贵。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you encounter performance problems when running `strokeEdges()`, try decreasing
    the `blurKsize` value. To turn off blur, set it to a value less than `3`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行`strokeEdges()`时遇到性能问题，尝试减小`blurKsize`的值。要关闭模糊，将其设置为小于`3`的值。
- en: Custom kernels – getting convoluted
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义核 – 变得复杂
- en: As we have just seen, many of OpenCV's predefined filters use a kernel. Remember
    that a kernel is a set of weights, which determine how each output pixel is calculated
    from a neighborhood of input pixels. Another term for a kernel is a **convolution
    matrix**. It mixes up or convolves the pixels in a region. Similarly, a kernel-based
    filter may be called a convolution filter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，OpenCV的许多预定义过滤器使用核。记住，核是一组权重，这些权重决定了每个输出像素是如何从输入像素的邻域中计算出来的。核的另一个术语是**卷积矩阵**。它在某个区域内混合或卷积像素。同样，基于核的过滤器可能被称为卷积过滤器。
- en: 'OpenCV provides a very versatile `filter2D()` function, which applies any kernel
    or convolution matrix that we specify. To understand how to use this function,
    let''s first learn the format of a convolution matrix. It is a 2D array with an
    odd number of rows and columns. The central element corresponds to a pixel of
    interest and the other elements correspond to the neighbors of this pixel. Each
    element contains an integer or floating point value, which is a weight that gets
    applied to an input pixel''s value. Consider this example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个非常通用的`filter2D()`函数，它可以应用我们指定的任何核或卷积矩阵。为了了解如何使用此函数，让我们首先学习卷积矩阵的格式。它是一个行和列都是奇数的二维数组。中心元素对应于一个感兴趣的像素，其他元素对应于该像素的邻居。每个元素包含一个整数或浮点值，这是一个应用于输入像素值的权重。考虑以下示例：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the pixel of interest has a weight of `9` and its immediate neighbors
    each have a weight of `-1`. For the pixel of interest, the output color will be
    nine times its input color minus the input colors of all eight adjacent pixels.
    If the pixel of interest is already a bit different from its neighbors, this difference
    becomes intensified. The effect is that the image looks *sharper* as the contrast
    between the neighbors is increased.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，感兴趣像素的权重为`9`，其直接邻居的权重各为`-1`。对于感兴趣像素，输出颜色将是其输入颜色的九倍减去所有八个相邻像素的输入颜色。如果感兴趣像素与其邻居已经有点不同，这种差异会变得更加明显。结果是，当邻居之间的对比度增加时，图像看起来会更*锐利*。
- en: 'Continuing our example, we can apply this convolution matrix to a source and
    destination image, respectively, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的示例，我们可以将这个卷积矩阵分别应用于源图像和目标图像，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second argument specifies the per-channel depth of the destination image
    (such as `cv2.CV_8U` for 8 bits per channel). A negative value (as used here)
    means that the destination image has the same depth as the source image.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数指定了目标图像的每个通道的深度（例如，对于每个通道8位，使用`cv2.CV_8U`）。一个负值（如这里所示）表示目标图像具有与源图像相同的深度。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For color images, note that `filter2D()` applies the kernel equally to each
    channel. To use different kernels on different channels, we would also have to
    use the `split()` and `merge()` functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于彩色图像，请注意`filter2D()`对每个通道应用内核是相同的。要使用不同通道的不同内核，我们还需要使用`split()`和`merge()`函数。
- en: 'Based on this simple example, let''s add two classes to `filters.py`. One class,
    `VConvolutionFilter`, will represent a convolution filter in general. A subclass,
    `SharpenFilter`, will represent our sharpening filter specifically. Let''s edit
    `filters.py` to implement these two new classes as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个简单的示例，让我们向`filters.py`中添加两个类。一个类，`VConvolutionFilter`，将代表一般的卷积滤镜。一个子类，`SharpenFilter`，将代表我们的锐化滤镜。让我们编辑`filters.py`以实现这两个新类，如下所示：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that the weights sum up to `1`. This should be the case whenever we want
    to leave the image''s overall brightness unchanged. If we modify a sharpening
    kernel slightly so that its weights sum up to `0` instead, we have an edge detection
    kernel that turns edges white and non-edges black. For example, let''s add the
    following edge detection filter to `filters.py`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，权重之和为`1`。这应该在我们想要保持图像整体亮度不变时始终成立。如果我们稍微修改锐化核，使其权重之和为`0`，那么我们就有了一个将边缘变为白色、非边缘变为黑色的边缘检测核。例如，让我们将以下边缘检测滤镜添加到`filters.py`中：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, let''s make a blur filter. Generally, for a blur effect, the weights
    should sum up to `1` and should be positive throughout the neighborhood. For example,
    we can take a simple average of the neighborhood as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们制作一个模糊滤镜。一般来说，为了产生模糊效果，权重之和应为`1`，并且在整个邻域内应为正值。例如，我们可以简单地取邻域的平均值，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our sharpening, edge detection, and blur filters use kernels that are highly
    symmetric. Sometimes, though, kernels with less symmetry produce an interesting
    effect. Let''s consider a kernel that blurs on one side (with positive weights)
    and sharpens on the other (with negative weights). It will produce a ridged or
    *embossed* effect. Here is an implementation that we can add to `filters.py`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的锐化、边缘检测和模糊滤镜都采用了高度对称的核。然而，有时使用对称性较低的核会产生有趣的效果。让我们考虑一个在一侧（具有正权重）模糊而在另一侧（具有负权重）锐化的核。这将产生一种脊状或*浮雕*效果。以下是一个可以添加到`filters.py`中的实现示例：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This set of custom convolution filters is very basic. Indeed, it is more basic
    than OpenCV's ready-made set of filters. However, with a bit of experimentation,
    you should be able to write your own kernels that produce a unique look.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这套自定义卷积滤镜非常基础。实际上，它比OpenCV的现成滤镜集更基础。然而，通过一些实验，你应该能够编写出产生独特外观的自己的核。
- en: Modifying the application
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改应用
- en: 'Now that we have high-level functions and classes for several filters, it is
    trivial to apply any of them to the captured frames in Cameo. Let''s edit `cameo.py`
    and add the lines that appear in bold face in the following excerpt:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了几个滤镜的高级函数和类，将它们应用于Cameo捕获的帧变得非常简单。让我们编辑`cameo.py`并添加以下摘录中加粗的行：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, I have chosen to apply two effects: stroking the edges and emulating
    Portra film colors. Feel free to modify the code to apply any filters you like.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我选择应用两种效果：描边边缘和模拟Portra胶片颜色。请随意修改代码以应用您喜欢的任何滤镜。
- en: 'Here is a screenshot from Cameo with stroked edges and Portra-like colors:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Cameo的一个截图，展示了描边边缘和类似Portra的颜色：
- en: '![Modifying the application](img/image00194.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![修改应用程序](img/image00194.jpeg)'
- en: Edge detection with Canny
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canny进行边缘检测
- en: 'OpenCV also offers a very handy function called Canny (after the algorithm''s
    inventor, John F. Canny), which is very popular not only because of its effectiveness,
    but also the simplicity of its implementation in an OpenCV program, as it is a
    one-liner:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV还提供了一个非常方便的函数，称为Canny（以算法的发明者John F. Canny命名），它不仅因其有效性而广受欢迎，而且因其实现简单而广受欢迎，因为它在OpenCV程序中是一行代码：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is a very clear identification of the edges:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是边缘的非常清晰的识别：
- en: '![Edge detection with Canny](img/image00195.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用Canny进行边缘检测](img/image00195.jpeg)'
- en: 'The Canny edge detection algorithm is quite complex but also interesting: it''s
    a five-step process that denoises the image with a Gaussian filter, calculates
    gradients, applies **non maximum** **suppression** (**NMS**) on edges, a double
    threshold on all the detected edges to eliminate false positives, and, lastly,
    analyzes all the edges and their connection to each other to keep the real edges
    and discard the weak ones.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Canny边缘检测算法相当复杂但也很有趣：它是一个五步过程，使用高斯滤波器对图像进行降噪，计算梯度，对边缘应用**非最大** **抑制**（**NMS**），对所有检测到的边缘进行双重阈值以消除假阳性，最后分析所有边缘及其相互之间的连接，以保留真实边缘并丢弃较弱的边缘。
- en: Contour detection
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮廓检测
- en: Another vital task in computer vision is contour detection, not only because
    of the obvious aspect of detecting contours of subjects contained in an image
    or video frame, but because of the derivative operations connected with identifying
    contours.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉中的另一个重要任务是轮廓检测，这不仅因为检测图像或视频帧中包含的主题轮廓的明显方面，还因为与识别轮廓相关的导数操作。
- en: These operations are, namely, computing bounding polygons, approximating shapes,
    and generally calculating regions of interest, which considerably simplify interaction
    with image data because a rectangular region with NumPy is easily defined with
    an array slice. We will be using this technique a lot when exploring the concept
    of object detection (including faces) and object tracking.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作包括计算边界多边形、近似形状以及通常计算感兴趣区域，这大大简化了与图像数据的交互，因为使用NumPy可以轻松地用数组切片定义矩形区域。在探索对象检测（包括人脸）和对象跟踪的概念时，我们将大量使用这项技术。
- en: 'Let''s go in order and familiarize ourselves with the API first with an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序进行，首先通过一个示例熟悉API：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Firstly, we create an empty black image that is 200x200 pixels in size. Then,
    we place a white square in the center of it utilizing ndarray's ability to assign
    values on a slice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个200x200像素大小的空黑色图像。然后，我们利用ndarray在切片上赋值的能力，在图像的中心放置一个白色方块。
- en: 'We then threshold the image, and call the `findContours()` function. This function
    has three parameters: the input image, hierarchy type, and the contour approximation
    method. There are a number of aspects that are of particular interest in this
    function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后对图像进行阈值处理，并调用`findContours()`函数。此函数有三个参数：输入图像、层次结构类型和轮廓近似方法。此函数中有几个特别有趣的方面：
- en: The function modifies the input image, so it would be advisable to use a copy
    of the original image (for example, by passing `img.copy()`).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数会修改输入图像，因此建议使用原始图像的副本（例如，通过传递`img.copy()`）。
- en: 'Secondly, the hierarchy tree returned by the function is quite important: `cv2.RETR_TREE`
    will retrieve the entire hierarchy of contours in the image, enabling you to establish
    "relationships" between contours. If you only want to retrieve the most external
    contours, use `cv2.RETR_EXTERNAL`. This is particularly useful when you want to
    eliminate contours that are entirely contained in other contours (for example,
    in a vast majority of cases, you won''t need to detect an object within another
    object of the same type).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，函数返回的层次结构树非常重要：`cv2.RETR_TREE`将检索图像中轮廓的整个层次结构，使您能够建立轮廓之间的“关系”。如果您只想检索最外层的轮廓，请使用`cv2.RETR_EXTERNAL`。这在您想要消除完全包含在其他轮廓中的轮廓时特别有用（例如，在大多数情况下，您不需要检测另一个相同类型的对象内的对象）。
- en: 'The `findContours` function returns three elements: the modified image, contours,
    and their hierarchy. We use the contours to draw on the color version of the image
    (so that we can draw contours in green) and eventually display it.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`findContours`函数返回三个元素：修改后的图像、轮廓及其层次结构。我们使用轮廓在图像的颜色版本上绘制（这样我们可以在绿色上绘制轮廓），并最终显示它。'
- en: The result is a white square with its contour drawn in green. Spartan, but effective
    in demonstrating the concept! Let's move on to more meaningful examples.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个用绿色绘制轮廓的白色正方形。虽然简单，但有效地展示了概念！让我们继续看更有意义的例子。
- en: Contours – bounding box, minimum area rectangle, and minimum enclosing circle
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮廓 – 包围盒、最小面积矩形和最小包围圆
- en: 'Finding the contours of a square is a simple task; irregular, skewed, and rotated
    shapes bring the best out of the `cv2.findContours` utility function of OpenCV.
    Let''s take a look at the following image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 找到正方形的轮廓是一个简单的任务；不规则、倾斜和旋转的形状最能发挥OpenCV的`cv2.findContours`实用函数的作用。让我们看看下面的图像：
- en: '![Contours – bounding box, minimum area rectangle, and minimum enclosing circle](img/image00196.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![轮廓 – 包围盒、最小面积矩形和最小包围圆](img/image00196.jpeg)'
- en: 'In a real-life application, we would be most interested in determining the
    bounding box of the subject, its minimum enclosing rectangle, and its circle.
    The `cv2.findContours` function in conjunction with a few other OpenCV utilities
    makes this very easy to accomplish:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们最感兴趣的是确定主题的包围盒、其最小包围矩形和其圆。结合`cv2.findContours`函数和一些其他OpenCV实用工具，这使得实现这一点变得非常容易：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After the initial imports, we load the image, and then apply a binary threshold
    on a grayscale version of the original image. By doing this, we operate all find-contour
    calculations on a grayscale copy, but we draw on the original so that we can utilize
    color information.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始导入之后，我们加载图像，然后在原始图像的灰度版本上应用二值阈值。通过这样做，我们在灰度副本上进行所有查找轮廓的计算，但我们绘制在原始图像上，以便利用颜色信息。
- en: 'Firstly, let''s calculate a simple bounding box:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们计算一个简单的包围盒：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a pretty straightforward conversion of contour information to the `(x,
    y)` coordinates, plus the height and width of the rectangle. Drawing this rectangle
    is an easy task and can be done using this code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的轮廓信息转换为`(x, y)`坐标的转换，加上矩形的宽度和高度。绘制这个矩形是一个简单的任务，可以使用以下代码完成：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Secondly, let''s calculate the minimum area enclosing the subject:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们计算包围主题的最小面积：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The mechanism used here is particularly interesting: OpenCV does not have a
    function to calculate the coordinates of the minimum rectangle vertexes directly
    from the contour information. Instead, we calculate the minimum rectangle area,
    and then calculate the vertexes of this rectangle. Note that the calculated vertexes
    are floats, but pixels are accessed with integers (you can''t access a "portion"
    of a pixel), so we need to operate this conversion. Next, we draw the box, which
    gives us the perfect opportunity to introduce the `cv2.drawContours` function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的机制特别有趣：OpenCV没有直接从轮廓信息计算最小矩形顶点坐标的功能。相反，我们计算最小矩形面积，然后计算这个矩形的顶点。请注意，计算出的顶点是浮点数，但像素是用整数访问的（您不能访问像素的一部分），因此我们需要进行这种转换。接下来，我们绘制这个盒子，这为我们提供了一个介绍`cv2.drawContours`函数的绝佳机会：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Firstly, this function—like all drawing functions—modifies the original image.
    Secondly, it takes an array of contours in its second parameter, so you can draw
    a number of contours in a single operation. Therefore, if you have a single set
    of points representing a contour polygon, you need to wrap these points into an
    array, exactly like we did with our box in the preceding example. The third parameter
    of this function specifies the index of the contours array that we want to draw:
    a value of `-1` will draw all contours; otherwise, a contour at the specified
    index in the contours array (the second parameter) will be drawn.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数——就像所有绘图函数一样——会修改原始图像。其次，它在其第二个参数中接受一个轮廓数组，因此您可以在一次操作中绘制多个轮廓。因此，如果您有一组代表轮廓多边形的点，您需要将这些点包装成一个数组，就像我们在前面的例子中处理我们的盒子一样。这个函数的第三个参数指定了我们要绘制的轮廓数组的索引：值为`-1`将绘制所有轮廓；否则，将绘制轮廓数组（第二个参数）中指定索引处的轮廓。
- en: Most drawing functions take the color of the drawing and its thickness as the
    last two parameters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数绘图函数将绘图颜色和厚度作为最后两个参数。
- en: 'The last bounding contour we''re going to examine is the minimum enclosing
    circle:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个边界轮廓是最小包围圆：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only peculiarity of the `cv2.minEnclosingCircle` function is that it returns
    a two-element tuple, of which the first element is a tuple itself, representing
    the coordinates of the circle's center, and the second element is the radius of
    this circle. After converting all these values to integers, drawing the circle
    is quite a trivial operation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv2.minEnclosingCircle` 函数的唯一特殊性在于它返回一个包含两个元素的元组，其中第一个元素本身也是一个元组，表示圆心的坐标，第二个元素是这个圆的半径。在将这些值转换为整数后，画圆就变得相当简单了。'
- en: 'The final result on the original image looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最终在原始图像上的结果看起来像这样：
- en: '![Contours – bounding box, minimum area rectangle, and minimum enclosing circle](img/image00197.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![等高线 – 矩形框、最小面积矩形和最小外接圆](img/image00197.jpeg)'
- en: Contours – convex contours and the Douglas-Peucker algorithm
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等高线 – 凸等高线和 Douglas-Peucker 算法
- en: Most of the time, when working with contours, subjects will have the most diverse
    shapes, including convex ones. A convex shape is one where there are two points
    within this shape whose connecting line goes outside the perimeter of the shape
    itself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当处理等高线时，主题将具有最多样化的形状，包括凸形。凸形是指在这个形状内部有两个点，它们之间的连线会超出形状本身的轮廓。
- en: 'The first facility that OpenCV offers to calculate the approximate bounding
    polygon of a shape is `cv2.approxPolyDP`. This function takes three parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 提供的第一个用于计算形状近似边界多边形的工具是 `cv2.approxPolyDP`。这个函数有三个参数：
- en: A contour
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等高线
- en: An epsilon value representing the maximum discrepancy between the original contour
    and the approximated polygon (the lower the value, the closer the approximated
    value will be to the original contour)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 epsilon 值，表示原始等高线和近似多边形之间的最大差异（值越低，近似值越接近原始等高线）
- en: A Boolean flag signifying that the polygon is closed
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔标志，表示多边形是封闭的
- en: The epsilon value is of vital importance to obtain a useful contour, so let's
    understand what it represents. An epsilon is the maximum difference between the
    approximated polygon's perimeter and the original contour's perimeter. The lower
    this difference is, the more the approximated polygon will be similar to the original
    contour.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: epsilon 值对于获得有用的等高线至关重要，因此让我们了解它代表什么。epsilon 是近似多边形周长和原始等高线周长之间的最大差异。这个差异越低，近似多边形就越接近原始等高线。
- en: You may ask yourself why we need an approximate polygon when we have a contour
    that is already a precise representation. The answer to this is that a polygon
    is a set of straight lines, and the importance of being able to define polygons
    in a region for further manipulation and processing is paramount in many computer
    vision tasks.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们已经有了一个精确表示的等高线时，你可能想知道为什么我们还需要一个近似的 polygon。答案是，多边形是一系列直线，能够在区域内定义多边形以便进一步的操作和处理，这在许多计算机视觉任务中至关重要。
- en: 'Now that we know what an epsilon is, we need to obtain contour perimeter information
    as a reference value. This is obtained with the `cv2.arcLength` function of OpenCV:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了 epsilon 是什么，我们需要获取等高线周长信息作为参考值。这可以通过 OpenCV 的 `cv2.arcLength` 函数获得：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Effectively, we're instructing OpenCV to calculate an approximated polygon whose
    perimeter can only differ from the original contour in an epsilon ratio.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们是在指示 OpenCV 计算一个近似的多边形，其周长只能在一个 epsilon 比率内与原始等高线不同。
- en: 'OpenCV also offers a `cv2.convexHull` function to obtain processed contour
    information for convex shapes and this is a straightforward one-line expression:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 还提供了一个 `cv2.convexHull` 函数来获取凸形状的处理后的等高线信息，这是一个简单的单行表达式：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s combine the original contour, approximated polygon contour, and the
    convex hull in one image to observe the difference between them. To simplify things,
    I''ve applied the contours to a black image so that the original subject is not
    visible but its contours are:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将原始等高线、近似的多边形等高线和凸包结合在一个图像中，以观察它们之间的差异。为了简化问题，我已经将等高线应用到一张黑底图像上，这样原始主题不可见，但其轮廓是可见的：
- en: '![Contours – convex contours and the Douglas-Peucker algorithm](img/image00198.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![等高线 – 凸等高线和 Douglas-Peucker 算法](img/image00198.jpeg)'
- en: As you can see, the convex hull surrounds the entire subject, the approximated
    polygon is the innermost polygon shape, and in between the two is the original
    contour, mainly composed of arcs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，凸包包围了整个主题，近似多边形是最内层的多边形形状，两者之间是原始等高线，主要由弧线组成。
- en: Line and circle detection
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线和圆检测
- en: Detecting edges and contours are not only common and important tasks, they also
    constitute the basis for other complex operations. Lines and shape detection go
    hand in hand with edge and contour detection, so let's examine how OpenCV implements
    these.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 检测边缘和轮廓不仅是常见且重要的任务，它们还构成了其他复杂操作的基础。线和形状检测与边缘和轮廓检测是相辅相成的，因此让我们看看 OpenCV 如何实现这些。
- en: The theory behind lines and shape detection has its foundation in a technique
    called the Hough transform, invented by Richard Duda and Peter Hart, who extended
    (generalized) the work done by Paul Hough in the early 1960s.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 线和形状检测背后的理论基于一种称为 Hough 变换的技术，由 Richard Duda 和 Peter Hart 发明，他们扩展（推广）了 Paul
    Hough 在 20 世纪 60 年代初的工作。
- en: Let's take a look at OpenCV's API for the Hough transforms.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 OpenCV 的 Hough 变换 API。
- en: Line detection
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线检测
- en: First of all, let's detect some lines, which is done with the `HoughLines` and
    `HoughLinesP` functions. The only difference between the two functions is that
    one uses the standard Hough transform, and the second uses the probabilistic Hough
    transform (hence `P` in the name).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 `HoughLines` 和 `HoughLinesP` 函数检测一些线，这是通过 `HoughLines` 函数调用来完成的。这两个函数之间的唯一区别是，一个使用标准
    Hough 变换，另一个使用概率 Hough 变换（因此名称中的 `P`）。
- en: The probabilistic version is so-called because it only analyzes a subset of
    points and estimates the probability of these points all belonging to the same
    line. This implementation is an optimized version of the standard Hough transform,
    and in this case, it's less computationally intensive and executes faster.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 概率版本之所以被称为概率版本，是因为它只分析点的一个子集，并估计这些点全部属于同一条线的概率。这个实现是标准 Hough 变换的优化版本，在这种情况下，它计算量更小，执行速度更快。
- en: 'Let''s take a look at a very simple example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个非常简单的例子：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The crucial point of this simple script—aside from the `HoughLines` function
    call—is the setting of minimum line length (shorter lines will be discarded) and
    the maximum line gap, which is the maximum size of a gap in a line before the
    two segments start being considered as separate lines.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单脚本的关键点——除了 `HoughLines` 函数调用之外——是设置最小线长度（较短的线将被丢弃）和最大线间隙，这是在两条线段开始被视为单独的线之前，线中最大间隙的大小。
- en: Also note that the `HoughLines` function takes a single channel binary image,
    processed through the Canny edge detection filter. Canny is not a strict requirement,
    however; an image that's been denoised and only represents edges, is the ideal
    source for a Hough transform, so you will find this to be a common practice.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`HoughLines` 函数需要一个单通道二值图像，该图像通过 Canny 边缘检测滤波器处理。Canny 不是严格的要求；一个去噪后只代表边缘的图像，是
    Hough 变换的理想来源，因此你会发现这是一种常见的做法。
- en: 'The parameters of `HoughLinesP` are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`HoughLinesP` 的参数如下：'
- en: The image we want to process.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要处理的图像。
- en: The geometrical representations of the lines, `rho` and `theta`, which are usually
    `1` and `np.pi/180`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线的几何表示，`rho` 和 `theta`，通常为 `1` 和 `np.pi/180`。
- en: The threshold, which represents the threshold below which a line is discarded.
    The Hough transform works with a system of bins and votes, with each bin representing
    a line, so any line with a minimum of the `<threshold>` votes is retained, the
    rest discarded.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阈值，表示低于此阈值的线将被丢弃。Hough 变换使用一个由桶和投票组成的系统，每个桶代表一条线，因此任何获得 `<阈值>` 投票的线将被保留，其余的将被丢弃。
- en: '`MinLineLength` and `MaxLineGap`, which we mentioned previously.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前提到的 `MinLineLength` 和 `MaxLineGap`。
- en: Circle detection
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 圆检测
- en: 'OpenCV also has a function for detecting circles, called `HoughCircles`. It
    works in a very similar fashion to `HoughLines`, but where `minLineLength` and
    `maxLineGap` were the parameters to discard or retain lines, `HoughCircles` has
    a minimum distance between circles'' centers, minimum, and maximum radius of the
    circles. Here''s the obligatory example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 还有一个用于检测圆的功能，称为 `HoughCircles`。它的工作方式与 `HoughLines` 非常相似，但 `minLineLength`
    和 `maxLineGap` 是用于丢弃或保留线的参数，而 `HoughCircles` 有圆心之间的最小距离、最小和最大半径等参数。下面是一个必看的示例：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here''s a visual representation of the result:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是结果的可视表示：
- en: '![Circle detection](img/image00199.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![圆检测](img/image00199.jpeg)'
- en: Detecting shapes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测形状
- en: The detection of shapes with the Hough transform is limited to circles; however,
    we already implicitly explored detecting shapes of any kind, specifically when
    we talked about `approxPolyDP`. This function allows the approximation of polygons,
    so if your image contains polygons, they will be quite accurately detected, combining
    the usage of `cv2.findContours` and `cv2.approxPolyDP`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用霍夫变换检测形状仅限于圆形；然而，当我们讨论`approxPolyDP`时，我们已经隐式地探索了检测任何形状的方法。这个函数允许对多边形进行近似，所以如果你的图像包含多边形，它们将被相当准确地检测到，这结合了`cv2.findContours`和`cv2.approxPolyDP`的使用。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At this point, you should have gained a good understanding of color spaces,
    Fourier Transform, and the several kinds of filters made available by OpenCV to
    process images.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经对颜色空间、傅里叶变换以及OpenCV提供的用于处理图像的几种类型的过滤器有了很好的理解。
- en: You should also be proficient in detecting edges, lines, circles, and shapes
    in general. Additionally, you should be able to find contours and exploit the
    information they provide about the subjects contained in an image. These concepts
    will serve as the ideal background to explore the topics in the next chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该熟练地检测边缘、线条、圆形以及一般形状。此外，你应该能够找到轮廓并利用它们提供关于图像中包含的主题的信息。这些概念将作为探索下一章主题的理想背景。
