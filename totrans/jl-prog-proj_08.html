<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Leveraging Unsupervised Learning Techniques</h1>
                </header>
            
            <article>
                
<p class="calibre2">Our supervised machine learning project was a success and we're well on our way to becoming experts in recommender systems. It's now time to leave behind the safety of our neatly tagged data and venture into the unknown. Yes, I'm talking about unsupervised machine learning. In this chapter, we'll train a model that will help us find hidden patterns in a mountain of data. And since we've come so far on our journey of learning Julia, it's time to take off the training wheels and take on our first client.</p>
<p class="calibre2">Just kidding—for now, we'll play pretend, but we'll indeed tackle a machine learning problem that could very well be one of the first tasks of a junior data scientist. We'll help our imaginary customer discover key insights for supporting their advertising strategy, a very important component of beginning their operations in San Francisco.</p>
<p class="calibre2">In the process, we'll learn about the following:</p>
<ul class="calibre10">
<li class="calibre11">What unsupervised machine learning is and when and how to use it</li>
<li class="calibre11">The basics of clustering, one of the most important unsupervised learning tasks</li>
<li class="calibre11">How to perform efficient data munging with the help of query</li>
<li class="calibre11">Metaprogramming in Julia</li>
<li class="calibre11">Training and running unsupervised machine learning models with clustering</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="calibre2">The Julia package ecosystem is under continuous development and new package versions are released on a daily basis. Most of the times this is great news, as new releases bring new features and bug fixes. However, since many of the packages are still in beta (version 0.x), any new release can introduce breaking changes. As a result, the code presented in the book can stop working. In order to ensure that your code will produce the same results as described in the book, it is recommended to use the same package versions. Here are the external packages used in this chapter and their specific versions:</p>
<pre class="calibre17">CSV@v.0.4.3<br class="title-page-name"/>DataFrames@v0.15.2<br class="title-page-name"/>DataValues@v0.4.5<br class="title-page-name"/>Gadfly@v1.0.1<br class="title-page-name"/>IJulia@v1.14.1<br class="title-page-name"/>Query@v0.10.1</pre>
<p class="calibre2">In order to install a specific version of a package you need to run:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add PackageName@vX.Y.Z</strong> </pre>
<p class="calibre2">For example:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add IJulia@v1.14.1</strong></pre>
<p class="calibre2">Alternatively you can install all the used packages by downloading the <kbd class="calibre12">Project.toml</kbd> file provided with the chapter and using <kbd class="calibre12">pkg&gt;</kbd> instantiate as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; download("https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter08/Project.toml", "Project.toml")</strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; activate . </strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; instantiate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unsupervised machine learning</h1>
                </header>
            
            <article>
                
<p class="calibre2">In <a href="a3fe07c4-b551-4573-ba72-edba84b1041a.xhtml" target="_blank" class="calibre9">Chapter 7</a>, <em class="calibre16">Machine Learning For Recommender Systems</em>, we learned about supervised machine learning. We used various features in the data (such as the user's ratings) to perform classification tasks. In supervised machine learning, we act a bit like a teacher—we provide a multitude of examples to our algorithm, which, once it gets enough data (and so its training is complete), is able to make generalizations about new items and infer their category or class.</p>
<p class="calibre2">But not all of the data lends itself to these kinds of tasks. Sometimes our data isn't labeled in any way. Imagine items as diverse as a website's traffic logs or the appointments made by customers at a dental clinic. These are just raw observations that aren't categorized in any way and don't contain any meaning. In such cases, data analysts employ unsupervised machine learning algorithms.</p>
<p class="calibre2">Unsupervised machine learning is used to discover hidden structures and patterns in otherwise unlabeled data. It is a very powerful machine learning task, successfully employed in a variety of fields, such as marketing (to identify groups of customers who share similar purchase preferences), medicine (used to spot tumours), IT security (by flagging abnormal user behaviour or web traffic), tax collection (alerting of possible tax evasion), and many, many more.</p>
<p class="calibre2">Any supervised machine learning task can be treated as unsupervised if we simply ignore the features that provide data classification. For example, we could use the famous Iris flower dataset to perform unsupervised learning if we didn't want to take into account the Species column. This would leave us with unlabeled sepal and petal lengths and widths, which could form interesting clusters.</p>
<p class="calibre2">As we've seen in <a href="90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml" target="_blank" class="calibre9">Chapter 1</a>, <em class="calibre16">Getting Started with Julia Programming, </em><strong class="calibre4">setosa</strong> can be reliably identified, as it consistently has lower petal length and width. But <strong class="calibre4">versicolor</strong> and <strong class="calibre4">virginica</strong>? Not so much. You can view this in the following diagram:</p>
<p class="CDPAlignCenter"><img src="assets/c427b97a-884f-4983-8c4a-267791e9bd88.png" class="calibre106"/></p>
<p class="calibre2">The diagram shows how <strong class="calibre4">setosa</strong> forms distinct clusters in almost all of the plots—but <strong class="calibre4">versicolor</strong> and <strong class="calibre4">virginica</strong> don't. This is unsupervised learning. Easy, right?</p>
<p class="calibre2">Not quite—it gets trickier than that. In our Iris flowers example, we cheat a bit as we color code the plots by species. So, the data is not really unlabeled. In a real unsupervised learning scenario, the plots would look like this, with all of the species information removed:</p>
<p class="CDPAlignCenter"><img src="assets/6ddba8d4-463a-497a-ae55-93090c61419d.png" class="calibre107"/></p>
<p class="calibre2">Even without the colors and the labels, since the distribution of the points is the same, we can still easily identify the <strong class="calibre4">setosa</strong> cluster. Except that, obviously, without the species labels we'd have absolutely no idea what it represents. And this is a very important point—<em class="calibre16">the algorithm cannot label the clusters by itself</em>. It can identify a degree of similarity between the various data points, but it can't tell what that <em class="calibre16">means</em> (it won't know it's <strong class="calibre4">setosa</strong>). A corollary of this is that there isn't a correct way of defining the clusters. They're the result of exploratory data mining techniques—and just like the exploration of an unknown territory, taking slightly different paths (looking at data from a different perspective) will lead to different results. To paraphrase the famous saying, the clusters are in the eye of the beholder.</p>
<p class="calibre2">The most common tasks of unsupervised machine learning are defined as follows:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Clustering (or cluster analysis)</strong>: Clustering is used to identify and group objects that are more similar to each other when compared to items in other potential groups or clusters. The comparison is done by using some metric present in the features of the data.</li>
<li class="calibre11"><strong class="calibre1">Anomaly detection</strong>: It is used to flag entities that do not fall within an expected pattern, as defined by the other items in the dataset. They are important as, in general, anomalies represent some kind of a problem, such as bank or tax fraud, a software bug, or a medical condition.</li>
</ul>
<p class="calibre2">In the remainder of this chapter, we'll focus exclusively on clustering—a very useful and valuable unsupervised machine learning task. We'll take a closer look at the theory behind clustering and then we'll implement an unsupervised machine learning project using the San Francisco business data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clustering</h1>
                </header>
            
            <article>
                
<p class="calibre2">As you've probably come to realize by now, when it comes to data science, there are almost always multiple avenues to attack a problem. At the algorithmic level, depending on the particularities of the data and the specific problem we're trying to solve, we'll usually have more than one option. A wealth of choices is usually good news as some algorithms can produce better results than others, depending on the specifics. Clustering is no exception—a few well-known algorithms are available, but we must understand their strengths and their limitations in order to avoid ending up with irrelevant clusters.</p>
<p class="calibre2">Scikit-learn, the famous Python machine learning library, drives the point home by using a few toy datasets. The datasets produce easily recognizable plots, making it easy for a human to identify the clusters. However, applying unsupervised learning algorithms will lead to strikingly different results—some of them in clear contradiction of what our human pattern recognition abilities would tell us:</p>
<div class="CDPAlignCenter1"><img src="assets/5bf78baa-39c0-473a-b027-2d00f62f0e18.png" class="calibre108"/></div>
<p class="calibre2">The preceding four plots illustrate the following:</p>
<ol class="calibre13">
<li class="calibre11">Two concentrical circular clusters</li>
<li class="calibre11">Two curves</li>
<li class="calibre11">Three blobs</li>
<li class="calibre11">A square made of uniformly distributed values resulting in a single cluster</li>
</ol>
<p class="calibre2">Color coding the clusters would result in the following diagram:</p>
<p class="CDPAlignCenter"><img src="assets/7124b5d9-59bd-4e93-b76b-11f90c8b79c3.png" class="calibre109"/></p>
<p class="calibre2">Using our innate pattern recognition abilities, we can easily see the well-defined clusters.</p>
<p class="calibre2">If the clusters are obvious enough for you, you might be surprised to discover that, when it comes to machine learning, things are not that clear-cut. Here is how some of the most common algorithms interpret the data (the following diagram and all of the details of the tests are available on the Scikit-learn website at <a href="http://scikit-learn.org" class="calibre9"><span>http://scikit-learn.org</span></a>):</p>
<p class="CDPAlignCenter"><img src="assets/5a6a4e9f-6779-4967-80c9-abfefe822dcd.png" class="calibre110"/></p>
<p class="calibre2">The diagram shows the color-coded clusters together with the computing times for eight well-known algorithms—MiniBatchKMeans, Affinity Propagation, Mean Shift, Spectral Clustering, Ward, Agglomerative Clustering, DBSCAN, and Birch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data analysis of the San Francisco business</h1>
                </header>
            
            <article>
                
<p class="calibre2">As our learning project for this chapter, let's imagine that we have been hired by a new client, the famous ACME Recruiting. They are a major HR company and want to open a new office in San Francisco. They are working on a very ambitious marketing strategy to accompany their launch. ACME wants to run outdoor campaigns via billboards; employ transit advertising with posters on buses, taxis, and bikes; and use direct mail by sending leaflets via snail mail.</p>
<p class="calibre2">They're targeting business clients and came to us to help them with two things:</p>
<ul class="calibre10">
<li class="calibre11">They want to know the best areas to run their campaign where to place the billboards, on what bus lines to place the ads and to what mail addresses to send the leaflets.</li>
<li class="calibre11">They would like to understand the market's recruiting needs so that they can get in touch with professionals with the required qualifications.</li>
</ul>
<p class="calibre2">Our plan is to use a database with information about the companies registered in San Francisco and employ unsupervised learning, in the form of clustering, to detect the areas with the highest density of companies. That's where ACME should spend their advertising dollars. Once we identify the companies they'll target, we'll be able to see what domain of activity they have. Our client will use this information to assess their recruiting needs.</p>
<p class="calibre2">Data-wise, we're off to a good start, as the city of San Francisco makes a lot of interesting data openly available at <span class="calibre5"><a href="https://data.sfgov.org" class="calibre9">https://data.sfgov.org</a></span>. Browsing through the website, we can find a database of registered tax-paying businesses. It provides a wealth of information including the name, address, opening and closing dates (if the business is closed), location geo-coordinates (and sometimes the name of the neighborhood), and more.</p>
<p class="calibre2">You can download the file at <span class="calibre5"><a href="https://data.sfgov.org/Economy-and-Community/Map-of-Registered-Business-Locations/ednt-jx6u" class="calibre9">https://data.sfgov.org/Economy-and-Community/Map-of-Registered-Business-Locations/ednt-jx6u</a></span> by clicking the <span class="calibre5">Export</span> button in the toolbar, or use the direct download URL: <span class="calibre5"><a href="https://data.sfgov.org/api/views/ednt-jx6u/rows.csv?accessType=DOWNLOAD" class="calibre9">https://data.sfgov.org/api/views/ednt-jx6u/rows.csv?accessType=DOWNLOAD</a></span><span class="calibre5">.</span></p>
<p class="calibre2">However, I strongly suggest using the file provided in this chapter's support files, just to make sure that we use exactly the same data and get the same results if you follow through. Please download it from <a href="https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter08/data/Map_of_Registered_Business_Locations.csv.zip" class="calibre9">https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter08/data/Map_of_Registered_Business_Locations.csv.zip</a>.</p>
<p class="calibre2">For each entry, we also get the <strong class="calibre4"><span class="calibre5">North American Industry Classification System</span></strong> (<strong class="calibre4">NAICS</strong>) Code, which is (the standard used by Federal statistical agencies in classifying business establishments for the purpose of collecting, analyzing, and publishing statistical data related to the U.S. business economy). This is important as we'll use it to identify the top most common types of businesses, which will help our client attract relevant candidates.</p>
<p class="calibre2">In our dataset, the NAICS code is indicated as a range, for example, <span class="calibre5">4400–4599</span>. Fortunately, we also get the name of the corresponding sector of activity. In this example, <span class="calibre5">4400–4599</span> stands for <em class="calibre16">retail trade</em>.</p>
<p class="calibre2">It's time to load the data and slice and dice! By now, I'm sure you know the drill:</p>
<pre class="calibre17"><strong class="calibre1"><span>julia&gt; using CSV, DataFrames</span>  
julia&gt; df = CSV.read("Map_of_Registered_Business_Locations.csv")</strong> </pre>
<p class="calibre2">Using <kbd class="calibre12"><span>describe(df)</span></kbd> gives us a treasure trove of information about each column. I'm including just <kbd class="calibre12">nunique</kbd> and <kbd class="calibre12">nmissing</kbd> in the next screenshot, for the sake of brevity, but feel free to check the data in more detail as an exercise:</p>
<p class="CDPAlignCenter"><img src="assets/5377007e-7718-48d2-8736-afc2d4947f2c.png" class="calibre111"/></p>
<p class="calibre2">Check the number and percentage of <span class="calibre5">missing</span> values (under the <kbd class="calibre12">nmissing</kbd> column) and the number of unique values (as <kbd class="calibre12">nunique</kbd>). We can see that, for the <kbd class="calibre12"><span>Location Id</span></kbd> column, we get <kbd class="calibre12">222871</kbd> unique values and zero missing entries. The number of unique location IDs is equal to the number of rows in the dataset:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; size(df, 1) 
222871 </strong> </pre>
<p class="calibre2">Moving on, <kbd class="calibre12">Ownership Name</kbd> stands for the entity that registered the business (either a person or another company) while <kbd class="calibre12"><span>DBA Name</span></kbd> represents the name of the business itself. For both of these, we can see that <kbd class="calibre12"><span>Number Unique</span></kbd> is smaller than <kbd class="calibre12"><span>Location Id</span></kbd>, meaning that some companies are owned by the same entities—and that some companies will have the same name. Looking further at <kbd class="calibre12"><span>Street Address</span></kbd>, it turns out that a large number of companies share the location with other businesses (156,658 unique addresses for <kbd class="calibre12">222871</kbd> companies). Finally, we can see that we have <kbd class="calibre12"><span>City</span></kbd>, <kbd class="calibre12"><span>State</span></kbd>, and <kbd class="calibre12"><span>Zipcode</span></kbd> information for almost all of our records.</p>
<p class="calibre2">The dataset also provides information about the date when a business was registered (<kbd class="calibre12"><span>Business Start Date</span></kbd>), closed (<kbd class="calibre12"><span>Business End Date</span></kbd>), and when it started and finished operating at that location (<kbd class="calibre12"><span>Location Start Date</span></kbd> and <kbd class="calibre12"><span>Location End Date</span></kbd> respectively). There are more details, but they are mostly irrelevant for our analysis, such as <kbd class="calibre12"><span>Parking Tax</span></kbd>, <kbd class="calibre12"><span>Transient Occupancy Tax</span></kbd>, and <kbd class="calibre12">LIC Code</kbd> data (missing for over 95% of the records) and the <kbd class="calibre12"><span>Supervisor District</span></kbd>, <kbd class="calibre12"><span>Neighborhoods Analysis Boundaries</span></kbd>, and <kbd class="calibre12"><span>Business Corridor</span></kbd> information (the business corridor data is missing <span class="calibre5">in 99.87% of cases though</span>).</p>
<p class="calibre2">It's time to clean up our data and get it ready for analysis!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data wrangling with query</h1>
                </header>
            
            <article>
                
<p class="calibre2">So far, we've seen how to manipulate <kbd class="calibre12"><span>DataFrame</span></kbd> instances using the <kbd class="calibre12"><span>DataFrames</span></kbd> API. I'm sure that you're by now aware that we can remove uninteresting columns by using <kbd class="calibre12"><span>delete!(df::DataFrame, column_name::Symbol)</span></kbd>, for instance. You may remember from the previous chapter that you can filter a <kbd class="calibre12">DataFrame</kbd> instance using the square brackets notation in combination with the <span class="calibre5"><em class="calibre16">dot </em>element-wise operations, such as  in the following example:</span></p>
<pre class="calibre17"><strong class="calibre1">julia&gt; df[df[Symbol("Parking Tax")] .== true, :][1:10, [Symbol("DBA Name"), Symbol("Parking Tax")]]</strong> </pre>
<p class="calibre2">The previous snippet will return the top 10 rows (the <kbd class="calibre12">DBA Name</kbd> and <kbd class="calibre12">Parking Tax</kbd> columns only) where the business pays parking tax:</p>
<p class="CDPAlignCenter"><img src="assets/63b2cb5f-2e06-496a-b829-998e916afde3.png" class="calibre112"/></p>
<p class="calibre2">Now, if you're thinking that Julia spoils us with beautiful syntax and great readability and that the preceding has neither—well, you'd be right! The previous syntax, although usable, can definitely be improved. And I bet you won't be too surprised to hear that Julia's package ecosystem already provides better ways of wrangling <kbd class="calibre12">DataFrames</kbd>. Enter <kbd class="calibre12"><span>Query</span></kbd>!</p>
<p class="calibre2">Query is a package for querying Julia data. It works with a multitude of data sources, including Array, DataFrame, CSV, SQLite, ODBC, and others. It provides filter, project, join, and group functionality, and it's heavily inspired by Microsoft's <strong class="calibre4">Language Integrated Query</strong> (<strong class="calibre4">LINQ</strong>). If this doesn't mean a lot to you, don't worry; you'll see it in action right away.</p>
<p class="calibre2">Here is how the preceding operation would be refactored to use query in order to filter out the businesses that pay parking tax:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from i in df begin 
           @where i[Symbol("Parking Tax")] == true 
           @select i 
           @collect DataFrame 
       end</strong></pre>
<p class="calibre2">If you're familiar with SQL, you can easily recognize the familiar language query constructs, <kbd class="calibre12"><span>from</span></kbd>, <kbd class="calibre12"><span>where</span></kbd>, and <kbd class="calibre12"><span>select</span></kbd>. That's powerful!</p>
<p class="calibre2">However, having to use this verbose syntax to convert column names such as <kbd class="calibre12">Parking Tax</kbd> into symbols in order to access our data is inconvenient. Before we begin, we'd be better off renaming the columns to be more symbol-friendly and replacing the spaces with underscores. We'll use the <kbd class="calibre12">DataFrames.rename!</kbd> function in combination with a comprehension:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; rename!(df, [n =&gt; replace(string(n), " "=&gt;"_") |&gt; Symbol for n in names(df)]) </strong></pre>
<p class="calibre2">The <kbd class="calibre12">rename!</kbd> function accepts a <kbd class="calibre12">DataFrame</kbd> and an <kbd class="calibre12">Array{Pair}</kbd> in the form <kbd class="calibre12">:current_column_name =&gt; :new_current_name</kbd>. We use the comprehension to build the array, and we do this by iterating over each current column name (returned by <kbd class="calibre12">names(df)</kbd>), converting the resulting symbol into a string, replacing <kbd class="calibre12">" "</kbd> with <kbd class="calibre12">"_"</kbd> and then converting the string back to a symbol.</p>
<p class="calibre2">Now we can use the more succinct dot notation with query, so the preceding snippet will look like this:</p>
<pre class="calibre17">@from i in df begin 
    @where i.Parking_Tax == true 
    @select i 
    @collect DataFrame 
end </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Metaprogramming in Julia</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you noticed the <kbd class="calibre12"><span>@</span></kbd> sign prefixing the various query parts in the preceding snippet, don't worry, it's not a typo. The <kbd class="calibre12"><span>@</span></kbd> prefix represents a <span class="calibre5">macro</span>—which introduces a very powerful programming technique called <span class="calibre5"><strong class="calibre4">metaprogramming</strong></span>.</p>
<p class="calibre2">If you haven't heard about it before, it basically means that a program has the ability to read, analyse, and transform, and even modify itself while running. Some languages, called <span class="calibre5"><strong class="calibre4">homoiconic</strong></span>, come with very powerful metaprogramming facilities. In homoiconic languages, the program itself is internally represented as a data structure that's available to the program and can be manipulated. Lisp is the prototypical homoiconic programming language, and for this reason, this kind of metaprogramming is done through Lisp-style macros. They work with the code's representation and are different from preprocessor macros of C and C++ fame, where the text files containing the code are manipulated before parsing and evaluation.</p>
<p class="calibre2">Julia, inspired to a certain degree by Lisp, is also a homoiconic language. Hence, for metaprogramming in Julia, we need to understand two key aspects—the representation of the code by means of expressions and symbols and the manipulation of the code using macros. If we see the execution of a Julia program as a sequence of steps, metaprogramming kicks in and modifies the code after the parsing step, but before the code is evaluated by the compiler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about symbols and expressions in metaprogramming</h1>
                </header>
            
            <article>
                
<p class="calibre2">Understanding metaprogramming is not easy, so don't panic if it doesn't come naturally from the start. One of the reasons for this, I think, is that it takes place at a level of abstraction higher than what we're used to with regular programming. I'm hoping that opening the discussion with symbols will make the introduction less abstract. We've used symbols extensively throughout this book, especially as arguments for the various functions. They look like this—<kbd class="calibre12"><span>:x</span></kbd> or <kbd class="calibre12"><span>:scientific</span></kbd> or <kbd class="calibre12"><span>:Celsius</span></kbd>. As you may have noticed, a symbol represents an identifier and we use it very much like a constant. However, it's more than that. It represents a piece of code that, instead of being evaluated as the variable, is used to refer to a variable itself.</p>
<p class="calibre2">A good analogy for understanding the relationship between a symbol and a variable has to do with the words in a phrase. Take for example the sentence: <em class="calibre16">Richard is tall</em>. Here, we understand that <em class="calibre16">Richard </em>is the name of a person, most likely a man. And Richard, the person, is tall. However, in the sentence: <em class="calibre16">Richard has seven letters</em>,<em class="calibre16"> </em>it is obvious that now we aren't talking about Richard the person. It wouldn't make too much sense to assume that Richard the person has seven letters. We are talking about the word <em class="calibre16">Richard </em>itself.</p>
<p class="calibre2">The equivalent, in Julia, of the first sentence (<em class="calibre16">Richard is tall</em>) would be <kbd class="calibre12"><span>julia&gt; x</span></kbd>. Here, <kbd class="calibre12"><span>x</span></kbd> is immediately evaluated in order to produce its value. If it hasn't been defined, it will result in an error, shown as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x 
ERROR: UndefVarError: x not defined</strong> </pre>
<p class="calibre2">Julia's symbols mimic the second sentence, where we talk about the word itself. In English, we wrap the word in single quotes, <span class="calibre5">'Richard'</span>, to indicate that we're not referring to a person but to the word itself. In the same way, in Julia, we prefix the variable name with a column, <kbd class="calibre12"><span>:x</span></kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; :x 
:x </strong></pre>
<pre class="calibre17"><strong class="calibre1">julia&gt; typeof(:x) 
Symbol </strong></pre>
<p class="calibre2">Hence, the column <kbd class="calibre12"><span>:</span></kbd> prefix is an operator that stops the evaluation. An unevaluated expression can be evaluated on demand by using the <kbd class="calibre12"><span>eval()</span></kbd> function or the <kbd class="calibre12"><span>@eval</span></kbd> macro, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; eval(:x) 
ERROR: UndefVarError: x not defined</strong> </pre>
<p class="calibre2">But we can go beyond symbols. We can write more complex <span class="calibre5">symbol-like</span> statements, for example,<kbd class="calibre12"><span>:(x = 2)</span></kbd>. This works a lot like a <span class="calibre5">symbol</span> but it is, in fact, an <span class="calibre5"><kbd class="calibre12">Expr</kbd> type</span>, which stands for <span class="calibre5">expression</span>. The expression, like any other <span class="calibre5">type</span>, can be referenced through variable names and, like symbols, they can be evaluated:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; assign = :(x = 2) 
:(x = 2) </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; eval(assign) 
2 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; x 
2</strong> </pre>
<p class="calibre2">The preceding snippet demonstrates that we can reference an <kbd class="calibre12"><span>Expr</span></kbd> type with the <kbd class="calibre12"><span>assign</span></kbd> variable and then <kbd class="calibre12"><span>eval</span></kbd> it. Evaluation produces side effects, the actual value of the variable <kbd class="calibre12"><span>x</span></kbd> now being <kbd class="calibre12"><span>2</span></kbd>.</p>
<p class="calibre2">Even more powerful, since <kbd class="calibre12"><span>Expr</span></kbd> is a <span class="calibre5">type</span>, it has properties that expose its internal structure:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; fieldnames(typeof(assign)) 
(:head, :args) </strong></pre>
<p class="calibre2">Every <kbd class="calibre12"><span>Expr</span></kbd> object has two fields—<kbd class="calibre12"><span>head</span></kbd> representing its kind and <kbd class="calibre12"><span>args</span></kbd> standing for the arguments. We can view the internals of <kbd class="calibre12"><span>Expr</span></kbd> by using the <kbd class="calibre12"><span>dump()</span></kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dump(assign)</strong><br class="title-page-name"/><strong class="calibre1">Expr</strong><br class="title-page-name"/><strong class="calibre1">head: Symbol =</strong><br class="title-page-name"/><strong class="calibre1">args: Array{Any}((2,))</strong><br class="title-page-name"/><strong class="calibre1">1: Symbol x</strong><br class="title-page-name"/><strong class="calibre1">2: Int64 2 </strong> </pre>
<p class="calibre2">This leads us to even more important discoveries. First, it means that we can programmatically manipulate <kbd class="calibre12"><span>Expr</span></kbd> through its properties:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; assign.args[2] = 3 
3 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; eval(assign) 
3 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; x 
3</strong> </pre>
<p class="calibre2">Our expression is no longer <kbd class="calibre12"><span>:(x = 2)</span></kbd>; it's now <kbd class="calibre12"><span>:(x = 3)</span></kbd>. By manipulating the <kbd class="calibre12"><span>args</span></kbd> of the <kbd class="calibre12"><span>assign</span></kbd> expression, the value of <kbd class="calibre12"><span>x</span></kbd> is now <kbd class="calibre12"><span>3</span></kbd>.</p>
<p class="calibre2">Second, we can programmatically create new instances of <kbd class="calibre12"><span>Expr</span></kbd> using the type's constructor:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; assign4 = Expr(:(=), :x, 4) :(x = 4) </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; eval(assign4) 4</strong><br class="title-page-name"/><strong class="calibre1"> julia&gt; x 4</strong> </pre>
<p class="calibre2">Please notice here that we wrapped the equals sign (<kbd class="calibre12">=</kbd>) in parenthesis to designate an expression, as Julia gets confused otherwise, thinking we want to perform an assignment right there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Quoting expressions</h1>
                </header>
            
            <article>
                
<p class="calibre2">The previous procedure, in which we wrap an expression within <kbd class="calibre12"><span>:(...)</span></kbd> in order to create <kbd class="calibre12"><span>Expr</span></kbd> objects, is called <span class="calibre5"><strong class="calibre4">quoting</strong></span>. It can also be done using quote blocks. Quote blocks make quoting easier as we can pass <em class="calibre16">regular-looking </em>code into them (as opposed to translating everything in to symbols), and supports quoting multiple lines of code in order to build randomly complex expressions:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; quote 
           y = 42 
           x = 10 
       end</strong><br class="title-page-name"/><strong class="calibre1"> 
julia&gt; eval(ans) 
10</strong><br class="title-page-name"/><strong class="calibre1"> 
julia&gt; y 
42</strong><br class="title-page-name"/><strong class="calibre1"> 
julia&gt; x 
10</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpolating strings</h1>
                </header>
            
            <article>
                
<p class="calibre2">Just like with string interpolation, we can reference variables within the expressions:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; name = "Dan" 
"Dan" </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; greet = :("Hello " * $name) 
:("Hello " * "Dan") </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; eval(greet) 
"Hello Dan"</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Macros</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now, we finally have the knowledge to understand macros. They are language constructs, which are executed after the code is parsed, but before it is evaluated. It can optionally accept a tuple of arguments and must return an <kbd class="calibre12"><span>Expr</span></kbd>. The resulting <kbd class="calibre12">Expression</kbd> is directly compiled, so we don't need to call <kbd class="calibre12"><span>eval()</span></kbd> on it.</p>
<p class="calibre2">For example, we can implement a configurable version of the previous <kbd class="calibre12"><span>greet</span></kbd> expression as a macro:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; macro greet(name) 
           :("Hello " * $name) 
       end 
@greet (macro with 1 method)</strong><br class="title-page-name"/><strong class="calibre1">julia&gt; @greet("Adrian") 
"Hello Adrian"</strong> </pre>
<p class="calibre2">As per the snippet, macros are defined using the <kbd class="calibre12"><span>macro</span></kbd> keyword and are invoked using the <kbd class="calibre12"><span>@...</span></kbd> syntax. The brackets are optional when invoking macros, so we could also use <kbd class="calibre12">@greet "Adrian"</kbd>.</p>
<p class="calibre2">Macros are very powerful language constructs that allow parts of the code to be customized before the full program is run. The official Julia documentation has a great example to illustrate this behavior:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; macro twostep(arg) 
         println("I execute at parse time. The argument is: ", arg) 
         return :(println("I execute at runtime. The argument is: ", $arg)) 
       end 
@twostep (macro with 1 method)</strong> </pre>
<p class="calibre2">We define a <span class="calibre5">macro</span> called <kbd class="calibre12"><span>twostep</span></kbd>, which has a body that calls the <span class="calibre5"><kbd class="calibre12">println</kbd></span> function to output text to the console. It returns an expression which, when evaluated, will also output a piece of text via the same <kbd class="calibre12"><span>println</span></kbd> function.</p>
<p class="calibre2">Now we can see it in action:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ex = macroexpand(@__MODULE__, :(@twostep :(1, 2, 3))); 
I execute at parse time. The argument is: $(Expr(:quote, :((1, 2, 3))))</strong> </pre>
<p class="calibre2">The snippet shows a call to <kbd class="calibre12"><span>macroexpand</span></kbd>, which takes as an argument the module in which to expand the expression (in our case, <kbd class="calibre12">@__MODULE__</kbd> stands for the current module) and an expression that represents a macro invocation. The call to <kbd class="calibre12">macroexpand</kbd> converts (expands) the macro into its resulting expressions. The output of the <kbd class="calibre12"><span>macroexpand</span></kbd> call is suppressed by appending <kbd class="calibre12"><span>;</span></kbd> at the end of the line, but the resulting expression is still safely stored in <kbd class="calibre12"><span>ex</span></kbd>. Then, we can see that the expanding of the macro (its parsing) takes place because the <kbd class="calibre12">I execute at parse time message</kbd> is output. Now look what happens when we evaluate the expression, <kbd class="calibre12"><span>ex</span></kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; eval(ex) 
I execute at runtime. The argument is: (1, 2, 3)</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">I execute at runtime</kbd> message is outputted, but not the <kbd class="calibre12">I execute at parse time</kbd> message. This is a very powerful thing. Imagine that output instead of a simple text output if we'd had some very computationally intensive or time-consuming operations. In a simple function, we'd have to run this code every time, but with a macro, this is done only once, at parse time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Closing words about macros</h1>
                </header>
            
            <article>
                
<p class="calibre2">Besides they're very powerful, macros are also very convenient. They can provide a lot of functionality with minimal overhead and can simplify the invocation of functions that take expressions as arguments. For example, <kbd class="calibre12"><span>@time</span></kbd> is a very useful macro that executes an <kbd class="calibre12">Expression</kbd> while measuring the execution time. And the great thing is that we can pass the argument expression as <em class="calibre16">regular</em> code, instead of building the <kbd class="calibre12"><span>Expr</span></kbd> by hand:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @time rand(1000); 
  0.000007 seconds (5 allocations: 8.094 KiB)</strong> </pre>
<p class="calibre2">Macros—and metaprogramming in general—are powerful concepts that require whole books to discuss at length. We must stop here in order to get back to our machine learning project. ACME Recruiting is eagerly waiting for our findings. I recommend going over the official documentation at <span class="calibre5"><a href="https://docs.julialang.org/en/stable/manual/metaprogramming/" class="calibre9">https://docs.julialang.org/en/stable/manual/metaprogramming/</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Beginning with Query.jl basics</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">Query</kbd> package can be added in the standard way—<kbd class="calibre12"><span>pkg&gt; add Query</span></kbd>. Once you bring it into scope using <kbd class="calibre12">Query</kbd>, it makes a rich API available for querying Julia data sources, <kbd class="calibre12"><span>DataFrames</span></kbd> being the most common source. A query is initiated using the <kbd class="calibre12"><span>@from</span></kbd> macro.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@from</h1>
                </header>
            
            <article>
                
<p class="calibre2">The general structure of a query is as follows:</p>
<pre class="calibre17">@from var in data_source begin 
    # query statements here 
end </pre>
<p class="calibre2">Within the <kbd class="calibre12"><span>begin...end</span></kbd> block, <kbd class="calibre12"><span>var</span></kbd> represents a row in the <kbd class="calibre12"><span>data_source</span></kbd>. The query statements are given one per line and can include any combination of available query commands, such as <kbd class="calibre12"><span>@select</span></kbd>, <kbd class="calibre12"><span>@orderby</span></kbd>, <kbd class="calibre12"><span>@join</span></kbd>, <kbd class="calibre12"><span>@group</span></kbd>, and <kbd class="calibre12"><span>@collect</span></kbd>. Let's take a closer look at the most important ones.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@select</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12"><span>@select</span></kbd> query command, similar to its <kbd class="calibre12">SQL <span>SELECT</span></kbd> counterpart, indicates which values are to be returned. Its general syntax is <kbd class="calibre12"><span>@select condition</span></kbd>, where <kbd class="calibre12">condition</kbd> can be any <kbd class="calibre12">Julia</kbd> expression. Most commonly, we'll want to return the whole row and, in this case, we'll just pass <kbd class="calibre12">var</kbd> itself. For instance, let's create a new <kbd class="calibre12">DataFrame</kbd> to hold a shopping list:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; shopping_list = DataFrame(produce=["Apples", "Milk", "Bread"], qty=[5, 2, 1])</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<div class="CDPAlignCenter1"><img src="assets/9aa23832-92c7-4f21-9940-cf16ff6b12ba.png" class="calibre113"/></div>
<p class="calibre2">A cool (geeky!) and handy shopping list.</p>
<p class="calibre2">We can <kbd class="calibre12"><span>@select</span></kbd> the whole row with the following:</p>
<pre class="calibre17">@from p in shopping_list begin 
    @select p 
end </pre>
<p class="calibre2">It's not very useful, as this basically returns the whole <kbd class="calibre12">DataFrame</kbd>, but we can also reference a column using <kbd class="calibre12">dot</kbd> notation, for example, <kbd class="calibre12"><span>p.produce</span></kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_list begin 
           @select p.produce 
       end 
3-element query result 
 "Apples" 
 "Milk" 
 "Bread"</strong> </pre>
<p class="calibre2">Given that <kbd class="calibre12"><span>@select</span></kbd> accepts any random <kbd class="calibre12">Julia</kbd> expression, we're free to manipulate the data as we see fit:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_list begin 
           @select uppercase(p.produce), 2p.qty 
       end 
3-element query result 
 ("APPLES", 10) 
 ("MILK", 4) 
 ("BREAD", 2)</strong> </pre>
<p class="calibre2">In the preceding snippet, we select the uppercase <kbd class="calibre12">produce</kbd> and two times the <kbd class="calibre12">qty</kbd>.</p>
<p class="calibre2">However, a better approach is to return <kbd class="calibre12"><span>NamedTuple</span></kbd>, using the special query curly brackets syntax:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_list begin 
           @select { produce = uppercase(p.produce), qty = 2p.qty } 
       end</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<div class="CDPAlignCenter1"><img src="assets/52c58edd-0b81-4afd-90c0-5778a62abd0a.png" class="calibre114"/></div>
<p class="calibre2">Here, we pass both the keys and the values for <kbd class="calibre12"><span>NamedTuple</span></kbd>, but they're not mandatory. They are, however, useful if we want properly named columns (and who doesn't, right?):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_list begin 
           @select { uppercase(p.produce), 2p.qty } 
       end</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<div class="CDPAlignCenter1"><img src="assets/073cc81e-d228-4770-9373-e322e9a9153c.png" class="calibre115"/></div>
<p class="calibre2">Without the explicit labels, <kbd class="calibre12">query</kbd> will assign column names such as <kbd class="calibre12"><span>__1__</span></kbd>, <kbd class="calibre12"><span>__2__</span></kbd>, and so on. It's not very readable!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@collect</h1>
                </header>
            
            <article>
                
<p class="calibre2">You might've noticed in the previous screenshots that the type of the returned value was <kbd class="calibre12"><span>query result</span></kbd>. A query will return an iterator that can be further used to loop over the individual elements of the result set. But we can use the <kbd class="calibre12"><span>@collect</span></kbd> statement to materialize the result into a specific data structure, most commonly <kbd class="calibre12"><span>Array</span></kbd> or <kbd class="calibre12"><span>DataFrame</span></kbd>. This is shown as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_list begin 
           @select { PRODUCE = uppercase(p.produce), double_qty = 2p.qty } 
           @collect 
       end</strong> </pre>
<p class="calibre2">We get the following:</p>
<div class="CDPAlignCenter1"><img src="assets/6e2749c8-5626-4d7d-b967-496d2a38f8c8.png" class="calibre116"/></div>
<p class="calibre2">By default, <kbd class="calibre12"><span>@collect</span></kbd> will produce an <kbd class="calibre12"><span>Array</span></kbd> of <kbd class="calibre12"><span>NamedTuple</span></kbd> elements. But we can pass it an extra argument for the data type we desire:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_list begin 
           @select {PRODUCE = uppercase(p.produce), double_qty = 2p.qty} 
           @collect DataFrame 
       end</strong> </pre>
<p class="calibre2"><span class="calibre5">The output looks like this:</span></p>
<div class="CDPAlignCenter1"><img src="assets/7252e5e9-f2be-40bd-9438-bf942ad5bca9.png" class="calibre117"/></div>
<p class="calibre2">Our result is now a <kbd class="calibre12"><span>DataFrame</span></kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@where</h1>
                </header>
            
            <article>
                
<p class="calibre2">One of the most useful commands is <kbd class="calibre12"><span>@where</span></kbd>, which allows us to filter a data source so that only the elements that satisfy the condition are returned. Similar to <kbd class="calibre12"><span>@select</span></kbd>, the condition can be any arbitrary <kbd class="calibre12">Julia</kbd> expression:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_list begin 
           @where p.qty &lt; 2 
           @select p 
           @collect DataFrame 
       end </strong></pre>
<p class="calibre2"><span class="calibre5">We get the following output:</span></p>
<div class="CDPAlignCenter1"><img src="assets/f4393176-520b-46ea-91e0-e895d15310f9.png" class="calibre118"/></div>
<p class="calibre2">Only bread has a <kbd class="calibre12">qty</kbd> smaller than <kbd class="calibre12">2</kbd>.</p>
<p class="calibre2">Filtering can be made even more powerful by means of range variables. These act like new variables belonging to the <kbd class="calibre12">query</kbd> expression and can be introduced using the <kbd class="calibre12"><span>@let</span></kbd> macro:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_list begin 
           @let weekly_qty = 7p.qty 
           @where weekly_qty &gt; 10 
           @select { p.produce, week_qty=weekly_qty } 
           @collect DataFrame 
       end</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<div class="CDPAlignCenter1"><img src="assets/163d72fb-c86d-4a01-96a5-e90290ed56a7.png" class="calibre119"/></div>
<p class="calibre2">Here, you can see how, within the <kbd class="calibre12">begin...end</kbd> block, we defined a local variable called <kbd class="calibre12">weekly_qty</kbd> with a value equal to <kbd class="calibre12">7 * p.qty</kbd>. We used the <kbd class="calibre12">@let</kbd> macro to introduce new variables. In the next line, we used it to filter out the rows that have a <kbd class="calibre12">weekly_qty</kbd> smaller than <kbd class="calibre12">10</kbd>. And then finally, we selected it and collected it into a <kbd class="calibre12">DataFrame</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@join</h1>
                </header>
            
            <article>
                
<p class="calibre2">Let's make things even more interesting:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; products_info = DataFrame(produce = ["Apples", "Milk", "Bread"], price = [2.20, 0.45, 0.79], allergenic = [false, true, true])</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<div class="CDPAlignCenter1"><img src="assets/ee9d6f9d-db29-44dd-8eb5-46c6756025e6.png" class="calibre120"/></div>
<p class="calibre2">We instantiate a new <kbd class="calibre12"><span>DataFrame</span></kbd>, called <kbd class="calibre12"><span>products_info</span></kbd>, which contains important information about items in our shopping list—their prices and whether or not they can be considered allergenic. We could use <kbd class="calibre12"><span>DataFrames.hcat!</span></kbd> to append some columns from <kbd class="calibre12"><span>products_info</span></kbd> to <kbd class="calibre12"><span>shopping_list</span></kbd>, but again, the syntax is not so nice and the approach is not that flexible. We've been spoiled by Julia and we like it that way! Fortunately, Query provides a <kbd class="calibre12"><span>@join</span></kbd> macro:</p>
<pre class="calibre17">shopping_info = @from p in shopping_list begin 
    @join pinfo in products_info on p.produce equals pinfo.produce 
    @select { p.produce, p.qty, pinfo.price, pinfo.allergenic } 
    @collect DataFrame 
end </pre>
<p class="calibre2">If you're familiar with SQL, the preceding snippet should be crystal clear. We execute a query from <kbd class="calibre12"><span>shopping_list</span></kbd> as <kbd class="calibre12"><span>p</span></kbd>, adding an inner join, <kbd class="calibre12"><span>@join</span></kbd>, with <kbd class="calibre12"><span>products_info</span></kbd> as <kbd class="calibre12"><span>pinfo</span></kbd>, on the condition that <kbd class="calibre12"><span>p.produce</span></kbd> equals <kbd class="calibre12"><span>pinfo.produce</span></kbd>. We basically put together the <kbd class="calibre12">produce</kbd> and <kbd class="calibre12">qty</kbd> columns from <kbd class="calibre12">shopping_list</kbd><span class="calibre5"><span class="calibre5"> </span></span><kbd class="calibre12">DataFrame</kbd> with the <kbd class="calibre12">price</kbd> and <kbd class="calibre12">allergenic</kbd> columns from <kbd class="calibre12">products_info</kbd>. The resulting <kbd class="calibre12">DataFrame</kbd> can now be referenced as <kbd class="calibre12"><span>shopping_info</span></kbd>:</p>
<div class="CDPAlignCenter1"><img src="assets/ba3ba9b7-2257-4995-84d9-d30da441fb1c.png" class="calibre121"/></div>
<p class="calibre2">The general syntax of a <kbd class="calibre12"><span>@join</span></kbd> command is as follow:</p>
<pre class="calibre17">@from var1 in datasource1 begin 
    @join var2 in datasource2 on var1.column equals var2.column  
end </pre>
<div class="packttip">Query provides two other variants of <kbd class="calibre24"><span>@join</span></kbd>: group join and left outer join. If you would like to read about them, please check the official documentation at <a href="http://www.queryverse.org/Query.jl/stable/querycommands.html#Joining-1" class="calibre19"><span>http://www.queryverse.org/Query.jl/stable/querycommands.html#Joining-1</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@group</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12"><span>@group</span></kbd> statement groups elements by some attribute:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in shopping_info begin 
           @group p.produce by p.allergenic 
           @collect 
       end 
2-element Array{Grouping{Bool,String},1}: 
 ["Apples"] 
 ["Milk", "Bread"] </strong> </pre>
<p class="calibre2">Not bad, but what we'd really like is to summarize the data. Query provides this under the name <kbd class="calibre12">split-apply-combine</kbd> (also known as, <kbd class="calibre12"><span>dplyr</span></kbd>). This requires an aggregation function that will be used to collapse the dataset based on the <kbd class="calibre12">Grouping</kbd> variable. If that's too abstract, an example will surely clear things up.</p>
<p class="calibre2">Say we want to get a count of allergenic items together with a comma-separated list of their names, so we know what to stay away from:</p>
<pre class="calibre17">@from p in shopping_info begin<br class="title-page-name"/>    @group p by p.allergenic into q<br class="title-page-name"/>    @select { allergenic = key(q),<br class="title-page-name"/>    count = length(q.allergenic),<br class="title-page-name"/>    produce = join(q.produce, ", ") }<br class="title-page-name"/>    @collect DataFrame<br class="title-page-name"/>end  </pre>
<p class="calibre2">We can see in this snippet how we do the grouping <span class="calibre5">into</span> the <kbd class="calibre12"><span>q</span></kbd> variable and then pass the aggregation function, <kbd class="calibre12"><span>length</span></kbd>, to get a count of the values of the <span class="calibre5">allergenic</span> column. We then use the <kbd class="calibre12"><span>join</span></kbd> function to concatenate the values in the <kbd class="calibre12"><span>produce</span></kbd> column.</p>
<p class="calibre2">The result will be a two-row <kbd class="calibre12"><span>DataFrame</span></kbd>:</p>
<p class="CDPAlignCenter"><img src="assets/2b3e656a-eb92-41c2-8e8b-691f6cabab33.png" class="calibre122"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@orderby</h1>
                </header>
            
            <article>
                
<p class="calibre2">Query also provides a sorting macro named <kbd class="calibre12"><span>@orderby</span></kbd>. It takes a list of attributes upon which to apply the sorting. Similar to SQL, the order is ascending by default, but we can change that by using the <span class="calibre5"><kbd class="calibre12">descending</kbd></span> function.</p>
<p class="calibre2">Given our previously defined <span class="calibre5"><kbd class="calibre12">products_info</kbd></span> <kbd class="calibre12"><span>DataFrame</span></kbd>, we can easily sort it as needed, for example, with the most expensive products first and then by product name:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @from p in products_info begin 
           @orderby descending(p.price), p.produce 
           @select p 
           @collect DataFrame 
        end</strong> </pre>
<p class="calibre2">The snippet shows how to employ <kbd class="calibre12"><span>@orderby</span></kbd> to sort the values in the source. Unsurprisingly, the resulting <kbd class="calibre12"><span>DataFrame</span></kbd> will be properly sorted with the most expensive products on top:</p>
<div class="CDPAlignCenter1"><img src="assets/a3ed77a4-067a-4959-b3b2-8931b7d40832.png" class="calibre123"/></div>
<p class="calibre2">All right, that was quite a detour! But now that we have knowledge of the great <kbd class="calibre12">Query</kbd> package, we're ready to efficiently slice and dice our data. Let's go!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing our data</h1>
                </header>
            
            <article>
                
<p class="calibre2">Our data cleaning plan is to only keep the businesses registered in San Francisco, CA, for which we have the address, zip code, NAICS code, and business location and which have not been closed (so they don't have a business end date) and have not moved away (don't have a location end date).</p>
<p class="calibre2">Using the <span class="calibre5"><kbd class="calibre12">DataFrame</kbd></span> API to apply the filters would be tedious. But with Query, it's a walk in the park:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add DataValues 
julia&gt; using DataValues 
julia&gt; clean_df = @from b in df begin </strong><br class="title-page-name"/><strong class="calibre1">    @where lowercase(b.City) == "san francisco" &amp;&amp; b.State == "CA" &amp;&amp;</strong><br class="title-page-name"/><strong class="calibre1">        ! isna(b.Street_Address) &amp;&amp; ! isna(b.Source_Zipcode) &amp;&amp;</strong><br class="title-page-name"/><strong class="calibre1">        ! isna(b.NAICS_Code) &amp;&amp; ! isna(b.NAICS_Code_Description) &amp;&amp;</strong><br class="title-page-name"/><strong class="calibre1">        ! isna(b.Business_Location) &amp;&amp;</strong><br class="title-page-name"/><strong class="calibre1">        occursin(r"\((.*), (.*)\)", get(b.Business_Location)) &amp;&amp;</strong><br class="title-page-name"/><strong class="calibre1">        isna(b.Business_End_Date) &amp;&amp; isna(b.Location_End_Date)</strong><br class="title-page-name"/><strong class="calibre1">    @select { b.DBA_Name, b.Source_Zipcode, b.NAICS_Code, </strong><br class="title-page-name"/><strong class="calibre1">        b.NAICS_Code_Description, b.Business_Location }</strong><br class="title-page-name"/><strong class="calibre1">    @collect DataFrame</strong><br class="title-page-name"/><strong class="calibre1">end</strong> </pre>
<p class="calibre2">We can see how <kbd class="calibre12"><span>@where</span></kbd> filters are applied, requiring that <kbd class="calibre12"><span>lowercase(b.City)</span></kbd> equals <kbd class="calibre12">"san francisco"</kbd> and that <span class="calibre5"><kbd class="calibre12">b.State</kbd></span> equals <kbd class="calibre12">"CA"</kbd>. Then, we use <kbd class="calibre12">! <span>isna</span></kbd> to make sure we only keep the rows where <kbd class="calibre12"><span>b.Street_Address</span></kbd>, <kbd class="calibre12"><span>b.Source_Zipcode</span></kbd>, <kbd class="calibre12"><span>b.NAICS_Code</span></kbd>, <kbd class="calibre12"><span>b.NAICS_Code_Description</span></kbd>, and <kbd class="calibre12"><span>b.Business_Location</span></kbd> are not missing. The <kbd class="calibre12">isna</kbd> function is provided by the <kbd class="calibre12">DataValues</kbd> package (which is used by Query itself) and that's why we're adding and using it.</p>
<p class="calibre2">We also make sure that <kbd class="calibre12"><span>b.Business_Location</span></kbd> matches a certain format that corresponds to geolocation coordinates. Finally, we make sure that, on the contrary, <span class="calibre5"><kbd class="calibre12">b.Business_End_Date</kbd></span> and <kbd class="calibre12"><span>b.Location_End_Date</span></kbd> are in fact missing.</p>
<p class="calibre2">Executing the query produces a new <kbd class="calibre12"><span>DataFrame</span></kbd> with almost 57,000 rows.</p>
<p class="calibre2">The next step is to take our <kbd class="calibre12"><span>clean_df</span></kbd> data and extract the geo-coordinates out of the <kbd class="calibre12"><span>Business_Location</span></kbd> column. Again, Query comes to the rescue:</p>
<pre class="calibre17"><strong class="calibre1">clean_df_geo = @from b in clean_df begin</strong><br class="title-page-name"/><strong class="calibre1">    @let geo = split(match(r"(\-?\d+(\.\d+)?),\s*(\-?\d+(\.\d+)?)",     </strong><br class="title-page-name"/><strong class="calibre1">                    get(b.Business_Location)).match, ", ")</strong><br class="title-page-name"/><strong class="calibre1">    @select {b.DBA_Name, b.Source_Zipcode, b.NAICS_Code,</strong><br class="title-page-name"/><strong class="calibre1">                    b.NAICS_Code_Description,</strong><br class="title-page-name"/><strong class="calibre1">                    lat = parse(Float64, geo[1]), long = parse(Float64, geo[2])}</strong><br class="title-page-name"/><strong class="calibre1">    @collect DataFrame</strong><br class="title-page-name"/><strong class="calibre1">end</strong> </pre>
<p class="calibre2">We make good use of the range variables feature (defined by <kbd class="calibre12"><span>@let</span></kbd>) to introduce a <kbd class="calibre12"><span>geo</span></kbd> variable, which uses <kbd class="calibre12"><span>match</span></kbd> to extract the latitude and longitude pairs from the <kbd class="calibre12"><span>Business_Location</span></kbd> data. Next, inside the <kbd class="calibre12"><span>@select</span></kbd> block, the two values in the <span class="calibre5">geo</span> array are converted in to proper <span class="calibre5">float</span> values and added to the resulting <span class="calibre5"><kbd class="calibre12">DataFrame</kbd>:</span></p>
<p class="CDPAlignCenter"><img src="assets/be644856-1437-46d8-a631-490fadafaa8a.png" class="calibre18"/></p>
<p class="calibre2">We're done! Our data is now neatly represented in our <span class="calibre5"><kbd class="calibre12">clean_df_geo</kbd></span><span class="calibre5"><span class="calibre5"> </span></span><kbd class="calibre12"><span>DataFrame</span></kbd>, containing the name of the business, zip code, NAICS code, NAICS code description, latitude, and longitude.</p>
<p class="calibre2">If we run <kbd class="calibre12"><span>describe(</span>clean_df_geo<span>)</span></kbd>, we'll see that we have 56,549 businesses with 53,285 unique names with only 18 NAICS code descriptions. We don't know how many zip codes the companies are spread across, but it's easy to find out:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; unique(clean_df_geo[:, :Source_Zipcode]) |&gt; length 
79 </strong></pre>
<p class="calibre2">Our businesses are registered within <kbd class="calibre12">79</kbd> zip codes in the city of San Francisco.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unsupervised machine learning with clustering</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia's package ecosystem provides a dedicated library for clustering. Unsurprisingly, it's called <strong class="calibre4">C<span class="calibre5">lustering</span></strong><span class="calibre5">.</span> <span class="calibre5">We can simply execute</span> <kbd class="calibre12"><span>pkg&gt; add Clustering</span></kbd> <span class="calibre5">to install it. The</span> <kbd class="calibre12">Clustering</kbd> <span class="calibre5">package implements a few common clustering algorithms—</span><span class="calibre5">k-means</span><span class="calibre5">,</span> <span class="calibre5">affinity propagation</span><span class="calibre5">,</span> <span class="calibre5">DBSCAN,</span> <span class="calibre5">and</span> <span class="calibre5">kmedoids</span><span class="calibre5">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The k-means algorithm</h1>
                </header>
            
            <article>
                
<p class="calibre2">The k-means algorithm is one of the most popular ones, providing a balanced combination of good results and good performance in a wide range of applications. However, one complication is that we're required to give it the number of clusters beforehand. More exactly, this number, called <span class="calibre5"><strong class="calibre4">k</strong></span> (hence the first letter of the name of the algorithm), represents the number of <span class="calibre5">centroids</span>. A <strong class="calibre4">centroid</strong> is a point that is representative of each cluster.</p>
<p class="calibre2">The <span class="calibre5">k-means</span> algorithm applies an iterative approach—it places the centroids using the algorithm defined by the seeding procedure, then it assigns each point to its corresponding centroid, the <span class="calibre5">mean</span> to which is closest. The algorithm stops on convergence, that is, when the point assignment doesn't change with a new iteration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Algorithm seeding</h1>
                </header>
            
            <article>
                
<p class="calibre2">There are a few ways to pick the centroids. Clustering provides three, one of which is <span class="calibre5">random</span> (labeled as the <span class="calibre5"><kbd class="calibre12">:rand</kbd></span> option in clustering), which randomly selects a subset of points as seeds (so all centroids are random). This is the default seeding strategy in classical <span class="calibre5">k-means</span>. There's also <span class="calibre5">k-means++</span>, a better variation proposed in 2007 by David Arthur and Sergei Vassilvitskii (labeled as <span class="calibre5"><kbd class="calibre12">:kmpp</kbd></span>), which picks one cluster center randomly, but then searches for the other centers in relation to the first one. The last available approach is centrality seeding (<span class="calibre5"><kbd class="calibre12">:kmcen</kbd></span>), which picks the samples with the highest centrality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding the areas with the most businesses</h1>
                </header>
            
            <article>
                
<p class="calibre2">In the previous section, we successfully cleaned our data, now neatly accessible in <span class="calibre5"><kbd class="calibre12">clean_df_geo</kbd></span><span class="calibre5"><span class="calibre5"> </span></span><kbd class="calibre12"><span>DataFrame</span></kbd>. If you run into any problems with the data cleaning process, you can just go ahead and load the dataset from scratch by using the <kbd class="calibre12"><span>clean_df_geo.tsv</span></kbd> file provided in this chapter's support files (<a href="https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter08/data/clean_df_geo.tsv.zip" class="calibre9">https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter08/data/clean_df_geo.tsv.zip</a>). In order to load it, all you have to do is run the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using CSV 
julia&gt; clean_df_geo = CSV.read("clean_df_geo.tsv", delim = '\t', nullable = false)</strong> </pre>
<p class="calibre2">So we want to identify the areas with the highest density of businesses. One approach is to use unsupervised machine learning to identify the areas by zip code and the number of businesses registered.</p>
<p class="calibre2">We'll train our model using the data in the <kbd class="calibre12"><span>:zipcode</span></kbd> column plus the number of businesses registered in the area. We'll need the number of businesses per zip code:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; model_data = @from b in clean_df_geo begin 
    @group b by b.Source_Zipcode into g 
    @let bcount = Float64(length(g)) 
    @orderby descending(bcount) 
    @select { zipcode = Float64(get(key(g))), businesses_count = bcount } 
    @collect DataFrame 
end</strong> </pre>
<p class="calibre2">We execute a query against <span class="calibre5"><kbd class="calibre12">clean_df_geo</kbd> </span><kbd class="calibre12"><span>DataFrame</span></kbd>, grouping it by <kbd class="calibre12"><span>:Source_Zipcode</span></kbd> into <kbd class="calibre12"><span>g</span></kbd>. We store the number of businesses from the current zip code in the <span class="calibre5"><kbd class="calibre12">bcount</kbd></span> range variable, as returned by <kbd class="calibre12"><span>length(g)</span></kbd>, but not before converting the number into a <kbd class="calibre12"><span>Float64</span></kbd>. The reason we're doing this is that, as we'll see right away, clustering expects the input to be <span class="calibre5"><kbd class="calibre12">Float64</kbd>, </span>so this will save us another processing step later. Back to our query. We also apply sorting by <span class="calibre5"><kbd class="calibre12">bcount</kbd></span> to allow us, the humans, to better understand the data (not needed for training the model). Finally, we instantiate a new <kbd class="calibre12"><span>DataFrame</span></kbd>, with two columns, a <span class="calibre5">zip code,</span> and <kbd class="calibre12"><span>businesses_count</span></kbd>, without forgetting to convert the zip code into <kbd class="calibre12"><span>Float64</span></kbd> too, for the same reason as before. When converting <kbd class="calibre12"><span>key(g)</span></kbd>, please also note that we're first calling the <span class="calibre5"><kbd class="calibre12">get</kbd></span> function. This is because, within a query block, the computed values are represented as <kbd class="calibre12"><span>DataValues</span></kbd> and to access the wrapped value we need to invoke <span class="calibre5"><kbd class="calibre12">get</kbd></span>:</p>
<p class="calibre2"/>
<div class="CDPAlignCenter1"><img src="assets/06081711-3cd3-4ee0-81d6-e1a9240bcef2.png" class="calibre124"/></div>
<p class="calibre2">Our training data is made of <kbd class="calibre12">79</kbd> zip codes and their corresponding businesses count. The top 22 areas have over 1,000 businesses each, and the number drops sharply for the rest:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; last(model_data)</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/dca65879-db99-4b9e-a076-ee713ba143ec.png" class="calibre125"/></p>
<p class="calibre2">You probably remember <kbd class="calibre12"><span>Gadfly</span></kbd>, the Julia plotting library we used in <a href="90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml" target="_blank" class="calibre9">Chapter 1</a>, <em class="calibre16">Getting Started with Julia Programming</em>, to visualize the Iris flowers dataset. Let's use it to quickly get a glimpse of our data:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Gadfly 
julia&gt; plot(model_data, x=:businesses_count, Geom.histogram)</strong> </pre>
<p class="calibre2">This will render the following histogram:</p>
<p class="CDPAlignCenter"><img src="assets/da643e25-42cc-4547-8bd3-ab887ba9c316.png" class="calibre126"/></p>
<p class="calibre2">We can easily see that most of the areas only have one registered business, followed by a few others, which only have a few. We can safely remove these from our training dataset as they won't be useful to our client. The only thing we need to do is to add the <kbd class="calibre12"><span>@where bcount &gt; 10</span></kbd> filter in the query for computing <kbd class="calibre12"><span>model_data</span></kbd>, between the <kbd class="calibre12"><span>@let</span></kbd> and the <kbd class="calibre12"><span>@orderby</span></kbd> statements:</p>
<pre class="calibre17">model_data = @from b in clean_df_geo begin 
    @group b by b.Source_Zipcode into g 
    @let bcount = Float64(length(g)) 
    @where bcount &gt; 10 
    @orderby descending(bcount) 
    @select { zipcode = Float64(get(key(g))), businesses_count = bcount } 
    @collect DataFrame 
end </pre>
<p class="calibre2">Once we remove all of the areas that host less than <kbd class="calibre12">10</kbd> companies, we're left with only <kbd class="calibre12">28</kbd> zip codes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Training our model</h1>
                </header>
            
            <article>
                
<p class="calibre2">Only one small step and we're ready to train our model. We need to convert the <kbd class="calibre12"><span>DataFrame</span></kbd> into an array and to permute the dimensions of the array so that the <kbd class="calibre12">DataFrame</kbd> columns become rows. In the new structure, each column (zip code and count pair) is considered a training sample. Let's do it:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; training_data = permutedims(convert(Array, model_data), [2, 1])</strong> </pre>
<p class="calibre2">Our training data is ready! It's time to put it to good use:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Clustering</strong><br class="title-page-name"/><strong class="calibre1">julia&gt; result = kmeans(training_data, 3, init=:kmpp, display=:iter)</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> 
  Iters               objv        objv-change | affected  
------------------------------------------------------------- 
      0       6.726516e+06 
      1       4.730363e+06      -1.996153e+06 |        0 
      2       4.730363e+06       0.000000e+00 |        0 
K-means converged with 2 iterations (objv = 4.73036279655838e6)</strong> </pre>
<p class="calibre2">We're using the k-means algorithm by invoking the function with the same name. As arguments, we provide the <kbd class="calibre12"><span>training_data</span></kbd> array and give it three clusters. We want to split the areas into three tiers—low, medium, and high density. The training shouldn't take more than a few seconds. And since we gave it the <kbd class="calibre12"><span>display=:iter</span></kbd> argument, we get progressive debug info at each iteration. For the seeding algorithm, we have used <span class="calibre5">k-means++</span> (<kbd class="calibre12"><span>:kmpp</span></kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpreting the results</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now we can take a look at how the points were assigned:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; result.assignments 
28-element Array{Int64,1}: 
 3 
 3 
 3 
 1 
 1 
 # some 1 values omitted from the output for brevity 
 1 
 1 
 2 
 2 
 # some 2 values omitted from the output for brevity 
 2 
 2</strong> </pre>
<p class="calibre2">Each element in the array corresponds to the element at the same index in the <kbd class="calibre12"><span>model_data</span></kbd>. Let's combine the data so it's easier to follow:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; model_data[:cluster_id] = result.assignments 
28-element Array{Int64,1}: </strong><br class="title-page-name"/><strong class="calibre1"># output truncated #</strong></pre>
<p class="calibre2">Now let's see what we end up with:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; model_data</strong></pre>
<p class="calibre2">The output is as follows:</p>
<div class="CDPAlignCenter1"><img src="assets/56e2d71e-dee6-4766-ba2e-4315548961e3.png" class="calibre127"/></div>
<p class="calibre2">We can see that the first three zip codes have been assigned to cluster <kbd class="calibre12">3</kbd>, the last eight to cluster <kbd class="calibre12">2</kbd>, and the rest to cluster <kbd class="calibre12">1</kbd>. You've probably noticed that the IDs of the clusters don't follow the actual count values, which is normal since the data is unlabeled. It is us who must interpret the meaning of the clusters. And our algorithm has decided that the areas with the highest density of businesses will stay in cluster <kbd class="calibre12">3</kbd>, the low densities in cluster <kbd class="calibre12">2</kbd>, and the average ones in cluster <kbd class="calibre12">1</kbd>. Plotting the data with <kbd class="calibre12">Gadfly</kbd> will confirm our findings:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(model_data, y = :zipcode, x = :businesses_count, color = result.assignments, Geom.point, Scale.x_continuous(minvalue=0, maxvalue=5000), Scale.y_continuous(minvalue=94050, maxvalue=94200), Scale.x_continuous(format=:plain))</strong> </pre>
<p class="calibre2"><span class="calibre5">It produces this plot:</span></p>
<div class="CDPAlignCenter1"><img src="assets/960b6dca-9559-473d-8984-8607b0b20df6.png" class="calibre128"/></div>
<p class="calibre2">Excellent! We can now inform our client that the best areas to target are in the zip codes 94110, 94103, and 94109, allowing them to reach 11,965 businesses in these dense parts of the city. They would also like to know which are <span class="calibre5">these </span>companies, so let's prepare a list:</p>
<pre class="calibre17">companies_in_top_areas = @from c in clean_df_geo begin 
       @where in(c.Source_Zipcode, [94110, 94103, 94109]) 
       @select c 
       @collect DataFrame 
end </pre>
<p class="calibre2">We use the zip codes we extracted in the clustering step to filter the <kbd class="calibre12"><span>clean_df_geo</span></kbd> dataset:</p>
<p class="CDPAlignCenter"><img src="assets/a19e81a0-f09a-42c8-9144-b0afca3d4207.png" class="calibre18"/></p>
<p class="calibre2">We end up with 11,965 companies concentrated in three area codes. Let's plot the points using the <kbd class="calibre12">geo</kbd> coordinates:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(companies_in_top_areas, y = :long, x = :lat, Geom.point, Scale.x_continuous(minvalue=36, maxvalue=40), Scale.y_continuous(minvalue=-125, maxvalue=-120), color=:Source_Zipcode) </strong></pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<div class="CDPAlignCenter1"><img src="assets/fd2ab408-24e1-45b5-87aa-59c304bf229d.png" class="calibre129"/></div>
<p class="calibre2">As expected, the locations are in close proximity, but there is one outlier whose coordinates are way off. Maybe there's an error in our data. Using Query, we can easily remove the culprit:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; companies_in_top_areas = @from c in companies_in_top_areas begin 
           @where c.lat != minimum(companies_in_top_areas[:lat]) 
           @select c 
           @collect DataFrame 
      end</strong> </pre>
<p class="calibre2">With our cleaned-up list, we can now explore the domain of activity for these companies. This will help our client reach out to candidates that fit the market's demand, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; activities = @from c in companies_in_top_areas begin 
           @group c by c.NAICS_Code_Description into g 
           @orderby descending(length(g)) 
           @select { activity = key(g), number_of_companies = length(g) } 
           @collect DataFrame 
       end</strong> </pre>
<p class="calibre2">That was easy:</p>
<div class="CDPAlignCenter1"><img src="assets/f2afb42f-a3dc-4711-a19d-7359d3a19d18.png" class="calibre130"/></div>
<p class="calibre2">All the companies in the targeted area are active in just <kbd class="calibre12">18</kbd> domains, out of which real estate is the most common one. Surely, our client's executives would appreciate a chart:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(activities, y=:number_of_companies, Geom.bar, color=:activity, Scale.y_continuous(format=:plain), Guide.XLabel("Activities"), Guide.YLabel("Number of companies"))</strong> </pre>
<p class="calibre2"><span class="calibre5">This is what we get:</span></p>
<div class="CDPAlignCenter1"><img src="assets/58c3bb0d-073c-449a-a7cd-dd1b376307bb.png" class="calibre131"/></div>
<p class="calibre2">Yes, the chart clearly shows that real estate is the activity in which most of the businesses are involved, with tech and retail coming in next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refining our findings</h1>
                </header>
            
            <article>
                
<p class="calibre2">Great progress so far, but a list of almost 12,000 companies is still hard to handle. We can help our client by breaking it down into clusters of businesses located in close proximity. It's the same workflow as before. First, we extract our training data:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; model_data = @from c in companies_in_top_areas begin 
           @select { latitude = c.lat, longitude = c.long } 
           @collect DataFrame 
       end</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<div class="CDPAlignCenter1"><img src="assets/5459fe82-6cca-4a38-ac6f-1147121f6bf2.png" class="calibre132"/></div>
<p class="calibre2">Now we permute the dimensions to set the data in the format expected by clustering (just like we did before):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; training_data = permutedims(convert(Array{Float64}, model_data), [2, 1])</strong> </pre>
<p class="calibre2">Our training array is ready!</p>
<p class="calibre2">We'll use the same k-means algorithm with k-means++ seeding.</p>
<div class="packttip">Please be aware that <span>k-means</span> is generally not the best choice for clustering geolocation data. <span>DBSCAN</span> is usually better suited and I recommend that you look into it for production applications. The <span>k-means</span> algorithm will fail, for example, when dealing with close points that wrap over 180 degrees. For our example project and for the data we're handling, <span>k-means</span> works fine, but keep this limitation in mind.</div>
<p class="calibre2">Training works in the same way. We'll go with <kbd class="calibre12">12</kbd> clusters, in order to get roughly 1,000 companies per group:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; result = kmeans(training_data, 12, init=:kmpp, display=:iter) 
  # output truncated 
K-means converged with 24 iterations (objv = 0.28192820139520336)</strong> </pre>
<p class="calibre2">This time it takes <kbd class="calibre12">24</kbd> iterations to reach convergence. Let's see what we've got:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; result.counts 
12-element Array{Int64,1}: 
 1076 
 1247 
  569 
 1180 
 1711 
 1191 
  695 
    1 
 1188 
   29 
 1928 
 1149</strong> </pre>
<p class="calibre2">Most of the data is evenly spread, but we can spot a few clusters which don't get that many businesses. Plotting the numbers gives us a clear picture:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(result.counts, Geom.bar, y=result.counts, Guide.YLabel("Number of businesses"), Guide.XLabel("Cluster ID"), color=result.counts)</strong> </pre>
<p class="calibre2"><span class="calibre5">Here is the plot:</span></p>
<div class="CDPAlignCenter1"><img src="assets/28e9133d-5275-495d-84cf-066d876c91c9.png" class="calibre133"/></div>
<p class="calibre2">Now we can <em class="calibre16">paste</em> the cluster assignments onto the <kbd class="calibre12">companies_in_top_areas</kbd> <kbd class="calibre12">DataFrame</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; companies_in_top_areas[:cluster_id] = result.assignments</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing our clusters on the map</h1>
                </header>
            
            <article>
                
<p class="calibre2">To get a better understanding of our data, in terms of points density and location proximity, we can render a plot with <kbd class="calibre12">Gadfly</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(companies_in_top_areas, color=:cluster_id, x=:lat, y=:long)</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/a58eb08a-a6dd-4c12-b4c9-d9b153b7a5e2.png" class="calibre134"/></p>
<p class="CDPAlignLeft1">We can see a pretty good cluster distribution, so our approach worked!</p>
<p class="calibre2">However, it would be even better if we could display the clusters on a map. Unfortunately, at the moment, there's no easy way to do this in Julia, so we'll use a third-party tool.</p>
<div class="packttip">PlotlyJS (<span><a href="https://github.com/sglyon/PlotlyJS.jl" class="calibre19">https://github.com/sglyon/PlotlyJS.jl</a></span>) provides related functionality, but my tests didn't produce good results given that the coordinates are tightly packed in the San Francisco area.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using BatchGeo to quickly build maps of our data</h1>
                </header>
            
            <article>
                
<p class="calibre2">BatchGeo (<span class="calibre5"><a href="https://batchgeo.com" class="calibre9">https://batchgeo.com</a></span>) is a popular web app for creating map-based data visualizations. It uses high-definition maps from Google and it provides a no-login, albeit limited, free version, which we can try out right away.</p>
<p class="calibre2">BatchGeo expects a CSV file with a series of columns, so our first job is to set that up. It couldn't be any simpler with Query:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; export_data = @from c in companies_in_top_areas begin 
                           @select { Name = c.DBA_Name, </strong><br class="title-page-name"/><strong class="calibre1">                                     Zip = c.Source_Zipcode, 
                                     Group = string("Cluster $(c.cluster_id)"), 
                                     Latitude = c.lat, Longitude = c.long,  
                                     City = "San Francisco", State = "CA" } 
                           @collect DataFrame 
                     end</strong> </pre>
<p class="calibre2"><span class="calibre5">The output is as follows:</span></p>
<div class="CDPAlignCenter1"><img src="assets/4e29ce70-793a-42eb-bf6e-f1759dae3f86.png" class="calibre135"/></div>
<p class="calibre2">The structured data is available in a new <kbd class="calibre12"><span>DataFrame</span></kbd> called <kbd class="calibre12"><span>export_data</span></kbd>. Unfortunately, BatchGeo has added a 250-row limit for free accounts, so we'll have to limit our export to just the top 250 rows.</p>
<p class="calibre2">Here's how we can export it:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; CSV.write("businesses.csv", head(export_data, 250))</strong> </pre>
<p class="calibre2">Success! The only thing left to do is to open <span class="calibre5"><a href="https://batchgeo.com" class="calibre9">https://batchgeo.com</a></span> in your favorite web browser and drag and drop the <kbd class="calibre12">business.csv</kbd> file to the designated place:</p>
<ol class="calibre13">
<li class="calibre11">This is done by performing the steps, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter"><img src="assets/f6f4b281-3bca-470f-a1ee-d7e714f537fd.png" class="calibre136"/></p>
<ol start="2" class="calibre13">
<li class="calibre11">Click <span>Validate &amp; Set Options</span>. You'll see that the columns were picked correctly and the defaults are good:</li>
</ol>
<p class="CDPAlignCenter"><img src="assets/7926f0f1-20b1-4f06-a165-8c751748f4bb.png" class="calibre137"/></p>
<ol start="3" class="calibre13">
<li class="calibre11">Clicking on <span>Make Map</span> will render our clusters on top of the map of San Francisco:</li>
</ol>
<p class="CDPAlignCenter"><img src="assets/9794ae2a-642c-4479-a4eb-676c170b1f0e.png" class="calibre138"/></p>
<p class="CDPAlignLeft1">Victory—a beautiful rendering of our data!</p>
<p class="calibre2">We can also disable the clustering so that each individual business will be plotted:</p>
<p class="CDPAlignCenter"><img src="assets/41672512-690b-4238-85fd-70555ca207e5.png" class="calibre139"/></p>
<p class="CDPAlignLeft1">Finally, we can save our map, follow the instructions, and get a unique URL for our visualization. Mine can be found at <span class="calibre5"><a href="https://batchgeo.com/map/7475bf3c362eb66f37ab8ddbbb718b87" class="calibre9">https://batchgeo.com/map/7475bf3c362eb66f37ab8ddbbb718b87</a></span> .</p>
<p class="calibre2">Excellent, just in time for the meeting with our client!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing the optimal number of clusters for k-means (and other algorithms)</h1>
                </header>
            
            <article>
                
<p class="calibre2">Depending on the nature of the data and the problem you'll be looking to solve, the number of clusters can come as a business requirement, or it may be an obvious choice (as in our case, where we wanted to identify low, middle, and high business density zones and so ended up with three clusters). However, in some cases, the answer might not be that obvious. In such situations, we'll need to apply a different algorithm to evaluate the optimal number of clusters.</p>
<p class="calibre2">One of the most common is the Elbow method. It is an iterative approach where we run the clustering algorithm with different values for <span class="calibre5">k</span>, for example between 1 and 10. The goal is to compare the total intra-cluster variation by plotting the sum of squared errors between each point and the mean of its cluster as a function of k. Using the visualization, we identify the <em class="calibre16">elbow-like </em>point of inflection, like this:</p>
<p class="CDPAlignCenter"><img src="assets/80d348c1-5ba4-4e46-b73f-ae1945d4e09f.png" class="calibre140"/></p>
<div class="packtfigref">This is the elbow.</div>
<div class="packttip">You can read more about this at <span><a href="http://www.sthda.com/english/articles/29-cluster-validation-essentials/96-determining-the-optimal-number-of-clusters-3-must-know-methods/" class="calibre19">http://www.sthda.com/english/articles/29-cluster-validation-essentials/96-determining-the-optimal-number-of-clusters-3-must-know-methods/</a></span> (with examples in R).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clustering validation</h1>
                </header>
            
            <article>
                
<p class="calibre2">Besides picking the optimum number of clusters, another aspect is cluster validation, that is, to determine how well the items fit the assigned clusters. This can be used to confirm that patterns do indeed exist and to compare competing clustering algorithms.</p>
<p class="calibre2"><span class="calibre5">Clustering</span> provides a small API for clustering validation with three techniques, including Silhouettes, one of the most common. You can find the documentation at <span class="calibre5"><a href="http://clusteringjl.readthedocs.io/en/latest/validate.html" class="calibre9">http://clusteringjl.readthedocs.io/en/latest/validate.html</a></span> and you can read more about validation theory at <span class="calibre5"><a href="http://www.sthda.com/english/articles/29-cluster-validation-essentials/97-cluster-validation-statistics-must-know-methods/" class="calibre9">http://www.sthda.com/english/articles/29-cluster-validation-essentials/97-cluster-validation-statistics-must-know-methods/</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre2">In this chapter, we looked into unsupervised machine learning techniques with Julia. We focused on clustering, one of the most widely used applications of unsupervised learning. Starting with a dataset about businesses registered in San Francisco, we performed complex—but not complicated, thanks to Query—data cleansing. In the process, we also learned about metaprogramming, a very powerful coding technique and one of Julia's most powerful and defining features.</p>
<p class="calibre2">Once our data was in top shape and after mastering the basics of clustering theory, using the <span class="calibre5">k-means</span> algorithm, we got down to business. We performed clustering to identify the areas with the highest density of companies to help our imaginary customer, ACME Recruiting, to target the best areas for advertising. After identifying the parts of the city that would give ACME the best reach, we performed data analysis to get the top domains of activity required by our customer so they could build a database of relevant candidates.</p>
<p class="calibre2">Finally, we performed clustering on the geolocation data of the businesses in the targeted areas and then we rendered these on top of a map. Our client was thrilled with our findings and their marketers now having all the necessary information to start planning their campaigns. Congratulations!</p>
<p class="calibre2">In the next chapter, we'll leave the fascinating world of machine learning in order to discover yet another key concept in data science—time series. We'll learn how to handle dates and time in Julia, how to work with time series data, and how to make forecasts. Exciting, isn't it?</p>


            </article>

            
        </section>
    </body></html>