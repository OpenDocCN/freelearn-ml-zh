- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Python is the dominant language used for ML, Microsoft is making heavy
    investments in AI, and not just through its investments in OpenAI and ChatGPT.
    Microsoft is actively expanding support for ML development in VB.NET and C# through
    the open source **ML.NET** framework. In this chapter, we’ll be looking at how
    to set up BP to use ML.NET through **Code Stages**.
  prefs: []
  type: TYPE_NORMAL
- en: In my research, random forests were the most commonly cited family of algorithms
    used in IA, followed by deep learning and gradient boosting. All of these algorithms
    have implementations in ML.NET. Random forests and gradient-boosting algorithms
    can realistically be used on digital workers to produce timely predictions. Deep
    learning may not be a good candidate for training and predicting the Digital Worker
    itself due to computation and GPU requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter features three examples that build on one another. They are modeled
    after a real-life scenario. Imagine that an ML model (binary classification for
    sentiment analysis) has been built by data scientists using ML.NET. The model
    has been reviewed and accepted for an IA use case and an IA team needs to take
    ownership of the model maintenance and source code going forward. In our examples,
    we will be going over the steps to successfully get the ML code running in BP.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up ML.NET in BP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing the C# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving BP integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download and import the three files in the `ch3` folder on GitHub at [https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch3](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch3).
    Note that two of the files have the file extension `.bpobject`, and they need
    importing as `Process / Object`. Additional setup steps will be performed as part
    of the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up ML.NET in BP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ML.NET can be used natively inside of BP code stages. While you have a choice
    between C# and VB.net in BP, almost all of the documentation on the Internet is
    written for C#. The examples in this chapter will also use C#.
  prefs: []
  type: TYPE_NORMAL
- en: Possibly the biggest challenge that developers face when trying to use ML.NET
    is getting all of the `.dll` files) imported and `.dll` dependencies in the project
    for the developer. BP unfortunately doesn’t have a feature to do the same. In
    BP, getting the assembly imports and namespaces working is largely through trial
    and error and checking documentation. We iteratively add new `.dll` files or namespaces
    and check for changes in the errors displayed in BP.
  prefs: []
  type: TYPE_NORMAL
- en: Since only Business Objects (not Processes) can have Code Stages, the contents
    of this chapter only apply to objects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding references and namespaces to BP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The area to add `.dll` files and namespaces is in the Object’s Properties in
    the **Code Options** tab. To access an Object’s properties, visit the **Initialise**
    Page. By default, to the left of the **Start** Stage, there’s a rectangle containing
    the Object’s name, the creation date, and the last changed date. Right-click this
    rectangle and choose **Properties**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Accessing an Object’s properties from the Initialise Page](img/B18416_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Accessing an Object’s properties from the Initialise Page
  prefs: []
  type: TYPE_NORMAL
- en: An alternate way of opening the Object’s Properties is to double-click the white
    rectangle. With the **Properties** window open, you’ll see a **Code Options**
    tab. The **Code Options** tab is where external assemblies and namespaces can
    be added. The code language (**C#**, **Visual Basic**, or **Visual J#**) can also
    be selected here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The Code Options tab of an Object’s Properties](img/B18416_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The Code Options tab of an Object’s Properties
  prefs: []
  type: TYPE_NORMAL
- en: While *Figure 3**.2* shows `.dll` file, you can also specify them by providing
    the full path. If you don’t see the full path to the `.dll`, this means that the
    assembly is either stored in the BP installation folder or somewhere on the Windows
    path. The `using` statements in C#, typically after adding the corresponding assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at our first example, where we will add **External References**
    and **Namespace Imports** to an Object. We will be doing five high-level steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining existing `using` statements in the source code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading the ML.NET package from NuGet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extracting the `.dll` files from the NuGet package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copying the `.dll` files to the BP installation folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding references and namespaces to the **Code** **Options** tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The overall goal for this example is to get BP working with ML.NET as much as
    we can before adding in the actual C# code in Code Stages.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – preparation work before BP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall the scenario introduced at the beginning of the chapter. We’re tasked
    with moving C# ML code into BP. There are two ways to approach determining which
    `.dll` libraries need to be imported. The first way is to copy all of the source
    code into a Code Stage and see what error messages appear. The other (and probably
    smarter) way is to examine the project’s source code first. This gets us familiar
    with the code base and gives us an idea of what `.dll` files and namespaces need
    to be added. We will be doing the latter here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our starting source code comes from Microsoft’s GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/dotnet/machinelearning-samples/tree/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis](https://github.com/dotnet/machinelearning-samples/tree/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis)'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the C# source files for using statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Microsoft GitHub project, there are only three C# source files. Let’s
    examine each one and note any `.dll` files that might need to be imported:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the first source file at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs).
    The `using` statements are in the first six lines of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of not are `Microsoft.ML` and `Microsoft.ML.DataOperationsCatalog`. `SentimentAnalysisConsoleApp.DataStructures`
    is a self-reference to the current project as opposed to an external library.
  prefs: []
  type: TYPE_NORMAL
- en: Open the second source file at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs).
    There’s only one `using` statement for `Microsoft.ML.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the final source file at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs).
    Again, we only see `Microsoft.ML.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ve found three notable `using` statements by examining the source files:
    `Microsoft.ML`, `Microsoft.ML.Data`, and `Microsoft.ML.DataOperationsCatalog`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the .csproj file for PackageReferences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `.csproj` file can also contain references to external libraries that need
    importing. Open [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/SentimentAnalysisConsoleApp.csproj](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/SentimentAnalysisConsoleApp.csproj)
    and search for the term `PackageReference`. See that there’s only one line containing
    `Microsoft.ML`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve finished examining the C# project code for `using` statements.
    This revealed the need to add `Microsoft.ML`, `Microsoft.ML.Data`, and `Microsoft.ML.DataOperationsCatalog`.
    The `.csproj` file reconfirmed the need to add `Microsoft.ML`. Now that we have
    an idea of which libraries we need to add, let’s download them from NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading ML.NET from NuGet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NuGet is the package manager for .NET. In traditional software development,
    `.dll` management and dependencies are usually handled by your IDE. This functionality
    is unfortunately missing from BP, so we’ll need to manually download packages
    from the NuGet website:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://www.nuget.org/](https://www.nuget.org/) in your web browser. Search
    for `ML.NET`. Click on the result named **Microsoft.ML**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on version `.nupkg` file. This file can be opened with a `.zip` extraction
    program, including the default Windows one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Downloading Microsoft.ML version 2.0.1 from NuGet](img/B18416_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Downloading Microsoft.ML version 2.0.1 from NuGet
  prefs: []
  type: TYPE_NORMAL
- en: Open the `.nupkg` file using a zip extraction tool. Navigate into the `lib\netstandard2.0`
    folder. Extract all seven of the `.dll` files somewhere convenient, such as your
    desktop. We will be using these files later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Seven .dll files to extract from lib\netstandard2.0](img/B18416_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Seven .dll files to extract from lib\netstandard2.0
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the three libraries that we need to import, two are present in the `Microsoft.ML`
    package: `Microsoft.ML` is in `Microsoft.ML.dll` and `Microsoft.ML.Data` is in
    `Microsoft.ML.Data.dll`.'
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t clear where we can find `Microsoft.ML.DataOperationsCatalog`. From
    the API documentation, found at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog?view=ml-dotnet),
    we see that it belongs to the `Microsoft.ML.Data.dll` assembly, meaning that the
    `Microsoft.ML` `.dll` files cover all of the `using` statements that we know of
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – DataOperationsCatalog found in Microsoft.ML.Data.dll](img/B18416_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – DataOperationsCatalog found in Microsoft.ML.Data.dll
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve extracted some of the necessary `.dll` files from the NuGet package,
    let’s move them to a location that BP can access.
  prefs: []
  type: TYPE_NORMAL
- en: Copying the .dll files to the BP installation folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, BP is installed at `C:\Program Files\Blue Prism Limited\Blue Prism
    Automate`. We need to copy the `.dll` files to the installation folder. If this
    isn’t your installation path, please substitute your own instead:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the seven `.dll` files extracted from the NuGet package into the BP installation
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the BP application if you have it open. BP needs to be restarted in
    order to load the new assemblies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple locations you can copy assemblies to so that they work with
    BP. This includes the Windows directory, the Windows system directory, and any
    folder on the system’s path environment variable. To make this example less error-prone,
    we’re copying it into the BP installation folder. In a production environment,
    a more maintainable solution would be to copy the `.dll` files into a custom folder
    and to include that folder in the Windows environment path variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the libraries have been copied into a folder that’s accessible to BP,
    let’s create a sample Object and import them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a BP object and adding external references and namespace imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this final section of the first example, we’ll create a BP Object, add the
    `.dll` files that are needed as references, add namespaces, and set the language
    to C#:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Group named `Ch3` inside of **Studio** | **Objects**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object named `Example 1 – Sentiment Analysis for User Reviews`
    inside of the `Ch3` Group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Initialise** Page, double-click on the white box with the Object’s
    name. This opens the Business Object’s Properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Double-clicking to open the Properties of the Business Object](img/B18416_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Double-clicking to open the Properties of the Business Object
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `Microsoft.ML.dll`. Click `Microsoft.ML.Data.dll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Microsoft.ML`. Click `Microsoft.ML.Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **C#** in the **Language** drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the **Code Options** tab looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Code Options tab at the end of the first example](img/B18416_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The Code Options tab at the end of the first example
  prefs: []
  type: TYPE_NORMAL
- en: '**Save** the object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example, we did the preparation work needed before moving the C# code
    into a Code Stage. First, we examined the project’s code to figure out *some*
    of the needed assembly imports. The assemblies themselves and the further code
    that we need to add to code stages might have additional dependencies that haven’t
    been imported yet. Next, we downloaded the ML.NET package from NuGet, and extracted
    the `.dll` files. Finally, we copied the ML.NET assemblies into the BP installation
    folder and added them as references in the Object’s Properties. In the next section,
    we’ll focus on porting the source code into BP.
  prefs: []
  type: TYPE_NORMAL
- en: Porting ML.NET C# into a Code Stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Porting code into BP is more of an art than a science. It requires knowledge
    of how C# works and digging into the ML.NET API documentation when necessary.
    We’ve already discussed the **Code Options** section of the Object’s Properties.
    The Object’s Properties also have a **Global Code** tab, which will be used in
    the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Global Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Global Code** tab is accessed through the Object’s Properties, similarly
    to the **Code** **Options** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The Global Code tab is accessed through the Object’s Properties](img/B18416_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The Global Code tab is accessed through the Object’s Properties
  prefs: []
  type: TYPE_NORMAL
- en: The **Global Code** section is used to place *common code* that’s needed across
    multiple Code Stages. This is similar in concept to a global Data Item (unticking
    Hide from other pages in the process checkbox) that’s needed across different
    Actions or Pages. Common code can include *variables*, *classes*, and *functions*.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also notice a **Check Code** button. This button validates the code from
    the perspective of the compiler in the **Global Code** section, as well as any
    other Code Stage in the Object. We will be using this button frequently to help
    us figure out which assemblies are missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will use both the **Global Code** section and the **Check
    Code** button to help in porting the C# code into BP. The example will go through
    five high-level steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving two C# classes into the **Global Code** section of the Object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copying the main source code into a Code Stage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iteratively fixing compiler errors through the use of the **Check** **Code**
    button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing C# console print commands so that they output to a file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the ported ML program
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example 2 - porting the source code into BP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will be moving all of the source code into a Code Stage,
    and fixing more assembly and namespace errors. Our goal is to reach a point where
    we can receive a prediction from the C# Code Stage.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This example was created and tested on BP versions 7.1.1 and 7.1.2\. However,
    if you’re using a different version of BP, there may be additional steps needed
    to get this example working. This is because different versions of BP come bundled
    with different versions of Microsoft’s .dll libraries. If you look into your BP
    installation folder, many of these .dll files are prefixed with `System.*` or
    `Microsoft.*`. The steps shown in this example should in the worst case get you
    very close to making a prediction through a Code Stage. You can get to a working
    solution by applying the techniques that we’ll see below.
  prefs: []
  type: TYPE_NORMAL
- en: Moving class definitions into BP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the first example, we saw that there were only three `.cs` source files.
    Two of the source files, `SentimentIssue.cs` and `SentimentPrediction.cs`, are
    class definitions. Let’s move them into the **Global Code** section of the Object:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Object created in the first example. If needed, a completed version
    of the Object, named `Example 1 - Sentiment Analysis for User Reviews (Completed)`,
    should have already been imported to the `Ch3` Group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Object’s Properties by double-clicking on the white box with the Object’s
    name on the **Initialise** Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Global** **Code** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the class definition code from [https://github.com/dotnet/machine learning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs)
    into the `public class SentimentIssue { … }`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for the file at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs).
    This includes everything between `public class SentimentPrediction { … }`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Confirm that the **Global Code** section contains two class definitions like
    in the figure below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The Global Code section contains the two class definitions](img/B18416_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – The Global Code section contains the two class definitions
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `The type 'Attribute' is defined in an assembly that is not referenced.
    You must add a reference to assembly 'netstandard,` `Version=2.0.0.0, Culture=neutral`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `netstandard.dll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the **Global Code** tab and click **Check Code** again. Ensure that
    no compiler errors remain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** to save the business object’s properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, we’ve successfully added two classes to the **Global Code** section
    of the Object. Next, let’s import the main program code into a Code Stage.
  prefs: []
  type: TYPE_NORMAL
- en: Porting the machine learning program code into a Code Stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main code for the ML program is in this file: [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move it into a Code Stage:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Action 1` Page and add a Code Stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link** it between **Start** and **End**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Adding a Code Stage to Action 1](img/B18416_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Adding a Code Stage to Action 1
  prefs: []
  type: TYPE_NORMAL
- en: Look at lines 12–20 of `Program.cs`. See that it has a number of `private static
    readonly string` statements. These statements define the paths to the training
    data file (line 15) and the model output file (line 20). Add two `Text` to the
    Object diagram to represent these. Name one Data Item `DataPath` and the other
    `ModelPath`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `DataPath` to `C:/Users/Public/wikiDetoxAnnotated40kRows.tsv`. Set
    the `ModelPath` to `C:/Users/Public/ch3_SentimentModel.zip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![ Figure 3.11 – Set the Initial Values of DataPath and ModelPath](img/B18416_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Set the Initial Values of DataPath and ModelPath
  prefs: []
  type: TYPE_NORMAL
- en: Double-click `Code1`. Add two Inputs corresponding to the Data Items `DataPath`
    and `ModelPath`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Adding the two Data Items as inputs to the Code Stage](img/B18416_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Adding the two Data Items as inputs to the Code Stage
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `Main(string[] args) { [Copy the text here] }` into the code window.
    These are lines 24 to 68 of `Program.cs`. Your code window should have 45 lines
    of code in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The 45 lines of code that should be in your window](img/B18416_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The 45 lines of code that should be in your window
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `.dll` is missing. For example, you might encounter `You must add
    a reference to assembly 'Microsoft.ML.Core` or `You must add a reference to assembly
    'Microsoft.ML.DataView`. Close the **Check Code** window and press **OK** to save
    the Code Stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `Microsoft.ML.DataView.dll` file from the NuGet website by searching
    for `lib\netstandard2.0\Microsoft.ML.DataView.dll` file from the NuGet package
    into the BP installation folder location. Close and relaunch BP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Object’s Properties on the `Microsoft.ML.Core.dll` and `Microsoft.ML.DataView.dll`
    as **External References**. Press **OK** to close the Object’s Properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Adding two new External References to the Object’s Properties](img/B18416_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Adding two new External References to the Object’s Properties
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the `Code1` Stage and click **Check Code** again. There should still
    be four compiler errors that don’t give a clear indication of what assembly or
    namespace needs to be imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The remaining four compiler errors](img/B18416_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – The remaining four compiler errors
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we don’t have a working Code Stage yet, but we’re getting close!
    Let’s investigate and resolve each of the remaining compiler errors individually.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing individual compiler errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'None of the compiler errors have obvious solutions. We’ll need to rely on the
    API documentation to find out which namespaces or assemblies need to be added.
    Let’s tackle them in the order of which line the error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the compiler error for line 8\. It says `The type or namespace name
    ''TrainTestData'' could not be found`. Let’s refer to the API to find out what
    `TrainTestData` is. The documentation at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog.traintestdata?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog.traintestdata?view=ml-dotnet)
    shows that it belongs to `DataOperationsCatalog`. Recall that `DataOperationsCatalog`
    was one of the `using` statements at the beginning of the `Project.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`using` statements are normally ported to BP by adding them into the `using
    static` statements cannot be added in that manner. Instead, we need to provide
    the whole namespace in the source code itself.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `Code1` stage on line 8 and prefix `TrainTestSplit` with `Microsoft.ML.DataOperationsCatalog`.
    Line 8 should now be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on **Check Code**. See that the compiler error on line 8 is gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the compiler error for line 13\. It says: `''TransformsCatalog.TextTransforms''
    does not contain a definition for ''FeaturizeText''`. Look up `FeaturizeText`
    in the API reference at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.textcatalog.featurizetext?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.textcatalog.featurizetext?view=ml-dotnet).
    It shows that the assembly `Microsoft.ML.Transforms.dll` is needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – FeaturizeText in Microsoft.ML.Transforms.dll](img/B18416_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – FeaturizeText in Microsoft.ML.Transforms.dll
  prefs: []
  type: TYPE_NORMAL
- en: Add `Microsoft.ML.Transforms.dll` as an **External Reference** in the Object’s
    Properties and close the Object’s Properties window by pressing **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Adding Microsoft.ML.Transforms.dll as an External Reference](img/B18416_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Adding Microsoft.ML.Transforms.dll as an External Reference
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the compiler error for line 13 is gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the compiler error for line 16\. It says `''BinaryClassificationCatalog.BinaryClassificationTrainers''
    does not contain a definition for ''SdcaLogisticRegression''`. The API page at
    [https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.trainers.sdcalogisticregressionbinarytrainer?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.trainers.sdcalogisticregressionbinarytrainer?view=ml-dotnet)
    shows that SdcaLogisticRegression is in Microsoft.ML.StandardTrainers.dll:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.18 – SdcaLogisticRegression in Microsoft.ML.StandardTrainers.dll](img/B18416_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – SdcaLogisticRegression in Microsoft.ML.StandardTrainers.dll
  prefs: []
  type: TYPE_NORMAL
- en: Add `Microsoft.ML.StandardTrainers.dll` as an **External Reference** in the
    Object’s Properties. Press **OK** to close the Properties window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the compiler error for line 16 is gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last compiler error that remains on line 26 is about a utility that helps
    to print results to the console window (`ConsoleHelper.PrintBinaryClassificationMetrics`).
    Since our goal is to get this running from BP, we won’t see any console window.
    Let’s change the C# code to write the output to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Changing console output to a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ConsoleHelper.cs` file is located at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/common/ConsoleHelper.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/common/ConsoleHelper.cs).
    We can copy the code of that function into the **Global Code** section of our
    Object’s Properties and change line 26 to call that function from our Code Stage.
    Then, we will change printing to the console window to writing a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ConsoleHelper.cs` on GitHub and copy the `PrintBinary` **ClassificationMetrics(…)**
    function from lines 41–57 into the **Global Code** section of your Object’s Properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Copying PrintBinaryClassificationMetrics() into Global Code](img/B18416_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Copying PrintBinaryClassificationMetrics() into Global Code
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Code1` Stage and on line 26, delete the `Console.Helper.` prefix.
    Line 26 should show `PrintBinaryClassificationMetrics(trainer.ToString(), metrics);`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Check Code** and confirm that there are no more compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Object’s Properties and add `System.IO`. to **Namespace Imports**.
    This is needed to write to a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Adding System.IO to the Namespace Imports](img/B18416_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Adding System.IO to the Namespace Imports
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `Code1` Stage and add the following lines to the beginning of
    the code window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the last two lines at the bottom of the code window. They are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It’s safe to delete them, as their purpose is to pause the console window so
    that you can review the printed text, which is no longer necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Paste the following three lines at the very bottom of the code window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press **OK** to save the code window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that all of the compiler errors are resolved, we’re ready to download the
    training data and test the ML.NET code stage.
  prefs: []
  type: TYPE_NORMAL
- en: Running the ML.NET program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re close to the finish line! We need to download the training data, copy
    it to the correct location, and run our model:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the training data from [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/Data/wikiDetoxAnnotated40kRows.tsv](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/Data/wikiDetoxAnnotated40kRows.tsv).
    Ensure that the file is downloaded as a `.tsv` file and *not* a `.``txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `.tsv` file to the location specified by the `DataPath` Data Item,
    `C:/Users/Public/wikiDetoxAnnotated40kRows.tsv`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Action 1` Page and run it in the Object Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See that there’s an error: `Internal : Could not execute code stage because
    exception thrown by code stage: Could not load file or assembly ‘``System.Collections.Immutable,
    Version=1.2.3.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `Systems.Collections.Immutable.dll` file from the NuGet website by
    searching for `lib\netstandard2.0\Systems.Collections.Immutable.dll` file from
    the NuGet package into the BP installation folder location. Close and relaunch
    BP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `Action 1` Page from the Object Studio again. See that there’s an error:
    `Shuffle input cursor reader failed with an exception`. This error is not very
    useful, but we can enclose the Code Stage into a try / catch statement to obtain
    the full stack trace. The full stack trace reveals another missing dependency,
    `Microsoft.ML.CpuMath`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `Microsoft.ML.CpuMath.dll` file from the NuGet website by searching
    for `lib\netstandard2.0\ Microsoft.ML.CpuMath.dll` file from the NuGet package
    into the BP installation folder location. This assembly actually has a further
    dependency on a file named CpuMathNative.dll. This file would normally be provided
    to you from the ML engineers as it will be built as a part of their code project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download `CpuMathNative.dll` from GitHub (assume that this is provided by the
    ML team): [https://github.com/PacktPublishing/Intelligent-Process-Automation-with-Blue-Prism/blob/main/ch3/CpuMathNative.dll](https://github.com/PacktPublishing/Intelligent-Process-Automation-with-Blue-Prism/blob/main/ch3/CpuMathNative.dll),
    and copy it to the BP installation folder. Close and relaunch BP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `Action 1` Page from the Object Studio again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `C:\Users\Public\ch3_output.txt` and confirm that it looks similar to
    the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.21 – The redirected console out contained in ch3_output.txt](img/B18416_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – The redirected console out contained in ch3_output.txt
  prefs: []
  type: TYPE_NORMAL
- en: This file shows the training accuracy and the results of a sample prediction
    for the sentence `I love` `this movie!`.
  prefs: []
  type: TYPE_NORMAL
- en: Confirm that the file, `C:/Users/Public/ch3_SentimentModel.zip`, stored in the
    `ModelPath` data item was created. The file size should be around 13 MB. This
    file can be loaded to make predictions without training the model again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve completed porting the ML code into BP. The biggest difficulty to overcome
    was knowing which assemblies and namespace imports to include. We were able to
    find this information in the compiler errors and the ML.NET API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: For reference, a completed object for the second example should have been imported
    as `Example 2 - Sentiment Analysis for User Reviews (Completed)` in the `Ch3`
    Group. Now that we have the model trained and the prediction working, let’s refactor
    the example so that it follows BP best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Improving BP integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the code in the second example works from a functional standpoint, it
    isn’t well integrated into BP. It’s housed in a single Code Stage, which isn’t
    maintainable or reusable. Data scientists don’t necessarily have experience in
    software design, so you may very well receive an entire ML program in a single
    source file or ML notebook to port into BP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some issues that are present in the second example include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s low logging fidelity. One of the biggest concerns when adding Code Stages
    is that you could be completing numerous important steps and not have any logs
    sent back to the BP database for record keeping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to retrain the entire model each time we want to make a prediction,
    which is time-consuming and repetitive work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a single Action, which doesn’t promote reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a lack of exception handling in the C# code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at how we can improve the four points listed in our next example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3 - refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the final example of this chapter, we’ll look at a refactored version of
    the object from the second example, which improves the functionality, reusability,
    and logging:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Example 3 – Sentiment Analysis for User Reviews (Refactored)` Object
    in the `Ch3` Group in the Object Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the `.zip` file without needing to edit the Object diagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.22 – The training data path and saved model path are stored as Environment
    Variables](img/B18416_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – The training data path and saved model path are stored as Environment
    Variables
  prefs: []
  type: TYPE_NORMAL
- en: See that the trained model path is now separate from the prediction model path.
    By keeping these separate, you can retrain a model while continuing to predict
    using the previous model. This is crucial because a newly trained model needs
    to be vetted before being used in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.23 – The trained model path and prediction model path are different](img/B18416_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – The trained model path and prediction model path are different
  prefs: []
  type: TYPE_NORMAL
- en: See that the fraction of training to testing data is exposed as an Environment
    Variable if it needs to be changed without editing the Object diagram. Part of
    building a model is heavy amounts of experimentation surrounding training parameters.
    It’s desirable to not have the training/test split hard-coded inside the Object’s
    Code Stages, in case it needs to be changed. Another valid design would be to
    pass this in as an Input to the Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See that the training, scoring, model saving, and prediction making have all
    been split into separate Actions. Most importantly, we can now predict without
    needing to train the model every time. This also improves the fidelity of the
    Session Logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Each ML stage with its own Action to improve logging and reusability](img/B18416_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – Each ML stage with its own Action to improve logging and reusability
  prefs: []
  type: TYPE_NORMAL
- en: Open the `try…catch` blocks have been added to each Code Stage, with error messages
    and a Success flag output back to BP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Adding try…catch blocks to improve error handling](img/B18416_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 – Adding try…catch blocks to improve error handling
  prefs: []
  type: TYPE_NORMAL
- en: Each Page also returns these to the caller as Outputs in the End stage instead
    of writing text into files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the **Initialise** Page, open the Object’s Properties, and look at the
    **Global Code**. See that a number of new *static variables* have been added to
    accommodate all of the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Static variables added to the Global Code, usable from other
    Code Stages](img/B18416_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 – Static variables added to the Global Code, usable from other Code
    Stages
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the third example. This was a refactored version of the second
    example, where readability, reusability, and maintainability have all been improved.
    It’s extremely common for an ML program to be contained entirely in just one or
    a few source files. Porting a C# program into a *single* Code Stage results in
    something that’s far from a BP best practice. We need to go that extra step and
    improve what’s provided so that it meets the standards of the IA Center of Excellence.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ML.NET is Microsoft’s open source, cross-platform ML framework. It’s built on
    .NET and can be used natively in BP through Code Stages. In this chapter, we were
    faced with a common IA scenario. We were provided with a working ML project built
    in ML.NET, and our task was to get the source code working in BP.
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, we examined the source code to understand which `.dll`
    libraries needed to be imported. We downloaded the ML.NET package from NuGet and
    copied the assemblies into the BP installation folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we started to move the code into a BP Code Stage. Some
    code, including class definitions, belong in the `.dll` or namespace errors. We
    tackled each error by reading the compiler error message and looking up key terms
    in the API as necessary. A key point to understand is that you don’t need to be
    an ML expert, nor do you need to have experience with the ML framework you’re
    working with to successfully port it into BP! We can successfully port the code
    by using **Check Code** and the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s common for ML code to be provided as a single source code program.
    In the third example, we split up a single Code Stage into multiple Actions that
    more closely matched the ML life cycle. The main goal was to make our Object more
    reusable and maintainable going forward.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes *Part 1* of this book, where we focused on how BP can trigger
    ML predictions. The main ways of doing so are through web APIs, the command line
    interface, and Code Stages. Up next is *Part 2* of the book, where we shift our
    focus to IA solution design.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Designing IA Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Part 1* of this book, we learned three different ways to connect BP to
    ML models to make predictions: Web APIs, the command-line interface, and code
    stages.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 2* describes the BP solution design elements that surround the ML prediction.
    Although the design concepts here are generic in that they could be used with
    any RPA tool, they are illustrated in BP. In [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062),
    we’ll introduce the idea of reviewing ML predictions as a way to manage IA risk.
    We’ll discuss and design two different ways to trigger manual review: random sampling
    and thresholding.'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) examines different ways to
    design an IA solution by varying the number of BP processes and work queues. Changing
    the number of processes and work queues affects the auditability and scalability
    of an IA solution. With this larger solution structure in place, [*Chapter 6*](B18416_06.xhtml#_idTextAnchor093)
    discusses some smaller, reusable elements that can be used across all of the different
    designs.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [*Chapter 7*](B18416_07.xhtml#_idTextAnchor114) consolidates the work
    in this part of the book into reusable IA process templates and an IA VBO that
    can be used as a starting point for your IA solution designs and development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18416_04.xhtml#_idTextAnchor062), *Reviewing Predictions and
    Human in the Loop*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18416_05.xhtml#_idTextAnchor075), *IA Process and Work Queue
    Designs for HITL*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18416_06.xhtml#_idTextAnchor093), *Reusable IA Components*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18416_07.xhtml#_idTextAnchor114), *IA Templates and Utility
    – IA Object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
