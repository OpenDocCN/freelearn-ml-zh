- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Azure Automated Machine Learning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure 自动化机器学习
- en: '**Automated Machine Learning**, also referred to as AutoML, is the automation
    of the iterative and time-consuming process of machine learning model development.
    AutoML enables data scientists and machine learning engineers to develop high-performing
    models in an efficient way allowing them to scale and build the best model quickly.
    Data scientists can rely on AutoML to perform tedious model development tasks
    such as feature engineering, algorithm selection, hyperparameter tuning, and model
    evaluation.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化机器学习**，也称为 AutoML，是机器学习模型开发中迭代和时间消耗过程的自动化。AutoML 使数据科学家和机器学习工程师能够以高效的方式开发高性能模型，使他们能够快速扩展和构建最佳模型。数据科学家可以依赖
    AutoML 来执行繁琐的模型开发任务，如特征工程、算法选择、超参数调整和模型评估。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to Azure AutoML
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure AutoML 简介
- en: Featurization concepts in AML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AML 中的特征化概念
- en: AutoML using AMLS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AMLS 进行 AutoML
- en: AutoML using AML Python SDK
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AML Python SDK 进行 AutoML
- en: Parsing your AutoML results via AML and the AML SDK
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 AML 和 AML SDK 解析您的 AutoML 结果
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this section, we are going to see how to create an automated machine learning
    model from start to end with step-by-step procedures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过逐步操作来展示如何从头到尾创建一个自动化机器学习模型。
- en: 'In order to access your workspace, recall the steps from the previous chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问您的 workspace，回顾前一章中的步骤：
- en: Go to [https://ml.azure.com](https://ml.azure.com).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://ml.azure.com](https://ml.azure.com)。
- en: Select your workspace name.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的 workspace 名称。
- en: In the workspace **User** interface on the left-hand side, click **Compute**.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧工作区的 **用户** 界面上，点击 **计算**。
- en: 'On the **compute** screen, select your compute instance and select **Start**:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **计算** 屏幕上，选择您的计算实例并选择 **启动**：
- en: '![Figure 5.1 – Start compute](img/B18003_05_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 开始计算](img/B18003_05_001.jpg)'
- en: Figure 5.1 – Start compute
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 开始计算
- en: Your compute instance will change from having a **Stopped** status to a **Starting**
    status.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的计算实例将从 **停止** 状态变为 **启动** 状态。
- en: In [*Chapter 2*](B18003_02.xhtml#_idTextAnchor038), *Working with Data in AMLS*,
    we cloned the Git repository – if you have not already done so, continue to follow
    the steps provided here. If you have already cloned the repository, skip to *step
    7*.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18003_02.xhtml#_idTextAnchor038)，“在 AMLS 中处理数据”，我们克隆了 Git 仓库 –
    如果您还没有这样做，请继续按照这里提供的步骤操作。如果您已经克隆了仓库，请跳转到 *步骤 7*。
- en: 'Open the Terminal on your compute instance. Note the path will include your
    user in the directory. Type the following into the Terminal to clone the sample
    notebooks into your working directory:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的计算实例上打开终端。注意路径将包括您的用户目录。在终端中输入以下内容以将示例笔记本克隆到您的工作目录：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Clicking on the refresh icon shown in *Figure 5**.2* will update and refresh
    the notebooks displayed on your screen:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击图 *图 5.2* 中显示的刷新图标将更新并刷新屏幕上显示的笔记本：
- en: '![Figure 5.2 – Refresh](img/B18003_05_002.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 刷新](img/B18003_05_002.jpg)'
- en: Figure 5.2 – Refresh
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 刷新
- en: 'Review the notebooks in your `Azure-Machine-Learning-Engineering` directory.
    This will display the files cloned into your working directory as shown in *Figure
    5**.3*:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看您 `Azure-Machine-Learning-Engineering` 目录中的笔记本。这将显示克隆到您工作目录中的文件，如图 *图 5.3*
    所示：
- en: '![Figure 5.3 – Azure-Machine-Learning-Engineering](img/B18003_05_003.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – Azure-Machine-Learning-Engineering](img/B18003_05_003.jpg)'
- en: Figure 5.3 – Azure-Machine-Learning-Engineering
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – Azure-Machine-Learning-Engineering
- en: Now, let’s learn about what **Azure Machine Learning** (**AML**) AutoML is,
    some of its benefits, and how to consume them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解 Azure Machine Learning（AML）AutoML 是什么，它的一些好处以及如何使用它们。
- en: Introduction to Azure AutoML
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure AutoML 简介
- en: AutoML is a powerful solution that enables not only data scientists but also
    citizen data scientists to build machine learning models supporting a variety
    of use cases. AutoML currently supports classification, regression, time-series
    forecasting, and computer vision in preview. Classification involves a response
    variable that identifies a category. The input training dataset will be leveraged
    to build a model to predict which category a new sample will fall into. Leveraging
    the Titanic dataset, we can leverage the classification model to predict whether
    a passenger will survive on the Titanic. In addition to supporting classification
    model creation, AutoML is also able to generate a regression model. A regression
    model will provide a continuous value as the output of the model. An example of
    a regression model would be to predict gas prices or taxi fares. AutoML can also
    predict values based on time with time-series forecasting. Not only this but AutoML
    also supports image classification, object detection, and instance segmentation
    using the **AML Studio** (**AMLS**) Python SDK.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: AutoML是一个强大的解决方案，它不仅使数据科学家能够构建机器学习模型，还使公民数据科学家能够构建支持各种用例的机器学习模型。目前，AutoML支持预览中的分类、回归、时间序列预测和计算机视觉。分类涉及一个响应变量，用于标识一个类别。输入训练数据集将被用来构建一个模型，以预测新样本将落入哪个类别。利用泰坦尼克号数据集，我们可以利用分类模型来预测乘客是否能在泰坦尼克号上幸存。除了支持分类模型创建外，AutoML还能够生成回归模型。回归模型将提供模型输出的连续值。回归模型的一个例子是预测汽油价格或出租车费用。AutoML还可以根据时间序列预测预测值。不仅如此，AutoML还支持使用**AML
    Studio**（**AMLS**）Python SDK进行图像分类、目标检测和实例分割。
- en: While AMLS supports a variety of AutoML tasks, the AMLS Python SDK supports
    a variety of features for developers and data scientists to leverage that are
    not currently available via AMLS alone.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AMLS支持各种AutoML任务，但AMLS Python SDK支持各种功能，供开发人员和数据科学家利用，这些功能目前仅通过AMLS本身无法获得。
- en: With the Python SDK, not only do we find support for computer vision tasks but
    also for viewing featurization information, enabling voting ensemble models, showing
    the best model based on non-primary metrics, as well as enabling and disabling
    **Open Neural Network Exchange** (**ONNX**) model compatibility.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python SDK，我们不仅找到了对计算机视觉任务的支持，还包括查看特征化信息、启用投票集成模型、根据非主要指标显示最佳模型，以及启用和禁用**开放神经网络交换**（**ONNX**）模型兼容性。
- en: Featurization concepts in AML
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AML中的特征化概念
- en: In order to provide the best model, regardless of whether AutoML is being leveraged,
    an important step in model creation is the engineering features. AutoML in AMLS
    will default to leverage featurization. This can be disabled in the UI as well
    as the SDK if the feature engineering step has already been accomplished. These
    featurization transformations on your dataset can not only be enabled or disabled
    but they can also be customized or excluded from specific columns. There are several
    featurization steps applied to your dataset based on the type of column, and the
    column’s data type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供最佳的模型，无论是否利用AutoML，模型创建的一个重要步骤是特征工程。在AMLS中，AutoML将默认利用特征化。如果特征工程步骤已经完成，可以在UI和SDK中禁用此功能。这些对您的数据集进行的特征化转换不仅可以启用或禁用，还可以自定义或排除特定列。根据列的类型和数据类型，您的数据集将应用几种特征化步骤。
- en: During training, AutoML leverages scaling or normalization to ensure model performance.
    AutoML leverages a variety of techniques, including scaling to unit variance,
    scaling by quantile range, scaling by the maximum absolute value, scaling by a
    column’s minimum and maximum, by applying **Principle Component Analysis** (**PCA**)
    for dimensionality reduction, **Singular Value Decomposition** (**SVD**) for dimensionality
    reduction, as well as rescaling each sample to a norm of 1.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练过程中，AutoML利用缩放或归一化来确保模型性能。AutoML利用各种技术，包括缩放到单位方差、按分位数范围缩放、按最大绝对值缩放、按列的最小值和最大值缩放，以及应用**主成分分析**（**PCA**）进行降维、**奇异值分解**（**SVD**）进行降维，以及将每个样本缩放到1的范数。
- en: Provided that featurization is enabled, certain columns will be dropped during
    the training process. Columns that have no variance – meaning all rows have the
    same value – or rows with high cardinality – meaning they have a very high variance,
    such as a column with GUID values – will be dropped. If a column has a numeric
    value but a low variance, AutoML will transform that value into a categorical
    feature and apply one-hot encoding. If a categorical column has high variance,
    one-hot hash encoding will be leveraged.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设特征化已启用，某些列将在训练过程中被删除。没有方差（意味着所有行都有相同的值）的列或具有高基数（意味着它们具有非常高的方差，例如具有GUID值的列）的行将被删除。如果一个列具有数值但方差低，AutoML会将该值转换为分类特征并应用独热编码。如果一个分类列具有高方差，将利用独热哈希编码。
- en: AutoML will also generate a k-means clustering model for each numeric column.
    Each sample will have its distance from the centroid of the cluster added to the
    dataset.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AutoML还将为每个数值列生成一个k-means聚类模型。每个样本将添加其与簇中心的距离到数据集中。
- en: Often, datasets will include missing values. AutoML will replace missing values
    with averages if the column is numeric or impute values using the most common
    value for a given column if it is categorical. This can actually be customized
    by leveraging a `FeaturizationConfig` in AutoML. The imputer for missing values
    can replace values with the mean, median, or mode of a value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据集会包含缺失值。如果列是数值型的，AutoML会用平均值替换缺失值；如果列是分类型的，它会使用给定列中最常见的值来填充。实际上，这可以通过在AutoML中利用`FeaturizationConfig`来自定义。缺失值填充器可以用值的均值、中位数或众数来替换值。
- en: For features that are date-time values, additional features will be generated
    including year, month, day, day of the year, day of the week, quarter, hour, minute,
    and second.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日期时间值特征，将生成包括年份、月份、日、年中的日、星期几、季度、小时、分钟和秒在内的附加特征。
- en: Specific to the forecasting task, the `TimeIndexFeaturization` class is leveraged
    to generate many different features. Examples include an integer value specifying
    whether it is before or after a certain date (July 1st, for example), the year,
    calendar quarter, calendar month, day, hour, minute, second, an a.m. or p.m. indicator,
    the day of the week, the day of the quarter (1 through 92), the day of the year
    (1 through 366), as well as an ISO week and year defined by the ISO 8601 standard.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预测任务，利用`TimeIndexFeaturization`类生成许多不同的特征。例如，包括一个整数值，指定是否在某个日期之前或之后（例如7月1日），年份、日历季度、日历月份、日、小时、分钟、秒、上午或下午指示符、星期几、季度中的天数（1到92）、年中的天数（1到366），以及由ISO
    8601标准定义的ISO周和年。
- en: For features that are text, term frequency will be added based on trigrams,
    bigrams, and unigrams. Text features are converted into document feature vectors.
    AutoML can be configured to leverage **Bidirectional Encoder Representations from
    Transformers** (**BERT**) during the featurization process by enabling deep learning.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本特征，将基于三元组、二元组和单语元添加词频。文本特征被转换为文档特征向量。通过启用深度学习，AutoML可以在特征化过程中配置利用**双向编码器表示从Transformer**（**BERT**）。
- en: AutoML not only can handle a variety of featurization steps to prepare models
    for training but can also handle classification, regression, and time-series forecasting
    directly in AMLS and accomplish these same modeling tasks, as well as compute
    vision tasks through the AML Python SDK.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: AutoML不仅可以处理各种特征化步骤以准备模型进行训练，还可以在AMLS中直接处理分类、回归和时间序列预测，并完成相同的建模任务，以及通过AML Python
    SDK完成计算机视觉任务。
- en: In the next section, we will explore how to leverage AMLS to accomplish classification
    for the well-known Titanic dataset. The dataset link will be available in the
    book’s GitHub repository.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何利用AMLS来完成对著名泰坦尼克号数据集的分类。数据集链接将在本书的GitHub存储库中提供。
- en: AutoML using AMLS
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AMLS的AutoML
- en: As mentioned earlier in the chapter, there are two ways to use AutoML in AML.
    For citizen data scientists or data scientists who prefer a no-code approach,
    AMLS can be used; for data scientists with coding experience, the AML Python SDK
    can be used. In this section, we will show you how to use AMLS to train a classification
    model on your Titanic dataset with AutoML to predict whether a passenger would
    survive the Titanic disaster or not.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，在AML中可以使用两种方式使用AutoML。对于公民数据科学家或偏好无代码方法的数据科学家，可以使用AMLS；对于有编码经验的数据科学家，可以使用AML
    Python SDK。在本节中，我们将向您展示如何使用AMLS在您的泰坦尼克号数据集上训练分类模型，以预测乘客是否能在泰坦尼克号灾难中幸存。
- en: 'Please sign in to AMLS at [https://ml.azure.com](https://ml.azure.com) and
    follow these instructions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请在 [https://ml.azure.com](https://ml.azure.com) 上登录到 AMLS 并按照以下说明操作：
- en: Select your subscription and the workspace you have been using throughout the
    book.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您在整个书中使用的订阅和工作室。
- en: 'On the left-hand side of the studio, click on **Automated ML** as shown in
    *Figure 5**.4*:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作室的左侧，如图 *图 5.4* 所示点击 **自动化机器学习**：
- en: '![Figure 5.4 – Importing AutoMLConfig](img/B18003_05_004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 导入 AutoMLConfig](img/B18003_05_004.jpg)'
- en: Figure 5.4 – Importing AutoMLConfig
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 导入 AutoMLConfig
- en: 'Select `titanic.csv` from your local computer to Azure as shown in *Figure
    5**.5*:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的本地计算机选择 `titanic.csv` 上传到 Azure，如图 *图 5.5* 所示：
- en: '![Figure 5.5 – Creating a new dataset by uploading titanic.csv from your local
    computer](img/B18003_05_005.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 通过从本地计算机上传 titanic.csv 创建新的数据集](img/B18003_05_005.jpg)'
- en: Figure 5.5 – Creating a new dataset by uploading titanic.csv from your local
    computer
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 通过从本地计算机上传 titanic.csv 创建新的数据集
- en: 'Provide basic information for the dataset as shown in *Figure 5**.6*:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如图 *图 5.6* 所示为数据集提供基本信息：
- en: '![Figure 5.6 – Providing basic information for the dataset](img/B18003_05_006.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 为数据集提供基本信息](img/B18003_05_006.jpg)'
- en: Figure 5.6 – Providing basic information for the dataset
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 为数据集提供基本信息
- en: 'On the next screen, click on `titanic.csv` as shown in *Figure 5**.7*. The
    dataset is available in the GitHub repo for this book:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，如图 *图 5.7* 所示点击 `titanic.csv`。数据集可在本书的 GitHub 仓库中找到：
- en: '![Figure 5.7 – Providing the location of stored data files](img/B18003_05_007.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 提供存储数据文件的位置](img/B18003_05_007.jpg)'
- en: Figure 5.7 – Providing the location of stored data files
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 提供存储数据文件的位置
- en: 'Once uploaded, the next screen will show you the settings and preview based
    on the upload file. The only setting you need to change is under **Column headers**,
    which you should set to **Only first file has headers** as shown in *Figure 5**.8*:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传后，下一屏幕将显示基于上传文件的设置和预览。您唯一需要更改的设置是在 **列标题** 下，您应该将其设置为 **只有第一个文件有标题**，如图 *图
    5.8* 所示：
- en: '![Figure 5.8 – Dataset preview](img/B18003_05_008.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 数据集预览](img/B18003_05_008.jpg)'
- en: Figure 5.8 – Dataset preview
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 数据集预览
- en: 'The next screen will show the dataset’s schema, which has been autodetected
    from the file as shown in *Figure 5**.9*:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一屏幕将显示数据集的模式，该模式已从文件自动检测到，如图 *图 5.9* 所示：
- en: '![Figure 5.9 – Dataset settings](img/B18003_05_009.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 数据集设置](img/B18003_05_009.jpg)'
- en: Figure 5.9 – Dataset settings
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 数据集设置
- en: 'The last step is to review and confirm the details and click on **Create**
    as shown in *Figure 5**.10*:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是审查并确认细节，然后如图 *图 5.10* 所示点击 **创建**：
- en: '![Figure 5.10 – Reviewing and confirming the creation of the dataset](img/B18003_05_010.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 审查和确认数据集的创建](img/B18003_05_010.jpg)'
- en: Figure 5.10 – Reviewing and confirming the creation of the dataset
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 审查和确认数据集的创建
- en: 'You will be taken back to the list of the datasets. You should see your Titanic
    dataset, which we named **training**, at the top of the list. Go ahead, select
    it, and click on **Next** as shown in *Figure 5**.11*:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被带回到数据集列表。您应该在列表顶部看到我们命名为 **训练** 的泰坦尼克号数据集。继续，选择它，然后如图 *图 5.11* 所示点击 **下一步**：
- en: '![Figure 5.11 – Select the training dataset and clicking on Next](img/B18003_05_011.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 选择训练数据集并点击 **下一步**](img/B18003_05_011.jpg)'
- en: Figure 5.11 – Select the training dataset and clicking on Next
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 选择训练数据集并点击 **下一步**
- en: 'In this step, you need to create an experiment for your AutoML run and then
    select the target column, sometimes called the *dependent variable*, and lastly,
    select a compute cluster for the model training as shown in *Figure 5**.12*:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，您需要为您的 AutoML 运行创建一个实验，然后选择目标列，有时称为 *因变量*，最后选择用于模型训练的计算集群，如图 *图 5.12*
    所示：
- en: '![Figure 5.12 – Creating a new AutoML experiment and selecting the target column
    and compute cluster](img/B18003_05_012.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 创建新的 AutoML 实验，选择目标列和计算集群](img/B18003_05_012.jpg)'
- en: Figure 5.12 – Creating a new AutoML experiment and selecting the target column
    and compute cluster
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 创建新的 AutoML 实验，选择目标列和计算集群
- en: 'On the next screen, you can select the machine learning task. AutoML has auto-detected
    the task based on the target column. In this case, it should be **Classification**
    as shown in *Figure 5**.13*:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，您可以选择机器学习任务。AutoML 已根据目标列自动检测到任务。在这种情况下，它应该是 **分类**，如图 *图 5.13* 所示：
- en: '![Figure 5.13 – Selecting the machine learning task (for example, in this case,
    Classification)](img/B18003_05_013.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 选择机器学习任务（例如，在本例中，分类）](img/B18003_05_013.jpg)'
- en: Figure 5.13 – Selecting the machine learning task (for example, in this case,
    Classification)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 选择机器学习任务（例如，在本例中，为分类）
- en: 'Next, click on `0.5` hours). Click **Save** to exit as shown in *Figure 5**.14*:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击 `0.5` 小时）。点击 **保存** 以退出，如图 *图 5.14* 所示：
- en: '![Figure 5.14 – Configuring settings for the training job](img/B18003_05_014.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 配置训练作业设置](img/B18003_05_014.jpg)'
- en: Figure 5.14 – Configuring settings for the training job
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 配置训练作业设置
- en: 'Click `3`. For the `10`, and finally, click on **Finish** as shown in *Figure
    5**.15*:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `3`。对于 `10`，最后，点击 **完成**，如图 *图 5.15* 所示：
- en: '![Figure 5.15 – Setting the validation type and test dataset](img/B18003_05_015.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 设置验证类型和测试数据集](img/B18003_05_015.jpg)'
- en: Figure 5.15 – Setting the validation type and test dataset
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 设置验证类型和测试数据集
- en: 'Once the model training is done, you will be presented with a screen summarizing
    the training statistics, such as the duration of the training, a link to the **training**
    dataset, and a summary of the best-performing model, with the name of its algorithm
    and its performance metric (for example, **AUC weighted**) as shown in *Figure
    5**.16*:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模型训练完成，你将看到一个屏幕，其中总结了训练统计信息，例如训练持续时间、**训练**数据集的链接以及最佳性能模型的摘要，包括其算法名称和性能指标（例如，**AUC
    加权**），如图 *图 5.16* 所示：
- en: '![Figure 5.16 – Model and run summary after training is completed](img/B18003_05_016.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 训练完成后模型和运行摘要](img/B18003_05_016.jpg)'
- en: Figure 5.16 – Model and run summary after training is completed
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 训练完成后模型和运行摘要
- en: Now that you have seen how to leverage AutoML through AMLS, take a moment to
    review the output not only in the **Details** section as shown in *Figure 5**.16*
    but also review each tab and explore the wealth of information provided during
    an AutoML experiment run.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了如何通过 AMLS 利用 AutoML，请花点时间回顾输出，不仅是在 *详细信息* 部分，如图 *图 5.16* 所示，还要查看每个选项卡并探索
    AutoML 实验运行期间提供的大量信息。
- en: Next, we will explore leveraging AutoML through the AML Python SDK. The AML
    Python SDK provides fine-grained control over your experiment, as we will see
    in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索如何通过 AML Python SDK 利用 AutoML。AML Python SDK 提供了对实验的精细控制，我们将在下一节中看到。
- en: AutoML using the AML Python SDK
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AML Python SDK 进行 AutoML
- en: Now that you have seen how to leverage AutoML inside AMLS, we will explore creating
    a model leveraging the AML Python SDK.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了如何在 AMLS 中利用 AutoML，我们将探索如何利用 AML Python SDK 创建模型。
- en: Earlier in the chapter, in *Introduction to AutoML*, we cloned our sample notebooks
    to leverage this material. For this chapter, note that there is a single notebook
    titled `Chapter5_Titanic_AutoML`. The initial code should look familiar, as the
    preparation of the dataset has not changed. However, when we run the experiment,
    we will now be leveraging an AutoML experiment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的部分，在 *AutoML 简介* 中，我们克隆了我们的示例笔记本以利用这些材料。对于本章，请注意，有一个名为 `Chapter5_Titanic_AutoML`
    的单个笔记本。初始代码应该看起来很熟悉，因为数据集的准备没有变化。然而，当我们运行实验时，我们现在将利用一个 AutoML 实验。
- en: In order to run an AutoML experiment, we will need to import `AutoMLConfig`
    as shown in *line 8* of the following figure.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行一个 AutoML 实验，我们需要导入 `AutoMLConfig`，如图中 *第 8 行* 所示。
- en: 'Here’s `AutoMLConfig` being imported with the Python SDK:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Python SDK 导入 `AutoMLConfig` 的示例：
- en: '![Figure 5.17 – Importing AutoMLConfig](img/B18003_05_017.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 导入 AutoMLConfig](img/B18003_05_017.jpg)'
- en: Figure 5.17 – Importing AutoMLConfig
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 导入 AutoMLConfig
- en: As part of an AutoML experiment, we are required to specify a training dataset,
    but we are not required to specify a validation or testing dataset. However, we
    can specify the training and validation datasets, and the test datasets in preview.
    In our sample, we will separate the dataset into a training, test, and validation
    dataset.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 AutoML 实验的一部分，我们需要指定一个训练数据集，但不需要指定验证或测试数据集。然而，我们可以指定训练和验证数据集，并在预览中指定测试数据集。在我们的示例中，我们将数据集分为训练、测试和验证数据集。
- en: Leveraging the `train_test_split` method from `sklearn`, we will break the dataset
    into three datasets used for training, validation, and testing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `sklearn` 中的 `train_test_split` 方法，我们将数据集分成三个数据集，分别用于训练、验证和测试。
- en: 'Let’s now look into how we can split the data for training the model and also
    test the model to analyze the accuracy of the model built:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨如何分割数据以训练模型，以及测试模型以分析所建模型的准确性：
- en: 'The following code is going to split the dataset between model training and
    model evaluation. We are also specifying which column is used for prediction –
    in the following case, it’s `Survived`. Then, we will print the output to validate
    whether the split worked or not. Here’s the dataset being split for model training,
    testing, and validation:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将分割数据集用于模型训练和模型评估。我们还指定了用于预测的列 – 在以下情况下，它是`Survived`。然后，我们将打印输出以验证分割是否成功。以下是用于模型训练、测试和验证的数据集分割：
- en: '![Figure 5.18 – Dataset splitting](img/B18003_05_018.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图5.18 – 数据集分割](img/B18003_05_018.jpg)'
- en: Figure 5.18 – Dataset splitting
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 – 数据集分割
- en: Once the dataset has been split, we can upload the datasets from our local directory
    where they have been saved in the `automl_train` folder, and when placed into
    blob storage, they will be placed into a directory called `titanic-auto-ml`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据集被分割，我们可以从本地目录上传数据集，这些数据集被保存在`automl_train`文件夹中，当放置到blob存储时，它们将被放置在名为`titanic-auto-ml`的目录中。
- en: 'In the following screenshot, the directory is uploaded into the default data
    store:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，目录被上传到默认的数据存储：
- en: '![Figure 5.19 – Uploading datasets to the data store](img/B18003_05_019.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图5.19 – 将数据集上传到数据存储](img/B18003_05_019.jpg)'
- en: Figure 5.19 – Uploading datasets to the data store
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 – 将数据集上传到数据存储
- en: 'Given that the data is now in blob storage, we can leverage the files to create
    tabular datasets with the AML Python SDK, noting their location in blob storage
    as shown here:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于数据现在在blob存储中，我们可以利用这些文件使用AML Python SDK创建表格数据集，并注意它们在blob存储中的位置，如下所示：
- en: '![Figure 5.20 – Creating AML tabular datasets](img/B18003_05_020.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图5.20 – 创建AML表格数据集](img/B18003_05_020.jpg)'
- en: Figure 5.20 – Creating AML tabular datasets
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 – 创建AML表格数据集
- en: 'Using the AML Python SDK, we can create an experiment as shown in the following
    code block in *line 4*:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用AML Python SDK，我们可以在*第4行*的代码块中创建一个实验，如下所示：
- en: '![Figure 5.21 – Creating an Azure ML experiment](img/B18003_05_021.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图5.21 – 创建Azure ML实验](img/B18003_05_021.jpg)'
- en: Figure 5.21 – Creating an Azure ML experiment
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 – 创建Azure ML实验
- en: An AutoML experiment can be run on a compute instance but given the duration
    of an experiment will be longer than we have seen up to this point, we will run
    it on a compute cluster. The following code shows how to create a compute cluster
    as we saw in [*Chapter 1*](B18003_01.xhtml#_idTextAnchor020)*, Introducing the
    Azure Machine* *Learning Service*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: AutoML实验可以在计算实例上运行，但考虑到实验的持续时间将比我们迄今为止看到的要长，我们将它在计算集群上运行。以下代码显示了如何创建计算集群，正如我们在[*第1章*](B18003_01.xhtml#_idTextAnchor020)*，介绍Azure机器学习服务*中看到的。
- en: 'Next, we will create a compute cluster for us to write out code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个计算集群以便我们编写代码：
- en: '![Figure 5.22 – Compute cluster creation for running the AML experiment run](img/B18003_05_022.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图5.22 – 为运行AML实验运行创建计算集群](img/B18003_05_022.jpg)'
- en: Figure 5.22 – Compute cluster creation for running the AML experiment run
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22 – 为运行AML实验运行创建计算集群
- en: For an AutoML experiment, we are able to provide fine-grained control over the
    experiment that is being run with the Python SDK.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AutoML实验，我们能够通过Python SDK提供对正在运行的实验的精细控制。
- en: 'An AutoML experiment run through the SDK can specify its behavior during the
    experiment run:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SDK运行的AutoML实验可以在实验运行期间指定其行为：
- en: '![Figure 5.23 – AutoML experiment settings](img/B18003_05_023.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图5.23 – AutoML实验设置](img/B18003_05_023.jpg)'
- en: Figure 5.23 – AutoML experiment settings
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23 – AutoML实验设置
- en: As shown in *Figure 5**.23*, we are able to specify `experiment_time_hours`.
    If no value is provided, the experiment run will time out after 6 days. `enable_early_stopping`,
    which defaults to `True`, will stop the experiment early if the model is not improving
    after `n_interations`. This behavior ensures that at a minimum, 20 iterations
    are run before an experiment run is stopped early.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图5*.*23*所示，我们可以指定`experiment_time_hours`。如果没有提供值，实验运行将在6天后超时。`enable_early_stopping`默认为`True`，如果模型在`n_interations`后没有改进，它将提前停止实验。这种行为确保在实验运行提前停止之前至少运行20次迭代。
- en: '`iteration_timeout_minutes` is the number of minutes each iteration can run
    before it is terminated. If it is not specified, a default value of 1 month is
    used. Another setting that can be configured is `max_concurrent_iterations`. An
    AML compute cluster can handle a single iteration per node. Specifying this value
    will expand the number of active nodes in a given cluster. If `max_concurrent_iterations`
    is greater than the node count in a given cluster, then the experiment runs will
    be queued and will execute once a node is available within a cluster. Setting
    `max_cores_per_iteration` to a value of `–1` indicates that all the cores available
    from the compute running the iteration should be leveraged. This value defaults
    to `1`. It is acceptable to provide values of `–1`, `1`, or a number that is less
    than or equal to the number of cores that are on the compute running the training
    experiment.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`iteration_timeout_minutes`是每个迭代可以运行的最长时间，在此之后它将被终止。如果没有指定，将使用默认值1个月。另一个可以配置的设置是`max_concurrent_iterations`。AML计算集群可以处理每个节点一个迭代。指定此值将扩展给定集群中活动节点的数量。如果`max_concurrent_iterations`大于给定集群中的节点数，那么实验运行将被排队，并在集群中有一个节点可用时执行。将`max_cores_per_iteration`设置为`–1`表示应该利用计算运行迭代时所有可用的核心。此值默认为`1`。提供`–1`、`1`或小于或等于运行训练实验的计算上核心数的数值是可以接受的。'
- en: We can specify `n_cross_validations`, and that will ensure the validation dataset
    will be extracted from the training data. However, in our experiment, we are explicitly
    passing a validation dataset, so this is commented out in *line 7* of *Figure
    5**.23*. If neither `n_cross_validations` is set nor is a validation dataset provided,
    AutoML will use its own validation techniques. If neither is provided and an AutoML
    experiment run is working with a dataset greater than 20,000 rows, 10% of the
    data will be used as a validation dataset. If a dataset is smaller than 20,000
    rows, then cross-validation is leveraged. If the dataset is less than 1,000 rows,
    10 folds are used for cross-validation, and if the dataset is between 1,000 and
    20,000 rows, then 3 folds are used for cross-validation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定`n_cross_validations`，这将确保验证数据集将从训练数据中提取。然而，在我们的实验中，我们明确传递了一个验证数据集，所以这在**图5**.23的**第7行**被注释掉了。如果既没有设置`n_cross_validations`，也没有提供验证数据集，AutoML将使用它自己的验证技术。如果两者都没有提供，并且一个AutoML实验运行正在使用大于20,000行的数据集，那么将使用10%的数据作为验证数据集。如果数据集小于20,000行，则利用交叉验证。如果数据集小于1,000行，则使用10个折进行交叉验证；如果数据集在1,000到20,000行之间，则使用3个折进行交叉验证。
- en: '`primary_metric` is the metric used to evaluate the model. Each task type has
    a list of valid metrics. The code here provides a list of the metrics available
    to use for a classification model evaluation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`primary_metric`是用于评估模型的指标。每个任务类型都有一个有效的指标列表。这里的代码提供了一个可用于分类模型评估的指标列表：'
- en: '![Figure 5.24 – Primary metrics for classification](img/B18003_05_024.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图5.24 – 分类的主要指标](img/B18003_05_024.jpg)'
- en: Figure 5.24 – Primary metrics for classification
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24 – 分类的主要指标
- en: Another property of an AutoML experiment run that can be set is featurization.
    The value here can either be set to `auto`, `off`, or `FeaturizationConfig`. If
    the value of `FeaturizationConfig` is specified, you can provide custom featurization,
    which will allow you to specify column transformer properties that support an
    imputer using the mean, median, or mode, as well as a one-hot hash encoding. For
    our example, we will leave the featurization as `auto`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置的另一个AutoML实验运行属性是特征化。这里的值可以是设置为`auto`、`off`或`FeaturizationConfig`。如果指定了`FeaturizationConfig`的值，你可以提供自定义特征化，这将允许你指定支持使用均值、中位数或众数作为填充器的列转换器属性，以及一个热哈希编码。对于我们的示例，我们将保持特征化为`auto`。
- en: By setting the value of verbosity in *Figure 5**.23*, we specify how granular
    the information logged in a given experiment will be. Keeping the logging at the
    `INFO` level will provide fine-grained logs inside the run of an AutoML experiment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置**图5**.23中的详细程度值，我们指定了给定实验中记录的信息的粒度。将日志保持在`INFO`级别将在AutoML实验的运行中提供细粒度的日志。
- en: 'The next thing that needs to be done is creating the `AutoMLConfig` object
    for running the experiment. There are many properties to support an AutoML experiment
    run. The first property we will review is the property *task*. The supported task
    types include classification, regression, and forecasting. Currently, in public
    preview, multi-class and multi-label image classification, object detection, and
    instance segmentation are available. For our task type, we will select `''classification''`
    as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要做的是创建用于运行实验的 `AutoMLConfig` 对象。有许多属性支持 AutoML 实验运行。我们将首先审查的属性是 *任务* 属性。支持的任务类型包括分类、回归和预测。目前，在公共预览版中，多类别和多标签图像分类、目标检测和实例分割是可用的。对于我们的任务类型，我们将选择
    `'classification'`，如下面的截图所示：
- en: '![Figure 5.25 – AutoMLConfig object](img/B18003_05_025.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.25 – AutoMLConfig 对象](img/B18003_05_025.jpg)'
- en: Figure 5.25 – AutoMLConfig object
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25 – AutoMLConfig 对象
- en: The `debug_log` property specifies the log file to which the debug information
    is written. If not specified, the value of `'automl.log'` is used as the log file
    name.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug_log` 属性指定了调试信息写入的日志文件。如果没有指定，则使用 `''automl.log''` 作为日志文件名。'
- en: '`compute_target` is specified, which can be either a compute instance or a
    compute cluster. Leveraging a compute cluster enables concurrent runs for an AutoML
    experiment run, which cannot be leveraged by a compute instance.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`compute_target` 被指定，可以是计算实例或计算集群。利用计算集群可以实现 AutoML 实验运行的并发运行，而计算实例无法实现这一点。'
- en: '`blocked_models` is a list of models to exclude from a given AutoML experiment
    run. For a classification model, the following is a list of models that can be
    excluded from a given experiment:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`blocked_models` 是一个要排除在给定 AutoML 实验运行之外的模型列表。对于分类模型，以下是可以排除在给定实验之外的模型列表：'
- en: '| **Classification Model** | **AutoMLConfig Value** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **分类模型** | **AutoML 配置值** |'
- en: '| Averaged Perceptron Classifier | `AveragedPerceptronClassifier` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 平均感知器分类器 | `AveragedPerceptronClassifier` |'
- en: '| Bernoulli Naïve Bayes | `BernoulliNaiveBayes` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 伯努利朴素贝叶斯 | `BernoulliNaiveBayes` |'
- en: '| Decision Tree | `DecisionTree` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 决策树 | `DecisionTree` |'
- en: '| Extreme Random Trees | `ExtremeRandomTrees` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 极端随机树 | `ExtremeRandomTrees` |'
- en: '| Gradient Boosting | `GradientBoosting` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 梯度提升 | `GradientBoosting` |'
- en: '| K-Nearest Neighbors Classifier | `KNN` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| K 近邻分类器 | `KNN` |'
- en: '| Light GBM Classified | `LightGBM` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| Light GBM 分类 | `LightGBM` |'
- en: '| Linear Support Vector Machine | `LinearSVM` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 线性支持向量机 | `LinearSVM` |'
- en: '| Logistic Regression | `LogisticRegression` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑回归 | `LogisticRegression` |'
- en: '| Multinomial Naïve Bayes | `MultinomialNaiveBayes` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 多项式朴素贝叶斯 | `MultinomialNaiveBayes` |'
- en: '| Random Forest | `RandomForest` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 随机森林 | `RandomForest` |'
- en: '| SGD Classifier | `SGD` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| SGD 分类器 | `SGD` |'
- en: '| Support Vector Machine | `SVM` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 支持向量机 | `SVM` |'
- en: '| TabNet Classifier | `TabNetClassifier` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| TabNet 分类器 | `TabNetClassifier` |'
- en: '| TensorFlow DNN Classifier | `TensorFlowDNN` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| TensorFlow DNN 分类器 | `TensorFlowDNN` |'
- en: '| TensorFlow Linear Classifier | `TensorFlowLinearClassifier` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| TensorFlow 线性分类器 | `TensorFlowLinearClassifier` |'
- en: '| XGBoost Classifier | `XGBoostClassifier` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| XGBoost 分类器 | `XGBoostClassifier` |'
- en: Figure 5.26 – List of models available to block
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26 – 可用以阻止的模型列表
- en: '`enable_onnx_compatible_models` defaults to a value of `False`. If this value
    is set to `True`, then you can export models in the ONNX format to leverage them
    for high-performance gains during inference.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`enable_onnx_compatible_models` 的默认值为 `False`。如果将该值设置为 `True`，则可以将模型导出为 ONNX
    格式，以便在推理期间利用它们实现高性能提升。'
- en: '`training_data` can be a pandas DataFrame, an AML dataset, or a tabular dataset.
    *Figure 5**.20* showcases how to create the tabular training dataset, which is
    passed to the `AutoMLConfig` object in *Figure 5**.25* on *line 19*. Note that
    the training dataset does include the response variable, `Survived`, which is
    specified as the response variable in the `label_column_name` property on *line
    20*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`training_data` 可以是 pandas DataFrame、AML 数据集或表格数据集。*图 5.20* 展示了如何创建表格训练数据集，该数据集在
    *图 5.25* 上的第 19 行传递给 `AutoMLConfig` 对象。请注意，训练数据集确实包括响应变量 `Survived`，该变量在第 20 行的
    `label_column_name` 属性中指定为响应变量。'
- en: Note that the validation dataset is provided in `AutoMLConfig` in the property
    named `validation_data`, which means that `n_cross_validations` cannot be provided
    in `automl_settings`. As mentioned earlier, it is not valid to supply both.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，验证数据集在 `AutoMLConfig` 中以 `validation_data` 属性名提供，这意味着 `n_cross_validations`
    不能在 `automl_settings` 中提供。如前所述，同时提供两者是不合法的。
- en: As part of the AML Python SDK, you can specify `test_data`. This feature is
    currently in preview. Metrics are calculated by using this dataset.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 AML Python SDK 的一部分，您可以指定 `test_data`。此功能目前处于预览阶段。通过使用此数据集来计算指标。
- en: '`experiment_exit_score` is the value to hit for the primary metric. If the
    primary metric hits that value, then the experiment will terminate early.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`experiment_exit_score` 是主要指标需要达到的值。如果主要指标达到该值，则实验将提前终止。'
- en: 'In order to run the experiment, the `automl_config` object is submitted to
    the experiment as shown in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行实验，将 `automl_config` 对象提交给实验，如下所示：
- en: '![Figure 5.27 – Submitting the AutoML experiment run](img/B18003_05_027.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.27 – 提交 AutoML 实验运行](img/B18003_05_027.jpg)'
- en: Figure 5.27 – Submitting the AutoML experiment run
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27 – 提交 AutoML 实验运行
- en: 'In the notebook, while not required, we can specify to hold off on the execution
    of future cells until the run is complete by executing the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中，虽然不是必需的，但我们可以通过执行以下代码来指定在运行完成之前暂停后续单元格的执行：
- en: '![Figure 5.28 – Waiting for completion](img/B18003_05_028.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.28 – 等待完成](img/B18003_05_028.jpg)'
- en: Figure 5.28 – Waiting for completion
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28 – 等待完成
- en: Wait for the experiment to complete and then move on to see the output of the
    model training. We can also view the metric to understand how the model performed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 等待实验完成，然后继续查看模型训练的输出。我们还可以查看指标以了解模型的性能。
- en: Parsing your AutoML results via AMLS and the AML SDK
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 AMLS 和 AML SDK 解析您的 AutoML 结果
- en: 'When the experiment run is completed, we are able to extract valuable information
    from the AutoML experiment run by leveraging the AML Python SDK:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当实验运行完成后，我们可以通过利用 AML Python SDK 从 AutoML 实验运行中提取有价值的信息：
- en: 'For an AutoML experiment run, each run is executed as a child run of the AutoML
    experiment run. This means that we can get the best run for the experiment run
    by looking at the child runs for a given run as shown in *Figure 5**.29*:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 AutoML 实验运行，每个运行都作为 AutoML 实验运行的子运行执行。这意味着我们可以通过查看给定运行的子运行来获取实验运行的最佳运行，如图
    *图 5.29* 所示：
- en: '![Figure 5.29 – Retrieving the best child run for an AutoML experiment run](img/B18003_05_029.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.29 – 检索 AutoML 实验运行的最佳子运行](img/B18003_05_029.jpg)'
- en: Figure 5.29 – Retrieving the best child run for an AutoML experiment run
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29 – 检索 AutoML 实验运行的最佳子运行
- en: As we can view the information programmatically, we are also able to retrieve
    the best model through AMLS. In the studio, by clicking on the `automl-classification-titanic`
    experiment, we can see the run created for the experiment.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以以编程方式查看信息，我们也能够通过 AMLS 获取最佳模型。在工作室中，通过单击 `automl-classification-titanic`
    实验项目，我们可以看到为实验创建的运行。
- en: 'Clicking on the run hyperlink brings us to the details of the experiment run.
    If we move over to the **Models** tab, we can see the models by their values for
    the primary metric, and an explanation provided for the best model:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击运行超链接将带我们到实验运行的详细信息。如果我们切换到 **模型** 选项卡，我们可以根据主要指标的值查看模型，并查看最佳模型提供的解释：
- en: '![Figure 5.30 – Retrieving the best child run for an AutoML experiment run
    in AMLS](img/B18003_05_030.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.30 – 在 AMLS 中检索 AutoML 实验运行的最佳子运行](img/B18003_05_030.jpg)'
- en: Figure 5.30 – Retrieving the best child run for an AutoML experiment run in
    AMLS
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30 – 在 AMLS 中检索 AutoML 实验运行的最佳子运行
- en: From *Figure 5**.30*, if we click on the **View explanation** hyperlink, we
    can explore information about the best model that AutoML was able to create.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *图 5.30*，如果我们单击 **查看解释** 超链接，我们可以探索 AutoML 能够创建的最佳模型的信息。
- en: 'By clicking on the **Aggregate feature importance** tab, we can see the features
    that had the highest impact on the model. We can see that **Sex**, **Pclass**,
    **Age**, and **Fare** were the top four features by importance for the model that
    was created:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击 **聚合特征重要性** 选项卡，我们可以看到对模型影响最大的特征。我们可以看到，**性别**、**舱位等级**、**年龄**和**票价**是创建的模型中最重要的前四个特征：
- en: '![Figure 5.31 – Aggregate feature importance](img/B18003_05_031.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.31 – 聚合特征重要性](img/B18003_05_031.jpg)'
- en: Figure 5.31 – Aggregate feature importance
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 聚合特征重要性
- en: 'From the `best_run` object, we can pull back the featurization that occurred
    on the dataset programmatically by downloading the `featurization summary json`
    file from the `outputs` directory. This gives us insight into the automated featurization
    that occurred on the dataset to provide the best model:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`best_run`对象中，我们可以通过从`outputs`目录下载`featurization summary json`文件来程序化地检索数据集上发生的特征化。这使我们能够了解对数据集进行的自动化特征化，以提供最佳模型：
- en: '![Figure 5.32 – Retrieving the featurization results](img/B18003_05_032.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图5.32 – 获取特征化结果](img/B18003_05_032.jpg)'
- en: Figure 5.32 – Retrieving the featurization results
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.32 – 获取特征化结果
- en: 'The featurization results can not only be reviewed programmatically but the
    explanation of the best model within AMLS can also be reviewed as shown here:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征化结果不仅可以程序化地审查，而且AMLS中最佳模型的解释也可以审查，如下所示：
- en: '![Figure 5.33 – The data transformation process implemented by AutoML](img/B18003_05_033.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图5.33 – AutoML实现的数据转换过程](img/B18003_05_033.jpg)'
- en: Figure 5.33 – The data transformation process implemented by AutoML
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.33 – AutoML实现的数据转换过程
- en: 'The run details can be viewed directly in the notebook by leveraging the `RunDetails`
    widget as shown in the code in *Figure 5**.34*:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过利用`RunDetails`小部件直接在笔记本中查看运行详情，如图*图5.34*中的代码所示：
- en: '![Figure 5.34 – The RunDetails widget](img/B18003_05_034.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图5.34 – RunDetails小部件](img/B18003_05_034.jpg)'
- en: Figure 5.34 – The RunDetails widget
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.34 – The RunDetails widget
- en: 'With the widget, you can visualize the value of the metric at each iteration
    of the training run for the primary metric (and other metrics as well), as seen
    in the following figure:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该小部件，您可以在以下图中查看主要指标（以及其他指标）在训练运行每次迭代的指标值：
- en: '![Figure 5.35 – Training iteration for the AutoML experiment run](img/B18003_05_035.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图5.35 – AutoML实验运行的训练迭代](img/B18003_05_035.jpg)'
- en: Figure 5.35 – Training iteration for the AutoML experiment run
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.35 – AutoML实验运行的训练迭代
- en: 'For the training run, we are able to pull out the best run and the fitted model
    programmatically through the SDK as shown here:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于训练运行，我们能够通过SDK程序化地提取最佳运行和拟合的模型，如下所示：
- en: '![Figure 5.36 – Retrieving the best model](img/B18003_05_036.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图5.36 – 获取最佳模型](img/B18003_05_036.jpg)'
- en: Figure 5.36 – Retrieving the best model
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.36 – 获取最佳模型
- en: 'We are also able to retrieve the estimator leveraged by AutoML as shown here.
    `estimator` is a class that helps organize the execution and configuration used
    for a particular run. It also allows us to configure the scale and compute used
    for the modeling. There are multiple steps inside `estimator` to be the code,
    and `[-1]` goes back to the previous steps:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还能够检索AutoML使用的估计器，如下所示。`estimator`是一个类，它帮助组织特定运行使用的执行和配置。它还允许我们配置建模使用的规模和计算。`estimator`内部有多个步骤用于代码，而`[-1]`则返回到之前的步骤：
- en: '![Figure 5.37 – Retrieving the estimator](img/B18003_05_037.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图5.37 – 获取估计器](img/B18003_05_037.jpg)'
- en: Figure 5.37 – Retrieving the estimator
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.37 – 获取估计器
- en: 'Given the model has been retrieved, we are able to leverage it for predictions
    directly as shown in *Figure 5**.38*:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于已经检索到模型，我们可以直接利用它进行预测，如图*图5.38*所示：
- en: '![Figure 5.38 – Leveraging the AutoML model directly](img/B18003_05_038.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图5.38 – 直接利用AutoML模型](img/B18003_05_038.jpg)'
- en: Figure 5.38 – Leveraging the AutoML model directly
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.38 – 直接利用AutoML模型
- en: 'We can leverage the test dataset to obtain metrics for the experiment, but
    we can also view a child run for the run that the best model was created for and
    retrieve the primary metrics for the test dataset:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以利用测试数据集获取实验的指标，但也可以查看为最佳模型创建的运行子运行，并检索测试数据集的主要指标：
- en: '![Figure 5.39 – Best model child run](img/B18003_05_039.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图5.39 – 最佳模型子运行](img/B18003_05_039.jpg)'
- en: Figure 5.39 – Best model child run
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.39 – 最佳模型子运行
- en: 'Clicking on the run for the model test displays the metrics that were computed
    for the test dataset provided. This is on the unseen data that was not leveraged
    for model creation:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击模型测试的运行，将显示为提供的测试数据集计算的指标。这是在模型创建时未使用的未见数据：
- en: '![Figure 5.40 – Best model child run metrics](img/B18003_05_040.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图5.40 – 最佳模型子运行指标](img/B18003_05_040.jpg)'
- en: Figure 5.40 – Best model child run metrics
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.40 – 最佳模型子运行指标
- en: 'As an output of the model, a `scoring` file is generated that can be leveraged
    for model deployment. This `score.py` file can be downloaded from the best run
    as shown in *Figure 5**.41*:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为模型输出的结果，会生成一个`scoring`文件，该文件可用于模型部署。这个`score.py`文件可以从*图5*中显示的最佳运行中下载。41*：
- en: '![Figure 5.41 – Downloading the scoring file](img/B18003_05_041.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图5.41 – 下载评分文件](img/B18003_05_041.jpg)'
- en: Figure 5.41 – Downloading the scoring file
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.41 – 下载评分文件
- en: 'Leveraging the AML Python SDK, the model can be registered to the AML workspace
    to enable the model deployment as shown in *Figure 5**.42*:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用AML Python SDK，可以将模型注册到AML工作区，以便像*图5*中所示的那样进行模型部署：
- en: '![Figure 5.42 – Registering the AutoML model](img/B18003_05_042.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图5.42 – 注册AutoML模型](img/B18003_05_042.jpg)'
- en: Figure 5.42 – Registering the AutoML model
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.42 – 注册AutoML模型
- en: 'Given that the model is registered and the scoring script is defined, we can
    deploy the model as an ACI service as shown in *Figure 5**.43*. Once the model
    has been deployed, which usually takes a few minutes, we can then use Postman
    or another REST- or HTTP-based client to call the inferencing API to test or consume
    other applications:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于模型已注册且评分脚本已定义，我们可以像*图5*中所示的那样将模型作为ACI服务部署。一旦模型部署完成，通常需要几分钟，我们就可以使用Postman或其他基于REST或HTTP的客户端调用推理API进行测试或消费其他应用程序：
- en: '![Figure 5.43 – Model deployment](img/B18003_05_043.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图5.43 – 模型部署](img/B18003_05_043.jpg)'
- en: Figure 5.43 – Model deployment
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.43 – 模型部署
- en: 'We are then able to call the test endpoint for real-time inferencing as shown
    in *Figure 5**.44*:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以调用测试端点进行实时推理，如图*图5*中所示：
- en: '![Figure 5.44 – AutoML best model deployment](img/B18003_05_044.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图5.44 – AutoML最佳模型部署](img/B18003_05_044.jpg)'
- en: Figure 5.44 – AutoML best model deployment
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.44 – AutoML最佳模型部署
- en: Next, let’s summarize the chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们总结本章内容。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we gave you an overview of Azure AutoML. We talked about how
    featurization, which can be an extremely time-consuming task, is handled by AutoML.
    We then explored how to use AutoML via AMLS for a no-code experience. Finally,
    we walked you through writing code using AutoML via the AML Python SDK and how
    to view and parse the output.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为您概述了Azure AutoML。我们讨论了特征化，这可能是一个耗时极长的任务，是如何由AutoML处理的。然后我们探讨了如何通过AMLS使用AutoML实现无代码体验。最后，我们向您展示了如何使用AML
    Python SDK编写代码，以及如何查看和解析输出。
- en: In the next chapter, we will show you how to deploy your ML models for real-time
    inference – for example, calling a REST API exposing the trained model – and for
    batch scoring.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您展示如何部署您的ML模型进行实时推理——例如，调用暴露训练模型的REST API——以及批量评分。
- en: 'Part 2: Deploying and Explaining Models in AMLS'
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：在AMLS中部署和解释模型
- en: In *Part 2*, readers will learn how to deploy models in AMLS in batches and
    in real time. Additionally, they will learn how to explain ML models and mitigate
    bias using AMLS.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二部分*中，读者将学习如何在AMLS中批量和实时部署模型。此外，他们还将学习如何使用AMLS解释ML模型并减轻偏差。
- en: 'This section has the following chapters:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 6*](B18003_06.xhtml#_idTextAnchor086), *Deploying ML Models for Real-Time
    Inferencing*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18003_06.xhtml#_idTextAnchor086)，*部署ML模型进行实时推理*'
- en: '[*Chapter 7*](B18003_07.xhtml#_idTextAnchor102), *Deploying ML Models for Batch
    Scoring*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18003_07.xhtml#_idTextAnchor102)，*部署ML模型进行批量评分*'
- en: '[*Chapter 8*](B18003_08.xhtml#_idTextAnchor108), *Responsible AI*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18003_08.xhtml#_idTextAnchor108)，*负责任的AI*'
- en: '[*Chapter 9*](B18003_09.xhtml#_idTextAnchor119), *Productionizing Your Workload
    with MLOps*'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18003_09.xhtml#_idTextAnchor119)，*使用MLOps生产化您的作业*'
