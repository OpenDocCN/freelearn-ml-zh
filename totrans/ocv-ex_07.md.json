["```py\nint main(int argc, char* argv[])\n{\n    string faceCascadeName = argv[1];\n\n    // Variable declarations and initializations\n\n    // Iterate until the user presses the Esc key\n    while(true)\n    {\n        // Capture the current frame\n        cap >> frame;\n\n        // Resize the frame\n        resize(frame, frame, Size(), scalingFactor, scalingFactor, INTER_AREA);\n\n        // Convert to grayscale\n        cvtColor(frame, frameGray, CV_BGR2GRAY);\n\n        // Equalize the histogram\n        equalizeHist(frameGray, frameGray);\n\n        // Detect faces\n        faceCascade.detectMultiScale(frameGray, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30) );\n```", "```py\n        // Draw green rectangle around the face\n        for(int i = 0; i < faces.size(); i++)\n        {\n            Rect faceRect(faces[i].x, faces[i].y, faces[i].width, faces[i].height);\n\n            // Custom parameters to make the mask fit your face. You may have to play around with them to make sure it works.\n            int x = faces[i].x - int(0.1*faces[i].width);\n            int y = faces[i].y - int(0.0*faces[i].height);\n            int w = int(1.1 * faces[i].width);\n            int h = int(1.3 * faces[i].height);\n\n            // Extract region of interest (ROI) covering your face\n            frameROI = frame(Rect(x,y,w,h));\n```", "```py\n            // Resize the face mask image based on the dimensions of the above ROI\n            resize(faceMask, faceMaskSmall, Size(w,h));\n\n            // Convert the above image to grayscale\n            cvtColor(faceMaskSmall, grayMaskSmall, CV_BGR2GRAY);\n\n            // Threshold the above image to isolate the pixels associated only with the face mask\n            threshold(grayMaskSmall, grayMaskSmallThresh, 230, 255, CV_THRESH_BINARY_INV);\n```", "```py\n            // Create mask by inverting the above image (because we don't want the background to affect the overlay)\n            bitwise_not(grayMaskSmallThresh, grayMaskSmallThreshInv);\n\n            // Use bitwise \"AND\" operator to extract precise boundary of face mask\n            bitwise_and(faceMaskSmall, faceMaskSmall, maskedFace, grayMaskSmallThresh);\n\n            // Use bitwise \"AND\" operator to overlay face mask\n            bitwise_and(frameROI, frameROI, maskedFrame, grayMaskSmallThreshInv);\n\n            // Add the above masked images and place it in the original frame ROI to create the final image\n            add(maskedFace, maskedFrame, frame(Rect(x,y,w,h)));\n        }\n\n    // code dealing with memory release and GUi\n\n    return 1;\n}\n```", "```py\nint main(int argc, char* argv[])\n{\n    string faceCascadeName = argv[1];\n    string eyeCascadeName = argv[2];\n\n    // Variable declarations and initializations\n\n    // Face detection code\n\n        vector<Point> centers;\n\n        // Draw green circles around the eyes\n        for(int i = 0; i < faces.size(); i++)\n        {\n            Mat faceROI = frameGray(faces[i]);\n            vector<Rect> eyes;\n\n            // In each face, detect eyes\n            eyeCascade.detectMultiScale(faceROI, eyes, 1.1, 2, 0 |CV_HAAR_SCALE_IMAGE, Size(30, 30));\n```", "```py\n            // For each eye detected, compute the center\n            for(int j = 0; j < eyes.size(); j++)\n            {\n                Point center( faces[i].x + eyes[j].x + int(eyes[j].width*0.5), faces[i].y + eyes[j].y + int(eyes[j].height*0.5) );\n                centers.push_back(center);\n            }\n        }\n\n        // Overlay sunglasses only if both eyes are detected\n        if(centers.size() == 2)\n        {\n            Point leftPoint, rightPoint;\n\n            // Identify the left and right eyes\n            if(centers[0].x < centers[1].x)\n            {\n                leftPoint = centers[0];\n                rightPoint = centers[1];\n            }\n            else\n            {\n                leftPoint = centers[1];\n                rightPoint = centers[0];\n            }\n```", "```py\n            // Custom parameters to make the sunglasses fit your face. You may have to play around with them to make sure it works.\n            int w = 2.3 * (rightPoint.x - leftPoint.x);\n            int h = int(0.4 * w);\n            int x = leftPoint.x - 0.25*w;\n            int y = leftPoint.y - 0.5*h;\n\n            // Extract region of interest (ROI) covering both the eyes\n            frameROI = frame(Rect(x,y,w,h));\n\n            // Resize the sunglasses image based on the dimensions of the above ROI\n            resize(eyeMask, eyeMaskSmall, Size(w,h));\n```", "```py\n            // Convert the above image to grayscale\n            cvtColor(eyeMaskSmall, grayMaskSmall, CV_BGR2GRAY);\n\n            // Threshold the above image to isolate the foreground object\n            threshold(grayMaskSmall, grayMaskSmallThresh, 245, 255, CV_THRESH_BINARY_INV);\n\n            // Create mask by inverting the above image (because we don't want the background to affect the overlay)\n            bitwise_not(grayMaskSmallThresh, grayMaskSmallThreshInv);\n\n            // Use bitwise \"AND\" operator to extract precise boundary of sunglasses\n            bitwise_and(eyeMaskSmall, eyeMaskSmall, maskedEye, grayMaskSmallThresh);\n\n            // Use bitwise \"AND\" operator to overlay sunglasses\n            bitwise_and(frameROI, frameROI, maskedFrame, grayMaskSmallThreshInv);\n\n            // Add the above masked images and place it in the original frame ROI to create the final image\n            add(maskedEye, maskedFrame, frame(Rect(x,y,w,h)));\n        }\n\n        // code for memory release and GUI\n\n    return 1;\n}\n```"]