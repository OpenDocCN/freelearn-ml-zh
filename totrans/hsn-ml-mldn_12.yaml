- en: Using ML.NET with ASP.NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中使用 ML.NET
- en: Now that we have an idea of how to create a production-grade .NET Core console
    application, in this chapter, we will deep dive into creating a fully functional
    ASP.NET Core Blazor web application. This application will utilize an ML.NET binary
    classification model to make file classifications on Windows executables (**Portable
    Executable** (**PE**) files), in order to determine whether the files themselves are
    either clean or malicious. Furthermore, we will explore breaking our application code
    into a component-based architecture using a .NET Core library to share between
    our web application and the console application that will train our model. By
    the end of the chapter, you should have a firm grasp of designing and coding a
    production-grade ASP.NET Core Blazor web application with ML.NET.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建一个生产级别的 .NET Core 控制台应用程序，在本章中，我们将深入探讨创建一个功能齐全的 ASP.NET Core Blazor
    网络应用程序。这个应用程序将利用 ML.NET 二元分类模型对 Windows 可执行文件（**可移植可执行文件**（**PE**）文件）进行文件分类，以确定文件本身是干净的还是恶意的。此外，我们将探索将我们的应用程序代码分解为基于组件的架构，使用
    .NET Core 库在 web 应用程序和将训练我们的模型的控制台应用程序之间共享。到本章结束时，你应该能够熟练地设计和编码带有 ML.NET 的生产级别
    ASP.NET Core Blazor 网络应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Breaking down ASP.NET Core
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆解 ASP.NET Core
- en: Creating the file classification web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件分类网络应用程序
- en: Exploring additional production-application enhancements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索额外的生产应用增强功能
- en: Breaking down ASP.NET Core
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆解 ASP.NET Core
- en: Building on the same .NET Core technology discussed in [Chapter 8](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml),
    *Using ML.NET with .NET Core and Forecasting*, ASP.NET Core adds a powerful web
    framework. This web framework includes a powerful rendering engine, Razor, in
    addition to supporting scalable **representational state transfer** (**REST**)
    services. The example in this chapter will use this technology to create our file
    classification frontend. In the next two sections, we will dive into the ASP.NET
    Core architecture and discuss Blazor, the new web framework from Microsoft.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基于[第 8 章](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml)中讨论的相同 .NET Core 技术，*在
    .NET Core 和预测中使用 ML.NET*，ASP.NET Core 添加了一个强大的网络框架。这个网络框架包括一个强大的渲染引擎 Razor，以及支持可扩展的
    **表示状态转移**（**REST**）服务。本章的示例将使用这项技术来创建我们的文件分类前端。在接下来的两个部分中，我们将深入研究 ASP.NET Core
    架构并讨论微软的新网络框架 Blazor。
- en: Understanding the ASP.NET Core architecture
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core 架构
- en: At a high level, ASP.NET Core builds on top of .NET Core, providing a fully-featured
    web framework. As with .NET Core, ASP.NET Core runs on Windows, Linux, and macOS,
    in addition to allowing deployments to x86, x64, and **Advanced RISC Machine**
    (**ARM**) CPU architectures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，ASP.NET Core 建立在 .NET Core 之上，提供了一个功能齐全的网络框架。与 .NET Core 一样，ASP.NET Core
    在 Windows、Linux 和 macOS 上运行，同时还允许部署到 x86、x64 和 **高级精简指令集机器**（**ARM**）CPU 架构。
- en: 'A typical ASP.NET Core application includes the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 ASP.NET Core 应用程序包括以下内容：
- en: Models
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: Views
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Controllers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: These components form a common web architecture principle of **Model-View-Controller**,
    otherwise known as **MVC**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件构成了一个常见的网络架构原则 **模型-视图-控制器**（**MVC**）。
- en: Controllers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers provide the server-side code for handling business logic for both
    web applications and REST services. Controllers can include both web and REST
    calls in the same controller, although I would recommend keeping them separate
    to ensure your code is organized cleanly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器为处理网络应用程序和 REST 服务的业务逻辑提供服务器端代码。控制器可以在同一个控制器中包含 web 和 REST 调用，尽管我建议将它们分开，以确保代码组织得干净整洁。
- en: Models
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: Models provide the container of data from the Controller to the View, and vice
    versa. For example, take a listing page pulling data from a database. The controller
    would return a model populated with that data, and if that same data was then
    used for filtering, it would also be serialized into **JavaScript Object Notation**
    (**JSON**) and sent back to the Controller.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模型为从控制器到视图以及相反方向提供数据容器。例如，考虑一个从数据库中获取数据的列表页面。控制器将返回一个包含该数据的模型，如果相同的数据被用于过滤，它也将序列化为
    **JavaScript 对象表示法**（**JSON**）并发送回控制器。
- en: Views
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Views provide the templates for the frontend view with support for model binding.
    Model binding allows properties bound to various **Domain Object Model** (**DOM**)
    objects—such as textboxes, checkboxes, and dropdowns—to be cleanly mapped to and
    from. This approach of model binding has the added benefit of supporting strongly
    typed references, which comes in extremely handy when you have a complex View
    with dozens of properties bound to a Model.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 视图提供了前端视图的模板，并支持模型绑定。模型绑定允许将绑定到各种**领域对象模型**（**DOM**）对象的属性（如文本框、复选框和下拉列表）干净地映射到和从。这种模型绑定的方法具有支持强类型引用的附加好处，这对于你有一个具有数十个绑定到模型的属性的复杂视图来说非常有用。
- en: Form handling with the model binding provides a similar model to the **Model-View
    ViewModel** (**MVVM**) approach we are going to dive into in [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*, with a **Universal Windows Platform** (**UWP**) application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模型绑定处理表单提供了与我们在[第10章](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml)“使用ML.NET与UWP”中将要深入探讨的**模型-视图-视图模型**（**MVVM**）方法类似的模型，这是一个**通用Windows平台**（**UWP**）应用程序。
- en: If you want to deep dive further into ASP.NET, Channel 9 from Microsoft has
    a series called ASP.NET Core 101 that covers all of the main aspects of ASP.NET,
    at [https://channel9.msdn.com/Series/ASPNET-Core-101](https://channel9.msdn.com/Series/ASPNET-Core-101).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步深入了解ASP.NET，微软的Channel 9有一个名为ASP.NET Core 101的系列，涵盖了ASP.NET的所有主要方面，请访问[https://channel9.msdn.com/Series/ASPNET-Core-101](https://channel9.msdn.com/Series/ASPNET-Core-101)。
- en: Blazor
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor
- en: Building on the ASP.NET Core infrastructure, Blazor focuses on removing one
    of the biggest hurdles with complex web applications—**JavaScript**. Blazor allows
    you to write C# code instead of JavaScript code to handle client-side tasks such
    as form handling, HTTP calls, and asynchronously loading data. Under the hood,
    Blazor uses **WebAssembly** (**Wasm**), a popular high-performant JavaScript framework
    supported by all current browsers (Edge, Safari, Chrome, and Firefox).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在ASP.NET Core基础设施之上，Blazor专注于消除复杂Web应用程序中最大的障碍之一——**JavaScript**。Blazor允许你编写C#代码而不是JavaScript代码来处理客户端任务，如表单处理、HTTP调用和异步加载数据。在底层，Blazor使用**WebAssembly**（**Wasm**），这是一个由所有当前浏览器（Edge、Safari、Chrome和Firefox）支持的高性能JavaScript框架。
- en: Similar to other frameworks, Blazor also supports and recommends the use of
    modular components to promote reuse. These are called **Blazor** **components**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他框架类似，Blazor也支持并推荐使用模块化组件来促进重用。这些被称为**Blazor组件**。
- en: 'In addition, there are three project types when creating a Blazor application:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在创建Blazor应用程序时，有三种项目类型：
- en: The Blazor-only client side is used, which is ideal for more static pages.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用Blazor客户端，这对于更多静态页面来说非常理想。
- en: A Blazor (ASP.NET Core-hosted) client-side application that is hosted inside
    ASP.NET Core (this is the project type we are going to review in the next section).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Blazor（ASP.NET Core托管）客户端应用程序，它托管在ASP.NET Core内部（这是我们将在下一节中要审查的项目类型）。
- en: A Blazor server-side application that updates the DOM. This is ideal for use
    with SignalR, Microsoft's real-time web framework supporting chats, real-time
    tickers, and maps, to name but a few.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Blazor服务器端应用程序，用于更新DOM。这对于与SignalR（微软的实时Web框架，支持聊天、实时股票行情和地图等）一起使用非常理想。
- en: If you want to deep dive further into Blazor, Microsoft has written an abundant
    amount of documentation on **Microsoft Developer Network** (**MSDN**) at: [https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1](https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步深入了解Blazor，微软已经在**微软开发者网络**（**MSDN**）上编写了大量关于Blazor的文档，请访问：[https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1](https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1)。
- en: Creating the file classification web application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件分类网络应用程序
- en: As mentioned earlier, the application we will be creating is a file classification
    web application. Using the knowledge garnered in the *Creating a binary classification
    application* section in [Chapter 4](da0d1d99-ad37-498b-8670-f8cee6ad49bc.xhtml),
    *Classification Model*, we will be taking it a step further and looking at adding
    more attributes to a file prior to making a classification. In addition, we will
    be integrating machine learning with ML.NET into the web application, where an
    end user can upload files for classification, returning either clean or malicious
    files, along with a confidence of that prediction.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将创建的应用程序是一个文件分类网络应用程序。使用 [第 4 章](da0d1d99-ad37-498b-8670-f8cee6ad49bc.xhtml)
    中“创建二进制分类应用程序”部分的知识，即 *分类模型*，我们将更进一步，查看在分类之前向文件添加更多属性。此外，我们还将机器学习与 ML.NET 集成到网络应用程序中，用户可以上传文件进行分类，返回清洁或恶意文件，以及预测的置信度。
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded at: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter09](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter09).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的章节一样，完整的项目代码、样本数据集和项目文件可以在以下位置下载：[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter09](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter09)。
- en: Exploring the project architecture
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目架构
- en: Given the previous applications have all been command-line applications, the
    project architecture for this example is quite different.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前的应用都是命令行应用，因此本例的项目架构相当不同。
- en: As with some of the previous chapters, an additional ML.NET NuGet package—`Microsoft.ML.FastTree`—is
    required in order to utilize the `FastTree` algorithm in ML.NET. Version 1.3.1
    is used in both the included example on GitHub and throughout this chapter's deep
    dive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些前面的章节一样，为了在 ML.NET 中使用 `FastTree` 算法，需要额外的 ML.NET NuGet 包——`Microsoft.ML.FastTree`。GitHub
    中的示例和本章的深入探讨中都使用了 1.3.1 版本。
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the example''s solution. Given that this example comprises three separate
    projects (more akin to a production scenario), the amount of both new and significantly
    modified files is quite large. We will review each of the new files shown in the
    following solution screenshot in detail in further sections:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您将找到示例解决方案的 Visual Studio 解决方案资源管理器视图。鉴于本例包含三个独立的项目（更类似于生产场景），新文件和显著修改的文件数量相当大。我们将在本节末尾运行应用程序之前，在以下部分详细审查以下解决方案屏幕截图中的每个新文件：
- en: '![](img/75e605e4-a04e-4723-8895-f9c81ffad49a.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75e605e4-a04e-4723-8895-f9c81ffad49a.png)'
- en: 'The `sampledata.csv` file contains 14 rows of extracted features from Windows
    Executables (we will go into these features in more detail in the next section).
    Feel free to adjust the data to fit your own observations or to adjust the trained
    model with different sample files. The following snippet is one of the rows found
    in the `sampledata.data` file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledata.csv` 文件包含从 Windows 可执行文件中提取的 14 行特征（我们将在下一节中详细介绍这些特征）。请随意调整数据以适应您的观察或使用不同的样本文件调整训练模型。以下是从
    `sampledata.data` 文件中找到的一行示例：'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition to this, we added the `testdata.data` file that contains additional
    data points to test the newly trained model against and evaluate it. Here is a
    sample row of the data inside of `testdata.data`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了 `testdata.data` 文件，其中包含额外的数据点，用于测试新训练的模型并对其进行评估。以下是 `testdata.data`
    文件中的数据样本行：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Due to the size of the example project, we will be diving into the code for
    each of the different components before running the applications at the end of
    this section, in the following order:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于示例项目的规模，我们将在本节末尾运行应用程序之前，按照以下顺序深入了解每个不同组件的代码：
- en: The .NET Core library for common code between the two applications
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个应用程序之间的常见代码的 .NET Core 库
- en: The ASP.NET Blazor web application for running the prediction
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行预测的 ASP.NET Blazor 网络应用程序
- en: The .NET Core console application for feature extraction and training
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于特征提取和训练的 .NET Core 控制台应用程序
- en: Diving into the library
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解库
- en: 'The classes and enumerations that were changed or added are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是被更改或添加的类和枚举：
- en: '`FileClassificationResponseItem`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文件分类响应项`'
- en: '`Converters`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`转换器`'
- en: '`ExtensionMethods`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`扩展方法`'
- en: '`HashingExtension`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`哈希扩展`'
- en: '`FileData`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文件数据`'
- en: '`FileDataPrediction`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文件数据预测`'
- en: '`FileClassificationFeatureExtractor`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileClassificationFeatureExtractor`'
- en: '`FileClassificationPredictor`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileClassificationPredictor`'
- en: '`FileClassificationTrainer`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileClassificationTrainer`'
- en: The `Constants` and `BaseML` classes remain unmodified from [Chapter 8](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml),
    *Using ML.NET with .NET Core and Forecasting*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Constants` 和 `BaseML` 类与第8章 [第8章](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml)，*使用ML.NET与.NET
    Core和预测* 中保持未修改。'
- en: Due to the nature of this application and that of production applications, where
    there are multiple platforms and/or ways to execute shared code, a library is
    used in this chapter's example application. The benefit of using a library is
    that all common code can reside in a portable and dependency-free manner. Expanding the
    functionality in this sample application to include desktop or mobile applications
    would be a much easier lift than having the code either duplicated or kept in
    the actual applications.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本应用程序和生产应用程序的性质，其中存在多个平台和/或执行共享代码的方式，本章示例应用程序中使用了库。使用库的好处是所有常用代码都可以以便携和无需依赖的方式存在。将此示例应用程序的功能扩展到包括桌面或移动应用程序，将比复制代码或保留在实际应用程序中要容易得多。
- en: The FileClassificationResponseItem class
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FileClassificationResponseItem` 类'
- en: The `FileClassificationResponseItem` class is the common class that contains
    the properties that are used to feed our model, and is also used to return back
    to the end user in the web application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileClassificationResponseItem` 类是包含用于向我们的模型提供属性的共同类，同时也用于在Web应用程序中返回给最终用户。'
- en: 'First, we define the `TRUE` and `FALSE` mapping to `1.0f` and `0.0f` respectively,
    like this:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义 `TRUE` 和 `FALSE` 映射到 `1.0f` 和 `0.0f`，如下所示：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we add all of the properties to be used to feed our model and display
    it back to the end user in the web application. The `FileSize`, `Is64Bit`, `NumImports`,  `NumImportFunctions`,
    `NumExportFunctions`, `IsSigned`, and `Strings` properties are used specifically
    as features in our model. The `SHA1Sum`, `Confidence`, `IsMalicious`, and `ErrorMessage` properties
    are used to return our classification back to the end user, as illustrated in
    the following code block:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加所有要用于向我们的模型提供并显示给Web应用程序的最终用户的属性。`FileSize`、`Is64Bit`、`NumImports`、`NumImportFunctions`、`NumExportFunctions`、`IsSigned`
    和 `Strings` 属性被专门用作模型中的特征。`SHA1Sum`、`Confidence`、`IsMalicious` 和 `ErrorMessage`
    属性用于将我们的分类返回给最终用户，如下面的代码块所示：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we have the constructor method.  The constructor, as you can see, has
    a byte array as a parameter. This was done to facilitate both the training and
    prediction paths in both of the applications, the idea being that the raw file
    bytes will come into the constructor from a `File.ReadAllBytes` call or other
    mechanisms, to provide flexibility. From there, we use the `PeNet` NuGet package.
    This package provides an easy-to-use interface for extracting features from a
    Windows Executable (also known as a PE file). For the scope of this application,
    a couple of features were chosen to be extracted and stored into the respective
    properties, as shown in the following code block:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有构造函数方法。如您所见，构造函数有一个字节数组作为参数。这样做是为了方便两个应用程序中的训练和预测路径，想法是原始文件字节将从 `File.ReadAllBytes`
    调用或其他机制进入构造函数，以提供灵活性。从那里，我们使用 `PeNet` NuGet 包。此包提供了一个易于使用的接口，用于从Windows可执行文件（也称为PE文件）中提取特征。对于本应用程序的范围，选择了一些特征进行提取并存储到相应的属性中，如下面的代码块所示：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The FileData class
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FileData` 类'
- en: 'The `FileData` class, as with previous containers of prediction data, provides
    our model with the fields necessary to provide a file classification. In addition,
    we overrode the `ToString` method to ease the exporting of this data to a **comma-separated
    values** (**CSV**) file during our feature extraction step, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的预测数据容器一样，`FileData` 类为我们提供必要的字段，以提供文件分类。此外，我们重写了 `ToString` 方法，以便在特征提取步骤中将此数据轻松导出到
    **逗号分隔值** (**CSV**) 文件，如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The FileDataPrediction class
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FileDataPrediction` 类'
- en: 'The `FileDataPrediction` class contains the prediction''s classification and
    probability properties to return to the end user in our web application, as shown
    in the following code block:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileDataPrediction` 类包含预测的分类和概率属性，以便在我们的Web应用程序中返回给最终用户，如下面的代码块所示：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Converters class
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Converters` 类'
- en: 'The `Converters` class provides an extension method to convert the `FileClassificationResponseItem`
    class—reviewed earlier in this section—to the `FileData` class. By making an extension
    method, as shown in the following code block, we can quickly and cleanly convert
    between the application container and our model-only container:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Converters` 类提供了一个扩展方法，用于将前面在本节中审查过的 `FileClassificationResponseItem` 类转换为
    `FileData` 类。通过创建扩展方法，如以下代码块所示，我们可以快速且干净地在应用程序容器和我们的仅模型容器之间进行转换：'
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The ExtensionMethods class
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ExtensionMethods` 类'
- en: 'The `ExtensionMethods` class, as shown in previous chapters, contains helper
    extension methods. In this example, we will be adding in the `ToStrings` extension
    method. Strings are a highly popular first pass and an easy-to-capture feature
    when making a classification of a file. Let''s dive into the method, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所示，`ExtensionMethods` 类包含辅助扩展方法。在本例中，我们将添加 `ToStrings` 扩展方法。字符串是在对文件进行分类时非常受欢迎的第一遍扫描，并且易于捕获的特征。让我们深入了解该方法，如下所示：
- en: 'First, we define two new constants for handling the buffer size and the encoding.
    As mentioned earlier, `1252` is the encoding in which Windows Executables are
    encoded, as shown in the following code block:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了两个新的常量来处理缓冲区大小和编码。如前所述，`1252` 是 Windows 可执行文件所使用的编码，如下面的代码块所示：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next change is the addition of the `ToStringsExtraction` method itself
    and defining our regular expression, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个更改是添加了 `ToStringsExtraction` 方法本身以及定义我们的正则表达式，如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This regular expression is what we will use to traverse the file's bytes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式是我们将用来遍历文件字节的。
- en: 'Next, we initialize the `StringBuilder` class and check if the passed-in byte
    array is null or empty (if it is, we can''t process it), like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们初始化 `StringBuilder` 类并检查传入的字节数组是否为空或为空（如果是，我们无法处理它），如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have confirmed there are bytes in the passed-in array, we only
    want to take up to `65536` bytes. The reason for this is that if the file is 100
    MB, this operation could take significant time to perform. Feel free to adjust
    this number and see the efficacy results. The code is shown here:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经确认传入的数组中有字节，我们只想取最多 `65536` 字节。这样做的原因是，如果文件是 100 MB，这个操作可能需要很长时间。您可以随意调整这个数字并查看效果。代码如下所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have the bytes we are going to analyze, we will loop through and
    extract lines of text found in the bytes, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了将要分析的字节，我们将遍历并提取字节中找到的文本行，如下所示：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we simply return the lines joined into a single string, like this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需将行连接成一个单独的字符串，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The HashingExtensions class
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`HashingExtensions` 类'
- en: The new `HashingExtensions` class converts our byte array to a SHA1 string.
    The reason for not putting this with our other extension methods is to provide
    a common class to potentially hold SHA256, ssdeep, or other hashes (especially
    given the recent SHA1 collisions, proving SHA1 to be insecure).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `HashingExtensions` 类将我们的字节数组转换为 SHA1 字符串。之所以没有将其放在我们的其他扩展方法中，是为了提供一个通用的类，可能包含
    SHA256、ssdeep 或其他哈希（特别是鉴于最近的 SHA1 冲突，证明了 SHA1 的不安全性）。
- en: 'For this method, we''re using the built-in .NET Core `SHA1` class, and then
    converting it to a Base64 string with a call to `ToBase64String`, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个方法，我们使用内置的 .NET Core `SHA1` 类，然后通过调用 `ToBase64String` 方法将其转换为 Base64 字符串，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The FileClassificationFeatureExtractor class
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FileClassificationFeatureExtractor` 类'
- en: 'The `FileClassificationFeatureExtractor` class contains our `Extract` and `ExtractFolder`
    methods:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileClassificationFeatureExtractor` 类包含我们的 `Extract` 和 `ExtractFolder` 方法：'
- en: 'First, our `ExtractFolder` method takes in the folder path and the output file
    that will contain our feature extraction, as shown in the following code block:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们的 `ExtractFolder` 方法接收文件夹路径和将包含我们的特征提取的输出文件，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we use the `Extract` method to call both the training and test extraction,
    as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `Extract` 方法调用训练和测试提取，如下所示：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The FileClassificationPredictor class
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FileClassificationPredictor` 类'
- en: 'The `FileClassificationPredictor` class provides the interface for both our
    command-line and web applications, using an overloaded `Predict` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileClassificationPredictor` 类为我们的命令行和 Web 应用程序提供接口，使用重载的 `Predict` 方法：'
- en: 'The first `Predict` method is for our command-line application that simply
    takes in the filename and is called into the overload in *Step 2* after loading
    in the bytes, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个 `Predict` 方法是为我们的命令行应用程序准备的，它简单地接收文件名，并在加载字节后调用 *步骤 2* 中的重载，如下所示：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second implementation is for our web application that takes the `FileClassificationResponseItem`
    object, creates our prediction engine, and returns the prediction data, as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种实现是为我们的Web应用程序，它接收`FileClassificationResponseItem`对象，创建我们的预测引擎，并返回预测数据，如下所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The FileClassificationTrainer class
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FileClassificationTrainer类
- en: 'The last class added in the library is the `FileClassificationTrainer` class.
    This class supports the use of the `FastTree` ML.NET trainer, as well as utilizing
    our features we have extracted from the files:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在库中最后添加的类是`FileClassificationTrainer`类。此类支持使用`FastTree` ML.NET训练器，以及利用我们从文件中提取的特征：
- en: 'The first change is the use of the `FileData` class to read the CSV file into
    the `dataView` property, as shown in the following code block:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一项更改是使用`FileData`类将CSV文件读取到`dataView`属性中，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '2\. Next, we map our `FileData` features to create our pipeline, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 接下来，我们将我们的`FileData`特征映射以创建我们的流水线，如下所示：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '3\. Lastly, we initialize our `FastTree` algorithm, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 最后，我们初始化我们的`FastTree`算法，如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The rest of the method is similar to our previous binary classification `Train`
    method in [Chapter 5](4c32e261-cec6-4113-9734-1e29c7c18f9a.xhtml), *Clustering
    Models*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的其他部分与我们在第5章中讨论的二元分类`Train`方法类似，*聚类模型*。
- en: Diving into the web application
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入Web应用程序
- en: With the library code having been reviewed, the next component is the web application.
    As discussed in the opening section, our web application is an ASP.NET Core Blazor
    application. For the scope of this example, we are using standard approaches for
    handling the backend and frontend. The architecture of this app combines both
    Blazor and ASP.NET Core—specifically, using ASP.NET Core to handle the REST service
    component of the app.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了库代码之后，下一个组件是Web应用程序。如开篇部分所述，我们的Web应用程序是一个ASP.NET Core Blazor应用程序。在本例的范围内，我们使用标准方法来处理后端和前端。该应用程序的架构结合了Blazor和ASP.NET
    Core——具体来说，使用ASP.NET Core来处理应用程序的REST服务组件。
- en: 'The files we will be diving into in this section are the following ones:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中深入研究的文件如下：
- en: '`UploadController`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UploadController`'
- en: '`Startup`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Startup`'
- en: '`Index.razor`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Index.razor`'
- en: The UploadController class
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UploadController类
- en: 'The purpose of the `UploadController` class is to handle the server-side processing
    of the file once submitted. For those having used ASP.NET MVC or Web API in the
    past, this controller should look very familiar:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`UploadController`类的目的是处理文件提交后的服务器端处理。对于那些以前使用过ASP.NET MVC或Web API的人来说，这个控制器看起来应该非常熟悉：'
- en: 'The first thing to note is the attribute tags decorating the class. The `ApiController`
    attribute configures the controller to handle HTTP APIs, while the `Route` tag
    indicates the controller will be listening on the `/Upload` path, as shown in
    the following code block:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要注意的第一件事是装饰类的属性标记。`ApiController`属性配置控制器以处理HTTP API，而`Route`标记表示控制器将监听`/Upload`路径，如下面的代码块所示：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next thing to note is the use of **Dependency Injection** (**DI**) in the
    constructor of `UploadController` passing in the predictor object. DI is a powerful
    approach to providing access to singleton objects such as `FileClassificationPredictor`
    or databases, and is illustrated in the following code block:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要注意的下一件事是在`UploadController`构造函数中使用**依赖注入**（**DI**）传递预测对象。DI是一种强大的方法，用于提供对单例对象（如`FileClassificationPredictor`或数据库）的访问，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we create a helper method to handle taking the `IFormFile` from the HTTP
    post and returning all of the bytes, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个辅助方法来处理从HTTP POST中获取`IFormFile`并返回所有字节，如下所示：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, we create the `Post` method. The `HttpPost` attribute tells the routing
    engine to listen for only a `HttpPost` call. The method handles taking the output
    of the `GetBytesFromPost` method call, creates the `FileClassificationResponseItem`
    object, and then returns the prediction, as shown in the following code block:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建`Post`方法。`HttpPost`属性告诉路由引擎仅监听`HttpPost`调用。该方法处理`GetBytesFromPost`方法调用的输出，创建`FileClassificationResponseItem`对象，然后返回预测，如下面的代码块所示：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Startup class
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Startup类
- en: 'The `Startup` class in both an ASP.NET Core and Blazor app controls the initialization
    of the various services used in the web application. Two major changes have been
    made to the `Startup` template that comes with Visual Studio, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core和Blazor应用程序中，`Startup`类控制Web应用程序中使用的各种服务的初始化。对Visual Studio附带的`Startup`模板进行了两项主要更改，如下所示：
- en: 'The first change is in the `ConfigureServices` method. Because this was a combined
    application of both ASP.NET Core and Blazor, we need to call the `AddControllers`
    method. In addition, we are going to utilize DI and initialize the predictor object
    once, prior to adding it as a singleton, as shown in the following code block:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首个改动发生在 `ConfigureServices` 方法中。因为这是一个同时应用了 ASP.NET Core 和 Blazor 的组合应用程序，我们需要调用
    `AddControllers` 方法。此外，我们打算利用依赖注入（DI）并一次性初始化预测器对象，然后再将其作为单例添加，如下面的代码块所示：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The second change comes in the `Configure` method. The first thing is to register
    the `CodePages` instance. Without this call, the feature extraction call to reference
    the Windows-1252 encoding will cause an exception (we will add this call to the
    trainer application as well, in the next section). The second thing is to configure
    the use of `MapControllerRoute`, as illustrated in the following code block:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个改动发生在 `Configure` 方法中。首先，我们需要注册 `CodePages` 实例。如果没有这个调用，对 Windows-1252 编码的引用将导致异常（我们将在下一节中将此调用添加到训练应用程序中）。其次，是配置
    `MapControllerRoute` 的使用，如下面的代码块所示：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Index.razor file
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Index.razor` 文件'
- en: 'The `Index.razor` file contains the frontend to our file classification web
    application. In addition, it contains the REST call to our `UploadController`
    class described earlier in this section. For this deep dive, we will specifically
    look at the Blazor code block, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index.razor` 文件包含我们文件分类 Web 应用程序的前端。此外，它还包含对之前在本节中描述的 `UploadController` 类的
    REST 调用。对于这次深入分析，我们将特别查看以下 Blazor 代码块：'
- en: 'The first thing to note is the declaration of our `FileClassificationResponseItem`
    class. We define the variable in this block, as it will allow access throughout
    the page. The second element is the declaration of our `HandleSelection` method,
    as illustrated in the following code block:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要注意的是我们 `FileClassificationResponseItem` 类的声明。我们在这个块中定义变量，因为它将允许在整个页面中访问。第二个元素是
    `HandleSelection` 方法的声明，如下面的代码块所示：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we take the first file, convert it to an array of bytes, and create the
    `MultipartFormdataContent` object to POST to the previously described `Post` method,
    as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将第一个文件转换为字节数组，并创建 `MultipartFormdataContent` 对象，以便将其 POST 到之前描述的 `Post`
    方法，如下所示：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, we POST the file to our `UploadController` endpoint and asynchronously
    await the response from our ML.NET prediction, before assigning the response to
    our response variable, `_classificationResponseItem`, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将文件 POST 到我们的 `UploadController` 端点，并异步等待来自 ML.NET 预测的响应，然后将响应分配给我们的响应变量
    `_classificationResponseItem`，如下所示：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Diving into the trainer application
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解训练应用程序
- en: Now that we have reviewed the shared library and the web application,  let's
    dive into the trainer application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了共享库和 Web 应用程序，让我们深入到训练应用程序中。
- en: 'We will review the following files:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾以下文件：
- en: '`ProgramArguments`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgramArguments`'
- en: '`ProgramActions`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgramActions`'
- en: '`Program`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program`'
- en: The ProgramArguments class
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ProgramArguments` 类'
- en: 'Building off the work in the `ProgramArguments` class detailed in [Chapter
    8](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml), *Using ML.NET with .NET Core and
    Forecasting*, we are only making one addition to the class. This change adds properties
    to store the `Testing` and `Training` folder paths, and is illustrated in the
    following code block:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 [第 8 章](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml) 中 `ProgramArguments`
    类的详细工作，*使用 ML.NET 与 .NET Core 和预测*，我们只对该类进行了一项添加。这次改动为类添加了存储 `Testing` 和 `Training`
    文件夹路径的属性，如下面的代码块所示：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unlike the previous chapter, feature extraction is based on a number of Windows
    executable files, as opposed to just an included CSV file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章不同，特征提取基于多个 Windows 可执行文件，而不是仅仅包含一个 CSV 文件。
- en: The ProgramActions enumeration
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ProgramActions` 枚举'
- en: 'The first change is in the `ProgramActions` enumeration. In [Chapter 8](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml), *Using
    ML.NET with .NET Core and Forecasting*, we had only training and prediction. However,
    as mentioned earlier in this chapter, we now also have `FeatureExtraction` to
    perform. To add support, we simply add `FEATURE_EXTRACTOR` to the enumeration,
    like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首个改动发生在 `ProgramActions` 枚举中。在 [第 8 章](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml)
    的 *使用 ML.NET 与 .NET Core 和预测* 中，我们只有训练和预测。然而，正如本章前面提到的，我们现在还有 `FeatureExtraction`
    需要执行。为了添加支持，我们只需将 `FEATURE_EXTRACTOR` 添加到枚举中，如下所示：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The Program class
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Program` 类'
- en: 'Inside the `Program` class, there are only two changes from the previous chapter''s
    overhaul of the command-line argument parsing, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program`类中，与上一章对命令行参数解析的重构相比，只有两个更改，如下所示：
- en: 'First, we need to register the `CodePages` encoder instance to properly read
    the Windows-1252 encoding from the files as we did in the web application, as
    follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要注册`CodePages`编码器实例，以便正确读取文件中的Windows-1252编码，就像我们在Web应用程序中所做的那样，如下所示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then can use a simplified and strongly typed switch case to handle our three
    actions, as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用一个简化和强类型化的switch case来处理我们的三个动作，如下所示：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Running the trainer application
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行训练应用程序
- en: 'To begin, we will need to first run the `chapter09.trainer` application to
    perform feature extraction and training of our model. To run the trainer application,
    the process is nearly identical to the sample application shown in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml),
    *Regression Model*, with the addition of passing in the test dataset folder path
    when training, and we will follow these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要先运行`chapter09.trainer`应用程序以执行模型的特征提取和训练。要运行训练应用程序，过程几乎与[第3章](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml)中展示的示例应用程序相同，即*回归模型*，但需要添加在训练时传递测试数据集文件夹路径，我们将遵循以下步骤：
- en: 'We will run the trainer application, passing in the paths to the training and
    test folders to perform feature extraction, as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将运行训练应用程序，传递训练和测试文件夹的路径以执行特征提取，如下所示：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Included in the code repository are two pre-feature extracted files (`sampledata.csv` and
    t`estdata.csv`) to allow you to train a model without performing your own feature
    extraction.  If you would like to perform your own feature extraction, create
    a `TestData` and `TrainingData` folder.  Populate these folders with a sampling
    of **PowerShell **(**PS1**), **Windows Executables** (**EXE **) and **Microsoft
    Word documents** (**DOCX**).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仓库中包含两个预特征提取的文件（`sampledata.csv`和`t`estdata.csv），以便您可以在不执行自己的特征提取的情况下训练模型。如果您想执行自己的特征提取，创建一个`TestData`和`TrainingData`文件夹。将这些文件夹填充为**PowerShell**（**PS1**）、**Windows可执行文件**（**EXE**）和**Microsoft
    Word文档**（**DOCX**）的样本。
- en: 'Now, we will again run the application to train the model based on *Step 1* sample
    and test data exports. The resulting model (`fileclassification.mdl`) will be
    in the same folder as the executable, as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将再次运行应用程序，根据*步骤1*样本和测试数据导出训练模型。生成的模型（`fileclassification.mdl`）将与可执行文件在同一文件夹中，如下所示：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Feel free to modify the values and see how the prediction changes based on
    the dataset on which the model was trained. A few areas of experimentation from
    this point might be to do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随意修改值，看看基于模型训练数据集的预测如何变化。从这个点开始，一些实验性的区域可能包括以下内容：
- en: Tweak the hyperparameters reviewed in the `Trainer` class—such as the `numberOfLeaves`,
    `numberOfTrees`, and `learningRate`—to see how accuracy is affected.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整`Trainer`类中审查的超参数——如`numberOfLeaves`、`numberOfTrees`和`learningRate`——以查看精度如何受到影响。
- en: Add new features to the `FileData` class, such as specific imports, instead
    of using just the count.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`FileData`类添加新功能，例如特定的导入，而不仅仅是使用计数。
- en: Add more variation to the training and sample set to get a better sampling of
    data.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向训练和样本集添加更多变化，以获得更好的数据采样。
- en: For convenience, the GitHub repository includes both the `testdata.csv` and
    `sampledata.csv` files.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，GitHub仓库包含了`testdata.csv`和`sampledata.csv`两个文件。
- en: Running the web application
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Web应用程序
- en: 'Now that our model has been trained, we can run our web application and test
    the submission of a file. You must first build the web application if you haven''t
    already. This will create the `bin\debug\netcoreapp3.1` folder. After building
    the web application, copy the model we trained in the previous section. At this
    point, start the web application. Upon starting, you should see the following
    in your default browser:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经训练了模型，我们可以运行我们的Web应用程序并测试文件提交。如果您还没有构建Web应用程序，您必须首先构建它。这将创建`bin\debug\netcoreapp3.1`文件夹。构建Web应用程序后，复制上一节中训练的模型。此时，启动Web应用程序。启动后，您应该在默认浏览器中看到以下内容：
- en: '![](img/853d9d5f-3a41-4867-aeec-bc598f0bebea.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/853d9d5f-3a41-4867-aeec-bc598f0bebea.png)'
- en: 'Proceed to click on the Choose File button, select an `.exe` or `.dll` file,
    and you should see the following results from our model:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 继续点击选择文件按钮，选择一个`.exe`或`.dll`文件，您应该看到我们的模型以下列结果：
- en: '![](img/097bd073-ce7c-4952-a75d-855b741af60b.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/097bd073-ce7c-4952-a75d-855b741af60b.png)'
- en: Feel free to try various files on your machine to see the confidence score,
    and if you receive a false positive, perhaps add additional features to the model
    to correct the classification.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试在您的机器上使用各种文件来查看置信度分数，如果您收到错误阳性结果，可能需要向模型添加更多功能以纠正分类。
- en: Exploring additional ideas for improvements
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索改进的额外想法
- en: Now that we have completed our deep dive, there are a couple of additional elements
    to possibly further enhance the application. A few ideas are discussed next.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了深入探讨，还有一些额外的元素可能有助于进一步增强应用程序。下面将讨论一些想法。
- en: Logging
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录日志
- en: As with our previous chapter's deep dive into logging, adding logging could
    be crucial to remotely understand when an error occurs on a web application. Logging
    utilizing NLog ([https://nlog-project.org/](https://nlog-project.org/)) or a similar
    open source project is highly recommended as your application complexity increases.
    This will allow you to log to a file, console, or third-party logging solution—such
    as Loggly—at varying levels.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章深入探讨日志记录时一样，添加日志记录对于远程了解 Web 应用程序上何时发生错误可能是至关重要的。随着应用程序复杂性的增加，强烈建议使用
    NLog ([https://nlog-project.org/](https://nlog-project.org/)) 或类似的开源项目进行日志记录。这将允许您以不同的级别将日志记录到文件、控制台或第三方日志解决方案——如
    Loggly。
- en: Utilizing a caching layer
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用缓存层
- en: Imagine deploying this application on a public-facing web server and having
    hundreds of concurrent users. Chances are that users might upload the same file—caching
    the results in memory would avoid unnecessary CPU processing to run the prediction
    every time. Some caching options include utilizing the ASP.NET in-memory caching,
    or external caching databases such as Redis. These are both available via NuGet
    packages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下将此应用程序部署到面向公众的 Web 服务器上，并拥有数百个并发用户。很可能会发生用户上传相同的文件——在内存中缓存结果可以避免每次预测时进行不必要的
    CPU 处理。一些缓存选项包括利用 ASP.NET 内存缓存，或外部缓存数据库，如 Redis。这两个都可通过 NuGet 包获得。
- en: Utilizing a database
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用数据库
- en: On a similar note to the caching suggestion, recording the results in a database
    could avoid unnecessary CPU processing. A logical choice would be to utilize a
    NoSQL database such as MongoDB. Using the SHA1 hash as the key and the value as
    the full JSON response could significantly improve performance in a high-traffic
    scenario. MongoDB has a .NET interface available on NuGet called `MongoDB.Driver`.
    Version 2.10.0 is the latest at the time of writing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与缓存建议类似，将结果记录在数据库中可以避免不必要的 CPU 处理。一个合理的选择是使用 NoSQL 数据库，例如 MongoDB。使用 SHA1 哈希作为键，将完整
    JSON 响应作为值可以显著提高高流量场景下的性能。MongoDB 在 NuGet 上有一个名为 `MongoDB.Driver` 的 .NET 接口。在撰写本文时，2.10.0
    是最新的版本。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we have discussed what goes into a production-ready
    ASP.NET Core Blazor web application architecture, using the work performed in
    previous chapters as a foundation. We also created a brand new file classification
    web application utilizing the FastTree binary classifier from ML.NET. Lastly,
    we also discussed some ways to further enhance an ASP.NET Core application (and
    production applications in general).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的讨论过程中，我们探讨了构建一个生产就绪的 ASP.NET Core Blazor 网络应用程序架构所需的内容，并以前几章的工作为基础。我们还创建了一个全新的文件分类网络应用程序，利用了
    ML.NET 的 FastTree 二进制分类器。最后，我们还讨论了一些进一步增强 ASP.NET Core 应用程序（以及一般的生产应用程序）的方法。
- en: In the next chapter, we will deep dive into creating a production web browser
    using the content of a web page to determine if the content is malicious or not,
    using ML.NET's sentiment analysis and the UWP framework.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨创建一个生产级网络浏览器，使用网页内容来确定内容是否恶意，利用 ML.NET 的情感分析和 UWP 框架。
