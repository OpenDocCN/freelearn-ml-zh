- en: Using ML.NET with ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an idea of how to create a production-grade .NET Core console
    application, in this chapter, we will deep dive into creating a fully functional
    ASP.NET Core Blazor web application. This application will utilize an ML.NET binary
    classification model to make file classifications on Windows executables (**Portable
    Executable** (**PE**) files), in order to determine whether the files themselves are
    either clean or malicious. Furthermore, we will explore breaking our application code
    into a component-based architecture using a .NET Core library to share between
    our web application and the console application that will train our model. By
    the end of the chapter, you should have a firm grasp of designing and coding a
    production-grade ASP.NET Core Blazor web application with ML.NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the file classification web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring additional production-application enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking down ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on the same .NET Core technology discussed in [Chapter 8](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml),
    *Using ML.NET with .NET Core and Forecasting*, ASP.NET Core adds a powerful web
    framework. This web framework includes a powerful rendering engine, Razor, in
    addition to supporting scalable **representational state transfer** (**REST**)
    services. The example in this chapter will use this technology to create our file
    classification frontend. In the next two sections, we will dive into the ASP.NET
    Core architecture and discuss Blazor, the new web framework from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ASP.NET Core architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a high level, ASP.NET Core builds on top of .NET Core, providing a fully-featured
    web framework. As with .NET Core, ASP.NET Core runs on Windows, Linux, and macOS,
    in addition to allowing deployments to x86, x64, and **Advanced RISC Machine**
    (**ARM**) CPU architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical ASP.NET Core application includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components form a common web architecture principle of **Model-View-Controller**,
    otherwise known as **MVC**.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controllers provide the server-side code for handling business logic for both
    web applications and REST services. Controllers can include both web and REST
    calls in the same controller, although I would recommend keeping them separate
    to ensure your code is organized cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models provide the container of data from the Controller to the View, and vice
    versa. For example, take a listing page pulling data from a database. The controller
    would return a model populated with that data, and if that same data was then
    used for filtering, it would also be serialized into **JavaScript Object Notation**
    (**JSON**) and sent back to the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views provide the templates for the frontend view with support for model binding.
    Model binding allows properties bound to various **Domain Object Model** (**DOM**)
    objects—such as textboxes, checkboxes, and dropdowns—to be cleanly mapped to and
    from. This approach of model binding has the added benefit of supporting strongly
    typed references, which comes in extremely handy when you have a complex View
    with dozens of properties bound to a Model.
  prefs: []
  type: TYPE_NORMAL
- en: Form handling with the model binding provides a similar model to the **Model-View
    ViewModel** (**MVVM**) approach we are going to dive into in [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*, with a **Universal Windows Platform** (**UWP**) application.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to deep dive further into ASP.NET, Channel 9 from Microsoft has
    a series called ASP.NET Core 101 that covers all of the main aspects of ASP.NET,
    at [https://channel9.msdn.com/Series/ASPNET-Core-101](https://channel9.msdn.com/Series/ASPNET-Core-101).
  prefs: []
  type: TYPE_NORMAL
- en: Blazor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on the ASP.NET Core infrastructure, Blazor focuses on removing one
    of the biggest hurdles with complex web applications—**JavaScript**. Blazor allows
    you to write C# code instead of JavaScript code to handle client-side tasks such
    as form handling, HTTP calls, and asynchronously loading data. Under the hood,
    Blazor uses **WebAssembly** (**Wasm**), a popular high-performant JavaScript framework
    supported by all current browsers (Edge, Safari, Chrome, and Firefox).
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other frameworks, Blazor also supports and recommends the use of
    modular components to promote reuse. These are called **Blazor** **components**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there are three project types when creating a Blazor application:'
  prefs: []
  type: TYPE_NORMAL
- en: The Blazor-only client side is used, which is ideal for more static pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blazor (ASP.NET Core-hosted) client-side application that is hosted inside
    ASP.NET Core (this is the project type we are going to review in the next section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blazor server-side application that updates the DOM. This is ideal for use
    with SignalR, Microsoft's real-time web framework supporting chats, real-time
    tickers, and maps, to name but a few.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to deep dive further into Blazor, Microsoft has written an abundant
    amount of documentation on **Microsoft Developer Network** (**MSDN**) at: [https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1](https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the file classification web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the application we will be creating is a file classification
    web application. Using the knowledge garnered in the *Creating a binary classification
    application* section in [Chapter 4](da0d1d99-ad37-498b-8670-f8cee6ad49bc.xhtml),
    *Classification Model*, we will be taking it a step further and looking at adding
    more attributes to a file prior to making a classification. In addition, we will
    be integrating machine learning with ML.NET into the web application, where an
    end user can upload files for classification, returning either clean or malicious
    files, along with a confidence of that prediction.
  prefs: []
  type: TYPE_NORMAL
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded at: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter09](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the previous applications have all been command-line applications, the
    project architecture for this example is quite different.
  prefs: []
  type: TYPE_NORMAL
- en: As with some of the previous chapters, an additional ML.NET NuGet package—`Microsoft.ML.FastTree`—is
    required in order to utilize the `FastTree` algorithm in ML.NET. Version 1.3.1
    is used in both the included example on GitHub and throughout this chapter's deep
    dive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the example''s solution. Given that this example comprises three separate
    projects (more akin to a production scenario), the amount of both new and significantly
    modified files is quite large. We will review each of the new files shown in the
    following solution screenshot in detail in further sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75e605e4-a04e-4723-8895-f9c81ffad49a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sampledata.csv` file contains 14 rows of extracted features from Windows
    Executables (we will go into these features in more detail in the next section).
    Feel free to adjust the data to fit your own observations or to adjust the trained
    model with different sample files. The following snippet is one of the rows found
    in the `sampledata.data` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, we added the `testdata.data` file that contains additional
    data points to test the newly trained model against and evaluate it. Here is a
    sample row of the data inside of `testdata.data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the size of the example project, we will be diving into the code for
    each of the different components before running the applications at the end of
    this section, in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Core library for common code between the two applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ASP.NET Blazor web application for running the prediction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The .NET Core console application for feature extraction and training
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classes and enumerations that were changed or added are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileClassificationResponseItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Converters`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtensionMethods`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HashingExtension`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileDataPrediction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileClassificationFeatureExtractor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileClassificationPredictor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileClassificationTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Constants` and `BaseML` classes remain unmodified from [Chapter 8](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml),
    *Using ML.NET with .NET Core and Forecasting*.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the nature of this application and that of production applications, where
    there are multiple platforms and/or ways to execute shared code, a library is
    used in this chapter's example application. The benefit of using a library is
    that all common code can reside in a portable and dependency-free manner. Expanding the
    functionality in this sample application to include desktop or mobile applications
    would be a much easier lift than having the code either duplicated or kept in
    the actual applications.
  prefs: []
  type: TYPE_NORMAL
- en: The FileClassificationResponseItem class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FileClassificationResponseItem` class is the common class that contains
    the properties that are used to feed our model, and is also used to return back
    to the end user in the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the `TRUE` and `FALSE` mapping to `1.0f` and `0.0f` respectively,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add all of the properties to be used to feed our model and display
    it back to the end user in the web application. The `FileSize`, `Is64Bit`, `NumImports`,  `NumImportFunctions`,
    `NumExportFunctions`, `IsSigned`, and `Strings` properties are used specifically
    as features in our model. The `SHA1Sum`, `Confidence`, `IsMalicious`, and `ErrorMessage` properties
    are used to return our classification back to the end user, as illustrated in
    the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the constructor method.  The constructor, as you can see, has
    a byte array as a parameter. This was done to facilitate both the training and
    prediction paths in both of the applications, the idea being that the raw file
    bytes will come into the constructor from a `File.ReadAllBytes` call or other
    mechanisms, to provide flexibility. From there, we use the `PeNet` NuGet package.
    This package provides an easy-to-use interface for extracting features from a
    Windows Executable (also known as a PE file). For the scope of this application,
    a couple of features were chosen to be extracted and stored into the respective
    properties, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The FileData class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FileData` class, as with previous containers of prediction data, provides
    our model with the fields necessary to provide a file classification. In addition,
    we overrode the `ToString` method to ease the exporting of this data to a **comma-separated
    values** (**CSV**) file during our feature extraction step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The FileDataPrediction class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FileDataPrediction` class contains the prediction''s classification and
    probability properties to return to the end user in our web application, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Converters class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Converters` class provides an extension method to convert the `FileClassificationResponseItem`
    class—reviewed earlier in this section—to the `FileData` class. By making an extension
    method, as shown in the following code block, we can quickly and cleanly convert
    between the application container and our model-only container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The ExtensionMethods class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ExtensionMethods` class, as shown in previous chapters, contains helper
    extension methods. In this example, we will be adding in the `ToStrings` extension
    method. Strings are a highly popular first pass and an easy-to-capture feature
    when making a classification of a file. Let''s dive into the method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define two new constants for handling the buffer size and the encoding.
    As mentioned earlier, `1252` is the encoding in which Windows Executables are
    encoded, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next change is the addition of the `ToStringsExtraction` method itself
    and defining our regular expression, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This regular expression is what we will use to traverse the file's bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we initialize the `StringBuilder` class and check if the passed-in byte
    array is null or empty (if it is, we can''t process it), like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have confirmed there are bytes in the passed-in array, we only
    want to take up to `65536` bytes. The reason for this is that if the file is 100
    MB, this operation could take significant time to perform. Feel free to adjust
    this number and see the efficacy results. The code is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the bytes we are going to analyze, we will loop through and
    extract lines of text found in the bytes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we simply return the lines joined into a single string, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The HashingExtensions class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new `HashingExtensions` class converts our byte array to a SHA1 string.
    The reason for not putting this with our other extension methods is to provide
    a common class to potentially hold SHA256, ssdeep, or other hashes (especially
    given the recent SHA1 collisions, proving SHA1 to be insecure).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this method, we''re using the built-in .NET Core `SHA1` class, and then
    converting it to a Base64 string with a call to `ToBase64String`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The FileClassificationFeatureExtractor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FileClassificationFeatureExtractor` class contains our `Extract` and `ExtractFolder`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our `ExtractFolder` method takes in the folder path and the output file
    that will contain our feature extraction, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `Extract` method to call both the training and test extraction,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The FileClassificationPredictor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FileClassificationPredictor` class provides the interface for both our
    command-line and web applications, using an overloaded `Predict` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `Predict` method is for our command-line application that simply
    takes in the filename and is called into the overload in *Step 2* after loading
    in the bytes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second implementation is for our web application that takes the `FileClassificationResponseItem`
    object, creates our prediction engine, and returns the prediction data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The FileClassificationTrainer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last class added in the library is the `FileClassificationTrainer` class.
    This class supports the use of the `FastTree` ML.NET trainer, as well as utilizing
    our features we have extracted from the files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is the use of the `FileData` class to read the CSV file into
    the `dataView` property, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '2\. Next, we map our `FileData` features to create our pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '3\. Lastly, we initialize our `FastTree` algorithm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the method is similar to our previous binary classification `Train`
    method in [Chapter 5](4c32e261-cec6-4113-9734-1e29c7c18f9a.xhtml), *Clustering
    Models*.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the library code having been reviewed, the next component is the web application.
    As discussed in the opening section, our web application is an ASP.NET Core Blazor
    application. For the scope of this example, we are using standard approaches for
    handling the backend and frontend. The architecture of this app combines both
    Blazor and ASP.NET Core—specifically, using ASP.NET Core to handle the REST service
    component of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files we will be diving into in this section are the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UploadController`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Startup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Index.razor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UploadController class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of the `UploadController` class is to handle the server-side processing
    of the file once submitted. For those having used ASP.NET MVC or Web API in the
    past, this controller should look very familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to note is the attribute tags decorating the class. The `ApiController`
    attribute configures the controller to handle HTTP APIs, while the `Route` tag
    indicates the controller will be listening on the `/Upload` path, as shown in
    the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to note is the use of **Dependency Injection** (**DI**) in the
    constructor of `UploadController` passing in the predictor object. DI is a powerful
    approach to providing access to singleton objects such as `FileClassificationPredictor`
    or databases, and is illustrated in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a helper method to handle taking the `IFormFile` from the HTTP
    post and returning all of the bytes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we create the `Post` method. The `HttpPost` attribute tells the routing
    engine to listen for only a `HttpPost` call. The method handles taking the output
    of the `GetBytesFromPost` method call, creates the `FileClassificationResponseItem`
    object, and then returns the prediction, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Startup class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Startup` class in both an ASP.NET Core and Blazor app controls the initialization
    of the various services used in the web application. Two major changes have been
    made to the `Startup` template that comes with Visual Studio, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is in the `ConfigureServices` method. Because this was a combined
    application of both ASP.NET Core and Blazor, we need to call the `AddControllers`
    method. In addition, we are going to utilize DI and initialize the predictor object
    once, prior to adding it as a singleton, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The second change comes in the `Configure` method. The first thing is to register
    the `CodePages` instance. Without this call, the feature extraction call to reference
    the Windows-1252 encoding will cause an exception (we will add this call to the
    trainer application as well, in the next section). The second thing is to configure
    the use of `MapControllerRoute`, as illustrated in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The Index.razor file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Index.razor` file contains the frontend to our file classification web
    application. In addition, it contains the REST call to our `UploadController`
    class described earlier in this section. For this deep dive, we will specifically
    look at the Blazor code block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to note is the declaration of our `FileClassificationResponseItem`
    class. We define the variable in this block, as it will allow access throughout
    the page. The second element is the declaration of our `HandleSelection` method,
    as illustrated in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we take the first file, convert it to an array of bytes, and create the
    `MultipartFormdataContent` object to POST to the previously described `Post` method,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we POST the file to our `UploadController` endpoint and asynchronously
    await the response from our ML.NET prediction, before assigning the response to
    our response variable, `_classificationResponseItem`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Diving into the trainer application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have reviewed the shared library and the web application,  let's
    dive into the trainer application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will review the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProgramArguments`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgramActions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ProgramArguments class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building off the work in the `ProgramArguments` class detailed in [Chapter
    8](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml), *Using ML.NET with .NET Core and
    Forecasting*, we are only making one addition to the class. This change adds properties
    to store the `Testing` and `Training` folder paths, and is illustrated in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the previous chapter, feature extraction is based on a number of Windows
    executable files, as opposed to just an included CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: The ProgramActions enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first change is in the `ProgramActions` enumeration. In [Chapter 8](a29eb79a-eca6-4b4f-b6a1-ee4c57d6d4d4.xhtml), *Using
    ML.NET with .NET Core and Forecasting*, we had only training and prediction. However,
    as mentioned earlier in this chapter, we now also have `FeatureExtraction` to
    perform. To add support, we simply add `FEATURE_EXTRACTOR` to the enumeration,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The Program class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `Program` class, there are only two changes from the previous chapter''s
    overhaul of the command-line argument parsing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to register the `CodePages` encoder instance to properly read
    the Windows-1252 encoding from the files as we did in the web application, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We then can use a simplified and strongly typed switch case to handle our three
    actions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Running the trainer application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we will need to first run the `chapter09.trainer` application to
    perform feature extraction and training of our model. To run the trainer application,
    the process is nearly identical to the sample application shown in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml),
    *Regression Model*, with the addition of passing in the test dataset folder path
    when training, and we will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run the trainer application, passing in the paths to the training and
    test folders to perform feature extraction, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Included in the code repository are two pre-feature extracted files (`sampledata.csv` and
    t`estdata.csv`) to allow you to train a model without performing your own feature
    extraction.  If you would like to perform your own feature extraction, create
    a `TestData` and `TrainingData` folder.  Populate these folders with a sampling
    of **PowerShell **(**PS1**), **Windows Executables** (**EXE **) and **Microsoft
    Word documents** (**DOCX**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will again run the application to train the model based on *Step 1* sample
    and test data exports. The resulting model (`fileclassification.mdl`) will be
    in the same folder as the executable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to modify the values and see how the prediction changes based on
    the dataset on which the model was trained. A few areas of experimentation from
    this point might be to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tweak the hyperparameters reviewed in the `Trainer` class—such as the `numberOfLeaves`,
    `numberOfTrees`, and `learningRate`—to see how accuracy is affected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add new features to the `FileData` class, such as specific imports, instead
    of using just the count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add more variation to the training and sample set to get a better sampling of
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For convenience, the GitHub repository includes both the `testdata.csv` and
    `sampledata.csv` files.
  prefs: []
  type: TYPE_NORMAL
- en: Running the web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our model has been trained, we can run our web application and test
    the submission of a file. You must first build the web application if you haven''t
    already. This will create the `bin\debug\netcoreapp3.1` folder. After building
    the web application, copy the model we trained in the previous section. At this
    point, start the web application. Upon starting, you should see the following
    in your default browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/853d9d5f-3a41-4867-aeec-bc598f0bebea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Proceed to click on the Choose File button, select an `.exe` or `.dll` file,
    and you should see the following results from our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/097bd073-ce7c-4952-a75d-855b741af60b.png)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to try various files on your machine to see the confidence score,
    and if you receive a false positive, perhaps add additional features to the model
    to correct the classification.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring additional ideas for improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed our deep dive, there are a couple of additional elements
    to possibly further enhance the application. A few ideas are discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with our previous chapter's deep dive into logging, adding logging could
    be crucial to remotely understand when an error occurs on a web application. Logging
    utilizing NLog ([https://nlog-project.org/](https://nlog-project.org/)) or a similar
    open source project is highly recommended as your application complexity increases.
    This will allow you to log to a file, console, or third-party logging solution—such
    as Loggly—at varying levels.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a caching layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine deploying this application on a public-facing web server and having
    hundreds of concurrent users. Chances are that users might upload the same file—caching
    the results in memory would avoid unnecessary CPU processing to run the prediction
    every time. Some caching options include utilizing the ASP.NET in-memory caching,
    or external caching databases such as Redis. These are both available via NuGet
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a similar note to the caching suggestion, recording the results in a database
    could avoid unnecessary CPU processing. A logical choice would be to utilize a
    NoSQL database such as MongoDB. Using the SHA1 hash as the key and the value as
    the full JSON response could significantly improve performance in a high-traffic
    scenario. MongoDB has a .NET interface available on NuGet called `MongoDB.Driver`.
    Version 2.10.0 is the latest at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we have discussed what goes into a production-ready
    ASP.NET Core Blazor web application architecture, using the work performed in
    previous chapters as a foundation. We also created a brand new file classification
    web application utilizing the FastTree binary classifier from ML.NET. Lastly,
    we also discussed some ways to further enhance an ASP.NET Core application (and
    production applications in general).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deep dive into creating a production web browser
    using the content of a web page to determine if the content is malicious or not,
    using ML.NET's sentiment analysis and the UWP framework.
  prefs: []
  type: TYPE_NORMAL
