["```py\n    //To create histograms of gray-level images \n    class Histogram1D { \n\n      private: \n        int histSize[1];          // number of bins in histogram \n        float hranges[2];         // range of values \n        const float* ranges[1];   // pointer to the value ranges \n        int channels[1];          // channel number to be examined \n\n      public: \n      Histogram1D() { \n\n        // Prepare default arguments for 1D histogram \n        histSize[0]= 256;        // 256 bins \n        hranges[0]= 0.0;         // from 0 (inclusive) \n        hranges[1]= 256.0;       // to 256 (exclusive) \n        ranges[0]= hranges;  \n        channels[0]= 0;          // we look at channel 0 \n      }\n\n```", "```py\n    // Computes the 1D histogram. \n    cv::Mat getHistogram(const cv::Mat &image) { \n\n      cv::Mat hist; \n      // Compute 1D histogram with calcHist \n      cv::calcHist(&image, 1, // histogram of 1 image only \n                   channels,  // the channel used \n                   cv::Mat(), // no mask is used \n                   hist,      // the resulting histogram \n                   1,         // it is a 1D histogram \n                   histSize,  // number of bins \n                   ranges     // pixel value range \n      ); \n\n      return hist; \n    } \n\n```", "```py\n    // Read input image \n    cv::Mat image= cv::imread(\"group.jpg\", 0); // open in b&w \n\n    // The histogram object \n    Histogram1D h; \n\n    // Compute the histogram \n    cv::Mat histo= h.getHistogram(image); \n\n```", "```py\n    // Loop over each bin \n    for (int i=0; i<256; i++) \n      cout << \"Value \" << i << \" = \" \n           <<histo.at<float>(i) << endl; \n\n```", "```py\n    Value 7 = 159 \n    Value 8 = 208 \n    Value 9 = 271 \n    Value 10 = 288 \n    Value 11 = 340 \n    Value 12 = 418 \n    Value 13 = 432 \n    Value 14 = 472 \n    Value 15 = 525 \n\n```", "```py\n    // Computes the 1D histogram and returns an image of it. \n    cv::Mat getHistogramImage(const cv::Mat &image, int zoom=1) { \n\n      // Compute histogram first \n      cv::Mat hist= getHistogram(image); \n      // Creates image \n      return getImageOfHistogram(hist, zoom); \n    } \n\n    // Create an image representing a histogram (static method) \n    static cv::Mat getImageOfHistogram (const cv::Mat &hist, int zoom) { \n      // Get min and max bin values \n      double maxVal = 0; \n      double minVal = 0; \n      cv::minMaxLoc(hist, &minVal, &maxVal, 0, 0); \n\n      // get histogram size \n      int histSize = hist.rows; \n\n      // Square image on which to display histogram \n      cv::Mat histImg(histSize*zoom, histSize*zoom,\n                      CV_8U, cv::Scalar(255)); \n\n      // set highest point at 90% of nbins (i.e. image height) \n      int hpt = static_cast<int>(0.9*histSize); \n\n      // Draw vertical line for each bin  \n      for (int h = 0; h < histSize; h++) { \n\n        float binVal = hist.at<float>(h); \n        if (binVal>0) { \n          int intensity = static_cast<int>(binVal*hpt / maxVal); \n          cv::line(histImg, cv::Point(h*zoom, histSize*zoom),\n                   cv::Point(h*zoom, (histSize - intensity)*zoom),\n                   cv::Scalar(0), zoom); \n        } \n      } \n\n      return histImg; \n    }\n\n```", "```py\n    //Display a histogram as an image \n    cv::namedWindow(\"Histogram\"); \n    cv::imshow(\"Histogram\", h.getHistogramImage(image)); \n\n```", "```py\n    cv::Mat thresholded;                 // output binary image \n    cv::threshold(image,thresholded,70,  // threshold value \n                  255,                   // value assigned to  \n                                         // pixels over threshold value \n                  cv::THRESH_BINARY);    // thresholding type \n\n```", "```py\n    void calcHist(const Mat*images, // source images \n          int nimages,          // number of source images (usually 1) \n          const int*channels,   // list the channels to be used \n          InputArray mask,      // input mask (pixels to consider) \n          OutputArray hist,     // output histogram \n          int dims,             // histogram dimension (number of channels) \n          const int*histSize,   // number of bins in each dimension \n          const float**ranges,  // range of each dimension \n          bool uniform=true,    // true if equally spaced bins \n          bool accumulate=false) // to cumulate over several calls \n\n```", "```py\n    float binVal = hist.at<float>(h); \n\n```", "```py\n    class ColorHistogram { \n\n      private: \n        int histSize[3];        // size of each dimension \n        float hranges[2];       // range of values (same for the 3 dimensions) \n        const float* ranges[3]; // ranges for each dimension \n        int channels[3];        // channel to be considered \n\n      public: \n      ColorHistogram() { \n\n        // Prepare default arguments for a color histogram \n        // each dimension has equal size and range \n        histSize[0]= histSize[1]= histSize[2]= 256; \n        hranges[0]= 0.0;    // BRG range from 0 to 256 \n        hranges[1]= 256.0; \n        ranges[0]= hranges; // in this class,   \n        ranges[1]= hranges; // all channels have the same range \n        ranges[2]= hranges; \n        channels[0]= 0;     // the three channels: B \n        channels[1]= 1;     // G \n        channels[2]= 2;     // R \n      }\n\n```", "```py\n    //Computes the histogram. \n    cv::Mat getHistogram(const cv::Mat &image) { \n      cv::Mat hist; \n\n      //Compute histogram \n      cv::calcHist(&image, 1,  // histogram of 1 image only \n                   channels,   // the channel used \n                   cv::Mat(),  // no mask is used \n                   hist,       // the resulting histogram \n                   3,          // it is a 3D histogram \n                   histSize,   // number of bins \n                   ranges      // pixel value range \n      ); \n\n      return hist; \n    }\n\n```", "```py\n    //Computes the histogram. \n    cv::SparseMat getSparseHistogram(const cv::Mat &image) { \n\n      cv::SparseMat hist(3,        // number of dimensions \n                    histSize,      // size of each dimension \n                    CV_32F); \n\n      //Compute histogram \n      cv::calcHist(&image, 1, // histogram of 1 image only \n                   channels,  // the channel used \n                   cv::Mat(), // no mask is used \n                   hist,      // the resulting histogram \n                   3,         // it is a 3D histogram \n                   histSize,  // number of bins \n                   ranges     // pixel value range \n      ); \n      return hist; \n    }\n\n```", "```py\n    newIntensity= lookup[oldIntensity]; \n\n```", "```py\n    static cv::Mat applyLookUp(const cv::Mat& image,   // input image \n                               const cv::Mat& lookup) {// 1x256 8U \n      // the output image \n      cv::Mat result; \n\n      // apply lookup table \n      cv::LUT(image,lookup,result); \n      return result; \n    }\n\n```", "```py\n    //Create an image inversion table \n    cv::Mat lut(1,256,CV_8U); // 256x1 matrix \n\n    for (int i=0; i<256; i++) { \n      //0 becomes 255, 1 becomes 254, etc. \n      lut.at<uchar>(i)= 255-i; \n    } \n\n```", "```py\n    // number of pixels in percentile \n    float number= image.total()*percentile; \n\n    // find left extremity of the histogram \n    int imin = 0; \n    for (float count=0.0; imin < 256; imin++) { \n      // number of pixel at imin and below must be > number \n      if ((count+=hist.at<float>(imin)) >= number) \n        break; \n    } \n\n    // find right extremity of the histogram \n    int imax = 255; \n    for (float count=0.0; imax >= 0; imax--) { \n      // number of pixel at imax and below must be > number \n      if ((count += hist.at<float>(imax)) >= number) \n        break; \n    }\n\n```", "```py\n    255.0*(i-imin)/(imax-imin); \n\n```", "```py\n    void colorReduce(cv::Mat &image, int div=64) { \n\n      // creating the 1D lookup table \n      cv::Mat lookup(1,256,CV_8U); \n\n      // defining the color reduction lookup \n      for (int i=0; i<256; i++)  \n        lookup.at<uchar>(i)= i/div*div + div/2; \n\n      // lookup table applied on all channels \n      cv::LUT(image,lookup,image); \n    }\n\n```", "```py\n    cv::equalizeHist(image,result); \n\n```", "```py\n    lookup.at<uchar>(i)= static_cast<uchar>(255.0*p[i]/image.total()); \n\n```", "```py\n    cv::Mat imageROI; \n    imageROI= image(cv::Rect(216,33,24,30)); // Cloud region \n\n```", "```py\n    Histogram1D h; \n    cv::Mat hist= h.getHistogram(imageROI); \n\n```", "```py\n    cv::normalize(histogram,histogram,1.0); \n\n```", "```py\n    cv::calcBackProject(&image,\n             1,          // one image \n             channels,   // the channels used,  \n                         // based on histogram dimension \n             histogram,  // the histogram we are backprojecting \n             result,     // the resulting back projection image \n             ranges,     // the ranges of values \n             255.0       // the scaling factor is chosen  \n                         // such that a probability value of 1 maps to 255 \n    ); \n\n```", "```py\n    cv::threshold(result, result, threshold, 255, cv::THRESH_BINARY); \n\n```", "```py\n    class ContentFinder { \n      private: \n        // histogram parameters \n        float hranges[2]; \n        const float* ranges[3]; \n        int channels[3]; \n        float threshold;         // decision threshold \n        cv::Mat histogram;       // input histogram  \n\n      public: \n      ContentFinder() : threshold(0.1f) { \n        // in this class, all channels have the same range \n        ranges[0]= hranges;   \n        ranges[1]= hranges;  \n        ranges[2]= hranges;  \n      }\n\n```", "```py\n    // Sets the reference histogram \n    void setHistogram(const cv::Mat& h) { \n      histogram= h; \n      cv::normalize(histogram,histogram,1.0); \n    }\n\n```", "```py\n    // Simplified version in which \n    // all channels used, with range [0,256[ by default \n    cv::Mat find(const cv::Mat& image) { \n\n      cv::Mat result; \n      hranges[0]= 0.0;   // default range [0,256[hranges[1]= 256.0; \n      channels[0]= 0;    // the three channels  \n      channels[1]= 1;  \n      channels[2]= 2;  \n      return find(image, hranges[0], hranges[1], channels); \n    } \n\n    // Finds the pixels belonging to the histogram \n    cv::Mat find(const cv::Mat& image, float minValue, float maxValue,\n                 int *channels) { \n\n      cv::Mat result; \n      hranges[0]= minValue; \n      hranges[1]= maxValue; \n      // histogram dim matches channel list \n      for (int i=0; i<histogram.dims; i++) \n        this->channels[i]= channels[i]; \n\n      cv::calcBackProject(&image, 1, // we only use one image  \n                  channels,    // channels used  \n                  histogram,   // the histogram we are using \n                  result,      // the back projection image \n                  ranges,      // the range of values, \n                               // for each dimension \n                  255.0        //the scaling factor is chosen such  \n                               //that a histogram value of 1 maps to 255 \n      ); \n    } \n\n    // Threshold back projection to obtain a binary image \n    if (threshold>0.0) \n      cv::threshold(result, result, 255.0*threshold,\n                    255.0, cv::THRESH_BINARY); \n\n      return result; \n    } \n\n```", "```py\n    // Load color image \n    ColorHistogram hc; \n    cv::Mat color= cv::imread(\"waves.jpg\"); \n\n    // extract region of interest \n    imageROI= color(cv::Rect(0,0,100,45)); // blue sky area \n\n    // Get 3D color histogram (8 bins per channel) \n    hc.setSize(8); // 8x8x8 \n    cv::Mat shist= hc.getHistogram(imageROI); \n\n```", "```py\n    // Create the content finder \n    ContentFinder finder; \n    // set histogram to be back-projected \n    finder.setHistogram(shist); \n    finder.setThreshold(0.05f); \n\n    // Get back-projection of color histogram \n    Cv::Mat result= finder.find(color); \n\n```", "```py\n    // Read reference image \n    cv::Mat image= cv::imread(\"baboon01.jpg\"); \n    // Baboon's face ROI \n    cv::Rect rect(110, 45, 35, 45); \n    cv::Mat imageROI= image(rect); \n    // Get the Hue histogram of baboon's face \n    int minSat=65; \n    ColorHistogram hc; \n    cv::Mat colorhist= hc.getHueHistogram(imageROI,minSat); \n\n```", "```py\n    // Computes the 1D Hue histogram  \n    // BGR source image is converted to HSV \n    // Pixels with low saturation are ignored \n    cv::Mat getHueHistogram(const cv::Mat &image, int minSaturation=0) { \n\n      cv::Mat hist; \n\n      // Convert to HSV colour space \n      cv::Mat hsv; \n      cv::cvtColor(image, hsv, CV_BGR2HSV); \n\n      // Mask to be used (or not) \n      cv::Mat mask; \n      // creating the mask if required \n      if (minSaturation>0) { \n\n        // Spliting the 3 channels into 3 images \n        std::vector<cv::Mat> v; \n        cv::split(hsv,v); \n\n        // Mask out the low saturated pixels \n        cv::threshold(v[1],mask,minSaturation,\n                      255, cv::THRESH_BINARY); \n      } \n\n      //Prepare arguments for a 1D hue histogram \n      hranges[0]= 0.0;    // range is from 0 to 180 \n      hranges[1]= 180.0; \n      channels[0]= 0;     // the hue channel  \n\n      //Compute histogram \n      cv::calcHist(&hsv, 1,  // histogram of 1 image only \n                   channels, //the channel used \n                   mask,     //binary mask \n                   hist,     //the resulting histogram \n                   1,        //it is a 1D histogram \n                   histSize, //number of bins \n                   ranges    //pixel value range \n      ); \n\n      return hist; \n    } \n\n```", "```py\n    ContentFinder finder; \n    finder.setHistogram(colorhist); \n\n```", "```py\n    image= cv::imread(\"baboon3.jpg\"); \n    // Convert to HSV space \n    cv::cvtColor(image, hsv, CV_BGR2HSV); \n    // Get back-projection of hue histogram \n    int ch[1]={0}; \n    finder.setThreshold(-1.0f); // no thresholding \n    cv::Mat result= finder.find(hsv,0.0f,180.0f,ch); \n\n```", "```py\n    // initial window position \n    cv::Rect rect(110,260,35,40); \n\n    // search object with mean shift \n    cv::TermCriteria criteria( \n               cv::TermCriteria::MAX_ITER | cv::TermCriteria::EPS,  \n               10, // iterate max 10 times \n               1); // or until the change in centroid position is less than 1px \n    cv::meanShift(result,rect,criteria); \n\n```", "```py\n    class ImageComparator { \n\n      private: \n\n      cv::Mat refH;         // reference histogram \n      cv::Mat inputH;       // histogram of input image \n\n      ColorHistogram hist;  // to generate the histograms \n      int nBins;           // number of bins used in each color channel \n\n      public: \n      ImageComparator() :nBins(8) { \n\n      } \n\n```", "```py\n    // set and compute histogram of reference image \n    void setReferenceImage(const cv::Mat& image) { \n\n      hist.setSize(nBins); \n      refH= hist.getHistogram(image); \n    } \n\n```", "```py\n    // compare the images using their BGR histograms \n    double compare(const cv::Mat& image) { \n\n      inputH= hist.getHistogram(image); \n\n      // histogram comparison using intersection \n      return cv::compareHist(refH,inputH, cv::HISTCMP_INTERSECT); \n    } \n\n```", "```py\n    ImageComparator c; \n    c.setReferenceImage(image); \n\n```", "```py\n    // Open image \n    cv::Mat image= cv::imread(\"bike55.bmp\",0); \n    // define image roi (here the girl on bike) \n    int xo=97, yo=112; \n    int width=25, height=30; \n    cv::Mat roi(image,cv::Rect(xo,yo,width,height)); \n    // compute sum \n    // returns a Scalar to work with multi-channel images \n    cv::Scalar sum= cv::sum(roi); \n\n```", "```py\n      // compute integral image \n      cv::Mat integralImage; \n      cv::integral(image,integralImage,CV_32S); \n\n```", "```py\n    // get sum over an area using three additions/subtractions \n    int sumInt= integralImage.at<int>(yo+height,xo+width)- \n                integralImage.at<int>(yo+height,xo)- \n                integralImage.at<int>(yo,xo+width)+ \n                integralImage.at<int>(yo,xo); \n\n```", "```py\n    // window at (xo,yo) of size width by height \n    return (integralImage.at<cv::Vec<T,N>>(yo+height,xo+width)- \n            integralImage.at<cv::Vec<T,N>>(yo+height,xo)- \n            integralImage.at<cv::Vec<T,N>>(yo,xo+width)+ \n            integralImage.at<cv::Vec<T,N>>(yo,xo)); \n\n```", "```py\n    // using a fixed threshold  \n    cv::Mat binaryFixed; \n    cv::threshold(image,binaryFixed,70,255,cv::THRESH_BINARY); \n\n```", "```py\n    // compute integral image \n    cv::Mat iimage; \n    cv::integral(image,iimage,CV_32S); \n\n```", "```py\n    int blockSize= 21;  // size of the neighborhood \n    int threshold=10;   // pixel will be compared \n                        // to (mean-threshold) \n\n    // for each row \n    int halfSize= blockSize/2; \n    for (int j=halfSize; j<nl-halfSize-1; j++) { \n\n      // get the address of row j \n      uchar* data= binary.ptr<uchar>(j); \n      int* idata1= iimage.ptr<int>(j-halfSize); \n      int* idata2= iimage.ptr<int>(j+halfSize+1); \n\n      // for each pixel of a line \n      for (int i=halfSize; i<nc-halfSize-1; i++) { \n\n        // compute sum \n        int sum= (idata2[i+halfSize+1]-data2[i-halfSize]-  \n                  idata1[i+halfSize+1]+idata1[i-halfSize]) \n                                      /(blockSize*blockSize); \n\n        // apply adaptive threshold \n        if (data[i]<(sum-threshold)) \n          data[i]= 0; \n        else \n          data[i]=255; \n      } \n    } \n\n```", "```py\n    cv::adaptiveThreshold(image,        // input image \n            binaryAdaptive,             // output binary image \n            255,                        // max value for output \n            cv::ADAPTIVE_THRESH_MEAN_C, // method \n            cv::THRESH_BINARY,          // threshold type \n            blockSize,                  // size of the block       \n            threshold);                 // threshold used \n\n```", "```py\n    cv::Mat filtered; \n    cv::Mat binaryFiltered;     \n    // box filter compute avg of pixels over a rectangular region \n    cv::boxFilter(image,filtered,CV_8U,cv::Size(blockSize,blockSize)); \n    // check if pixel greater than (mean + threshold) \n    binaryFiltered= image>= (filtered-threshold); \n\n```", "```py\n    // convert to a multi-channel image made of binary planes \n    // nPlanes must be a power of 2 \n    void convertToBinaryPlanes(const cv::Mat& input,              \n                               cv::Mat& output, int nPlanes) { \n\n      // number of bits to mask out \n      int n= 8-static_cast<int>( \n                     log(static_cast<double>(nPlanes))/log(2.0)); \n      // mask used to eliminate least significant bits \n      uchar mask= 0xFF<<n;  \n\n      // create a vector of binary images \n      std::vector<cv::Mat> planes; \n      // reduce to nBins by eliminating least significant bits \n      cv::Mat reduced= input&mask; \n\n      // compute each binary image plane \n      for (int i=0; i<nPlanes; i++) { \n        // 1 for each pixel equals to i<<shift \n        planes.push_back((reduced==(i<<n))&0x1); \n      } \n\n      // create multi-channel image \n      cv::merge(planes,output); \n    } \n\n```", "```py\n    template <typename T, int N> \n    class IntegralImage { \n\n      cv::Mat integralImage; \n\n      public: \n\n      IntegralImage(cv::Mat image) { \n\n       // (costly) computation of the integral image          \n       cv::integral(image,integralImage, \n                    cv::DataType<T>::type); \n      } \n\n      // compute sum over sub-regions of any size  \n      // from 4 pixel accesses \n      cv::Vec<T,N> operator()(int xo, int yo, int width, int height) { \n\n      // window at (xo,yo) of size width by height \n      return (integralImage.at<cv::Vec<T,N>>(yo+height,xo+width)- \n              integralImage.at<cv::Vec<T,N>>(yo+height,xo)- \n              integralImage.at<cv::Vec<T,N>>(yo,xo+width)+ \n              integralImage.at<cv::Vec<T,N>>(yo,xo)); \n      } \n\n    }; \n\n```", "```py\n    // histogram of 16 bins \n    Histogram1D h; \n    h.setNBins(16); \n    // compute histogram over image roi\n    cv::Mat refHistogram=  h.getHistogram(roi); \n\n```", "```py\n    // first create 16-plane binary image \n    cv::Mat planes; \n    convertToBinaryPlanes(secondIimage,planes,16); \n    // then compute integral image \n    IntegralImage<float,16> intHistogram(planes); \n\n```", "```py\n    double maxSimilarity=0.0; \n    int xbest, ybest; \n    // loop over a horizontal strip around girl \n    // location in initial image \n    for (int y=110; y<120; y++) { \n      for (int x=0; x<secondImage.cols-width; x++) { \n\n        // compute histogram of 16 bins using integral image \n        histogram= intHistogram(x,y,width,height); \n        // compute distance with reference histogram \n        double distance= cv::compareHist(refHistogram,\n                                         histogram,\n                                         CV_COMP_INTERSECT); \n        //find position of most similar histogram \n        if (distance>maxSimilarity) { \n\n          xbest= x; \n          ybest= y; \n          maxSimilarity= distance; \n        } \n      } \n    } \n    //draw rectangle at best location \n    cv::rectangle(secondImage, cv::Rect(xbest,ybest,width,height),0)); \n\n```"]