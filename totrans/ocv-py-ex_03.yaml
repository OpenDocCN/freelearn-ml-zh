- en: Chapter 3. Cartoonizing an Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to convert an image into a cartoon-like
    image. We will learn how to access the webcam and take keyboard/mouse inputs during
    a live video stream. We will also learn about some advanced image filters and
    see how we can use them to cartoonize an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will know:'
  prefs: []
  type: TYPE_NORMAL
- en: How to access the webcam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to take keyboard and mouse inputs during a live video stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create an interactive application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use advanced image filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to cartoonize an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the webcam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can build very interesting applications using the live video stream from
    the webcam. OpenCV provides a video capture object which handles everything related
    to opening and closing of the webcam. All we need to do is create that object
    and keep reading frames from it.
  prefs: []
  type: TYPE_NORMAL
- en: The following code will open the webcam, capture the frames, scale them down
    by a factor of 2, and then display them in a window. You can press the *Esc* key
    to exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we can see in the preceding code, we use OpenCV''s `VideoCapture` function
    to create the video capture object cap. Once it''s created, we start an infinite
    loop and keep reading frames from the webcam until we encounter a keyboard interrupt.
    In the first line within the while loop, we have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `ret` is a Boolean value returned by the `read` function, and it indicates
    whether or not the frame was captured successfully. If the frame is captured correctly,
    it''s stored in the variable `frame`. This loop will keep running until we press
    the *Esc* key. So we keep checking for a keyboard interrupt in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we know, the ASCII value of *Esc* is 27\. Once we encounter it, we break
    the loop and release the video capture object. The line `cap.release()` is important
    because it gracefully closes the webcam.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to capture a live video stream from the webcam, let's see
    how to use the keyboard to interact with the window displaying the video stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Interacting with the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program will display the input video stream and wait for the keyboard input
    to change the color space. If you run the previous program, you will see the window
    displaying the input video stream from the webcam. If you press *G*, you will
    see that the color space of the input stream gets converted to grayscale. If you
    press *Y*, the input stream will be converted to YUV color space. Similarly, if
    you press *H*, you will see the image being converted to HSV color space.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, we use the function `waitKey()` to listen to the keyboard events.
    As and when we encounter different keystrokes, we take appropriate actions. The
    reason we are using the function `ord()` is because `waitKey()` returns the ASCII
    value of the keyboard input; thus, we need to convert the characters into their
    ASCII form before checking their values.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to use the mouse to interact with the display
    window. Let's start with something simple. We will write a program that will detect
    the quadrant in which the mouse click was detected. Once we detect it, we will
    highlight that quadrant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mouse inputs](img/B04554_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What's happening underneath?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the main function in this program. We create a white image
    on which we are going to click using the mouse. We then create a named window
    and bind the mouse callback function to this window. Mouse callback function is
    basically the function that will be called when a mouse event is detected. There
    are many kinds of mouse events such as clicking, double-clicking, dragging, and
    so on. In our case, we just want to detect a mouse click. In the function `detect_quadrant`,
    we check the first input argument event to see what action was performed. OpenCV
    provides a set of predefined events, and we can call them using specific keywords.
    If you want to see a list of all the mouse events, you can go to the Python shell
    and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The second and third arguments in the function `detect_quadrant` provide the
    X and Y coordinates of the mouse click event. Once we know these coordinates,
    it's pretty straightforward to determine what quadrant it's in. With this information,
    we just go ahead and draw a rectangle with the specified color, using `cv2.rectangle()`.
    This is a very handy function that takes the top left point and the bottom right
    point to draw a rectangle on an image with the specified color.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with a live video stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can use the mouse to interact with live video stream from
    the webcam. We can use the mouse to select a region and then apply the "negative
    film" effect on that region, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interacting with a live video stream](img/B04554_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following program, we will capture the video stream from the webcam,
    select a region of interest with the mouse, and then apply the effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding program, you will see a window displaying the video
    stream. You can just draw a rectangle on the window using your mouse and you will
    see that region being converted to its "negative".
  prefs: []
  type: TYPE_NORMAL
- en: How did we do it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we can see in the main function of the program, we initialize a video capture
    object. We then bind the function `draw_rectangle` with the mouse callback in
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then start an infinite loop and start capturing the video stream. Let''s
    see what is happening in the function `draw_rectangle`. Whenever we draw a rectangle
    using the mouse, we basically have to detect three types of mouse events: mouse
    click, mouse movement, and mouse button release. This is exactly what we do in
    this function. Whenever we detect a mouse click event, we initialize the top left
    point of the rectangle. As we move the mouse, we select the region of interest
    by keeping the current position as the bottom right point of the rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the region of interest, we just invert the pixels to apply the
    "negative film" effect. We subtract the current pixel value from 255 and this
    gives us the desired effect. When the mouse movement stops and button-up event
    is detected, we stop updating the bottom right position of the rectangle. We just
    keep displaying this image until another mouse click event is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Cartoonizing an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to handle the webcam and keyboard/mouse inputs, let's go
    ahead and see how to convert a picture into a cartoon-like image. We can either
    convert an image into a sketch or a colored cartoon image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of what a sketch will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cartoonizing an image](img/B04554_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you apply the cartoonizing effect to the color image, it will look something
    like this next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cartoonizing an image](img/B04554_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Deconstructing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you run the preceding program, you will see a window with a video stream
    from the webcam. If you press *S*, the video stream will change to sketch mode
    and you will see its pencil-like outline. If you press *C*, you will see the color-cartoonized
    version of the input stream. If you press any other key, it will return to the
    normal mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the function `cartoonize_image` and see how we did it. We first
    convert the image to a grayscale image and run it through a median filter. Median
    filters are very good at removing salt and pepper noise. This is the kind of noise
    where you see isolated black or white pixels in the image. It is common in webcams
    and mobile cameras, so we need to filter it out before we proceed further. To
    give an example, look at the following images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deconstructing the code](img/B04554_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we see in the input image, there are a lot of isolated green pixels. They
    are lowering the quality of the image and we need to get rid of them. This is
    where the median filter comes in handy. We just look at the NxN neighborhood around
    each pixel and pick the median value of those numbers. Since the isolated pixels
    in this case have high values, taking the median value will get rid of these values
    and also smoothen the image. As you can see in the output image, the median filter
    got rid of all those isolated pixels and the image looks clean. Following is the
    code to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code is pretty straightforward. We just use the function `medianBlur` to
    apply the median filter to the input image. The second argument in this function
    specifies the size of the kernel we are using. The size of the kernel is related
    to the neighborhood size that we need to consider. You can play around with this
    parameter and see how it affects the output.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to `cartoonize_image`, we proceed to detect the edges on the grayscale
    image. We need to know where the edges are so that we can create the pencil-line
    effect. Once we detect the edges, we threshold them so that things become black
    and white, both literally and metaphorically!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we check if the sketch mode is enabled. If it is, then we
    just convert it into a color image and return it. What if we want the lines to
    be thicker? Let''s say we want to see something like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deconstructing the code](img/B04554_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the lines are thicker than before. To achieve this, replace
    the `if` code block with the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are using the erode function with a 3x3 kernel here. The reason we have this
    in place is because it gives us a chance to play with the thickness of the line
    drawing. Now you might ask that if we want to increase the thickness of something,
    shouldn't we be using dilation? Well, the reasoning is right, but there is a small
    twist here. Note that the foreground is black and the background is white. Erosion
    and dilation treat white pixels as foreground and black pixels as background.
    So if we want to increase the thickness of the black foreground, we need to use
    erosion. After we apply erosion, we just use the median filter to clear out the
    noise and get the final output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we use bilateral filtering to smoothen the image. Bilateral
    filtering is an interesting concept and its performance is much better than a
    Gaussian filter. The good thing about bilateral filtering is that it preserves
    the edges, whereas the Gaussian filter smoothens everything out equally. To compare
    and contrast, let''s look at the following input image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deconstructing the code](img/B04554_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s apply the Gaussian filter to the previous image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deconstructing the code](img/B04554_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s apply the bilateral filter to the input image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deconstructing the code](img/B04554_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the quality is better if we use the bilateral filter. The image
    looks smooth and the edges look nice and sharp! The code to achieve this is given
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you closely observe the two outputs, you can see that the edges in the Gaussian
    filtered image look blurred. Usually, we just want to smoothen the rough areas
    in the image and keep the edges intact. This is where the bilateral filter comes
    in handy. The Gaussian filter just looks at the immediate neighborhood and averages
    the pixel values using a Gaussian kernel. The bilateral filter takes this concept
    to the next level by averaging only those pixels that are similar to each other
    in intensity. It also takes a color neighborhood metric to see if it can replace
    the current pixel that is similar in intensity as well. If you look the function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The last two arguments here specify the color and space neighborhood. This is
    the reason the edges look crisp in the output of the bilateral filter. We run
    this filter multiple times on the image to smoothen it out, to make it look like
    a cartoon. We then superimpose the pencil-like mask on top of this color image
    to create a cartoon-like effect.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learnt how to access the webcam. We discussed how to take
    the keyboard and mouse inputs during live video stream. We used this knowledge
    to create an interactive application. We discussed the median and bilateral filters,
    and talked about the advantages of the bilateral filter over the Gaussian filter.
    We used all these principles to convert the input image into a sketch-like image,
    and then cartoonized it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to detect different body parts in static
    images as well as in live videos.
  prefs: []
  type: TYPE_NORMAL
