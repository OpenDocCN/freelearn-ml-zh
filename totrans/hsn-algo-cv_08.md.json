["```py\nusing namespace cv; \nusing namespace ml; \n```", "```py\nconst int SAMPLE_COUNT = 8; \nfloat samplesA[SAMPLE_COUNT][2] \n        = { {250, 50}, \n            {125, 100}, \n            {50, 50}, \n            {150, 150}, \n            {100, 250}, \n            {250, 250}, \n            {150, 50}, \n            {50, 250} }; \nMat samples(SAMPLE_COUNT, 2, CV_32F, samplesA); \n```", "```py\nint responsesA[SAMPLE_COUNT] \n        = {2, 2, 2, 2, 1, 2, 2, 1}; \nMat responses(SAMPLE_COUNT, 1, CV_32S, responsesA); \n```", "```py\nPtr<TrainData> data; \nSampleTypes layout = ROW_SAMPLE; \ndata = TrainData::create(samples, \n                         layout, \n                         responses); \n```", "```py\nPtr<SVM> svm = SVM::create(); \nsvm->setType(SVM::C_SVC); \nsvm->setKernel(SVM::LINEAR); \nsvm->setTermCriteria( \n            TermCriteria(TermCriteria::MAX_ITER + \n                         TermCriteria::EPS, \n                         100, \n                         1e-6)); \n```", "```py\nif(!svm->train(data)) \n{ \n    cout << \"training failed\" << endl; \n    return -1; \n} \n```", "```py\nMat image = Mat::zeros(300, \n                       300, \n                       CV_8UC3); \nVec3b blue(255,0,0), green(0,255,0); \nfor (int i=0; i<image.rows; ++i) \n{ \n    for (int j=0; j<image.cols; ++j) \n    { \n        Mat_<float> sampleMat(1,2); \n        sampleMat << j, i; \n        float response = svm->predict(sampleMat); \n\n        if (response == 1) \n            image.at<Vec3b>(i, j)  = green; \n        else if (response == 2) \n            image.at<Vec3b>(i, j)  = blue; \n    } \n} \n```", "```py\nVec3b black(0,0,0), white(255,255,255), color; \nfor(int i=0; i<SAMPLE_COUNT; i++) \n{ \n    Point p(samplesA[i][0], \n            samplesA[i][1]); \n    if (responsesA[i] == 1) \n        color = black; \n    else if (responsesA[i] == 2) \n        color = white; \n    circle(image, \n           p, \n           5, \n           color, \n           CV_FILLED); \n}\n```", "```py\nint responsesA[SAMPLE_COUNT] \n        = {2, 2, 2, 2, 1, 1, 2, 1}; \n```", "```py\nint responsesA[SAMPLE_COUNT] \n        = {2, 2, 3, 2, 1, 1, 2, 1};\n```", "```py\nHOGDescriptor hog; \nhog.winSize = Size(128, 128); \n```", "```py\nvector<float> tempDesc; \nhog.compute(Mat(hog.winSize, CV_8UC3), \n            tempDesc); \nint descriptorSize = tempDesc.size(); \n```", "```py\nvector<String> posFiles; \nglob(\"/pos\", posFiles); \n\nvector<String> negFiles; \nglob(\"/neg\", negFiles); \n```", "```py\nint scount = posFiles.size() + negFiles.size(); \n\nMat samples(scount, \n            descriptorSize, \n            CV_32F); \n\nMat responses(scount, \n              1, \n              CV_32S); \n```", "```py\nfor(int i=0; i<posFiles.size(); i++) \n{ \n    Mat image = imread(posFiles.at(i)); \n    if(image.empty()) \n        continue; \n    vector<float> descriptors; \n    if((image.cols != hog.winSize.width) \n            || \n            (image.rows != hog.winSize.height)) \n    { \n        resize(image, image, hog.winSize); \n    } \n    hog.compute(image, descriptors); \n    Mat(1, descriptorSize, CV_32F, descriptors.data()) \n            .copyTo(samples.row(i)); \n    responses.at<int>(i) = +1; // positive \n} \n```", "```py\nfor(int i=0; i<negFiles.size(); i++) \n{ \n    Mat image = imread(negFiles.at(i)); \n    if(image.empty()) \n        continue; \n    vector<float> descriptors; \n    if((image.cols != hog.winSize.width) \n            || \n            (image.rows != hog.winSize.height)) \n    { \n        resize(image, image, hog.winSize); \n    } \n    hog.compute(image, descriptors); \n    Mat(1, descriptorSize, CV_32F, descriptors.data()) \n            .copyTo(samples.row(i + posFiles.size())); \n    responses.at<int>(i + posFiles.size()) = -1;\n} \n```", "```py\nPtr<TrainData> tdata = TrainData::create(samples, \n                                         ROW_SAMPLE, \n                                         responses);\n```", "```py\nPtr<SVM> svm = SVM::create(); \nsvm->setType(SVM::C_SVC); \nsvm->setKernel(SVM::LINEAR); \nsvm->setTermCriteria( \n            TermCriteria(TermCriteria::MAX_ITER + \n                         TermCriteria::EPS, \n                         10000, \n                         1e-6)); \n\nsvm->train(tdata); \n```", "```py\nMat image = imread(\"image.jpg\"); \n\nif((image.cols != hog.winSize.width) \n        || \n        (image.rows != hog.winSize.height)) \n{ \n    resize(image, image, hog.winSize); \n} \n\nvector<float> descs; \nhog.compute(image, descs); \nint result = svm->predict(descs); \nif(result == +1) \n{ \n    cout << \"Image contains a traffic sign.\" << endl; \n} \nelse if(result == -1) \n{ \n    cout << \"Image does not contain a traffic sign.\" << endl; \n} \n```", "```py\nsvm->save(\"trained_svm_model.xml\"); \n```", "```py\nPtr<SVM> svm = SVM::load(\"trained_svm_model.xml \"); \n```", "```py\nSampleTypes layout = ROW_SAMPLE; \ndata = TrainData::create(samples, \n                         layout, \n                         responses); \n```", "```py\nPtr<ANN_MLP> ann = ANN_MLP::create(); \n```", "```py\nMat_<int> layers(4,1); \nlayers(0) = featureCount;    // input layer \nlayers(1) = classCount * 4;  // hidden layer 1 \nlayers(2) = classCount * 2;  // hidden layer 2 \nlayers(3) = classCount;      // output layer \nann->setLayerSizes(layers); \n```", "```py\nif(!ann->train(data)) \n{ \n    cout << \"training failed\" << endl; \n    return -1; \n} \n```", "```py\nMat_<float> input(1, featureCount); \nMat_<float> output(1, classCount); \n// fill the input Mat \nann->predict(input, output); \n```", "```py\nCascadeClassifier detector; \nif(!detector.load(\"classifier.xml\")) \n{ \n    cout << \"Can't load the provided cascade classifier.\" << endl; \n    return -1; \n} \n```", "```py\nvector<Rect> objects; \ndetector.detectMultiScale(frame, \n                          objects); \n\nfor(int i=0; i< objects.size(); i++) \n{ \n    rectangle(frame, \n              objects [i], \n              color, \n              thickness); \n} \n```", "```py\nScalar color = Scalar(0,0,255); \nint thickness = 2; \n```", "```py\ndouble t = (double)getTickCount(); \n\ndetector.detectMultiScale(image, \n                          objects); \n\nt = ((double)getTickCount() - t)/getTickFrequency(); \nt *= 1000; // convert to ms \n```", "```py\nScalar green = Scalar(0,255,0); \nint thickness = 2; \ndouble scale = 0.75; \nputText(frame, \n        \"Took \" + to_string(int(t)) + \"ms to detect\", \n        Point(0, frame.rows-1), \n        FONT_HERSHEY_SIMPLEX, \n        scale, \n        green, \n        thickness);\n```", "```py\ndouble scaleFactor = 1.1; \nint minNeighbors = 3; \nint flags = 0; // not used \nSize minSize(50,50); \nSize maxSize(500, 500); \nvector<Rect> objects; \ndetector.detectMultiScale(image, \n                          objects, \n                          scaleFactor, \n                          minNeighbors, \n                          flags, \n                          minSize, \n                          maxSize); \n```", "```py\nopencv_createsamples -vec samples.vec -img sign.png -bg bg.txt  \n    -num 250 -bgcolor 0 -bgthresh 10 -maxidev 50 \n    -maxxangle 0.7 -maxyangle 0.7 -maxzangle 0.5 \n    -w 32 -h 32 \n```", "```py\nopencv_annotation --images=imgpath --annotations=anno.txt \n```", "```py\n* mark rectangles with the left mouse button, \n* press 'c' to accept a selection, \n* press 'd' to delete the latest selection, \n* press 'n' to proceed with next image, \n* press 'esc' to stop.\n```", "```py\nsigns01.jpg 2 145 439 105 125 1469 335 185 180 \nsigns02.jpg 1 862 468 906 818 \nsigns03.jpg 1 1450 680 530 626 \nsigns04.jpg 1 426 326 302 298 \nsigns05.jpg 0 \nsigns06.jpg 1 1074 401 127 147 \nsigns07.jpg 1 1190 540 182 194 \nsigns08.jpg 1 794 460 470 488\n```", "```py\nopencv_createsamples -info anno.txt -vec samples.vec -w 32 -h 32 \n```", "```py\nopencv_traincascade -data classifier -vec samples.vec \n    -bg bg.txt -numPos 200 -numNeg 200 -w 32 -h 32 \n```", "```py\nusing namespace cv; \nusing namespace dnn; \n```", "```py\nopencv-source-files/samples/dnntf_text_graph_ssd.py\n```", "```py\ntf_text_graph_ssd.py --input frozen_inference_graph.pb \n            --output frozen_inference_graph.pbtxt \n```", "```py\nNet network = readNetFromTensorflow( \n        \"frozen_inference_graph.pb\", \n        \"frozen_inference_graph.pbtxt\"); \nif(network.empty()) \n    { \n        cout << \"Can't load TensorFlow model.\" << endl; \n        return -1; \n    } \n```", "```py\nconst int inWidth = 300; \nconst int inHeight = 300; \nconst float meanVal = 127.5; // 255 divided by 2 \nconst float inScaleFactor = 1.0f / meanVal; \nbool swapRB = true; \nbool crop = false; \nMat inputBlob = blobFromImage(frame, \n                      inScaleFactor, \n                      Size(inWidth, inHeight), \n                      Scalar(meanVal, meanVal, meanVal), \n                      swapRB, \n                      crop); \n\nnetwork.setInput(inputBlob); \n\nMat result = network.forward();\n```", "```py\nMat detections(result.size[2], \n               result.size[3], \n               CV_32F, \n               result.ptr<float>()); \n```", "```py\nconst float confidenceThreshold = 0.5f; \nfor(int i=0; i<detections.rows; i++) \n{ \n    float confidence = detections.at<float>(i, 2); \n    if(confidence > confidenceThreshold) \n    { \n        // passed the confidence threshold \n    } \n} \n```", "```py\nint objectClass = (int)(detections.at<float>(i, 1)) - 1; \nint left = static_cast<int>( \n            detections.at<float>(i, 3) * frame.cols); \nint top = static_cast<int>( \n            detections.at<float>(i, 4) * frame.rows); \nint right = static_cast<int>( \n            detections.at<float>(i, 5) * frame.cols); \nint bottom = static_cast<int>( \n            detections.at<float>(i, 6) * frame.rows); \nrectangle(frame, Point(left, top), \n          Point(right, bottom), Scalar(0, 255, 0)); \nString label = \"ID = \" + to_string(objectClass); \nif(objectClass < labels.size()) \n    label = labels[objectClass]; \nint baseLine = 0; \nSize labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, \n                             0.5, 2, &baseLine); \ntop = max(top, labelSize.height); \n\nrectangle(frame, \n          Point(left, top - labelSize.height), \n          Point(left + labelSize.width, top + baseLine), \n          white, \n                 CV_FILLED); \n\nputText(frame, label, Point(left, top), \n        FONT_HERSHEY_SIMPLEX, 0.5, red); \n```", "```py\nconst vector<string> labels = { \"person\", \"bicycle\" ...}; \n```"]