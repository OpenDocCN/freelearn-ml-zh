- en: Designing Functions and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue looking at the fundamental concepts of Julia. The
    topics that we have chosen here will provide a solid foundation of the key concepts
    of Julia programming. In particular, we will discuss the core Julia programming techniques
    that are related to functions and interfaces. Functions are the fundamental building
    blocks of software. Interfaces are contractual relationships between different
    components of the software. Effective use of functions and interfaces is a must
    for building robust applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple dispatch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parametric methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of the learning process, we will go over a use case of game design.
    More specifically, we will pretend that we are building a space war game that
    contains a game board with spaceships and asteroid pieces. We will build functions
    that move the game pieces around and equip the spaceships with weapons to blow
    things up.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the necessary knowledge to design
    and develop functions effectively. Through the use of multiple dispatch and parametric
    methods, your application will become more extendable. Once you have learned these
    techniques, you should also be able to design a system that contains pluggable
    components based on interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: I can't wait any longer. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: Designing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function is a core construct in Julia for defining the behaviors of an application.
    In fact, Julia works more like a procedural/functional programming language as
    opposed to an object-oriented programming language. In object-oriented programming,
    you focus on building classes and defining functions for those classes. In Julia,
    you focus on building functions that operate on data types or data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how functions are defined and the powerful
    features that come with functions.
  prefs: []
  type: TYPE_NORMAL
- en: Our use case – a space war game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will illustrate programming concepts by building
    parts of a space war game. The design of the game is very simple and straightforward.
    It consists of game pieces such as spaceships and asteroids that are scattered
    around a two-dimensional grid. These game pieces are called widgets in our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first define our data types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As data types are central to our design, this warrants a little more explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Position` type is used to store the coordinates of a game piece. It is
    represented by two integers: `x` and `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Size` type is used to store the size of a game piece. It is represented by
    two integers: `width` and `height`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Widget` type is used to hold a single game piece. It is represented by
    a `name`, `position`, and `size`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `Position` type is mutable because we expect our game pieces to
    move around by just updating their coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over a number of topics related to how functions are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are actually two different syntaxes that we can use to define a function:'
  prefs: []
  type: TYPE_NORMAL
- en: The first way is a simple one-liner that contains both the signature and body
    of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way uses the `function` keyword with the signature, followed by the
    code block and the `end` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function is simple enough—for example, if it just has a single instruction—then
    it is usually more preferable to write the function in a single line. This style
    of function definition is very common for scientific computing projects, as many
    functions simply mimic the corresponding mathematical formulae.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our game, we can just write four functions for moving the game pieces around
    the board by modifying the coordinates of the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is indeed quite idiomatic in Julia to write single-line functions. People
    coming from a different background may find it more intuitive to write the following,
    more verbose, form. There is nothing wrong with this; both forms work just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to bear in mind about how these functions are written:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use of underscore**: The preceding function names use an underscore to separate
    the words. According to the official Julia manual, the convention is to just smash
    the words together without any separators unless it becomes too confusing or hard
    to read. My personal opinion is that underscore should always be used for multi-word
    function names because it enhances the readability and makes the code more consistent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use of exclamation mark**: The preceding function names contain exclamation
    mark to indicate that the function mutates the state of the object that is being
    passed into the function. This is a good practice because it reminds the developer
    that there will be side effects when calling the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duck typing**:You may wonder why the function arguments are not annotated
    with any type information. In the `move_up!` function, although we do not have
    any type annotation, we expect the `widget` argument to have the `Widget` type and
    `v` to have the `Int` type when the function is used. This is an interesting topic,
    and we will discuss it further in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, defining functions is a fairly straightforward task, and the
    way Julia handles function arguments is quite interesting. We will go over this
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a statically typed language without any polymorphism, such as C or Fortran,
    every argument must be specified with the exact type. Julia, however, is dynamically
    typed and supports duck typing—*if it walks like a duck and quacks like a duck,
    then it is a duck*. Type information is not required in the source code at all.
    Instead, the compiler looks at runtime types that you pass into the function and
    compiles the appropriate method specialized for those types. The process of deducing
    types throughout a method body based on the argument types is called **type inference**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, there is no need to annotate function arguments with type information
    at all. People sometimes get the impression that putting type annotations all
    over their Julia code will improve performance. That is not usually the case.
    For method signatures, types have no effect on performance: they are only useful
    to control dispatch.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what would you choose? Annotate arguments with types or not?
  prefs: []
  type: TYPE_NORMAL
- en: Untyped arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When function arguments are not annotated with type information, the function
    is actually more flexible. Why? That''s because it can work with any type that
    you pass into the function. Let''s say that, in the future, the coordinate system
    is changed from `Int` to `Float64`. When this happens, the function will not need
    to be changed: it just works!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, keeping everything untyped may not be the best idea either because
    the function cannot really work with every possible data type that is defined
    in the world. In addition, it could often lead to obscure exception messages and
    make the program more difficult to debug. For instance, if we were to pass an
    `Int` value as the `Widget` argument to the `move_up!` function by mistake, then
    it will complain about the type not having a `position` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f002970-d5a3-4330-a80f-9b4932e66fc3.png)'
  prefs: []
  type: TYPE_IMG
- en: The error message is quite obscure. Is there anything that we can do to make
    debugging a little easier? The answer is that we could provide the type of function
    arguments. Let's see how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Typed arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that our implementation of the `move` functions comes with some implicit
    design assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `v` should be a numerical value, as implied by the `+` or `-` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `widget` has to be a `Widget` object, or at least something that contains
    a `Position` object, as implied by the access of the `position` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For these reasons, it''s generally safer to define functions with some type
    information. Having said that, the `move_up!` function can be redefined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we just define all `move` functions the same way, then debugging becomes
    easier. Suppose that we make the same mistake as we did in the preceding code
    by passing an integer as the first argument: we will now receive a more sensible
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f2f41a4-84ce-4c4b-bc3a-23ff2bcc9019.png)'
  prefs: []
  type: TYPE_IMG
- en: So instead of trying to run the function and failing miserably with an unknown
    effect, the Julia compiler will now tell us that the method does not exist for
    the argument types that we pass into the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next topic, let''s at least play a little bit of the
    game. In order to display these objects more nicely in the Julia REPL, we can
    define some `show` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These `Base.show` functions provide the implementation that is used when `Position`,
    `Size`, or `Widget` objects need to be shown at the specific I/O device, such
    as the REPL. By defining these functions, we get a much nicer output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `show` function for the `Widget` type prints the name, position,
    and size of the widget. The respective `show` functions for the `Position` and
    `Size` types are going to be called from the `print` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `show` function comes with another form, `show(io, mime, x)`, so that the
    value `x` can be displayed in different formats for different MIME types.
  prefs: []
  type: TYPE_NORMAL
- en: MIME stands for Multipurpose Internet Mail Extensions. It is also called Media
    Type. It is a standard that is used to specify the type of a data stream. For
    example, `text/plain` represents a plain text stream and `text/html` represents
    a text stream that has HTML content.
  prefs: []
  type: TYPE_NORMAL
- en: The default MIME type for a `show` function is `text/plain`, which is essentially
    the type we use in a Julia REPL environment. If we use Julia in a notebook environment,
    such as Jupyter, then we can provide a `show` function that provides additional
    formatting in HTML using the MIME type of `text/html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s give it a test drive. We can move around an asteroid game piece
    by calling various `move` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows. Note that the output of the asteroid widget is formatted
    exactly as how we coded it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/526794fa-c712-4d76-902e-32da1a2ae163.png)'
  prefs: []
  type: TYPE_IMG
- en: Defining functions with typed arguments is generally considered a good practice
    because the function can only work with the specific data types of the arguments.
    Also, from a client usage perspective, you can clearly see what is required by
    the function just by looking at the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it is more beneficial to define a function with untyped arguments.
    The standard `print` function, for instance, has a function signature that looks
    like `print(io::IO, x)`. The intention is that the `print` function is guaranteed
    to work with all possible data types.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, this should be an exception rather than the norm. In most
    situations, it makes more sense to use typed arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to provide default values for the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Working with optional arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we do not want to hardcode any values in a function. The general
    solution is to extract the hardcoded values and work them into function arguments.
    In Julia, we can also provide default values for the arguments. When we have default
    values, then the arguments become optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this concept, let''s write a function that makes a bunch of asteroids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function takes an argument of `N` for the number of asteroids. It also accepts
    a position range, `pos_range`, and `size_range`, for creating randomly sized asteroids
    that are placed randomly on our game map. You may notice that we have also defined
    two single-line functions, `pos_rand` and `sz_rand`, directly inside the body
    of the `make_asteroid` function. These functions only exist within the scope of
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out without specifying any value for `pos_range` or `size_range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/852f06fe-fa4d-4781-b68f-a37eec559383.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But the fact that they are optional also allows us to provide custom values.
    For instance, we can place the asteroids closer to each other by specifying a
    much narrower range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/853a8162-0baa-4421-a20e-7989d36bf73f.png)'
  prefs: []
  type: TYPE_IMG
- en: Where does the magic come from? If you hit the *Tab* key while entering the
    `make_asteroid` function from the REPL, you may notice that the single function
    definition ends up with three methods.
  prefs: []
  type: TYPE_NORMAL
- en: What are functions and methods?
  prefs: []
  type: TYPE_NORMAL
- en: Functions are *generic* in Julia. This means that we can extend the purpose
    of a function by defining various methods that have the same name, but take different
    types of argument.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, every function in Julia may be associated to one or more associated methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, Julia automatically creates these three methods, one for each signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f472c6a9-b180-4283-b218-ecf93c16d941.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to find the methods of a function is to just use the `methods`
    function that comes from the Julia `Base` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3c45f0d-cb27-4043-aa83-b4c4ae445c62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, we can fully specify all arguments as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/845db025-091e-4565-9c9e-62c7c8c39843.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it is quite convenient to provide default values for positional
    arguments. In the case that the default values are generally accepted, the calling
    function becomes simpler because it does not have to specify all arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something feels a little weird here, though—the code is becoming more difficult
    to read: `make_asteroids(5, 100:5:200, 200:10:500)`. What does `5`, `100:5:200`,
    and `200:10:500` mean? These arguments look quite opaque, and the programmer may
    not remember what they mean without looking up the source code or the manual.
    There has to be a better way! Next, we will check how to solve this problem using
    keyword arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing keyword arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A drawback of optional arguments is that they must be in the same order in which
    they are defined. When there are more arguments, it is not easily readable which
    values are bound to which arguments from the call site. In that case, we may use
    keyword arguments to improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s redefine the `make_asteroid` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this function and the one from the previous section
    is just a single character. The positional arguments (in this case, `N`) and keyword
    arguments (`pos_range` and `size_range`) just need to be separated by a `;` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the caller''s perspective, keyword arguments must be passed with the names
    of the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb4455fc-589c-49d9-bef1-b258566c80e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using keyword arguments has made the code a lot more readable! In fact, the
    keyword arguments do not even need to be passed in the same order as they were
    defined in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0316c188-b6b5-4c38-9ce2-e0d610df0b2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another cool feature is that keyword arguments do not have to carry any default
    values. For example, we could define the same function where the first argument
    `N` becomes a mandatory keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we could just call the function with `N` specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cda73710-d1be-4c26-990f-c2a774e677e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Using keyword arguments is a good way to write self-documenting code. Some open
    source packages, such as Plots, make extensive use of keyword arguments. It works
    very well when a function needs many arguments.
  prefs: []
  type: TYPE_NORMAL
- en: While we specify default values for keyword arguments in this example, they
    are not really required. In the case that there is no default value, the keyword
    argument becomes mandatory when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Another cool feature is that we can pass a variable number of arguments to a
    function. We will look into this next.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting variable numbers of arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is more convenient if the function can just accept any number
    of arguments. In this case, we can add three dots `...` to a function argument
    and Julia will automatically roll up all passed arguments into a single variable.
    This feature is known as **slurping**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `shoot` function, we first print the type of the `targets` variable
    and then print every shot that was fired. Let''s set up the game pieces first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start shooting! Let''s first call the `shoot` function by passing
    a single target and then do that again by passing three targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12802734-0bd9-445e-8bdb-274296744e1a.png)'
  prefs: []
  type: TYPE_IMG
- en: It turns out that the arguments are just combined as a tuple and bound to a
    single `targets` variable. In this case, we just iterate the tuple and perform
    an action on each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Slurping is a fantastic way to combine function arguments and handle them all
    together. This makes it possible to call the function with any number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about a similar feature called splatting, which essentially
    performs the opposite function of slurping.
  prefs: []
  type: TYPE_NORMAL
- en: Splatting arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slurping is very useful in its own right, but the triple-dot notation actually
    has a second usage. At the call site, when a variable is followed by three periods,
    the variable will be automatically assigned as multiple function arguments. This
    feature is known as **splatting**. In fact, this mechanism is very similar to
    slurping, except that it is doing the opposite action. We will take a look at
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have written a function to arrange a couple of spaceships
    in a specific formation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also constructed a couple of spaceships ahead of a space war:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ed21f74-7033-4038-b1a6-94b9677020a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now call the `triangular_formation!` function using the splatting technique,
    which involves appending three periods after the function argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53f37537-a8aa-4643-9f84-ff8074117318.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the three elements inside the `spaceships` vector are distributed
    to the three arguments as the `triangular_formation!` function expects.
  prefs: []
  type: TYPE_NORMAL
- en: Splatting can technically work with any collection type—vector and tuple. It
    should work as long as the variable being splatted supports the general iteration
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you may wonder what happens when the number of elements in the
    variable does not equal the number of arguments as defined in the function.
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to check this behavior out as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Splatting is a good way to build up function arguments and then pass them into
    the function directly without having to split them up into separate arguments.
    It is therefore quite convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how functions can be passed around to provide higher-order
    programming facilities.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding first-class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are said to be **first-class** when they can be assigned to variables
    or struct fields, passed into functions, returned from a function, and so on.
    They are treated as first-class citizens just like regular data types. We will
    now take a look at how functions can be passed around like regular data values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s design a new function that can propel a spaceship to leap in a random
    direction for a random distance. You may recall from the beginning of this chapter
    that we have already defined four `move` functions—`move_up!`, `move_down!`, `move_left!`,
    and `move_right!`. Here''s our strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `random_move` function that returns one of the possible `move` functions.
    This provides the basis for choosing a direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `random_leap!` function that moves the spaceship using the specified
    `move` function and leap distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `random_move` function returns a function that is randomly
    chosen from the array of `move` functions. The `random_leap!` function accepts
    a `move` function, `move_func`, as an argument and then it just makes the call
    with the widget and distance. Let''s test the `random_leap!` function now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e128f4d3-99e1-4fc4-b016-86db90f6141e.png)'
  prefs: []
  type: TYPE_IMG
- en: We have successfully called a randomly chosen `move` function. All of this can
    be done easily because we can store functions as if they are regular variables.
    The first-class nature makes it very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about anonymous functions. Anonymous functions are commonly
    used in Julia programs because they are a quick way to make a function and pass
    it around to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Developing anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we just want to create a simple function and pass it around without
    assigning it a name. This style of programming is actually fairly common in functional
    programming languages. We can illustrate its use with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to explode all of the asteroids. One way to do this is
    to define an `explode` function and pass it into the `foreach` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The results look good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abb9cecd-9cb4-4fcc-9436-65ef7aa95761.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can achieve the same effect if we just pass an anonymous function into `foreach`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax of the anonymous function contains the argument variables, followed
    by the thin arrow `->` and the function body. In this case, we only have a single
    argument. If we have more arguments, then we can write them as a tuple that is
    enclosed in parentheses. An anonymous function can also be assigned to a variable
    and passed around. Let''s say we want to explode the spaceships as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there are some advantages for using anonymous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to come up with a function name and pollute the namespace of
    the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The anonymous function logic is available at the call site, so the code is easier
    to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is slightly more compact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now, we have gone over most of the pertinent details regarding how to define
    and use functions. The next topic, do-syntax, is closely related to anonymous
    functions. It is a great way to enhance code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Using do-syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with anonymous functions, we may end up having a code block that
    is in the middle of a function call, making the code more difficult to read. The
    do-syntax is a great way to address this problem and produce clear, easy-to-read
    code.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the concept, let's build up a new use case for our battle fleet.
    In particular, we will enhance our spaceships with the ability to launch missiles.
    We also want to support the requirement that launching a weapon requires that
    the spaceship is in a healthy state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a `fire` function that takes a `launch` function and a spaceship.
    The `launch` function is executed only when the spaceship is healthy. Why do we
    want to take a function as an argument? Because we want to make it flexible so
    that, later on, we can use the same `fire` function to launch laser beams and
    other possible weapons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try this out using an anonymous function to fire the missile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13905790-cf10-42d0-ab3f-975b2177a9fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far so good. But what happens if we need a more complex procedure to fire
    missiles? For example, say that we would like to move the spaceship up before
    firing and move it back down afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax now looks quite ugly. Fortunately, we can rewrite the code using
    the do-syntax and make it more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How does it work? Well, the syntax is translated so that the do-block is turned
    into an anonymous function and it is then just inserted as the first argument
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting usage of the do-syntax can be found in Julia's `open` function.
    Because reading a file involves opening and closing a file handler, the `open`
    function is designed to accept an anonymous function that takes an `IOStream`
    and do something with it, while the opening/closing housekeeping tasks are handled
    by the `open` function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is quite simple, so let''s just replicate it here with our own `process_file`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the do-syntax, we can focus on developing the logic of file processing
    without having to worry about the housekeeping chores, such as opening and closing
    files. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9655030d-b3a1-4997-85cd-c4dda6d5d999.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the do-syntax can be useful in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes the code more readable by rearranging the anonymous function argument
    in a block format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the anonymous functions to be wrapped in a context for which additional
    logic can be executed before or after the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will take a look at multiple dispatch, which is a unique feature that
    is not commonly found in object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Multiple Dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple dispatch is one of the most unique features in the Julia programming
    language. They are used extensively in the Julia Base library, `stdlib`, as well
    as many open source packages. In this section, we will explore how multiple dispatch work
    and how one can utilize them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: What is a dispatch?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dispatch is the process by which a function is selected for execution. You
    may wonder why there is any controversy in selecting which function to execute.
    When we develop a function, we give it a name, some arguments, and a block of
    code that it should execute. If we come up with unique names for all functions
    in a system, then there will be no ambiguity. However, there are often times when
    we want to reuse the same function name and apply it to different data types for
    similar types of operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples are abundant in Julia''s Base library. For example, the `isascii`
    function has three methods, and each one takes a different argument type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the type of the argument, the proper method is dispatched and executed. When
    we call the `isascii` function with a `Char` object, the first method is dispatched.
    Likewise, when we call it with a `String` object, which is a subtype of `AbstractString`,
    then the second method is dispatched. Sometimes, the type of the argument being
    passed to the method is not known until runtime, and in that case, the proper
    method is dispatched right at that moment, depending on the specific value being
    passed. This behavior is called **dynamic dispatch**.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch is a key concept that will come up over and over again. It is important
    that we understand the rules as related to how a function being dispatched. We
    will go over these next.
  prefs: []
  type: TYPE_NORMAL
- en: Matching to the narrowest types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Data Type Concepts*, we can define functions that take abstract
    types as arguments. When it comes to dispatch, Julia will find the method that
    matches the narrowest type in the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this concept, let''s return to our favorite example in this chapter
    regarding spaceships and asteroids! In fact, we will improve our data types as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined an abstract type, `Thing`, which can be anything that
    exists in the universe. When we design this type, we expect its concrete subtypes
    will have the standard `position` and `size` fields. Therefore, we just happily
    define `position` and `size` functions for `Thing`. By default, we do not want
    to assume any shape of anything, so the `shape` function for `Thing` only returns
    an `:unknown` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more interesting, we will equip our spaceships with two types
    of weapon—laser and missiles. In Julia, we can conveniently define them as **enums**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `@enum` macro defines a new type called `Weapon`. The only values
    of the `Weapon` type are `Laser` and `Missile`. Enums are a good way to define
    typed constants. Internally, they define numeric values for each constant, and
    so it should be quite performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can define the `Spaceship` and `Asteroid` concrete types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that both `Spaceship` and `Asteroid` include `position` and `size` fields
    as part of our design contract. In addition, we have a `weapon` field added for
    the `Spaceship` type. Because we have designed our state-of-the-art spaceships
    like saucers, we have defined the `shape` function for the `Spaceship` type as
    well. Let''s test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c159226a-fae3-44ff-95a0-2f13543b2903.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now created two spaceships and two asteroids. Let's turn our focus to
    the results of the preceding `shape` function calls for a moment. When it was
    called with a spaceship object `s1`, it was dispatched to `shape(s::Spaceship)` and
    returned `:saucer`. When it was called with an asteroid object, it was dispatched
    to `shape(t::Thing)` because there are no other matches for the `Asteroid` object.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, Julia's dispatch mechanism always looks for the function with the
    narrowest type in the arguments. Judging between `shape(s::Spaceship)` and `shape(t:Thing)`,
    it will choose to execute `shape(s::Spaceship)` for a `Spaceship` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Are you familiar with multiple dispatch? If not, don't worry. In the next section,
    we will dive deep into how multiple dispatch works in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching with multiple arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only seen dispatch examples for methods that take a single argument.
    We can extend the same concept for multiple arguments, and that's simply called
    multiple dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: So how does it work when multiple arguments are involved? Let's say we continue
    developing our space war game with the ability to detect collisions between different
    objects. To look at this in detail, we'll go through a sample implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define functions that can check whether two rectangles overlap each
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can define a function that returns `true` when two `Thing` objects
    collide. This function can be called for any combination of `Spaceship` and `Asteroid`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is a really naive idea because we know that spaceships and asteroids
    have different shapes, possibly nonrectangular ones. Nonetheless, this is not
    a bad default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a quick test before we go further. Note that I have intentionally
    suppressed the output of the return values only because they''re unimportant for
    our discussion here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e60f1e68-d13c-4a81-ae58-ff7e4e3e9f6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Knowing that the collision-detection logic may be different depending on the
    type of objects, we can further define these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this new method, based upon the narrowest-type selection process, we can
    safely handle spaceship-spaceship collision detection. Let''s prove my claim with
    the same test as the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5489630e-75fb-4f86-b167-bd27cc636009.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks good. If we just continue defining the rest of the functions, then
    everything will be covered and perfect!
  prefs: []
  type: TYPE_NORMAL
- en: Multiple dispatch is indeed a simple concept. Essentially, all function arguments
    are considered when Julia tries to determine which function needs to be dispatched.
    The same rule applies—the narrowest type always wins!
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, sometimes it is unclear which function needs to be dispatched.
    Next, we will look into how this can happen and how the problem can be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Possible ambiguities during dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, we can always define all possible methods with concrete type arguments;
    however, that may not be the most desirable option when designing software. Why?
    It's because the number of combinations in argument types could be overwhelming,
    and it is often unnecessary to enumerate them all. In our game example here, we
    only need to detect collisions between two types—`spaceship` and `asteroid`. So
    we just need to define 2 x 2 = 4 methods; however, imagine what we would do when
    we have 10 types of object. We would then have to define 100 methods!
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of abstract types can save us. Let''s just imagine that we do have
    to support 10 concrete data types. If the other eight data types have similar
    shapes, then we could cut down the number of methods tremendously by accepting
    an abstract type as one of the arguments. How? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These two functions provide the default implementation for detecting collisions
    between an `Asteroid` and any `Thing`. The first method can handle the first argument
    being `Asteroid` and the second argument being any subtype of `Thing`. If we were
    to have 10 concrete types in total, this single method can handle 10 scenarios.
    Likewise, the second method can handle the other 10 scenarios. Let''s just have
    a quick check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fe541ee-d03c-43f6-83ae-a04bb4c6e881.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Great! these two calls are working fine. Let''s finish our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46487813-1879-4ca5-9127-92a6ce27e2dd.png)'
  prefs: []
  type: TYPE_IMG
- en: But wait, what happened when we tried to check the collision between two asteroids?
    Well, the Julia runtime has detected an ambiguity here. When we pass two `Asteroid`
    arguments, it is unclear whether we want to execute `collide(A::Thing, B::Asteroid)`
    or `collide(A::Asteroid, B::Thing)`. Both methods seem to be able to take the
    task, but neither of their signatures is narrower than the other, and so it just
    gave up and throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it actually suggested a fix as part of the error message. A possible
    fix is to define a new method, `collide(::Asteroid, ::Asteroid)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Because it has the narrowest signature, Julia can properly dispatch to this
    new method when two asteroids are passed to the `collide` function. Once this
    method is defined, there will be no more ambiguity. Let''s try again. The result
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dafd456f-9b4c-43c6-b322-4b15f6452855.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when you encounter ambiguity for multiple dispatch, it can be
    resolved easily by creating a function with more specific types in its arguments.
    The Julia runtime will not try to guess what you want to do. As a developer, we
    need to provide clear instructions to the computer.
  prefs: []
  type: TYPE_NORMAL
- en: However, ambiguities may not be obvious from just looking at the code. In order
    to reduce the risk of hitting the problem at runtime, we can proactively detect
    which part of the code may introduce such ambiguities. Fortunately, Julia already
    provides a convenient tool to identify ambiguities. We will take a look at that
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting ambiguities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often difficult to find ambiguous methods until you happen to hit a specific
    use case at runtime. That's not good. I don't know about you, but software engineers
    like me don't like surprises in production!
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Julia provides a function in the `Test` package for detecting
    ambiguities. We can try this out using a similar test. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c0cd4f8-e830-4c24-8350-fa401dd8f6d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have created a small module in the REPL that defines three `foo` methods.
    It''s a classic example of ambiguous methods—if we pass two integer arguments,
    then it is unclear whether the second or the third `foo` method should be executed.
    Now, let''s use the `detect_ambiguities` function and see if it can detect the
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6738a537-9dc2-4bec-b9d1-f74c687318b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is telling us that the `foo(x::Integer, y)` and `foo(x, y::Integer)`
    functions are ambiguous. As we''ve already learned how to fix that problem, we
    can do that and test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b4ed642-482e-4f3d-9783-be086d149712.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In fact, the `detect_ambiguities` function is even more useful when you have
    functions that extend functions from other modules. In this case, you can just
    call the `detect_ambiguities` function with the modules that you want to check
    all together. Here''s how it works when you pass two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e7a4bb3-71fd-4a78-a7dc-2b542ce705cc.png)'
  prefs: []
  type: TYPE_IMG
- en: In this hypothetical example, the `Foo4` module imports the `Foo2.foo` function
    and extends it by adding a new method. The `Foo2` module by itself would be ambiguous,
    but combining both modules resolves the ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: So when should we make use of this great detective function? A good way to do
    this is to add the `detect_ambiguities` test in the module's automated test suite
    so that it is executed in the continuous integration pipeline for every build.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use this ambiguity detection tool, we can use multiple
    dispatch without fear! In the next section, we will go over another aspect of
    dispatch called dynamic dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dynamic dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's dispatch mechanism is unique not only because of its multiple dispatch
    features, but also the way that it treats function arguments dynamically when
    deciding where to dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to randomly pick two objects and check whether they collide.
    We can define the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96f136c4-abed-4f9f-b3ce-9ea8baad0c17.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that different `collide` methods are called depending on the types
    of the arguments that are passed in the `two` variable.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of dynamic behavior can be found as polymorphism in object-oriented
    programming languages. The main difference is that Julia supports multiple dispatch,
    utilizing all arguments for dispatch at runtime. By contrast, in Java, only the
    object being invoked is used for dynamic dispatch. Once the proper class is identified
    for dispatch, the method arguments are then used for static dispatch when there
    are several overloaded methods with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple dispatch is a powerful feature. When combined with custom data types,
    it allows the developer to control which methods are called for different scenarios.
    If you are more interested in multiple dispatch, you can watch a video on YouTube
    with the title *The Unreasonable Effectiveness of Multiple Dispatch*. It is a
    presentation by Stefan Karpinski, recorded at the JuliaCon 2019 conference.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into how function arguments can be parameterized for additional
    flexibility and expressiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging parametric methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's type system and multiple dispatch feature provide a powerful foundation
    for writing extendable code. As it turns out, we can also use parametric types
    in function arguments. We can call these parametric methods. Parametric methods
    provide an interesting way to express what data types may be matched during dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will go over how to utilize parametric methods
    in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Using type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When defining functions, we have an option to annotate each argument with type
    information. The type of an argument can be a regular abstract type, concrete
    type, or a parametric type. Let''s consider this sample function for exploding
    an array of game pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `things` argument is annotated with `AbstractVector{Any}`, which means
    that it can be any `AbstractVector` type that contains any object that is a subtype
    of `Any` (which is really just everything). To make the method parametric, we
    can just rewrite it with a `T` type parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `explode` function can accept any `AbstractVector` with the parameter `T`,
    which can be any subtype of `Any`. So, if we just pass a vector of `Asteroid`
    objects—that is, `Vector{Asteroid}`—it should just work. It also works if we pass
    a vector of symbols—that is, `Vector{Symbol}`. Let''s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31715df8-97e0-4c6b-9c15-6248ae3558bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that `Vector{Asteroid}` is actually a subtype of `AbstractVector{Asteroid}`.
    In general, we can say that `SomeType{T}` is a subtype of `SomeOtherType{T}` whenever `SomeType`
    is a subtype of `SomeOtherType`. But, if we are unsure, it is easy to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/330c1cfc-9dd3-4c90-bfb9-643f02bc930f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perhaps we don''t really want the `explode` function to take a vector of anything.
    Since this function is written for our space war game, we could restrict the function
    to accept a vector of any type that is a subtype of `Thing`. It can be easily
    achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `where` notation is used to further qualify the parameter with superclass
    information. Whenever a type parameter is used in the function signature, we must
    accompany it with a `where` clause for the same parameter(s).
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters in function arguments allow us to specify a class of data types
    that fit within the constraint indicated inside the `where` clause. The preceding `explode`
    function can take a vector containing any subtype of `Thing`. This means that
    the function is generic in the sense that it can be dispatched with an unlimited
    number of types, as long as it satisfies the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore the use of abstract types as an alternative way to specify
    function arguments. At first glance, it looks fairly similar to using parametric
    types; however, there is a slight difference, which we will explain in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing abstract types with type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, we can replace any abstract type with a type parameter in the function
    signature. When we do this, we will end up with a parametric method that has the
    same semantics as the original one.
  prefs: []
  type: TYPE_NORMAL
- en: This is not an unimportant observation. Let's see if we can demonstrate this
    behavior with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we are building a `tow` function so that a spaceship can tow away
    something in the universe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tow` function is currently defined with a concrete `Spaceship` type and
    an abstract `Thing` type argument. If we want to see the methods defined for this
    function, we can use the `methods` function to display what is stored in Julia''s
    method table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3a19533-a7ea-466b-be6e-ebd45dae2e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: The same method signature comes back perfectly, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a parametric method where we use a type parameter for the
    argument `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now defined a new method with a different signature syntax. But is
    it really a different method? Let''s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a55466c-c637-48ef-972e-045238fa7504.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the methods list still only has one entry, which means that
    the new method definition has replaced the original one. It should not be too
    surprising, however. The new method signature, while looking different from the
    one before, does have the same meaning as the original one. Ultimately, the second
    argument `B` still accepts any type that is a subtype of `Thing`.
  prefs: []
  type: TYPE_NORMAL
- en: So, why do we even go through all the trouble to do this? Well, there is no
    reason to turn this method into a parametric one in this case. But go through
    the next section, and you will see why doing this can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing type consistency in using parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most useful features with type parameters is that they can be used
    to enforce type consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to create a new function that groups two `Thing` objects
    together. As we don''t really care about what concrete types are passed, we can
    just write a single function that does the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also run some trivial tests quickly to ensure that all four combinations
    of spaceships and asteroids are working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e19fa57-a73c-4b21-a95e-57a20b65941d.png)'
  prefs: []
  type: TYPE_IMG
- en: You may wonder how we get such a nice output regarding the specific weapons.
    As we have learned previously, we can extend the `show` function from the Base
    package with our types. You can find our implementation of the `show` function
    in the book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all is good, but then we realize that the requirement is slightly different
    from what we thought originally. Rather than grouping any kind of object, the
    function should be able to group the same kinds of objects only—that is, it''s
    okay to group spaceship with spaceship and asteroid with asteroid, but not spaceship
    with asteroid. So what can we do here? An easy solution is to just throw a type
    parameter in the method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we have annotated both arguments with type `T`, and we specify
    that `T` must be a subtype of `Thing`. Because both arguments use the same type,
    we are now instructing the system to dispatch to this method only if both arguments
    have the same type. We can now try the same four test cases as before, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ebaf0c2-8b13-4e9d-9d10-11eba14776d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Effectively, we can now ensure that the method is only dispatched when the arguments
    have the same type. This is one of the few reasons why it is a good idea to use
    type parameters for function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will talk about another reason to use type parameters—extracting type
    information from the method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting type information from the method signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to find out the parameter type within the method body. This
    is actually very easy to do. As it turns out, all parameters are also bound as
    a variable that we can access in the method body itself. The implementation of
    the standard `eltype` function provides a good example for such usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the type parameter `T` is referenced in the body. Let''s how
    it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48f85bfb-e129-4e0a-aff4-d6dbbc4fcf87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first call, because all objects in the array have the `Spaceship` type,
    the `Spaceship` type is returned, and likewise for the second call, where `Asteroid`
    is returned. The third call returns `Thing` because we have a mixed number of
    `Spaceship` and `Asteroid` objects. These types can be further examined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e86caba5-4a62-4734-a4d0-98ecfdadda9f.png)'
  prefs: []
  type: TYPE_IMG
- en: In summary, we can build more flexible functions by using type parameters in
    function definitions. From an expressiveness perspective, each type parameter
    can cover a whole class of data types. We can also use the same type parameter
    in multiple arguments to enforce type consistency. Finally, we can easily extract
    type information directly from the method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and discuss the last topic of this chapter – interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Working with interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to design and work with interfaces in Julia.
    Unlike other mainstream programming languages, Julia does not have a formal way
    to define interfaces. This informality may make some people a little uneasy. Nonetheless,
    interfaces do exist and are used extensively in many Julia programs.
  prefs: []
  type: TYPE_NORMAL
- en: Designing and developing interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are behavioral contracts. A behavior is defined by a set of functions
    that operates on one or more specific objects). In Julia, the contract is purely
    conventional and is not formally specified. To illustrate this concept, let's
    create a module that contains the logic of taking an object anywhere from the
    galaxy.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Vehicle interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We shall first create a module called `Vehicle`. The purpose of this module
    is to implement our space-travel logic. As we want to keep this module generic,
    we will design an interface that any object can implement in order to participate
    in our space-travel program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the module consists of four sections, as indicated by the
    following embedded comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how the code is actually written in the module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section exports a single function called `go!`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The second code segment is merely documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The third code segment contains generic definitions of the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last code segment contains the space-travel logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `travel_path` function calculates the direction and distance to travel from
    the current position to the final destination. It is expected to return a tuple.
    For testing purposes, we are just returning hardcoded values.
  prefs: []
  type: TYPE_NORMAL
- en: The `go!` function expects that the vehicle object being passed in the first
    argument is some kind of space vehicle. Furthermore, the logic also expects the
    vehicle to exhibit certain behavior, such as being able to turn on the engine,
    steer in the right direction, move a certain distance, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a client program wants to call the `go!` function, it must pass a type that
    implements the expected interface as assumed by this logic. But how does one know
    what functions to implement? Well, it is defined as part of the documentation
    as spelled out in the comment from the *Interface Documentation* code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Another clue is that the required functions are defined in the previous code
    as empty generic functions—that is, functions without any signature or body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have written the interface''s contractual requirements as comments
    in the code. It is generally better to do this as Julia doc strings so that the
    requirements can be generated and published to an online website or printed as
    hard copy. We could do something like this for every function specified in the
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `Vehicle` module is now completed, and as part of the source code, we have
    set certain expectations. If any object wants to participate in our space-travel
    program, it must implement the five functions—`power_on!`, `power_off!`, `turn!`,
    `move!`, and `position`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will design a new fighter jet line for the space-travel program!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FighterJet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand what to expect from the `Vehicle` interface, we can
    develop something that actually implements the interface. We will create a new
    `FighterJets` module and define the `FighterJet` data type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To conform to the `Vehicle` interface defined previously, we must first import
    the generic functions from the `Vehicle` module and then implement the logic for
    operating the `FighterJet` vehicle. Here is the code for the `power_on` and `power_off`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, a real fighter jet may be a bit more involved than just setting
    a Boolean field to either `true` or `false`. For testing purposes, we also print
    something to the console so that we know what is happening. Let''s also define
    the function to steer the direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the logic for the `turn!` function here is as simple as changing the
    direction field and printing some text on the console. The `move!` function is
    a little more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used the trigonometric functions `sin` and `cos` to calculate
    the new position that the fighter jet will be traveling to. Finally, we must implement
    the `position` function, which returns the current position of the fighter jet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `FighterJet` type fully implements the interface, we can utilize
    the game logic as expected. Let''s give it a spin by creating a new `FighterJet`
    object and invoke the `go!` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/887ebe5d-a4d8-4b13-8cd7-104eb4c2f2d6.png)'
  prefs: []
  type: TYPE_IMG
- en: In a nutshell, implementing an interface is a fairly simple task. The key is
    to understand what functions are required to implement an interface and make sure
    that the custom data type can support those functions. As a professional developer,
    we should clearly document the interface functions so that there is no confusion
    about what needs to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can consider the interface that we just designed as **hard
    contracts**. They are hard in the sense that all of the functions specified in
    our interface must be implemented by any object participating in our space-travel
    program. In the next section, we will go over **soft contracts**, which correspond
    to interface functions that may be optional.
  prefs: []
  type: TYPE_NORMAL
- en: Handling soft contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, certain interface contracts are not absolutely required when a default
    behavior can be assumed by the interface. The functions that are not mandatory
    may be referred to as soft contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want to add a new function for landing a vehicle. Most vehicles
    have wheels, but some don't, especially high-tech ones! So, as part of the landing
    procedure, we must engage the wheels only when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we design a soft contract for an interface? In this case, we can assume
    that most future vehicles have no wheels and therefore the default behavior does
    not require engaging the wheels. Here, in the `Vehicle` module, we can add the
    `engage_wheel!` function to document and provide a default implementation, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The documentation clearly states that the `engage_wheels!` function is optional.
    Because of this, rather than providing an empty generic function, we have implemented
    an actual `engage_wheel!` function that does absolutely nothing and just returns
    a value of `nothing`. The landing logic is then written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the caller provides a vehicle type that implements the `engage_wheels!`
    function, then it will be used; otherwise, the call to `engage_wheels!` would
    invoke the generic function and do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will leave it to the reader to complete this exercise by creating another
    vehicle type that implements the `engage_wheel!` function. (Sorry: the vehicle
    you develop is probably not very *high-tech* since it has wheels.)'
  prefs: []
  type: TYPE_NORMAL
- en: A soft contract is a simple way to provide a default implementation for optional
    interface functions. Next, we will look into a slightly more formal method to
    declare whether a data type supports certain interface elements. We will call
    them *traits*.
  prefs: []
  type: TYPE_NORMAL
- en: Using interface traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, you may encounter a situation where you need to determine whether
    a data type implements an interface. The information about whether a data type
    exhibits certain behavior is also called a trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we implement traits for an interface? In the `Vehicle` module, we can
    add a new function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This default implementation simply raises an error, and that''s intentional.
    This trait function is expected to be implemented by any vehicle data types. In
    the interface code, the landing function can make use of the trait function for
    a more refined logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, trait functions just need to return a binary answer, `true`
    or `false`; however, it is entirely up to the developer how to design the trait.
    For example, it is perfectly reasonable to define the trait function so that it
    returns the type of landing gear—`:wheels`, `:slider`, or `:none`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good idea to define traits as simply as possible. As you may recall,
    the interface that we implemented for our fighter jet in the previous section
    requires five functions—`power_on!`, `power_off!`, `move!`, `turn!`, and `position`.
    From a design perspective, we can create different traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`has_power()`: returns `true` if the vehicle needs to be powered on/off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_move()`: returns `true` if the vehicle is able to move'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_turn()`: returns `true` if the vehicle can turn in any direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location_aware()`: returns `true` if the vehicle can keep track of its location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have these small building blocks, we can define more complex traits
    that are composed of these simple ones. For example, we can define a trait called
    `smart_vehicle` that supports all of the four traits that we listed. In addition,
    we can define a `solar_vehicle` trait, which is used for vehicles that rely on
    solar power and is always on.
  prefs: []
  type: TYPE_NORMAL
- en: Using traits is a very powerful technique to model object behaviors. There are
    some patterns that are built around how to implement traits in practice. We will
    discuss these more extensively in [Chapter 5](962e7c27-570f-498e-89b9-d9075c58cd45.xhtml),
    *Reusability Patterns.*
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should feel more comfortable about designing interfaces in
    Julia. They are relatively simple to understand and develop. While Julia does
    not provide any formal syntax for interface specification, it is not difficult
    to come up with our own convention. With the help of traits, we can even implement
    more dynamic behavior for our objects.
  prefs: []
  type: TYPE_NORMAL
- en: We have now concluded all topics in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our journey by discussing how to define functions
    and make use of various types of function arguments, such as positional arguments,
    keyword arguments, and variable arguments. We talked about how to use splatting
    to auto assign the elements of an array or tuple to function arguments. We explored
    first-class functions by assigning them to variables and passing them around in
    functional calls. We learned how to create anonymous functions and use the do-syntax
    to make code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed Julia's dispatch mechanism and introduced the concept of multiple
    dispatch. We realized that ambiguity may exist and so we reviewed the standard
    tools for detecting ambiguities. We have learned how dispatch is dynamic in nature.
    We looked at  parametric methods and how they could be useful in several use cases,
    such as enforcing type consistency and extracting type information from the type
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to design interfaces. We realized that there is no formal language
    syntax for defining interfaces in Julia, but we also recognize defining interfaces
    is straightforward and easy to do. We came to know that sometimes it is acceptable
    to have soft contracts so that the developer does not have to implement all interface
    functions. Finally, we wrapped up the discussion with the concept of traits and
    how they can be useful for querying whether a data type implements a specific
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss two more major features in the Julia language—macros
    and meta programming. Macros are very useful in creating new syntax that makes
    the code clean and easy to maintain. Just take a deep breath and keep going!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are positional arguments different from keyword arguments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between splatting and slurping?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of using the do-syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tool is available for detecting method ambiguities as related to multiple
    dispatch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you ensure that the same concrete type is passed to a function in a parametric
    method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are interfaces implemented without any formal language syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you implement traits, and how are traits useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
