- en: Designing Functions and Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计函数和接口
- en: This chapter will continue looking at the fundamental concepts of Julia. The
    topics that we have chosen here will provide a solid foundation of the key concepts
    of Julia programming. In particular, we will discuss the core Julia programming techniques
    that are related to functions and interfaces. Functions are the fundamental building
    blocks of software. Interfaces are contractual relationships between different
    components of the software. Effective use of functions and interfaces is a must
    for building robust applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续探讨 Julia 的基本概念。我们在这里选择的主题将为 Julia 编程的关键概念提供一个坚实的基础。特别是，我们将讨论与函数和接口相关的核心
    Julia 编程技术。函数是软件的基本构建块。接口是软件不同组件之间的契约关系。有效地使用函数和接口对于构建健壮的应用程序是必不可少的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Multiple dispatch
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重分派
- en: Parametric methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化方法
- en: Interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: As part of the learning process, we will go over a use case of game design.
    More specifically, we will pretend that we are building a space war game that
    contains a game board with spaceships and asteroid pieces. We will build functions
    that move the game pieces around and equip the spaceships with weapons to blow
    things up.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为学习过程的一部分，我们将回顾一个游戏设计的用例。更具体地说，我们将假装我们正在构建一个包含太空战游戏板、飞船和陨石部件的游戏。我们将构建移动游戏部件的函数，并为飞船配备武器以摧毁物体。
- en: By the end of this chapter, you will have the necessary knowledge to design
    and develop functions effectively. Through the use of multiple dispatch and parametric
    methods, your application will become more extendable. Once you have learned these
    techniques, you should also be able to design a system that contains pluggable
    components based on interfaces.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备设计和开发函数所需的知识。通过使用多重分派和参数化方法，你的应用程序将变得更加可扩展。一旦你学会了这些技术，你也应该能够设计一个包含可插拔组件的系统，基于接口。
- en: I can't wait any longer. Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经迫不及待了。让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter03).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源代码位于 [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter03)。
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 Julia 1.3.0 环境中进行了测试。
- en: Designing functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计函数
- en: Function is a core construct in Julia for defining the behaviors of an application.
    In fact, Julia works more like a procedural/functional programming language as
    opposed to an object-oriented programming language. In object-oriented programming,
    you focus on building classes and defining functions for those classes. In Julia,
    you focus on building functions that operate on data types or data structures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 Julia 定义应用程序行为的核心结构。实际上，与面向对象编程语言相比，Julia 更像是一种过程式/函数式编程语言。在面向对象编程中，你专注于构建类并为这些类定义函数。在
    Julia 中，你专注于构建在数据类型或数据结构上操作的功能。
- en: In this section, we will demonstrate how functions are defined and the powerful
    features that come with functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何定义函数以及函数带来的强大功能。
- en: Our use case – a space war game
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的用例 - 太空战游戏
- en: Throughout this chapter, we will illustrate programming concepts by building
    parts of a space war game. The design of the game is very simple and straightforward.
    It consists of game pieces such as spaceships and asteroids that are scattered
    around a two-dimensional grid. These game pieces are called widgets in our program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过构建太空战游戏的部分来阐述编程概念。游戏的设计非常简单直接。它由散布在二维网格上的游戏部件（如飞船和陨石）组成。在我们的程序中，这些游戏部件被称为小部件。
- en: 'Let''s first define our data types as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义以下数据类型：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As data types are central to our design, this warrants a little more explanation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据类型是我们设计的关键，这需要更多的解释：
- en: The `Position` type is used to store the coordinates of a game piece. It is
    represented by two integers: `x` and `y`.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Position` 类型用于存储游戏部件的坐标。它由两个整数表示：`x` 和 `y`。'
- en: The `Size` type is used to store the size of a game piece. It is represented by
    two integers: `width` and `height`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size` 类型用于存储游戏部件的大小。它由两个整数表示：`width` 和 `height`。'
- en: The `Widget` type is used to hold a single game piece. It is represented by
    a `name`, `position`, and `size`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Widget` 类型用于存储单个游戏部件。它由一个 `name`、`position` 和 `size` 表示。'
- en: Note that the `Position` type is mutable because we expect our game pieces to
    move around by just updating their coordinates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Position` 类型是可变的，因为我们期望我们的游戏部件通过更新它们的坐标来移动。
- en: Next, we will go over a number of topics related to how functions are defined.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论与函数定义相关的一些主题。
- en: Defining functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'There are actually two different syntaxes that we can use to define a function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以使用两种不同的语法来定义函数：
- en: The first way is a simple one-liner that contains both the signature and body
    of the function.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是一个简单的单行代码，其中包含函数的签名和主体。
- en: The second way uses the `function` keyword with the signature, followed by the
    code block and the `end` keyword.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法使用 `function` 关键字和签名，然后是代码块和 `end` 关键字。
- en: If the function is simple enough—for example, if it just has a single instruction—then
    it is usually more preferable to write the function in a single line. This style
    of function definition is very common for scientific computing projects, as many
    functions simply mimic the corresponding mathematical formulae.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数足够简单——例如，如果它只有一条指令——那么通常更倾向于将其写在一行中。这种函数定义风格在科学计算项目中非常常见，因为许多函数只是模仿相应的数学公式。
- en: 'For our game, we can just write four functions for moving the game pieces around
    the board by modifying the coordinates of the widget:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们可以简单地编写四个函数来在棋盘上移动游戏部件，通过修改部件的坐标：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is indeed quite idiomatic in Julia to write single-line functions. People
    coming from a different background may find it more intuitive to write the following,
    more verbose, form. There is nothing wrong with this; both forms work just fine:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中编写单行函数确实非常地道。来自不同背景的人可能会觉得以下更冗长的形式更直观。这并没有什么问题；这两种形式都运行得很好：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are a few things to bear in mind about how these functions are written:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这些函数时，有几个要点需要注意：
- en: '**Use of underscore**: The preceding function names use an underscore to separate
    the words. According to the official Julia manual, the convention is to just smash
    the words together without any separators unless it becomes too confusing or hard
    to read. My personal opinion is that underscore should always be used for multi-word
    function names because it enhances the readability and makes the code more consistent.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下划线使用**：前面的函数名使用下划线来分隔单词。根据官方 Julia 手册，惯例是直接将单词组合在一起，除非变得过于混乱或难以阅读。我个人认为，对于多词函数名，应该始终使用下划线，因为它增强了可读性，并使代码更加一致。'
- en: '**Use of exclamation mark**: The preceding function names contain exclamation
    mark to indicate that the function mutates the state of the object that is being
    passed into the function. This is a good practice because it reminds the developer
    that there will be side effects when calling the function.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**感叹号使用**：前面的函数名包含感叹号，以表示该函数会改变传入函数的对象的状态。这是一个好习惯，因为它提醒开发者调用函数时会有副作用。'
- en: '**Duck typing**:You may wonder why the function arguments are not annotated
    with any type information. In the `move_up!` function, although we do not have
    any type annotation, we expect the `widget` argument to have the `Widget` type and
    `v` to have the `Int` type when the function is used. This is an interesting topic,
    and we will discuss it further in the next section.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鸭子类型**：你可能想知道为什么函数参数没有标注任何类型信息。在 `move_up!` 函数中，尽管我们没有类型注解，但我们期望当函数被使用时，`widget`
    参数具有 `Widget` 类型，而 `v` 具有整数 `Int` 类型。这是一个有趣的话题，我们将在下一节中进一步讨论。'
- en: As you can see, defining functions is a fairly straightforward task, and the
    way Julia handles function arguments is quite interesting. We will go over this
    next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，定义函数是一项相当直接的任务，Julia 处理函数参数的方式非常有趣。我们将在下一节中讨论这一点。
- en: Annotating function arguments
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数注解
- en: In a statically typed language without any polymorphism, such as C or Fortran,
    every argument must be specified with the exact type. Julia, however, is dynamically
    typed and supports duck typing—*if it walks like a duck and quacks like a duck,
    then it is a duck*. Type information is not required in the source code at all.
    Instead, the compiler looks at runtime types that you pass into the function and
    compiles the appropriate method specialized for those types. The process of deducing
    types throughout a method body based on the argument types is called **type inference**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何多态性的静态类型语言中，例如C或Fortran，每个参数都必须使用确切的类型进行指定。然而，Julia是动态类型，并支持鸭子类型——*如果它像鸭子走路，像鸭子叫，那么它就是一只鸭子*。源代码中根本不需要类型信息。相反，编译器会查看传递给函数的运行时类型，并为这些类型编译适当的方法。根据参数类型在整个方法体中进行类型推断的过程称为**类型推断**。
- en: 'Therefore, there is no need to annotate function arguments with type information
    at all. People sometimes get the impression that putting type annotations all
    over their Julia code will improve performance. That is not usually the case.
    For method signatures, types have no effect on performance: they are only useful
    to control dispatch.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根本不需要用类型信息注解函数参数。有时人们会有这样的印象，在他们所有的Julia代码中添加类型注解会提高性能。这通常不是情况。对于方法签名，类型对性能没有影响：它们仅用于控制调度。
- en: So, what would you choose? Annotate arguments with types or not?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你会选择什么？给参数添加类型注解还是不添加？
- en: Untyped arguments
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无类型参数
- en: 'When function arguments are not annotated with type information, the function
    is actually more flexible. Why? That''s because it can work with any type that
    you pass into the function. Let''s say that, in the future, the coordinate system
    is changed from `Int` to `Float64`. When this happens, the function will not need
    to be changed: it just works!'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数参数没有使用类型信息进行注解时，函数实际上更加灵活。为什么？那是因为它可以与传递给函数的任何类型一起工作。让我们假设，在未来，坐标系从`Int`变为`Float64`。当这种情况发生时，函数不需要进行任何更改：它只需正常工作！
- en: 'In contrast, keeping everything untyped may not be the best idea either because
    the function cannot really work with every possible data type that is defined
    in the world. In addition, it could often lead to obscure exception messages and
    make the program more difficult to debug. For instance, if we were to pass an
    `Int` value as the `Widget` argument to the `move_up!` function by mistake, then
    it will complain about the type not having a `position` field:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，保持所有内容无类型可能也不是最好的主意，因为函数实际上不能与世界上定义的任何可能的数据类型一起工作。此外，它经常会导致晦涩的异常信息，并使程序更难调试。例如，如果我们不小心将`Int`值作为`Widget`参数传递给`move_up!`函数，那么它将抱怨类型没有`position`字段：
- en: '![](img/2f002970-d5a3-4330-a80f-9b4932e66fc3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f002970-d5a3-4330-a80f-9b4932e66fc3.png)'
- en: The error message is quite obscure. Is there anything that we can do to make
    debugging a little easier? The answer is that we could provide the type of function
    arguments. Let's see how this can be done.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息相当晦涩。我们是否可以做一些事情来使调试稍微容易一些？答案是，我们可以提供函数参数的类型。让我们看看这是如何实现的。
- en: Typed arguments
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带类型参数
- en: 'We know that our implementation of the `move` functions comes with some implicit
    design assumptions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的`move`函数实现包含一些隐式的设计假设：
- en: The value of `v` should be a numerical value, as implied by the `+` or `-` operator.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v`的值应该是一个数值，正如`+`或`-`运算符所暗示的。'
- en: The `widget` has to be a `Widget` object, or at least something that contains
    a `Position` object, as implied by the access of the `position` field.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widget`必须是一个`Widget`对象，或者至少包含一个`Position`对象，正如访问`position`字段所暗示的。'
- en: 'For these reasons, it''s generally safer to define functions with some type
    information. Having said that, the `move_up!` function can be redefined as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常更安全的是定义具有一些类型信息的函数。话虽如此，`move_up!`函数可以被重新定义为以下内容：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we just define all `move` functions the same way, then debugging becomes
    easier. Suppose that we make the same mistake as we did in the preceding code
    by passing an integer as the first argument: we will now receive a more sensible
    error message:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是以相同的方式定义所有的`move`函数，那么调试就会变得更容易。假设我们像前面代码中那样犯了一个错误，即把一个整数作为第一个参数传递：我们现在将收到一个更合理的错误信息：
- en: '![](img/7f2f41a4-84ce-4c4b-bc3a-23ff2bcc9019.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f2f41a4-84ce-4c4b-bc3a-23ff2bcc9019.png)'
- en: So instead of trying to run the function and failing miserably with an unknown
    effect, the Julia compiler will now tell us that the method does not exist for
    the argument types that we pass into the function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是试图运行函数并因未知效果而失败，Julia 编译器现在会告诉我们，对于我们传递给函数的参数类型，不存在该方法。
- en: 'Before we move on to the next topic, let''s at least play a little bit of the
    game. In order to display these objects more nicely in the Julia REPL, we can
    define some `show` functions, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，至少让我们玩一小会儿这个游戏。为了在 Julia REPL 中更优雅地显示这些对象，我们可以定义一些 `show` 函数，如下所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These `Base.show` functions provide the implementation that is used when `Position`,
    `Size`, or `Widget` objects need to be shown at the specific I/O device, such
    as the REPL. By defining these functions, we get a much nicer output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `Base.show` 函数提供了当 `Position`、`Size` 或 `Widget` 对象需要在特定的 I/O 设备（如 REPL）上显示时的实现。通过定义这些函数，我们得到了一个更优雅的输出。
- en: Note that the `show` function for the `Widget` type prints the name, position,
    and size of the widget. The respective `show` functions for the `Position` and
    `Size` types are going to be called from the `print` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Widget` 类型的 `show` 函数会打印出小部件的名称、位置和大小。`Position` 和 `Size` 类型的相应 `show` 函数将由
    `print` 函数调用。
- en: The `show` function comes with another form, `show(io, mime, x)`, so that the
    value `x` can be displayed in different formats for different MIME types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` 函数还有一个形式，即 `show(io, mime, x)`，这样 `x` 值就可以以不同的格式显示不同的 MIME 类型。'
- en: MIME stands for Multipurpose Internet Mail Extensions. It is also called Media
    Type. It is a standard that is used to specify the type of a data stream. For
    example, `text/plain` represents a plain text stream and `text/html` represents
    a text stream that has HTML content.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: MIME 代表多用途互联网邮件扩展。它也被称为媒体类型。这是一个用于指定数据流类型的标准。例如，`text/plain` 代表纯文本流，而 `text/html`
    代表包含 HTML 内容的文本流。
- en: The default MIME type for a `show` function is `text/plain`, which is essentially
    the type we use in a Julia REPL environment. If we use Julia in a notebook environment,
    such as Jupyter, then we can provide a `show` function that provides additional
    formatting in HTML using the MIME type of `text/html`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` 函数的默认 MIME 类型是 `text/plain`，这本质上是我们用于 Julia REPL 环境的类型。如果我们使用 Julia
    在笔记本环境中，例如 Jupyter，那么我们可以提供一个 `show` 函数，该函数使用 `text/html` MIME 类型提供额外的 HTML 格式化。'
- en: 'Finally, let''s give it a test drive. We can move around an asteroid game piece
    by calling various `move` functions, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来试驾一下。我们可以通过调用各种 `move` 函数来移动小行星游戏部件，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result is as follows. Note that the output of the asteroid widget is formatted
    exactly as how we coded it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下。请注意，小行星小部件的输出格式与我们编码的完全一致：
- en: '![](img/526794fa-c712-4d76-902e-32da1a2ae163.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/526794fa-c712-4d76-902e-32da1a2ae163.png)'
- en: Defining functions with typed arguments is generally considered a good practice
    because the function can only work with the specific data types of the arguments.
    Also, from a client usage perspective, you can clearly see what is required by
    the function just by looking at the function definition.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型参数定义函数通常被认为是一种良好的实践，因为函数只能与参数的具体数据类型一起工作。此外，从客户端使用角度来看，你只需查看函数定义就可以清楚地看到函数需要什么。
- en: Sometimes it is more beneficial to define a function with untyped arguments.
    The standard `print` function, for instance, has a function signature that looks
    like `print(io::IO, x)`. The intention is that the `print` function is guaranteed
    to work with all possible data types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时定义一个具有无类型参数的函数更有益。例如，标准的 `print` 函数有一个看起来像 `print(io::IO, x)` 的函数签名。其意图是 `print`
    函数保证能够与所有可能的数据类型一起工作。
- en: Generally speaking, this should be an exception rather than the norm. In most
    situations, it makes more sense to use typed arguments.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，这应该是一个例外而不是常态。在大多数情况下，使用类型参数更有意义。
- en: Next, we will discuss how to provide default values for the arguments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何为参数提供默认值。
- en: Working with optional arguments
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理可选参数
- en: Sometimes, we do not want to hardcode any values in a function. The general
    solution is to extract the hardcoded values and work them into function arguments.
    In Julia, we can also provide default values for the arguments. When we have default
    values, then the arguments become optional.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不想在函数中硬编码任何值。一般的解决方案是提取硬编码的值并将它们整合到函数参数中。在 Julia 中，我们还可以为参数提供默认值。当我们有默认值时，参数就变成了可选的。
- en: 'To illustrate this concept, let''s write a function that makes a bunch of asteroids:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，让我们编写一个创建一系列小行星的函数：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function takes an argument of `N` for the number of asteroids. It also accepts
    a position range, `pos_range`, and `size_range`, for creating randomly sized asteroids
    that are placed randomly on our game map. You may notice that we have also defined
    two single-line functions, `pos_rand` and `sz_rand`, directly inside the body
    of the `make_asteroid` function. These functions only exist within the scope of
    the function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个名为`N`的参数，表示小行星的数量。它还接受位置范围`pos_range`和大小范围`size_range`，用于创建随机大小的小行星，这些小行星随机放置在我们的游戏地图上。您可能会注意到，我们还在`make_asteroid`函数体内直接定义了两个单行函数`pos_rand`和`sz_rand`。这些函数仅存在于函数的作用域内。
- en: 'Let''s try this out without specifying any value for `pos_range` or `size_range`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试不指定`pos_range`或`size_range`的任何值：
- en: '![](img/852f06fe-fa4d-4781-b68f-a37eec559383.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/852f06fe-fa4d-4781-b68f-a37eec559383.png)'
- en: 'But the fact that they are optional also allows us to provide custom values.
    For instance, we can place the asteroids closer to each other by specifying a
    much narrower range:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们是可选的，这也允许我们提供自定义值。例如，我们可以通过指定一个更窄的范围来使小行星彼此更近：
- en: '![](img/853a8162-0baa-4421-a20e-7989d36bf73f.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/853a8162-0baa-4421-a20e-7989d36bf73f.png)'
- en: Where does the magic come from? If you hit the *Tab* key while entering the
    `make_asteroid` function from the REPL, you may notice that the single function
    definition ends up with three methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法从何而来？如果您在REPL中输入`make_asteroid`函数时按下*Tab*键，您可能会注意到单个函数定义最终有三个方法。
- en: What are functions and methods?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法是什么？
- en: Functions are *generic* in Julia. This means that we can extend the purpose
    of a function by defining various methods that have the same name, but take different
    types of argument.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在Julia中是*通用的*。这意味着我们可以通过定义具有相同名称但接受不同类型参数的各种方法来扩展函数的目的。
- en: Hence, every function in Julia may be associated to one or more associated methods.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Julia中的每个函数都可以关联到一个或多个相关方法。
- en: 'Internally, Julia automatically creates these three methods, one for each signature:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，Julia自动为每个签名创建这三个方法：
- en: '![](img/f472c6a9-b180-4283-b218-ecf93c16d941.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f472c6a9-b180-4283-b218-ecf93c16d941.png)'
- en: 'Another way to find the methods of a function is to just use the `methods`
    function that comes from the Julia `Base` package:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种找到函数方法的方式是使用来自Julia `Base`包的`methods`函数：
- en: '![](img/f3c45f0d-cb27-4043-aa83-b4c4ae445c62.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3c45f0d-cb27-4043-aa83-b4c4ae445c62.png)'
- en: 'Of course, we can fully specify all arguments as such:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以完全指定所有参数，如下所示：
- en: '![](img/845db025-091e-4565-9c9e-62c7c8c39843.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/845db025-091e-4565-9c9e-62c7c8c39843.png)'
- en: As you can see, it is quite convenient to provide default values for positional
    arguments. In the case that the default values are generally accepted, the calling
    function becomes simpler because it does not have to specify all arguments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为位置参数提供默认值非常方便。如果默认值通常被接受，调用函数会变得更简单，因为它不需要指定所有参数。
- en: 'Something feels a little weird here, though—the code is becoming more difficult
    to read: `make_asteroids(5, 100:5:200, 200:10:500)`. What does `5`, `100:5:200`,
    and `200:10:500` mean? These arguments look quite opaque, and the programmer may
    not remember what they mean without looking up the source code or the manual.
    There has to be a better way! Next, we will check how to solve this problem using
    keyword arguments.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里感觉有点奇怪——代码变得越来越难以阅读：`make_asteroids(5, 100:5:200, 200:10:500)`。`5`、`100:5:200`和`200:10:500`代表什么？这些参数看起来相当晦涩，程序员可能需要查看源代码或手册才能记住它们的含义。必须有一种更好的方法！接下来，我们将检查如何使用关键字参数解决这个问题。
- en: Utilizing keyword arguments
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关键字参数
- en: A drawback of optional arguments is that they must be in the same order in which
    they are defined. When there are more arguments, it is not easily readable which
    values are bound to which arguments from the call site. In that case, we may use
    keyword arguments to improve readability.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数的缺点是它们必须按照定义的顺序排列。当有更多参数时，从调用点绑定到哪个参数的值并不容易阅读。在这种情况下，我们可以使用关键字参数来提高可读性。
- en: 'Let''s redefine the `make_asteroid` function as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式重新定义`make_asteroid`函数：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only difference between this function and the one from the previous section
    is just a single character. The positional arguments (in this case, `N`) and keyword
    arguments (`pos_range` and `size_range`) just need to be separated by a `;` character.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与上一节中的函数之间的唯一区别只是一个字符。位置参数（在这种情况下，`N`）和关键字参数（`pos_range`和`size_range`）只需要用分号（`;`）字符分隔。
- en: 'From the caller''s perspective, keyword arguments must be passed with the names
    of the arguments:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用者的角度来看，关键字参数必须按照参数的名称传递：
- en: '![](img/cb4455fc-589c-49d9-bef1-b258566c80e8.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb4455fc-589c-49d9-bef1-b258566c80e8.png)'
- en: 'Using keyword arguments has made the code a lot more readable! In fact, the
    keyword arguments do not even need to be passed in the same order as they were
    defined in the function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字参数使代码的阅读性大大提高！实际上，关键字参数甚至不需要按照它们在函数中定义的顺序传递：
- en: '![](img/0316c188-b6b5-4c38-9ce2-e0d610df0b2e.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0316c188-b6b5-4c38-9ce2-e0d610df0b2e.png)'
- en: 'Another cool feature is that keyword arguments do not have to carry any default
    values. For example, we could define the same function where the first argument
    `N` becomes a mandatory keyword argument:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个酷炫的功能是关键字参数不需要携带任何默认值。例如，我们可以定义一个相同的函数，其中第一个参数`N`成为一个强制关键字参数：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, we could just call the function with `N` specified:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们只需指定`N`来调用函数：
- en: '![](img/cda73710-d1be-4c26-990f-c2a774e677e8.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cda73710-d1be-4c26-990f-c2a774e677e8.png)'
- en: Using keyword arguments is a good way to write self-documenting code. Some open
    source packages, such as Plots, make extensive use of keyword arguments. It works
    very well when a function needs many arguments.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字参数是编写自文档代码的好方法。一些开源包，如Plots，广泛使用关键字参数。当函数需要许多参数时，它工作得非常好。
- en: While we specify default values for keyword arguments in this example, they
    are not really required. In the case that there is no default value, the keyword
    argument becomes mandatory when the function is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个例子中我们为关键字参数指定了默认值，但它们实际上并不是必需的。在没有默认值的情况下，当函数被调用时，关键字参数变为强制性的。
- en: Another cool feature is that we can pass a variable number of arguments to a
    function. We will look into this next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个酷炫的功能是我们可以向函数传递任意数量的参数。我们将在下一节中探讨这一点。
- en: Accepting variable numbers of arguments
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受可变数量的参数
- en: Sometimes, it is more convenient if the function can just accept any number
    of arguments. In this case, we can add three dots `...` to a function argument
    and Julia will automatically roll up all passed arguments into a single variable.
    This feature is known as **slurping**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果函数可以接受任意数量的参数会更方便。在这种情况下，我们可以在函数参数中添加三个点`...`，Julia会自动将所有传递的参数滚成一个单一的变量。这个功能被称为**吸入**。
- en: 'Here is an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `shoot` function, we first print the type of the `targets` variable
    and then print every shot that was fired. Let''s set up the game pieces first:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shoot`函数中，我们首先打印`targets`变量的类型，然后打印每发射击。让我们首先设置游戏元素：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can start shooting! Let''s first call the `shoot` function by passing
    a single target and then do that again by passing three targets:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始射击了！首先通过传递一个目标来调用`shoot`函数，然后再次通过传递三个目标来执行：
- en: '![](img/12802734-0bd9-445e-8bdb-274296744e1a.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12802734-0bd9-445e-8bdb-274296744e1a.png)'
- en: It turns out that the arguments are just combined as a tuple and bound to a
    single `targets` variable. In this case, we just iterate the tuple and perform
    an action on each of them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，参数被简单地组合成一个元组，并绑定到一个单一的`targets`变量。在这种情况下，我们只是迭代这个元组并对它们中的每一个执行操作。
- en: Slurping is a fantastic way to combine function arguments and handle them all
    together. This makes it possible to call the function with any number of arguments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 吸入是一种将函数参数组合在一起并统一处理它们的绝佳方式。这使得可以以任意数量的参数调用函数。
- en: Next, we will learn about a similar feature called splatting, which essentially
    performs the opposite function of slurping.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解一个类似的功能，称为展开（splatting），它本质上执行的是吸入（slurping）的相反功能。
- en: Splatting arguments
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开参数
- en: Slurping is very useful in its own right, but the triple-dot notation actually
    has a second usage. At the call site, when a variable is followed by three periods,
    the variable will be automatically assigned as multiple function arguments. This
    feature is known as **splatting**. In fact, this mechanism is very similar to
    slurping, except that it is doing the opposite action. We will take a look at
    an example.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Slurping 本身非常有用，但三点的表示法实际上还有第二个用途。在调用点，当一个变量后面跟着三个点时，该变量将被自动分配为多个函数参数。这个特性被称为**展开**。实际上，这个机制与
    slurping 非常相似，只是它执行的是相反的操作。我们将通过一个例子来看看。
- en: 'Let''s say that we have written a function to arrange a couple of spaceships
    in a specific formation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经编写了一个函数来安排几艘太空船在特定的队形中：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have also constructed a couple of spaceships ahead of a space war:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在太空战之前构建了几艘太空船：
- en: '![](img/0ed21f74-7033-4038-b1a6-94b9677020a9.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ed21f74-7033-4038-b1a6-94b9677020a9.png)'
- en: 'We can now call the `triangular_formation!` function using the splatting technique,
    which involves appending three periods after the function argument:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用展开技术调用 `triangular_formation!` 函数，这涉及到在函数参数后附加三个点：
- en: '![](img/53f37537-a8aa-4643-9f84-ff8074117318.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53f37537-a8aa-4643-9f84-ff8074117318.png)'
- en: In this case, the three elements inside the `spaceships` vector are distributed
    to the three arguments as the `triangular_formation!` function expects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`spaceships` 向量中的三个元素被分配到三个参数中，正如 `triangular_formation!` 函数所期望的那样。
- en: Splatting can technically work with any collection type—vector and tuple. It
    should work as long as the variable being splatted supports the general iteration
    interface.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Splatting 可以在技术上与任何集合类型一起工作——向量（vector）和元组（tuple）。只要被展开的变量支持通用迭代接口，它就应该可以工作。
- en: In addition, you may wonder what happens when the number of elements in the
    variable does not equal the number of arguments as defined in the function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能想知道当变量中的元素数量与函数中定义的参数数量不相等时会发生什么。
- en: You are encouraged to check this behavior out as an exercise.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你将这种行为作为练习进行检查。
- en: Splatting is a good way to build up function arguments and then pass them into
    the function directly without having to split them up into separate arguments.
    It is therefore quite convenient.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 展开是构建函数参数并直接将它们传递给函数的好方法，而无需将它们拆分成单独的参数。因此，它非常方便。
- en: Next, we will discuss how functions can be passed around to provide higher-order
    programming facilities.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何传递函数以提供高级编程功能。
- en: Understanding first-class functions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解一等函数
- en: Functions are said to be **first-class** when they can be assigned to variables
    or struct fields, passed into functions, returned from a function, and so on.
    They are treated as first-class citizens just like regular data types. We will
    now take a look at how functions can be passed around like regular data values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数可以被分配给变量或结构体字段、传递给函数、从函数返回等时，我们称其为**一等函数**。它们被当作一等公民对待，就像常规数据类型一样。我们现在将看看函数如何像常规数据值一样被传递。
- en: 'Let''s design a new function that can propel a spaceship to leap in a random
    direction for a random distance. You may recall from the beginning of this chapter
    that we have already defined four `move` functions—`move_up!`, `move_down!`, `move_left!`,
    and `move_right!`. Here''s our strategy:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个新的函数，该函数可以使太空船向随机方向跳跃随机距离。你可能还记得，在本章的开头我们已经定义了四个 `move` 函数——`move_up!`、`move_down!`、`move_left!`
    和 `move_right!`。以下是我们的策略：
- en: Create a `random_move` function that returns one of the possible `move` functions.
    This provides the basis for choosing a direction.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `random_move` 函数，该函数返回可能的 `move` 函数之一。这为选择方向提供了基础。
- en: Create a `random_leap!` function that moves the spaceship using the specified
    `move` function and leap distance.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `random_leap!` 函数，该函数使用指定的 `move` 函数和跳跃距离来移动太空船。
- en: 'The code is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, the `random_move` function returns a function that is randomly
    chosen from the array of `move` functions. The `random_leap!` function accepts
    a `move` function, `move_func`, as an argument and then it just makes the call
    with the widget and distance. Let''s test the `random_leap!` function now:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`random_move` 函数返回一个函数，该函数是从 `move` 函数数组中随机选择的。`random_leap!` 函数接受一个 `move`
    函数，`move_func`，作为参数，然后它只是用小部件和距离进行调用。现在让我们测试 `random_leap!` 函数：
- en: '![](img/e128f4d3-99e1-4fc4-b016-86db90f6141e.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e128f4d3-99e1-4fc4-b016-86db90f6141e.png)'
- en: We have successfully called a randomly chosen `move` function. All of this can
    be done easily because we can store functions as if they are regular variables.
    The first-class nature makes it very convenient.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功调用了随机选择的`move`函数。所有这些都可以轻松完成，因为我们可以将函数存储得就像它们是常规变量一样。一等性质使其非常方便。
- en: Next, we will learn about anonymous functions. Anonymous functions are commonly
    used in Julia programs because they are a quick way to make a function and pass
    it around to other functions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习匿名函数。匿名函数在Julia程序中很常见，因为它们是快速创建函数并将其传递给其他函数的好方法。
- en: Developing anonymous functions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发匿名函数
- en: Sometimes, we just want to create a simple function and pass it around without
    assigning it a name. This style of programming is actually fairly common in functional
    programming languages. We can illustrate its use with an example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们只想创建一个简单的函数，并在不为其指定名称的情况下传递它。这种编程风格在函数式编程语言中实际上相当常见。我们可以用一个例子来说明它的用法。
- en: 'Suppose that we want to explode all of the asteroids. One way to do this is
    to define an `explode` function and pass it into the `foreach` function as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要引爆所有的小行星。一种方法是为它定义一个`explode`函数，并将其作为参数传递给`foreach`函数，如下所示：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The results look good:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来不错：
- en: '![](img/abb9cecd-9cb4-4fcc-9436-65ef7aa95761.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abb9cecd-9cb4-4fcc-9436-65ef7aa95761.png)'
- en: 'We can achieve the same effect if we just pass an anonymous function into `foreach`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是将匿名函数传递给`foreach`，我们也可以达到相同的效果：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The syntax of the anonymous function contains the argument variables, followed
    by the thin arrow `->` and the function body. In this case, we only have a single
    argument. If we have more arguments, then we can write them as a tuple that is
    enclosed in parentheses. An anonymous function can also be assigned to a variable
    and passed around. Let''s say we want to explode the spaceships as well:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数的语法包括参数变量，后面跟着细箭头`->`和函数体。在这种情况下，我们只有一个参数。如果我们有更多的参数，我们可以将它们写成括号内的元组。匿名函数也可以被分配给变量并传递。假设我们还想引爆宇宙飞船：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can see that there are some advantages for using anonymous functions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，使用匿名函数有一些优点：
- en: There is no need to come up with a function name and pollute the namespace of
    the module.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要想出一个函数名并污染模块的命名空间。
- en: The anonymous function logic is available at the call site, so the code is easier
    to read.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数的逻辑在调用位置可用，这使得代码更容易阅读。
- en: The code is slightly more compact.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码稍微紧凑一些。
- en: By now, we have gone over most of the pertinent details regarding how to define
    and use functions. The next topic, do-syntax, is closely related to anonymous
    functions. It is a great way to enhance code readability.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何定义和使用函数的大部分相关细节。下一个主题，do-语法，与匿名函数密切相关。这是一种提高代码可读性的好方法。
- en: Using do-syntax
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用do-语法
- en: When working with anonymous functions, we may end up having a code block that
    is in the middle of a function call, making the code more difficult to read. The
    do-syntax is a great way to address this problem and produce clear, easy-to-read
    code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当与匿名函数一起工作时，我们可能会得到一个位于函数调用中间的代码块，这使得代码更难阅读。do-语法是解决这个问题的好方法，可以产生清晰、易于阅读的代码。
- en: To illustrate the concept, let's build up a new use case for our battle fleet.
    In particular, we will enhance our spaceships with the ability to launch missiles.
    We also want to support the requirement that launching a weapon requires that
    the spaceship is in a healthy state.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，让我们为我们的战斗舰队构建一个新的用例。特别是，我们将增强我们的宇宙飞船以发射导弹的能力。我们还希望支持这样的要求：发射武器需要宇宙飞船处于健康状态。
- en: 'We can define a `fire` function that takes a `launch` function and a spaceship.
    The `launch` function is executed only when the spaceship is healthy. Why do we
    want to take a function as an argument? Because we want to make it flexible so
    that, later on, we can use the same `fire` function to launch laser beams and
    other possible weapons:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个`fire`函数，它接受一个`launch`函数和一个宇宙飞船。只有当宇宙飞船处于健康状态时，`launch`函数才会被执行。我们为什么想要将函数作为参数传递？因为我们想要使其灵活，以便以后可以使用相同的`fire`函数来发射激光束和其他可能的武器：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s try this out using an anonymous function to fire the missile:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用匿名函数来发射导弹：
- en: '![](img/13905790-cf10-42d0-ab3f-975b2177a9fc.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13905790-cf10-42d0-ab3f-975b2177a9fc.png)'
- en: 'So far so good. But what happens if we need a more complex procedure to fire
    missiles? For example, say that we would like to move the spaceship up before
    firing and move it back down afterward:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。但如果我们需要更复杂的程序来发射导弹怎么办？例如，假设我们希望在发射前将宇宙飞船向上移动，发射后再将其降回原位：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The syntax now looks quite ugly. Fortunately, we can rewrite the code using
    the do-syntax and make it more readable:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的语法看起来相当丑陋。幸运的是，我们可以使用 do 语法重写代码，使其更易读：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How does it work? Well, the syntax is translated so that the do-block is turned
    into an anonymous function and it is then just inserted as the first argument
    of the function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？好吧，语法被转换，使得 do 块变成了一个匿名函数，然后它被作为函数的第一个参数插入。
- en: An interesting usage of the do-syntax can be found in Julia's `open` function.
    Because reading a file involves opening and closing a file handler, the `open`
    function is designed to accept an anonymous function that takes an `IOStream`
    and do something with it, while the opening/closing housekeeping tasks are handled
    by the `open` function itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的 `open` 函数中可以找到一个有趣的 do 语法的用法。因为读取文件涉及到打开和关闭文件句柄，所以 `open` 函数被设计成接受一个接受
    `IOStream` 并对其执行某些操作的匿名函数，而打开/关闭的维护工作则由 `open` 函数本身处理。
- en: 'The idea is quite simple, so let''s just replicate it here with our own `process_file`
    function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单，所以让我们用我们自己的 `process_file` 函数来复制它：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the do-syntax, we can focus on developing the logic of file processing
    without having to worry about the housekeeping chores, such as opening and closing
    files. Consider the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 do 语法，我们可以专注于开发文件处理的逻辑，而无需担心诸如打开和关闭文件等维护工作。考虑以下代码：
- en: '![](img/9655030d-b3a1-4997-85cd-c4dda6d5d999.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9655030d-b3a1-4997-85cd-c4dda6d5d999.png)'
- en: 'As you can see, the do-syntax can be useful in two ways:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，do 语法可以在两种方式下发挥作用：
- en: It makes the code more readable by rearranging the anonymous function argument
    in a block format.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过将匿名函数参数重新排列成块格式，使代码更易读。
- en: It allows the anonymous functions to be wrapped in a context for which additional
    logic can be executed before or after the function.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许匿名函数被包裹在一个上下文中，可以在函数执行前后执行额外的逻辑。
- en: Next, we will take a look at multiple dispatch, which is a unique feature that
    is not commonly found in object-oriented languages.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨多重分派，这是在面向对象语言中不常见的一种独特特性。
- en: Understanding Multiple Dispatch
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多重分派
- en: Multiple dispatch is one of the most unique features in the Julia programming
    language. They are used extensively in the Julia Base library, `stdlib`, as well
    as many open source packages. In this section, we will explore how multiple dispatch work
    and how one can utilize them effectively.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 多重分派是 Julia 编程语言中最独特的特性之一。它们在 Julia Base 库、`stdlib` 以及许多开源包中被广泛使用。在本节中，我们将探讨多重分派是如何工作的，以及如何有效地利用它们。
- en: What is a dispatch?
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是分派？
- en: A dispatch is the process by which a function is selected for execution. You
    may wonder why there is any controversy in selecting which function to execute.
    When we develop a function, we give it a name, some arguments, and a block of
    code that it should execute. If we come up with unique names for all functions
    in a system, then there will be no ambiguity. However, there are often times when
    we want to reuse the same function name and apply it to different data types for
    similar types of operation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 分派是选择执行函数的过程。你可能想知道为什么在执行哪个函数上会有争议。当我们开发一个函数时，我们给它一个名字，一些参数，以及它应该执行的代码块。如果我们为系统中的所有函数想出独特的名字，那么就不会有歧义。然而，很多时候我们想要重用相同的函数名，并将其应用于不同数据类型的类似操作。
- en: 'Examples are abundant in Julia''s Base library. For example, the `isascii`
    function has three methods, and each one takes a different argument type:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的 Base 库中有许多例子。例如，`isascii` 函数有三个方法，每个方法都接受不同的参数类型：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Depending on the type of the argument, the proper method is dispatched and executed. When
    we call the `isascii` function with a `Char` object, the first method is dispatched.
    Likewise, when we call it with a `String` object, which is a subtype of `AbstractString`,
    then the second method is dispatched. Sometimes, the type of the argument being
    passed to the method is not known until runtime, and in that case, the proper
    method is dispatched right at that moment, depending on the specific value being
    passed. This behavior is called **dynamic dispatch**.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch is a key concept that will come up over and over again. It is important
    that we understand the rules as related to how a function being dispatched. We
    will go over these next.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Matching to the narrowest types
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Data Type Concepts*, we can define functions that take abstract
    types as arguments. When it comes to dispatch, Julia will find the method that
    matches the narrowest type in the arguments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this concept, let''s return to our favorite example in this chapter
    regarding spaceships and asteroids! In fact, we will improve our data types as
    follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have defined an abstract type, `Thing`, which can be anything that
    exists in the universe. When we design this type, we expect its concrete subtypes
    will have the standard `position` and `size` fields. Therefore, we just happily
    define `position` and `size` functions for `Thing`. By default, we do not want
    to assume any shape of anything, so the `shape` function for `Thing` only returns
    an `:unknown` symbol.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more interesting, we will equip our spaceships with two types
    of weapon—laser and missiles. In Julia, we can conveniently define them as **enums**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the `@enum` macro defines a new type called `Weapon`. The only values
    of the `Weapon` type are `Laser` and `Missile`. Enums are a good way to define
    typed constants. Internally, they define numeric values for each constant, and
    so it should be quite performant.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can define the `Spaceship` and `Asteroid` concrete types as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that both `Spaceship` and `Asteroid` include `position` and `size` fields
    as part of our design contract. In addition, we have a `weapon` field added for
    the `Spaceship` type. Because we have designed our state-of-the-art spaceships
    like saucers, we have defined the `shape` function for the `Spaceship` type as
    well. Let''s test it out:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c159226a-fae3-44ff-95a0-2f13543b2903.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: We have now created two spaceships and two asteroids. Let's turn our focus to
    the results of the preceding `shape` function calls for a moment. When it was
    called with a spaceship object `s1`, it was dispatched to `shape(s::Spaceship)` and
    returned `:saucer`. When it was called with an asteroid object, it was dispatched
    to `shape(t::Thing)` because there are no other matches for the `Asteroid` object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: To recap, Julia's dispatch mechanism always looks for the function with the
    narrowest type in the arguments. Judging between `shape(s::Spaceship)` and `shape(t:Thing)`,
    it will choose to execute `shape(s::Spaceship)` for a `Spaceship` argument.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Julia的分发机制始终寻找参数中最窄类型的函数。在`shape(s::Spaceship)`和`shape(t:Thing)`之间进行判断时，它将选择为`Spaceship`参数执行`shape(s::Spaceship)`。
- en: Are you familiar with multiple dispatch? If not, don't worry. In the next section,
    we will dive deep into how multiple dispatch works in Julia.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉多重分发吗？如果不熟悉，不要担心。在下一节中，我们将深入探讨多重分发在Julia中的工作原理。
- en: Dispatching with multiple arguments
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有多个参数的分发
- en: So far, we have only seen dispatch examples for methods that take a single argument.
    We can extend the same concept for multiple arguments, and that's simply called
    multiple dispatch.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了接受单个参数的方法的分发示例。我们可以将相同的概念扩展到多个参数，这简单地称为多重分发。
- en: So how does it work when multiple arguments are involved? Let's say we continue
    developing our space war game with the ability to detect collisions between different
    objects. To look at this in detail, we'll go through a sample implementation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及多个参数时，它是如何工作的呢？让我们假设我们继续开发我们的太空战游戏，使其能够检测不同对象之间的碰撞。为了详细查看这一点，我们将通过一个示例实现来探讨。
- en: 'First, define functions that can check whether two rectangles overlap each
    other:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义可以检查两个矩形是否重叠的函数：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can define a function that returns `true` when two `Thing` objects
    collide. This function can be called for any combination of `Spaceship` and `Asteroid`
    objects:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个函数，当两个`Thing`对象发生碰撞时返回`true`。这个函数可以为任何组合的`Spaceship`和`Asteroid`对象调用：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Of course, this is a really naive idea because we know that spaceships and asteroids
    have different shapes, possibly nonrectangular ones. Nonetheless, this is not
    a bad default implementation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个非常天真的想法，因为我们知道飞船和陨石有不同的形状，可能是非矩形的。尽管如此，这并不是一个坏的选择性实现。
- en: 'Let''s run a quick test before we go further. Note that I have intentionally
    suppressed the output of the return values only because they''re unimportant for
    our discussion here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们先进行一个快速测试。请注意，我故意抑制了返回值的输出，因为它们对我们这里的讨论并不重要：
- en: '![](img/e60f1e68-d13c-4a81-ae58-ff7e4e3e9f6a.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e60f1e68-d13c-4a81-ae58-ff7e4e3e9f6a.png)'
- en: 'Knowing that the collision-detection logic may be different depending on the
    type of objects, we can further define these methods:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 知道碰撞检测逻辑可能根据对象类型的不同而不同，我们可以进一步定义这些方法：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this new method, based upon the narrowest-type selection process, we can
    safely handle spaceship-spaceship collision detection. Let''s prove my claim with
    the same test as the preceding code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，基于最窄类型的选择过程，我们可以安全地处理飞船-飞船的碰撞检测。让我们用与前面代码相同的测试来证明我的说法：
- en: '![](img/5489630e-75fb-4f86-b167-bd27cc636009.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5489630e-75fb-4f86-b167-bd27cc636009.png)'
- en: It looks good. If we just continue defining the rest of the functions, then
    everything will be covered and perfect!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。如果我们继续定义其余的函数，那么一切都将被涵盖，并且完美无缺！
- en: Multiple dispatch is indeed a simple concept. Essentially, all function arguments
    are considered when Julia tries to determine which function needs to be dispatched.
    The same rule applies—the narrowest type always wins!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 多重分发确实是一个简单的概念。本质上，当Julia试图确定需要分发哪个函数时，会考虑所有函数参数。同样的规则适用——最窄类型总是获胜！
- en: Unfortunately, sometimes it is unclear which function needs to be dispatched.
    Next, we will look into how this can happen and how the problem can be resolved.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有时不清楚需要分发哪个函数。接下来，我们将探讨这种情况是如何发生的以及如何解决这个问题。
- en: Possible ambiguities during dispatch
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发过程中的可能歧义
- en: Of course, we can always define all possible methods with concrete type arguments;
    however, that may not be the most desirable option when designing software. Why?
    It's because the number of combinations in argument types could be overwhelming,
    and it is often unnecessary to enumerate them all. In our game example here, we
    only need to detect collisions between two types—`spaceship` and `asteroid`. So
    we just need to define 2 x 2 = 4 methods; however, imagine what we would do when
    we have 10 types of object. We would then have to define 100 methods!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以始终定义所有可能的方法，使用具体的类型参数；然而，在设计软件时，这可能不是最理想的选择。为什么？因为它在参数类型中的组合数量可能非常庞大，而且通常没有必要列举所有这些类型。在我们的游戏示例中，我们只需要检测两种类型——`spaceship`和`asteroid`之间的碰撞。所以我们只需要定义2
    x 2 = 4种方法；然而，想象一下当我们有10种对象类型时我们会做什么。我们那时将不得不定义100种方法！
- en: 'The idea of abstract types can save us. Let''s just imagine that we do have
    to support 10 concrete data types. If the other eight data types have similar
    shapes, then we could cut down the number of methods tremendously by accepting
    an abstract type as one of the arguments. How? Let''s take a look:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These two functions provide the default implementation for detecting collisions
    between an `Asteroid` and any `Thing`. The first method can handle the first argument
    being `Asteroid` and the second argument being any subtype of `Thing`. If we were
    to have 10 concrete types in total, this single method can handle 10 scenarios.
    Likewise, the second method can handle the other 10 scenarios. Let''s just have
    a quick check:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fe541ee-d03c-43f6-83ae-a04bb4c6e881.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'Great! these two calls are working fine. Let''s finish our test:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46487813-1879-4ca5-9127-92a6ce27e2dd.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: But wait, what happened when we tried to check the collision between two asteroids?
    Well, the Julia runtime has detected an ambiguity here. When we pass two `Asteroid`
    arguments, it is unclear whether we want to execute `collide(A::Thing, B::Asteroid)`
    or `collide(A::Asteroid, B::Thing)`. Both methods seem to be able to take the
    task, but neither of their signatures is narrower than the other, and so it just
    gave up and throws an error.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it actually suggested a fix as part of the error message. A possible
    fix is to define a new method, `collide(::Asteroid, ::Asteroid)`, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Because it has the narrowest signature, Julia can properly dispatch to this
    new method when two asteroids are passed to the `collide` function. Once this
    method is defined, there will be no more ambiguity. Let''s try again. The result
    is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dafd456f-9b4c-43c6-b322-4b15f6452855.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: As you can see, when you encounter ambiguity for multiple dispatch, it can be
    resolved easily by creating a function with more specific types in its arguments.
    The Julia runtime will not try to guess what you want to do. As a developer, we
    need to provide clear instructions to the computer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: However, ambiguities may not be obvious from just looking at the code. In order
    to reduce the risk of hitting the problem at runtime, we can proactively detect
    which part of the code may introduce such ambiguities. Fortunately, Julia already
    provides a convenient tool to identify ambiguities. We will take a look at that
    in the next section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Detecting ambiguities
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often difficult to find ambiguous methods until you happen to hit a specific
    use case at runtime. That's not good. I don't know about you, but software engineers
    like me don't like surprises in production!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Julia provides a function in the `Test` package for detecting
    ambiguities. We can try this out using a similar test. Consider the following
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c0cd4f8-e830-4c24-8350-fa401dd8f6d5.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'We have created a small module in the REPL that defines three `foo` methods.
    It''s a classic example of ambiguous methods—if we pass two integer arguments,
    then it is unclear whether the second or the third `foo` method should be executed.
    Now, let''s use the `detect_ambiguities` function and see if it can detect the
    problem:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6738a537-9dc2-4bec-b9d1-f74c687318b3.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'The result is telling us that the `foo(x::Integer, y)` and `foo(x, y::Integer)`
    functions are ambiguous. As we''ve already learned how to fix that problem, we
    can do that and test again:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b4ed642-482e-4f3d-9783-be086d149712.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'In fact, the `detect_ambiguities` function is even more useful when you have
    functions that extend functions from other modules. In this case, you can just
    call the `detect_ambiguities` function with the modules that you want to check
    all together. Here''s how it works when you pass two modules:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e7a4bb3-71fd-4a78-a7dc-2b542ce705cc.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: In this hypothetical example, the `Foo4` module imports the `Foo2.foo` function
    and extends it by adding a new method. The `Foo2` module by itself would be ambiguous,
    but combining both modules resolves the ambiguity.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: So when should we make use of this great detective function? A good way to do
    this is to add the `detect_ambiguities` test in the module's automated test suite
    so that it is executed in the continuous integration pipeline for every build.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use this ambiguity detection tool, we can use multiple
    dispatch without fear! In the next section, we will go over another aspect of
    dispatch called dynamic dispatch.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dynamic dispatch
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's dispatch mechanism is unique not only because of its multiple dispatch
    features, but also the way that it treats function arguments dynamically when
    deciding where to dispatch.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to randomly pick two objects and check whether they collide.
    We can define the function as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s run it and see what happens:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96f136c4-abed-4f9f-b3ce-9ea8baad0c17.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: We can see that different `collide` methods are called depending on the types
    of the arguments that are passed in the `two` variable.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: This kind of dynamic behavior can be found as polymorphism in object-oriented
    programming languages. The main difference is that Julia supports multiple dispatch,
    utilizing all arguments for dispatch at runtime. By contrast, in Java, only the
    object being invoked is used for dynamic dispatch. Once the proper class is identified
    for dispatch, the method arguments are then used for static dispatch when there
    are several overloaded methods with the same name.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Multiple dispatch is a powerful feature. When combined with custom data types,
    it allows the developer to control which methods are called for different scenarios.
    If you are more interested in multiple dispatch, you can watch a video on YouTube
    with the title *The Unreasonable Effectiveness of Multiple Dispatch*. It is a
    presentation by Stefan Karpinski, recorded at the JuliaCon 2019 conference.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into how function arguments can be parameterized for additional
    flexibility and expressiveness.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging parametric methods
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's type system and multiple dispatch feature provide a powerful foundation
    for writing extendable code. As it turns out, we can also use parametric types
    in function arguments. We can call these parametric methods. Parametric methods
    provide an interesting way to express what data types may be matched during dispatch.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will go over how to utilize parametric methods
    in our game.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Using type parameters
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When defining functions, we have an option to annotate each argument with type
    information. The type of an argument can be a regular abstract type, concrete
    type, or a parametric type. Let''s consider this sample function for exploding
    an array of game pieces:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `things` argument is annotated with `AbstractVector{Any}`, which means
    that it can be any `AbstractVector` type that contains any object that is a subtype
    of `Any` (which is really just everything). To make the method parametric, we
    can just rewrite it with a `T` type parameter as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, the `explode` function can accept any `AbstractVector` with the parameter `T`,
    which can be any subtype of `Any`. So, if we just pass a vector of `Asteroid`
    objects—that is, `Vector{Asteroid}`—it should just work. It also works if we pass
    a vector of symbols—that is, `Vector{Symbol}`. Let''s give it a try:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31715df8-97e0-4c6b-9c15-6248ae3558bd.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: 'Note that `Vector{Asteroid}` is actually a subtype of `AbstractVector{Asteroid}`.
    In general, we can say that `SomeType{T}` is a subtype of `SomeOtherType{T}` whenever `SomeType`
    is a subtype of `SomeOtherType`. But, if we are unsure, it is easy to check:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/330c1cfc-9dd3-4c90-bfb9-643f02bc930f.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: 'Perhaps we don''t really want the `explode` function to take a vector of anything.
    Since this function is written for our space war game, we could restrict the function
    to accept a vector of any type that is a subtype of `Thing`. It can be easily
    achieved as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `where` notation is used to further qualify the parameter with superclass
    information. Whenever a type parameter is used in the function signature, we must
    accompany it with a `where` clause for the same parameter(s).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters in function arguments allow us to specify a class of data types
    that fit within the constraint indicated inside the `where` clause. The preceding `explode`
    function can take a vector containing any subtype of `Thing`. This means that
    the function is generic in the sense that it can be dispatched with an unlimited
    number of types, as long as it satisfies the constraint.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore the use of abstract types as an alternative way to specify
    function arguments. At first glance, it looks fairly similar to using parametric
    types; however, there is a slight difference, which we will explain in the next
    section.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Replacing abstract types with type parameters
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, we can replace any abstract type with a type parameter in the function
    signature. When we do this, we will end up with a parametric method that has the
    same semantics as the original one.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: This is not an unimportant observation. Let's see if we can demonstrate this
    behavior with an example.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we are building a `tow` function so that a spaceship can tow away
    something in the universe, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `tow` function is currently defined with a concrete `Spaceship` type and
    an abstract `Thing` type argument. If we want to see the methods defined for this
    function, we can use the `methods` function to display what is stored in Julia''s
    method table:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3a19533-a7ea-466b-be6e-ebd45dae2e4d.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: The same method signature comes back perfectly, as expected.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a parametric method where we use a type parameter for the
    argument `B`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have now defined a new method with a different signature syntax. But is
    it really a different method? Let''s check:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a55466c-c637-48ef-972e-045238fa7504.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: We can see that the methods list still only has one entry, which means that
    the new method definition has replaced the original one. It should not be too
    surprising, however. The new method signature, while looking different from the
    one before, does have the same meaning as the original one. Ultimately, the second
    argument `B` still accepts any type that is a subtype of `Thing`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: So, why do we even go through all the trouble to do this? Well, there is no
    reason to turn this method into a parametric one in this case. But go through
    the next section, and you will see why doing this can be useful.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing type consistency in using parameters
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most useful features with type parameters is that they can be used
    to enforce type consistency.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to create a new function that groups two `Thing` objects
    together. As we don''t really care about what concrete types are passed, we can
    just write a single function that does the work:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also run some trivial tests quickly to ensure that all four combinations
    of spaceships and asteroids are working:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e19fa57-a73c-4b21-a95e-57a20b65941d.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: You may wonder how we get such a nice output regarding the specific weapons.
    As we have learned previously, we can extend the `show` function from the Base
    package with our types. You can find our implementation of the `show` function
    in the book's GitHub repository.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all is good, but then we realize that the requirement is slightly different
    from what we thought originally. Rather than grouping any kind of object, the
    function should be able to group the same kinds of objects only—that is, it''s
    okay to group spaceship with spaceship and asteroid with asteroid, but not spaceship
    with asteroid. So what can we do here? An easy solution is to just throw a type
    parameter in the method signature:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this function, we have annotated both arguments with type `T`, and we specify
    that `T` must be a subtype of `Thing`. Because both arguments use the same type,
    we are now instructing the system to dispatch to this method only if both arguments
    have the same type. We can now try the same four test cases as before, as shown
    in the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ebaf0c2-8b13-4e9d-9d10-11eba14776d4.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Effectively, we can now ensure that the method is only dispatched when the arguments
    have the same type. This is one of the few reasons why it is a good idea to use
    type parameters for function arguments.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will talk about another reason to use type parameters—extracting type
    information from the method signature.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Extracting type information from the method signature
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to find out the parameter type within the method body. This
    is actually very easy to do. As it turns out, all parameters are also bound as
    a variable that we can access in the method body itself. The implementation of
    the standard `eltype` function provides a good example for such usage:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can see that the type parameter `T` is referenced in the body. Let''s how
    it works:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48f85bfb-e129-4e0a-aff4-d6dbbc4fcf87.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: 'In the first call, because all objects in the array have the `Spaceship` type,
    the `Spaceship` type is returned, and likewise for the second call, where `Asteroid`
    is returned. The third call returns `Thing` because we have a mixed number of
    `Spaceship` and `Asteroid` objects. These types can be further examined as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e86caba5-4a62-4734-a4d0-98ecfdadda9f.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: In summary, we can build more flexible functions by using type parameters in
    function definitions. From an expressiveness perspective, each type parameter
    can cover a whole class of data types. We can also use the same type parameter
    in multiple arguments to enforce type consistency. Finally, we can easily extract
    type information directly from the method signature.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and discuss the last topic of this chapter – interfaces.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Working with interfaces
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to design and work with interfaces in Julia.
    Unlike other mainstream programming languages, Julia does not have a formal way
    to define interfaces. This informality may make some people a little uneasy. Nonetheless,
    interfaces do exist and are used extensively in many Julia programs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Designing and developing interfaces
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are behavioral contracts. A behavior is defined by a set of functions
    that operates on one or more specific objects). In Julia, the contract is purely
    conventional and is not formally specified. To illustrate this concept, let's
    create a module that contains the logic of taking an object anywhere from the
    galaxy.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Vehicle interface
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We shall first create a module called `Vehicle`. The purpose of this module
    is to implement our space-travel logic. As we want to keep this module generic,
    we will design an interface that any object can implement in order to participate
    in our space-travel program.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the module consists of four sections, as indicated by the
    following embedded comments:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see how the code is actually written in the module:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section exports a single function called `go!`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second code segment is merely documentation:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The third code segment contains generic definitions of the functions:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the last code segment contains the space-travel logic:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `travel_path` function calculates the direction and distance to travel from
    the current position to the final destination. It is expected to return a tuple.
    For testing purposes, we are just returning hardcoded values.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The `go!` function expects that the vehicle object being passed in the first
    argument is some kind of space vehicle. Furthermore, the logic also expects the
    vehicle to exhibit certain behavior, such as being able to turn on the engine,
    steer in the right direction, move a certain distance, and so on.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'If a client program wants to call the `go!` function, it must pass a type that
    implements the expected interface as assumed by this logic. But how does one know
    what functions to implement? Well, it is defined as part of the documentation
    as spelled out in the comment from the *Interface Documentation* code segment:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another clue is that the required functions are defined in the previous code
    as empty generic functions—that is, functions without any signature or body:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So far, we have written the interface''s contractual requirements as comments
    in the code. It is generally better to do this as Julia doc strings so that the
    requirements can be generated and published to an online website or printed as
    hard copy. We could do something like this for every function specified in the
    interface:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `Vehicle` module is now completed, and as part of the source code, we have
    set certain expectations. If any object wants to participate in our space-travel
    program, it must implement the five functions—`power_on!`, `power_off!`, `turn!`,
    `move!`, and `position`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will design a new fighter jet line for the space-travel program!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FighterJet
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand what to expect from the `Vehicle` interface, we can
    develop something that actually implements the interface. We will create a new
    `FighterJets` module and define the `FighterJet` data type as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To conform to the `Vehicle` interface defined previously, we must first import
    the generic functions from the `Vehicle` module and then implement the logic for
    operating the `FighterJet` vehicle. Here is the code for the `power_on` and `power_off`
    functions:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Of course, a real fighter jet may be a bit more involved than just setting
    a Boolean field to either `true` or `false`. For testing purposes, we also print
    something to the console so that we know what is happening. Let''s also define
    the function to steer the direction:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Again, the logic for the `turn!` function here is as simple as changing the
    direction field and printing some text on the console. The `move!` function is
    a little more interesting:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we have used the trigonometric functions `sin` and `cos` to calculate
    the new position that the fighter jet will be traveling to. Finally, we must implement
    the `position` function, which returns the current position of the fighter jet:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that the `FighterJet` type fully implements the interface, we can utilize
    the game logic as expected. Let''s give it a spin by creating a new `FighterJet`
    object and invoke the `go!` function as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/887ebe5d-a4d8-4b13-8cd7-104eb4c2f2d6.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: In a nutshell, implementing an interface is a fairly simple task. The key is
    to understand what functions are required to implement an interface and make sure
    that the custom data type can support those functions. As a professional developer,
    we should clearly document the interface functions so that there is no confusion
    about what needs to be implemented.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can consider the interface that we just designed as **hard
    contracts**. They are hard in the sense that all of the functions specified in
    our interface must be implemented by any object participating in our space-travel
    program. In the next section, we will go over **soft contracts**, which correspond
    to interface functions that may be optional.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Handling soft contracts
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, certain interface contracts are not absolutely required when a default
    behavior can be assumed by the interface. The functions that are not mandatory
    may be referred to as soft contracts.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want to add a new function for landing a vehicle. Most vehicles
    have wheels, but some don't, especially high-tech ones! So, as part of the landing
    procedure, we must engage the wheels only when necessary.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we design a soft contract for an interface? In this case, we can assume
    that most future vehicles have no wheels and therefore the default behavior does
    not require engaging the wheels. Here, in the `Vehicle` module, we can add the
    `engage_wheel!` function to document and provide a default implementation, as
    follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The documentation clearly states that the `engage_wheels!` function is optional.
    Because of this, rather than providing an empty generic function, we have implemented
    an actual `engage_wheel!` function that does absolutely nothing and just returns
    a value of `nothing`. The landing logic is then written as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, if the caller provides a vehicle type that implements the `engage_wheels!`
    function, then it will be used; otherwise, the call to `engage_wheels!` would
    invoke the generic function and do nothing.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'I will leave it to the reader to complete this exercise by creating another
    vehicle type that implements the `engage_wheel!` function. (Sorry: the vehicle
    you develop is probably not very *high-tech* since it has wheels.)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: A soft contract is a simple way to provide a default implementation for optional
    interface functions. Next, we will look into a slightly more formal method to
    declare whether a data type supports certain interface elements. We will call
    them *traits*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Using interface traits
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, you may encounter a situation where you need to determine whether
    a data type implements an interface. The information about whether a data type
    exhibits certain behavior is also called a trait.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we implement traits for an interface? In the `Vehicle` module, we can
    add a new function, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This default implementation simply raises an error, and that''s intentional.
    This trait function is expected to be implemented by any vehicle data types. In
    the interface code, the landing function can make use of the trait function for
    a more refined logic:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Generally speaking, trait functions just need to return a binary answer, `true`
    or `false`; however, it is entirely up to the developer how to design the trait.
    For example, it is perfectly reasonable to define the trait function so that it
    returns the type of landing gear—`:wheels`, `:slider`, or `:none`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good idea to define traits as simply as possible. As you may recall,
    the interface that we implemented for our fighter jet in the previous section
    requires five functions—`power_on!`, `power_off!`, `move!`, `turn!`, and `position`.
    From a design perspective, we can create different traits:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '`has_power()`: returns `true` if the vehicle needs to be powered on/off'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_move()`: returns `true` if the vehicle is able to move'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_turn()`: returns `true` if the vehicle can turn in any direction'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location_aware()`: returns `true` if the vehicle can keep track of its location'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have these small building blocks, we can define more complex traits
    that are composed of these simple ones. For example, we can define a trait called
    `smart_vehicle` that supports all of the four traits that we listed. In addition,
    we can define a `solar_vehicle` trait, which is used for vehicles that rely on
    solar power and is always on.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Using traits is a very powerful technique to model object behaviors. There are
    some patterns that are built around how to implement traits in practice. We will
    discuss these more extensively in [Chapter 5](962e7c27-570f-498e-89b9-d9075c58cd45.xhtml),
    *Reusability Patterns.*
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should feel more comfortable about designing interfaces in
    Julia. They are relatively simple to understand and develop. While Julia does
    not provide any formal syntax for interface specification, it is not difficult
    to come up with our own convention. With the help of traits, we can even implement
    more dynamic behavior for our objects.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: We have now concluded all topics in this chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our journey by discussing how to define functions
    and make use of various types of function arguments, such as positional arguments,
    keyword arguments, and variable arguments. We talked about how to use splatting
    to auto assign the elements of an array or tuple to function arguments. We explored
    first-class functions by assigning them to variables and passing them around in
    functional calls. We learned how to create anonymous functions and use the do-syntax
    to make code more readable.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed Julia's dispatch mechanism and introduced the concept of multiple
    dispatch. We realized that ambiguity may exist and so we reviewed the standard
    tools for detecting ambiguities. We have learned how dispatch is dynamic in nature.
    We looked at  parametric methods and how they could be useful in several use cases,
    such as enforcing type consistency and extracting type information from the type
    parameters.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to design interfaces. We realized that there is no formal language
    syntax for defining interfaces in Julia, but we also recognize defining interfaces
    is straightforward and easy to do. We came to know that sometimes it is acceptable
    to have soft contracts so that the developer does not have to implement all interface
    functions. Finally, we wrapped up the discussion with the concept of traits and
    how they can be useful for querying whether a data type implements a specific
    interface.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss two more major features in the Julia language—macros
    and meta programming. Macros are very useful in creating new syntax that makes
    the code clean and easy to maintain. Just take a deep breath and keep going!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are positional arguments different from keyword arguments?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between splatting and slurping?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of using the do-syntax?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tool is available for detecting method ambiguities as related to multiple
    dispatch?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you ensure that the same concrete type is passed to a function in a parametric
    method?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are interfaces implemented without any formal language syntax?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you implement traits, and how are traits useful?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
