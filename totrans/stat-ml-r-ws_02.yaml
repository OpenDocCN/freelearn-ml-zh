- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the basics of R, the most widely used open source
    language for statistical analysis and modeling. We will start with an introduction
    to RStudio, how to perform simple calculations, the common data structures and
    control logic, and how to write functions in R.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to do basic computations in R using
    common data structures such as vectors, lists and data frames in the RStudio **integrated
    development environment** (**IDE**). You will also be able to wrap these calculations
    in functions using different methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering the R and RStudio basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common data structures in R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control logic in R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring functions in R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the exercises in this chapter, you will need to have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of R, which is 4.1.2 at the time of writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest version of RStudio Desktop, which is 2021.09.2+382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code for this chapter is available at [https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_1/Chapter_1.R](https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_1/Chapter_1.R).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R is a popular open source language that supports statistical analysis and modeling,
    and it is most widely used by statisticians developing statistical models and
    performing data analysis. One question commonly asked by learners is how to choose
    between Python and R. For those new to both and needing a simple model for a not-so-big
    dataset, R would be a better choice. It has rich resources to support modeling
    and plotting tasks that were developed by statisticians long before Python was
    born. Besides its many off-the-shelf graphing and statistical modeling offerings,
    the R community is also catching up in advanced machine learning such as deep
    learning, which the Python community currently dominates.
  prefs: []
  type: TYPE_NORMAL
- en: There are many differences between the two languages, and recent years have
    witnessed increasing convergence in many aspects. This book aims to equip you
    with the essential knowledge to understand and use statistics and calculus via
    R. We hope that at some point, you will be able to extract from the inner workings
    of the language itself and think at the methodological level when performing some
    analysis. After cultivating the essential skills from the fundamentals, it will
    just be a matter of personal preference regarding the specific language in use.
    To this end, R provides dedicated utility functions to automatically “convert”
    Python code to be used within the R context, which gives us another reason not
    to worry about choosing a specific language.
  prefs: []
  type: TYPE_NORMAL
- en: Covering the R and RStudio basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is easy to confuse R with **RStudio** if you are a first-time user. In a
    nutshell, R is the engine that supports all sorts of backend computations, and
    RStudio is a convenient tool for navigating and managing related coding and reference
    resources. Specifically, RStudio is an **IDE** where the user writes R code, performs
    analysis, and develops models without worrying much about the backend logistics
    required by the R engine. The interface provided by RStudio makes the development
    work much more convenient and user-friendly than the vanilla R interface.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to install R on our computer, as the RStudio will ship with the
    computation horsepower upon installation. We can choose the corresponding version
    of R at [https://cloud.r-project.org/](https://cloud.r-project.org/), depending
    on the specific type of operating system we use. RStudio can then be downloaded
    at [https://www.rstudio.com/products/rstudio/download/](https://www.rstudio.com/products/rstudio/download/)
    and installed accordingly. When launching the RStudio application after installing
    both software, the R engine will be automatically detected and used. Let’s go
    through an exercise to get familiar with the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.01 – exploring RStudio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RStudio provides a comprehensive environment for working with R scripts and
    exploring the data simultaneously. In this exercise, we will look at a basic example
    of how to write a simple script to store a string and perform a simple calculation
    using RStudio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the RStudio application and observe the three panes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Console** pane is used to execute R commands and display the immediate
    result.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Environment** pane stores all the global variables in the current **session**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Files** pane lists all the files within the current working directory
    along with other tabs, as shown in *Figure 1**.1*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the R version is printed as a message in the console (highlighted
    in the dashed box):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A screenshot of the RStudio upon the first launch](img/B18680_01_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – A screenshot of the RStudio upon the first launch
  prefs: []
  type: TYPE_NORMAL
- en: We can also type `R.version` in the console to retrieve more detailed information
    on the version of the R engine in use, as shown in *Figure 1**.2*. It is essential
    to check the R version, as different versions *may* produce different results
    when running the same code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Typing a command in the console to check the R version](img/B18680_01_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Typing a command in the console to check the R version
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a new `test.R` upon saving the file. See the following figure for an
    illustration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Creating a new R script](img/B18680_01_003..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Creating a new R script
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the script can be achieved by placing the cursor at the current line
    and pressing *Cmd* + *Enter* for macOS or *Ctrl* + *Enter* for Windows; alternatively,
    click on the **Run** button at the top of the R script pane, as shown in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Executing the script by clicking on the Run button](img/B18680_01_004..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Executing the script by clicking on the Run button
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following commands in the script editing pane and observe the output
    in the console as well as the changes in the other panes. First, we create a `test`
    by assigning `"I am a string"`. A variable can be used to store an object, which
    could take the form of a string, number, data frame, or even function (more on
    this later). Strings consist of characters, a common data type in R. The `test`
    variable created in the script is also reflected in the **Environment** pane,
    which is a convenient check as we can also observe the content in the variable.
    See *Figure 1**.5* for an illustration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 1.5 – Creating a string-type variable](img/B18680_01_005..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Creating a string-type variable
  prefs: []
  type: TYPE_NORMAL
- en: 'We also assign a simple addition operation to `test2` and print it out in the
    console. These commands are also annotated via the `#` sign, where the contents
    after the sign are not executed and are only used to provide an explanation of
    the following code. See *Figure 1**.6* for an illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.6 – Assigning a string and performing basic computation](img/B18680_01_006..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Assigning a string and performing basic computation
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check the contents of the environment workspace via the `ls()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition, note that the newly created R script is also reflected in the **Files**
    pane. RStudio is an excellent one-stop IDE for working with R and will be the
    programming interface for this book. We will introduce more features of RStudio
    in a more specific context along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The canonical way of assigning some value to a variable is via the `<-` operator
    instead of the `=` sign as in the example. However, the author chose to use the
    `=` sign as it is faster to type on the screen and has an equivalent effect as
    the `<-` sign in the majority of cases.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, note that the output message in the `[1]` sign, which indicates
    that the result is a one-dimensional output. We will ignore this sign in the output
    message unless otherwise specified.
  prefs: []
  type: TYPE_NORMAL
- en: The exercise in the previous section provides an additional example, which is
    an essential operation in R. As with other modern programming languages, R also
    ships with many standard arithmetic operators, including subtraction `(-)`, multiplication
    `(*)`, division `(/)`, exponentiation `(^)`, and modulo `(%%)` operators. The
    modulo operator returns the remainder of the numerator in the division operation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an exercise to go through some common arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.02 – common arithmetic operations in R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise will perform different arithmetic operations (addition, subtraction,
    multiplication, division, exponentiation, and modulo) between two numbers: 5 and
    2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the commands under the `print()` function, as directly executing the command
    will also print out the result as highlighted in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Performing common arithmetic operations in R](img/B18680_01_007..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Performing common arithmetic operations in R
  prefs: []
  type: TYPE_NORMAL
- en: Note that these elementary arithmetic operations can jointly form complex operations.
    When evaluating a complex operation that consists of multiple operators, the general
    rule of thumb is to use parentheses to enforce the execution of a specific component
    according to the desired sequence. This follows in most numeric analyses using
    any programming language.
  prefs: []
  type: TYPE_NORMAL
- en: But, what forms can we expect the data to take in R?
  prefs: []
  type: TYPE_NORMAL
- en: Common data types in R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are five most basic data types in R: **numeric**, **integer**, **character**,
    **logical**, and **factor**. Any complex R object can be decomposed into individual
    elements that fall into one of these five data types and, therefore, contain one
    or more data types. The definition of these five data types is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1.23`. A variable is treated as a numeric even if we assign an integer value
    to it in the first place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer** is a whole number and so a subset of the numeric data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character** is the data type used to store a sequence of characters (including
    letters, symbols, or even numbers) to form a string or a piece of text, surrounded
    by double or single quotes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRUE` or `FALSE`. It is often used in a conditional statement to determine
    whether specific codes after the condition should be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factor** is a special data type used to store categorical variables that
    contain a limited number of categories (or **levels**), ordered or unordered.
    For example, a list of student heights classified as low, medium, and high can
    be represented as a factor type to encode the inherent ordering, which would not
    be available when represented as a character type. On the other hand, unordered
    lists such as male and female can also be represented as factor types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through an example to understand these different data types.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.03 – understanding data types in R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'R has strict rules on the data types when performing arithmetic operations.
    In general, the data types of all variables should be the same when evaluating
    a particular **statement** (a piece of code). Performing an arithmetic operation
    on different data types may give an error. In this exercise, we will look at how
    to check the data type to ensure the type consistency and different ways to convert
    the data type from one into another:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating five variables, each belonging to a different data type.
    Check the data type using the `class()` function. Note that we can use the semicolon
    to separate different actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As expected, the data type of the `b` variable is converted into numeric even
    when it is assigned an integer in the first place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Perform addition on the variables. Let’s start with the `a` and `b` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the decimal point is ignored when displaying the result of the addition,
    which is still numeric as verified via the `class()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s look at the addition between `a` and `c`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, we received an *error* message due to a mismatch in data types when
    evaluating an addition operation. This is because the `+` addition operator in
    R is a binary operator designed to take in two values (operands) and produce another,
    all of which need to be numeric (including integer, of course). The error pops
    up when any of the two input *arguments* are non-numeric.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s trying adding `a` and `d`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Surprisingly, the result is the same as `a + b`, suggesting that the Boolean
    `b` variable taking a `TRUE` value is converted into a value of one under the
    hood. Correspondingly, a Boolean value of `FALSE`, obtained by adding an exclamation
    mark before the variable, would be treated as zero when performing an arithmetic
    operation with a numeric:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the implicit Boolean conversion occurs in settings when such conversion
    is necessary to proceed in a specific statement. For example, `d` is converted
    into a numeric value of one when evaluating whether `a` equals `d`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Convert the data types using the `as.(datatype)` family of functions in R.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, the `as.numeric()` function converts the input parameter into
    a numeric, `as.integer()` returns the integer part of the input decimal, `as.character()`
    converts all inputs (including numeric and Boolean) into strings, and `as.logical()`
    converts any non-zero numeric into `TRUE` and zero into `FALSE`. Let’s look at
    a few examples:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This suggests that the `b` variable is successfully converted into numeric.
    Note that type conversion is a standard data processing operation in R, and type
    incompatibility is a popular source of error that may be difficult to trace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since `as.integer()` only returns the integer part of the input, the result
    is always “floored” to the lower bound integer. We could use the `round()` function
    to round it up or down, depending on the value of the first digit after the decimal
    point:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `as.character()` function converts all input parameters into strings as
    represented by the double quotes, including numeric and Boolean. The converted
    value no longer maintains the original arithmetic property. For example, a numeric
    converted into a character would not go through the addition operation. Also,
    a Boolean converted into a character would no longer be evaluated via a logical
    statement and treated as a character:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since there is only one element in the input parameter, the resulting number
    of levels is only `1`, meaning the original input itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A categorical variable is called a `high`, `medium`, or `low` has an inherent
    ordering in nature, while a gender variable valued as either `male` or `female`
    has no order.
  prefs: []
  type: TYPE_NORMAL
- en: Common data structures in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures provide an organized way to store various data points that follow
    either the same or different types. This section will look at the typical data
    structures used in R, including the vector, matrix, data frame, and list.
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `c()`. The arithmetic operations between two vectors are similar to the single-element
    example earlier, provided that their lengths are equal. There needs to be a one-to-one
    correspondence between the elements of the two vectors; if not, the calculation
    *may* give an error. Let’s look at an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.04 – working with vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create two vectors of the same length in this exercise and add them
    up. As an extension, we will also attempt the same addition using a vector of
    a different length. We will also perform a pairwise comparison between the two
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two vectors named `vec_a` and `vec_b` and extract simple summary statistics
    such as `mean` and `sum`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The sum and mean of a vector can be generated using the `sum()` and `mean()`
    function, respectively. We will cover more ways to summarize a vector later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add up `vec_a` and `vec_b`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The addition between two vectors is performed element-wise. The result can also
    be saved into another variable for further processing. How about adding a single
    element to a vector?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add `vec_a` and `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under the hood, element one is broadcasted into vector `c(1,1,1)`, whose length
    is decided by `vec_a`. `vec_a` and `c(1,1)`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We still get the same result, except for a warning message saying that the longer
    vector’s length of three is not a multiple of the shorter vector length of two.
    Pay attention to this warning message. It is not recommended to follow such practice
    as the warning may become an explicit error or become the implicit cause of an
    underlying bug in an extensive program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will perform a pairwise comparison between the two vectors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have used evaluation operators such as `>` (greater than) and `==`
    (equal to), returning logical results (`TRUE` or `FALSE`) for each pair.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note, there are multiple logical comparison operators in R. The common ones
    include the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<` for less than'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=` for less than or equal to'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>` for greater than'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=` for greater than or equal to'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`==` for equal to'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=` for not equal to'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the common arithmetic operations, we may also be interested in selected
    partial components of a vector. We can use square brackets to select specific
    elements of a vector, which is the same way to select elements in other data structures
    such as in a matrix or a data frame. In between the square brackets are indices
    indicating what elements to select. For example, we can use `vec_a[1]` to select
    the first element of `vec_a`. Let’s go through an exercise to look at different
    ways to subset a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.05 – subsetting a vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can pass in the select index (starting from `1`) to select the corresponding
    element in the vector. We can wrap the indices via the `c()` combine function
    and pass in the square brackets to select multiple elements. Selecting multiple
    sequential indices can also be achieved via a shorthand notation by writing the
    first and last index with a colon in between. Let’s run through different ways
    of subsetting a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the first element in `vec_a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the first and third elements in `vec_a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select all three elements in `vec_a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Selecting multiple elements in this way is not very convenient since we need
    to type every index. When the indices are sequential, a nice shorthand trick is
    to use the starting and end index separated by a colon. For example, `1:3` would
    be the same as `c(1,2,3)`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also perform more complex subsetting by adding a conditional statement
    within the square brackets as the selection criteria. For example, the logical
    evaluation introduced earlier returns either `True` or `False`. An element whose
    index is marked as `true` in the square bracket would be selected. Let’s see an
    example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select elements in `vec_a` that are bigger than the corresponding elements
    in `vec_b`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result contains the last two elements since only the second and third indices
    are set as `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like a vector, a **matrix** is a two-dimensional array consisting of a collection
    of elements of the same data type arranged in a fixed number of rows and columns.
    It is often faster to work with a data structure exclusively containing the same
    data type since the program does not need to differentiate between different types
    of data. This makes the matrix a popular data structure in scientific computing,
    especially in an optimization procedure that involves intensive computation. Let’s
    get familiar with the matrix, including different ways to create, index, subset,
    and enlarge a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.06 – creating a matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard way to create a matrix in R is to call the `matrix()` function,
    where we need to supply three input arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The elements to be filled in the matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of rows in the matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filling direction (either by row or by column)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also rename the rows and columns of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `vec_a` and `vec_b` to create a matrix called `mtx_a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, the input vectors, `vec_a` and `vec_b`, are combined via the `c()` function
    to form a long vector, which then gets sequentially arranged into two rows (`nrow=2`)
    row-wise (`byrow=TRUE`). Feel free to try out different dimension configurations,
    such as setting three rows and two columns when creating the matrix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pay attention to the row and column names in the output. The rows are indexed
    by the first index in the square bracket, while the second indexes the columns.
    We can also rename the matrix as follows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rename the matrix `mtx_a` via the `rownames()` and `colnames()` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s look at how to select elements from the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.07 – subsetting a matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can still use the square brackets to select one or more matrix elements.
    The colon shorthand trick also applies to matrix subsetting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the element at the first row and second column of the `mtx_a` matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select all elements of the last two columns across all rows in the `mtx_a`
    matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select all elements of the second row of the `mtx_a` matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the third row of the `mtx_a` matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Therefore, we have multiple ways to select the specific elements of interest
    from a matrix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with a matrix requires similar arithmetic operations compared to a vector.
    In the next exercise, we will look at summarizing a matrix both row-wise and column-wise
    and performing basic operations such as addition and multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.08 – arithmetic operations with a matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by making a new matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another matrix named `mtx_b` whose elements are double those in `mtx_a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Besides multiplication, all standard arithmetic operators (such as `+`, `-`,
    and `/`) apply in a similar element-wise fashion to a matrix, backed by the same
    broadcasting mechanism. Operations between two matrices of the same size are also
    performed element-wise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Divide `mtx_a` by `mtx_b`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the row-wise and column-wise sum and mean of `mtx_a` using `rowSums()`,
    `colSums()`, `rowMeans()`, and `colMeans()` respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When running an optimizing procedure, we often need to save some intermediate
    metrics, such as model loss and accuracy, for diagnosis. These metrics can be
    saved in a matrix form by gradually appending new data to the current matrix.
    Let’s look at how to expand a matrix both row-wise and column-wise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.09 – expanding a matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding a column or multiple columns to a matrix can be achieved via the `cbind()`
    function, which merges a new matrix or vector column-wise. Similarly, an additional
    matrix or vector can be concatenated row-wise via the `rbind()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Append `mtx_b` to `mtx_a` column-wise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We may need to rename the columns since some of them overlap. This also applies
    to the row-wise concatenation as follows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Append `mtx_b` to `mtx_a` row-wise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, we’ve seen the matrix in operation. How about data frames next?
  prefs: []
  type: TYPE_NORMAL
- en: Data frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **data frame** is a standard data structure where variables are stored as
    columns and observations as rows in an **object**. It is an advanced version of
    a matrix in that the elements for each column can be of different data types.
  prefs: []
  type: TYPE_NORMAL
- en: The R engine comes with several default datasets stored as data frames. In the
    next exercise, we will look at different ways to examine and understand the structure
    of a data frame.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.10 – understanding data frames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The data frame is a famous data structure representing rectangular-shaped data
    similar to Excel. Let’s examine a default dataset in R as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `iris` dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Checking the dimension using the `dim()` function suggests that the `iris` dataset
    contains 150 rows and five columns. We can initially understand its contents by
    looking at the first and last few observations (rows) in the dataset.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Examine the first and last five rows using `head()` and `tail()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the row names are sequentially indexed by integers starting from one
    by default. The first four columns are numeric, and the last is a character (or
    factor). We can look at the structure of the data frame more systematically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Examine the structure of the `iris` dataset using `str()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `str()` function summarizes the data frame structure, including the total
    number of observations and variables, the complete list of variable names, data
    type, and the first few observations. The number of categories (levels) is also
    shown if the column is a factor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also create a data frame by passing in vectors as columns of the same
    length to the `data.frame()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a data frame called `df_a` with two columns that correspond to `vec_a`
    and `vec_b` respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Selecting the elements of a data frame can be done in a similar fashion to matrix
    selection. Other functions such as `subset()` make the selection more flexible.
    Let’s go through an example.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.11 – selecting elements in a data frame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will first look at different ways to select a particular
    set of elements and then introduce the `subset()` function to perform customized
    conditional selection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the second column of the `df_a` data frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The row-level indexing is left blank to indicate that all rows will be selected.
    We can also make it explicit by referencing all row-level indices:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '>>> df_a$b'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 1 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the rows of `df_a` where column `a` is greater than two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that row index three is also shown as part of the output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can directly use column `a` within the context of the `subset()` function,
    saving us from using the `$` sign instead. We can also select the column by passing
    the column name to the `select` argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select column `b` where column `a` is greater than two in `df_a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another typical operation in data analysis is sorting one or more variables
    of a data frame. Let’s see how it works in R.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.12 – sorting vectors and data frames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `order()` function can be used to return the ranked position of the elements
    in the input vector, which can then be used to sort the elements via updated indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `c(5,1,10)` vector in `vec_c` and sort it in ascending order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the smallest element in `vec_c` is `1`, the corresponding ranked position
    is `1`. Similarly, `5` is set as the second rank and `10` as the third and highest
    rank. The ranked positions are then used to reshuffle and sort the original vector,
    the same as how we would select its elements via `order()` function ranks the
    elements in ascending order by default. What if we want to sort by descending
    order? We could simply add a minus sign to the input vector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Sort the `df_a` data frame by column `a` in descending order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Data frames will be the primary structures we will work with in this book.
    Let’s look at the last and most complex data structure: list.'
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **list** is a flexible data structure that can hold different data types (numeric,
    integer, character, logical, factor, or even list itself), each possibly having
    a different length. It is the most complex structure we have introduced so far,
    gathering various objects in a structured way. To recap, let’s compare the four
    data structures in terms of the contents, data type, and length in *Figure 1**.8*.
    In general, all four structures can store elements of any data type. Vectors (one-dimensional
    array) and matrices (two-dimensional array) require the contents to be homogeneous
    data types. A data frame contains one or more vectors whose data types could differ,
    and a list could contain entries of different data types. Matrices and data frames
    follows a rectangular shape and so require the same length for each column. However,
    the entries in a list could be of arbitrary lengths (subject to memory constraint)
    different from each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Comparing four different data structures in terms of contents,
    data type, and length](img/B18680_01_008..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Comparing four different data structures in terms of contents,
    data type, and length
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to create a list.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.13 – creating a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will go through different ways to manipulate a list, including
    creating and renaming a list, and accessing, adding, and removing elements in
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list using the previous `a`, `vec_a`, and `df_a` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output shows that the list elements are indexed by double square brackets,
    which can be used to access the entries in the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Access the second entry in the list, `ls_a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default indices can also be renamed to enable entry selection by name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rename the list based on the original names and access the `vec_a` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can access a specific entry in the list by using the name either in square
    brackets or via the `$` sign.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new entry named `new_entry` with the content `"test"` in the `ls_a` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result shows that `"test"` is now added to the last entry of `ls_a`. We
    can also remove a specific entry by assigning `NULL` to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove the entry named `df_a` in `ls_a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The entry named `df_a` is now successfully removed from the list. We can also
    update an existing entry in the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the entry named `vec_a` to be `c(1,2)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The entry named `vec_a` is now successfully updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The flexibility and scalability of the list structure make it a popular choice
    for storing heterogeneous data elements, similar to the dictionary in Python.
    In the next section, we will extend our knowledge base by going over the control
    logic in R, which gives us more flexibility and precision when writing long programs.
  prefs: []
  type: TYPE_NORMAL
- en: Control logic in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relational and logical operators help compare statements as we add logic to
    the program. We can also add to the complexity by evaluating multiple conditional
    statements via loops that repeatedly iterate over a sequence of actions. This
    section will cover the essential relational and logical operators that form the
    building blocks of conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly covered a few relational operators such as `>=` and `==` earlier.
    This section will provide a detailed walkthrough on the use of standard relational
    operators. Let’s look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.14 – practicing with standard relational operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relational operators allow us to compare two quantities and obtain the single
    result of the comparison. We will go over the following steps to learn how to
    express and use standard relational operators in R:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following evaluations using the equality operator (`==`) and observe
    the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The equality operator performs by strictly evaluating the two input arguments
    on both sides (including logical data) and only returns `TRUE` if they are equal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the same evaluations using the inequality operator (`!=`) and observe
    the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The inequality operator is the exact opposite of the equality operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following evaluations using the greater than and less than operators
    (`>` and `<`) and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the second evaluation, the comparison between character data follows the
    pairwise alphabetical order of both strings starting from the leftmost character.
    In this case, the letter `s` comes after `c` and is encoded as a higher-valued
    numeric. In the third example, `TRUE` is converted into one and `FALSE` into zero,
    so returning a logical value of `TRUE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following evaluations using the greater-than-or-equal-to operator
    (`>=`) and less-than-or-equal-to operator (`<=`) and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that these operators consist of two conditional evaluations connected
    via an `OR` operator (`|`). We can, therefore, break it down into two evaluations
    in brackets, resulting in the same output as before:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The relational operators also apply to vectors, which we encountered earlier,
    such as row-level filtering to subset a data frame.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compare `vec_a` with `1` using the greater-than operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We would get the same result by separately comparing each element and combining
    the resulting using `c()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `AND` (`&`), `OR` (`|`), and `NOT` (`!`). The `AND` operator returns `TRUE`
    only if both operands are `TRUE`, and the `OR` operator returns `TRUE` if at least
    one operand is `TRUE`. On the other hand, the `NOT` operator flips the evaluation
    result to the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through an exercise on the use of these logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.15 – practicing using standard logical operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start with the `AND` operator, the most widely used control logic to
    ensure a specific action only happens if multiple conditions are satisfied at
    the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following evaluations using the `AND` operator and observe the
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result shows that both conditions need to be satisfied to obtain a `TRUE`
    output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following evaluations using the `OR` operator and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result shows that the output is `TRUE` if at least one condition is evaluated
    as `TRUE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following evaluations using the `NOT` operator and observe the
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the third example, the evaluation is the same as `1 >= 0`, which returns
    `TRUE`. The `NOT` operator, therefore, reverses the evaluation result after the
    exclamation sign.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These operators can also be used to perform pairwise logical evaluations in
    vectors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following evaluations and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is also a long-form for the `AND` (`&&`) and the `OR` (`||`) logical operators.
    Different from the element-wise comparison in the previous short-form, the long-form
    is used to evaluate only the first element of each input vector, and such evaluation
    continues only until the result is determined. In other words, the long-form only
    returns a single result when evaluating two vectors of multiple elements. It is
    most widely used in modern R programming control flow, especially in the conditional
    `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Both evaluations are based on the first element of each vector. That is, the
    second element of each vector is ignored in both evaluations. This offers computational
    benefit, especially when the vectors are large. Since there is no point in continuing
    the evaluation if the final result can be obtained by evaluating the first element,
    we can safely discard the rest.
  prefs: []
  type: TYPE_NORMAL
- en: In the first evaluation using `&&`, comparing the first element of the two vectors
    (`TRUE` and `FALSE`) returns `FALSE`, while continuing the comparison of the second
    element will also return `FALSE`, so the second comparison is unnecessary. In
    the second evaluation using `||`, comparing the first element (`TRUE | FALSE`)
    gives `TRUE`, saving the need to make the second comparison, as the result will
    always be evaluated as `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `if-else` statement, is used to combine the result of multiple logical operators
    and decide the flow of follow-up actions. It is commonly used to increase the
    complexity of large R programs. The `if-else` statement follows a general structure
    as follows, where the evaluation condition is first validated. If the validation
    returns `TRUE`, the expression within the curve braces of the `if` clause would
    be executed and the rest of the code is ignored. Otherwise, the expression within
    the `else` clause would be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go through an exercise to see how to use the `if-else` control statement.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.16 – practicing using the conditional statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Time for another exercise! Let’s practice using the conditional statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize an `x` variable with a value of `1` and write an `if-else` condition
    to determine the output message. Print out `"positive"` if `x` is greater than
    zero, and `"not` `positive"` otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The condition within the `if` clause evaluates to be `TRUE`, and the code inside
    is executed, printing out `"positive"` in the console. Note that the `else` branch
    is optional and can be removed if we only intend to place one check to the input.
    Additional `if-else` control can also be embedded within a branch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also add additional branches using the `if-else` conditional control
    statement, where the middle part can be repeated multiple times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initialize an `x` variable with `0` and write a control flow to determine and
    print out its sign:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the conditions are sequentially evaluated, the second statement returns `TRUE`
    and so prints out `"zero"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `if` statement; the codes will only be executed if the condition evaluates
    to be `TRUE`. The only difference is that a loop will continue to iteratively
    execute the code as long as the condition is `TRUE`. There are two types of loops:
    the `while` loop and the `for` loop. The `while` loop is used when the number
    of iterations is unknown, and the termination relies on either the evaluation
    condition or a separated condition within the running expression using the `break`
    control statement. The `for` loop is used when the number of iterations is known.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` loop follows a general structure as follows, where `condition 1`
    first gets evaluated to determine the expression within the outer curly braces
    that should be executed. There is an (optional) `if` statement to decide whether
    the `while` loop needs to be terminated based on `condition 2`. These two conditions
    control the termination of the `while` loop, which exits the execution as long
    as any one condition evaluates as `TRUE`. Inside the `if` clause, `condition 2`
    can be placed anywhere within the `while` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that `condition 1` within the `while` statement needs to be `FALSE` at
    some point; otherwise, the loop will continue indefinitely, which may cause a
    session expiry error within RStudio.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through an exercise to look at how to use the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.17 – practicing the while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s try out the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize an `x` variable with a value of `2` and write a `while` loop. If
    `x` is less than `10`, square it and print out its value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `while` loop is executed twice, bringing the value of `x` from `2` to `16`.
    During the third evaluation, `x` is above 10 and the conditional statement evaluates
    to be `FALSE`, thus exiting the loop. We can also print out `x` to double-check
    its value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a condition after the squaring to exit the loop if `x` is greater than
    10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Only one number is printed out this time. The reason is that when `x` is changed
    to `16`, the `if` condition evaluates to be `TRUE`, thus triggering the `break`
    statement to exit the `while` loop and ignore the `print()` statement. Let’s verify
    the value of `x`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at the `for` loop, which assumes the following general structure.
    Here, `var` is a placement to sequentially reference the contents in `sequence`,
    which can be a vector, a list, or another data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The same expression will be evaluated for each unique variable in `sequence`,
    unless an explicit `if` condition is triggered to either exit the loop using `break`,
    or skip the rest of the code and immediately jump to the next iteration using
    `next`. Let’s go through an exercise to put these in perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.18 – practicing using the for loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s try the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a vector to store three strings (`statistics`, `and`, and `calculus`)
    and print out each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the `for` loop iterates through each element in the `string_a` vector
    by sequentially assigning the element value to the `i` variable at each iteration.
    We can also choose to iterate using the vector index, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we created a series of integer indexes from `1` up to the length of the
    vector and assigned them to the `i` variable in each iteration, which is then
    used to reference the element in the `string_a` vector. This is a more flexible
    and versatile way of referencing elements in a vector since we can also use the
    same index to reference other vectors. Directly referencing the element as in
    the previous approach is more concise and readable. However, it lacks the level
    of control and flexibility without the looping index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a condition to break the loop if the current element is `"and"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The loop is exited upon satisfying the `if` condition when the current value
    in `i` is `"and"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a condition to jump to the next iteration if the current element is `"and"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the next statement is evaluated, the following `print()` function is ignored,
    and the program jumps to the next iteration, printing only `"statistics"` and
    `"calculus"` with the `"``and"` element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So far, we have covered some of the most fundamental building blocks in R.
    We are now ready to come to the last and most widely used building block: functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring functions in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `sum()` and `mean()` functions we used in the previous exercise. We can also
    define our own function to operate as an interface that processes a given input
    signal and produces an output. See *Figure 1**.9* for an illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Illustration of a function’s workflow](img/B18680_01_009..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Illustration of a function’s workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can be created using the `function` keyword with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can be decomposed into the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function name**: The name of the functional object registered and stored
    in the R environment. We use this name followed by a pair of parentheses and (optionally)
    input arguments within the parentheses to call the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input argument**: A placeholder used to receive input value when calling
    the function. An argument can be optional (with a default value assigned) or compulsory
    (with no default value assigned). Setting all arguments as optional is the same
    as requiring no compulsory input arguments for the function. However, we will
    need to pass a specific value to a compulsory argument in order to call the function.
    In addition, the optional argument can also appear after the compulsory argument,
    if any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function body**: This is the area where the main statement is executed to
    complete a specific action and fulfill the purpose of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through an exercise on creating a user-defined function.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.19 – creating a user-defined function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function named `test_func` to receive an input and print out `"(input)
    is fun"`. Allow the option to print the message in uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we used the `=` sign instead of `<-` to assign the functional object
    to the `test_func` variable. However, the latter is more commonly observed when
    creating functions in R. In the input, we created two arguments: the compulsory
    argument, `x`, to receive the message to be printed, and the optional argument,
    `cap`, to determine whether the message needs to be converted into uppercase.
    The optional argument means that the user can either go with the default setting
    (that is, a lowercase message) by not supplying anything to this argument or overwrite
    the default behavior by explicitly passing in a value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the function body, we first create a `msg` variable and assign the message
    content by calling the `paste()` function, a built-in function to concatenate
    the two input arguments. If the `cap` argument is `FALSE`, the `if` statement
    will evaluate to `FALSE` and `msg` will be directly returned as the function’s
    output. Otherwise, the statement within the `if` clause will be triggered to convert
    the `msg` variable into uppercase using the `toupper()` function, another built-in
    function in R.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s see what happens after calling the function in different ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first two cases work as expected. In the third case, we did not supply any
    value to the `x` argument, defined as a compulsory argument. This leads to an
    error and fails to call the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the essential building blocks in R, including how
    to leverage and navigate the RStudio IDE, basic arithmetic operations (addition,
    subtraction, multiplication, division, exponentiation, and modulo), common data
    structures (vectors, matrices, data frames, and lists), control logic, including
    relational operators (`>`, `==`, `<`, `>=`, `<=`, and `!=`) and logical operators
    (`&`, `|`, `!`, `&&`, and `||`), conditional statements using `ifelse`, the `for`
    and `while` loops, and finally, functions in R. Understanding these fundamental
    aspects will greatly benefit our learning in later chapters as we gradually introduce
    more challenging topics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover `dplyr`, one of the most widely used libraries
    for data processing and manipulation. Tapping into the various utility functions
    provided by `dplyr` will make it much easier to handle most data processing tasks.
  prefs: []
  type: TYPE_NORMAL
