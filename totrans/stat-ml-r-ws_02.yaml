- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started with R
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R语言入门
- en: In this chapter, we will cover the basics of R, the most widely used open source
    language for statistical analysis and modeling. We will start with an introduction
    to RStudio, how to perform simple calculations, the common data structures and
    control logic, and how to write functions in R.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍R的基础知识，这是最广泛使用的开源统计分析和建模语言。我们将从RStudio的介绍开始，如何进行简单的计算，常见的数组和控制逻辑，以及如何在R中编写函数。
- en: By the end of the chapter, you will be able to do basic computations in R using
    common data structures such as vectors, lists and data frames in the RStudio **integrated
    development environment** (**IDE**). You will also be able to wrap these calculations
    in functions using different methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用RStudio中的常见数据结构（如向量、列表和数据框）进行基本的计算，并能够使用不同的方法将这些计算封装在函数中。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Introducing R
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍R
- en: Covering the R and RStudio basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖R和RStudio的基础知识
- en: Common data structures in R
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R中的常见数据结构
- en: Control logic in R
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R中的控制逻辑
- en: Exploring functions in R
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索R中的函数
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the exercises in this chapter, you will need to have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，您需要具备以下条件：
- en: The latest version of R, which is 4.1.2 at the time of writing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写本书时R的最新版本，即4.1.2
- en: The latest version of RStudio Desktop, which is 2021.09.2+382
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RStudio桌面版的最新版本，即2021.09.2+382
- en: All the code for this chapter is available at [https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_1/Chapter_1.R](https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_1/Chapter_1.R).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码均可在[https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_1/Chapter_1.R](https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/blob/main/Chapter_1/Chapter_1.R)找到。
- en: Introducing R
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍R
- en: R is a popular open source language that supports statistical analysis and modeling,
    and it is most widely used by statisticians developing statistical models and
    performing data analysis. One question commonly asked by learners is how to choose
    between Python and R. For those new to both and needing a simple model for a not-so-big
    dataset, R would be a better choice. It has rich resources to support modeling
    and plotting tasks that were developed by statisticians long before Python was
    born. Besides its many off-the-shelf graphing and statistical modeling offerings,
    the R community is also catching up in advanced machine learning such as deep
    learning, which the Python community currently dominates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: R是一种流行的开源语言，支持统计分析和建模，它被统计学家广泛用于开发统计模型和进行数据分析。学习者常问的一个问题是如何在Python和R之间进行选择。对于那些对两者都较新，并且需要一个简单的模型来处理不太大的数据集的人来说，R会是一个更好的选择。它拥有丰富的资源来支持建模和绘图任务，这些任务是在Python出现之前由统计学家开发的。除了其许多现成的图形和统计建模产品外，R社区也在追赶目前由Python社区主导的高级机器学习，如深度学习。
- en: There are many differences between the two languages, and recent years have
    witnessed increasing convergence in many aspects. This book aims to equip you
    with the essential knowledge to understand and use statistics and calculus via
    R. We hope that at some point, you will be able to extract from the inner workings
    of the language itself and think at the methodological level when performing some
    analysis. After cultivating the essential skills from the fundamentals, it will
    just be a matter of personal preference regarding the specific language in use.
    To this end, R provides dedicated utility functions to automatically “convert”
    Python code to be used within the R context, which gives us another reason not
    to worry about choosing a specific language.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 两种语言之间有许多差异，近年来在许多方面也见证了越来越多的趋同。本书旨在为您提供理解和使用R语言进行统计和微积分的基本知识。我们希望有一天，您能够从语言本身的内部运作中提取信息，并在进行某些分析时从方法论层面进行思考。在从基础知识培养基本技能之后，具体使用哪种语言将只是个人偏好的问题。为此，R提供了专门的实用函数，可以自动“转换”Python代码以在R环境中使用，这又给我们提供了一个不必担心选择特定语言的理由。
- en: Covering the R and RStudio basics
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖R和RStudio的基础知识
- en: It is easy to confuse R with **RStudio** if you are a first-time user. In a
    nutshell, R is the engine that supports all sorts of backend computations, and
    RStudio is a convenient tool for navigating and managing related coding and reference
    resources. Specifically, RStudio is an **IDE** where the user writes R code, performs
    analysis, and develops models without worrying much about the backend logistics
    required by the R engine. The interface provided by RStudio makes the development
    work much more convenient and user-friendly than the vanilla R interface.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个初学者，很容易将 R 与 **RStudio** 混淆。简而言之，R 是支持各种后端计算的动力引擎，而 RStudio 是一个方便的工具，用于导航和管理相关的编码和参考资源。具体来说，RStudio
    是一个 **IDE**，用户在其中编写 R 代码、执行分析和开发模型，无需过多担心 R 引擎所需的底层物流。RStudio 提供的界面使得开发工作比原始 R
    界面更加方便和用户友好。
- en: First, we need to install R on our computer, as the RStudio will ship with the
    computation horsepower upon installation. We can choose the corresponding version
    of R at [https://cloud.r-project.org/](https://cloud.r-project.org/), depending
    on the specific type of operating system we use. RStudio can then be downloaded
    at [https://www.rstudio.com/products/rstudio/download/](https://www.rstudio.com/products/rstudio/download/)
    and installed accordingly. When launching the RStudio application after installing
    both software, the R engine will be automatically detected and used. Let’s go
    through an exercise to get familiar with the interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的计算机上安装 R，因为 RStudio 在安装时会附带计算能力。我们可以根据所使用的特定操作系统类型，在 [https://cloud.r-project.org/](https://cloud.r-project.org/)
    选择相应的 R 版本。然后可以在 [https://www.rstudio.com/products/rstudio/download/](https://www.rstudio.com/products/rstudio/download/)
    下载 RStudio 并相应地安装。在安装了这两种软件后启动 RStudio 应用程序，R 引擎将自动检测并使用。让我们通过一个练习来熟悉界面。
- en: Exercise 1.01 – exploring RStudio
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.01 – 探索 RStudio
- en: RStudio provides a comprehensive environment for working with R scripts and
    exploring the data simultaneously. In this exercise, we will look at a basic example
    of how to write a simple script to store a string and perform a simple calculation
    using RStudio.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio 提供了一个全面的环境，用于同时处理 R 脚本和探索数据。在这个练习中，我们将查看一个基本示例，说明如何使用 RStudio 编写一个简单的脚本来存储字符串并执行简单的计算。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Launch the RStudio application and observe the three panes:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 RStudio 应用程序并观察三个面板：
- en: The **Console** pane is used to execute R commands and display the immediate
    result.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台** 面板用于执行 R 命令并显示即时结果。'
- en: The **Environment** pane stores all the global variables in the current **session**.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境** 面板存储当前 **会话** 中所有的全局变量。'
- en: The **Files** pane lists all the files within the current working directory
    along with other tabs, as shown in *Figure 1**.1*.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件** 面板列出了当前工作目录中的所有文件以及其他标签页，如图 *图 1**.1* 所示。'
- en: 'Note that the R version is printed as a message in the console (highlighted
    in the dashed box):'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，R 版本会以消息的形式打印在控制台中（用虚线框突出显示）：
- en: '![Figure 1.1 – A screenshot of the RStudio upon the first launch](img/B18680_01_001.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 首次启动 RStudio 的截图](img/B18680_01_001.jpg)'
- en: Figure 1.1 – A screenshot of the RStudio upon the first launch
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 首次启动 RStudio 的截图
- en: We can also type `R.version` in the console to retrieve more detailed information
    on the version of the R engine in use, as shown in *Figure 1**.2*. It is essential
    to check the R version, as different versions *may* produce different results
    when running the same code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在控制台中输入 `R.version` 来检索有关正在使用的 R 引擎版本的更详细信息，如图 *图 1**.2* 所示。检查 R 版本至关重要，因为不同的版本在运行相同代码时可能会产生不同的结果。
- en: '![Figure 1.2 – Typing a command in the console to check the R version](img/B18680_01_002.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 在控制台中输入命令以检查 R 版本](img/B18680_01_002.jpg)'
- en: Figure 1.2 – Typing a command in the console to check the R version
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 在控制台中输入命令以检查 R 版本
- en: 'Build a new `test.R` upon saving the file. See the following figure for an
    illustration:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存文件后构建一个新的 `test.R`。以下图示说明了这一点：
- en: '![Figure 1.3 – Creating a new R script](img/B18680_01_003..jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 创建新的 R 脚本](img/B18680_01_003..jpg)'
- en: Figure 1.3 – Creating a new R script
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 创建新的 R 脚本
- en: 'Running the script can be achieved by placing the cursor at the current line
    and pressing *Cmd* + *Enter* for macOS or *Ctrl* + *Enter* for Windows; alternatively,
    click on the **Run** button at the top of the R script pane, as shown in the following
    figure:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本可以通过将光标放在当前行并按 *Cmd* + *Enter*（macOS）或 *Ctrl* + *Enter*（Windows）来实现；或者，可以点击
    R 脚本面板顶部的 **运行** 按钮，如图所示：
- en: '![Figure 1.4 – Executing the script by clicking on the Run button](img/B18680_01_004..jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.4 – Executing the script by clicking on the Run button](img/B18680_01_004..jpg)'
- en: Figure 1.4 – Executing the script by clicking on the Run button
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 点击运行按钮执行脚本
- en: 'Type the following commands in the script editing pane and observe the output
    in the console as well as the changes in the other panes. First, we create a `test`
    by assigning `"I am a string"`. A variable can be used to store an object, which
    could take the form of a string, number, data frame, or even function (more on
    this later). Strings consist of characters, a common data type in R. The `test`
    variable created in the script is also reflected in the **Environment** pane,
    which is a convenient check as we can also observe the content in the variable.
    See *Figure 1**.5* for an illustration:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本编辑面板中输入以下命令，并在控制台以及其他面板中观察输出。首先，我们通过分配 `"I am a string"` 创建一个 `test`。一个变量可以用来存储一个对象，它可以是字符串、数字、数据框，甚至是函数（稍后会有更多介绍）。字符串由字符组成，是
    R 中的一种常见数据类型。在脚本中创建的 `test` 变量也会反映在 **环境** 面板中，这是一个方便的检查点，因为我们也可以观察变量中的内容。参见 *图
    1**.5* 的说明：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 1.5 – Creating a string-type variable](img/B18680_01_005..jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.5 – Creating a string-type variable](img/B18680_01_005..jpg)'
- en: Figure 1.5 – Creating a string-type variable
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 创建字符串类型变量
- en: 'We also assign a simple addition operation to `test2` and print it out in the
    console. These commands are also annotated via the `#` sign, where the contents
    after the sign are not executed and are only used to provide an explanation of
    the following code. See *Figure 1**.6* for an illustration:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还把一个简单的加法操作分配给 `test2` 并在控制台中打印出来。这些命令也通过 `#` 符号进行了注释，其中符号后面的内容不会执行，仅用于解释下面的代码。参见
    *图 1**.6* 的说明：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Figure 1.6 – Assigning a string and performing basic computation](img/B18680_01_006..jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.6 – Assigning a string and performing basic computation](img/B18680_01_006..jpg)'
- en: Figure 1.6 – Assigning a string and performing basic computation
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 分配字符串并执行基本计算
- en: 'We can also check the contents of the environment workspace via the `ls()`
    function:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过 `ls()` 函数检查环境工作区的内容：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In addition, note that the newly created R script is also reflected in the **Files**
    pane. RStudio is an excellent one-stop IDE for working with R and will be the
    programming interface for this book. We will introduce more features of RStudio
    in a more specific context along the way.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，新创建的 R 脚本也反映在 **文件** 面板中。RStudio 是一个用于处理 R 的优秀一站式 IDE，并将成为本书的编程接口。我们将在更具体的上下文中介绍
    RStudio 的更多功能。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The canonical way of assigning some value to a variable is via the `<-` operator
    instead of the `=` sign as in the example. However, the author chose to use the
    `=` sign as it is faster to type on the screen and has an equivalent effect as
    the `<-` sign in the majority of cases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将一些值分配给变量的规范方式是通过 `<-` 运算符，而不是像示例中那样使用 `=` 符号。然而，作者选择使用 `=` 符号，因为它在屏幕上输入更快，并且在大多数情况下与
    `<-` 符号有相同的效果。
- en: In addition, note that the output message in the `[1]` sign, which indicates
    that the result is a one-dimensional output. We will ignore this sign in the output
    message unless otherwise specified.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意 `[1]` 标记中的输出消息，它表示结果是一个一维输出。除非另有说明，否则我们将忽略这个标记。
- en: The exercise in the previous section provides an additional example, which is
    an essential operation in R. As with other modern programming languages, R also
    ships with many standard arithmetic operators, including subtraction `(-)`, multiplication
    `(*)`, division `(/)`, exponentiation `(^)`, and modulo `(%%)` operators. The
    modulo operator returns the remainder of the numerator in the division operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的练习提供了一个额外的例子，这是 R 中的一个基本操作。与其他现代编程语言一样，R 也提供了许多标准算术运算符，包括减法 `(-)`、乘法 `(*)`、除法
    `(/)`、指数 `(^)` 和取模 `(%%)` 运算符。取模运算符返回除法操作中分子的余数。
- en: Let’s look at an exercise to go through some common arithmetic operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个练习来了解一些常见的算术运算。
- en: Exercise 1.02 – common arithmetic operations in R
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.02 – R 中的常见算术运算
- en: 'This exercise will perform different arithmetic operations (addition, subtraction,
    multiplication, division, exponentiation, and modulo) between two numbers: 5 and
    2.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将在两个数字之间执行不同的算术运算（加法、减法、乘法、除法、指数和取模）：5和2。
- en: 'Type the commands under the `print()` function, as directly executing the command
    will also print out the result as highlighted in the console:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`print()`函数下输入命令，因为直接执行命令也会在控制台高亮显示结果：
- en: '![Figure 1.7 – Performing common arithmetic operations in R](img/B18680_01_007..jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 在R中执行常见的算术运算](img/B18680_01_007..jpg)'
- en: Figure 1.7 – Performing common arithmetic operations in R
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 在R中执行常见的算术运算
- en: Note that these elementary arithmetic operations can jointly form complex operations.
    When evaluating a complex operation that consists of multiple operators, the general
    rule of thumb is to use parentheses to enforce the execution of a specific component
    according to the desired sequence. This follows in most numeric analyses using
    any programming language.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些基本的算术运算可以联合形成复杂的运算。在评估由多个运算符组成的复杂运算时，一般规则是使用括号来强制执行特定组件，以符合所需的顺序。这在大多数使用任何编程语言的数值分析中都是适用的。
- en: But, what forms can we expect the data to take in R?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以在R中期望数据采取哪些形式？
- en: Common data types in R
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: R中的常见数据类型
- en: 'There are five most basic data types in R: **numeric**, **integer**, **character**,
    **logical**, and **factor**. Any complex R object can be decomposed into individual
    elements that fall into one of these five data types and, therefore, contain one
    or more data types. The definition of these five data types is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: R中有五种最基本的数据类型：**数值型**、**整型**、**字符型**、**逻辑型**和**因子型**。任何复杂的R对象都可以分解为属于这五种数据类型之一的单个元素，因此包含一个或多个数据类型。这五种数据类型的定义如下：
- en: '`1.23`. A variable is treated as a numeric even if we assign an integer value
    to it in the first place.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.23`。即使我们最初将其赋值为整数值，变量也被视为数值型。'
- en: '**Integer** is a whole number and so a subset of the numeric data type.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整型**是一个整数，因此是数值数据类型的一个子集。'
- en: '**Character** is the data type used to store a sequence of characters (including
    letters, symbols, or even numbers) to form a string or a piece of text, surrounded
    by double or single quotes.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符型**是用于存储字符序列（包括字母、符号甚至数字）以形成字符串或文本的数据类型，由双引号或单引号包围。'
- en: '`TRUE` or `FALSE`. It is often used in a conditional statement to determine
    whether specific codes after the condition should be executed.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRUE`或`FALSE`。它通常用于条件语句中，以确定条件之后的特定代码是否应该执行。'
- en: '**Factor** is a special data type used to store categorical variables that
    contain a limited number of categories (or **levels**), ordered or unordered.
    For example, a list of student heights classified as low, medium, and high can
    be represented as a factor type to encode the inherent ordering, which would not
    be available when represented as a character type. On the other hand, unordered
    lists such as male and female can also be represented as factor types.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因子型**是一种特殊的数据类型，用于存储包含有限数量类别（或**水平**）的分类变量，可以是有序或无序的。例如，将学生身高分类为矮、中、高可以表示为因子类型，以编码固有的顺序，这在作为字符类型表示时是不可用的。另一方面，无序列表，如男性和女性，也可以表示为因子类型。'
- en: Let’s go through an example to understand these different data types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解这些不同的数据类型。
- en: Exercise 1.03 – understanding data types in R
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.03 – 理解R中的数据类型
- en: 'R has strict rules on the data types when performing arithmetic operations.
    In general, the data types of all variables should be the same when evaluating
    a particular **statement** (a piece of code). Performing an arithmetic operation
    on different data types may give an error. In this exercise, we will look at how
    to check the data type to ensure the type consistency and different ways to convert
    the data type from one into another:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: R在执行算术运算时对数据类型有严格的规定。一般来说，在评估特定**语句**（一段代码）时，所有变量的数据类型应该相同。对不同数据类型执行算术运算可能会产生错误。在这个练习中，我们将探讨如何检查数据类型以确保类型一致性，以及将数据类型从一种转换为另一种的不同方法：
- en: 'We start by creating five variables, each belonging to a different data type.
    Check the data type using the `class()` function. Note that we can use the semicolon
    to separate different actions:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建五个变量，每个变量属于不同的数据类型。使用`class()`函数检查数据类型。注意，我们可以使用分号来分隔不同的操作：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As expected, the data type of the `b` variable is converted into numeric even
    when it is assigned an integer in the first place.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，即使 `b` 变量最初被分配了一个整数值，它的数据类型也被转换为数值。
- en: 'Perform addition on the variables. Let’s start with the `a` and `b` variables:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对变量进行加法运算。让我们从 `a` 和 `b` 变量开始：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the decimal point is ignored when displaying the result of the addition,
    which is still numeric as verified via the `class()` function.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在显示加法结果时忽略了小数点，结果仍然是数值，这可以通过 `class()` 函数验证。
- en: 'Now, let’s look at the addition between `a` and `c`:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `a` 和 `c` 之间的加法：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, we received an *error* message due to a mismatch in data types when
    evaluating an addition operation. This is because the `+` addition operator in
    R is a binary operator designed to take in two values (operands) and produce another,
    all of which need to be numeric (including integer, of course). The error pops
    up when any of the two input *arguments* are non-numeric.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们在评估加法运算时由于数据类型不匹配而收到了一个错误信息。这是因为 R 中的 `+` 加法运算符是一个二元运算符，它需要接受两个值（操作数）并产生另一个值，所有这些都需要是数值（包括整数）。当两个输入参数中的任何一个不是数值时，错误就会发生。
- en: 'Let’s trying adding `a` and `d`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试将 `a` 和 `d` 相加：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Surprisingly, the result is the same as `a + b`, suggesting that the Boolean
    `b` variable taking a `TRUE` value is converted into a value of one under the
    hood. Correspondingly, a Boolean value of `FALSE`, obtained by adding an exclamation
    mark before the variable, would be treated as zero when performing an arithmetic
    operation with a numeric:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 令人惊讶的是，结果是和 `a + b` 一样的，这表明布尔变量 `b` 在底层被转换成了一个数值。相应地，通过在变量前添加感叹号得到的布尔值 `FALSE`，在进行与数字的算术运算时会被视为零：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that the implicit Boolean conversion occurs in settings when such conversion
    is necessary to proceed in a specific statement. For example, `d` is converted
    into a numeric value of one when evaluating whether `a` equals `d`:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在需要此类转换以在特定语句中继续进行时，会隐式进行布尔转换。例如，在评估 `a` 是否等于 `d` 时，`d` 被转换为数值 `1`：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Convert the data types using the `as.(datatype)` family of functions in R.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 R 中的 `as.(datatype)` 函数系列转换数据类型。
- en: 'For example, the `as.numeric()` function converts the input parameter into
    a numeric, `as.integer()` returns the integer part of the input decimal, `as.character()`
    converts all inputs (including numeric and Boolean) into strings, and `as.logical()`
    converts any non-zero numeric into `TRUE` and zero into `FALSE`. Let’s look at
    a few examples:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，`as.numeric()` 函数将输入参数转换为数值，`as.integer()` 返回输入小数的整数部分，`as.character()` 将所有输入（包括数值和布尔值）转换为字符串，而
    `as.logical()` 将任何非零数值转换为 `TRUE`，将零转换为 `FALSE`。让我们看几个例子：
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This suggests that the `b` variable is successfully converted into numeric.
    Note that type conversion is a standard data processing operation in R, and type
    incompatibility is a popular source of error that may be difficult to trace:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表明 `b` 变量已成功转换为数值。请注意，类型转换是 R 中的标准数据处理操作，类型不兼容是常见的错误来源，可能难以追踪：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since `as.integer()` only returns the integer part of the input, the result
    is always “floored” to the lower bound integer. We could use the `round()` function
    to round it up or down, depending on the value of the first digit after the decimal
    point:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `as.integer()` 只返回输入的整数部分，结果总是“向下取整”到较小的整数。我们可以使用 `round()` 函数将其向上或向下取整，具体取决于小数点后第一位数字的值：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `as.character()` function converts all input parameters into strings as
    represented by the double quotes, including numeric and Boolean. The converted
    value no longer maintains the original arithmetic property. For example, a numeric
    converted into a character would not go through the addition operation. Also,
    a Boolean converted into a character would no longer be evaluated via a logical
    statement and treated as a character:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`as.character()` 函数将所有输入参数转换为字符串，如双引号所示，包括数值和布尔值。转换后的值不再保持原始的算术属性。例如，转换为字符的数值不会进行加法运算。同样，转换为字符的布尔值将不再通过逻辑语句进行评估，而是被视为字符：'
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since there is only one element in the input parameter, the resulting number
    of levels is only `1`, meaning the original input itself.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于输入参数中只有一个元素，因此结果的级别数只有 `1`，意味着原始输入本身。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A categorical variable is called a `high`, `medium`, or `low` has an inherent
    ordering in nature, while a gender variable valued as either `male` or `female`
    has no order.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被称为 `high`、`medium` 或 `low` 的分类变量在自然中具有固有的顺序，而一个值作为 `male` 或 `female` 的性别变量则没有顺序。
- en: Common data structures in R
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 中的常见数据结构
- en: Data structures provide an organized way to store various data points that follow
    either the same or different types. This section will look at the typical data
    structures used in R, including the vector, matrix, data frame, and list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构提供了一种有组织的方式来存储遵循相同或不同类型的数据点。本节将探讨 R 中使用的典型数据结构，包括向量、矩阵、数据框和列表。
- en: Vector
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: A `c()`. The arithmetic operations between two vectors are similar to the single-element
    example earlier, provided that their lengths are equal. There needs to be a one-to-one
    correspondence between the elements of the two vectors; if not, the calculation
    *may* give an error. Let’s look at an exercise.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `c()`。两个向量之间的算术运算与前面早些时候的单个元素示例类似，前提是它们的长度相等。两个向量的元素之间需要有逐个对应关系；如果不是，计算可能会出错。让我们看看一个练习。
- en: Exercise 1.04 – working with vectors
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.04 – 处理向量
- en: 'We will create two vectors of the same length in this exercise and add them
    up. As an extension, we will also attempt the same addition using a vector of
    a different length. We will also perform a pairwise comparison between the two
    vectors:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建两个长度相同的向量并将它们相加。作为扩展，我们还将尝试使用不同长度的向量进行相同的加法。我们还将对两个向量进行成对比较：
- en: 'Create two vectors named `vec_a` and `vec_b` and extract simple summary statistics
    such as `mean` and `sum`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为 `vec_a` 和 `vec_b` 的向量，并提取简单的统计摘要，如 `mean` 和 `sum`：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The sum and mean of a vector can be generated using the `sum()` and `mean()`
    function, respectively. We will cover more ways to summarize a vector later.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向量的总和和平均值可以使用 `sum()` 和 `mean()` 函数分别生成。我们将在后面介绍更多总结向量的方法。
- en: 'Add up `vec_a` and `vec_b`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `vec_a` 和 `vec_b` 相加：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The addition between two vectors is performed element-wise. The result can also
    be saved into another variable for further processing. How about adding a single
    element to a vector?
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个向量的加法是逐元素进行的。结果也可以保存到另一个变量中，以便进行进一步处理。那么，向一个向量中添加一个单个元素呢？
- en: 'Add `vec_a` and `1`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `vec_a` 和 `1` 相加：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Under the hood, element one is broadcasted into vector `c(1,1,1)`, whose length
    is decided by `vec_a`. `vec_a` and `c(1,1)`:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在底层，第一个元素被广播到长度由 `vec_a` 决定的向量 `c(1,1,1)` 中，`vec_a` 和 `c(1,1)`：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We still get the same result, except for a warning message saying that the longer
    vector’s length of three is not a multiple of the shorter vector length of two.
    Pay attention to this warning message. It is not recommended to follow such practice
    as the warning may become an explicit error or become the implicit cause of an
    underlying bug in an extensive program.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们仍然得到相同的结果，只是多了一个警告信息，说明较长向量的长度为三不是较短向量长度为二的倍数。请注意这个警告信息。不建议这样做，因为警告可能会变成显式错误，或者在大型程序中成为潜在错误的隐含原因。
- en: 'Next, we will perform a pairwise comparison between the two vectors:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将对两个向量进行成对比较：
- en: '[PRE17]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we have used evaluation operators such as `>` (greater than) and `==`
    (equal to), returning logical results (`TRUE` or `FALSE`) for each pair.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用了评估运算符，如 `>`（大于）和 `==`（等于），为每一对返回逻辑结果（`TRUE` 或 `FALSE`）。
- en: 'Note, there are multiple logical comparison operators in R. The common ones
    include the following:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，R 中有多个逻辑比较运算符。常见的一些包括以下内容：
- en: '`<` for less than'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 表示小于'
- en: '`<=` for less than or equal to'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` 表示小于或等于'
- en: '`>` for greater than'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 表示大于'
- en: '`>=` for greater than or equal to'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` 表示大于或等于'
- en: '`==` for equal to'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 表示等于'
- en: '`!=` for not equal to'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 表示不等于'
- en: Besides the common arithmetic operations, we may also be interested in selected
    partial components of a vector. We can use square brackets to select specific
    elements of a vector, which is the same way to select elements in other data structures
    such as in a matrix or a data frame. In between the square brackets are indices
    indicating what elements to select. For example, we can use `vec_a[1]` to select
    the first element of `vec_a`. Let’s go through an exercise to look at different
    ways to subset a vector.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的算术运算外，我们还可能对向量的选定部分感兴趣。我们可以使用方括号来选择向量的特定元素，这与在矩阵或数据框等其他数据结构中选择元素的方式相同。方括号之间是索引，表示要选择哪些元素。例如，我们可以使用
    `vec_a[1]` 来选择 `vec_a` 的第一个元素。让我们通过一个练习来看看如何以不同的方式对向量进行子集化。
- en: Exercise 1.05 – subsetting a vector
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.05 – 向量子集选择
- en: 'We can pass in the select index (starting from `1`) to select the corresponding
    element in the vector. We can wrap the indices via the `c()` combine function
    and pass in the square brackets to select multiple elements. Selecting multiple
    sequential indices can also be achieved via a shorthand notation by writing the
    first and last index with a colon in between. Let’s run through different ways
    of subsetting a vector:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将选择索引（从`1`开始）传递进去，以选择向量中的相应元素。我们可以通过`c()`组合函数包装索引，并传递到方括号中以选择多个元素。通过在第一个和最后一个索引之间写冒号，也可以通过简写符号选择多个连续索引。让我们运行不同的向量子集选择方法：
- en: 'Select the first element in `vec_a`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`vec_a`中的第一个元素：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Select the first and third elements in `vec_a`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`vec_a`中的第一个和第三个元素：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Select all three elements in `vec_a`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`vec_a`中的所有三个元素：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Selecting multiple elements in this way is not very convenient since we need
    to type every index. When the indices are sequential, a nice shorthand trick is
    to use the starting and end index separated by a colon. For example, `1:3` would
    be the same as `c(1,2,3)`:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式选择多个元素不太方便，因为我们需要输入每个索引。当索引是连续的时，一个很好的简写技巧是使用由冒号分隔的起始和结束索引。例如，`1:3`与`c(1,2,3)`相同：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can also perform more complex subsetting by adding a conditional statement
    within the square brackets as the selection criteria. For example, the logical
    evaluation introduced earlier returns either `True` or `False`. An element whose
    index is marked as `true` in the square bracket would be selected. Let’s see an
    example.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以通过在方括号内添加条件语句作为选择条件来执行更复杂的子集选择。例如，前面引入的逻辑评估返回`True`或`False`。在方括号中标记为`true`的索引的元素将被选中。让我们看一个例子。
- en: 'Select elements in `vec_a` that are bigger than the corresponding elements
    in `vec_b`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`vec_a`中选择大于`vec_b`中相应元素的元素：
- en: '[PRE22]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The result contains the last two elements since only the second and third indices
    are set as `true`.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果包含最后两个元素，因为只有第二个和第三个索引被设置为`true`。
- en: Matrix
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵
- en: Like a vector, a **matrix** is a two-dimensional array consisting of a collection
    of elements of the same data type arranged in a fixed number of rows and columns.
    It is often faster to work with a data structure exclusively containing the same
    data type since the program does not need to differentiate between different types
    of data. This makes the matrix a popular data structure in scientific computing,
    especially in an optimization procedure that involves intensive computation. Let’s
    get familiar with the matrix, including different ways to create, index, subset,
    and enlarge a matrix.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量一样，**矩阵**是一个二维数组，由相同数据类型的元素集合组成，这些元素按固定数量的行和列排列。使用仅包含相同数据类型的数据结构通常更快，因为程序不需要区分不同类型的数据。这使得矩阵在科学计算中成为一种流行的数据结构，尤其是在涉及大量计算的优化过程中。让我们熟悉矩阵，包括创建、索引、子集和扩展矩阵的不同方法。
- en: Exercise 1.06 – creating a matrix
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.06 – 创建矩阵
- en: 'The standard way to create a matrix in R is to call the `matrix()` function,
    where we need to supply three input arguments:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中创建矩阵的标准方法是调用`matrix()`函数，我们需要提供三个输入参数：
- en: The elements to be filled in the matrix
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要填充到矩阵中的元素
- en: The number of rows in the matrix
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的行数
- en: The filling direction (either by row or by column)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充方向（按行或按列）
- en: 'We will also rename the rows and columns of the matrix:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将重命名矩阵的行和列：
- en: 'Use `vec_a` and `vec_b` to create a matrix called `mtx_a`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vec_a`和`vec_b`创建一个名为`mtx_a`的矩阵：
- en: '[PRE23]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, the input vectors, `vec_a` and `vec_b`, are combined via the `c()` function
    to form a long vector, which then gets sequentially arranged into two rows (`nrow=2`)
    row-wise (`byrow=TRUE`). Feel free to try out different dimension configurations,
    such as setting three rows and two columns when creating the matrix.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，通过`c()`函数将输入向量`vec_a`和`vec_b`组合成一个长向量，然后按顺序排列成两行（`nrow=2`），按行排列（`byrow=TRUE`）。您可以自由尝试不同的维度配置，例如在创建矩阵时设置三行两列。
- en: Pay attention to the row and column names in the output. The rows are indexed
    by the first index in the square bracket, while the second indexes the columns.
    We can also rename the matrix as follows.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意输出中的行和列名称。行通过方括号中的第一个索引进行索引，而第二个索引列。我们还可以按如下方式重命名矩阵。
- en: 'Rename the matrix `mtx_a` via the `rownames()` and `colnames()` functions:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`rownames()`和`colnames()`函数重命名矩阵`mtx_a`：
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s look at how to select elements from the matrix.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从矩阵中选择元素。
- en: Exercise 1.07 – subsetting a matrix
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.07 – 矩阵的子集
- en: 'We can still use the square brackets to select one or more matrix elements.
    The colon shorthand trick also applies to matrix subsetting:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用方括号来选择一个或多个矩阵元素。冒号简写技巧也适用于矩阵子集：
- en: 'Select the element at the first row and second column of the `mtx_a` matrix:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`mtx_a`矩阵的第一行和第二列的元素：
- en: '[PRE25]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Select all elements of the last two columns across all rows in the `mtx_a`
    matrix:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`mtx_a`矩阵中所有行的最后两列的所有元素：
- en: '[PRE26]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Select all elements of the second row of the `mtx_a` matrix:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`mtx_a`矩阵第二行的所有元素：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Select the third row of the `mtx_a` matrix:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`mtx_a`矩阵的第三行：
- en: '[PRE28]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Therefore, we have multiple ways to select the specific elements of interest
    from a matrix.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们有多种方法从矩阵中选择感兴趣的特定元素。
- en: Working with a matrix requires similar arithmetic operations compared to a vector.
    In the next exercise, we will look at summarizing a matrix both row-wise and column-wise
    and performing basic operations such as addition and multiplication.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量相比，处理矩阵需要类似的算术运算。在下一个练习中，我们将探讨按行和列总结矩阵以及执行基本操作，如加法和乘法。
- en: Exercise 1.08 – arithmetic operations with a matrix
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.08 – 矩阵的算术运算
- en: 'Let’s start by making a new matrix:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的矩阵开始：
- en: 'Create another matrix named `mtx_b` whose elements are double those in `mtx_a`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`mtx_b`的矩阵，其元素是`mtx_a`中元素的两倍：
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Besides multiplication, all standard arithmetic operators (such as `+`, `-`,
    and `/`) apply in a similar element-wise fashion to a matrix, backed by the same
    broadcasting mechanism. Operations between two matrices of the same size are also
    performed element-wise.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了乘法之外，所有标准算术运算符（如`+`、`-`和`/`）都以类似元素级的方式应用于矩阵，并依赖于相同的广播机制。相同大小的两个矩阵之间的操作也是按元素进行的。
- en: 'Divide `mtx_a` by `mtx_b`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`mtx_a`除以`mtx_b`：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calculate the row-wise and column-wise sum and mean of `mtx_a` using `rowSums()`,
    `colSums()`, `rowMeans()`, and `colMeans()` respectively:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rowSums()`、`colSums()`、`rowMeans()`和`colMeans()`分别计算`mtx_a`的行和列总和以及平均值：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When running an optimizing procedure, we often need to save some intermediate
    metrics, such as model loss and accuracy, for diagnosis. These metrics can be
    saved in a matrix form by gradually appending new data to the current matrix.
    Let’s look at how to expand a matrix both row-wise and column-wise.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行优化过程时，我们经常需要保存一些中间指标，如模型损失和准确度，以进行诊断。这些指标可以通过逐渐将新数据附加到当前矩阵中保存为矩阵形式。让我们看看如何按行和列扩展矩阵。
- en: Exercise 1.09 – expanding a matrix
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.09 – 扩展矩阵
- en: 'Adding a column or multiple columns to a matrix can be achieved via the `cbind()`
    function, which merges a new matrix or vector column-wise. Similarly, an additional
    matrix or vector can be concatenated row-wise via the `rbind()` function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`cbind()`函数向矩阵中添加一个或多个列，该函数按列合并新的矩阵或向量列。同样，可以通过`rbind()`函数按行连接额外的矩阵或向量：
- en: 'Append `mtx_b` to `mtx_a` column-wise:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按列将`mtx_b`附加到`mtx_a`：
- en: '[PRE32]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We may need to rename the columns since some of them overlap. This also applies
    to the row-wise concatenation as follows.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可能需要重命名列，因为其中一些列有重叠。这同样适用于以下按行连接。
- en: 'Append `mtx_b` to `mtx_a` row-wise:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按行将`mtx_b`附加到`mtx_a`：
- en: '[PRE33]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, we’ve seen the matrix in operation. How about data frames next?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经看到了矩阵的操作。接下来是数据框如何？
- en: Data frame
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框
- en: A **data frame** is a standard data structure where variables are stored as
    columns and observations as rows in an **object**. It is an advanced version of
    a matrix in that the elements for each column can be of different data types.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据框**是一种标准的数据结构，其中变量存储为列，观测值存储为对象中的行。它是矩阵的高级版本，因为每个列的元素可以有不同的数据类型。'
- en: The R engine comes with several default datasets stored as data frames. In the
    next exercise, we will look at different ways to examine and understand the structure
    of a data frame.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: R引擎自带一些默认数据集，存储为数据框。在下一个练习中，我们将探讨不同的方法来检查和理解数据框的结构。
- en: Exercise 1.10 – understanding data frames
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.10 – 理解数据框
- en: 'The data frame is a famous data structure representing rectangular-shaped data
    similar to Excel. Let’s examine a default dataset in R as an example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框是一种著名的矩形形状数据结构，类似于Excel。让我们以R中的默认数据集为例进行考察：
- en: 'Load the `iris` dataset:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`iris`数据集：
- en: '[PRE34]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Checking the dimension using the `dim()` function suggests that the `iris` dataset
    contains 150 rows and five columns. We can initially understand its contents by
    looking at the first and last few observations (rows) in the dataset.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `dim()` 函数检查维度表明 `iris` 数据集包含 150 行和五列。我们可以通过查看数据集的前几行和最后几行（观测值）来初步了解其内容。
- en: 'Examine the first and last five rows using `head()` and `tail()`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `head()` 和 `tail()` 查看前五行和后五行：
- en: '[PRE35]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the row names are sequentially indexed by integers starting from one
    by default. The first four columns are numeric, and the last is a character (or
    factor). We can look at the structure of the data frame more systematically.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，行名默认按整数顺序索引，从一开始。前四列是数值型，最后一列是字符型（或因子）。我们可以更系统地查看数据框的结构。
- en: 'Examine the structure of the `iris` dataset using `str()`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `str()` 查看数据集 `iris` 的结构：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `str()` function summarizes the data frame structure, including the total
    number of observations and variables, the complete list of variable names, data
    type, and the first few observations. The number of categories (levels) is also
    shown if the column is a factor.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`str()` 函数总结了数据框的结构，包括观测值和变量的总数，变量名称的完整列表，数据类型，以及前几行观测值。如果列是因子，还会显示类别（水平）的数量。'
- en: We can also create a data frame by passing in vectors as columns of the same
    length to the `data.frame()` function.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以通过将相同长度的向量作为列传递给 `data.frame()` 函数来创建数据框。
- en: 'Create a data frame called `df_a` with two columns that correspond to `vec_a`
    and `vec_b` respectively:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `df_a` 的数据框，其中包含两列，分别对应 `vec_a` 和 `vec_b`：
- en: '[PRE37]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Selecting the elements of a data frame can be done in a similar fashion to matrix
    selection. Other functions such as `subset()` make the selection more flexible.
    Let’s go through an example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数据框的元素可以与矩阵选择类似的方式进行。其他如 `subset()` 函数等使选择更加灵活。让我们通过一个例子来了解。
- en: Exercise 1.11 – selecting elements in a data frame
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.11 – 在数据框中选择元素
- en: 'In this exercise, we will first look at different ways to select a particular
    set of elements and then introduce the `subset()` function to perform customized
    conditional selection:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将首先查看选择特定元素集的不同方法，然后介绍 `subset()` 函数以执行自定义条件选择：
- en: 'Select the second column of the `df_a` data frame:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `df_a` 数据框的第二列：
- en: '[PRE38]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The row-level indexing is left blank to indicate that all rows will be selected.
    We can also make it explicit by referencing all row-level indices:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 行级索引留空表示将选择所有行。我们也可以通过引用所有行级索引来明确表示：
- en: '[PRE39]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '>>> df_a$b'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '>>> df_a$b'
- en: 1 1 1
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 1 1
- en: '[PRE40]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Select the rows of `df_a` where column `a` is greater than two:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `df_a` 中列 `a` 大于两的行：
- en: '[PRE41]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that row index three is also shown as part of the output.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，行索引三也显示为输出的一部分。
- en: We can directly use column `a` within the context of the `subset()` function,
    saving us from using the `$` sign instead. We can also select the column by passing
    the column name to the `select` argument.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以直接在 `subset()` 函数的上下文中使用列 `a`，这样我们就不需要使用 `$` 符号了。我们也可以通过传递列名给 `select` 参数来选择列。
- en: 'Select column `b` where column `a` is greater than two in `df_a`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `df_a` 中选择列 `a` 大于两的列 `b`：
- en: '[PRE42]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Another typical operation in data analysis is sorting one or more variables
    of a data frame. Let’s see how it works in R.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析中的另一个典型操作是对数据框的一个或多个变量进行排序。让我们看看在 R 中它是如何工作的。
- en: Exercise 1.12 – sorting vectors and data frames
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.12 – 排序向量和数据框
- en: 'The `order()` function can be used to return the ranked position of the elements
    in the input vector, which can then be used to sort the elements via updated indexing:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`order()` 函数可以用来返回输入向量中元素的排名位置，然后可以通过更新索引对这些元素进行排序：'
- en: 'Create the `c(5,1,10)` vector in `vec_c` and sort it in ascending order:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `vec_c` 中创建 `c(5,1,10)` 向量，并按升序排序：
- en: '[PRE43]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Since the smallest element in `vec_c` is `1`, the corresponding ranked position
    is `1`. Similarly, `5` is set as the second rank and `10` as the third and highest
    rank. The ranked positions are then used to reshuffle and sort the original vector,
    the same as how we would select its elements via `order()` function ranks the
    elements in ascending order by default. What if we want to sort by descending
    order? We could simply add a minus sign to the input vector.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `vec_c` 中的最小元素是 `1`，相应的排名位置是 `1`。同样，`5` 被设置为第二排名，`10` 被设置为第三和最高排名。然后使用排名位置重新排列和排序原始向量，就像我们通过
    `order()` 函数按默认升序对元素进行排序一样。如果我们想按降序排序呢？我们只需在输入向量中添加一个负号即可。
- en: 'Sort the `df_a` data frame by column `a` in descending order:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按列 `a` 降序排序 `df_a` 数据框：
- en: '[PRE44]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Data frames will be the primary structures we will work with in this book.
    Let’s look at the last and most complex data structure: list.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框将是我们在本书中将主要使用的数据结构。让我们看看最后一个也是最复杂的数据结构：列表。
- en: List
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: A **list** is a flexible data structure that can hold different data types (numeric,
    integer, character, logical, factor, or even list itself), each possibly having
    a different length. It is the most complex structure we have introduced so far,
    gathering various objects in a structured way. To recap, let’s compare the four
    data structures in terms of the contents, data type, and length in *Figure 1**.8*.
    In general, all four structures can store elements of any data type. Vectors (one-dimensional
    array) and matrices (two-dimensional array) require the contents to be homogeneous
    data types. A data frame contains one or more vectors whose data types could differ,
    and a list could contain entries of different data types. Matrices and data frames
    follows a rectangular shape and so require the same length for each column. However,
    the entries in a list could be of arbitrary lengths (subject to memory constraint)
    different from each other.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**是一种灵活的数据结构，可以容纳不同类型的数据（数值、整数、字符、逻辑、因子，甚至列表本身），每个可能具有不同的长度。这是我们迄今为止引入的最复杂结构，以结构化的方式收集各种对象。为了回顾，让我们在
    *图 1**.8* 中比较四种数据结构的内容、数据类型和长度。一般来说，所有四种结构都可以存储任何数据类型的元素。向量（一维数组）和矩阵（二维数组）要求内容是同质数据类型。数据框包含一个或多个数据类型可能不同的向量，而列表可以包含不同数据类型的条目。矩阵和数据框遵循矩形形状，因此要求每列的长度相同。然而，列表中的条目可以具有任意长度（受内存限制），彼此不同。'
- en: '![Figure 1.8 – Comparing four different data structures in terms of contents,
    data type, and length](img/B18680_01_008..jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 比较四种不同数据结构的内容、数据类型和长度](img/B18680_01_008..jpg)'
- en: Figure 1.8 – Comparing four different data structures in terms of contents,
    data type, and length
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 比较四种不同数据结构的内容、数据类型和长度
- en: Let’s look at how to create a list.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个列表。
- en: Exercise 1.13 – creating a list
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.13 – 创建列表
- en: 'In this exercise, we will go through different ways to manipulate a list, including
    creating and renaming a list, and accessing, adding, and removing elements in
    a list:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过不同的方式操作列表，包括创建和重命名列表，以及访问、添加和删除列表中的元素：
- en: 'Create a list using the previous `a`, `vec_a`, and `df_a` variables:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的 `a`、`vec_a` 和 `df_a` 变量创建一个列表：
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The output shows that the list elements are indexed by double square brackets,
    which can be used to access the entries in the list.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出显示列表元素通过双方括号索引，可以用来访问列表中的条目。
- en: 'Access the second entry in the list, `ls_a`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问列表 `ls_a` 中的第二个条目：
- en: '[PRE46]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The default indices can also be renamed to enable entry selection by name.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认索引也可以重命名，以便通过名称选择条目。
- en: 'Rename the list based on the original names and access the `vec_a` variable:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据原始名称重命名列表并访问 `vec_a` 变量：
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can access a specific entry in the list by using the name either in square
    brackets or via the `$` sign.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过使用方括号或 `$` 符号中的名称来访问列表中的特定条目。
- en: 'Add a new entry named `new_entry` with the content `"test"` in the `ls_a` list:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ls_a` 列表中添加一个名为 `new_entry` 的新条目，内容为 `"test"`：
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The result shows that `"test"` is now added to the last entry of `ls_a`. We
    can also remove a specific entry by assigning `NULL` to it.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果显示 `"test"` 现已添加到 `ls_a` 的最后一个条目。我们还可以通过将其赋值为 `NULL` 来删除特定的条目。
- en: 'Remove the entry named `df_a` in `ls_a`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ls_a` 中删除名为 `df_a` 的条目：
- en: '[PRE49]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The entry named `df_a` is now successfully removed from the list. We can also
    update an existing entry in the list.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命名为 `df_a` 的条目现在已成功从列表中删除。我们还可以更新列表中的现有条目。
- en: 'Update the entry named `vec_a` to be `c(1,2)`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `vec_a` 的条目更新为 `c(1,2)`：
- en: '[PRE50]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The entry named `vec_a` is now successfully updated.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命名为 `vec_a` 的条目现在已成功更新。
- en: The flexibility and scalability of the list structure make it a popular choice
    for storing heterogeneous data elements, similar to the dictionary in Python.
    In the next section, we will extend our knowledge base by going over the control
    logic in R, which gives us more flexibility and precision when writing long programs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表结构的灵活性和可扩展性使其成为存储异构数据元素的流行选择，类似于 Python 中的字典。在下一节中，我们将通过了解 R 中的控制逻辑来扩展我们的知识库，这使我们编写长程序时具有更大的灵活性和精确度。
- en: Control logic in R
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 中的控制逻辑
- en: Relational and logical operators help compare statements as we add logic to
    the program. We can also add to the complexity by evaluating multiple conditional
    statements via loops that repeatedly iterate over a sequence of actions. This
    section will cover the essential relational and logical operators that form the
    building blocks of conditional statements.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关系和逻辑运算符帮助我们比较语句，当我们向程序添加逻辑时。我们还可以通过通过循环重复遍历一系列操作来评估多个条件语句，从而增加复杂性。本节将介绍构成条件语句构建块的基本关系和逻辑运算符。
- en: Relational operators
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系运算符
- en: We briefly covered a few relational operators such as `>=` and `==` earlier.
    This section will provide a detailed walkthrough on the use of standard relational
    operators. Let’s look at a few examples.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前简要介绍了几个关系运算符，如`>=`和`==`。本节将详细介绍标准关系运算符的使用。让我们看看一些例子。
- en: Exercise 1.14 – practicing with standard relational operators
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.14 – 练习使用标准关系运算符
- en: 'Relational operators allow us to compare two quantities and obtain the single
    result of the comparison. We will go over the following steps to learn how to
    express and use standard relational operators in R:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符允许我们比较两个量，并获得比较的单个结果。我们将学习以下步骤，了解如何在R中表达和使用标准关系运算符：
- en: 'Execute the following evaluations using the equality operator (`==`) and observe
    the output:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用等式运算符（`==`）执行以下评估并观察输出：
- en: '[PRE51]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The equality operator performs by strictly evaluating the two input arguments
    on both sides (including logical data) and only returns `TRUE` if they are equal.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等式运算符通过严格评估两侧（包括逻辑数据）的两个输入参数来执行，只有当它们相等时才返回`TRUE`。
- en: 'Execute the same evaluations using the inequality operator (`!=`) and observe
    the output:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不等式运算符（`!=`）执行相同的评估并观察输出：
- en: '[PRE52]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The inequality operator is the exact opposite of the equality operator.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不等式运算符与等式运算符正好相反。
- en: 'Execute the following evaluations using the greater than and less than operators
    (`>` and `<`) and observe the output:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大于和小于运算符（`>`和`<`）执行以下评估并观察输出：
- en: '[PRE53]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the second evaluation, the comparison between character data follows the
    pairwise alphabetical order of both strings starting from the leftmost character.
    In this case, the letter `s` comes after `c` and is encoded as a higher-valued
    numeric. In the third example, `TRUE` is converted into one and `FALSE` into zero,
    so returning a logical value of `TRUE`.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第二次评估中，字符数据之间的比较遵循从最左侧字符开始的两个字符串的成对字母顺序。在这种情况下，字母`s`排在`c`之后，并且被编码为更高数值的数字。在第三个例子中，`TRUE`被转换为1，`FALSE`被转换为0，因此返回一个逻辑值`TRUE`。
- en: 'Execute the following evaluations using the greater-than-or-equal-to operator
    (`>=`) and less-than-or-equal-to operator (`<=`) and observe the output:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大于等于运算符（`>=`）和小于等于运算符（`<=`）执行以下评估并观察输出：
- en: '[PRE54]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note that these operators consist of two conditional evaluations connected
    via an `OR` operator (`|`). We can, therefore, break it down into two evaluations
    in brackets, resulting in the same output as before:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这些运算符由两个条件评估通过`OR`运算符（`|`）连接而成。因此，我们可以将其分解为括号中的两个评估，从而得到与之前相同的输出：
- en: '[PRE55]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The relational operators also apply to vectors, which we encountered earlier,
    such as row-level filtering to subset a data frame.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关系运算符也适用于我们之前遇到的向量，例如行级筛选以子集化数据框。
- en: 'Compare `vec_a` with `1` using the greater-than operator:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大于运算符比较`vec_a`与`1`：
- en: '[PRE56]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We would get the same result by separately comparing each element and combining
    the resulting using `c()`.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过分别比较每个元素并使用`c()`函数组合结果来得到相同的结果。
- en: Logical operators
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: A `AND` (`&`), `OR` (`|`), and `NOT` (`!`). The `AND` operator returns `TRUE`
    only if both operands are `TRUE`, and the `OR` operator returns `TRUE` if at least
    one operand is `TRUE`. On the other hand, the `NOT` operator flips the evaluation
    result to the opposite.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`AND`（`&`）、`OR`（`|`）和`NOT`（`!`）。`AND`运算符仅在两个操作数都为`TRUE`时返回`TRUE`，而`OR`运算符如果至少有一个操作数为`TRUE`就返回`TRUE`。另一方面，`NOT`运算符将评估结果翻转至相反。'
- en: Let’s go through an exercise on the use of these logical operators.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个练习来了解这些逻辑运算符的使用。
- en: Exercise 1.15 – practicing using standard logical operators
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.15 – 练习使用标准逻辑运算符
- en: 'We will start with the `AND` operator, the most widely used control logic to
    ensure a specific action only happens if multiple conditions are satisfied at
    the same time:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最广泛使用的控制逻辑`AND`运算符开始，确保只有在多个条件同时满足时才会执行特定操作：
- en: 'Execute the following evaluations using the `AND` operator and observe the
    output:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `AND` 运算符执行以下评估并观察输出：
- en: '[PRE57]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The result shows that both conditions need to be satisfied to obtain a `TRUE`
    output.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果显示，需要满足两个条件才能获得 `TRUE` 输出。
- en: 'Execute the following evaluations using the `OR` operator and observe the output:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `OR` 运算符执行以下评估并观察输出：
- en: '[PRE58]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The result shows that the output is `TRUE` if at least one condition is evaluated
    as `TRUE`.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果显示，如果至少有一个条件评估为 `TRUE`，则输出为 `TRUE`。
- en: 'Execute the following evaluations using the `NOT` operator and observe the
    output:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `NOT` 运算符执行以下评估并观察输出：
- en: '[PRE59]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the third example, the evaluation is the same as `1 >= 0`, which returns
    `TRUE`. The `NOT` operator, therefore, reverses the evaluation result after the
    exclamation sign.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第三个例子中，评估与 `1 >= 0` 相同，返回 `TRUE`。因此，`NOT` 运算符在感叹号之后反转评估结果。
- en: These operators can also be used to perform pairwise logical evaluations in
    vectors.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些运算符也可以用于在向量中执行成对逻辑评估。
- en: 'Execute the following evaluations and observe the output:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下评估并观察输出：
- en: '[PRE60]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There is also a long-form for the `AND` (`&&`) and the `OR` (`||`) logical operators.
    Different from the element-wise comparison in the previous short-form, the long-form
    is used to evaluate only the first element of each input vector, and such evaluation
    continues only until the result is determined. In other words, the long-form only
    returns a single result when evaluating two vectors of multiple elements. It is
    most widely used in modern R programming control flow, especially in the conditional
    `if` statement.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AND` (`&&`) 和 `OR` (`||`) 逻辑运算符也有长格式。与之前短格式中的逐元素比较不同，长格式仅用于评估每个输入向量的第一个元素，并且这种评估仅继续到结果确定为止。换句话说，长格式在评估包含多个元素的向量时仅返回单个结果。它在现代
    R 编程控制流中应用最广泛，尤其是在条件 `if` 语句中。
- en: 'Let’s look at the following example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Both evaluations are based on the first element of each vector. That is, the
    second element of each vector is ignored in both evaluations. This offers computational
    benefit, especially when the vectors are large. Since there is no point in continuing
    the evaluation if the final result can be obtained by evaluating the first element,
    we can safely discard the rest.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 两次评估都基于每个向量的第一个元素。也就是说，在两次评估中，每个向量的第二个元素都被忽略。这提供了计算上的好处，尤其是在向量很大时。由于如果可以通过评估第一个元素获得最终结果，就没有必要继续评估，因此我们可以安全地丢弃其余部分。
- en: In the first evaluation using `&&`, comparing the first element of the two vectors
    (`TRUE` and `FALSE`) returns `FALSE`, while continuing the comparison of the second
    element will also return `FALSE`, so the second comparison is unnecessary. In
    the second evaluation using `||`, comparing the first element (`TRUE | FALSE`)
    gives `TRUE`, saving the need to make the second comparison, as the result will
    always be evaluated as `TRUE`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次使用 `&&` 进行评估时，比较两个向量的第一个元素（`TRUE` 和 `FALSE`）返回 `FALSE`，而继续比较第二个元素也将返回 `FALSE`，因此第二次比较是不必要的。在第二次使用
    `||` 进行评估时，比较第一个元素（`TRUE | FALSE`）给出 `TRUE`，这样就无需进行第二次比较，因为结果始终会被评估为 `TRUE`。
- en: Conditional statements
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'A `if-else` statement, is used to combine the result of multiple logical operators
    and decide the flow of follow-up actions. It is commonly used to increase the
    complexity of large R programs. The `if-else` statement follows a general structure
    as follows, where the evaluation condition is first validated. If the validation
    returns `TRUE`, the expression within the curve braces of the `if` clause would
    be executed and the rest of the code is ignored. Otherwise, the expression within
    the `else` clause would be executed:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else` 语句用于组合多个逻辑运算符的结果并决定后续动作的流程。它通常用于增加大型 R 程序的复杂性。`if-else` 语句遵循以下一般结构，其中首先验证评估条件。如果验证返回
    `TRUE`，则执行 `if` 子句中的花括号内的表达式，其余代码将被忽略。否则，将执行 `else` 子句中的表达式：'
- en: '[PRE62]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Let’s go through an exercise to see how to use the `if-else` control statement.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一项练习来看看如何使用 `if-else` 控制语句。
- en: Exercise 1.16 – practicing using the conditional statement
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.16 – 练习使用条件语句
- en: 'Time for another exercise! Let’s practice using the conditional statement:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 时间进行另一项练习！让我们练习使用条件语句：
- en: 'Initialize an `x` variable with a value of `1` and write an `if-else` condition
    to determine the output message. Print out `"positive"` if `x` is greater than
    zero, and `"not` `positive"` otherwise:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个值为 `1` 的 `x` 变量，并编写一个 `if-else` 条件来决定输出消息。如果 `x` 大于零，则打印出 `"positive"`，否则打印
    `"not positive"`：
- en: '[PRE63]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The condition within the `if` clause evaluates to be `TRUE`, and the code inside
    is executed, printing out `"positive"` in the console. Note that the `else` branch
    is optional and can be removed if we only intend to place one check to the input.
    Additional `if-else` control can also be embedded within a branch.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if` 子句中的条件评估为 `TRUE`，并且其中的代码被执行，在控制台打印出 `"positive"`。注意，`else` 分支是可选的，并且如果只想对输入进行一个检查，则可以将其删除。额外的
    `if-else` 控制也可以嵌入到一个分支中。'
- en: We can also add additional branches using the `if-else` conditional control
    statement, where the middle part can be repeated multiple times.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以使用 `if-else` 条件控制语句添加额外的分支，其中中间部分可以重复多次。
- en: 'Initialize an `x` variable with `0` and write a control flow to determine and
    print out its sign:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个值为 `0` 的 `x` 变量，并编写一个控制流程来确定并打印其符号：
- en: '[PRE64]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As the conditions are sequentially evaluated, the second statement returns `TRUE`
    and so prints out `"zero"`.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于条件是依次评估的，第二个语句返回 `TRUE` 并因此打印出 `"zero"`。
- en: Loops
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'A `if` statement; the codes will only be executed if the condition evaluates
    to be `TRUE`. The only difference is that a loop will continue to iteratively
    execute the code as long as the condition is `TRUE`. There are two types of loops:
    the `while` loop and the `for` loop. The `while` loop is used when the number
    of iterations is unknown, and the termination relies on either the evaluation
    condition or a separated condition within the running expression using the `break`
    control statement. The `for` loop is used when the number of iterations is known.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `if` 语句；只有当条件评估为 `TRUE` 时，代码才会被执行。唯一的区别是，循环会继续迭代执行代码，只要条件为 `TRUE`。有两种类型的循环：`while`
    循环和 `for` 循环。`while` 循环用于迭代次数未知的情况，其终止依赖于评估条件或使用 `break` 控制语句在运行表达式中的分离条件。`for`
    循环用于迭代次数已知的情况。
- en: 'The `while` loop follows a general structure as follows, where `condition 1`
    first gets evaluated to determine the expression within the outer curly braces
    that should be executed. There is an (optional) `if` statement to decide whether
    the `while` loop needs to be terminated based on `condition 2`. These two conditions
    control the termination of the `while` loop, which exits the execution as long
    as any one condition evaluates as `TRUE`. Inside the `if` clause, `condition 2`
    can be placed anywhere within the `while` block:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环遵循以下一般结构，其中首先评估 `condition 1` 以确定应该执行的外部花括号内的表达式。有一个（可选的）`if` 语句来决定是否根据
    `condition 2` 需要终止 `while` 循环。这两个条件控制 `while` 循环的终止，只要任一条件评估为 `TRUE`，循环就会退出执行。在
    `if` 子句中，`condition 2` 可以放置在 `while` 块内的任何位置：'
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that `condition 1` within the `while` statement needs to be `FALSE` at
    some point; otherwise, the loop will continue indefinitely, which may cause a
    session expiry error within RStudio.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`while` 语句中的 `condition 1` 需要在某个时刻为 `FALSE`；否则，循环将无限期地继续，这可能导致 RStudio 中的会话过期错误。
- en: Let’s go through an exercise to look at how to use the `while` loop.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个练习来看看如何使用 `while` 循环。
- en: Exercise 1.17 – practicing the while loop
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.17 – 练习 while 循环
- en: 'Let’s try out the `while` loop:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下 `while` 循环：
- en: 'Initialize an `x` variable with a value of `2` and write a `while` loop. If
    `x` is less than `10`, square it and print out its value:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个值为 `2` 的 `x` 变量，并编写一个 `while` 循环。如果 `x` 小于 `10`，则平方它并打印其值：
- en: '[PRE66]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `while` loop is executed twice, bringing the value of `x` from `2` to `16`.
    During the third evaluation, `x` is above 10 and the conditional statement evaluates
    to be `FALSE`, thus exiting the loop. We can also print out `x` to double-check
    its value:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`while` 循环执行了两次，将 `x` 的值从 `2` 增加到 `16`。在第三次评估中，`x` 大于 10，条件语句评估为 `FALSE`，因此退出循环。我们也可以打印出
    `x` 来双重检查其值：'
- en: '[PRE67]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add a condition after the squaring to exit the loop if `x` is greater than
    10:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在平方之后添加一个条件，如果 `x` 大于 `10` 则退出循环：
- en: '[PRE68]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Only one number is printed out this time. The reason is that when `x` is changed
    to `16`, the `if` condition evaluates to be `TRUE`, thus triggering the `break`
    statement to exit the `while` loop and ignore the `print()` statement. Let’s verify
    the value of `x`:'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次只打印出一个数字。原因是当`x`变为`16`时，`if`条件评估为`TRUE`，从而触发`break`语句退出`while`循环并忽略`print()`语句。让我们验证`x`的值：
- en: '[PRE69]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let’s look at the `for` loop, which assumes the following general structure.
    Here, `var` is a placement to sequentially reference the contents in `sequence`,
    which can be a vector, a list, or another data structure:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`for`循环，它假设以下一般结构。在这里，`var`是一个用于按顺序引用`sequence`内容的占位符，`sequence`可以是一个向量、一个列表或其他数据结构：
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The same expression will be evaluated for each unique variable in `sequence`,
    unless an explicit `if` condition is triggered to either exit the loop using `break`,
    or skip the rest of the code and immediately jump to the next iteration using
    `next`. Let’s go through an exercise to put these in perspective.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`sequence`中的每个唯一变量，相同的表达式将被评估，除非触发一个显式的`if`条件，使用`break`退出循环，或者跳过剩余的代码并立即跳转到下一个迭代使用`next`。让我们通过一个练习来了解这些概念。
- en: Exercise 1.18 – practicing using the for loop
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1.18 – 练习使用for循环
- en: 'Next, let’s try the `for` loop:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试`for`循环：
- en: 'Create a vector to store three strings (`statistics`, `and`, and `calculus`)
    and print out each element:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个向量来存储三个字符串（`statistics`、`and`和`calculus`），并打印出每个元素：
- en: '[PRE71]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here, the `for` loop iterates through each element in the `string_a` vector
    by sequentially assigning the element value to the `i` variable at each iteration.
    We can also choose to iterate using the vector index, as follows:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`for`循环通过在每个迭代中将元素值按顺序分配给`i`变量来遍历`string_a`向量中的每个元素。我们也可以选择使用向量索引进行迭代，如下所示：
- en: '[PRE72]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we created a series of integer indexes from `1` up to the length of the
    vector and assigned them to the `i` variable in each iteration, which is then
    used to reference the element in the `string_a` vector. This is a more flexible
    and versatile way of referencing elements in a vector since we can also use the
    same index to reference other vectors. Directly referencing the element as in
    the previous approach is more concise and readable. However, it lacks the level
    of control and flexibility without the looping index.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一系列从`1`到向量长度的整数索引，并将它们分配给每个迭代的`i`变量，然后使用它来引用`string_a`向量中的元素。这是一种更灵活和多变的方式来引用向量中的元素，因为我们也可以使用相同的索引来引用其他向量。直接引用元素，如前一种方法，更简洁、更易读。然而，它缺乏没有循环索引的控制和灵活性。
- en: 'Add a condition to break the loop if the current element is `"and"`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个条件，如果当前元素是`"and"`，则退出循环：
- en: '[PRE73]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The loop is exited upon satisfying the `if` condition when the current value
    in `i` is `"and"`.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`i`的当前值是`"and"`时，满足`if`条件将退出循环。
- en: 'Add a condition to jump to the next iteration if the current element is `"and"`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个条件，如果当前元素是`"and"`，则跳到下一个迭代：
- en: '[PRE74]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: When the next statement is evaluated, the following `print()` function is ignored,
    and the program jumps to the next iteration, printing only `"statistics"` and
    `"calculus"` with the `"``and"` element.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当下一个语句被评估时，下面的`print()`函数将被忽略，程序跳到下一个迭代，只打印出`"statistics"`和`"calculus"`以及`"``and"`元素。
- en: 'So far, we have covered some of the most fundamental building blocks in R.
    We are now ready to come to the last and most widely used building block: functions.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了R语言中最基础的构建块。现在，我们准备进入最后一个也是最广泛使用的构建块：函数。
- en: Exploring functions in R
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索R语言中的函数
- en: 'A `sum()` and `mean()` functions we used in the previous exercise. We can also
    define our own function to operate as an interface that processes a given input
    signal and produces an output. See *Figure 1**.9* for an illustration:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的练习中使用过的`sum()`和`mean()`函数。我们也可以定义自己的函数，作为处理给定输入信号并产生输出的接口。参见*图1**.9*以了解说明：
- en: '![Figure 1.9 – Illustration of a function’s workflow](img/B18680_01_009..jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 函数工作流程的说明](img/B18680_01_009..jpg)'
- en: Figure 1.9 – Illustration of a function’s workflow
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 函数工作流程的说明
- en: 'A function can be created using the `function` keyword with the following format:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`function`关键字创建一个函数，其格式如下：
- en: '[PRE75]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'A function can be decomposed into the following parts:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以分解为以下部分：
- en: '**Function name**: The name of the functional object registered and stored
    in the R environment. We use this name followed by a pair of parentheses and (optionally)
    input arguments within the parentheses to call the function.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数名**：在 R 环境中注册并存储的函数对象的名称。我们使用此名称后跟一对括号，并在括号内（可选）输入参数来调用函数。'
- en: '**Input argument**: A placeholder used to receive input value when calling
    the function. An argument can be optional (with a default value assigned) or compulsory
    (with no default value assigned). Setting all arguments as optional is the same
    as requiring no compulsory input arguments for the function. However, we will
    need to pass a specific value to a compulsory argument in order to call the function.
    In addition, the optional argument can also appear after the compulsory argument,
    if any.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入参数**：在调用函数时用于接收输入值的占位符。参数可以是可选的（已分配默认值）或必选的（未分配默认值）。将所有参数都设置为可选的等同于函数不需要必选输入参数。然而，我们需要向必选参数传递一个特定值才能调用函数。此外，如果有的话，可选参数也可以出现在必选参数之后。'
- en: '**Function body**: This is the area where the main statement is executed to
    complete a specific action and fulfill the purpose of the function.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数体**：这是执行主要语句以完成特定操作并实现函数目的的区域。'
- en: '`return()` function.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return()` 函数。'
- en: Let’s go through an exercise on creating a user-defined function.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个创建用户定义函数的练习来了解。
- en: Exercise 1.19 – creating a user-defined function
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1.19 – 创建用户定义的函数
- en: 'Now, let’s try it out:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试试看：
- en: 'Create a function named `test_func` to receive an input and print out `"(input)
    is fun"`. Allow the option to print the message in uppercase:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `test_func` 的函数，用于接收输入并打印出 `"(input) is fun"`。允许选择将消息打印为大写：
- en: '[PRE76]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that we used the `=` sign instead of `<-` to assign the functional object
    to the `test_func` variable. However, the latter is more commonly observed when
    creating functions in R. In the input, we created two arguments: the compulsory
    argument, `x`, to receive the message to be printed, and the optional argument,
    `cap`, to determine whether the message needs to be converted into uppercase.
    The optional argument means that the user can either go with the default setting
    (that is, a lowercase message) by not supplying anything to this argument or overwrite
    the default behavior by explicitly passing in a value.'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用 `=` 符号而不是 `<-` 来将函数对象赋值给 `test_func` 变量。然而，在 R 中创建函数时，后者更为常见。在输入中，我们创建了两个参数：必选参数
    `x`，用于接收要打印的消息，以及可选参数 `cap`，用于确定消息是否需要转换为大写。可选参数意味着用户可以选择不提供任何内容给此参数，以使用默认设置（即小写消息），或者通过显式传递一个值来覆盖默认行为。
- en: In the function body, we first create a `msg` variable and assign the message
    content by calling the `paste()` function, a built-in function to concatenate
    the two input arguments. If the `cap` argument is `FALSE`, the `if` statement
    will evaluate to `FALSE` and `msg` will be directly returned as the function’s
    output. Otherwise, the statement within the `if` clause will be triggered to convert
    the `msg` variable into uppercase using the `toupper()` function, another built-in
    function in R.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在函数体中，我们首先创建一个 `msg` 变量，并通过调用 `paste()` 函数（一个用于连接两个输入参数的内置函数）来分配消息内容。如果 `cap`
    参数为 `FALSE`，则 `if` 语句将评估为 `FALSE`，`msg` 将直接作为函数的输出返回。否则，将触发 `if` 子句中的语句，使用 `toupper()`
    函数（R 中的另一个内置函数）将 `msg` 变量转换为大写。
- en: 'Let’s see what happens after calling the function in different ways:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看以不同方式调用函数后会发生什么：
- en: '[PRE77]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The first two cases work as expected. In the third case, we did not supply any
    value to the `x` argument, defined as a compulsory argument. This leads to an
    error and fails to call the function.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前两种情况按预期工作。在第三种情况下，我们没有为定义为必选参数的 `x` 参数提供任何值。这导致错误，并未能调用函数。
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the essential building blocks in R, including how
    to leverage and navigate the RStudio IDE, basic arithmetic operations (addition,
    subtraction, multiplication, division, exponentiation, and modulo), common data
    structures (vectors, matrices, data frames, and lists), control logic, including
    relational operators (`>`, `==`, `<`, `>=`, `<=`, and `!=`) and logical operators
    (`&`, `|`, `!`, `&&`, and `||`), conditional statements using `ifelse`, the `for`
    and `while` loops, and finally, functions in R. Understanding these fundamental
    aspects will greatly benefit our learning in later chapters as we gradually introduce
    more challenging topics.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了R语言的基本构建块，包括如何利用和导航RStudio IDE，基本的算术运算（加法、减法、乘法、除法、指数和取模），常见的数据结构（向量、矩阵、数据框和列表），控制逻辑，包括关系运算符（`>`、`==`、`<`、`>=`、`<=`和`!=`）和逻辑运算符（`&`、`|`、`!`、`&&`和`||`），使用`ifelse`的条件语句，`for`和`while`循环，以及最后，R语言中的函数。理解这些基本方面将极大地促进我们在后续章节中的学习，因为我们将逐渐引入更具挑战性的主题。
- en: In the next chapter, we will cover `dplyr`, one of the most widely used libraries
    for data processing and manipulation. Tapping into the various utility functions
    provided by `dplyr` will make it much easier to handle most data processing tasks.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍`dplyr`，这是数据处理和操作中最广泛使用的库之一。利用`dplyr`提供的各种实用函数将使处理大多数数据处理任务变得更加容易。
