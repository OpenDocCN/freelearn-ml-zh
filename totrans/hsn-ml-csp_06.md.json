["```py\nnetwork = new DistanceNetwork(3, 100 * 100);\n```", "```py\nprivate void RandomizeNetwork()\n         {\n             if (network != null)\n             {\n                 foreach (var neuron in (network?.Layers.SelectMany(layer\n                   => layer?.Neurons)).Where(neuron => neuron != null))\n                     neuron.RandGenerator = \n                       new UniformContinuousDistribution\n                       (new Range(0, 255));\n\n                 network?.Randomize();\n             }\n\n             UpdateMap();\n         }\n```", "```py\nSOMLearning trainer = new SOMLearning(network);\n             double[] input = new double[3];\n             double fixedLearningRate = learningRate / 10;\n             double driftingLearningRate = fixedLearningRate * 9;\n             int i = 0;\n\n             while (!needToStop)\n             {\n                 trainer.LearningRate = driftingLearningRate \n                   * (iterations - i)\n                   / iterations + fixedLearningRate;\n                 trainer.LearningRadius = radius * (iterations - i) \n                   / iterations;\n\n                 if (rand != null)\n                 {\n                     input[0] = rand.Next(256);\n                     input[1] = rand.Next(256);\n                     input[2] = rand.Next(256);\n                 }\n\n                 trainer.Run(input);\n\n                 // update map once per 50 iterations\n                 if ((i % 10) == 9)\n                 {\n                     UpdateMap();\n                 }\n\n                 i++;\n\n                 SetText(currentIterationBox, i.ToString());\n\n                 if (i >= iterations)\n                     break;\n             }\n```", "```py\nSOMLearning trainer = new SOMLearning(network);\n```", "```py\n                if (rand != null)\n                 {\n                     input[0] = rand.Next(256);\n                     input[1] = rand.Next(256);\n                     input[2] = rand.Next(256);\n                 }\n```", "```py\ntrainer.LearningRate = driftingLearningRate * (iterations - i) /\n  iterations + fixedLearningRate;\ntrainer.LearningRadius = radius * (iterations - i) / iterations;\n```", "```py\nRILogManager.Default.ViewerSendWatch(\"Learning Rate\", $\"{trainer.LearningRate}\");\nRILogManager.Default.ViewerSendWatch(\"Learning Radius\", $\"{trainer.LearningRadius}\");\nRILogManager.Default.ViewerSendWatch(\"Red\", $\"{RGBInput[0]}\");\nRILogManager.Default.ViewerSendWatch(\"Green\", $\"{RGBInput[1]}\");\nRILogManager.Default.ViewerSendWatch(\"Blue\", $\"{RGBInput[2]}\");\n```", "```py\nRILogManager.Default.SendDebug($\"Red {RGBInput[0]}, Green {RGBInput[1]}, Blue \n  {RGBInput[2]}\");\n```", "```py\ntrainer.Run(RGBInput);\n```", "```py\nDistanceNetwork network = new DistanceNetwork(2, networkSize \n  * networkSize);\n\n             // set random generators range\n             foreach (var neuron in network.Layers.SelectMany(layer =>\n               layer.Neurons))\n                 neuron.RandGenerator = new UniformContinuousDistribution(\n                     new Range(0, Math.Max\n                       (pointsPanel.ClientRectangle.Width,\n                       pointsPanel.ClientRectangle.Height)));\n\n             // create learning algorithm\n             SOMLearning trainer = new SOMLearning(network, networkSize, \n               networkSize);\n\n             // create map\n             map = new int[networkSize, networkSize, 3];\n\n             double fixedLearningRate = learningRate / 10;\n             double driftingLearningRate = fixedLearningRate * 9;\n\n             // iterations\n             int i = 0;\n\n             // loop\n             while (!needToStop)\n             {\n                 trainer.LearningRate = driftingLearningRate \n                   * (iterations - i) / iterations + fixedLearningRate;\n                 trainer.LearningRadius = (double)learningRadius * \n                   (iterations - i) / iterations;\n\n                 // run training epoch\n                 trainer.RunEpoch(trainingSet);\n\n                 // update map\n                 UpdateMap(network);\n\n                 // increase current iteration\n                 i++;\n\n                 // set current iteration's info\n                 SetText(currentIterationBox, i.ToString());\n\n                 // stop ?\n                 if (i >= iterations)\n                     break;\n             }\n```", "```py\n            // get first layer\n             Layer layer = network.Layers[0];\n\n             // lock\n             Monitor.Enter(this);\n\n             // run through all neurons\n             for (int i = 0; i < layer.Neurons.Length; i++)\n             {\n                 Neuron neuron = layer.Neurons[i];\n\n                 int x = i % networkSize;\n                 int y = i / networkSize;\n\n                 map[y, x, 0] = (int)neuron.Weights[0];\n                 map[y, x, 1] = (int)neuron.Weights[1];\n                 map[y, x, 2] = 0;\n             }\n\n             // collect active neurons\n             for (int i = 0; i < pointsCount; i++)\n             {\n                 network.Compute(trainingSet[i]);\n                 int w = network.GetWinner();\n\n                 map[w / networkSize, w % networkSize, 2] = 1;\n             }\n\n             // unlock\n             Monitor.Exit(this);\n\n             //\n             mapPanel.Invalidate();\n```", "```py\npublic int GetWinner()\n{\n// find the MIN value\ndouble min = output[0];\nint minIndex = 0;\nfor (int i = 1; i < output.Length; i++)\n{\nif (output[i] < min)\n{\n// found new MIN value\nmin = output[i];\nminIndex = i;\n}\n}\nreturn minIndex;\n}\n```"]