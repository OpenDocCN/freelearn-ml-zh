- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Visualization with ggplot2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter covered intermediate data processing techniques, focusing
    on dealing with string data. When the raw data has been transformed and processed
    into a clean and structured shape, we can take the analysis to the next level
    by visualizing the clean data in a graph, which we aim to accomplish in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to plot standard graphs using the
    `ggplot2` package and add customizations to present excellent visuals.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing `ggplot2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the grammar of graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geometries in graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling themes in graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the exercises in this chapter, you will need to have the latest
    versions of the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ggplot2` package, version 3.3.6\. Alternatively, install the `tidyverse`
    package and load `ggplot2` directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ggthemes` package, version 4.2.4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The versions mentioned along with the packages in the preceding list are the
    latest ones while I am writing this book.
  prefs: []
  type: TYPE_NORMAL
- en: All the code and data for this chapter is available at [https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/tree/main/Chapter_4](https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/tree/main/Chapter_4).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ggplot2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conveying information via graphs tends to be more effective and visually appealing
    than tables alone. After all, humans are much quicker at processing visual information,
    such as recognizing a car in an image. In building **machine learning** (**ML**)
    models, we are often interested in the training and test loss profile in the form
    of a line chart that indicates the reduction in the training and test set loss
    as the model gets trained for a more extended period. Observing performance metrics
    helps us better diagnose whether a model is **underfitting** or **overfitting**—in
    other words, whether the current model is too simple or overly complex. Note that
    the test set is used to approximate a future dataset, and minimizing the test
    set error helps the model generalize to new datasets, an approach known as **empirical
    risk minimization**. Underfitting refers to the case when the model does poorly
    in both training and test sets due to insufficient fitting power, while overfitting
    means the model does well in the training set but not in the test set due to an
    overly complex model. Both underfitting and overfitting lead to high error frequency
    on the test set and thus low generalization power.
  prefs: []
  type: TYPE_NORMAL
- en: Good visualization skills are also a signpost of a good communicator. Creating
    good visualizations requires carefully designing the interface while satisfying
    the technical constraints regarding what is achievable. When tasked with building
    an ML model, most of the time is often spent on data processing, model development,
    and fine-tuning, only leaving a disproportionately small amount of time to communicate
    the modeling results to stakeholders. Effective communication means that an ML
    model, albeit a black-box solution for people outside this field, could still
    be transparently and adequately explained to and understood by its internal users.
    Meaningful and powerful visualizations created by various offerings from `ggplot2`,
    the specific package from the `tidyverse` ecosystem that focuses on graphing,
    serve as an excellent enabler to effective communication; the outputs are generally
    more visually engaging and attractive than the default plotting options offered
    by base R. After all, creating good visualizations will be an essential skill
    as you climb up the corporate ladder and think more from the audience’s perspective.
    Good presentation skills will become equally important to (if not more important
    than) your technical skills?, such as model development.
  prefs: []
  type: TYPE_NORMAL
- en: This section will show you how to achieve good visual communication by building
    simple yet powerful plots using the `ggplot2` package. It will help demystify
    modern visualization techniques using R and prepare you for more advanced visualization
    techniques. We will start with a simple scatter plot example and introduce the
    basic plotting grammar of the `ggplot2` package using the `mtcars` dataset, which
    contains a set of automobile-related observations and is automatically loaded
    in the working environment when loading `ggplot2`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a scatter plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A scatter plot is a two-dimensional plot where the value of the two variables,
    often numeric in type, uniquely determines each dot on the plot. It is the go-to
    plot when we want to assess the relationship between two numeric variables.
  prefs: []
  type: TYPE_NORMAL
- en: Let us go through an exercise to plot the relationship between the number of
    cylinders (the `cyl` variable) in a car and the miles per gallon (the `mpg` variable)
    using the `mtcars` dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.1 – Building a scatter plot using the mtcars dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will first examine the structure of the `mtcars` dataset
    and generate a bivariate scatter plot using `ggplot2`. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load and examine the structure of the `mtcars` dataset, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result shows that the `mtcars` DataFrame contains 32 rows and 11 columns,
    a relatively small and structured dataset that is easy to work with. Next, we
    will plot the relationship between `cyl` and `mpg`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `ggplot()` and `geom_point()` functions to generate a scatter plot
    based on the `cyl` and `mpg` variables. Enlarge the size of the title and text
    for the plot along both axes using the `theme` layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As shown in *Figure 4**.1*, the generated result contains 32 dots whose positions
    are uniquely determined by a combination of `cyl` and `mpg`. The screenshot suggests
    a decreasing trend in the value of `mpg` as `cyl` increases, although the within-group
    variation is also pronounced across the three groups of `cyl`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Scatter plot between cyl and mpg](img/B18680_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Scatter plot between cyl and mpg
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `aes()` function maps `cyl` to the *x* axis and `mpg` to the *y*
    axis. When the mapping relationship is not explicitly shown, we often assume that
    the first argument corresponds to the horizontal axis and the second to the vertical
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script used to generate the scatter plot consists of two high-level functions:
    `ggplot()` and `geom_point()`. The `ggplot()` function specifies the dataset to
    be used in the first argument and the variables to be respectively plotted on
    the two axes in the second argument, wrapped using the `aes()` function (more
    on this later). The `geom_point()` function enforces the display to be in a scatter
    plot. These two functions are chained together via a particular `+` operator,
    indicating overlaying the second layer of operation to the first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that the `cyl` variable is treated as numeric by `ggplot()`, as
    shown by the additional labels of `5` and `7` on the horizontal axis. We can verify
    the distinct values of `cyl` via the `unique()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Apparently, we need to treat it as a categorical variable to avoid unwanted
    interpolation between different values. This can be achieved by wrapping the `cyl`
    variable via the `factor()` function, which converts the input argument to a categorical
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot is shown in *Figure 4**.2*. By explicitly converting `cyl`
    to a categorical variable, the horizontal axis correctly indicates a distribution
    of dots for each unique value of `cyl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Scatter plot after converting cyl to a categorical variable](img/B18680_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Scatter plot after converting cyl to a categorical variable
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we have learned how to build a scatter plot by passing in the
    variables of interest after converting to the desired type. This works similarly
    to other kinds of plots, which observe a standard set of grammatical rules. Next,
    we will go through these fundamental rules to understand their commonalities.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the grammar of graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous example contained the three essential layers that need to be specified
    when plotting a graph: **data**, **aesthetics**, and **geometries**. The primary
    purpose of each layer is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The data layer specifies the dataset to be plotted. This corresponds to the
    `mtcars` dataset we specified earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aesthetics layer specifies the scale-related items that map the variables
    to the visual properties of the plot. Examples include the variables to be shown
    for the *x* axis and *y* axis, the size and color, and other plot aesthetics.
    This corresponds to the `cyl` and `mpg` variables we specified earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The geometry layer specifies the visual elements used for the data, such as
    presenting the data via points, lines, or other forms. The `geom_point()` command
    we set in the previous example tells the plot to be shown as a scatter plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other layers, such as the theme layer, also help beautify the plot, which we
    will cover later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `geom_point()` layer from the previous example also suggests that we could
    easily switch to another type of plot by changing the keyword after the underscore.
    For example, as shown in the following code snippet, we can show the scatter plot
    as a boxplot for each unique value of `cyl` using the `geom_boxplot()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.3*, which visualizes
    a set of points as a boxplot for each distinct value of `cyl`. Employing a boxplot
    is an excellent way to detect outliers, such as the two extreme points lying outside
    the third boxplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Visualizing the same plot using a boxplot](img/B18680_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Visualizing the same plot using a boxplot
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we could change the color and size of the points in the previous
    scatter plot by tweaking the aesthetics layer. Let us go through an exercise to
    see how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.2 – Changing the color and size of points in a scatter plot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the aesthetics layer to modify the color and
    size of the points displayed in the last scatter plot based on the `disp` and
    `hp` variables. The `disp` variable measures the engine displacement, and the
    `hp` variable indicates the gross horsepower. The points will thus vary in color
    and size given different values of `disp` and `hp`. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the color of the points in the scatter plot by passing `disp` to the
    `color` argument in the `aes()` function. Enlarge the `size` parameter of the
    legend as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will generate the output shown in *Figure 4**.4*, where
    the color gradient of each point changes based on the value of `disp`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Adding color to the scatter plot](img/B18680_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Adding color to the scatter plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the size of the points in the scatter plot by passing `hp` to the `size`
    argument in the `aes()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will generate the output shown in *Figure 4**.5*, where
    the size of each point also changes based on the value of `hp`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Changing point size in the scatter plot](img/B18680_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Changing point size in the scatter plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the plot now looks more enriched, be careful when adding dimensions
    to a single plot. In our current example, the single plot contains four dimensions
    of information: `cyl`, `mpg`, `disp`, and `hp`. Human brains are adept at processing
    two- or three-dimensional visuals but may struggle when presented with higher
    dimensions of graphs. The presentation style depends on what message we want to
    convey to our audience. Instead of lumping all dimensions together, building a
    separate plot with just two or three variables for illustration may be more effective.
    Remember—effective communication in model development lies in the quality of the
    message to the audience and not in the richness of the visual output.'
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise will let us look at the individual components of different
    layers in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.3 – Building a scatter plot with smooth curve fitting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will build a scatter plot and fit a smooth curve that
    passes through the points. Adding a smooth curve helps us detect the overall pattern
    among the points and is achieved using the `geom_smooth()` function. Proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a scatter plot using `hp` and `mpg` with smooth curve fitting using `geom_smooth()`
    and coloring using `disp`, and adjust the opacity of the points by setting `alpha=0.6`
    in `geom_point()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding command generates the output shown in *Figure 4**.6*,
    where the central blue curve represents a model that best fits the points and
    the surrounding bounds indicate the uncertainty interval. We will discuss more
    on the concept of a model in a later chapter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Fitting a smooth curve among the points in a scatter plot](img/B18680_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Fitting a smooth curve among the points in a scatter plot
  prefs: []
  type: TYPE_NORMAL
- en: Since the graphics are based on the concept of additive layers, we can also
    generate a plot by starting with some components, storing them in a variable,
    and then furnishing the graph variable with additional components. Let us see
    how this is done in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a scatter plot using `hp` and `mpg` with the same opacity level and store
    the plot in the `plt` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As shown in *Figure 4**.7*, directly printing out `plt` generates a working
    plot, which suggests that a plot can also be stored as an object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Generating a scatter plot using hp and mpg](img/B18680_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Generating a scatter plot using hp and mpg
  prefs: []
  type: TYPE_NORMAL
- en: 'Color the points using `disp` and add a smooth curve fitting to the previous
    plot, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running these commands will generate the same plot as the one shown in *Figure
    4**.6*. Therefore, we can build a base plot, save it in a variable, and adjust
    its visual properties by adding extra layer specifications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also exercise more refined control over the size, shape, and color of
    the points in a scatter plot, all achieved by specifying the relevant arguments.
    Let us see how this can be completed in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.4 – Controlling the size, shape, and color of points in a scatter
    plot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will experiment with different input parameters to control
    a few visual properties of the points in the scatter plot. These controls are
    provided by the `geom_point()` function. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a scatter plot between `hp` and `mpg`, and color the points using
    `disp`. Show the points as circles of size `4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will generate the output shown in *Figure 4**.8*, where
    we see that the points are enlarged to be circles of different colors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Generating the same scatter plot with bigger-sized circles as
    points](img/B18680_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Generating the same scatter plot with bigger-sized circles as points
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that setting `shape=1` in `geom_point()` presents the points as circles.
    We could show them in other forms by changing this argument. For example, the
    following command visualizes the points as triangles of a smaller size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is shown in *Figure 4**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Visualizing the points as triangles in the scatter plot](img/B18680_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Visualizing the points as triangles in the scatter plot
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how to make the scatter plot more visually appealing by
    filling in the inner color of the points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the color of the previous scatter plot using `cyl` (after converting
    it to a factor type) in the `aes()` function, and set the `shape` parameter to
    `21`, `size` to `5`, and transparency (via `alpha`) to `0.6` in the `geom_point()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Looking at the output in *Figure 4**.10*, the plot now looks more visually
    appealing, where three groups of points are spread across different ranges of
    `hp` and `mpg`. A shrewd reader may wonder why we are setting `shape=21` when
    the points are still visualized as circles. This is because `21` is a special
    value that allows the inner color of circles to be filled, along with their outlines
    or outer color:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Filling the inner color of the points in the scatter plot](img/B18680_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Filling the inner color of the points in the scatter plot
  prefs: []
  type: TYPE_NORMAL
- en: Note that other than visualizing points on a graph, we can also present them
    as textual labels, which is more informative in a particular scenario. It could
    also be the case that multiple points overlap, making it difficult to tell them
    apart. Let’s look at how to handle such situations and present the points using
    an alternative way via the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.5 – Alternative ways of presenting points in a scatter plot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn two different ways of presenting the points
    in a scatter plot: showing textual labels and jittering the overlapping points.
    Both techniques will add more flexibility to our plotting toolkit. Proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualize the brand names based on the names of each row using `row.names()`
    and plot them on the previous scatter plot of `hp` against `mpg` using `geom_text()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will generate the output shown in *Figure 4**.11*, where
    brand names replace the points. However, some brand names overlap with each other,
    making it difficult to identify their specific text. Let us see how to remedy
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Showing brand names in a scatter plot](img/B18680_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Showing brand names in a scatter plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Adjust the overlapping text using the `position_jitter()` function by passing
    it into the `position` argument of the `geom_text()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing this command will generate the output shown in *Figure 4**.12*, where
    we have additionally specified the `fontface` argument to be `bold` for better
    clarity. By changing the `width` and `height` parameters of the `position_jitter()`
    function and passing it to the `position` argument of `geom_text()`, we managed
    to adjust the position of the text on the graph, which is now more visually digestible:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Jittering the position of the text](img/B18680_04_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Jittering the position of the text
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how to jitter overlapping points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a scatter plot of factored `cyl` against `mpg`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.13*, where we
    intentionally used the `cyl` categorical variable to show that multiple points
    are overlapping on the graph:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Visualizing a scatter plot with overlapping points](img/B18680_04_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Visualizing a scatter plot with overlapping points
  prefs: []
  type: TYPE_NORMAL
- en: Let us adjust the position of the overlapping points so that they are visually
    separable, giving us a sense of how many such points line up on a single spot.
    Note that jittering means adding random positional adjustments to the points in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jitter the points using `geom_jitter()`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.14*, where the
    points along each category of `cyl` are now separated from each other instead
    of aligning on the same line. Adding random jitters thus helps visually separate
    the overlapping points using random perturbations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Randomly jittering the overlapping points](img/B18680_04_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Randomly jittering the overlapping points
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the geometry of graphics that determines the visual elements
    shown in the plot.
  prefs: []
  type: TYPE_NORMAL
- en: Geometries in graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous section mostly covered scatter plots. In this section, we will
    go over two additional common types of plots: bar charts and line plots. We will
    discuss different ways to construct these plots, focusing on the geometries that
    can be used to control layer-specific visual properties of the graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding geometry in scatter plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us revisit the scatter plot and zoom in on the geometry layer. The geometry
    layer determines how the plot actually looks, which is an essential layer in our
    visual communication. At the time of writing, there are over 50 geometries we
    can choose from, all of which start with the `geom_` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some overall guidelines apply when deciding which type of geometry to use.
    For example, the following list contains the possible kinds of applicable geometries
    for a typical scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point**, which visualizes the data as points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jitter**, which adds positional jittering to a scatter plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abline**, which adds a line on the scatter plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smooth**, which smooths the plot by fitting a trend line along with the confidence
    bounds to help identify a particular pattern in the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Count**, which counts and shows the number of observations at each location
    in the scatter plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each geometry layer is associated with its own aesthetic configurations, including
    both compulsory and optional settings. For example, the `geom_point()` function
    requires `x` and `y` as mandatory arguments to uniquely locate points on the plot
    and allows optional settings such as the `alpha` parameter to control the level
    of transparency, as well as `color` and `fill` to manage the coloring of the points,
    along with their `shape` and `size` parameters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the geometry layer provides layer-specific control, we can set some of
    the visual properties in either the aesthetics layer or the geometry layer. For
    example, the following code generates the same plot as the one shown in *Figure
    4**.15*, where the coloring can be set in either the base `ggplot()` function
    or the layer-specific `geom_point()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That produces the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Generating the same scatter plot using layer-specific geometry
    control](img/B18680_04_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Generating the same scatter plot using layer-specific geometry
    control
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility from layer-specific control manifests when we have more than
    one layer (not necessarily a different type) to display in the plot. We will see
    how multiple geometry layers can be used together in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.6 – Using multiple geometry layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will display the average `hp` and `mpg` values across
    different groups of `cyl` on top of the previous scatter plot. Once obtained from
    the raw `mtcars` dataset, extra mean statistics can be added by overlaying another
    geometry layer, taking the same type of scatter plot. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the average values for all columns for each group of `cyl` using
    the `dplyr` library and store the result in a variable called `tmp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that the summary statistics on the average of all columns are obtained
    using the `summarize_all()` function, a utility function that applies the input
    function across all columns for each group. Here, we pass the `mean` function
    to calculate the average of a column. The resulting `tibble` object, stored in
    `tmp`, contains the average value for all variables across three groups of `cyl`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is important to note that upon adding an extra geometry layer, the base aesthetics
    layer expects the same column names in each geometry layer. The base aesthetics
    layer in the `ggplot()` function applies to all geometry layers. Let us see how
    to add an extra geometry layer as a scatter plot to show the average `hp` and
    `mpg` values across different groups of `cyl`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add an extra layer of scatter plot to show the average `hp` and `mpg` values
    as big squares for each group of `cyl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running this command will generate the output shown in *Figure 4**.16*, where
    the big squares (obtained by setting `shape=15` and `size=6` in the second `geom_point`
    layer) are sourced from the `tmp` dataset, as specified by the `data` parameter
    in the additional geometry layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the average `hp` and `mpg` values are automatically left-joined into
    the existing dataset, which shows different values of `hp` and `mpg` for each
    group of `cyl`. To ensure the two geometry layers are compatible with each other
    when plotted together, we need to ensure all matching coordinates (the `x` and
    `y` arguments) exist in the corresponding raw datasets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Visualizing the average hp and mpg values for each group of
    cyl](img/B18680_04_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Visualizing the average hp and mpg values for each group of cyl
  prefs: []
  type: TYPE_NORMAL
- en: This plot consists of two geometry layers, where the first layer plots each
    observation as small circles, and the second layer plots the average values as
    big boxes for `hp` and `mpg` for each group of `cyl`. Adding extra layers follows
    the same principle, as long as the data source for each layer contains the column
    names as specified in the base aesthetics layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate the need for matching coordinates for multiple layers,
    let us try typing the following command in the console, where we only select the
    `mpg` and `disp` columns in the raw data passed to the second geometry layer.
    As you can see from the output, the `hp` column is expected, without which an
    error is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section, we will look at a new type of plot: a bar chart, along
    with its associated geometry layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing bar charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bar chart displays certain statistics (such as frequency or proportion) of
    a categorical or continuous variable in the form of bars. Among multiple types
    of bar charts, a histogram is a special type of bar chart that shows the binned
    distribution of a single continuous variable. Therefore, plotting a histogram
    is always in terms of one continuous input variable, achieved using the `geom_histogram()`
    function and only specifying the `x` argument. Under the hood, the function first
    cuts the continuous input variable into discrete bins. It then uses the internally
    calculated `count` variable to indicate the number of observations in each bin
    to be passed to the `y` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at how to build a histogram in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.7 – Building a histogram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will look at different ways to apply positional adjustments
    when displaying a histogram. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a histogram of the `hp` variable using the `geom_histogram()` layer,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will generate the output shown in *Figure 4**.17*, along
    with the warning message on the binning. This is because the default binning value
    is not suitable since there are multiple gaps between the bars, making it difficult
    to interpret for a continuous variable. We will need to fine-tune the width of
    each bin using the `binwidth` argument:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Plotting a histogram for hp](img/B18680_04_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Plotting a histogram for hp
  prefs: []
  type: TYPE_NORMAL
- en: 'Adjust the `binwidth` argument to make the histogram continuous and remove
    the warning message, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Displaying a continuous histogram](img/B18680_04_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Displaying a continuous histogram
  prefs: []
  type: TYPE_NORMAL
- en: Making a continuous-looking histogram is data-dependent and requires trial and
    error. In this case, setting `binwidth=40` seems to be working for us.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will introduce grouping to the previous histogram by changing the coloring
    of the bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the bars with different colors using the `fill` argument based on the
    factored `cyl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.19*, where each
    bar represents different groups of `cyl`. However, a shrewd reader may immediately
    find that, for some bars with two colors, it is difficult to discern whether they
    are overlapping or stacked on top of one another. Indeed, the default setting
    for the histogram is `position="stack"`, meaning the bars are stacked by default.
    To remove such confusion, we can explicitly show the bars side by side:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Coloring the bars in the histogram](img/B18680_04_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Coloring the bars in the histogram
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the bars side by side by setting `position="dodge"`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.20*, where the
    bars are now shown side by side. We can further adjust the `binwidth` parameter
    to reduce the gaps in between:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Side-by-side bar chart](img/B18680_04_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Side-by-side bar chart
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can also show the statistics as proportions instead of counts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Show the previous histogram of `hp` by `cyl` as proportions by executing the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.21*, where the
    `ylab()` function is used to change the label of the *y* axis. Since the proportion
    of each bin needs to sum to `1`, the plot contains bars of equal height, each
    containing one or more groups. For each bin with multiple groups, the height of
    each color represents the proportion of observations falling in this group of
    `cyl` within the specific bin. Such a plot is often used when we only care about
    the relative percentage of each group instead of the absolute count:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Showing the bar chart as proportions](img/B18680_04_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Showing the bar chart as proportions
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, a histogram is a special type of bar chart. A classical
    bar chart contains a categorical variable on the *x* axis, where each position
    represents the count of the number of observations falling into that particular
    category. A bar chart can be generated using the `geom_bar()` function, which
    allows the same positional adjustment as `geom_histogram()`. Let us go through
    the following exercise to learn its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.8 – Building a bar chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will visualize the count of observations by `cyl` and
    `gear` as a bar chart. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot the count of observations for each unique combination of `cyl` and `gear`
    in a stacked bar chart, using `cyl` as the *x* axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will generate the output shown in *Figure 4**.22*, where
    the height of the bar represents the count of observations for the particular
    combination of `cyl` and `gear`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Stacked bar chart by cyl and gear](img/B18680_04_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Stacked bar chart by cyl and gear
  prefs: []
  type: TYPE_NORMAL
- en: We can also represent the bar chart using the proportion/percentage of observations
    in the respective group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert the bar chart to a percentage-based plot to show the distribution of
    each combination, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will generate the output shown in *Figure 4**.23*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Visualizing a bar chart as proportions](img/B18680_04_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Visualizing a bar chart as proportions
  prefs: []
  type: TYPE_NORMAL
- en: As before, we can also convert the bar chart from stacked to side by side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualize the previous information in a side-by-side bar chart, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will generate the output shown in *Figure 4**.24*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.24 – A side-by-side bar chart](img/B18680_04_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – A side-by-side bar chart
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also customize the bar chart so that the bars partially overlap with
    each other. This is achieved using the `position_dodge()` function as follows,
    where we adjust the `width` parameter to jitter the overlapping bars to a certain
    extent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Adjusting overlapping bars in a bar chart](img/B18680_04_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – Adjusting overlapping bars in a bar chart
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at another popular type of plot: a line plot.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing line plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **line plot** displays the value of one variable as the other variable changes.
    As with a scatter plot, a line plot can be considered scattered points connected
    via a line. It is mainly used to depict the relationship between two variables.
    For example, when two variables are positively correlated with each other, increasing
    one variable would lead to a seemingly proportionate increase in the other variable.
    Visualizing such a relationship on a line plot could result in a trend line between
    the two variables with a positive slope.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most widely used types of line plots is the time series plot, where
    the value of a particular metric (such as stock price) is shown as a function
    of time (such as daily). In the following exercise, we will look at the quarterly
    earnings of Johnson & Johnson between 1960 and 1981, using the `JohnsonJohnson`
    dataset provided by base R. We will explore different ways to visualize the line
    chart, along with a little bit of data processing specific to time series data.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.9 – Building a time series plot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will look at visualizing the time series data as a line
    plot. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine the structure of the `JohnsonJohnson` dataset by executing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output suggests that the dataset is a univariate (meaning a single variable)
    time series ranging from `1960` to `1981`. Printing out its contents (only showing
    the top five rows) also tells us that the frequency is quarterly, using year-quarter
    as a unique index for each data point in the time series:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let us convert it to our familiar DataFrame format to ease data manipulation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Convert it to a DataFrame called `JohnsonJohnson2` with two columns: `qtr_earning`
    to store the quarterly time series, and `date` to store the approximate date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `date` column is obtained by extracting the `time` index from the `JohnsonJohnson`
    time series object, displaying as the year-month format using `as.yearmon()`,
    and then converting to a date format using `as.Date()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will also add two extra indicator columns for plotting purposes later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add an `ind` indicator column that takes the value of `TRUE` if the date is
    equal to or beyond `1975-01-01`, and `FALSE` otherwise. Also, extract the quarter
    from the `date` variable and store it in the `qtr` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this command, we used the `quarters()` function to extract the quarter from
    a date-formatted field. Next, we will plot the quarterly earnings as a time series.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Plot `qtr_earning` as a function of `date` using a line plot, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.26*, where we
    specify the `date` column as the *x* axis and `qtr_earning` as the *y* axis, followed
    by the `geom_line()` layer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Time series plot of quarterly earnings](img/B18680_04_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26 – Time series plot of quarterly earnings
  prefs: []
  type: TYPE_NORMAL
- en: The line chart for the quarterly earnings displays a long-term increasing trend
    and short-term fluctuations. The subject of time series forecasting focuses on
    using these structural components (such as trend and seasonality) to predict future
    values.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can color code the time series so that different line segments
    display a different color according to another grouping variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify the color of the line plot according to the `ind` column, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.27*, where we
    set `color=ind` in the base aesthetics layer to change the coloring. Note that
    the two line segments are disconnected since they are essentially separate time
    series plotted on the chart:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Two line charts of different colors](img/B18680_04_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.27 – Two line charts of different colors
  prefs: []
  type: TYPE_NORMAL
- en: We can also plot multiple lines when there are multiple categories in the grouping
    variable, each of which will assume a different color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot the time series for each quarter respectively, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding command will generate the output shown in *Figure 4**.28*,
    where `1980`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Yearly times series plot for each quarter](img/B18680_04_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 – Yearly times series plot for each quarter
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the theme layer, which controls the stylistic
    elements of a plot.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling themes in graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The theme layer specifies all non-data-related properties on the plot, such
    as the background, legend, axis labels, and so on. Proper control of the themes
    in the plot could aid visual communication by highlighting critical information
    and directing users’ attention to the intended message we would like to convey.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of visual elements controlled by the theme layer, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**, used to specify the textual display (for example, color) of the axis
    label'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line**, used to specify the visual properties of the axes such as color and
    line type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rectangle**, used to control the borders and backgrounds of the plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three types are specified using functions that start with `element_`, including
    examples such as `element_text()` and `element_line()`. We will go over these
    functions in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The theme layer can be easily applied as an additional layer on the existing
    graph. Let us go through an exercise on how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.10 – Applying themes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will look at how to tweak the theme-related elements of
    the previous time series plot, including moving the legend and changing the properties
    of the axes. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the legend of the previous time series plot at the bottom by overlaying
    a theme layer with its `legend.position` argument specified as `"bottom"`. Also,
    enlarge the font size of the text along the axes and legend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.29*, where the
    legend is now moved to the bottom of the plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Displaying the legend at the bottom](img/B18680_04_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – Displaying the legend at the bottom
  prefs: []
  type: TYPE_NORMAL
- en: We can also position the legend anywhere within the plot by providing the coordinate
    information to the `legend.position` argument. The coordinates start at the lower-left
    corner with a value of `(0,0)` and span all the way to the upper-right corner,
    taking the value of `(1,1)`. Since the upper-left part of the plot seems vacant,
    we may consider moving the legend there to save some extra space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move the legend to the upper-left corner by supplying a pair of proper coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we specified the legend’s position to be `(0.1, 0.8)`. In general, configuring
    a proper position using the coordinate system requires trial and error. We have
    also saved the result in a variable called `tmp`, which will be used later. The
    generated plot is shown in *Figure 4**.30*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Coordinate-based positional adjustment for the legend](img/B18680_04_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.30 – Coordinate-based positional adjustment for the legend
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will adjust the properties of the axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the previous plot, change the color of the axes’ titles to blue using
    the `element_text()` function on the `axis.title` property. Also, make the axes’
    lines solid black using the `element_line()` function on the `axis.line` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.31*, where we
    used the `element_text()` and `element_line()` functions to adjust the visual
    properties (`color` and `linetype`) of the title (`axis.title`) and the lines
    (`axis.line`) for the axes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Changing the titles and lines of the axes](img/B18680_04_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.31 – Changing the titles and lines of the axes
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can change the default background and grids as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the default grids and background in the previous plot by executing the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we used `panel.grid.major` and `panel.grid.minor` to access the grid
    properties and `panel.background` to access the background property of the plot.
    The `element_blank()` removes all existing configurations and is specified for
    all these three properties. The result is shown in *Figure 4**.32*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Removing the grids and background setting](img/B18680_04_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.32 – Removing the grids and background setting
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can also save the theme layer in a variable and apply it as an
    overlay to other plots. We treat the whole plot or a specific layer configuration
    as a variable, making it convenient to scale to multiple plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides creating our own themes, we can also utilize the built-in theme layers
    provided by `ggplot2`. As listed here, these built-in themes provide off-the-shelf
    solutions to facilitate plotting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`theme_gray()`, the default theme we used earlier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`theme_classic()`, the traditional theme mostly used in scientific plotting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`theme_void()`, which removes all non-data-related properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`theme_bw()`, mostly used when the transparency level is configured'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we can use the `theme_classic()` function to generate a similar
    plot as before, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Using out-of-the-box theme setting](img/B18680_04_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.33 – Using out-of-the-box theme setting
  prefs: []
  type: TYPE_NORMAL
- en: Other than the built-in themes, the `ggthemes` package provides additional themes
    that further extend our choices of available themes. Let us explore this package
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring ggthemes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ggthemes` package contains multiple pre-built themes. Just as using `dplyr`
    could significantly accelerate our data processing task, using the pre-built themes
    could also ease our graphing efforts compared with ground-up development. Let
    us look at a few available themes in this package.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.11 – Exploring themes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will explore a few additional out-of-the-box themes provided
    by `ggthemes`. Remember to download and load this package before continuing with
    the following code examples. We will cover two theme functions. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the `theme_fivethirtyeight` theme on the previous plot, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.34*, where the
    legend is placed at the bottom:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.34 – Applying the theme_fivethirtyeight theme](img/B18680_04_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.34 – Applying the theme_fivethirtyeight theme
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the `theme_tufte()` theme, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command generates the output shown in *Figure 4**.35*, the type
    of plot commonly used in scientific papers. Note that the plots in academic papers
    recommend only showing essential information. This means that additional configurations
    such as background are discouraged. Real-life plots, on the other hand, prefer
    a decent balance between usefulness and beauty:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Applying the theme_tufte theme](img/B18680_04_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.35 – Applying the theme_tufte theme
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we looked at controlling theme-related elements in
    a graph, which gives us great flexibility when it comes to fine-tuning and customizing
    a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced essential graphics techniques based on the `ggplot2`
    package. We started by going over the basic scatter plot and learned the grammar
    of developing layers in a plot. To build, edit, and improve a plot, we need to
    specify three essential layers: data, aesthetics, and geometries. For example,
    the `geom_point()` function used to build a scatter plot allows us to control
    the size, shape, and color of the points on a graph. We can also display them
    as text in addition to presenting points using the `geom_text()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the layer-specific control provided by the geometry layer and
    showed examples using bar charts and line plots. A bar chart can help represent
    the frequency distribution of categorical variables and the histogram of continuous
    variables. A line chart supports time series data and can help identify trends
    and patterns if appropriately plotted.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also covered the theme layer, which allows us to control all non-data-related
    visual aspects of a graph. Coupled with the built-in themes by base R and off-the-shelf
    themes by `ggthemes`, we have many options to choose from and accelerate the graphing
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover **exploratory data analysis** (**EDA**),
    a common and essential step in many data analytics and modeling tasks.
  prefs: []
  type: TYPE_NORMAL
