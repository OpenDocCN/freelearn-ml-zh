["```py\n    int main() \n    { \n      //1\\. Create image processor object \n      ColorDetector cdetect; \n\n      //2\\. Read input image \n      cv::Mat image= cv::imread(\"boldt.jpg\"); \n      if (image.empty()) return 0;  \n\n      //3\\. Set input parameters \n      cdetect.setTargetColor(230,190,130);  // here blue sky \n\n      //4\\. Process the image and display the result \n      cv::namedWindow(\"result\"); \n      cv::Mat result = cdetect.process(image); \n      cv::imshow(\"result\",result); \n\n      cv::waitKey(); \n      return 0; \n    } \n\n```", "```py\n    // get the iterators \n    cv::Mat_<cv::Vec3b>::const_iterator it= image.begin<cv::Vec3b>(); \n    cv::Mat_<cv::Vec3b>::const_iterator itend= image.end<cv::Vec3b>(); \n    cv::Mat_<uchar>::iterator itout= result.begin<uchar>(); \n\n    //for each pixel \n    for ( ; it!= itend; ++it, ++itout) { \n\n      // compute distance from target color \n      if (getDistanceToTargetColor(*it)<=maxDist) { \n        *itout= 255; \n      } else { \n       *itout= 0; \n      } \n    } \n\n```", "```py\n    // Computes the distance from target color. \n    int getDistanceToTargetColor(const cv::Vec3b& color) const { \n      return getColorDistance(color, target); \n    } \n    // Computes the city-block distance between two colors. \n    int getColorDistance(const cv::Vec3b& color1,  \n    const cv::Vec3b& color2) const { \n      return abs(color1[0]-color2[0])+\n             abs(color1[1]-color2[1])+ \n             abs(color1[2]-color2[2]); \n    } \n\n```", "```py\n    cv::Mat ColorDetector::process(const cv::Mat &image) { \n\n      // re-allocate binary map if necessary \n      // same size as input image, but 1-channel \n      result.create(image.size(),CV_8U); \n\n      // processing loop above goes here \n      return result; \n    }\n\n```", "```py\n    class ColorDetector {\n      private: \n\n      // minimum acceptable distance \n      int maxDist;  \n      // target color \n      cv::Vec3b target; \n\n      // image containing resulting binary map \n      cv::Mat result;\n\n```", "```py\n    // empty constructor \n    // default parameter initialization here \n    ColorDetector() : maxDist(100), target(0,0,0) {} \n\n```", "```py\n    // another constructor with target and distance \n    ColorDetector(uchar blue, uchar green, uchar red, int mxDist); \n\n```", "```py\n    // Sets the color distance threshold \n    // Threshold must be positive, \n    // otherwise distance threshold is set to 0\\. \n    void setColorDistanceThreshold(int distance) { \n\n      if (distance<0) \n        distance=0; \n        maxDist= distance; \n      } \n\n      // Gets the color distance threshold \n      int getColorDistanceThreshold() const { \n        return maxDist; \n      }\n\n```", "```py\n    // Sets the color to be detected \n    void setTargetColor(uchar blue,\n                        uchar green,\n                        uchar red) { \n      // BGR order \n      target = cv::Vec3b(blue, green, red); \n    } \n    // Sets the color to be detected \n    void setTargetColor(cv::Vec3b color) { \n      target= color; \n    } \n\n    // Gets the color to be detected \n    cv::Vec3b getTargetColor() const { \n      return target; \n    } \n\n```", "```py\n    return abs(color[0]-target[0])+\n           abs(color[1]-target[1])+\n           abs(color[2]-target[2]); \n\n```", "```py\n    return static_cast<int>(\n           cv::norm<int,3>(cv::Vec3i(color[0]-target[0],\n                                     color[1]-target[1],\n                                     color[2]-target[2]))); \n\n```", "```py\n    return static_cast<int>( cv::norm<uchar,3>(color-target));// wrong! \n\n```", "```py\n    cv::Vec3b dist; \n    cv::absdiff(color,target,dist); \n    return cv::sum(dist)[0];\n\n```", "```py\n    cv::Mat ColorDetector::process(const cv::Mat &image) { \n      cv::Mat output; \n      // compute absolute difference with target color \n      cv::absdiff(image,cv::Scalar(target),output); \n\n      // split the channels into 3 images \n      std::vector<cv::Mat> images; \n      cv::split(output,images); \n\n      // add the 3 channels (saturation might occurs here) \n      output= images[0]+images[1]+images[2]; \n      // apply threshold \n      cv::threshold(output,                  // same input/output image \n                    output,   \n                    maxDist,                // threshold (must be < 256) \n                    255,                    // max value \n                    cv::THRESH_BINARY_INV); // thresholding mode \n\n      return output; \n    }\n\n```", "```py\n    cv::floodFill(image,              // input/ouput image \n           cv::Point(100, 50),        // seed point \n           cv::Scalar(255, 255, 255), // repainted color \n           (cv::Rect*)0,              // bounding rect of the repainted set \n           cv::Scalar(35, 35, 35),    // low/high difference threshold \n           cv::Scalar(35, 35, 35),    // identical most of the time  \n           cv::FLOODFILL_FIXED_RANGE);// pixels compared to seed \n\n```", "```py\n    // full constructor \n    ColorDetector(uchar blue, uchar green, uchar red, int  maxDist=100): \n                  maxDist(maxDist) {  \n\n      // target color \n      setTargetColor(blue, green, red); \n    } \n\n```", "```py\n    cv::Mat operator()(const cv::Mat &image) { \n      // color detection code here  \n    } \n\n```", "```py\n    ColorDetector colordetector(230,190,130,  // color \n                                100);         // threshold \n    cv::Mat result= colordetector(image);     // functor call \n\n```", "```py\n    cv::Ptr<cv::ORB> ptrORB = cv::ORB::create(); // default state \n\n```", "```py\n    // define bounding rectangle \n    // the pixels outside this rectangle \n    // will be labeled as background \n    cv::Rect rectangle(5,70,260,120); \n\n```", "```py\n    cv::Mat result;                     // segmentation (4 possible values) \n    cv::Mat bgModel,fgModel;            // the models (internally used) \n    // GrabCut segmentation    \n    cv::grabCut(image,                  // input image \n                result,                 // segmentation result \n                rectangle,              // rectangle containing foreground \n                bgModel,fgModel,        // models \n                5,                      // number of iterations \n                cv::GC_INIT_WITH_RECT); // use rectangle \n\n```", "```py\n    // Get the pixels marked as likely foreground \n    cv::compare(result,cv::GC_PR_FGD,result,cv::CMP_EQ); \n    // Generate output image \n    cv::Mat foreground(image.size(),CV_8UC3,cv::Scalar(255,255,255)); \n    image.copyTo(foreground,// bg pixels are not copied result);\n\n```", "```py\n    // checking first bit with bitwise-and \n    result= result&1; // will be 1 if FG \n\n```", "```py\n    cv::Mat ColorDetector::process(const cv::Mat &image) { \n\n      // re-allocate binary map if necessary \n      // same size as input image, but 1-channel \n      result.create(image.rows,image.cols,CV_8U); \n\n      // Converting to Lab color space  \n      cv::cvtColor(image, converted, CV_BGR2Lab); \n\n      // get the iterators of the converted image  \n      cv::Mat_<cv::Vec3b>::iterator it=  converted.begin<cv::Vec3b>(); \n      cv::Mat_<cv::Vec3b>::iterator itend= converted.end<cv::Vec3b>(); \n      // get the iterator of the output image  \n      cv::Mat_<uchar>::iterator itout= result.begin<uchar>(); \n\n      // for each pixel \n      for ( ; it!= itend; ++it, ++itout) { \n\n```", "```py\n    class ColorDetector { \n      private: \n      // image containing color converted image \n      cv::Mat converted; \n\n```", "```py\n    // Sets the color to be detected \n    void setTargetColor(unsigned char red, unsigned char green,\n                        unsigned char blue) { \n\n      // Temporary 1-pixel image \n      cv::Mat tmp(1,1,CV_8UC3); \n      tmp.at<cv::Vec3b>(0,0)= cv::Vec3b(blue, green, red); \n\n      // Converting the target to Lab color space  \n      cv::cvtColor(tmp, tmp, CV_BGR2Lab); \n\n      target= tmp.at<cv::Vec3b>(0,0); \n    } \n\n```", "```py\n    cv::cvtColor(color, gray, CV_BGR2Gray); \n\n```", "```py\n    // convert into HSV space \n    cv::Mat hsv; \n    cv::cvtColor(image, hsv, CV_BGR2HSV); \n\n```", "```py\n    // split the 3 channels into 3 images \n    std::vector<cv::Mat> channels; \n    cv::split(hsv,channels); \n    // channels[0] is the Hue \n    // channels[1] is the Saturation \n    // channels[2] is the Value \n\n```", "```py\n    cv::Mat hs(128, 360, CV_8UC3);   \n    for (int h = 0; h < 360; h++) { \n      for (int s = 0; s < 128; s++) { \n        hs.at<cv::Vec3b>(s, h)[0] = h/2;    // all hue angles \n        // from high saturation to low \n        hs.at<cv::Vec3b>(s, h)[1] = 255-s*2; \n        hs.at<cv::Vec3b>(s, h)[2] = 255;    // constant value \n      }       \n    }\n\n```", "```py\n    // convert into HSV space \n    cv::Mat hsv; \n    cv::cvtColor(image, hsv, CV_BGR2HSV); \n    // split the 3 channels into 3 images \n    std::vector<cv::Mat> channels; \n    cv::split(hsv,channels); \n    // Value channel will be 255 for all pixels \n    channels[2]= 255; \n    // merge back the channels \n    cv::merge(channels,hsv); \n    // reconvert to BGR \n    cv::Mat newImage; \n    cv::cvtColor(hsv,newImage,CV_HSV2BGR); \n\n```", "```py\n    void detectHScolor(const cv::Mat& image,  // input image \n               double minHue, double maxHue,  // Hue interval \n               double minSat, double maxSat,  // saturation interval \n               cv::Mat& mask) {               // output mask \n\n      // convert into HSV space \n      cv::Mat hsv; \n      cv::cvtColor(image, hsv, CV_BGR2HSV); \n\n      // split the 3 channels into 3 images \n      std::vector<cv::Mat> channels; \n      cv::split(hsv, channels); \n      // channels[0] is the Hue \n      // channels[1] is the Saturation \n      // channels[2] is the Value \n\n      // Hue masking \n      cv::Mat mask1; // below maxHue \n      cv::threshold(channels[0], mask1, maxHue, 255,\n                    cv::THRESH_BINARY_INV); \n      cv::Mat mask2; // over minHue \n      cv::threshold(channels[0], mask2, minHue, 255, cv::THRESH_BINARY); \n\n      cv::Mat hueMask; // hue mask \n      if (minHue < maxHue) \n        hueMask = mask1 & mask2; \n      else // if interval crosses the zero-degree axis \n        hueMask = mask1 | mask2; \n\n      // Saturation masking \n      // between minSat and maxSat \n      cv::Mat satMask; // saturation mask \n      cv::inRange(channels[1], minSat, maxSat, satMask); \n\n      // combined mask \n      mask = hueMask & satMask; \n    }\n\n```", "```py\n    // detect skin tone \n    cv::Mat mask; \n    detectHScolor(image, 160, 10,  // hue from 320 degrees to 20 degrees  \n                  25, 166,         // saturation from ~0.1 to 0.65 \n                  mask); \n\n    // show masked image \n    cv::Mat detected(image.size(), CV_8UC3, cv::Scalar(0, 0, 0)); \n    image.copyTo(detected, mask); \n\n```"]