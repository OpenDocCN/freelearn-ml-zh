- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring Your Monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have decided that MSA is the right architectural style for our organization,
    what’s next?
  prefs: []
  type: TYPE_NORMAL
- en: In a recent report, *2022 APIs & Microservices Connectivity Report*, published
    by Kong Inc., 75% of organizations have a lack of innovation and technology adoption.
  prefs: []
  type: TYPE_NORMAL
- en: The need for an IT system that quickly responds to customer and market needs
    has never been higher. Monolithic applications can no longer respond to high-paced
    market updates and needs. That’s one main reason for organizations to look to
    update their IT system, to stay in business.
  prefs: []
  type: TYPE_NORMAL
- en: MSA is a primary enabler for a flexible and reliable enterprise system. Transitioning
    from a monolithic architecture into MSA is, therefore, becoming essential to modernizing
    an organization’s IT systems.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss, in this chapter, how to break up the business requirements
    of an existing running monolithic application in to microservices, and the steps
    necessary to transition toward MSA applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following areas as we go over the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the system’s microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ABC monolith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function decomposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data decomposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request decomposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the system’s microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether it is a brownfield or greenfield enterprise system implementation, we
    still need to break up business requirements into basic functions as granularly
    as possible. This will later help us identify each microservice and successfully
    integrate it into our enterprise system.
  prefs: []
  type: TYPE_NORMAL
- en: In a brownfield system, business and system requirements have already been identified
    and implemented. They may, however, need to be revisited and updated according
    to new business criteria, changes, and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of refactoring your application into simple services is to form
    highly granular functions that will eventually be built (or acquired) as microservices.
    You are very likely to add new functions to your new MSA in addition to some of
    the functions you will already extract from the monolithic system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, therefore, split the migration process into the following high-level steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the to-be MSA system and the functions needed to build that MSA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify what existing functions in the current monolithic system are to be
    reused in the new MSA and implemented as microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the delta between the existing functions to be reused and the functions
    needed to get to the to-be MSA system. These are the new functions to be implemented
    in the new MSA system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the functions list identified in *step 3*, identify which functions will
    be developed as a microservice in-house, and the ones that can be acquired through
    third parties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decomposing the monolith using a function-driven approach is a good starting
    point; nevertheless, using that approach alone is not enough. Since data stores
    are centralized in the monolith, data dependencies will still be a big concern
    in maintaining the microservices’ autonomy.
  prefs: []
  type: TYPE_NORMAL
- en: The interaction between the different functions in the monolith is another concern.
    We will need to look into how the function calls are being processed and handled,
    what data is being shared between these functions, and what data is being returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examining monolithic system functions, data, and function calls (requests) during
    the refactoring process is essential for maintaining the autonomy of microservices
    and achieving the desired level of granularity.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that we must maintain the microservices autonomy principle during
    the entire monolith decomposition process. Too many microservices would cause
    a **Nano-service anti-pattern** effect, while too few would still leave your system
    with the same issues as a monolithic system.
  prefs: []
  type: TYPE_NORMAL
- en: The Nano-service anti-pattern creates too many expectations for most systems’
    operations, which can in turn further complicate your MSA system and create a
    lack of stability, decreased reliability, and other system performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, apply the **Common Closure Principle**, where microservices
    that change for the same exact reason are better off packaged together in a single
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: To better explain the monolith transformation process to an MSA, in the following
    sections, we will design a simple hypothetical monolithic system, break up the
    system using the already mentioned three stages of system decomposition, build
    the different microservices, and then organize them together to build the MSA.
  prefs: []
  type: TYPE_NORMAL
- en: The ABC monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ABC is a simplified hypothetical product-ordering monolithic system built specifically
    to demonstrate the process and the steps needed in refactoring a monolithic application
    into an MSA. We will be using this ABC system throughout this book to demonstrate
    some examples of how to apply the concepts and methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we put the ABC-Monolith system together for demo purposes only
    and our aim here is not to discuss how the ABC-Monolith can be designed or structured
    better. We are more focused on the ABC-Monolith system refactoring process itself.
  prefs: []
  type: TYPE_NORMAL
- en: In the ABC-Monolith, the user can place an order from an existing product catalog
    and track the order’s shipping status. For simplicity, all sales are final, and
    products cannot be returned.
  prefs: []
  type: TYPE_NORMAL
- en: The system will be able to clear the order payment, assign a shipping courier
    to the order, and track all order and shipping updates.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the high-level ABC-Monolith architecture. A user
    portal is used to add items to the cart, then send the order details to the ABC-Monolith.
    The ABC-Monolith has different tightly coupled functions with a centralized database,
    all to process the order from payment to delivery. The user is notified of all
    order and shipping updates throughout the order fulfillment process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: The ABC-Monolith architecture](img/B18934_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The ABC-Monolith architecture'
  prefs: []
  type: TYPE_NORMAL
- en: To further understand the monolith, we will next go over the system As-Is state
    by discussing the existing monolith’s functions, the monolith database structure,
    and the workflow of the order placement process. We will close this section by
    comparing the As-Is to the To-Be state.
  prefs: []
  type: TYPE_NORMAL
- en: The ABC-Monolith’s current functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is imperative to start by understanding what current functions are implemented
    in the monolith and what their role is in the overall system. The following table
    lists the system functions we need to consider later in our system refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `place_order()` | A function to create a record with all order information,
    and mark the order as “pending” awaiting the rest of the order placement process.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `check_inventory()` | To check the availability of an item in the placed
    order. |'
  prefs: []
  type: TYPE_TB
- en: '| `process_payment()` | Verify the payment of the total order amount. Will
    return an error code if the payment is not cleared. |'
  prefs: []
  type: TYPE_TB
- en: '| `update_inventory()` | Once an order is verified and the payment is successfully
    processed, the item inventory should be updated accordingly. |'
  prefs: []
  type: TYPE_TB
- en: '| `create_order()` | The order is now successfully processed; time to change
    the order status, and kick off the order preparation process (packing, etc.).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `create_shipping_request()` | Starts the order shipping request and notifies
    the courier with an available order for shipping. |'
  prefs: []
  type: TYPE_TB
- en: '| `order_status_update()` | A function to update the order status with any
    changes such as preparing, shipping, exception, received, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `shipment_status_update()` | A function to update the shipping status with
    any changes such as, pending pickup, picked up, en route, exception, received,
    and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `notify_user()` | To notify the user of any changes or updates to the placed
    order. |'
  prefs: []
  type: TYPE_TB
- en: '| `register_customer()` | A function that creates customer record information
    with a full name, address, phone, and other details. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: The ABC-Monolith functions list'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding table, we focused our description on the role of the function
    itself regardless of what the parameter passing is, or what the return values
    are.
  prefs: []
  type: TYPE_NORMAL
- en: The ABC-Monolith’s database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the functions identified in the monolith share a centralized database.
    The following are the database tables being accessed by the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Database Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `CUSTOMER` | A table holding all customer information such as name, email,
    and phone. |'
  prefs: []
  type: TYPE_TB
- en: '| `ITEM` | The product information is in the catalog. Product information includes
    product name, price, and stock quantity. |'
  prefs: []
  type: TYPE_TB
- en: '| `ORDER` | Information on orders placed. |'
  prefs: []
  type: TYPE_TB
- en: '| `ORDER_ITEM` | A many-to-many relationship normalization table between the
    `ORDER` and `ITEM` tables. |'
  prefs: []
  type: TYPE_TB
- en: '| `ORDER_STATUS` | The status of each placed order, with a reference to `status_code`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `STATUS_CODE` | Lookup table for order and shipment status codes. |'
  prefs: []
  type: TYPE_TB
- en: '| `COURIER` | Shipping courier information, including courier name, contact,
    and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHIPMENT_REQUEST` | A list of all shipping requests for orders placed. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHIPMENT_REQUEST_STATUS` | The status of each shipment request, with a reference
    to `status_code`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: The ABC-Monolith database tables list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is ABC’s **Entity Relationship Diagram** (**ERD**). Note that
    we needed to create the **ORDER_ITEM** normalization table to break up the many-to-many
    relationship between both the **ORDER** and **ITEM** tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: The ABC-Monolith ERD](img/B18934_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The ABC-Monolith ERD'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that some of the monolith’s functions require full read/write access
    to specific tables with access to all fields in the table, while some other functions
    need only access to specific fields in the table. This information is important
    in system refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will go over the workflow to identify the ABC-Monolith
    As-Is state and determine how we can transition into the To-Be state. Along with
    the workflow information, the function database access requirements will help
    us refactor the monolith database into individual MSA databases for each microservice.
  prefs: []
  type: TYPE_NORMAL
- en: The ABC workflow and current function calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know so far what functions are used in the monolith and how the monolith’s
    database is structured. The next step is to examine the order placement workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: The ABC-Monolith function requests/workflow](img/B18934_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The ABC-Monolith function requests/workflow'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding workflow diagram, the individual functions are all
    executed sequentially. Since it is all one tightly coupled system, there are no
    synchronization issues expected, and hence no orchestration is needed.
  prefs: []
  type: TYPE_NORMAL
- en: As we move toward the ABC-MSA, however, the decoupling of services creates the
    need to have a centralized point for managing the execution of these services
    in a specific sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Shown in the following diagram are ABC’s As-Is and To-Be states. No centralized
    management in the As-Is state is needed; however, an orchestrator component is
    introduced in the To-Be state to manage the process flows between the services.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the individual services in the To-Be states has a dedicated database,
    as shown in the diagram. In the As-Is state, on the other hand, the database is
    centralized.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: The ABC As-Is and To-Be states](img/B18934_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: The ABC As-Is and To-Be states'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how our current ABC-Monolith is structured, and what both the
    as-is and to-be states are, it is time to start the ABC-Monolith refactoring process
    to transform into the ABC-MSA.
  prefs: []
  type: TYPE_NORMAL
- en: We will refactor the monolith in three stages. First, we will decompose the
    monolith functions and map these functions to microservices. Then, we will decompose
    the data to see how the individual databases will be designed. Finally, out of
    the monolith’s workflow, we will analyze the function requests, and build our
    MSA sagas from there.
  prefs: []
  type: TYPE_NORMAL
- en: Function decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in refactoring the ABC-monolith is to create the microservices
    based on the system functions we previously identified. This is a straightforward
    mapping between the existing functions and the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is that, by looking only at each function by itself without
    considering any function calls or data connections, you need to be as granular
    as possible in your function decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the `notify_user()` function is doing too many things for a
    microservice, displaying a web user message status/update, notifying the user
    by email, and/or notifying the user by SMS. Each of these functions can have its
    own rules, design, issues, and concerns. Splitting the `notify_user()` function
    into three functions is a better approach from an MSA perspective to achieve the
    separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we split the `notify_user()` function into one function for handling
    web messages and notifications, one for handling email notifications, and one
    for SMS message notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`web_msg_notification()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email_notification()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sms_notification()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, the `process_payment()` function can also be split into two different,
    more granular functions, one for handling direct credit card payments and one
    for handling PayPal payments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`verify_cc_payment()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verify_paypal_payment()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following diagram shows how the ABC-Monolith is broken up so far. We haven’t
    yet looked into how the system’s functions are interacting with each other. The
    function interactions and the order fulfillment’s overall workflow will be handled
    at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: The ABC-Monolith function decomposition](img/B18934_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: The ABC-Monolith function decomposition'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are satisfied with the current level of granularity so far
    and we are ready to examine how the database tables are being accessed to see
    whether further decomposition is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Data decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During this stage, we need to look at how each function is accessing the database
    and what tables and even which parts of the database tables are accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows what parts of the database the ABC-Monolith functions
    access. It is essential to know exactly which tables are accessed by which function
    and why. This will help us identify database dependencies, in order to later eliminate
    these dependencies and split the centralized ABC-Monolith database into separate
    data stores, each data store dedicated to each microservice.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: ABC-Monolith database access](img/B18934_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: ABC-Monolith database access'
  prefs: []
  type: TYPE_NORMAL
- en: We are still bound by the microservice autonomy rule. The challenging part in
    the diagram and this refactoring phase is the shared tables. Sharing a table between
    two microservices creates coupling that would clearly violate the autonomy rule.
    On the other hand, creating multiple copies of the table across different microservices
    will create serious data consistency issues. So, how do we solve this conundrum?
  prefs: []
  type: TYPE_NORMAL
- en: Remember the `ORDER` table, for example, across the `place_order()`, `create_order()`,
    and `process_payment()` services of the ABC-MSA system. A similar approach is
    taken for `check_inventory()`, `update_inventory()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: So, with saga patterns in mind, let’s reexamine the ABC-Monolith database access
    shown in the preceding diagram, to build a new database access diagram for services
    in the ABC-MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to coordinate the data transactions, choreography and orchestration.
    In choreography, the ABC-MSA saga participant services will have to coordinate
    data transactions among themselves. In orchestration, a centralized orchestrator
    performs the coordination process and handles all workflow transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, we can choose either coordination methodology, but in our example,
    we would argue that orchestration creates a better decoupling model over choreography.
    For that reason, and to keep our example simple, we will be using orchestration
    for our ABC-MSA saga patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the ABC-MSA service database access. As you can
    see in the diagram, there are a few database tables that have been copied across
    the system. We will, in the next section, use saga patterns to maintain data consistency
    across the copied tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: ABC-MSA database access](img/B18934_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: ABC-MSA database access'
  prefs: []
  type: TYPE_NORMAL
- en: We notice in other services, such as `notify_user()` function may not be a good
    idea anyway. You should only see small database access similarities between these
    different services, not a completely identical database. In a real scenario, we
    are better off combining these three services into only one service as it originally
    was.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in a real-life scenario, the `process_payment()` function is likely
    to be mapped to a single service that includes clearing the payment overall, regardless
    of whether it is a credit card, PayPal, or any other form of payment. For demo
    purposes, we will split `notify_user()` and `process_payment()` into three and
    two different services respectively.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been able to build the ABC-MSA’s microservices from the ABC-Monolith
    functions, identify data access in the monolith, and decompose the monolith into
    separate microservices, each with its own database. In the next section, we will
    focus more on how to ensure isolation and separation of concerns for the microservices
    by looking into how the service requests are orchestrated in the new ABC-MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: Request decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ABC-Monolith function request flow has already been identified and shown
    in *Figure 1**.3*. We will now see how this flow is going to work in the ABC-MSA.
  prefs: []
  type: TYPE_NORMAL
- en: In the ABC-MSA, the sagas are programmed and configured in the centralized orchestrator.
    The orchestrator will initiate separate API calls to each service in the saga,
    in either a synchronous or asynchronous fashion, depending on the defined workflow,
    and wait for a response from each API call to determine what other API call(s)
    to initiate next and how.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows how the workflow would be in the ABC-MSA. Please
    note that all API calls in our scenario are being initiated from the orchestrator.
    As you can see from the sequence number, there are some API calls initiated in
    parallel, and in some other cases, the orchestrator decides the next course of
    action based on the response it receives from a previously executed service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: The ABC-MSA workflow](img/B18934_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: The ABC-MSA workflow'
  prefs: []
  type: TYPE_NORMAL
- en: The user in the ABC-MSA workflow diagram initiates the order fulfillment process
    from a web interface, which will kick off the workflow from the orchestrator.
    Both the **place_order** and **check_inventory** services are launched at the
    same time by the orchestrator. **place_order** creates the order with all its
    information and marks its state as **pending**, waiting for the rest of the workflow
    to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: The **check_inventory** service checks the inventory of items ordered and sends
    back a **true** or **false** response depending on whether the item is available
    or not. If any of the items ordered are not available, the **web_msg_notification**,
    **email_notification**, and **sms_notification** services are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here is the first challenge: all three notification services will require
    access to the `CUSTOMER` database in order to get the customer’s name, email address,
    phone number, and so on. But having one database for all three services creates
    undesired coupling that would violate the microservices autonomy principle. As
    we discussed earlier, we should instead create copies of that `CUSTOMER` database
    across all services to avoid service coupling. But how do we do that?'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Maintaining database consistency across MSA](img/B18934_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Maintaining database consistency across MSA'
  prefs: []
  type: TYPE_NORMAL
- en: The `CUSTOMER` database is mainly managed by the `CUSTOMER` database whenever
    a record is edited, created, or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The orchestrator will need to wait for a success confirmation from all four
    services, `CUSTOMER` database fails? You will end up with data inconsistency,
    which can be a serious issue later on.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why all saga participants’ local transactions will need to have a set
    of compensating transactions to ensure a rollback in case of any failures in executing
    the transaction. In our example, the orchestrator will need to undo updates to
    the `CUSTOMER` database for all the other services.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows how a failure to update the `CUSTOMER` database
    should be rolled back using saga patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Compensating transactions for registering new customer information
    and placing an order](img/B18934_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Compensating transactions for registering new customer information
    and placing an order'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were able to go over the main steps of refactoring a monolith
    into an MSA, the steps necessary, the main things to consider, and the methodology
    of doing so. The simplified ABC-Monolith system was a good example; however, as
    systems get more complicated and the workflow gets more involved, data and process
    synchronization challenges start to arise.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18934_01.xhtml#_idTextAnchor014), we briefly discussed the
    challenges and the methodologies to be applied to overcome these challenges. In
    the next chapter, we will start applying the methodology to the ABC system we
    are trying to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how we can further maintain microservices’
    autonomy and MSA stability and overcome some other operational challenges, and
    the role of API gateways, orchestrators, and microservice aggregators.
  prefs: []
  type: TYPE_NORMAL
