["```py\nfunction process_command(command::String, args)\n    if command == \"open\"\n        # open a file\n    elseif command == \"close\"\n        # close current file\n    elseif command == \"exit\"\n        # exit program\n    elseif command == \"help\"\n        # pops up a help dialog\n    else\n        error(\"bug - this should have never happened.\")\n    end\nend\n```", "```py\nstruct OpenCommand end\n```", "```py\nOpenCommand()\n```", "```py\nstruct Val{x} end\n```", "```py\nfunction process_command(::Val{:open}, filename) \n    println(\"opening file $filename\")\nend\n\nfunction process_command(::Val{:close}, filename) \n    println(\"closing file $filename\")\nend\n```", "```py\nfunction process_command(command::String, args...)\n    process_command(Val(Symbol(command)), args...)\nend\n```", "```py\n# A parametric type that represents a specific command\nstruct Command{T} end\n\n# Constructor function to create a new Command instance from a string\nCommand(s::AbstractString) = Command{Symbol(s)}()\n```", "```py\n# Dispatcher function\nfunction process_command(command::String, args...)\n    process_command(Command(command), args...)\nend\n\n# Actions\nfunction process_command(::Command{:open}, filename) \n    println(\"opening file $filename\")\nend\n\nfunction process_command(::Command{:close}, filename) \n    println(\"closing file $filename\")\nend\n```", "```py\nfunction ntuple(f::F, n::Integer) where F\n    t = n == 0 ? () :\n        n == 1 ? (f(1),) :\n        n == 2 ? (f(1), f(2)) :\n        n == 3 ? (f(1), f(2), f(3)) :\n        n == 4 ? (f(1), f(2), f(3), f(4)) :\n        n == 5 ? (f(1), f(2), f(3), f(4), f(5)) :\n        n == 6 ? (f(1), f(2), f(3), f(4), f(5), f(6)) :\n        n == 7 ? (f(1), f(2), f(3), f(4), f(5), f(6), f(7)) :\n        n == 8 ? (f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8)) :\n        n == 9 ? (f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8), f(9)) :\n        n == 10 ? (f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8), f(9), f(10)) :\n        _ntuple(f, n)\n    return t\nend\n```", "```py\nfunction _ntuple(f, n)\n    @_noinline_meta\n    (n >= 0) || throw(ArgumentError(string(\"tuple length should be ≥ 0, got \", n)))\n    ([f(i) for i = 1:n]...,)\nend\n```", "```py\n# Using singleton type dynamic dispatch\n# inferrable ntuple (enough for bootstrapping)\nntuple(f, ::Val{0}) = ()\nntuple(f, ::Val{1}) = (@_inline_meta; (f(1),))\nntuple(f, ::Val{2}) = (@_inline_meta; (f(1), f(2)))\nntuple(f, ::Val{3}) = (@_inline_meta; (f(1), f(2), f(3)))\n\n@inline function ntuple(f::F, ::Val{N}) where {F,N}\n    N::Int\n    (N >= 0) || throw(ArgumentError(string(\"tuple length should be ≥ 0, got \", N)))\n    if @generated\n        quote\n            @nexprs $N i -> t_i = f(i)\n            @ncall $N tuple t\n        end\n    else\n        Tuple(f(i) for i = 1:N)\n    end\nend\n```", "```py\nmodule CreditApproval\n\n# primary function to open an account\nfunction open_account(first_name, last_name, email) end\n\n# supportive functions \nfunction check_background(first_name, last_name) end\nfunction create_account(first_name, last_name, email) end\nfunction notify_downstream(account_number) end\n\nend\n```", "```py\n# Background check. \n# In practice, we would call a remote service for this.\n# For this example, we just return true.\nfunction check_background(first_name, last_name)\n    println(\"Doing background check for $first_name $last_name\")\n    return true\nend\n```", "```py\n# Create an account.\n# In practice, we would actually create a record in database.\n# For this example, we return an account number of 1.\nfunction create_account(first_name, last_name, email)\n    println(\"Creating an account for $first_name $last_name\")\n    return 1\nend\n```", "```py\n# Notify downstream system by sending a message.\n# For this example, we just print to console and returns nothing.\nfunction notify_downstream(account_number)\n    println(\"Notifying downstream system about new account $account_number\")\n    return nothing\nend\n```", "```py\n# Open a new account. \n# Returns `:success` if account is created successfully.\n# Returns `:failure` if background check fails.\nfunction open_account(first_name, last_name, email)\n    check_background(first_name, last_name) || return :failure\n    account_number = create_account(first_name, last_name, email)\n    notify_downstream(account_number)\n    return :success\nend\n```", "```py\nfunction open_account(first_name, last_name, email; checker = check_background)\n    checker(first_name, last_name) || return :failure\n    account_number = create_account(first_name, last_name, email)\n    notify_downstream(account_number)\n    return :success\nend\n```", "```py\n@testset \"CreditApprovalStub.jl\" begin\n\n# stubs\ncheck_background_success(first_name, last_name) = true\ncheck_background_failure(first_name, last_name) = false\n\n# testing\nlet first_name = \"John\", last_name = \"Doe\", email = \"jdoe@julia-is-awesome.com\"\n    @test open_account(first_name, last_name, email, checker = check_background_success) == :success\n    @test open_account(first_name, last_name, email, checker = check_background_failure) == :failure\nend\n```", "```py\nusing Mocking\n\nfunction open_account(first_name, last_name, email)\n    @mock(check_background(first_name, last_name)) || return :failure\n    account_number = create_account(first_name, last_name, email)\n    notify_downstream(account_number)\n    return :success\nend \n```", "```py\nusing Mocking\nMocking.activate()\n```", "```py\ncheck_background_success_patch = \n    @patch function check_background(first_name, last_name)\n        println(\"check_background stub ==> simulating success\")\n        return true\n    end\n\ncheck_background_failure_patch =\n    @patch function check_background(first_name, last_name)\n        println(\"check_background stub ==> simulating failure\")\n        return false\n    end\n```", "```py\n# test background check failure case\napply(check_background_failure_patch) do \n    @test open_account(\"john\", \"doe\", \"jdoe@julia-is-awesome.com\") == :failure\nend\n\n# test background check successful case\napply(check_background_success_patch) do \n    @test open_account(\"peter\", \"doe\", \"pdoe@julia-is-awesome.com\") == :success\nend\n```", "```py\nfunction open_account(first_name, last_name, email)\n    @mock(check_background(first_name, last_name)) || return :failure\n    account_number = @mock(create_account(first_name, last_name, email))\n    @mock(notify_downstream(account_number))\n    return :success\nend\n```", "```py\ncreate_account_patch = \n    @patch function create_account(first_name, last_name, email)\n        println(\"create_account stub is called\")\n        return 314\n    end\n```", "```py\napply([check_background_success_patch, create_account_patch]) do\n    @test open_account(\"peter\", \"doe\", \"pdoe@julia-is-awesome.com\") == :success\nend\n```", "```py\nlet check_background_call_count  = 0,\n    create_account_call_count    = 0,\n    notify_downstream_call_count = 0,\n    notify_downstream_received_proper_account_number = false\n\n    # insert more code here...\nend\n```", "```py\ncheck_background_success_patch = \n    @patch function check_background(first_name, last_name)\n        check_background_call_count += 1\n        println(\"check_background mock is called, simulating success\")\n        return true\n    end\n```", "```py\ncreate_account_patch = \n    @patch function create_account(first_name, last_name, email)\n        create_account_call_count += 1\n        println(\"create account_number mock is called\")\n        return 314\n    end\n```", "```py\nnotify_downstream_patch = \n    @patch function notify_downstream(account_number)\n        notify_downstream_call_count += 1\n        if account_number > 0\n            notify_downstream_received_proper_account_number = true\n        end\n        println(\"notify downstream mock is called\")\n        return nothing\n    end\n```", "```py\nfunction verify()\n    @test check_background_call_count  == 1\n    @test create_account_call_count    == 1\n    @test notify_downstream_call_count == 1\n    @test notify_downstream_received_proper_account_number\nend\n```", "```py\napply([check_background_success_patch, create_account_patch, notify_downstream_patch]) do\n    @test open_account(\"peter\", \"doe\", \"pdoe@julia-is-awesome.com\") == :success\nend\n```", "```py\nverify()\n```", "```py\nusing HTTP\nusing JSON3\n\nfunction fetch_top_stories()\n    url = \"https://hacker-news.firebaseio.com/v0/topstories.json\"\n    response = HTTP.request(\"GET\", url)\n    return JSON3.read(String(response.body))\nend\n```", "```py\nstruct Story\n    by::String\n    descendants::Union{Nothing,Int}\n    score::Int\n    time::Int\n    id::Int\n    title::String\n    kids::Union{Nothing,Vector{Int}}\n    url::Union{Nothing,String}\nend\n```", "```py\n# Construct a Story from a Dict (or Dict-compatible) object\nfunction Story(obj)\n    value = (x) -> get(obj, x, nothing)\n    return Story(\n        obj[:by], \n        value(:descendants), \n        obj[:score], \n        obj[:time],\n        obj[:id], \n        obj[:title], \n        value(:kids), \n        value(:url))\nend\n```", "```py\nfunction fetch_story(id)\n    url = \"https://hacker-news.firebaseio.com/v0/item/$(id).json\"\n    response = HTTP.request(\"GET\", url)\n    return Story(JSON3.read(response.body))\nend\n```", "```py\nusing Statistics: mean\n\nfunction average_score(n = 10)\n    story_ids = fetch_top_stories()\n    println(now(), \" Found \", length(story_ids), \" stories\")\n\n    top_stories = [fetch_story(id) for id in story_ids[1:min(n,end)]]\n    println(now(), \" Fetched \", n, \" story details\")\n\n    avg_top_scores = mean(s.score for s in top_stories)\n    println(now(), \" Average score = \", avg_top_scores)\n\n    return avg_top_scores\nend\n```", "```py\nfunction average_score(n = 10)\n    story_ids = fetch_top_stories()\n    println(now(), \" Found \", length(story_ids), \" stories\")\n\n    top_stories = [fetch_story(id) for id in story_ids[1:min(n,end)]]\n    println(now(), \" Fetched \", n, \" story details\")\n\n    avg_top_scores = mean(s.score for s in top_stories)\n    println(now(), \" Average score = \", avg_top_scores)\n\n    return avg_top_scores\nend\n```", "```py\naverage_score2(n = 10) = \n    fetch_top_stories() |> \n    take(n) |> \n    fetch_story_details |> \n    calculate_average_score\n```", "```py\ntake(n::Int) = xs -> xs[1:min(n,end)]\n\nfetch_story_details(ids::Vector{Int}) = fetch_story.(ids)\n\ncalculate_average_score(stories::Vector{Story}) = mean(s.score for s in stories)\n```", "```py\nusing Formatting: printfmtln\n\nlogx(fmt::AbstractString, f::Function = identity) = x -> begin\n    let y = f(x)\n        print(now(), \" \")\n        printfmtln(fmt, y)\n    end\n    return x\nend\n```", "```py\naverage_score3(n = 10) = \n    fetch_top_stories()                        |> \n    logx(\"Number of top stories = {}\", length) |>\n    take(n)                                    |> \n    logx(\"Limited number of stories = $n\")     |>\n    fetch_story_details                        |> \n    logx(\"Fetched story details\")              |>\n    calculate_average_score                    |> \n    logx(\"Average score = {}\")\n```", "```py\nhotness(score) = score > 100 ? Val(:high) : Val(:low)\n```", "```py\ncelebrate(v::Val{:high}) = logx(\"Woohoo! Lots of hot topics!\")(v)\ncelebrate(v::Val{:low}) = logx(\"It's just a normal day...\")(v)\n```", "```py\ncheck_hotness(n = 10) =\n    average_score3(n) |> hotness |> celebrate\n```", "```py\nadd1v(xs) = [x + 1 for x in xs]\nmul2v(xs) = [2x for x in xs]\n```", "```py\nadd1mul2v(xs) = xs |> add1v |> mul2v\n```", "```py\nadd1(x) = x + 1\nmul2(x) = 2x\n```", "```py\nadd1mul2(xs) = xs .|> add1 .|> mul2\n```", "```py\ntake(n::Int) = xs -> xs[1:min(n,end)]\n```"]