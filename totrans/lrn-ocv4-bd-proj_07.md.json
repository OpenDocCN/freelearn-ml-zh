["```py\n#include \"opencv2/core/utility.hpp\"\n#include \"opencv2/objdetect/objdetect.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/highgui.hpp\"\n\nusing namespace cv;\nusing namespace std;\n\n...\n\nint main(int argc, char* argv[]) \n{ \n    string faceCascadeName = argv[1]; \n\n    // Variable declaration and initialization \n    ...\n    // Iterate until the user presses the Esc key \n    while(true) \n    { \n        // Capture the current frame \n        cap >> frame; \n\n        // Resize the frame \n        resize(frame, frame, Size(), scalingFactor, scalingFactor, INTER_AREA); \n\n        // Convert to grayscale \n        cvtColor(frame, frameGray, COLOR_BGR2GRAY); \n\n        // Equalize the histogram \n        equalizeHist(frameGray, frameGray); \n\n        // Detect faces \n        faceCascade.detectMultiScale(frameGray, faces, 1.1, 2, 0|HAAR_SCALE_IMAGE, Size(30, 30) ); \n```", "```py\n        // Draw green rectangle around the face \n        for(auto& face:faces) \n        { \n            Rect faceRect(face.x, face.y, face.width, face.height); \n\n            // Custom parameters to make the mask fit your face. You may have to play around with them to make sure it works. \n            int x = face.x - int(0.1*face.width); \n            int y = face.y - int(0.0*face.height); \n            int w = int(1.1 * face.width); \n            int h = int(1.3 * face.height); \n\n            // Extract region of interest (ROI) covering your face \n            frameROI = frame(Rect(x,y,w,h));\n```", "```py\n            // Resize the face mask image based on the dimensions of the above ROI \n            resize(faceMask, faceMaskSmall, Size(w,h)); \n\n            // Convert the previous image to grayscale \n            cvtColor(faceMaskSmall, grayMaskSmall, COLOR_BGR2GRAY); \n\n            // Threshold the previous image to isolate the pixels associated only with the face mask \n            threshold(grayMaskSmall, grayMaskSmallThresh, 230, 255, THRESH_BINARY_INV); \n```", "```py\n            // Create mask by inverting the previous image (because we don't want the background to affect the overlay) \n            bitwise_not(grayMaskSmallThresh, grayMaskSmallThreshInv); \n\n            // Use bitwise \"AND\" operator to extract precise boundary of face mask \n            bitwise_and(faceMaskSmall, faceMaskSmall, maskedFace, grayMaskSmallThresh); \n\n            // Use bitwise \"AND\" operator to overlay face mask \n            bitwise_and(frameROI, frameROI, maskedFrame, grayMaskSmallThreshInv); \n\n            // Add the previously masked images and place it in the original frame ROI to create the final image \n            add(maskedFace, maskedFrame, frame(Rect(x,y,w,h))); \n        } \n\n    // code dealing with memory release and GUI \n\n    return 1; \n} \n```", "```py\n...\nint main(int argc, char* argv[]) \n{ \n    string faceCascadeName = argv[1]; \n    string eyeCascadeName = argv[2]; \n\n    // Variable declaration and initialization\n    ....\n    // Face detection code \n    ....\n    vector<Point> centers; \n    ....     \n    // Draw green circles around the eyes \n    for( auto& face:faces ) \n    { \n        Mat faceROI = frameGray(face[i]); \n        vector<Rect> eyes; \n\n        // In each face, detect eyes eyeCascade.detectMultiScale(faceROI, eyes, 1.1, 2, 0 |CV_HAAR_SCALE_IMAGE, Size(30, 30)); \n```", "```py\n            // For each eye detected, compute the center \n            for(auto& eyes:eyes) \n            { \n                Point center( face.x + eye.x + int(eye.width*0.5), face.y + eye.y + int(eye.height*0.5) ); \n                centers.push_back(center); \n            } \n        } \n\n        // Overlay sunglasses only if both eyes are detected \n        if(centers.size() == 2) \n        { \n            Point leftPoint, rightPoint; \n\n            // Identify the left and right eyes \n            if(centers[0].x < centers[1].x) \n            { \n                leftPoint = centers[0]; \n                rightPoint = centers[1]; \n            } \n            else \n            { \n                leftPoint = centers[1]; \n                rightPoint = centers[0]; \n            } \n```", "```py\n            // Custom parameters to make the sunglasses fit your face. You may have to play around with them to make sure it works. \n            int w = 2.3 * (rightPoint.x - leftPoint.x); \n            int h = int(0.4 * w); \n            int x = leftPoint.x - 0.25*w; \n            int y = leftPoint.y - 0.5*h; \n\n            // Extract region of interest (ROI) covering both the eyes \n            frameROI = frame(Rect(x,y,w,h)); \n\n            // Resize the sunglasses image based on the dimensions of the above ROI \n            resize(eyeMask, eyeMaskSmall, Size(w,h)); \n```", "```py\n            // Convert the previous image to grayscale \n            cvtColor(eyeMaskSmall, grayMaskSmall, COLOR_BGR2GRAY); \n\n            // Threshold the previous image to isolate the foreground object \n            threshold(grayMaskSmall, grayMaskSmallThresh, 245, 255, THRESH_BINARY_INV); \n\n            // Create mask by inverting the previous image (because we don't want the background to affect the overlay) \n            bitwise_not(grayMaskSmallThresh, grayMaskSmallThreshInv); \n\n            // Use bitwise \"AND\" operator to extract precise boundary of sunglasses \n            bitwise_and(eyeMaskSmall, eyeMaskSmall, maskedEye, grayMaskSmallThresh); \n\n            // Use bitwise \"AND\" operator to overlay sunglasses \n            bitwise_and(frameROI, frameROI, maskedFrame, grayMaskSmallThreshInv); \n\n            // Add the previously masked images and place it in the original frame ROI to create the final image \n            add(maskedEye, maskedFrame, frame(Rect(x,y,w,h))); \n        } \n\n        // code for memory release and GUI \n\n    return 1; \n} \n```"]