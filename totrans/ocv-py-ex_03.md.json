["```py\nimport cv2\n\ncap = cv2.VideoCapture(0)\n\n# Check if the webcam is opened correctly\nif not cap.isOpened():\n    raise IOError(\"Cannot open webcam\")\n\nwhile True:\n    ret, frame = cap.read()\n    frame = cv2.resize(frame, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)\n    cv2.imshow('Input', frame)\n\n    c = cv2.waitKey(1)\n    if c == 27:\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n```", "```py\nret, frame = cap.read()\n```", "```py\nif c == 27:\n```", "```py\nimport argparse\n\nimport cv2\n\ndef argument_parser():\n    parser = argparse.ArgumentParser(description=\"Change color space of the \\\n            input video stream using keyboard controls. The control keys are: \\\n            Grayscale - 'g', YUV - 'y', HSV - 'h'\")\n    return parser\n\nif __name__=='__main__':\n    args = argument_parser().parse_args()\n\n    cap = cv2.VideoCapture(0)\n\n    # Check if the webcam is opened correctly\n    if not cap.isOpened():\n        raise IOError(\"Cannot open webcam\")\n\n    cur_char = -1\n    prev_char = -1\n\n    while True:\n        # Read the current frame from webcam\n        ret, frame = cap.read()\n\n        # Resize the captured image\n        frame = cv2.resize(frame, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)\n\n        c = cv2.waitKey(1)\n\n        if c == 27:\n            break\n\n        if c > -1 and c != prev_char:\n            cur_char = c\n        prev_char = c\n\n        if cur_char == ord('g'):\n            output = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        elif cur_char == ord('y'):\n            output = cv2.cvtColor(frame, cv2.COLOR_BGR2YUV)\n\n        elif cur_char == ord('h'):\n            output = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\n        else:\n            output = frame\n\n        cv2.imshow('Webcam', output)\n\n    cap.release()\n    cv2.destroyAllWindows()\n```", "```py\nimport cv2\nimport numpy as np\n\ndef detect_quadrant(event, x, y, flags, param):\n    if event == cv2.EVENT_LBUTTONDOWN:\n        if x > width/2:\n            if y > height/2:\n                point_top_left = (int(width/2), int(height/2))\n                point_bottom_right = (width-1, height-1)\n            else:\n                point_top_left = (int(width/2), 0)\n                point_bottom_right = (width-1, int(height/2))\n\n        else:\n            if y > height/2:\n                point_top_left = (0, int(height/2))\n                point_bottom_right = (int(width/2), height-1)\n            else:\n                point_top_left = (0, 0)\n                point_bottom_right = (int(width/2), int(height/2))\n\n        cv2.rectangle(img, (0,0), (width-1,height-1), (255,255,255), -1)\n        cv2.rectangle(img, point_top_left, point_bottom_right, (0,100,0), -1)\n\nif __name__=='__main__':\n    width, height = 640, 480\n    img = 255 * np.ones((height, width, 3), dtype=np.uint8)\n    cv2.namedWindow('Input window')\n    cv2.setMouseCallback('Input window', detect_quadrant)\n\n    while True:\n        cv2.imshow('Input window', img)\n        c = cv2.waitKey(10)\n        if c == 27:\n            break\n\n    cv2.destroyAllWindows()\n```", "```py\n>>> import cv2\n>>> print [x for x in dir(cv2) if x.startswith('EVENT')]\n```", "```py\nimport cv2\nimport numpy as np\n\ndef draw_rectangle(event, x, y, flags, params):\n    global x_init, y_init, drawing, top_left_pt, bottom_right_pt\n\n    if event == cv2.EVENT_LBUTTONDOWN:\n        drawing = True\n        x_init, y_init = x, y\n\n    elif event == cv2.EVENT_MOUSEMOVE:\n        if drawing:\n            top_left_pt = (min(x_init, x), min(y_init, y))\n            bottom_right_pt = (max(x_init, x), max(y_init, y))\n            img[y_init:y, x_init:x] = 255 - img[y_init:y, x_init:x]\n\n    elif event == cv2.EVENT_LBUTTONUP:\n        drawing = False\n        top_left_pt = (min(x_init, x), min(y_init, y))\n        bottom_right_pt = (max(x_init, x), max(y_init, y))\n        img[y_init:y, x_init:x] = 255 - img[y_init:y, x_init:x]\n\nif __name__=='__main__':\n    drawing = False\n    top_left_pt, bottom_right_pt = (-1,-1), (-1,-1)\n\n    cap = cv2.VideoCapture(0)\n\n    # Check if the webcam is opened correctly\n    if not cap.isOpened():\n        raise IOError(\"Cannot open webcam\")\n\n    cv2.namedWindow('Webcam')\n    cv2.setMouseCallback('Webcam', draw_rectangle)\n\n    while True:\n        ret, frame = cap.read()\n        img = cv2.resize(frame, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)\n        (x0,y0), (x1,y1) = top_left_pt, bottom_right_pt\n        img[y0:y1, x0:x1] = 255 - img[y0:y1, x0:x1]\n        cv2.imshow('Webcam', img)\n\n        c = cv2.waitKey(1)\n        if c == 27:\n            break\n\n    cap.release()\n    cv2.destroyAllWindows()\n```", "```py\ncv2.setMouseCallback('Webcam', draw_rectangle)\n```", "```py\nimport cv2\nimport numpy as np\n\ndef cartoonize_image(img, ds_factor=4, sketch_mode=False):\n    # Convert image to grayscale\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    # Apply median filter to the grayscale image\n    img_gray = cv2.medianBlur(img_gray, 7)\n\n    # Detect edges in the image and threshold it\n    edges = cv2.Laplacian(img_gray, cv2.CV_8U, ksize=5)\n    ret, mask = cv2.threshold(edges, 100, 255, cv2.THRESH_BINARY_INV)\n\n    # 'mask' is the sketch of the image\n    if sketch_mode:\n        return cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)\n\n    # Resize the image to a smaller size for faster computation\n    img_small = cv2.resize(img, None, fx=1.0/ds_factor, fy=1.0/ds_factor, interpolation=cv2.INTER_AREA)\n    num_repetitions = 10\n    sigma_color = 5\n    sigma_space = 7\n    size = 5\n\n    # Apply bilateral filter the image multiple times\n    for i in range(num_repetitions):\n        img_small = cv2.bilateralFilter(img_small, size, sigma_color, sigma_space)\n\n    img_output = cv2.resize(img_small, None, fx=ds_factor, fy=ds_factor, interpolation=cv2.INTER_LINEAR)\n\n    dst = np.zeros(img_gray.shape)\n\n    # Add the thick boundary lines to the image using 'AND' operator\n    dst = cv2.bitwise_and(img_output, img_output, mask=mask)\n    return dst\n\nif __name__=='__main__':\n    cap = cv2.VideoCapture(0)\n\n    cur_char = -1\n    prev_char = -1\n\n    while True:\n        ret, frame = cap.read()\n        frame = cv2.resize(frame, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)\n\n        c = cv2.waitKey(1)\n        if c == 27:\n            break\n\n        if c > -1 and c != prev_char:\n            cur_char = c\n        prev_char = c\n\n        if cur_char == ord('s'):\n            cv2.imshow('Cartoonize', cartoonize_image(frame, sketch_mode=True))\n        elif cur_char == ord('c'):\n            cv2.imshow('Cartoonize', cartoonize_image(frame, sketch_mode=False))\n        else:\n            cv2.imshow('Cartoonize', frame)\n\n    cap.release()\n    cv2.destroyAllWindows()\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.png')\noutput = cv2.medianBlur(img, 7)\ncv2.imshow('Input', img)\ncv2.imshow('Median filter', output)\ncv2.waitKey()\n```", "```py\nif sketch_mode:\n    img_sketch = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)\n    kernel = np.ones((3,3), np.uint8)\n    img_eroded = cv2.erode(img_sketch, kernel, iterations=1)\n    return cv2.medianBlur(img_eroded, 5)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg')\n\nimg_gaussian = cv2.GaussianBlur(img, (13,13), 0)\nimg_bilateral = cv2.bilateralFilter(img, 13, 70, 50)\n\ncv2.imshow('Input', img)\ncv2.imshow('Gaussian filter', img_gaussian)\ncv2.imshow('Bilateral filter', img_bilateral)\ncv2.waitKey()\n```", "```py\nimg_small = cv2.bilateralFilter(img_small, size, sigma_color, sigma_space)\n```"]