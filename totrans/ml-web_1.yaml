- en: Chapter 1. Introduction to Practical Machine Learning Using Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 使用Python的实用机器学习简介
- en: In the technology industry, the skill of analyzing and mining commercial data
    is becoming more and more important. All the companies that are related to the
    online world generate data that can be exploited to improve their business, or
    can be sold to other companies. This huge amount of information, which can be
    commercially useful, needs to be restructured and analyzed using the expertise
    of data science (or data mining) professionals. Data science employs techniques
    known as machine learning algorithms to transform the data in models, which are
    able to predict the behavior of certain entities that are highly considered by
    the business environment. This book is about these algorithms and techniques that
    are so crucial in today's technology business world, and how to efficiently deploy
    them in a real commercial environment. You will learn the most relevant machine-learning
    techniques and will have the chance to employ them in a series of exercises and
    applications designed to enhance commercial awareness and, with the skills learned
    in this book, these can be used in your professional experience. You are expected
    to already be familiar with the Python programming language, linear algebra, and
    statistics methodologies to fully acquire the topics discussed in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在科技行业，分析和挖掘商业数据的能力正变得越来越重要。所有与网络世界相关的公司都会产生可以被利用来改善其业务或出售给其他公司的数据。这些可以用于商业的信息量巨大，需要使用数据科学（或数据挖掘）专业人士的专长对其进行重构和分析。数据科学采用被称为机器学习算法的技术来将数据转化为模型，这些模型能够预测商业环境高度关注的某些实体的行为。本书就是关于这些在当今科技商业世界中至关重要的算法和技术，以及如何在真实商业环境中高效地部署它们。你将学习最相关的机器学习技术，并将有机会在一系列旨在增强商业意识和运用本书中学到的技能的练习和应用程序中应用它们。我们期望你已经熟悉Python编程语言、线性代数和统计方法，以便完全掌握本书中讨论的主题。
- en: There are many tutorials and classes available online on these subjects, but
    we recommend you read the official Python documentation ([https://docs.python.org/](https://docs.python.org/)
    ), the books *Elementary Statistics* by A. Bluman and *Statistical Inference*
    by G. Casella and R. L. Berger to understand the statistical main concepts and
    methods and *Linear Algebra and Its Applications* by G. Strang to learn about
    linear algebra.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线有关于这些主题的许多教程和课程，但我们建议你阅读官方的Python文档([https://docs.python.org/](https://docs.python.org/)
    )，A. Bluman的《基础统计学》和G. Casella、R. L. Berger的《统计推断》来了解统计的主要概念和方法，以及G. Strang的《线性代数及其应用》来学习线性代数。
- en: The purpose of this introductory chapter is to familiarize you with the more
    advanced libraries and tools used by machine-learning professionals in Python,
    such as **NumPy** , **pandas,** and **matplotlib,** which will help you to grasp
    the necessary technical knowledge to implement the techniques presented in the
    following chapters. Before continuing with the tutorials and description of the
    libraries used in this book, we would like to clarify the main concepts of the
    machine-learning field, and give a practical example of how a machine-learning
    algorithm can predict useful information in a real context.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本介绍章节的目的是让你熟悉机器学习专业人士在Python中使用的更高级的库和工具，如**NumPy**、**pandas**和**matplotlib**，这些将帮助你掌握实施以下章节中介绍的技术所需的技术知识。在继续使用本书中使用的教程和库的描述之前，我们想澄清机器学习领域的主要概念，并给出一个机器学习算法如何在真实环境中预测有用信息的实际示例。
- en: General machine-learning concepts
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用机器学习概念
- en: In this book, the most relevant machine-learning algorithms are going to be
    discussed and used in exercises to make you familiar with them. In order to explain
    these algorithms and to understand the content of this book, there are a few general
    concepts we need to visit that are going to be described hereafter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将讨论并使用最相关的机器学习算法，并通过练习使你熟悉它们。为了解释这些算法并理解本书的内容，我们需要了解一些一般概念，以下将进行描述。
- en: First of all, a good definition of machine learning is the subfield of computer
    science that has been developed from the fields of pattern recognition, artificial
    intelligence, and computational learning theory. Machine learning can also be
    seen as a data-mining tool, which focuses more on the data analysis aspects to
    understand the data provided. The purpose of this discipline is the development
    of programs, which are able to *learn* from previously seen data, through tunable
    parameters (usually arrays of double precision values), that are designed to be
    adjusted automatically to improve the resulting predictions. In this way, computers
    can predict a behavior, *generalizing* the underlying structure of the data, instead
    of just storing (or retrieving) the values like usual database systems. For this
    reason, machine learning is associated with computational statics, which also
    attempt to predict a behavior based on previous data. Common industrial applications
    of machine-learning algorithms are spam filtering, search engines, optical character
    recognition, and computer vision. Now that we have defined the discipline, we
    can describe the terminology used in each machine-learning problem, in more detail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对机器学习的良好定义是计算机科学的一个子领域，它从模式识别、人工智能和计算学习理论等领域发展而来。机器学习也可以被视为一种数据挖掘工具，它更侧重于数据分析方面来理解提供的数据。这个学科的目的在于开发能够从先前看到的数据中*学习*的程序，这些程序通过可调参数（通常是双精度值数组）设计为自动调整以改进预测结果。通过这种方式，计算机可以预测一种行为，*泛化*数据的潜在结构，而不是像传统的数据库系统那样仅仅存储（或检索）值。因此，机器学习与计算统计学相关联，后者也试图根据先前数据预测行为。机器学习算法的常见工业应用包括垃圾邮件过滤、搜索引擎、光学字符识别和计算机视觉。现在我们已经定义了这个学科，我们可以更详细地描述每个机器学习问题中使用的术语。
- en: 'Any learning problem starts with a data set of *n* samples, which are used
    to predict the properties of the future unknown data. Each sample is typically
    composed of more than a single value so it is a vector. The components of this
    vector are called *features* . For example, imagine predicting the price of a
    second-hand car based on its characteristics: year of fabrication, color, engine
    size, and so on. Each car *i* in the dataset will be a vector of features *x(i)*
    that corresponds to its color, engine size, and many others. In this case, there
    is also a *target* (or label) variable associated with each car *i* , *y(i)* which
    is the second-hand car price. A *training example* is formed by a pair *(x(i),
    y(i))* and therefore the complete set of *N* data points used to learn is called
    a *training dataset {(x(i), y(i));i=1,…,N}* . The symbol *x* will denote the space
    of feature (input) values, and *y* the space of target (output) values. The machine-learning
    algorithm chosen to solve the problem will be described by a mathematical model,
    with some parameters to tune in the training set. After the training phase is
    completed, the performance of the prediction is evaluated using another two sets:
    validation and testing sets. The validation set is used to choose, among multiple
    models, the one that returns the best results, while the testing set is usually
    used to determine the actual precision of the chosen model. Typically the dataset
    is divided into 50% training set, 25% validation set, and 25% testing set.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 任何学习问题都始于一个包含*n*个样本的数据集，这些样本用于预测未来未知数据的属性。每个样本通常由多个值组成，因此它是一个向量。这个向量的组成部分被称为*特征*。例如，想象一下根据其特征预测二手车的价格：制造年份、颜色、发动机大小等。数据集中的每辆汽车*i*将是一个特征向量*x(i)*，它对应于其颜色、发动机大小和其他许多属性。在这种情况下，也与每辆汽车*i*相关联的一个*目标*（或标签）变量*y(i)*，它是二手车的价格。一个*训练示例*由一对*(x(i),
    y(i))*组成，因此用于学习的完整数据点集称为*训练数据集*{(x(i), y(i));i=1,…,N}。符号*x*将表示特征（输入）值的空间，而*y*表示目标（输出）值的范围。用于解决该问题的机器学习算法将通过一个数学模型来描述，其中一些参数需要在训练集中调整。在训练阶段完成后，使用另外两个集合来评估预测的性能：验证集和测试集。验证集用于在多个模型中选择返回最佳结果的模型，而测试集通常用于确定所选模型的实际精确度。通常，数据集被分为50%的训练集、25%的验证集和25%的测试集。
- en: 'The learning problems can be divided in two main categories (both of which
    are extensively covered in this book):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 学习问题可以分为两大类（这两类在本书中都有广泛的介绍）：
- en: '**Unsupervised learning** : The training dataset is given by input feature
    vectors *x* without any corresponding label values. The usual objective is to
    find similar examples within the data using clustering algorithms, or to project
    the data from a high-dimensional space down to a few dimensions (blind signal
    separations algorithms such as principal component analysis). Since there is usually
    no target value for each training example, it is not possible to evaluate errors
    of the model directly from the data; you need to use a technique that evaluates
    how the elements within each cluster are similar to each other and different from
    the other cluster''s members. This is one of the major differences between unsupervised
    learning and supervised learning.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无监督学习**：训练数据集由输入特征向量 *x* 给出，没有任何相应的标签值。通常的目标是使用聚类算法在数据中找到相似示例，或将数据从高维空间投影到几个维度（如主成分分析等盲信号分离算法）。由于通常每个训练示例都没有目标值，无法直接从数据中评估模型的误差；你需要使用一种技术来评估每个簇内的元素彼此相似以及与其他簇成员的不同。这是无监督学习和监督学习之间的一大区别。'
- en: '**Supervised learning** : Each data sample is given in a pair consisting of
    an input feature vector and a label value. The task is to infer the parameters
    to predict the target values of the test data. These types of problems can be
    further divided into:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监督学习**：每个数据样本都以一对形式给出，包括一个输入特征向量和标签值。任务是推断参数以预测测试数据的目标值。这类问题可以进一步分为：'
- en: '**Classification** : The data targets belong to two or more classes, and the
    goal is to learn how to predict the class of unlabeled data from the training
    set. Classification is a discrete (as opposed to continuous) form of supervised
    learning, where the label has a limited number of categories. A practical example
    of the classification problem is the handwritten digit recognition example, in
    which the objective is to match each feature vector to one of a finite number
    of discrete categories.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类**：数据目标属于两个或多个类别，目标是学习如何从训练集中预测未标记数据的类别。分类是监督学习的一种离散形式（与连续形式相对），其中标签有有限数量的类别。分类问题的实际例子是手写数字识别，其目标是将每个特征向量匹配到有限数量的离散类别之一。'
- en: '**Regression** : The label is a continuous variable. For example, the prediction
    of the height of a child based on his age and weight is a regression problem.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归**：标签是一个连续变量。例如，根据孩子的年龄和体重预测孩子身高的问题就是一个回归问题。'
- en: 'We are going to focus on unsupervised learning methods in [Chapter 2](text00020.html#ch02
    "Chapter 2. Unsupervised Machine Learning") , *Machine Learning Techniques: Unsupervised
    Learning,* while the most relevant supervised learning algorithms are discussed
    in [Chapter 3](text00024.html#page "Chapter 3. Supervised Machine Learning") ,
    *Supervised Machine Learning* . [Chapter 4](text00032.html#ch04 "Chapter 4. Web
    Mining Techniques") , *Web Mining Techniques* will approach the field of web-mining
    techniques that can also be considered as both supervised and unsupervised methods.
    The recommendation systems, which are again part of the supervised learning category,
    are described in [Chapter 5](text00037.html#page "Chapter 5. Recommendation Systems")
    , *Recommendation Systems* . The **Django** web framework is then introduced in
    [Chapter 6](text00046.html#ch06 "Chapter 6. Getting Started with Django") , *Getting
    Started with Django,* and then an example of the recommendation system (using
    both the Django framework and the algorithms explained in [Chapter 5](text00037.html#page
    "Chapter 5. Recommendation Systems") , *Recommendation Systems* ) is detailed
    in [Chapter 7](text00050.html#page "Chapter 7. Movie Recommendation System Web
    Application") , *Movie Recommendation System Web Application* . We finish the
    book with an example of a Django web-mining application, using some of the techniques
    learned in [Chapter 4](text00032.html#ch04 "Chapter 4. Web Mining Techniques")
    , *Web Mining Techniques* . By the end of the book you should be able to understand
    the different machine-learning methods and be able to deploy them in a real working
    web application using Django.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第二章](text00020.html#ch02 "第二章. 无监督机器学习")中关注无监督学习方法，*机器学习技术：无监督学习*，而最相关的监督学习算法将在[第三章](text00024.html#page
    "第三章. 监督机器学习")中讨论，*监督机器学习*。 [第四章](text00032.html#ch04 "第四章. 网络挖掘技术")，*网络挖掘技术*将探讨网络挖掘技术领域，这些技术也可以被视为监督和无监督方法。推荐系统，再次属于监督学习类别，在[第五章](text00037.html#page
    "第五章. 推荐系统")，*推荐系统*中描述。然后，在[第六章](text00046.html#ch06 "第六章. 开始使用Django")，*开始使用Django*中介绍了**Django**网络框架，并在[第七章](text00050.html#page
    "第七章. 电影推荐系统网络应用")，*电影推荐系统网络应用*中详细介绍了推荐系统（使用Django框架和[第五章](text00037.html#page
    "第五章. 推荐系统")，*推荐系统*中解释的算法）的示例。我们用Django网络挖掘应用的示例结束本书，使用[第四章](text00032.html#ch04
    "第四章. 网络挖掘技术")，*网络挖掘技术*中学到的一些技术。到本书结束时，你应该能够理解不同的机器学习方法，并能够在使用Django的真正工作网络应用中部署它们。
- en: We continue the chapter by giving an example of how machine learning can be
    used in real business problems and in tutorials for Python libraries (NumPy, pandas,
    and matplotlib), which are essential for putting the algorithms learned in each
    of the following chapters into practice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过提供一个示例来继续本章，说明机器学习如何在实际商业问题和Python库（NumPy、pandas和matplotlib）的教程中使用，这些库对于将每个后续章节中学到的算法付诸实践至关重要。
- en: Machine-learning example
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习示例
- en: 'To explain further what machine learning can do with real data, we consider
    the following example (the following code is available in the author''s GitHub
    book folder [https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_1/](https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_1/)
    ). We have taken the *Internet Advertisements Data Set* from the *UC Irvine Machine
    Learning Repository* ([http://archive.ics.uci.edu](http://archive.ics.uci.edu)
    ). Web advertisements have been collected from various web pages, and each of
    them has been transformed into a numeric feature''s vector. From the `ad.names`
    file we can see that the first three features represent the image size in the
    page, and the other features are related to the presence of specific words or
    phrases on the URL of the image or in the text (1558 features in total). The labels
    values are either `ad` or `nonad` , depending on whether the page has an advert
    or not. As an example, a web page in `ad.data` is given by:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释机器学习如何使用真实数据，我们考虑以下示例（以下代码可在作者的GitHub书籍文件夹[https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_1/](https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_1/)中找到）。我们从*UC
    Irvine机器学习仓库*（[http://archive.ics.uci.edu](http://archive.ics.uci.edu)）的*互联网广告数据集*中获取数据。从各种网页上收集了网络广告，并将每个广告转换为一个数值特征向量。从`ad.names`文件中我们可以看到，前三个特征代表页面中的图像大小，其他特征与图像URL或文本中特定单词或短语的呈现有关（总共有1558个特征）。标签值要么是`ad`，要么是`nonad`，这取决于页面是否有广告。以下是一个`ad.data`中的网页示例：
- en: '`125, 125, ...., 1\. 0, 1, 0, ad.`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`125, 125, ..., 1.0, 1, 0, ad.`'
- en: 'Based on this data, a classical machine-learning task is to find a model to
    predict which pages are adverts and which are not (classification). To start with,
    we consider the data file `ad.data` which contains the full feature''s vectors
    and labels, but it has also missing values indicated with a `?` . We can use the
    pandas Python library to transform the`?` to `-1` (see next paragraph for a full
    tutorial on the pandas library):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此数据，一个经典的机器学习任务就是找到一个模型来预测哪些页面是广告，哪些不是（分类）。首先，我们考虑包含完整特征向量和标签的数据文件`ad.data`，但其中也包含用`?`表示的缺失值。我们可以使用pandas
    Python库将`?`转换为`-1`（下一段将提供关于pandas库的完整教程）：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A **DataFrame** is created with the data from the `ad.data` file, and each
    `?` is first replaced with the an value (`replace` function), then with `-1` (the
    `fillna` function). Now each label has to be transformed into a numerical value
    (and so do all the other values in the data):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ad.data`文件中的数据创建了一个**DataFrame**，首先将每个`?`替换为空值（使用`replace`函数），然后替换为`-1`（使用`fillna`函数）。现在必须将每个标签转换为数值（数据中的所有其他值也是如此）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each `ad.` label has been transformed into `1` while the `nonad.` values have
    been replaced by `0` . All the columns (features) need to be numeric and float
    types (using the `astype` function and the `to_numeric` function through a `lambda`
    function).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ad.`标签已转换为`1`，而`nonad.`值已被替换为`0`。所有列（特征）都需要是数值和浮点类型（使用`astype`函数和通过`lambda`函数的`to_numeric`函数）。
- en: 'We want to use the **Support Vector Machine** ( **SVM** ) algorithm provided
    by the `scikit-learn` library (see [Chapter 3](text00024.html#page "Chapter 3. Supervised
    Machine Learning") , *Supervised Machine Learning* ) to predict 20% of the labels
    in the data. First, we split the data into two sets: a training set (80%) and
    a test set (20%):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用`scikit-learn`库提供的**支持向量机**（**SVM**）算法（见[第3章](text00024.html#page "第3章.
    监督机器学习")，*监督机器学习*）来预测数据中的20%标签。首先，我们将数据分为两个集合：一个训练集（80%）和一个测试集（20%）：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the libraries provided by Numpy (a tutorial is provided in the next paragraph),
    the data are shuffled (function `random.shuffle` ) before being split to assure
    the rows in the two sets are randomly selected. The `-1` notation indicates the
    last column of the array is not considered.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Numpy提供的库（下一段将提供教程），在分割数据以确保两个集合中的行随机选择之前，对数据进行打乱（使用`random.shuffle`函数）。`-1`表示数组的最后一列不考虑。
- en: 'Now we train our SVM model using the training data:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用训练数据来训练我们的SVM模型：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have defined our `clf` variable that declares the SVM model with the values
    of the parameters. Then the function `fit` is called to fit the model with the
    training data (see [Chapter 3](text00024.html#page "Chapter 3. Supervised Machine
    Learning") , *Supervised Machine Learning* for further details). The mean accuracy
    in predicting the 20% test cases is performed as follows, using the score function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`clf`变量，它声明了具有参数值的SVM模型。然后调用`fit`函数将模型与训练数据拟合（详见[第3章](text00024.html#page
    "第3章. 监督机器学习")，*监督机器学习*以获取更多详细信息）。预测20%测试案例的平均准确度如下，使用得分函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the preceding code (the full code is available in the `chapter_1` folder
    of the author''s GitHub account) gives a result of 92% accuracy, which means 92%
    of the test cases of the predicted label agree with the true label. This is the
    power of machine learning: from previous data, we are able to infer if a page
    will contain an advert or not. To achieve that, we have essentially prepared and
    manipulated the data using the NumPy and pandas libraries, and then applied the
    SVM algorithm on the cleaned data using the `scikit-learn` library. Since this
    book will largely employ the `numpy` and `pandas` (and some `matplotlib` ) libraries,
    the following paragraphs will discuss how to install the libraries and how the
    data can be manipulated (or even created) using these libraries.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码（完整代码可在作者的GitHub账户的`chapter_1`文件夹中找到）得到92%的准确率，这意味着92%的预测标签测试案例与真实标签一致。这是机器学习的力量：从以前的数据中，我们能够推断出页面是否包含广告。为了实现这一点，我们本质上使用NumPy和pandas库准备和操作了数据，然后使用`scikit-learn`库在清理后的数据上应用了SVM算法。由于本书将大量使用`numpy`和`pandas`（以及一些`matplotlib`）库，以下段落将讨论如何安装这些库以及如何使用这些库操作（甚至创建）数据。
- en: Installing and importing a module (library)
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和导入模块（库）
- en: 'Before continuing with the discussion on the libraries, we need to clarify
    how to install each module we want to use in Python. The usual way to install
    a module is through the `pip` command using the terminal:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论库之前，我们需要明确如何安装我们想在Python中使用的每个模块。安装模块的常用方法是使用终端中的`pip`命令：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The module is then usually imported into the code using the statement:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通常使用以下语句将模块导入到代码中：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `numpy` is the library name and `np` is the reference name from which
    any function *X* in the library can be accessed using `np.X` instead of `numpy.X`
    . We are going to assume that all the libraries (`scipy` , `scikit-learn` , `pandas`
    , `scrapy` , `nltk` , and all others) have been be installed and imported in this
    way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`numpy`是库名称，`np`是从中可以访问库中任何函数*X*的引用名称，使用`np.X`而不是`numpy.X`。我们将假设所有库（`scipy`、`scikit-learn`、`pandas`、`scrapy`、`nltk`以及所有其他库）都已按这种方式安装和导入。
- en: Preparing, manipulating and visualizing data – NumPy, pandas and matplotlib
    tutorials
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备、操作和可视化数据 – NumPy、pandas和matplotlib教程
- en: Most of the data comes in a very unpractical form for applying machine-learning
    algorithms. As we have seen in the example (in the preceding paragraph), the data
    can have missing values or non-numeric columns, which are not ready to be fed
    into any machine-learning technique. Therefore, a machine-learning professional
    usually spends a large amount of time cleaning and preparing the data to transform
    it into a form suitable for further analysis or visualization. This section will
    teach how to use `numpy` and `pandas` to create, prepare, and manipulate data
    in Python while the `matplotlib` paragraph will provide the basis of plotting
    a graph in Python. The Python shell has been used to discuss the NumPy tutorial,
    although all versions of the code in the IPython notebook, and plain Python script,
    are available in the `chapter_1` folder of the author's GitHub. pandas and matplotlib
    are discussed using the IPython notebook.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据以非常不实用的形式出现，无法应用于机器学习算法。正如我们在示例（上一段）中看到的，数据可能包含缺失值或非数值列，这些数据不适合输入到任何机器学习技术中。因此，机器学习专业人士通常花费大量时间清理和准备数据，将其转换为适合进一步分析或可视化的形式。本节将介绍如何使用`numpy`和`pandas`在Python中创建、准备和操作数据，而`matplotlib`部分将提供在Python中绘制图表的基础。Python
    shell已被用于讨论NumPy教程，尽管IPython笔记本中所有版本的代码以及纯Python脚本都可在作者的GitHub的`chapter_1`文件夹中找到。pandas和matplotlib使用IPython笔记本进行讨论。
- en: Using NumPy
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NumPy
- en: Numerical Python or NumPy, is an open source extension library for Python, and
    is a fundamental module required for data analysis and high performance scientific
    computing. The library features support Python for large, multi-dimensional arrays
    and matrices, and it provides precompiled functions for numerical routines. Furthermore,
    it provides a large library of mathematical functions to manipulate these arrays.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Numerical Python或NumPy是一个开源的Python扩展库，是数据分析和高性能科学计算的基本模块。该库支持Python处理大型、多维数组，并提供预编译的数值函数。此外，它还提供了一组丰富的数学函数来操作这些数组。
- en: 'The library provides the following functionalities:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供了以下功能：
- en: Fast multi-dimensional array for vector arithmetic operations
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的多维数组用于向量算术运算
- en: Standard mathematical functions for fast operations on entire arrays of data
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准数学函数，用于对整个数据数组进行快速操作
- en: Linear algebra
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性代数
- en: Sorting, unique, and set operations
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序、唯一和集合操作
- en: Statistics and aggregating data
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计和聚合数据
- en: 'The main advantage of NumPy is the speed of the usual array operations compared
    to standard Python operations. For instance, a traditional summation of 10000000
    elements:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的主要优势是，与标准的Python操作相比，常规数组操作的速度更快。例如，对10000000个元素进行传统求和：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Compare this to the Numpy function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与Numpy函数进行比较：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The time used is `2.1142539978` and `0.0807049274445` respectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所用时间是`2.1142539978`和`0.0807049274445`。
- en: Arrays creation
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组创建
- en: 'The array object is the main feature provided by the NumPy library. Arrays
    are the equivalent of Python lists, but each element of an array has the same
    numerical type (typically float or int). It is possible to define an array casting
    from a list using the function array by using the following code. Two arguments
    are passed to it: the list to be converted and the type of the new generated array:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象是NumPy库提供的主要功能。数组相当于Python列表，但数组中的每个元素都具有相同的数值类型（通常是float或int）。可以使用以下代码通过`array`函数从列表定义数组类型转换。向它传递两个参数：要转换的列表和新生成数组的数据类型：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And vice versa, an array can be transformed into a list by the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，可以使用以下代码将数组转换为列表：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Assigning an array to a new one will not create a new copy in memory, it will
    just link the new name to the same original object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个数组赋值给新变量时，不会在内存中创建一个新的副本，它只是将新名称链接到同一个原始对象。
- en: 'To create a new object from an existing one, the `copy` function needs to be
    used:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要从现有对象创建新对象，需要使用`copy`函数：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively an array can be filled with a single value in the following way:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用以下方式用一个单一值填充数组：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Arrays can also be created randomly using the `random` submodule. For example,
    giving the length of an array as an input of the function, `permutation` will
    find a random sequence of integers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以使用`random`子模块随机创建。例如，将数组的长度作为函数的输入，`permutation`将找到一系列随机整数：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another method, `normal` , will draw a sequence of numbers from a normal distribution:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，`normal`，将从正态分布中抽取一系列数字：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`0` is the mean of the distribution while `1` is the standard deviation and
    `5` is the number of array''s elements to draw. To use a uniform distribution,
    the random function will return numbers between `0` and `1` (not included):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`是分布的均值，`1`是标准差，`5`是要抽取的数组元素的数量。要使用均匀分布，随机函数将返回介于`0`和`1`之间的数字（不包括`1`）：'
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'NumPy also provides a number of functions for creating two-dimensional arrays
    (matrices). For instance, to create an identity matrix of a given dimension, the
    following code can be used:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了一系列用于创建二维数组（矩阵）的函数。例如，要创建给定维度的单位矩阵，可以使用以下代码：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `eye` function returns matrices with ones along the kth diagonal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`eye`函数返回沿第k对角线为1的矩阵：'
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The most commonly used functions to create new arrays (1 or 2 dimensional)
    are `zeros` and `ones` which create new arrays of specified dimensions filled
    with these values. These are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新数组（1维或2维）最常用的函数是`zeros`和`ones`，它们创建具有指定维度的数组，并用这些值填充。这些函数是：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `zeros_like` and `ones_like` functions instead create a new array with
    the same type as an existing one, with the same dimensions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`zeros_like`和`ones_like`函数则创建一个与现有数组类型相同的新数组，具有相同的维度：'
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another way to create two-dimensional arrays is to merge one-dimensional arrays
    using `vstack` (vertical merge):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建二维数组的方法是将一维数组使用`vstack`（垂直合并）合并：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The creation using distributions are also possible for two-dimensional arrays,
    using the `random` submodule. For example, a random matrix 2x3 from a uniform
    distribution between `0` and `1` is created by the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布创建二维数组也是可能的，使用 `random` 子模块。例如，通过以下命令创建一个从 `0` 到 `1` 的均匀分布的 2x3 随机矩阵：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another often used distribution is the multivariate normal distribution:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用分布是多元正态分布：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The list `[10,0]` is the mean vector, `[[3, 1], [1, 4]]` is the covariance matrix
    and `5` is the number of samples to draw.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 `[10,0]` 是均值向量，`[[3, 1], [1, 4]]` 是协方差矩阵，`5` 是要抽取的样本数量。
- en: '| Method | Description |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `tolist` | Function to transform NumPy array to list |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `tolist` | 用于将 NumPy 数组转换为列表的函数 |'
- en: '| `copy` | Function to copy NumPy array values |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `copy` | 用于复制 NumPy 数组值的函数 |'
- en: '| `ones` , `zeros` | Functions to create an array of zeros or ones |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `ones` , `zeros` | 用于创建全零或全一数组的函数 |'
- en: '| `zeros_like` , `ones_like` | Functions to create two-dimensional arrays with
    same shape of the input list |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `zeros_like` , `ones_like` | 用于创建与输入列表形状相同的二维数组的函数 |'
- en: '| `fill` | Function to replace an array entries with a certain value |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `fill` | 用于用特定值替换数组条目的函数 |'
- en: '| `identity` | Function to create identity matrix |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `identity` | 用于创建单位矩阵的函数 |'
- en: '| `eye` | Function to create a matrix with one entry along a kth diagonal |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `eye` | 用于创建具有第 k 个对角线上的一个条目的矩阵的函数 |'
- en: '| `vstack` | Function to merge arrays into two-dimensional arrays |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `vstack` | 用于将数组合并到二维数组的函数 |'
- en: '| random submodule: `random` , `permutation` , `normal` , `rand` , `multivariate_normal`
    , and others | Random submodule create arrays drawing samples from distributions
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| random 子模块：`random` , `permutation` , `normal` , `rand` , `multivariate_normal`
    ，以及其他 | Random 子模块创建从分布中抽取样本的数组 |'
- en: Array manipulations
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组操作
- en: 'All the usual operations to access, slice, and manipulate a Python list can
    be applied in the same way, or in a similar way to an array:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于访问、切片和操作 Python 列表的常规操作都可以以相同的方式或类似的方式应用于数组：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The unique value can be also selected using `unique` :'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unique` 也可以选择唯一值：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The values of the array can also be sorted using `sort` and its indices with
    `argsort` :'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的值也可以使用 `sort` 进行排序，其索引使用 `argsort`：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is also possible to randomly rearrange the order of the array''s elements
    using the `shuffle` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `shuffle` 函数也可以随机重新排列数组元素的顺序：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'NumPy also has a built-in function to compare arrays `array_equal` :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还有一个内置函数用于比较数组 `array_equal`：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Multi-dimensional arrays, however, differ from the list. In fact, a list of
    dimensions is specified using the comma (instead of a bracket for list). For example,
    the elements of a two-dimensional array (that is a matrix) are accessed in the
    following way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组与列表不同。实际上，使用逗号（而不是列表的括号）指定维度列表。例如，二维数组（即矩阵）的元素可以通过以下方式访问：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Slicing is applied on each dimension using the colon `:` symbol between the
    initial value and the end value of the slice:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用冒号 `:` 符号在切片的初始值和结束值之间进行每个维度的切片操作：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'While a single `:` means all the elements along that axis are considered:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个 `:` 表示该轴上的所有元素都被考虑时：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'One-dimensional arrays can be obtained from multi-dimensional arrays using
    the `flatten` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flatten` 函数可以从多维数组中获得一维数组：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is also possible to inspect an array object to obtain information about
    its content. The size of an array is found using the attribute shape:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以检查数组对象以获取有关其内容的信息。使用属性 `shape` 可以找到数组的大小：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, `arr` is a matrix of two rows and three columns. The `dtype`
    property returns the type of values are stored within the array:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`arr` 是一个两行三列的矩阵。`dtype` 属性返回数组中存储的值的类型：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`float64` is a numeric type to store double-precision (8-byte) real numbers
    (similar to `float` type in regular Python). There are also other data types such
    as `int64` , `int32` , `string,` and an array can be converted from one type to
    another. For example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`float64` 是一种用于存储双精度（8字节）实数的数值类型（类似于常规 Python 中的 `float` 类型）。还有其他数据类型，如 `int64`
    , `int32` , `string`，并且数组可以从一种类型转换为另一种类型。例如：'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `len` function returns the length of the first dimension when used on an
    array:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数组上使用 `len` 函数时，它返回第一维的长度：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Like in Python for loop, the `in` word can be used to check if a value is contained
    in an array:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 中的 for 循环类似，可以使用 `in` 关键字检查值是否包含在数组中：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An array can be manipulated in such a way that its elements are rearranged
    in different dimensions using the function `reshape` . For example, a matrix with
    eight rows and one column can be reshaped to a matrix with four rows and two columns:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用函数 `reshape` 以这种方式操作数组，使其元素在不同维度上重新排列。例如，一个有八行一列的矩阵可以被重塑为一个有四行两列的矩阵：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In addition, transposed matrices can be created; that is to say, a new array
    with the final two dimensions switched can be obtained using the transpose function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以创建转置矩阵；也就是说，可以使用转置函数获得一个新数组，其最后两个维度被交换：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Arrays can also be transposed using the `T` attribute:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以使用 `T` 属性进行转置：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Another way to reshuffle the elements of an array is to use the `newaxis` function
    to increase the dimensionality:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种重新排列数组元素的方法是使用 `newaxis` 函数增加维度性：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, in each case the new array has two dimensions, the one generated
    by `newaxis` has a length of one.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在每种情况下，新数组都有两个维度，由 `newaxis` 生成的一个维度长度为1。
- en: 'Joining arrays is an operation performed by the `concatenate` function in NumPy,
    and the syntax depends on the dimensionality of the array. Multiple one-dimensional
    arrays can be chained, specifying the arrays to be joined as a tuple:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中，通过 `concatenate` 函数执行数组连接操作，其语法取决于数组的维度。可以链式连接多个一维数组，指定要连接的数组为一个元组：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using a multi-dimensional array, the axis along which multiple arrays are concatenated
    needs to be specified. Otherwise, NumPy concatenates along the first dimension
    by default:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多维数组时，需要指定沿哪个轴连接多个数组。否则，NumPy 默认沿第一个维度进行连接：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is common to save a large amount of data as a binary file instead of using
    the direct format. NumPy provides a function, `tostring` , to convert an array
    to a binary string. Of course there''s also the inverse operation, where a conversion
    of a binary string to an array is supported using the `fromstring` routine. For
    example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会将大量数据保存为二进制文件而不是直接格式。NumPy 提供了一个函数 `tostring`，用于将数组转换为二进制字符串。当然，也支持逆操作，即使用
    `fromstring` 例程将二进制字符串转换为数组。例如：
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| Method | Description |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `unique` | Function to select only unique values from an array |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `unique` | 从数组中选择唯一值的功能 |'
- en: '| `random` , `shuffle` | Function to randomly rearrange the elements of an
    array |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `random` , `shuffle` | 用于随机重新排列数组元素的函数 |'
- en: '| `sort` , `argsort` | `sort` sorts the order of an array''s values in increasing
    order, while `argsort` orders the array''s indices such that the array gets arranged
    in an increasing order |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `sort` , `argsort` | `sort` 按照递增顺序对数组值进行排序，而 `argsort` 对数组索引进行排序，使得数组按递增顺序排列
    |'
- en: '| `array_equal` | Compare two arrays and return a True id (they are equal False
    otherwise) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `array_equal` | 比较两个数组并返回一个布尔值（如果它们相等则为True，否则为False） |'
- en: '| `flatten` | Transform a two-dimensional array into a one-dimensional array
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `flatten` | 将二维数组转换为单维数组 |'
- en: '| `transpose` | Calculate the transpose of a two-dimensional array |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `transpose` | 计算二维数组的转置 |'
- en: '| `reshape` | Rearrange entries of a two-dimensional array into a different
    shape |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `reshape` | 将二维数组的条目重新排列成不同的形状 |'
- en: '| `concatenate` | Concatenate two -dimensional arrays into one matrix |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `concatenate` | 将二维数组连接成一个矩阵 |'
- en: '| `fromstring` , `tostring` | Convert an array to a binary string |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `fromstring` , `tostring` | 将数组转换为二进制字符串 |'
- en: Array operations
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组操作
- en: 'Common mathematical operations are obviously supported in NumPy. For example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 显然支持常见的数学运算。例如：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Since any operation is applied element wise, the arrays are required to have
    the same size. If this condition is not satisfied, an error is returned:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何操作都是逐元素应用的，因此数组必须具有相同的大小。如果不满足此条件，将返回错误：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The error states that the objects cannot be `broadcasted` because the only
    way to perform an operation with arrays of different size is called broadcasting.
    This means the arrays have a different number of dimensions, and the array with
    less dimensions will be repeated until it matches the dimensions of the other
    array. Consider the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 错误表明对象不能进行 `广播`，因为使用不同大小的数组执行操作的唯一方法称为广播。这意味着数组具有不同数量的维度，维度较少的数组将被重复，直到它与另一个数组的维度相匹配。考虑以下情况：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The array `arr2` was *broadcasted* to a two-dimensional array that matched
    the size of `arr1` . Therefore, `arr2` was repeated for each dimension of `arr1`
    , equivalent to the array:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `arr2` 被广播为一个与 `arr1` 大小匹配的二维数组。因此，`arr2` 在 `arr1` 的每个维度上重复，相当于以下数组：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we want to make the way an array is broadcasted explicit, the `newaxis`
    constant allows us to specify how we want to broadcast:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使数组广播的方式更明确，`newaxis` 常量允许我们指定我们想要如何广播：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Unlike Python lists, arrays can be queried using conditions. A typical example
    is to use Boolean arrays to filter the elements:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 列表不同，数组可以使用条件进行查询。一个典型的例子是使用布尔数组来过滤元素：
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Multiple Boolean expressions can be used to subset the array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多个布尔表达式来对数组进行子集化：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Arrays of integers can be used to specify the indices to select the elements
    of another array. For example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用整数数组来指定索引，以选择另一个数组的元素。例如：
- en: '[PRE52]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `arr2` represents the ordered indices to select elements from array `arr1`
    : the zeroth, first, first, third, first, first, and first elements of `arr1`
    , in that order have been selected. Also lists can be used for the same purpose:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr2` 表示从数组 `arr1` 中选择元素的有序索引：`arr1` 的零、第一、第一、第三、第一、第一和第一个元素按此顺序被选中。同样，列表也可以用于相同的目的：'
- en: '[PRE53]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In order to replicate the same operation with multi-dimensional arrays, multiple
    one-dimensional integer arrays have to be put into the selection bracket, one
    for each dimension.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用多维数组复制相同的操作，必须将多个一维整数数组放入选择括号中，每个维度一个。
- en: 'The first selection array represents the values of the first index in the matrix
    entries, while the values on the second selection array represent the column index
    of the matrix entries. The following example illustrates the idea:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选择数组表示矩阵条目中的第一个索引的值，而第二个选择数组上的值表示矩阵条目的列索引。以下示例说明了这个概念：
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The values on `arr2` are the first index (row) on `arr1` entries while `arr3`
    are the second index (column) values, so the first chosen entry on `arr1` corresponds
    to row 1 column 1 which is `13` .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr2` 中的值是 `arr1` 中条目的第一个索引（行），而 `arr3` 是第二个索引（列）的值，因此 `arr1` 中第一个选择的条目对应于第
    1 行第 1 列，即 `13`。'
- en: 'The function `take` can be used to apply your selection with integer arrays,
    and it works in the same way as bracket selection:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `take` 可以用于对整数数组应用选择，并且它的工作方式与方括号选择相同：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Subsets of a multi-dimensional array can be selected along a given dimension
    specifying the axis argument on the `take` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `take` 函数上指定轴参数来沿给定维度选择多维数组的子集：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `put` function is the opposite of the `take` function, and it takes values
    from an array and puts them at specified indices in the array that calls the `put`
    method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`put` 函数是 `take` 函数的反面，它从数组中获取值并将它们放在调用 `put` 方法的数组中指定的索引处：'
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We finish this section with the note that multiplication also remains element-wise
    for two-dimensional arrays (and does not correspond to matrix multiplication):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以注意，乘法对于二维数组来说仍然是逐元素进行的（并不对应矩阵乘法）：
- en: '[PRE58]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '| Method | Description |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `take` | Select values of an array from indices given by a second array |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `take` | 从由第二个数组给出的索引中选择数组的值 |'
- en: '| `put` | Replace the values in an array with values of another array at given
    positions |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `put` | 用另一个数组在给定位置上的值替换数组中的值 |'
- en: Linear algebra operations
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性代数运算
- en: 'The most common operations between matrices is the inner product of a matrix
    with its transpose, *X^T X* , using `np.dot` :'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵与它的转置的内积是最常见的矩阵操作，即 *X^T X* 使用 `np.dot` 计算：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There are functions to directly calculate the different types of product (`inner`
    , `outer` , and `cross` ) on arrays (that is matrices or vectors).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 存在函数可以直接计算数组上的不同类型的产品（`inner`、`outer` 和 `cross`）。
- en: 'For one-dimensional arrays (vectors) the inner product corresponds to the dot
    product:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一维数组（向量）来说，内积对应于点积：
- en: '[PRE60]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'NumPy also contains a sub-module, `linalg` that has a series of functions to
    perform linear algebra calculations over matrices. The determinant of a matrix
    can be computed as:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还包含一个子模块 `linalg`，它有一系列函数用于在矩阵上执行线性代数计算。矩阵的行列式可以计算如下：
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also the inverse of a matrix can be generated using the function `inv` :'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以使用函数 `inv` 生成矩阵的逆：
- en: '[PRE62]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It is straightforward to calculate the eigenvalues and eigenvectors of a matrix:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 计算矩阵的特征值和特征向量很简单：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '| Method | Description |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dot` | Dot product between two arrays |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `dot` | 两个数组之间的点积 |'
- en: '| `inner` | Inner product between multi-dimensional arrays |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `inner` | 多维数组之间的内积 |'
- en: '| `linalg` module with functions such as: `linalg.det` , `linalg.inv` , `linalg.eig`
    | `linalg` is a module that collects several linear algebra methods among which
    are the determinant of a matrix (`det` ), the inverse of a matrix (`inv` ) and
    the eigenvalues, eigenvectors of a matrix (`eig` ) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `linalg`模块包含如`linalg.det`、`linalg.inv`、`linalg.eig`等函数 | `linalg`是一个收集了多种线性代数方法的模块，其中包括矩阵的行列式（`det`）、矩阵的逆（`inv`）以及矩阵的特征值和特征向量（`eig`）
    |'
- en: Statistics and mathematical functions
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统计和数学函数
- en: 'NumPy provides a set of functions to compute statistics of the data contained
    in the arrays. Operations of the aggregation type, such as sum, mean, median,
    and standard deviation are available as an attribute of an array. For example,
    creating a random array (from a normal distribution), it is possible to calculate
    the mean in two ways:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了一套用于计算数组中数据统计函数的函数。聚合操作，如求和、平均值、中位数和标准差，作为数组的属性可用。例如，创建一个随机数组（来自正态分布），可以通过两种方式计算平均值：
- en: '[PRE64]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The full list of functions is shown in the table below:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了函数的完整列表：
- en: '| Method | Description |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mean` | mean of the elements. If the array is empty, the mean is set to
    `Na` `N` by default. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 元素的平均值。如果数组为空，则默认将平均值设置为`Na` `N`。 |'
- en: '| `std` , `var` | Functions to calculate the standard deviation (`std` ) and
    variance (`var` ) of the array. An optional degree of freedom parameter can be
    specified (default is the length of the array). |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `std` , `var` | 计算数组的标准差（`std`）和方差（`var`）的函数。可以指定一个可选的自由度参数（默认为数组的长度）。 |'
- en: '| `min` , `max` | Functions to determine the minimum (`min` ) and maximum (`max`
    ) value contained in the array. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `min` , `max` | 确定数组中包含的最小值（`min`）和最大值（`max`）的函数。 |'
- en: '| `argmin` , `argmax` | These functions return the index of the smallest element
    (`argmin` ) and largest element (`argmax` ). |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `argmin` , `argmax` | 这些函数返回最小元素（`argmin`）和最大元素（`argmax`）的索引。 |'
- en: Understanding the pandas module
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解pandas模块
- en: pandas is a powerful Python module that contains a wide range of functions to
    analyze data structures. pandas relies on the NumPy library and it is designed
    to make data analysis operations easy and fast. This module offers high performance
    with respect to normal Python functions, especially for reading or writing files
    or making databases; pandas is the optimal choice to perform data manipulation.
    The following paragraphs discuss the main methods to explore the information contained
    in the data, and how to perform manipulations on it. We start by describing how
    data is stored in pandas and how to load data into it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: pandas是一个强大的Python模块，包含了一系列用于分析数据结构的功能。pandas依赖于NumPy库，并且旨在使数据分析操作变得简单快捷。该模块在性能方面优于常规Python函数，尤其是在读取或写入文件或创建数据库时；pandas是执行数据操作的最佳选择。以下段落讨论了探索数据中包含的信息的主要方法以及如何对其进行操作。我们首先描述数据在pandas中的存储方式以及如何将其加载到其中。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Throughout the rest of the book, we use the following import conventions for
    `pandas` :'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们对`pandas`使用以下导入约定：
- en: '[PRE65]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Therefore, whenever code contains the letters `pd` , it is referring to `pandas`
    .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当代码中包含字母`pd`时，它指的是`pandas`。
- en: Exploring data
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索数据
- en: 'In order to introduce the database structure, called **DataFrame** , into pandas,
    we need to describe the one-dimensional array-like object containing data of any
    NumPy data type and an associated array of data label called its index. This structure
    is called `Series` and a simple example is:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将称为**DataFrame**的数据库结构引入pandas，我们需要描述包含任何NumPy数据类型的数据以及与其关联的数据标签数组，即其索引的一维数组-like对象。这种结构称为`Series`，一个简单的例子是：
- en: '![Exploring data](img/Image00001.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00001.jpg)'
- en: 'The `obj` object is composed of two values, the index on the left and the associated
    value on the right. Given that the length of the data is equal to *N,* the default
    indexing goes from `0` to *N-1* . The array and index objects of the `Series`
    can be obtained using its values and index attributes, respectively:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`对象由两个值组成，左边的索引和右边的关联值。鉴于数据的长度等于*N*，默认索引从`0`到*N-1*。`Series`的数组和索引对象可以通过其值和索引属性分别获得：'
- en: '![Exploring data](img/Image00002.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00002.jpg)'
- en: 'The indexing is preserved by applying NumPy array operations (such as scalar
    multiplication, filtering with a Boolean array, or applying math functions):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用NumPy数组操作（如标量乘法、布尔数组过滤或应用数学函数）来保留索引：
- en: '![Exploring data](img/Image00003.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00003.jpg)'
- en: 'A Python dictionary can be transformed into a `Series` but the indexing will
    correspond to the key values:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python字典可以被转换成一个`Series`，但索引将对应于键值：
- en: '![Exploring data](img/Image00004.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00004.jpg)'
- en: 'It is possible to specify a separated list as an index:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定一个分开的列表作为索引：
- en: '![Exploring data](img/Image00005.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00005.jpg)'
- en: In this case, the last index value, `g` , has not got an associated object value,
    so by default a **Not a Number** ( **NaN** ) is inserted.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最后一个索引值`g`没有关联的对象值，因此默认插入一个**非数字**（**NaN**）。
- en: 'The terms of *missing* or *NA* will be used to refer to missing data. To find
    the missing data the `isnull` and `notnull` functions can be used in pandas:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*缺失*或*NA*将用于指代缺失数据。要找到缺失数据，可以在pandas中使用`isnull`和`notnull`函数：
- en: '![Exploring data](img/Image00006.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00006.jpg)'
- en: We can now start loading a CSV file into a DataFrame structure. A DataFrame
    represents a data structure containing an ordered set of columns, each of which
    can be a different value type (numeric, string, Boolean, and others). The DataFrame
    has two indices (a row and column index) and it can be thought of as a dictionary
    of `Series` that share the same index (column). For the purpose of this tutorial,
    we are using the data contained in the `ad.data` file stored in the [http://archive.ics.uci.edu](http://archive.ics.uci.edu)
    website (at [http://archive.ics.uci.edu/ml/datasets/Internet+Advertisements](http://archive.ics.uci.edu/ml/datasets/Internet+Advertisements)
    ) as already explained in the preceding machine-learning example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始将CSV文件加载到DataFrame结构中。DataFrame表示一个包含有序列的数据结构，每一列可以有不同的值类型（数值、字符串、布尔值和其他）。DataFrame有两个索引（行索引和列索引），它可以被视为一个共享相同索引（列）的`Series`字典。为了本教程的目的，我们正在使用存储在[http://archive.ics.uci.edu](http://archive.ics.uci.edu)网站上的`ad.data`文件中的数据（如前所述的机器学习示例中所述）。
- en: 'The data is loaded in the following way using the terminal (in this case the
    path is `data_example/ad-dataset/ad-data` ):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用终端（在这种情况下路径是`data_example/ad-dataset/ad-data`）以下方式加载数据：
- en: '![Exploring data](img/Image00007.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00007.jpg)'
- en: 'This file does not have a header (set to `none` ) so the column''s names are
    numbers and we can get a summary of the DataFrame by using the `describe` function
    on the object data:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件没有标题（设置为`none`），因此列名是数字，我们可以使用`describe`函数在数据对象上获取DataFrame的摘要：
- en: '![Exploring data](img/Image00008.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00008.jpg)'
- en: This summarizes quantitative information. We can see that there are `1554` numeric
    columns (indicated by numbers since there is no header) and `3279` rows (called
    `count` for each column). Each of the columns has a list of statistical parameters
    (mean, standard deviation, min, max, and percentiles) that helps to obtain an
    initial estimate of the quantitative information contained in the data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了定量信息。我们可以看到有`1554`个数值列（由于没有标题，用数字表示）和`3279`行（每列称为`count`）。每一列都有一个统计参数列表（平均值、标准差、最小值、最大值和分位数），这有助于获取数据中包含的定量信息的初始估计。
- en: 'It is possible to obtain the column names using the `columns` property:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`columns`属性来获取列名：
- en: '![Exploring data](img/Image00009.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00009.jpg)'
- en: 'So all the columns names are of type `int64` and the following command returns
    the actual types of all the columns:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有列名都是`int64`类型，以下命令返回所有列的实际类型：
- en: '![Exploring data](img/Image00010.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00010.jpg)'
- en: 'The first four columns and the label (last column) are of the type `object,`
    while the others are of the type `int64` . Columns can be accessed in two ways.
    The first method is by specifying the column name like the key in a dictionary:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 前四列和标签（最后一列）是`object`类型，而其他列是`int64`类型。可以通过两种方式访问列。第一种方法是通过指定列名，就像字典中的键一样：
- en: '![Exploring data](img/Image00011.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00011.jpg)'
- en: 'Multiple columns can be obtained by specifying a list of them with the column
    names:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定列名列表来获得多列：
- en: '![Exploring data](img/Image00012.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00012.jpg)'
- en: The other way to access columns is by using the *dot* syntax, but it will only
    work if the column name could also be a Python variable name (that is no spaces),
    if it is not the same as the DataFrame property or function name (such as count
    or sum), and the name is of the string type (not `int64` like in this example).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种访问列的方法是使用*点*语法，但只有当列名也可以作为Python变量名（即没有空格），并且不与DataFrame属性或函数名（如count或sum）相同，并且名称是字符串类型（不是像在这个例子中的`int64`）时，它才会工作。
- en: 'To briefly gain an insight into the content of a DataFrame, the function `head()`
    can be used. The first five items in a column (or the first five rows in the DataFrame)
    are returned by default:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要简要了解DataFrame的内容，可以使用`head()`函数。默认情况下，返回列中的前五个项目（或DataFrame中的前五行）：
- en: '![Exploring data](img/Image00013.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00013.jpg)'
- en: 'The opposite method is `tail()` , which returns the last five items or rows
    by default. Specifying a number on the `tail()` or `head()` function, will return
    the first *n* items in the chosen column:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的方法是`tail()`，默认情况下返回最后五个项目或行。在`tail()`或`head()`函数上指定一个数字，将返回所选列中的前*n*个项目：
- en: '![Exploring data](img/Image00014.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00014.jpg)'
- en: 'It is also possible to use the Python''s regular slicing syntax to obtain a
    certain number of rows of the DataFrame:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用Python的常规切片语法来获取DataFrame的一定数量的行：
- en: '![Exploring data](img/Image00015.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![探索数据](img/Image00015.jpg)'
- en: This example shows only rows from `1` to `3` .
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只显示了从`1`到`3`的行。
- en: Manipulate data
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作数据
- en: 'It is possible to select row(s) in different ways, such as specifying the index
    or the condition as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以不同的方式选择行，例如指定索引或条件如下：
- en: '![Manipulate data](img/Image00016.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00016.jpg)'
- en: 'Or specifying multiple conditions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 或者指定多个条件：
- en: '![Manipulate data](img/Image00017.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00017.jpg)'
- en: The data returned are web pages with feature `1` greater than `0` and containing
    an advert.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据是具有特征`1`大于`0`且包含广告的网页。
- en: 'The `ix` method allows us to select rows specifying the desired index:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`ix`方法允许我们通过指定所需的索引来选择行：'
- en: '![Manipulate data](img/Image00018.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00018.jpg)'
- en: 'Alternatively the function `iloc` can be used:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用函数`iloc`：
- en: '![Manipulate data](img/Image00019.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00019.jpg)'
- en: 'The difference is that `ix` works on labels in the index column and `iloc`
    works on the positions in the index (so it only takes integers). Therefore, in
    this example, `ix` finds all the rows from `0` until the label `3` appears, while
    the `iloc` function returns the rows in the first `3` positions in the data frame.
    There is a third function to access data in a DataFrame, `loc` . This function
    looks at the index names associated with the rows and it returns their values.
    For example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于`ix`在索引列的标签上工作，而`iloc`在索引的位置上工作（因此它只接受整数）。因此，在这个例子中，`ix`找到从`0`到出现标签`3`的所有行，而`iloc`函数返回数据框中前`3`个位置的行。还有一个第三个函数可以访问DataFrame中的数据，即`loc`。这个函数查看与行关联的索引名称，并返回它们的值。例如：
- en: '![Manipulate data](img/Image00020.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00020.jpg)'
- en: Note that this function behaves differently with respect to the normal slicing
    in Python because both starting and ending rows are included in the result (the
    row with index `3` is included in the output).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数与Python中的正常切片行为不同，因为起始行和结束行都包含在结果中（索引为`3`的行包含在输出中）。
- en: 'It is possible to set an entire column to a value:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将整个列设置为某个值：
- en: '![Manipulate data](img/Image00021.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00021.jpg)'
- en: 'To also set a specific cell value to the desired values:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要也将特定单元格的值设置为所需的值：
- en: '![Manipulate data](img/Image00022.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00022.jpg)'
- en: 'Or the entire row to a set of values (random values between `0` and `1` and
    `ad.` label in this example):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 或者将整行设置为一系列值（在这个例子中是介于`0`和`1`之间的随机值和`ad.`标签）：
- en: '![Manipulate data](img/Image00023.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00023.jpg)'
- en: 'After transforming an array of values in a `Series` object, it is possible
    to append a row at the end of the DataFrame:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`Series`对象中的值数组转换后，可以在DataFrame的末尾添加一行：
- en: '![Manipulate data](img/Image00024.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00024.jpg)'
- en: 'Alternatively, the `loc` function (as in NumPy) can be used to add a row at
    the last line:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用`loc`函数（如NumPy中所示）在最后一行添加一行：
- en: '![Manipulate data](img/Image00025.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00025.jpg)'
- en: 'It is easy to add a column in the DataFrame by simply assigning the new column
    name to a value:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地将新列名赋给值，很容易在DataFrame中添加一列：
- en: '![Manipulate data](img/Image00026.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00026.jpg)'
- en: 'In this case, the new column has all the entries assigned to *test value* .
    Similarly, the column can be deleted using the `drop` function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，新列包含了分配给*测试值*的所有条目。同样，可以使用`drop`函数删除该列：
- en: '![Manipulate data](img/Image00027.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00027.jpg)'
- en: 'A dataset may contain duplicates for various reasons, so pandas provides the
    method `duplicated` to indicate whether each row is a repetition or not:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可能由于各种原因包含重复项，因此pandas提供了`duplicated`方法来指示每一行是否是重复的：
- en: '![Manipulate data](img/Image00028.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00028.jpg)'
- en: 'More usefully, though, the `drop_duplicates` function returns a DataFrame with
    only the unique values. For example, for the label the unique values are:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 更有用的是，`drop_duplicates`函数返回一个只包含唯一值的DataFrame。例如，对于标签，唯一值如下：
- en: '![Manipulate data](img/Image00029.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00029.jpg)'
- en: 'It is possible to transform the result into a list:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以转换成一个列表：
- en: '![Manipulate data](img/Image00030.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00030.jpg)'
- en: 'As we did in the machine-learning example, these labels can be transformed
    into numeric values using the methods explained in the preceding example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在机器学习示例中所做的那样，这些标签可以使用前面示例中解释的方法转换为数值：
- en: '![Manipulate data](img/Image00031.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00031.jpg)'
- en: 'The label column is still the `object` type:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 标签列仍然是`object`类型：
- en: '![Manipulate data](img/Image00032.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00032.jpg)'
- en: 'So the column now can be converted into the float type:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在可以将该列转换为浮点类型：
- en: '![Manipulate data](img/Image00033.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00033.jpg)'
- en: 'The first four columns contain mixed values (strings, `?` , and float numbers),
    so we need to remove the string values to convert the columns into a numeric type.
    We can use the function `replace` to substitute all the instances of `?` (missing
    values) with `NaN` :'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前四列包含混合值（字符串、`?`和浮点数），因此我们需要删除字符串值以将列转换为数值类型。我们可以使用`replace`函数将所有`?`（缺失值）实例替换为`NaN`：
- en: '![Manipulate data](img/Image00034.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00034.jpg)'
- en: 'Now we can handle these rows with missing data in two ways. The first method
    is just to remove the lines with missing values using `dropna` :'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用两种方式处理这些包含缺失数据的行。第一种方法就是使用`dropna`删除包含缺失值的行：
- en: '![Manipulate data](img/Image00035.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00035.jpg)'
- en: 'Instead of removing the rows with missing data (which may lead to deleting
    important information), the empty entries can be filled. For most purposes, a
    constant value can be inserted in the empty cells with the `fillna` method:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是删除包含缺失数据的行（这可能会导致删除重要信息），可以使用`fillna`方法填充空条目。对于大多数目的，可以在空单元格中插入一个常数值：
- en: '![Manipulate data](img/Image00036.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00036.jpg)'
- en: 'Now that all the values are numeric the columns can be set to type `float,`
    applying the `astype` function. Alternatively, we can apply a `lambda` function
    to convert each column in the DataFrame to a numeric type:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有值都是数值型，可以将列设置为`float`类型，应用`astype`函数。或者，我们可以应用一个`lambda`函数将DataFrame中的每一列转换为数值类型：
- en: '![Manipulate data](img/Image00037.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00037.jpg)'
- en: Each *x* instance is a column and the `to_numeric` function converts it to the
    closest numeric type (`float` in this case).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 每个*x*实例是一个列，`to_numeric`函数将其转换为最接近的数值类型（在这种情况下是`float`）：
- en: 'For the sake of completeness of this tutorial, we want to show how two DataFrames
    can be concatenated since this operation can be useful in real applications. Let''s
    create another small DataFrame with random values:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个教程更加完整，我们想展示如何将两个DataFrame连接起来，因为这种操作在实际应用中可能很有用。让我们创建另一个包含随机值的DataFrame：
- en: '![Manipulate data](img/Image00038.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00038.jpg)'
- en: 'This new table with two rows can be merged with the original DataFrame using
    the `concat` function placing the rows of `data1` at the bottom of the `data`
    :'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`concat`函数可以将这个包含两行的新表与原始DataFrame合并，将`data1`的行放置在`data`的底部：
- en: '![Manipulate data](img/Image00039.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据](img/Image00039.jpg)'
- en: The number of rows of `datatot` is now increased by two rows with respect to
    `data` (note that the number of rows is different from the beginning because we
    dropped the rows with `NaN` ).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 与`data`相比，`datatot`的行数现在增加了两行（注意，行数与开始时不同，因为我们删除了包含`NaN`的行）。
- en: Matplotlib tutorial
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Matplotlib教程
- en: '`matplotlib.pyplot` is a library that collects a series of methods to plot
    data similar to **MATLAB** . Since the following chapters will employ this library
    to visualize some results, a simple example here will explain all the `matplotlib`
    code you will see as you continue in this book:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib.pyplot` 是一个收集了一系列用于绘制数据的函数的库，类似于 **MATLAB**。由于以下章节将使用这个库来可视化一些结果，这里的一个简单示例将解释你将在本书中看到的所有的
    `matplotlib` 代码：'
- en: '![Matplotlib tutorial](img/Image00040.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![Matplotlib 教程](img/Image00040.jpg)'
- en: 'After importing the library (as `plt` ), the `figure` object is initialized
    (`fig` ) and an `axis` object is added (`ax` ). Each line plotted into the `ax`
    object through the command `ax.plot()` is called a handle. All the following instructions
    are then recorded by `matplotlib.pyplot` and plotted in the `figure` object. In
    this case, the line in green has been shown from the terminal and saved as a `figure.png`
    file, using the commands `plt.show()` and `fig.savefig()` respectively. The result
    is equal to:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 导入库（作为 `plt`）后，初始化 `figure` 对象（`fig`）并添加一个 `axis` 对象（`ax`）。通过命令 `ax.plot()`
    绘制到 `ax` 对象中的每条线都称为句柄。然后，所有后续指令都由 `matplotlib.pyplot` 记录并在 `figure` 对象中绘制。在这种情况下，绿色线条已从终端显示并保存为
    `figure.png` 文件，分别使用 `plt.show()` 和 `fig.savefig()` 命令。结果是：
- en: '![Matplotlib tutorial](img/Image00041.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![Matplotlib 教程](img/Image00041.jpg)'
- en: Example of simple plot
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 简单绘图示例
- en: 'The next example illustrates a plot of several lines with different format
    styles in one command using Numpy arrays:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了使用 Numpy 数组在一个命令中绘制具有不同格式样式的几条线的绘图：
- en: '![Matplotlib tutorial](img/Image00042.jpg)![Matplotlib tutorial](img/Image00043.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![Matplotlib 教程](img/Image00042.jpg)![Matplotlib 教程](img/Image00043.jpg)'
- en: Example of plot with multiple lines
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 多条线绘图示例
- en: Note that the function `get_legend_handles_labels()` returns the list of handles
    and labels stored in the object `ax` and they are passed to the function legend
    to be plotted. The symbols `'r--'` , `'bs'` , and `'g^'` refer to the shape of
    the points and their color (red rectangles, blue squares, and green triangles
    respectively). The `linewidth` parameter sets the thickness of the line while
    `markersize` sets the size of the dots.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数 `get_legend_handles_labels()` 返回存储在对象 `ax` 中的句柄和标签列表，并将它们传递给绘图函数 `legend`。符号
    `'r--'`、`'bs'` 和 `'g^'` 分别指代点的形状及其颜色（红色矩形、蓝色正方形和绿色三角形）。`linewidth` 参数设置线的粗细，而
    `markersize` 设置点的尺寸。
- en: 'Another useful plot to visualize the results is the scatter plot in which values
    for typically two variables of a set of data (data generated using NumPy `random`
    submodule) are displayed:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的可视化结果的方法是散点图，其中显示了一组数据（使用 NumPy `random` 子模块生成）中通常两个变量的值：
- en: '![Matplotlib tutorial](img/Image00044.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![Matplotlib 教程](img/Image00044.jpg)'
- en: 'The `s` option represents the size of the points and `colors` are the colors
    that correspond to each set of points and the handles are passed directly into
    the legend function (`p1` , `p2` , `p3` ):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`s` 选项表示点的尺寸，`colors` 是对应于每组点的颜色，句柄直接传递到图例函数（`p1`、`p2`、`p3`）：'
- en: '![Matplotlib tutorial](img/Image00045.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![Matplotlib 教程](img/Image00045.jpg)'
- en: Scatter plot of randomly distributed points
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 随机分布点的散点图
- en: For further details on how to use `matplotlib` we advise the reader to read
    online material and tutorials such as [http://matplotlib.org/users/pyplot_tutorial.html](http://matplotlib.org/users/pyplot_tutorial.html)
    .
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用 `matplotlib` 的更多细节，我们建议读者阅读在线材料和学习教程，例如 [http://matplotlib.org/users/pyplot_tutorial.html](http://matplotlib.org/users/pyplot_tutorial.html)。
- en: Scientific libraries used in the book
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书中使用的科学库
- en: 'Throughout this book, certain libraries are necessary to implement the machine-learning
    techniques discussed in each chapter. We are going to briefly describe the most
    relevant libraries employed hereafter:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，为了实现每一章讨论的机器学习技术，某些库是必要的。我们将简要描述以下将使用的最相关的库：
- en: '**SciPy** is a collection of mathematical methods based on the NumPy array
    objects. It is an open source project so it takes advantage of additional methods
    continuously written from developers around the world. Python software that employs
    a SciPy routine is part of advanced projects or applications comparable to similar
    frameworks such as MATLAB, **Octave** or **RLab** . There are a wide range of
    methods available from manipulating and visualizing data functions to parallel
    computing routines that enhance the versatility and potentiality of the Python
    language.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SciPy** 是基于 NumPy 数组对象的一系列数学方法。它是一个开源项目，因此它利用了来自世界各地开发者的持续编写的方法。使用 SciPy
    例程的 Python 软件是高级项目或应用的一部分，与 MATLAB、**Octave** 或 **RLab** 等类似框架相当。它提供了从操作和可视化数据函数到并行计算例程的广泛方法，这些例程增强了
    Python 语言的灵活性和潜力。'
- en: '**scikit-learn** ( **sklearn** ) is an open source machine learning module
    for Python programming language. It implements various algorithms such as clustering,
    classification, and regression including support vector machines, **Naive Bayes**
    , **Decision Trees** , **Random Forests** , **k-means** , and **Density Based
    Spatial Clustering of Applications with Noise** ( **DBSCAN** ) and it interacts
    natively with numerical Python libraries such as NumPy and SciPy. Although most
    of the routines are written in Python, some functions are implemented in **Cython**
    to achieve better performance. For instance, support vector machines and logistic
    regression are written in Cython wrapping other external libraries ( **LIBSVM**
    , **LIBLINEAR** ).'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scikit-learn**（**sklearn**）是 Python 编程语言的开放源代码机器学习模块。它实现了包括支持向量机、**朴素贝叶斯**、**决策树**、**随机森林**、**k-means**
    和 **基于密度的空间聚类应用噪声**（**DBSCAN**）在内的聚类、分类和回归等算法，并且与数值 Python 库（如 NumPy 和 SciPy）进行原生交互。尽管大多数例程是用
    Python 编写的，但一些函数是用 **Cython** 实现的，以实现更好的性能。例如，支持向量机和逻辑回归是用 Cython 包装其他外部库（**LIBSVM**、**LIBLINEAR**）编写的。'
- en: '**The Natural Language Toolkit** ( **NLTK** ), is a collection of libraries
    and functions for **Natural Language Processing** ( **NLP** ) for Python language
    processing. NLTK is designed to support research and teaching on NLP and related
    topics including artificial intelligence, cognitive science, information retrieval,
    linguistics, and machine learning. It also features a series of text processing
    routines for tokenization, stemming, tagging, parsing, semantic reasoning, and
    classification. NLTK includes sample codes and sample data and interfaces to more
    than 50 corpora and lexical databases.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自然语言工具包**（**NLTK**）是 Python 语言处理中用于自然语言处理（**NLP**）的一组库和函数。NLTK 设计用于支持 NLP
    和相关领域的研究和教学，包括人工智能、认知科学、信息检索、语言学和机器学习。它还提供了一系列文本处理例程，用于分词、词干提取、标记、解析、语义推理和分类。NLTK
    包括示例代码和示例数据，以及超过 50 个语料库和词汇数据库的接口。'
- en: '**Scrapy** is an open source web crawling framework for the Python programming
    language. Originally designed for scraping websites, and as a general purpose
    crawler, it is also suitable for extracting data through APIs. The Scrapy project
    is written around *spiders* that act by providing a set of instructions. It also
    features a web crawling shell that allows the developers to test their concepts
    before actually implementing them. Scrapy is currently maintained by Scrapinghub
    Ltd., a web scraping development and services Company.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scrapy** 是一种用于 Python 编程语言的开放源代码网络爬虫框架。最初设计用于抓取网站，作为一个通用爬虫，它也适用于通过 API 提取数据。Scrapy
    项目围绕提供一组指令的 *蜘蛛* 进行编写。它还提供了一个网络爬虫外壳，允许开发者在实际实现之前测试他们的概念。Scrapy 目前由 Scrapinghub
    Ltd. 维护，这是一家网络爬取开发和服务的公司。'
- en: '**Django** is a free and open source web application framework implemented
    in Python following the *model view controller* architectural pattern. Django
    is designed for creation of complex, database-oriented websites. It also allows
    us to manage the application through an administrative interface, which can create,
    read, delete, or update data used in the application. There are a series of established
    websites that currently use Django, such as Pinterest, Instagram, Mozilla, The
    Washington Times, and Bitbucket.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Django** 是一个遵循 *模型-视图-控制器* 架构模式的免费和开源 Web 应用程序框架，用 Python 实现。Django 设计用于创建复杂、以数据库为中心的网站。它还允许我们通过管理界面来管理应用程序，可以创建、读取、删除或更新应用程序中使用的数据。目前有一系列已建立的网站正在使用
    Django，例如 Pinterest、Instagram、Mozilla、华盛顿时报和 Bitbucket。'
- en: When to use machine learning
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用机器学习
- en: 'Machine learning is not magic and it may be not be beneficial to all data-related
    problems. It is important at the end of this introduction to clarify when machine-learning
    techniques are extremely useful:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习并非魔法，它可能对所有与数据相关的问题都不一定有益。在本介绍的最后，重要的是要明确机器学习技术在何时极为有用：
- en: 'It is not possible to code the rules: a series of human tasks (to determine
    if an e-mail is spam or not, for example) cannot be solved effectively using simple
    rules methods. In fact, multiple factors can affect the solution and if rules
    depend on a large number of factors it becomes hard for humans to manually implement
    these rules.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则无法编码：一系列人类任务（例如，确定一封电子邮件是否为垃圾邮件）无法通过简单的规则方法有效解决。实际上，多个因素可能影响解决方案，如果规则依赖于大量因素，那么对人类来说手动实施这些规则变得很困难。
- en: 'A solution is not scalable: whenever it is time consuming to manually take
    decisions on certain data, the machine-learning techniques can scale adequately.
    For example, a machine-learning algorithm can efficiently go through millions
    of e-mails and determine if they are spam or not.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案不可扩展：每当手动对某些数据进行决策耗时较长时，机器学习技术可以适当地扩展。例如，机器学习算法可以有效地处理数百万封电子邮件并确定它们是否为垃圾邮件。
- en: However, if it is possible to find a good target prediction, by simply using
    mathematical rules, computations, or predetermined schemas that can be implemented
    without needing any data-driven learning, these advanced machine-learning techniques
    are not necessary (and you should not use them).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果可能找到良好的目标预测，仅通过使用数学规则、计算或无需数据驱动学习的预定方案，这些高级机器学习技术就不再必要（您也不应该使用它们）。
- en: 读累了记得休息一会哦~
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we introduced the basic machine-learning concepts and terminology
    that will be used in the rest of the book. Tutorials of the most relevant libraries
    (NumPy, pandas, and matplotlib) used by machine-learning professionals to prepare,
    t manipulate, and visualize data have been also presented. A general introduction
    of all the other Python libraries that will be used in the following chapters
    has been also provided.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了本书其余部分将使用的机器学习基本概念和术语。我们还介绍了机器学习专业人士用于准备、处理和可视化数据的最重要的库（NumPy、pandas和matplotlib）的教程。还提供了一般介绍所有将在以下章节中使用的其他Python库。
- en: You should have a general knowledge of what the machine-learning field can practically
    do, and you should now be familiar with the methods employed to transform the
    data into a usable format, so that a machine-learning algorithm can be applied.
    In the next chapter we will explain the main unsupervised learning algorithms
    and how to implement them using the `sklearn` library.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对机器学习领域实际上能做什么有一个一般性的了解，并且您现在应该熟悉将数据转换为可用格式的方法，以便应用机器学习算法。在下一章中，我们将解释主要的无监督学习算法以及如何使用`sklearn`库来实现它们。
