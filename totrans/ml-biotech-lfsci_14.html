<html><head></head><body>
		<div id="_idContainer374">
			<p><a id="_idTextAnchor153"/></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.1.1">Chapter 11: Deploying Models with Flask Applications</span></h1>
			<p><span class="koboSpan" id="kobo.2.1">Over the course of this book, we explored the development of numerous robust machine learning models in areas such as breast cancer detection, scientific topic modeling, protein classification, and molecular property prediction. </span><span class="koboSpan" id="kobo.2.2">In each of these tutorials, we prepared and validated our models to allow them to have the best predictive power possible. </span><span class="koboSpan" id="kobo.2.3">We will now pivot from the development of new models to the deployment of trained models to our end users.</span></p>
			<p><span class="koboSpan" id="kobo.3.1">Within this chapter, we will explore one of the most popular frameworks for the preparation of web applications: </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Flask</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">We will use Flask to prepare a web application to serve our models to end users, and we will also prepare an </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Application Programming Interface</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">API</span></strong><span class="koboSpan" id="kobo.9.1">) to serve our predictions to other web applications.</span></p>
			<p><span class="koboSpan" id="kobo.10.1">Over the course of this chapter, we will cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.11.1">Understanding API frameworks </span></li>
				<li><span class="koboSpan" id="kobo.12.1">Working with Flask and Visual Studio Code</span></li>
				<li><span class="koboSpan" id="kobo.13.1">Using Flask as an API and web application</span></li>
				<li><span class="koboSpan" id="kobo.14.1">Tutorial – Deploying a pretrained model using Flask</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.15.1">With these objectives in mind, let's go ahead and get started!</span></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.16.1">Understanding API frameworks </span></h1>
			<p><span class="koboSpan" id="kobo.17.1">Whether </span><a id="_idIndexMarker1125"/><span class="koboSpan" id="kobo.18.1">you are logging in to your email account, scrolling through social </span><a id="_idIndexMarker1126"/><span class="koboSpan" id="kobo.19.1">media, or even logging in to an online retailer, we use </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">web applications</span></strong><span class="koboSpan" id="kobo.21.1"> on a daily basis to accomplish a variety of tasks. </span><span class="koboSpan" id="kobo.21.2">For example, imagine a user scrolling through an electronic laboratory notebook on their local computer. </span><span class="koboSpan" id="kobo.21.3">When the user logs in and sees their data, this information is retrieved using an API (that is, an </span><em class="italic"><span class="koboSpan" id="kobo.22.1">application programming interface</span></em><span class="koboSpan" id="kobo.23.1">, not to be confused with an </span><em class="italic"><span class="koboSpan" id="kobo.24.1">active pharmaceutical ingredient</span></em><span class="koboSpan" id="kobo.25.1">). </span><span class="koboSpan" id="kobo.25.2">Once the data is retrieved for the user in the backend, it populates </span><a id="_idIndexMarker1127"/><span class="koboSpan" id="kobo.26.1">the frontend in a beautiful </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">User Interface</span></strong><span class="koboSpan" id="kobo.28.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.29.1">UI</span></strong><span class="koboSpan" id="kobo.30.1">) that allows the user to interact with the data, make changes, and save it. </span><span class="koboSpan" id="kobo.30.2">We can use web applications and APIs in </span><a id="_idIndexMarker1128"/><span class="koboSpan" id="kobo.31.1">a variety of ways, such as transferring data, communicating with others, or even making predictions, as illustrated in </span><em class="italic"><span class="koboSpan" id="kobo.32.1">Figure 11.1</span></em><span class="koboSpan" id="kobo.33.1">:</span></p>
			<div>
				<div id="_idContainer364" class="IMG---Figure">
					<span class="koboSpan" id="kobo.34.1"><img src="image/B17761_11_001.jpg" alt="Figure 11.1 – Some examples of web application functionality "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.35.1">Figure 11.1 – Some examples of web application functionality</span></p>
			<p><span class="koboSpan" id="kobo.36.1">With all of these capabilities, APIs and their counterparts have provided the main tool in the web </span><a id="_idIndexMarker1129"/><span class="koboSpan" id="kobo.37.1">application space for creating UIs to serve data and make predictions. </span><span class="koboSpan" id="kobo.37.2">There are a number of useful </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">web application frameworks</span></strong><span class="koboSpan" id="kobo.39.1"> available for a range of programming languages, as illustrated in </span><em class="italic"><span class="koboSpan" id="kobo.40.1">Figure 11.2</span></em><span class="koboSpan" id="kobo.41.1">:</span></p>
			<div>
				<div id="_idContainer365" class="IMG---Figure">
					<span class="koboSpan" id="kobo.42.1"><img src="image/B17761_11_002.jpg" alt="Figure 11.2 – Some examples of web application frameworks "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.43.1">Figure 11.2 – Some examples of web application frameworks</span></p>
			<p><span class="koboSpan" id="kobo.44.1">For the purposes of this chapter, we will focus on one of the more popular machine learning </span><a id="_idIndexMarker1130"/><span class="koboSpan" id="kobo.45.1">deployment frameworks: Flask (</span><a href="https://github.com/pallets/flask"><span class="koboSpan" id="kobo.46.1">https://github.com/pallets/flask</span></a><span class="koboSpan" id="kobo.47.1">). </span><span class="koboSpan" id="kobo.47.2">Relative to its counterparts, Flask can be thought of as a </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">micro web framework</span></strong><span class="koboSpan" id="kobo.49.1"> – it is completely written in Python and highly abstracted, allowing users </span><a id="_idIndexMarker1131"/><span class="koboSpan" id="kobo.50.1">to get started in the model deployment process with little to no difficulties.</span></p>
			<p><span class="koboSpan" id="kobo.51.1">As we begin to </span><a id="_idIndexMarker1132"/><span class="koboSpan" id="kobo.52.1">deploy models using the Flask framework, it is important to ask ourselves who the end user of our application will be. </span><span class="koboSpan" id="kobo.52.2">In many cases, predictions using our previously trained models will be conducted by colleagues and stakeholders. </span><span class="koboSpan" id="kobo.52.3">Therefore, having a useable UI will be important. </span><span class="koboSpan" id="kobo.52.4">On the other hand, our deployed models may not be needed by a person but rather a piece of software or another web application that will need to programmatically interact with it. </span><span class="koboSpan" id="kobo.52.5">In that case, a UI will not be needed – however, we </span><a id="_idIndexMarker1133"/><span class="koboSpan" id="kobo.53.1">will need an organized way (for example, </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">JSON</span></strong><span class="koboSpan" id="kobo.55.1">) to handle the transfer of data between the two systems. </span><span class="koboSpan" id="kobo.55.2">We can see a depiction of these two cases in </span><em class="italic"><span class="koboSpan" id="kobo.56.1">Figure 11.3</span></em><span class="koboSpan" id="kobo.57.1">:</span></p>
			<div>
				<div id="_idContainer366" class="IMG---Figure">
					<span class="koboSpan" id="kobo.58.1"><img src="image/B17761_11_003.jpg" alt="Figure 11.3 – The two general types of web applications "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.59.1">Figure 11.3 – The two general types of web applications</span></p>
			<p><span class="koboSpan" id="kobo.60.1">In either case, we will be able to accommodate both of these cases using Flask. </span><span class="koboSpan" id="kobo.60.2">The Flask framework </span><a id="_idIndexMarker1134"/><span class="koboSpan" id="kobo.61.1">offers a variety of architectures – both simple and complex – allowing users to select the pattern that best fits their needs. </span><span class="koboSpan" id="kobo.61.2">Flask APIs, in a similar </span><a id="_idIndexMarker1135"/><span class="koboSpan" id="kobo.62.1">way to their counterparts such as </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">Django</span></strong><span class="koboSpan" id="kobo.64.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">Node.js</span></strong><span class="koboSpan" id="kobo.66.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">Spring</span></strong><span class="koboSpan" id="kobo.68.1">, all generally </span><a id="_idIndexMarker1136"/><span class="koboSpan" id="kobo.69.1">operate in a similar manner using URLs. </span><span class="koboSpan" id="kobo.69.2">For both backend APIs </span><a id="_idIndexMarker1137"/><span class="koboSpan" id="kobo.70.1">and frontend UIs, we can use URLs to organize how we develop an application. </span><span class="koboSpan" id="kobo.70.2">For example, users can log in to a website to view and edit data within their profiles, whereas APIs can allow external entities to interact with models, as depicted in </span><em class="italic"><span class="koboSpan" id="kobo.71.1">Figure 11.4</span></em><span class="koboSpan" id="kobo.72.1">:</span></p>
			<div>
				<div id="_idContainer367" class="IMG---Figure">
					<span class="koboSpan" id="kobo.73.1"><img src="image/B17761_11_004.jpg" alt="Figure 11.4 – The two general types of web applications with examples "/></span>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption"><span class="koboSpan" id="kobo.74.1">Figure 11.4 – The two general types of web applications with examples</span></p>
			<p><span class="koboSpan" id="kobo.75.1">In order to interact </span><a id="_idIndexMarker1138"/><span class="koboSpan" id="kobo.76.1">with a web application, a user needs to make what is known </span><a id="_idIndexMarker1139"/><span class="koboSpan" id="kobo.77.1">as an </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">HTTP request</span></strong><span class="koboSpan" id="kobo.79.1">, which is usually carried out without them knowing. </span><span class="koboSpan" id="kobo.79.2">Each of these requests is generally associated with a URL, allowing the user to accomplish a task. </span><span class="koboSpan" id="kobo.79.3">The four HTTP request types are depicted in </span><em class="italic"><span class="koboSpan" id="kobo.80.1">Figure 11.5</span></em><span class="koboSpan" id="kobo.81.1">:</span></p>
			<div>
				<div id="_idContainer368" class="IMG---Figure">
					<span class="koboSpan" id="kobo.82.1"><img src="image/B17761_11_005.jpg" alt="Figure 11.5 – The four HTTP request types "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.83.1">Figure 11.5 – The four HTTP request types</span></p>
			<p><span class="koboSpan" id="kobo.84.1">For example, if a user navigating to </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">www.website.com/profile</span></strong><span class="koboSpan" id="kobo.86.1"> intends to retrieve the details of their profile, they would use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">GET</span></strong><span class="koboSpan" id="kobo.88.1"> request. </span><span class="koboSpan" id="kobo.88.2">On the other hand, an application using </span><a id="_idIndexMarker1140"/><span class="koboSpan" id="kobo.89.1">the API with the intention of classifying a segment of text would use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">POST</span></strong><span class="koboSpan" id="kobo.91.1"> request to send the text to </span><a href="http://www.website.com/api/classify"><span class="koboSpan" id="kobo.92.1">www.website.com/api/classify</span></a><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">These URL paths are known as </span><em class="italic"><span class="koboSpan" id="kobo.94.1">routes</span></em><span class="koboSpan" id="kobo.95.1"> within the confines of web applications, and they allow developers and data scientists to better organize their models for deployment. </span><span class="koboSpan" id="kobo.95.2">In the following section, we will see how routes can be used more specifically within the Flask framework.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.96.1">Working with Flask and Visual Studio Code</span></h1>
			<p><span class="koboSpan" id="kobo.97.1">Flask is one </span><a id="_idIndexMarker1141"/><span class="koboSpan" id="kobo.98.1">of the most commonly used and versatile </span><a id="_idIndexMarker1142"/><span class="koboSpan" id="kobo.99.1">web applications available in the </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">Python</span></strong><span class="koboSpan" id="kobo.101.1"> language. </span><span class="koboSpan" id="kobo.101.2">Its abstract and </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">high-level framework</span></strong><span class="koboSpan" id="kobo.103.1"> makes it easy for users of all levels to have an </span><a id="_idIndexMarker1143"/><span class="koboSpan" id="kobo.104.1">implementation up and running in no time. </span><span class="koboSpan" id="kobo.104.2">Over the course of </span><a id="_idIndexMarker1144"/><span class="koboSpan" id="kobo.105.1">this section, we will learn about the different components of a Flask application and deploy a simple model locally on our machine.</span></p>
			<p><span class="koboSpan" id="kobo.106.1">Before we </span><a id="_idIndexMarker1145"/><span class="koboSpan" id="kobo.107.1">can get started with Flask, we will need an </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">Integrated Development Environment</span></strong><span class="koboSpan" id="kobo.109.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.110.1">IDE</span></strong><span class="koboSpan" id="kobo.111.1">) to work with. </span><span class="koboSpan" id="kobo.111.2">So far, we have </span><a id="_idIndexMarker1146"/><span class="koboSpan" id="kobo.112.1">worked almost exclusively in </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">Jupyter Notebook</span></strong><span class="koboSpan" id="kobo.114.1"> to train and develop models. </span><span class="koboSpan" id="kobo.114.2">When it comes to implementation, we will need another type of IDE to work with. </span><span class="koboSpan" id="kobo.114.3">There </span><a id="_idIndexMarker1147"/><span class="koboSpan" id="kobo.115.1">are numerous Python IDEs we can use, such as </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">PyCharm</span></strong><span class="koboSpan" id="kobo.117.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Spyder</span></strong><span class="koboSpan" id="kobo.119.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Visual Studio</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.121.1">Code</span></strong><span class="koboSpan" id="kobo.122.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.123.1">VSC</span></strong><span class="koboSpan" id="kobo.124.1">). </span><span class="koboSpan" id="kobo.124.2">I personally have found VSC to be the </span><a id="_idIndexMarker1148"/><span class="koboSpan" id="kobo.125.1">most user-friendly to work with, and therefore, we will use that as our primary IDE in this section. </span><span class="koboSpan" id="kobo.125.2">You can download VSC from their website (</span><a href="https://code.visualstudio.com/download"><span class="koboSpan" id="kobo.126.1">https://code.visualstudio.com/download</span></a><span class="koboSpan" id="kobo.127.1">) or by using </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">Anaconda</span></strong><span class="koboSpan" id="kobo.129.1">.</span></p>
			<p><span class="koboSpan" id="kobo.130.1">Go ahead and </span><a id="_idIndexMarker1149"/><span class="koboSpan" id="kobo.131.1">begin the installation process, which might take a few minutes. </span><span class="koboSpan" id="kobo.131.2">While you wait, create a new folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">flask-test</span></strong><span class="koboSpan" id="kobo.133.1"> on your local computer. </span><span class="koboSpan" id="kobo.133.2">Once the installation process is complete, open VSC. </span><span class="koboSpan" id="kobo.133.3">You can open the folder you just created in a few simple steps:</span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.134.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">File</span></strong><span class="koboSpan" id="kobo.136.1"> on the top menu.</span></li>
				<li><span class="koboSpan" id="kobo.137.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">Open Folder</span></strong><span class="koboSpan" id="kobo.139.1">.</span></li>
				<li><span class="koboSpan" id="kobo.140.1">Navigate to your directory and click </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Select Folder</span></strong><span class="koboSpan" id="kobo.142.1">.</span></li>
			</ol>
			<p><span class="koboSpan" id="kobo.143.1">You should now see the name of your directory in the </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">explorer</span></strong><span class="koboSpan" id="kobo.145.1"> pane on the left-hand side of the screen. </span><span class="koboSpan" id="kobo.145.2">Within the explorer pane, you will be able to see all of the files and folders </span><a id="_idIndexMarker1150"/><span class="koboSpan" id="kobo.146.1">relevant to your current project. </span><span class="koboSpan" id="kobo.146.2">Let's go </span><a id="_idIndexMarker1151"/><span class="koboSpan" id="kobo.147.1">ahead and populate it with a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">app.py</span></strong><span class="koboSpan" id="kobo.149.1"> by right-clicking in the explorer pane and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">New File</span></strong><span class="koboSpan" id="kobo.151.1">.</span></p>
			<p><span class="koboSpan" id="kobo.152.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">app.py</span></strong><span class="koboSpan" id="kobo.154.1"> file is the </span><a id="_idIndexMarker1152"/><span class="koboSpan" id="kobo.155.1">main file that Flask uses in its framework. </span><span class="koboSpan" id="kobo.155.2">Everything within the application is included in this file or referenced from within it. </span><span class="koboSpan" id="kobo.155.3">Although its content depends on the exact implementation of the user, the file generally contains four main sections:</span></p>
			<ol>
				<li value="1"><span class="koboSpan" id="kobo.156.1">Importing libraries, data, and other resources</span></li>
				<li><span class="koboSpan" id="kobo.157.1">Instantiating the application and declaring other useful functions</span></li>
				<li><span class="koboSpan" id="kobo.158.1">Declaring the routes for the application</span></li>
				<li><span class="koboSpan" id="kobo.159.1">Running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">__name__ == "__main__" driver</span></strong><span class="koboSpan" id="kobo.161.1"> piece of code</span><p><span class="koboSpan" id="kobo.162.1">We can see an illustration of these components in </span><em class="italic"><span class="koboSpan" id="kobo.163.1">Figure 11.6</span></em><span class="koboSpan" id="kobo.164.1">:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer369" class="IMG---Figure">
					<span class="koboSpan" id="kobo.165.1"><img src="image/B17761_11_006.jpg" alt="Figure 11.6 – The main components of a Flask application "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.166.1">Figure 11.6 – The main components of a Flask application</span></p>
			<p><span class="koboSpan" id="kobo.167.1">Let's now go ahead and populate </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">app.py</span></strong><span class="koboSpan" id="kobo.169.1"> with some code. </span><span class="koboSpan" id="kobo.169.2">This is generally done in four main sections:</span></p>
			<ol>
				<li value="1"><span class="koboSpan" id="kobo.170.1">We will begin by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">Flask</span></strong><span class="koboSpan" id="kobo.172.1"> class from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">flask</span></strong><span class="koboSpan" id="kobo.174.1"> library:</span><p class="source-code"><span class="koboSpan" id="kobo.175.1">from flask import Flask</span></p></li>
				<li><span class="koboSpan" id="kobo.176.1">Next, we will need to create an instance of our Flask app:</span><p class="source-code"><span class="koboSpan" id="kobo.177.1">app = Flask(__name__)</span></p></li>
				<li><span class="koboSpan" id="kobo.178.1">We can now use the app object to create routes for our application. </span><span class="koboSpan" id="kobo.178.2">Routes operate </span><a id="_idIndexMarker1153"/><span class="koboSpan" id="kobo.179.1">by executing the function directly </span><a id="_idIndexMarker1154"/><span class="koboSpan" id="kobo.180.1">beneath it when that route is interacted with. </span><span class="koboSpan" id="kobo.180.2">Let's make a simple one that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">"Hello Biotech World!"</span></strong><span class="koboSpan" id="kobo.182.1">:</span><p class="source-code"><span class="koboSpan" id="kobo.183.1">@app.route('/')</span></p><p class="source-code"><span class="koboSpan" id="kobo.184.1">def biotech():</span></p><p class="source-code"><span class="koboSpan" id="kobo.185.1">    return "Hello Biotech World!"</span></p></li>
				<li><span class="koboSpan" id="kobo.186.1">Finally, we will need a driver for the application that can fulfill using </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">if __name__ == '__main__'</span></strong><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">We will also set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">debug</span></strong><span class="koboSpan" id="kobo.190.1"> parameter as </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">True</span></strong><span class="koboSpan" id="kobo.192.1"> to help us address any potential issues, and we will set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">port</span></strong><span class="koboSpan" id="kobo.194.1"> value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">8080</span></strong><span class="koboSpan" id="kobo.196.1">:</span><p class="source-code"><span class="koboSpan" id="kobo.197.1">if __name__ == '__main__':</span></p><p class="source-code"><span class="koboSpan" id="kobo.198.1">    app.run(debug=True, port=8080)</span></p><p><span class="koboSpan" id="kobo.199.1">From the command line in VSC, go ahead and run the Python application:</span></p><p class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.200.1">$ python3.8 app.py</span></strong></p><p><span class="koboSpan" id="kobo.201.1">This will run </span><a id="_idIndexMarker1155"/><span class="koboSpan" id="kobo.202.1">the application on your local computer. </span><span class="koboSpan" id="kobo.202.2">You can access it through any browser, such as </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">Google</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.204.1">Chrome</span></strong><span class="koboSpan" id="kobo.205.1">, and by navigating to </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">http://localhost:8080/</span></strong><span class="koboSpan" id="kobo.207.1">. </span><span class="koboSpan" id="kobo.207.2">Upon reaching this URL, you should be greeted by our previous message. </span><span class="koboSpan" id="kobo.207.3">Please note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">localhost</span></strong><span class="koboSpan" id="kobo.209.1"> URL is a link only accessible locally on your computer and is not available to others. </span><span class="koboSpan" id="kobo.209.2">The concept of routes should be familiar to us from the many websites we have used in the past. </span><span class="koboSpan" id="kobo.209.3">We can break down a URL into its smaller components, as depicted in </span><em class="italic"><span class="koboSpan" id="kobo.210.1">Figure 11.7</span></em><span class="koboSpan" id="kobo.211.1">:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer370" class="IMG---Figure">
					<span class="koboSpan" id="kobo.212.1"><img src="image/B17761_11_007.jpg" alt="Figure 11.7 – The main components of a URL "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.213.1">Figure 11.7 – The main components of a URL</span></p>
			<p><span class="koboSpan" id="kobo.214.1">In our case, we are currently editing the path or endpoint of the application. </span><span class="koboSpan" id="kobo.214.2">Flask applications can handle many paths and endpoints, giving developers a great deal of flexibility.</span></p>
			<p><span class="koboSpan" id="kobo.215.1">You can stop the application from running by pressing </span><em class="italic"><span class="koboSpan" id="kobo.216.1">CTRL</span></em><span class="koboSpan" id="kobo.217.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.218.1">C</span></em><span class="koboSpan" id="kobo.219.1"> in the command line, which will halt the process. </span><span class="koboSpan" id="kobo.219.2">With the process halted, go ahead and create </span><a id="_idIndexMarker1156"/><span class="koboSpan" id="kobo.220.1">a second route by copying </span><a id="_idIndexMarker1157"/><span class="koboSpan" id="kobo.221.1">the current route and function directly below it. </span><span class="koboSpan" id="kobo.221.2">Give the path a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">/lifescience</span></strong><span class="koboSpan" id="kobo.223.1"> (instead of just </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">/</span></strong><span class="koboSpan" id="kobo.225.1">) and give its function a unique name such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">lifescience</span></strong><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">Next, change the returned value, run the application again, and navigate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">http://localhost:8080/lifescience</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">If all was successful, you should be able to see your new message!</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.230.1">Routes and Functions</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.231.1">Please note that routes must be unique – this means that you cannot have multiple routes in Flask pointing to </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">/biotech</span></strong><span class="koboSpan" id="kobo.233.1">. </span><span class="koboSpan" id="kobo.233.2">Similarly, the function beneath the route must also be unique in its name.</span></p>
			<p><span class="koboSpan" id="kobo.234.1">When deploying </span><a id="_idIndexMarker1158"/><span class="koboSpan" id="kobo.235.1">our models, we will work with similar architecture. </span><span class="koboSpan" id="kobo.235.2">However, the return statements will generally comprise either a UI for people to use or data for applications to consume. </span><span class="koboSpan" id="kobo.235.3">In the following section, we will explore this in a little more depth by using a </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Natural Language Processing</span></strong><span class="koboSpan" id="kobo.237.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.238.1">NLP</span></strong><span class="koboSpan" id="kobo.239.1">) use case.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.240.1">Using Flask as an API and web application</span></h1>
			<p><span class="koboSpan" id="kobo.241.1">In </span><a href="B17761_09_Final_JM_ePub.xhtml#_idTextAnchor132"><em class="italic"><span class="koboSpan" id="kobo.242.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.243.1">, </span><em class="italic"><span class="koboSpan" id="kobo.244.1">Natural Language Processing</span></em><span class="koboSpan" id="kobo.245.1">, we explored the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">transformers</span></strong><span class="koboSpan" id="kobo.247.1"> library </span><a id="_idIndexMarker1159"/><span class="koboSpan" id="kobo.248.1">for the purposes of running text similarity </span><a id="_idIndexMarker1160"/><span class="koboSpan" id="kobo.249.1">search engines. </span><span class="koboSpan" id="kobo.249.2">By using this technology, we </span><a id="_idIndexMarker1161"/><span class="koboSpan" id="kobo.250.1">could have explored other models and implementations, such as </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">sentiment analysis</span></strong><span class="koboSpan" id="kobo.252.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">text classification</span></strong><span class="koboSpan" id="kobo.254.1">, and many more. </span><span class="koboSpan" id="kobo.254.2">One particular </span><a id="_idIndexMarker1162"/><span class="koboSpan" id="kobo.255.1">type of model that has gained a great deal of traction </span><a id="_idIndexMarker1163"/><span class="koboSpan" id="kobo.256.1">when it comes to NLP is the </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">summarization</span></strong><span class="koboSpan" id="kobo.258.1"> model. </span></p>
			<p><span class="koboSpan" id="kobo.259.1">We can </span><a id="_idIndexMarker1164"/><span class="koboSpan" id="kobo.260.1">think of summarization models as tasks designed </span><a id="_idIndexMarker1165"/><span class="koboSpan" id="kobo.261.1">to reduce several paragraphs of text down to a few sentences, thereby allowing users to reduce the amount of time required to read. </span><span class="koboSpan" id="kobo.261.2">Luckily for us, we can implement an out-of-the-box summarization model using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">transformers</span></strong><span class="koboSpan" id="kobo.263.1"> library and install that in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">app.py</span></strong><span class="koboSpan" id="kobo.265.1"> file. </span><span class="koboSpan" id="kobo.265.2">Not only will we need to cater to human users (by using a UI), but we will also need to cater to web applications (APIs) that may be interested in using our model. </span><span class="koboSpan" id="kobo.265.3">In order to accommodate these two cases, we will need three files in total within our project to get us started:</span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">app.py</span></strong><span class="koboSpan" id="kobo.267.1">: This is the main file in which the Flask framework and all NLP models are instantiated.</span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">styles.css</span></strong><span class="koboSpan" id="kobo.269.1">: This is a CSS file that allows us to style the UI.</span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">index.html</span></strong><span class="koboSpan" id="kobo.271.1">: This is an HTML file with a pre-built UI page that human users will interact with.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.272.1">For better organization, let's add the CSS file to </span><a id="_idIndexMarker1166"/><span class="koboSpan" id="kobo.273.1">a directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">styles</span></strong><span class="koboSpan" id="kobo.275.1"> and the HTML file to </span><a id="_idIndexMarker1167"/><span class="koboSpan" id="kobo.276.1">a directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">templates</span></strong><span class="koboSpan" id="kobo.278.1">.</span></p>
			<p><span class="koboSpan" id="kobo.279.1">When working with new Flask applications, we generally want to have a </span><em class="italic"><span class="koboSpan" id="kobo.280.1">blank slate</span></em><span class="koboSpan" id="kobo.281.1"> when it comes to the libraries we installed via </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">pip</span></strong><span class="koboSpan" id="kobo.283.1">. </span><span class="koboSpan" id="kobo.283.2">In other words, each Flask application should have its own </span><em class="italic"><span class="koboSpan" id="kobo.284.1">virtual environment</span></em><span class="koboSpan" id="kobo.285.1">, where we only install libraries the application will need and use. </span><span class="koboSpan" id="kobo.285.2">We can accomplish this using </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">virtualenv</span></strong><span class="koboSpan" id="kobo.287.1">, which (ironically) can be installed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">pip</span></strong><span class="koboSpan" id="kobo.289.1">. </span></p>
			<p><span class="koboSpan" id="kobo.290.1">Once installed, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">virtualenv</span></strong><span class="koboSpan" id="kobo.292.1"> on the command line to create a new environment for this project called </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">.venv</span></strong><span class="koboSpan" id="kobo.294.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.295.1">$ python38 virtualenv .venv</span></p>
			<p><span class="koboSpan" id="kobo.296.1">You can call your virtual environment anything you like, but most users generally default to the </span><a id="_idIndexMarker1168"/><span class="koboSpan" id="kobo.297.1">name in the preceding command. </span><span class="koboSpan" id="kobo.297.2">You will know this </span><a id="_idIndexMarker1169"/><span class="koboSpan" id="kobo.298.1">command was successful when you see a new </span><a id="_idIndexMarker1170"/><span class="koboSpan" id="kobo.299.1">directory in your current working directory with </span><a id="_idIndexMarker1171"/><span class="koboSpan" id="kobo.300.1">the specified name. </span><span class="koboSpan" id="kobo.300.2">We will now need to </span><em class="italic"><span class="koboSpan" id="kobo.301.1">activate</span></em><span class="koboSpan" id="kobo.302.1"> the environment, which can be a little tricky depending on the type of system you are using. </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">Windows</span></strong><span class="koboSpan" id="kobo.304.1"> users can activate their environment using the following command:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.305.1">&gt; .\.venv\Scripts\activate</span></p>
			<p><span class="koboSpan" id="kobo.306.1">On the other hand, </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">Linux</span></strong><span class="koboSpan" id="kobo.308.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">Mac</span></strong><span class="koboSpan" id="kobo.310.1"> users can activate their environments via the following command:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.311.1">$ source .venv\bin\activate</span></p>
			<p><span class="koboSpan" id="kobo.312.1">You can confirm the environment was activated if its name appears on the left-hand side of the command line's current working directory. </span><span class="koboSpan" id="kobo.312.2">Go ahead and install </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">flask</span></strong><span class="koboSpan" id="kobo.314.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">transformers</span></strong><span class="koboSpan" id="kobo.316.1">, as we will need these libraries in the current environment.</span></p>
			<p><span class="koboSpan" id="kobo.317.1">With the environment set up and including the three files discussed, we should have a directory structure as depicted in </span><em class="italic"><span class="koboSpan" id="kobo.318.1">Figure 11.8</span></em><span class="koboSpan" id="kobo.319.1">:</span></p>
			<div>
				<div id="_idContainer371" class="IMG---Figure">
					<span class="koboSpan" id="kobo.320.1"><img src="image/B17761_11_008.jpg" alt="Figure 11.8 – The current folder structure of this project in VSC "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.321.1">Figure 11.8 – The current folder structure of this project in VSC</span></p>
			<p><span class="koboSpan" id="kobo.322.1">With the project structure now in place, let's add some code to </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">app.py</span></strong><span class="koboSpan" id="kobo.324.1">. </span><span class="koboSpan" id="kobo.324.2">We can begin by importing some of the libraries we will need within this application:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.325.1">from flask import Flask, jsonify, request, render_template </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.326.1">import json</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.327.1">from transformers import pipeline</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.328.1">import re</span></p>
			<p><span class="koboSpan" id="kobo.329.1">Now that </span><a id="_idIndexMarker1172"/><span class="koboSpan" id="kobo.330.1">the libraries have been imported, we can instantiate </span><a id="_idIndexMarker1173"/><span class="koboSpan" id="kobo.331.1">an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">Flask</span></strong><span class="koboSpan" id="kobo.333.1"> application just as </span><a id="_idIndexMarker1174"/><span class="koboSpan" id="kobo.334.1">before. </span><span class="koboSpan" id="kobo.334.2">However, we will need to specify the </span><a id="_idIndexMarker1175"/><span class="koboSpan" id="kobo.335.1">template folder this time:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.336.1">app = Flask(__name__, template_folder='templates')</span></p>
			<p><span class="koboSpan" id="kobo.337.1">With the application instantiated, we can now create an instance of the summarizer model from the transformers </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">pipeline</span></strong><span class="koboSpan" id="kobo.339.1"> class:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.340.1">summarizer = pipeline("summarization")</span></p>
			<p><span class="koboSpan" id="kobo.341.1">Next, we can add our </span><em class="italic"><span class="koboSpan" id="kobo.342.1">routes</span></em><span class="koboSpan" id="kobo.343.1">. </span><span class="koboSpan" id="kobo.343.2">We will first create a route to our home page, which displays the UI using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">index.html</span></strong><span class="koboSpan" id="kobo.345.1"> file:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.346.1">@app.route('/')</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.347.1">def home():</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.348.1">    return render_template('index.html')</span></p>
			<p><span class="koboSpan" id="kobo.349.1">We will then need to add two routes: one for the UI, and another for the API. </span><span class="koboSpan" id="kobo.349.2">There are many best practices that vary depending on the framework, the industry, and the use case. </span><span class="koboSpan" id="kobo.349.3">In most scenarios, </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">api</span></strong><span class="koboSpan" id="kobo.351.1"> endpoints are generally preceded with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">api</span></strong><span class="koboSpan" id="kobo.353.1"> word to distinguish them from others. </span><span class="koboSpan" id="kobo.353.2">Let's go ahead and create a route for the UI first:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.354.1">@app.route('/prediction', methods = ["POST"])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.355.1">def ui_prediction():</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.356.1">    """</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.357.1">    A function that takes a JSON with two fields: "text" &amp; "maxlen"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.358.1">    Returns: the summarized text of the paragraphs.</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.359.1">    """</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.360.1">    print(request.form.values())</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.361.1">    paragraphs = request.form.get("paragraphs")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.362.1">    paragraphs = re.sub("\d+", "", paragraphs)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.363.1">    maxlen = int(request.form.get("maxlen"))</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.364.1">    summary = summarizer(paragraphs, max_length=maxlen, min_length=49, do_sample=False)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.365.1">    return render_template('index.html', prediction_text = '" {} "'.format(summary[0]["summary_text"])), 200</span></p>
			<p><span class="koboSpan" id="kobo.366.1">Notice </span><a id="_idIndexMarker1176"/><span class="koboSpan" id="kobo.367.1">that within this function, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">request.form.get</span></strong><span class="koboSpan" id="kobo.369.1"> function to retrieve the values from the form in the UI. </span><span class="koboSpan" id="kobo.369.2">In addition, we use </span><a id="_idIndexMarker1177"/><span class="koboSpan" id="kobo.370.1">some regular expressions to clean up the text, and </span><a id="_idIndexMarker1178"/><span class="koboSpan" id="kobo.371.1">then we summarize the contents using the </span><a id="_idIndexMarker1179"/><span class="koboSpan" id="kobo.372.1">summarizer model. </span><span class="koboSpan" id="kobo.372.2">Finally, we return the summary and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">index.html</span></strong><span class="koboSpan" id="kobo.374.1"> file.</span></p>
			<p><span class="koboSpan" id="kobo.375.1">Let's now create the second route for the api:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.376.1">@app.route('/api/prediction', methods = ["POST"])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.377.1">def api_prediction():</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.378.1">    """</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.379.1">    A function that takes a JSON with two fields: "text" &amp; "maxlen"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.380.1">    Returns: the summarized text of the paragraphs.</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.381.1">    """</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.382.1">    query = json.loads(request.data)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.383.1">    paragraphs = re.sub("\d+", "", query["text"])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.384.1">    maxlen = query["maxlen"]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.385.1">    minlen = query["minlen"]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.386.1">    summary = summarizer(paragraphs, max_length=maxlen, min_length=minlen, do_sample=False)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.387.1">    return jsonify(summary), 200</span></p>
			<p><span class="koboSpan" id="kobo.388.1">Notice that in addition to taking the input data, cleaning the contents, and summarizing it, we can take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">maxlen</span></strong><span class="koboSpan" id="kobo.390.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">minlen</span></strong><span class="koboSpan" id="kobo.392.1"> parameters directly from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">JSON</span></strong><span class="koboSpan" id="kobo.394.1"> object.</span></p>
			<p><span class="koboSpan" id="kobo.395.1">Finally, we can go ahead and execute the code:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.396.1">if __name__ == '__main__':</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.397.1">    app.run(debug=True)</span></p>
			<p><span class="koboSpan" id="kobo.398.1">With that, we </span><a id="_idIndexMarker1180"/><span class="koboSpan" id="kobo.399.1">have successfully developed the Flask </span><a id="_idIndexMarker1181"/><span class="koboSpan" id="kobo.400.1">application. </span><span class="koboSpan" id="kobo.400.2">Once deployed, you should be able to </span><a id="_idIndexMarker1182"/><span class="koboSpan" id="kobo.401.1">navigate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">http://localhost:5000/</span></strong><span class="koboSpan" id="kobo.403.1"> and start </span><a id="_idIndexMarker1183"/><span class="koboSpan" id="kobo.404.1">summarizing paragraphs of text! </span><span class="koboSpan" id="kobo.404.2">We can see an example of the application in </span><em class="italic"><span class="koboSpan" id="kobo.405.1">Figure 11.9</span></em><span class="koboSpan" id="kobo.406.1">:</span></p>
			<div>
				<div id="_idContainer372" class="IMG---Figure">
					<span class="koboSpan" id="kobo.407.1"><img src="image/B17761_11_009.jpg" alt="Figure 11.9 – A screenshot of the summarizer web application  "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.408.1">Figure 11.9 – A screenshot of the summarizer web application </span></p>
			<p><span class="koboSpan" id="kobo.409.1">In addition, we </span><a id="_idIndexMarker1184"/><span class="koboSpan" id="kobo.410.1">can use applications such as </span><strong class="bold"><span class="koboSpan" id="kobo.411.1">Postman</span></strong><span class="koboSpan" id="kobo.412.1"> (</span><a href="https://www.postman.com/"><span class="koboSpan" id="kobo.413.1">https://www.postman.com/</span></a><span class="koboSpan" id="kobo.414.1">) to test the API endpoint. </span><span class="koboSpan" id="kobo.414.2">Alternatively, we could use the requests library from Python to accomplish the same thing. </span><span class="koboSpan" id="kobo.414.3">In this case, we would need to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">POST</span></strong><span class="koboSpan" id="kobo.416.1"> request, add the URL, and then add the data in the form of a dictionary and the content type of the application/JSON:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.417.1">{</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.418.1">    "text" : "Biotechnology is a broad area of biology, involving the use of living systems and organisms to develop or make products. </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.419.1">                              …</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.420.1"> molecular biology, biochemistry, cell biology, embryology, genetics, microbiology) and conversely provides methods to support and perform basic research in biology.",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.421.1">    "maxlen" : 60,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.422.1">    "minlen" : 30</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.423.1">}</span></p>
			<p><span class="koboSpan" id="kobo.424.1">With the application now working, we managed to successfully create a solution that uses Flask </span><a id="_idIndexMarker1185"/><span class="koboSpan" id="kobo.425.1">to cater to both human users and other web </span><a id="_idIndexMarker1186"/><span class="koboSpan" id="kobo.426.1">applications. </span><span class="koboSpan" id="kobo.426.2">In the final chapter of this book, we will </span><a id="_idIndexMarker1187"/><span class="koboSpan" id="kobo.427.1">deploy this application to the cloud. </span><span class="koboSpan" id="kobo.427.2">However, one </span><a id="_idIndexMarker1188"/><span class="koboSpan" id="kobo.428.1">of the most important steps of doing this is providing a list of the libraries that need to be installed. </span><span class="koboSpan" id="kobo.428.2">Given that we have set up a virtual environment, we can easily transfer a list of these libraries to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.430.1"> file via </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">pip</span></strong><span class="koboSpan" id="kobo.432.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.433.1">$ pip freeze &gt; requirements.txt</span></p>
			<p><span class="koboSpan" id="kobo.434.1">With that, you should now see a </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.436.1"> file in the same directory as </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">app.py</span></strong><span class="koboSpan" id="kobo.438.1">. </span><span class="koboSpan" id="kobo.438.2">It is important to ensure that the environment you use only contains the libraries you plan to use. </span><span class="koboSpan" id="kobo.438.3">This helps keep the application light and fast to use. </span><span class="koboSpan" id="kobo.438.4">In the following section, we will look at a more in-depth application – one that uses a previously trained model concerning the breast cancer dataset we saw earlier in this book.</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.439.1">Tutorial – Deploying a pretrained model using Flask</span></h1>
			<p><span class="koboSpan" id="kobo.440.1">In the previous example of creating a Flask application, we saw how we can make use of the </span><a id="_idIndexMarker1189"/><span class="koboSpan" id="kobo.441.1">application in conjunction with a predictive </span><a id="_idIndexMarker1190"/><span class="koboSpan" id="kobo.442.1">model to deploy a solution to our end users. </span><span class="koboSpan" id="kobo.442.2">However, the model that we deployed was an out-of-the-box solution and not a model we developed ourselves. </span><span class="koboSpan" id="kobo.442.3">In this section, we will once again deploy a model within a Flask application; however, we use a model based on the cancer dataset we saw in </span><a href="B17761_05_Final_JM_ePub.xhtml#_idTextAnchor082"><em class="italic"><span class="koboSpan" id="kobo.443.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.444.1">, </span><em class="italic"><span class="koboSpan" id="kobo.445.1">Understanding Machine Learning</span></em><span class="koboSpan" id="kobo.446.1">.</span></p>
			<p><span class="koboSpan" id="kobo.447.1">If you recall, the main idea behind this model was to take in a number of measurements for a given tumor, and based on those measurements, determine what the diagnosis will likely be, resulting in either </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">Malignant</span></strong><span class="koboSpan" id="kobo.449.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Benign</span></strong><span class="koboSpan" id="kobo.451.1">. </span><span class="koboSpan" id="kobo.451.2">Within this application, we will enable users to interact with a trained model and enter measurements that the model will use to make a prediction. </span><span class="koboSpan" id="kobo.451.3">With this in mind, let's get started!</span></p>
			<p><span class="koboSpan" id="kobo.452.1">In the same way as before, go ahead and add a new folder and a new virtual environment to install the relevant libraries. </span></p>
			<p><span class="koboSpan" id="kobo.453.1">Using the same directory architecture and process as before, we can begin by importing the relevant libraries. </span><span class="koboSpan" id="kobo.453.2">Notice that we have added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">pickle</span></strong><span class="koboSpan" id="kobo.455.1"> library here, as we will need to use the </span><em class="italic"><span class="koboSpan" id="kobo.456.1">pickled</span></em><span class="koboSpan" id="kobo.457.1"> models we previously created:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.458.1">from flask import Flask, jsonify, request, render_template </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.459.1">import json</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.460.1">import pickle</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.461.1">import pandas as pd</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.462.1">from sklearn.preprocessing import StandardScaler</span></p>
			<p><span class="koboSpan" id="kobo.463.1">Our next step involves importing the two models we trained – the actual classification model and the standard scaler model we used for the data: </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.464.1">loaded_scaler= pickle.load(open("./models/ch10_scaler.pickle",'rb'))</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.465.1">loaded_clf= pickle.load(open("./models/ch10_rfc_clf.pickle",'rb'))</span></p>
			<p><span class="koboSpan" id="kobo.466.1">We can then define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">predict_diagnosis</span></strong><span class="koboSpan" id="kobo.468.1"> function to clean up our code later when developing our routes. </span><span class="koboSpan" id="kobo.468.2">This function will take the input data in the form of a list, the scaler model, and the classification model:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.469.1">def predict_diagnosis(inputData, scaler, model):</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.470.1">    """</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.471.1">    Function that takes a list of measurements, scales them, and returns a prediction</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.472.1">    """</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.473.1">    inputDataDF = pd.DataFrame([inputData])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.474.1">    scaledInputData = scaler.transform(inputDataDF)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.475.1">    prediction = model.predict(scaledInputData)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.476.1">    return prediction[0]</span></p>
			<p><span class="koboSpan" id="kobo.477.1">Next, we will instantiate the Flask application while specifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">template</span></strong><span class="koboSpan" id="kobo.479.1"> folder:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.480.1">app = Flask(__name__, template_folder='templates')</span></p>
			<p><span class="koboSpan" id="kobo.481.1">With </span><a id="_idIndexMarker1191"/><span class="koboSpan" id="kobo.482.1">these items taken care of, we can focus </span><a id="_idIndexMarker1192"/><span class="koboSpan" id="kobo.483.1">on our routes. </span><span class="koboSpan" id="kobo.483.2">First, we will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">home</span></strong><span class="koboSpan" id="kobo.485.1"> route that users will see first:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.486.1">@app.route('/')</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.487.1">def home():</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.488.1">    return render_template('index.html')</span></p>
			<p><span class="koboSpan" id="kobo.489.1">Next, we will need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">prediction</span></strong><span class="koboSpan" id="kobo.491.1"> route, just as before. </span><span class="koboSpan" id="kobo.491.2">The only difference here is that the number of input values will be greater, as we are working with a few more features now:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.492.1">@app.route('/prediction', methods = ["POST"])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.493.1">def prediction():</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.494.1">    print(request.form.values())</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.495.1">    radius_mean = request.form.get("radius_mean")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.496.1">    texture_mean = request.form.get("texture_mean")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.497.1">    smoothness_mean = request.form.get("smoothness_mean")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.498.1">    texture_se = request.form.get("texture_se")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.499.1">    smoothness_se = request.form.get("smoothness_se")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.500.1">    symmetry_se = request.form.get("symmetry_se")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.501.1">    input_features = [radius_mean, texture_mean, smoothness_mean, texture_se, smoothness_se, symmetry_se]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.502.1">    prediction = predict_diagnosis(input_features, loaded_scaler, loaded_clf)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.503.1">    prediction = "Malignant" if prediction == "M" else "Benign"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.504.1">    </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.505.1">    return render_template('index.html', prediction_text = '" {} "'.format(prediction))</span></p>
			<p><span class="koboSpan" id="kobo.506.1">Finally, we can go ahead and run the application:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.507.1">if __name__ == '__main__':</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.508.1">    app.run(debug=False, port=5000)</span></p>
			<p><span class="koboSpan" id="kobo.509.1">Upon running </span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.510.1">the model and navigating </span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.511.1">to localhost in the web browser, the application will appear. </span><span class="koboSpan" id="kobo.511.2">Go ahead and try making a few predictions using the UI, an example of which is displayed in </span><em class="italic"><span class="koboSpan" id="kobo.512.1">Figure 11.10</span></em><span class="koboSpan" id="kobo.513.1">:</span></p>
			<div>
				<div id="_idContainer373" class="IMG---Figure">
					<span class="koboSpan" id="kobo.514.1"><img src="image/B17761_11_0010.jpg" alt="Figure 11.10 – A screenshot of the breast cancer web application  "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.515.1">Figure 11.10 – A screenshot of the breast cancer web application </span></p>
			<p><span class="koboSpan" id="kobo.516.1">We can see that the model is able to take our input data, run a prediction, and return a result to </span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.517.1">the user. </span><span class="koboSpan" id="kobo.517.2">One thing we did not do </span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.518.1">here is create an API route for other web applications to interact with our model. </span><span class="koboSpan" id="kobo.518.2">As a challenge, go ahead and create this route, using the previous summarization application as an example. </span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.519.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.520.1">In this chapter, we steered away from the development of models and focused more on how models can be deployed to interact with web applications. </span><span class="koboSpan" id="kobo.520.2">We investigated the idea of data transfer via APIs, and we also learned about some of the most common frameworks. </span><span class="koboSpan" id="kobo.520.3">We investigated one of the most common Python web application frameworks known as Flask. </span><span class="koboSpan" id="kobo.520.4">Using Flask, we developed an NLP summarization model that allows both human users and other web applications to interact with it and use its capabilities. </span><span class="koboSpan" id="kobo.520.5">In addition, we learned how to deploy previously trained models, such as those from </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">scikit-learn</span></strong><span class="koboSpan" id="kobo.522.1">. </span></p>
			<p><span class="koboSpan" id="kobo.523.1">In each of these instances, we launched our models locally as we developed their frameworks and capabilities. </span><span class="koboSpan" id="kobo.523.2">In the next chapter, we will make our model available to others by using </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">Docker</span></strong><span class="koboSpan" id="kobo.525.1"> containers and </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">AWS</span></strong><span class="koboSpan" id="kobo.527.1"> to deploy our model to the cloud.</span></p>
		</div>
	</body></html>