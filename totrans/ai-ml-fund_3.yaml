- en: '3'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: Regression
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Describe the mathematical logic involved in regression
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述回归中涉及的数学逻辑
- en: Illustrate the use of the NumPy library for Regression
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阐述 NumPy 库在回归中的应用
- en: Identify linear regression with one variable and with multiple variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别一元和多元线性回归
- en: Use polynomial regression
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多项式回归
- en: This chapter covers the fundamentals of linear and polynomial regression.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了线性回归和多项式回归的基础。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Regression is a broad topic that connects mathematical statistics, data science,
    machine learning, and artificial intelligence. As the basics of regression are
    rooted in mathematics, we will start by exploring the mathematical fundamentals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回归是一个广泛的领域，它将数学统计学、数据科学、机器学习和人工智能联系起来。由于回归的基本原理根植于数学，我们将从探索数学基础开始。
- en: Most of this topic will deal with different forms of linear regression, including
    linear regression with one variable, linear regression with multiple variables,
    polynomial regression with one variable, and polynomial regression with multiple
    variables. Python provides a lot of support for performing regression operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题的大部分内容将涉及不同形式的线性回归，包括一元线性回归、多元线性回归、一元多项式回归和多元多项式回归。Python 提供了大量支持进行回归操作的功能。
- en: We will also use alternative regression models while comparing and contrasting
    support vector Regression with forms of Linear Regression. Throughout this chapter,
    we will use stock price data loaded from an online service provider. The models
    in this chapter are not intended to provide trading or investment advice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较和对比支持向量回归与线性回归形式的同时，我们还将使用替代的回归模型。在本章中，我们将使用从在线服务提供商加载的股价数据进行回归分析。本章中的模型并不旨在提供交易或投资建议。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Although it is not suggested to use the models in this chapter to provide trading
    or investment advice, it is a very exciting and interesting journey that explains
    the fundamentals of regression.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不建议使用本章中的模型提供交易或投资建议，但这确实是一次非常激动人心且有趣的旅程，它解释了回归的基本原理。
- en: Linear Regression with One Variable
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一元线性回归
- en: A general regression problem can be defined as follows. Suppose we have a set
    of data points. We need to figure out a best fit curve to approximately fit the
    given data points. This curve will describe the relationship between our input
    variable x, which is the data points, and output variable y, which is the curve.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一般的回归问题可以定义为如下。假设我们有一组数据点。我们需要找出一个最佳拟合曲线来近似拟合给定的数据点。这条曲线将描述我们的输入变量 x（数据点）与输出变量
    y（曲线）之间的关系。
- en: In real life, we often have multiple input variables determining one output
    variable. Regression helps us understand how the output variable changes when
    we keep all but one input variable fixed, and we change the remaining input variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们经常有多个输入变量决定一个输出变量。回归帮助我们理解当我们将所有但一个输入变量固定时，输出变量是如何变化的，并且我们改变剩余的输入变量。
- en: What Is Regression?
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是回归？
- en: In this chapter, we will work with regression on the two-dimensional plane.
    This means that our data points are two-dimensional, and we are looking for a
    curve to approximate how to calculate one variable from another.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究二维平面上的回归。这意味着我们的数据点是二维的，我们正在寻找一条曲线来近似如何从一个变量计算另一个变量。
- en: 'We will learn about the following types of regression:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习以下类型的回归：
- en: '**Linear regression with one variable using a polynomial of degree 1** : This
    is the most basic form of regression, where a straight line approximates the trajectory
    of future datasets.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用一元多项式（度数为1）进行一元线性回归**：这是回归的最基本形式，其中一条直线近似表示未来数据集的轨迹。'
- en: '**Linear regression with multiple variables using a polynomial of degree 1**
    : We will be using equations of degree 1, but we will now allow multiple input
    variables, also known as features.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用一元多项式（度数为1）进行多元线性回归**：我们将使用一元方程，但现在我们将允许多个输入变量，也称为特征。'
- en: '**Polynomial regression with one variable** : This is a generic form of linear
    regression of one variable. As the polynomial used to approximate the relationship
    between the input and the output is of an arbitrary degree, we can create curves
    that fit the data points better than a straight line. The regression is still
    linear – not because the polynomial is linear, but because the regression problem
    can be modeled using linear algebra.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一元多项式回归**：这是单变量线性回归的一种通用形式。由于用来近似输入和输出之间关系的多项式是任意阶的，我们可以创建比直线更好地拟合数据点的曲线。回归仍然是线性的——不是因为多项式是线性的，而是因为回归问题可以用线性代数来建模。'
- en: '**Polynomial regression with multiple variables** : This is the most generic
    regression problem using higher degree polynomials and multiple features to predict
    the future.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多元多项式回归**：这是使用高阶多项式和多个特征预测未来的最通用回归问题。'
- en: '**Support vector regression** : This form of regression uses support vector
    machines to predict data points. This type of regression is included to compare
    its usage to the other four regression types.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持向量回归**：这种回归形式使用支持向量机来预测数据点。这种回归形式包括在内，以便将其与其他四种回归形式的用法进行比较。'
- en: 'In this topic, we will deal with the first type of linear regression: we will
    use one variable, and the polynomial of the regression will describe a straight
    line.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将处理第一种类型的线性回归：我们将使用一个变量，回归的多项式将描述一条直线。
- en: On the two-dimensional plane, we will use the Déscartes coordinate system, more
    commonly known as the Cartesian coordinate system. We have an *X* and a *Y* axis,
    and the intersection of these two axes is the origin. We denote points by their
    X and Y coordinates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维平面上，我们将使用笛卡尔坐标系，更通俗地称为直角坐标系。我们有一个 *X* 轴和一个 *Y* 轴，这两个轴的交点是原点。我们用它们的 X 和 Y
    坐标来表示点。
- en: 'For instance, the point (2, 1) corresponds to the orange point on the following
    coordinate system:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，点 (2, 1) 对应于以下坐标系中的橙色点：
- en: '![](img/Image00020.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00020.jpg)'
- en: 'Figure 3.1: Representation of point (2,1) on the coordinate system'
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.1：在坐标系中表示点 (2,1)
- en: A straight line can be described with the equation `y = a*x + b` , where a is
    the slope of the equation, determining how steeply the equation climbs up, and
    b is a constant determining where the line intersects the Y axis
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一条直线可以用方程 `y = a*x + b` 来描述，其中 a 是方程的斜率，决定了方程上升的陡峭程度，b 是一个常数，决定了直线与 Y 轴的交点。
- en: 'In the following diagram, you can see three equations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，你可以看到三个方程：
- en: The blue line is described with the y = 2*x + 1 equation.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝线用 y = 2*x + 1 方程描述。
- en: The orange line is described with the y = x + 1 equation.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橙线用 y = x + 1 方程描述。
- en: The purple line is described with the y = 0.5*x + 1 equation.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紫色线用 y = 0.5*x + 1 方程描述。
- en: You can see that all three equations intersect the y-axis at 1, and their slope
    is determined by the factor by which we multiply x.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，所有三个方程都在 y 轴上交于 1，它们的斜率由我们乘以 x 的因子决定。
- en: 'If you know x, you can figure out y. If you know y, you can figure out x:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道 x，你可以找出 y。如果你知道 y，你可以找出 x：
- en: '![](img/Image00021.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00021.jpg)'
- en: 'Figure 3.2: Representation of the equations y = 2*x + 1, y = x + 1, and y =
    0.5*x + 1 on the coordinate system'
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.2：在坐标系中表示方程 y = 2*x + 1, y = x + 1, 和 y = 0.5*x + 1
- en: 'We can describe more complex curves with equations too:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用方程描述更复杂的曲线：
- en: '![](img/Image00022.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00022.jpg)'
- en: 'Figure 3.3: Image showing a complex curve'
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.3：显示复杂曲线的图像
- en: Note
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you would like to experiment more with the Cartesian coordinate system,
    you can use the following plotter: [https://s3-us-west-2.amazonaws.com/oerfiles/College+Algebra/calculator.html](https://s3-us-west-2.amazonaws.com/oerfiles/College+Algebra/calculator.html)
    .'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更多地实验笛卡尔坐标系，你可以使用以下绘图器：[https://s3-us-west-2.amazonaws.com/oerfiles/College+Algebra/calculator.html](https://s3-us-west-2.amazonaws.com/oerfiles/College+Algebra/calculator.html)。
- en: Features and Labels
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特征和标签
- en: In machine learning, we differentiate between features and labels. Features
    are considered our input variables, and labels are our output variables.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，我们区分特征和标签。特征被认为是我们的输入变量，标签是我们的输出变量。
- en: When talking about regression, the possible values of labels is a continuous
    set of rational numbers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论回归时，标签的可能值是一个连续的有理数集合。
- en: Think about features as values on the X-axis, and labels as the value on the
    Y-axis.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将特征视为 X 轴上的值，将标签视为 Y 轴上的值。
- en: 'The task of regression is to predict label values based on feature values.
    We often create a label by shifting values of a feature forward. For instance,
    if we would like to predict stock prices in 1 month, and we create the label by
    shifting the stock price feature 1 month to the future, then:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回归的任务是根据特征值预测标签值。我们通常通过将特征值前移来创建标签。例如，如果我们想预测1个月后的股价，并且通过将股价特征前移1个月来创建标签，那么：
- en: For each stock price feature value that's at least 1 month old, training data
    is available that shows the predicted stock price data 1 month in the future
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个至少有1个月历史的股价特征值，都有可用的训练数据，显示了1个月后的预测股价数据。
- en: For the last month, prediction data is not available, so these values are all
    NaN (not a number)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于上个月，预测数据不可用，因此这些值都是NaN（不是一个数字）。
- en: We must drop the last month, because we cannot use these values for the prediction.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须丢弃上个月的数据，因为我们不能使用这些值进行预测。
- en: Feature Scaling
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特征缩放
- en: At times, we have multiple features that may have values within completely different
    ranges. Imagine comparing micrometers on a map to kilometers in the real world.
    They won't be easy to handle because of the magnitudinal difference of nine zeros.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们有多组特征，它们的值可能完全在不同的范围内。想象一下，在地图上比较微米和现实世界中的千米。由于数量级相差九个零，它们将很难处理。
- en: A less dramatic difference is the difference between imperial and metric data.
    Pounds and kilograms, and centimeters and inches, don't compare that well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不那么戏剧性的差异是英制和公制数据之间的差异。磅和千克，厘米和英寸，它们之间的比较并不好。
- en: Therefore, we often scale our features to normalized values that are easier
    to handle, as we can compare values of this range more easily. We scale training
    and testing data together. Ranges are typically scaled within [-1;1].
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通常将特征缩放到归一化值，这样处理起来更容易，因为我们更容易比较这个范围内的值。我们将训练数据和测试数据一起缩放。范围通常缩放到[-1;1]之间。
- en: 'We will demonstrate two types of scaling:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示两种类型的缩放：
- en: Min-Max normalization
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小-最大归一化
- en: Mean normalization
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值归一化
- en: 'Min-max scaling is calculated as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最小-最大缩放的计算如下：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Mean normalization is calculated as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 均值归一化的计算如下：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s an example of Min-Max and min-max:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个最小-最大和最大-最小归一化的例子：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Scaling could add to the processing time, but often it is a sensible step to
    add.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放可能会增加处理时间，但通常这是一个合理的步骤。
- en: 'In the scikit-learn library, we have access to a function that scales NumPy
    arrays:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在scikit-learn库中，我们可以访问一个用于缩放NumPy数组的函数：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The scale method performs mean normalization. Notice that the result is a NumPy
    array.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放方法执行均值归一化。请注意，结果是NumPy数组。
- en: Cross-Validation with Training and Test Data
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于训练和测试数据的交叉验证
- en: Cross-validation measures the predictive performance of a statistical model.
    The better the cross-validation result, the more you can trust that your model
    can be used to predict the future.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉验证衡量统计模型的预测性能。交叉验证结果越好，你就越可以相信你的模型可以用来预测未来。
- en: During cross-validation, we test our model's ability to predict the future on
    real **test data** . Test data is not used in the prediction process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在交叉验证期间，我们测试模型在真实**测试数据**上预测未来的能力。测试数据不用于预测过程。
- en: '**Training data** is used to construct the model that predicts our results.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**训练数据**用于构建预测结果的模型。'
- en: Once we load data from a data source, we typically separate data into a larger
    chunk of training data, and a smaller chunk of test data. This separation shuffles
    the entries of training and test data randomly. Then, it gives you an array of
    training features, their corresponding training labels, testing features, and
    their corresponding testing labels.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从数据源加载数据，我们通常将数据分成较大的训练数据块和较小的测试数据块。这种分离会随机打乱训练和测试数据的条目。然后，它给你一个包含训练特征、相应的训练标签、测试特征和相应的测试标签的数组。
- en: We can do the training-testing split using the `model_selection` library of
    scikit-learn.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用scikit-learn的`model_selection`库进行训练-测试分割。
- en: 'Suppose in our dummy example that we have scaled Fibonacci data and its indices
    as labels:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们这个假设的例子中，我们已经缩放了斐波那契数据及其索引作为标签：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's use 10% of the data as test data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用10%的数据作为测试数据。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With training and testing, if we get the ratios wrong, we run the risk of overfitting
    or underfitting the model.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练和测试过程中，如果我们得到错误的比率，我们就有可能过度拟合或欠拟合模型。
- en: Overfitting occurs when we train the model too well, and it fits the training
    dataset too well. The model will be very accurate on the training data, but it
    will not be usable in real life, because its accuracy decreases when used on any
    other data. The model adjusts to the random noise in the training data and assumes
    patterns on this noise that yield false predictions. Underfitting occurs when
    the model does not fit the training data well enough to recognize important characteristics
    of the data. As a result, it cannot make the necessary predictions on new data.
    One example for this is when we attempt to do linear regression on data that is
    not linear. For instance, Fibonacci numbers are not linear, therefore, a model
    on a Fibonacci-like sequence cannot be linear either.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们训练模型过于完美，以至于它对训练数据集拟合得太好时，就会发生过拟合。模型将在训练数据上非常准确，但在现实生活中却无法使用，因为当它用于任何其他数据时，其准确性会下降。模型调整到训练数据中的随机噪声，并假设在这个噪声上的模式会产生错误的预测。当模型没有很好地拟合训练数据，以至于无法识别数据的重要特征时，就会发生欠拟合。结果，它无法对新数据进行必要的预测。一个例子是当我们尝试对非线性数据进行线性回归时。例如，斐波那契数不是线性的，因此，斐波那契序列上的模型也不能是线性的。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you remember the Cartesian coordinate system, you know that the horizontal
    axis is the X axis, and that the vertical axis is the Y axis. Our features are
    on the X axis, while our labels are on the Y axis. Therefore, we use features
    and X as synonyms, while labels are often denoted by Y. Therefore, x_test denotes
    feature test data, x_train denotes feature training data, y_test denotes label
    test data, and y_train denotes label training data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得笛卡尔坐标系，你知道水平轴是X轴，而垂直轴是Y轴。我们的特征位于X轴，而我们的标签位于Y轴。因此，我们将特征和X视为同义词，而标签通常用Y表示。因此，x_test表示特征测试数据，x_train表示特征训练数据，y_test表示标签测试数据，y_train表示标签训练数据。
- en: Fitting a Model on Data with scikit-learn
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用scikit-learn在数据上拟合模型
- en: We are illustrating the process of regression on a dummy example, where we only
    have one feature and very limited data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个虚拟示例来展示回归的过程，在这个示例中，我们只有一个特征和非常有限的数据。
- en: As we only have one feature, we have to format `x_train` by reshaping it with
    `x_train.reshape (-1,1)` to a NumPy array containing one feature.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有一个特征，我们必须通过`x_train.reshape (-1,1)`将`x_train`格式化为一个包含一个特征的NumPy数组。
- en: 'Therefore, before executing the code on fitting the best line, execute the
    following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在执行拟合最佳线的代码之前，请执行以下代码：
- en: '`x_train = x_train.reshape(-1, 1)`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`x_train = x_train.reshape(-1, 1)`'
- en: '`x_test = x_test.reshape(-1, 1)`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`x_test = x_test.reshape(-1, 1)`'
- en: '`# array([a, b, c]).reshape(-1, 1) becomes:`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`# array([a, b, c]).reshape(-1, 1) becomes:`'
- en: '`# array([[a, b, c]])`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`# array([[a, b, c]])`'
- en: Suppose we have train and test data for our features and labels.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为我们的特征和标签有训练和测试数据。
- en: 'We can fit a model on this data for performing prediction. We will now use
    linear regression for this purpose:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这些数据上拟合一个模型来进行预测。现在我们将使用线性回归来完成这个目的：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also calculate the score associated with the model:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以计算与模型相关的分数：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This score is the mean square error and represents the accuracy of the model.
    It represents how well we can predict features from labels.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分数是均方误差，代表了模型的准确性。它表示我们能够从标签中预测特征的好坏程度。
- en: This number indicates a very bad model. The best possible score is 1.0\. A score
    of 0.0 can be achieved if we constantly predict the labels by ignoring the features.
    We will omit the mathematical background of this score in this book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字表示一个非常差的模型。最佳可能的分数是1.0。如果我们始终通过忽略特征来预测标签，我们可以达到0.0的分数。在这本书中，我们将省略这个分数的数学背景。
- en: 'Our model does not perform well for two reasons:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型表现不佳有两个原因：
- en: 11 training data and 2 testing data are simply not enough to perform proper
    predictive analysis.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11个训练数据和2个测试数据对于进行适当的预测分析来说远远不够。
- en: Even if we ignore the number of points, the Fibonacci `x -> y` function does
    not describe a linear relationship between x and y. Approximating a non-linear
    function with a line is only useful if we are very close to the training interval.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使忽略点的数量，斐波那契`x -> y`函数也不描述x和y之间的线性关系。用线来近似非线性函数只有在非常接近训练区间时才有用。
- en: We will see a lot of more accurate models in the future, and we may even reach
    model scores of 0.9.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们将看到更多更准确的模型，甚至可能达到0.9的模型分数。
- en: Linear Regression Using NumPy Arrays
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用NumPy数组进行线性回归
- en: One reason why NumPy arrays are handier than Python lists is that they can be
    treated as vectors. There are a few operations defined on vectors that can simplify
    our calculations. We can perform operations on vectors of similar lengths. The
    sum and the (vectorial) product of two vectors equals a vector, where each coordinate
    is the sum or (vectorial) product of the corresponding coordinates.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组比Python列表更方便的一个原因是它们可以被当作向量来处理。有一些定义在向量上的操作可以简化我们的计算。我们可以对长度相似的向量执行操作。两个向量的和以及它们的（向量）积等于一个向量，其中每个坐标是相应坐标的和或（向量）积。
- en: 'For example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The product of a vector and a scalar is a vector, where each coordinate is
    multiplied by the scalar:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 向量与标量的乘积是一个向量，其中每个坐标都乘以标量：
- en: '`v1 * 2 # array([2, 4, 6])`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 * 2 # array([2, 4, 6])`'
- en: 'The second power of a vector equals the vectorial product of the vector with
    itself. The double asterisk denotes the power operator:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的平方等于向量与自身的向量积。双星号表示幂运算符：
- en: '`v1 ** 2 # array([1, 4, 9], dtype=int32)`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 ** 2 # array([1, 4, 9], dtype=int32)`'
- en: Suppose we have a set of points in the plane. Our job is to find the best fit
    line.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在平面上有一组点。我们的任务是找到最佳拟合线。
- en: Let's see two examples.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个示例。
- en: 'Our first example contains 13 values that seem linear in nature. We are plotting
    the following data:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例包含13个看似线性的值。我们正在绘制以下数据：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you wanted to draw a line that is the closest to these dots, your educated
    guess would be quite close to reality:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要绘制一条最接近这些点的线，你的合理猜测将非常接近现实：
- en: '![](img/Image00023.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00023.jpg)'
- en: 'Figure 3.4: Plotted graph of values [2, 8, 8, 18, 25, 21, 32, 44, 32, 48, 61,
    45, 62]'
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.4：值[2, 8, 8, 18, 25, 21, 32, 44, 32, 48, 61, 45, 62]的绘制图表
- en: 'Our second example is the first 13 values of the Fibonacci sequence, after
    scaling. Although we can define a line that fits these points the closest, we
    can see from the distribution of the points that our model will not be too useful:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个示例是缩放后的斐波那契数列的前13个值。尽管我们可以定义一条最接近这些点的线，但我们从点的分布中可以看出，我们的模型不会很有用：
- en: '![](img/Image00024.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00024.jpg)'
- en: 'Figure 3.5: Plotted graph of Fibonacci values'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.5：斐波那契值的绘制图表
- en: 'We have already learned what the equation of a straight line is: `y = a * x
    + b`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学过了直线的方程：`y = a * x + b`
- en: In this equation, `a` is the slope, and `b` is the `y` -intercept. To find the
    line of best fit, we have to find the co-efficients `a` and `b` .
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，`a` 是斜率，`b` 是 `y` 轴截距。为了找到最佳拟合线，我们必须找到系数 `a` 和 `b` 。
- en: Our job is to minimize the sum of distances from the line of best fit.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是使最佳拟合线到各点的距离之和最小化。
- en: In this book, we will save the thought process behind calculating the coefficients
    `a` and `b` , because you will find little practical use for it. We would rather
    utilize the mean as the arithmetic mean of the values in a list. We can use the
    mean function provided by NumPy for this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将保存计算系数 `a` 和 `b` 的思维过程，因为你会发现它几乎没有实际用途。我们更愿意使用列表中值的算术平均值作为均值。我们可以使用NumPy提供的均值函数来完成这个任务。
- en: 'Let''s find the line of best fit for these two examples:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到这两个示例的最佳拟合线：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we plot the line y = a*x + b with the preceding coefficients, we get the
    following graph:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用前面的系数绘制出线 y = a*x + b，我们得到以下图表：
- en: '![](img/Image00025.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00025.jpg)'
- en: 'Figure 3.6: Plotted graph of array values [2, 8, 8, 18, 25, 21, 32, 44, 32,
    48, 61, 45, 62] and the line y=a*x+b'
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.6：绘制图表显示数组值[2, 8, 8, 18, 25, 21, 32, 44, 32, 48, 61, 45, 62]和线y=a*x+b
- en: Note
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a linear regression calculator at [http://www.endmemo.com/statistics/lr.php](http://www.endmemo.com/statistics/lr.php)
    . You can also check the calculator to get an idea of what lines of best fit look
    like on a given dataset.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://www.endmemo.com/statistics/lr.php](http://www.endmemo.com/statistics/lr.php)找到一个线性回归计算器。你还可以检查计算器，以了解给定数据集上的最佳拟合线看起来像什么。
- en: 'Regarding the scaled Fibonacci values, the line of best fit looks as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于缩放后的斐波那契值，最佳拟合线看起来如下：
- en: '![](img/Image00026.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00026.jpg)'
- en: 'Figure 3.7: Plotted graph showing Fibonacci values and the line y=a*x+b'
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.7：绘制图表显示斐波那契值和线y=a*x+b
- en: The best fit line of the second dataset clearly appears more off from anywhere
    outside the trained interval.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数据集的最佳拟合线显然比训练区间外的任何地方都要偏离。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We don't have to use this method to perform linear regression. Many libraries,
    including scikit-learn, will help us automatize this process. Once we perform
    linear regression with multiple variables, we are better off using a library to
    perform regression for us.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必使用这种方法来进行线性回归。包括 scikit-learn 在内的许多库将帮助我们自动化这个过程。一旦我们进行了多元线性回归，我们最好使用库来为我们执行回归。
- en: Fitting a Model Using NumPy Polyfit
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NumPy Polyfit 拟合模型
- en: NumPy Polyfit can also be used to create a line of best fit for linear regression
    with one variable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy Polyfit 也可以用于创建一元线性回归的最佳拟合线。
- en: 'Recall the calculation for the line of best fit:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下最佳拟合线的计算：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The equation for finding the coefficients a and b is quite long. Fortunately,
    `numpy.polyfit` performs these calculations to find the coefficients of the line
    of best fit. The `polyfit` function accepts three arguments: the array of `x`
    values, the array of `y` values, and the degree of polynomial to look for. As
    we are looking for a straight line, the highest power of `x` is 1 in the polynomial:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 找到系数 a 和 b 的方程相当长。幸运的是，`numpy.polyfit` 执行这些计算以找到最佳拟合线的系数。`polyfit` 函数接受三个参数：`x`
    值的数组，`y` 值的数组，以及要查找的多项式度数。由于我们正在寻找一条直线，多项式中 `x` 的最高次幂是 1：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Plotting the Results in Python
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中绘制结果
- en: Suppose you have a set of data points and a regression line. Our task is to
    plot the points and the line together so that we can see the results with our
    own eyes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一组数据点和一条回归线。我们的任务是绘制点和线，以便我们可以用我们的眼睛看到结果。
- en: 'We will use the `matplotlib.pyplot` library for this. This library has two
    important functions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `matplotlib.pyplot` 库来完成这个任务。这个库有两个重要的函数：
- en: '**Scatter:** This displays scattered points on the plane, defined by a list
    of x coordinates and a list of y coordinates.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**散点图：** 这个函数在平面上显示散点，由一系列 x 坐标和一系列 y 坐标定义。'
- en: '**Plot:** Along with two arguments, this function plots a segment defined by
    two points, or a sequence of segments defined by multiple points. Plot is like
    scatter, except that instead of displaying the points, they are connected by lines.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘图：** 除了两个参数外，这个函数绘制由两个点定义的段，或者由多个点定义的段序列。绘图类似于散点图，除了点不是显示出来，而是通过线连接。'
- en: A plot with three arguments plots a segment and/or two points formatted according
    to the third argument
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有三个参数的绘图函数绘制一个段和/或两个点，格式根据第三个参数
- en: 'A segment is defined by two points. As `x` ranges between 1 and 14, it makes
    sense to display a segment between 0 and 15\. We must substitute the value of
    `x` in the equation `a*x+b` to get the corresponding `y` values:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个段由两个点定义。当 `x` 在 1 和 14 之间变化时，显示 0 和 15 之间的段是有意义的。我们必须将 `x` 的值代入方程 `a*x+b`
    中，以得到相应的 `y` 值：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00027.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00027.jpg)'
- en: 'Figure 3.8: Graph displaying how data points fit a regression line'
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.8：显示数据点如何拟合回归线的图形
- en: You might have to call `plot.show()` to display the preceding graph. In the
    IPython console, the coordinate system shows up automatically.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要调用 `plot.show()` 来显示前面的图形。在 IPython 控制台中，坐标系会自动显示。
- en: The segment and the scattered data points are displayed as expected.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 段和散点数据点按预期显示。
- en: 'Plot has an advanced signature. You can use one call of plot to draw scattered
    dots, lines, and any curves on this diagram. These variables are interpreted in
    groups of three:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Plot 有一个高级签名。你可以使用一个 plot 调用来在这个图表上绘制散点、线和任何曲线。这些变量被解释为三组：
- en: X values
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X 值
- en: Y values
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y 值
- en: Formatting options in the form of a string
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以字符串形式表示的格式选项
- en: 'Let''s create a function for deriving an array of approximated y values from
    an array of approximated x values:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，从近似 x 值的数组推导出近似 y 值的数组：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will use the `fit` function to plot values:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `fit` 函数来绘制值：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00028.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00028.jpg)'
- en: 'Figure 3.9: Graph for the plot function using the fit function'
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.9：使用 fit 函数的绘图函数的图形
- en: The Python plotter library offers a simple solution for most of your graphing
    problems. You can draw as many lines, dots, and curves as you want on this graph.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Python 绘图库为大多数图形问题提供了一个简单的解决方案。你可以在这张图上绘制尽可能多的线、点和曲线。
- en: Every third variable is responsible for formatting. The letter g stands for
    green, while the letter r stands for red. You could have used b for blue, y for
    yellow, and so on. In the absence of a color, each triple will be displayed using
    a different color. The o character symbolizes that we want to display a dot where
    each data point lies. Therefore, 'go' has nothing to do with movement – it requests
    the plotter to plot green dots. The '-' characters are responsible for displaying
    a dashed line. If you just use one minus, a straight line appears instead of the
    dashed line.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每第三个变量负责格式化。字母 g 代表绿色，而字母 r 代表红色。您可以使用 b 代表蓝色，y 代表黄色，等等。如果没有指定颜色，每个三元组将使用不同的颜色显示。字符
    o 表示我们希望在数据点所在的位置显示一个点。因此，'go' 与移动无关——它要求绘图器绘制绿色点。'-' 字符负责显示虚线。如果您只使用一个减号，则会出现直线而不是虚线。
- en: 'If we simplify this formatting, we can specify that we only want dots of an
    arbitrary color, and straight lines of another arbitrary color. By doing this,
    we can simply write the following plot call:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简化这种格式化，我们可以指定我们只想绘制任意颜色的点，以及另一种任意颜色的直线。通过这样做，我们可以简单地写出以下绘图调用：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00029.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00029.jpg)'
- en: 'Figure 3.10: Graph for plot function with dashed line'
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.10：带有虚线的 plot 函数图形
- en: 'When displaying curves, the plotter connects the dots with segments. Also,
    keep in mind that even a complex sequence of curves is an approximation that connects
    the dots. For instance, if you execute the code from [https://gist.github.com/traeblain/1487795](https://gist.github.com/traeblain/1487795)
    , you will recognize the segments of the batman function as connected lines:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示曲线时，绘图器使用线段连接点。同时，请注意，即使是复杂的曲线序列也只是连接点的近似。例如，如果您执行来自 [https://gist.github.com/traeblain/1487795](https://gist.github.com/traeblain/1487795)
    的代码，您将识别出 batman 函数的段是连接的线条：
- en: '![](img/Image00030.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00030.jpg)'
- en: 'Figure 3.11: Graph for the batman function'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.11：batman 函数的图形
- en: 'There is a wide variety of ways to plot curves. We have seen that the `polyfit`
    method of the NumPy library returns an array of coefficients to describe a linear
    equation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种绘制曲线的方法。我们已经看到，NumPy 库的 `polyfit` 方法返回一个系数数组来描述一个线性方程：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This array describes the equation `4.85714286 * x - 2.76923077` .
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组描述了方程 `4.85714286 * x - 2.76923077`。
- en: 'Suppose we now want to plot a curve, `y = -x**2 + 3*x - 2` . This quadratic
    equation is described by the coefficient array `[-1, 3, -2].` We could write our
    own function to calculate the y values belonging to x values. However, the NumPy
    library already has a feature to do this work for us: `np.poly1d` :'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在想要绘制一条曲线，`y = -x**2 + 3*x - 2`。这个二次方程由系数数组 `[-1, 3, -2]` 描述。我们可以编写自己的函数来计算属于
    x 值的 y 值。然而，NumPy 库已经有一个功能可以为我们完成这项工作：`np.poly1d`：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The f function that''s created by the poly1d call not only works with single
    values, but also with lists or NumPy arrays:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由 poly1d 调用创建的 f 函数不仅适用于单个值，还适用于列表或 NumPy 数组：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now use these values to plot a non-linear curve:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些值来绘制非线性曲线：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00031.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00031.jpg)'
- en: 'Figure 3.12: Graph for pyplot function'
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.12：pyplot 函数的图形
- en: Predicting Values with Linear Regression
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用线性回归预测值
- en: 'Suppose we are interested in the `y` value belonging to the `x` coordinate
    `20` . Based on the linear regression model, all we need to do is substitute the
    value of `20` in the place of `x` :'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们感兴趣的是 `x` 坐标 `20` 对应的 `y` 值。根据线性回归模型，我们只需要将 `20` 的值替换到 `x` 的位置：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00032.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00032.jpg)'
- en: 'Figure 3.13: Graph showing the predicted value using Linear Regression'
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.13：使用线性回归显示预测值的图形
- en: Here, we denoted the predicted value with red. This red point is on the best
    fit line.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用红色表示预测值。这个红色点位于最佳拟合线上。
- en: 'Activity 5: Predicting Population'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 5：预测人口
- en: 'You are working at the government office of Metropolis, trying to forecast
    the need for elementary school capacity. Your task is to figure out a 2025 and
    2030 prediction for the number of children starting elementary school. The past
    data is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在 Metropolis 政府办公室工作，试图预测小学容量需求。您的任务是确定 2025 年和 2030 年开始上小学的儿童数量预测。过去的数据如下：
- en: '![](img/Image00033.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00033.jpg)'
- en: 'Figure 3.14: A table representing number of kids starting elementary school
    from 2001 to 2018'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.14：表示 2001 年至 2018 年开始上小学的儿童数量的表格
- en: 'Plot these tendencies on a two-dimensional chart. To do this, you must:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维图表上绘制这些趋势。为此，你必须：
- en: Use linear regression. Features are the years ranging from 2001 to 2018\. For
    simplicity, we can indicate 2001 as year 1, and 2018 as year 18.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用线性回归。特征是从2001年到2018年的年份。为了简化，我们可以将2001年表示为第1年，2018年表示为第18年。
- en: Use `np.polyfit` to determine the coefficients of the regression line.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.polyfit` 确定回归线的系数。
- en: Plot the results using `matplotlib.pyplot` to determine future tendencies.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `matplotlib.pyplot` 绘制结果以确定未来的趋势。
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity is available at page 269.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在第269页找到。
- en: Linear Regression with Multiple Variables
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多变量线性回归
- en: In the previous topic, we dealt with linear regression with one variable. Now
    we will learn an extended version of linear regression, where we will use multiple
    input variables to predict the output.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个主题中，我们处理了一元线性回归。现在我们将学习线性回归的扩展版本，我们将使用多个输入变量来预测输出。
- en: We will rely on examples where we will load and predict stock prices. Therefore,
    we will experiment with the main libraries used for loading stock prices.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依靠加载和预测股票价格的例子。因此，我们将实验用于加载股票价格的主要库。
- en: Multiple Linear Regression
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多元线性回归
- en: If you recall the formula for the line of best fit in linear regression, it
    was defined as `y = a*x + b` , where `a` is the slope of the line, `b` is the
    y-intercept of the line, `x` is the feature value, and `y` is the calculated label
    value.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得线性回归中最佳拟合线的公式，它被定义为 `y = a*x + b`，其中 `a` 是线的斜率，`b` 是线的y截距，`x` 是特征值，`y`
    是计算出的标签值。
- en: 'In multiple regression, we have multiple features and one label. Assuming that
    we have three features, `x1` , `x2` , and `x3` , our model changes as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在多元回归中，我们有多个特征和一个标签。假设我们有三个特征，`x1`、`x2` 和 `x3`，我们的模型将如下变化：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In NumPy array format, we can write this equation as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy数组格式中，我们可以将此方程写成以下形式：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For convenience, it makes sense to define the whole equation in a vector multiplication
    form. The coefficient of `b` is going to be `1` :'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，将整个方程定义为向量乘积形式是有意义的。`b` 的系数将是 `1`：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Multiple linear regression is a simple scalar product of two vectors, where
    the coefficients `b` , `a1` , `a2` , and `a3` determine the best fit equation
    in four-dimensional space.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 多元线性回归是两个向量之间的简单标量积，其中系数 `b`、`a1`、`a2` 和 `a3` 决定了四维空间中的最佳拟合方程。
- en: 'To understand the formula of multiple linear regression, you will need the
    scalar product of two vectors. As the other name for a scalar product is dot product,
    the NumPy function performing this operation is called dot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解多元线性回归的公式，你需要两个向量的标量积。由于标量积的另一个名称是点积，执行此操作的NumPy函数被称为dot：
- en: '`import numpy as np`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`import numpy as np`'
- en: '`v1 = [1, 2, 3]`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = [1, 2, 3]`'
- en: '`v2 = [4, 5, 6]`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`v2 = [4, 5, 6]`'
- en: '`np.dot( v1, v2 ) = 1 * 4 + 2 * 5 + 3 * 6 = 32`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.dot( v1, v2 ) = 1 * 4 + 2 * 5 + 3 * 6 = 32`'
- en: We simply sum the product of each respective coordinate.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将每个相应坐标的乘积相加。
- en: We can determine these coefficients by minimizing the error between data points
    and the nearest points described by the equation. For simplicity, we will omit
    the mathematical solution of the best fit equation, and use scikit-learn instead.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过最小化数据点与方程描述的最近点之间的误差来确定这些系数。为了简化，我们将省略最佳拟合方程的数学解，并使用scikit-learn。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In n-dimensional spaces, where n is greater than 3, the number of dimensions
    determines the different variables that are in our model. In the preceding example,
    we have three features and one label. This yields four dimensions. If you want
    to imagine a four-dimensional space, you can imagine three-dimensional space and
    time for simplification. A five-dimensional space can be imagined as a four-dimensional
    space, where each point in time has a temperature. Dimensions are just features
    (and labels); they do not necessarily correlate with our concept of three-dimensional
    space.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在n维空间中，其中n大于3，维数的数量决定了我们模型中的不同变量。在前面的例子中，我们有三个特征和一个标签。这产生了四个维度。如果你想想象四维空间，你可以想象三维空间和时间来简化。五维空间可以想象为四维空间，其中每个时间点都有一个温度。维度只是特征（和标签）；它们不一定与我们三维空间的概念相关。
- en: The Process of Linear Regression
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性回归的过程
- en: 'We will follow the following simple steps to solve Linear Regression problems:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循以下简单步骤来解决线性回归问题：
- en: Load data from data sources.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据源加载数据。
- en: Prepare data for prediction (normalize, format, filter).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备预测数据（归一化、格式化、过滤）。
- en: Compute the parameters of the regression line. Regardless of whether we use
    linear regression with one variable or with multiple variables, we will follow
    these steps.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算回归线的参数。无论我们使用单变量线性回归还是多变量线性回归，我们都会遵循以下步骤。
- en: Importing Data from Data Sources
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数据源导入数据
- en: 'There are multiple libraries that can provide us with access to data sources.
    As we will be working with stock data, let''s cover two examples that are geared
    toward retrieving financial data, Quandl and Yahoo Finance:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个库可以为我们提供访问数据源的方法。由于我们将处理股票数据，让我们看看两个针对检索金融数据的示例，Quandl和Yahoo Finance：
- en: scikit-learn comes with a few datasets that can be used for practicing your
    skills.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scikit-learn 包含一些数据集，可用于练习您的技能。
- en: '[Quandl.com](http://Quandl.com) provides you with free and paid financial datasets.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Quandl.com](http://Quandl.com) 提供免费和付费的金融数据集。'
- en: '[pandas.io](http://pandas.io) helps you load any .csv, .excel, .json, or SQL
    data.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pandas.io](http://pandas.io) 帮助您加载任何 .csv、.excel、.json 或 SQL 数据。'
- en: Yahoo Finance provides you with financial datasets.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yahoo Finance 为您提供金融数据集。
- en: Loading Stock Prices with Yahoo Finance
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Yahoo Finance加载股票价格
- en: 'The process of loading stock data with Yahoo Finance is straightforward. All
    you need to do is install the fix_yahoo_finance package using the following command
    in the CLI::'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yahoo Finance加载股票数据的过程很简单。您只需要在CLI中使用以下命令安装fix_yahoo_finance包：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will download a dataset that has open, high, low, close, adjusted close,
    and volume values of the S&P 500 index, starting from 2015:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将下载一个包含从2015年开始的S&P 500指数的开盘价、最高价、最低价、收盘价、调整后的收盘价和交易量的数据集：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's all you need to do. The data frame containing the S&P 500 index is ready.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要做的。包含S&P 500指数的数据框已准备好。
- en: 'You can plot the index prices with the plot method:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用plot方法绘制指数价格：
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00034.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00034.jpg)'
- en: 'Figure 3.15: Graph showing stock prices for Yahoo Finance'
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.15：显示Yahoo Finance股票价格的图表
- en: 'It is also possible to save data to a CSV file using the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令将数据保存到CSV文件：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Loading Files with pandas
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用pandas加载文件
- en: 'Suppose a CSV file containing stock data is given. We will now use pandas to
    load data from this file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个包含股票数据的CSV文件。我们现在将使用pandas从该文件加载数据：
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To properly parse data, we must set the index column name, specify the absence
    of headers, and make sure that dates are parsed as dates.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确解析数据，我们必须设置索引列名称，指定没有标题，并确保日期被解析为日期。
- en: Loading Stock Prices with Quandl
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Quandl加载股票价格
- en: Quandl.com is a reliable source of financial and economic datasets.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Quandl.com 是金融和经济数据集的可靠来源。
- en: 'Exercise 8: Using Quandl to Load Stock Prices'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：使用Quandl加载股票价格
- en: 'Open the Anaconda prompt and install Quandl using the following command:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Anaconda提示符并使用以下命令安装Quandl：
- en: '[PRE30]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Go to [https://www.quandl.com/](https://www.quandl.com/) .
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://www.quandl.com/](https://www.quandl.com/)。
- en: Click on the Financial data.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“金融数据”。
- en: Among the filters, click the checkbox next to the **Free** label. If you have
    a Quandl subscription, you can use that to download stock data.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在过滤器中，点击**免费**标签旁边的复选框。如果您有Quandl订阅，您可以使用它下载股票数据。
- en: Select a stock or index you would like to use. For our example, we will use
    the S&P Composite index data that was collected by the Yale Department of Economics.
    The link for this is [https://www.quandl.com/data/YALE/SPCOMP-S-P-Composite](https://www.quandl.com/data/YALE/SPCOMP-S-P-Composite)
    .
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想使用的股票或指数。在我们的例子中，我们将使用耶鲁大学经济学系收集的S&P综合指数数据。此链接为 [https://www.quandl.com/data/YALE/SPCOMP-S-P-Composite](https://www.quandl.com/data/YALE/SPCOMP-S-P-Composite)。
- en: Find the Quandl ticker belonging to your instrument you would like to load.
    Our Quandl code for the S&P 500 data is "`YALE/SPCOMP` ".
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到您想加载的仪器的Quandl代码。我们用于S&P 500数据的Quandl代码是 "YALE/SPCOMP"。
- en: 'Load the data from the Jupyter QtConsole:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Jupyter QtConsole加载数据：
- en: '[PRE31]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'All the columns of the imported values are features:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有导入值的列都是特征：
- en: '[PRE32]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Preparing Data for Prediction
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备预测数据
- en: Before we perform regression, we must choose the features we are interested
    in, and we also have to figure out the data range on which we do the regression.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行回归之前，我们必须选择我们感兴趣的特征，并且我们还需要确定我们进行回归的数据范围。
- en: 'Preparing the data for prediction is the second step in the regression process.
    This step also has several sub-steps. We will go through these sub-steps in the
    following order:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 准备预测数据是回归过程的第二步。这一步也有几个子步骤。我们将在以下顺序中通过这些子步骤：
- en: Suppose a data frame is given with preloaded data.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设有一个包含预加载数据的数据帧。
- en: Select the columns from the dataset you are interested in.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你感兴趣的列。
- en: Replace NaN values with a numeric value to avoid getting rid of data.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用数值替换NaN值以避免删除数据。
- en: Determine the forecast interval T, determining the amount of time or number
    of data rows you wish to look into in the future.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定预测区间T，确定你希望在未来查看的时间长度或数据行数。
- en: Create a label column out of the value you wish to forecast. For row i of the
    data frame, the value of the label should belong to the time instant, i+T.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你希望预测的值创建一个标签列。对于数据帧的第i行，标签的值应该属于时间点i+T。
- en: For the last T rows, the label value is NaN. Drop these rows from the data frame.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后T行，标签值是NaN。从数据帧中删除这些行。
- en: Create NumPy arrays from the features and the label.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从特征和标签创建NumPy数组。
- en: Scale the features array.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩放特征数组。
- en: Separate the training and testing data.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将训练数据和测试数据分开。
- en: A few features highly correlate to each other. For instance, the Real Dividend
    column proportionally grows with Real Price. The ratio between them is not always
    similar, but they do correlate.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特征高度相关。例如，实际股息列与实际价格成比例增长。它们之间的比率并不总是相同的，但它们确实相关。
- en: As regression is not about detecting correlation between features, we would
    rather get rid of a few attributes we know are redundant and perform regression
    on the features that are non-correlated.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回归不是关于检测特征之间的相关性，我们宁愿去除一些已知的冗余属性，并在非相关特征上执行回归。
- en: 'If you have gone through the Loading stock prices with Quandl section, you
    already have a data frame containing historical data on the S&P 500 Index. We
    will keep the Long Interest Rate, Real Price, and Real Dividend columns:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了“使用Quandl加载股票价格”部分，你已经有了一个包含S&P 500指数历史数据的数据帧。我们将保留长期利率、实际价格和实际股息列：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you cannot work with NaN data, you can replace it by filling in numbers
    in place of NaNs. In general, you have two choices:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你不能处理NaN数据，你可以通过用数字替换NaN来替换它。通常，你有两种选择：
- en: Get rid of the data
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除数据
- en: Replace the data with a default value that makes sense
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用有意义的默认值替换数据
- en: '[PRE35]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can check the length of the data frame by using the `len` function, as shown
    in the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`len`函数检查数据帧的长度，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The length of our data frame is 1771.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据帧长度是1771。
- en: If we want to predict the Real Price for the upcoming 20 years, we will have
    to predict 240 values. This is approximately 15% of the length of the data frame,
    which makes perfect sense.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要预测未来20年的实际价格，我们将必须预测240个值。这大约是数据帧长度的15%，这是完全合理的。
- en: 'We will therefore create a Real Price Label by shifting the Real Price values
    up by 240 units:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将通过将实际价格值向上移动240个单位来创建一个实际价格标签：
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This way, each Real Price Label value will be the Real Price value in 20 years.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个实际价格标签值将是20年后的实际价格值。
- en: 'The side effect of shifting these values is that NaN values appear in the last
    240 values:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值移动的副作用是在最后240个值中出现NaN值：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can get rid of them by executing dropna on the data frame:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在数据帧上执行dropna来去除它们：
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This way, we have data up to 1998 July, and we have the future values up to
    2018 in the Real Price Label column:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有到了1998年7月的数据，并且在实际价格标签列中有未来值直到2018年：
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's prepare our features and labels for regression.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为回归准备我们的特征和标签。
- en: 'For the features, we will use the drop method of the data frame. The drop method
    returns a new data frame that doesn''t contain the column that was dropped:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特征，我们将使用数据帧的drop方法。drop方法返回一个新的数据帧，其中不包含被删除的列：
- en: '[PRE43]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The 1 in the second argument specifies that we are dropping columns. As the
    original data frame was not modified, the label can be directly extracted from
    it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数中的1指定了我们正在删除列。由于原始数据帧没有被修改，标签可以直接从中提取。
- en: 'It is now time to scale the features with the preprocessing module of Scikit
    Learn:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用Scikit Learn的预处理模块缩放特征了：
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, the scaled features are easier to read and interpret. While
    scaling data, we must scale all data together, including training and testing
    data.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，缩放后的特征更容易阅读和解释。在缩放数据时，我们必须一起缩放所有数据，包括训练数据和测试数据。
- en: Performing and Validating Linear Regression
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行和验证线性回归
- en: 'Now that scaling is done, our next task is to separate the training and testing
    data from each other. We will be using 90% of the data as training data, and the
    rest (10%) will be used as test data:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在缩放完成后，我们的下一个任务是分别将训练数据和测试数据分开。我们将使用90%的数据作为训练数据，其余的（10%）将用作测试数据：
- en: '[PRE45]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The train_test_split function shuffles the lines of our data, keeping the correspondence,
    and puts approximately 10% of all data in the test variables, keeping 90% for
    the training variables. This will help us evaluate how good our model is.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: train_test_split函数会打乱我们数据的行，保持对应关系，并将大约10%的所有数据放入测试变量中，保留90%用于训练变量。这将帮助我们评估我们的模型有多好。
- en: 'We can now create the linear regression model based on the training data:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以根据训练数据创建线性回归模型：
- en: '[PRE46]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once the model is ready, we can use it to predict the labels belonging to the
    test feature values:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型准备就绪，我们就可以用它来预测属于测试特征值的标签：
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you are interested in the relationship between the predicted feature values
    and the accurate test feature values, you can plot them using a Python two-dimensional
    graph plotter utility:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣的是预测特征值和准确测试特征值之间的关系，你可以使用Python二维图表绘制实用程序来绘制它们：
- en: '[PRE48]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This gives you an image of a graph where the test data is compared to the results
    of the prediction. The closer these values are to the `y = x` line, the better.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这给你一个图表的图像，其中测试数据与预测结果进行比较。这些值越接近`y = x`线，就越好。
- en: 'You can see from the following graph that the predictions do center around
    the `y=x` line with a degree of error. This error is obvious, as otherwise, we
    would be able to make a lot of money with such a simple prediction, and everyone
    would pursue predicting stock prices instead of working in their own field of
    expertise:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下图表中看到，预测确实围绕`y=x`线进行，存在一定的误差。这种误差很明显，否则我们就能用这样的简单预测赚很多钱，每个人都会追求预测股价而不是在自己的专业领域工作：
- en: '![](img/Image00035.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00035.jpg)'
- en: 'Figure 3.16: Graph for the plot scatter function'
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.16：散点图绘制函数的图表
- en: 'We can conclude that there is a degree of error in the model. The question
    is, how can we quantify this error? The answer is simple: we can score the model
    using a built-in utility that calculates the mean square error of the model:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，模型存在一定的误差。问题是，我们如何量化这个误差？答案是简单的：我们可以使用内置的实用程序对模型进行评分，该实用程序计算模型的均方误差：
- en: '[PRE49]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can conclude that the model is very accurate. This is not a surprise, because
    every single financial advisor scammer tends to tell us that the market grows
    at around 6-7% a year. This is a linear growth, and the model essentially predicts
    that the markets will continue growing at a linear rate. Making a conclusion that
    markets tend to go up in the long run is not rocket science.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，该模型非常准确。这并不令人惊讶，因为每个金融顾问骗子都倾向于告诉我们市场每年增长大约6-7%。这是一种线性增长，模型本质上预测市场将继续以线性速度增长。得出市场长期倾向于上涨的结论并不是什么科学。
- en: Predicting the Future
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预测未来
- en: We have already used prediction on test data. Now, it's time to use the actual
    data to see into the future.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了测试数据的预测。现在，是时候使用实际数据来看向未来了。
- en: '[PRE50]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The trick to predicting the future is that we have to save the values belonging
    to the values we dropped when building the model. We built our stock price model
    based on historical data from 20 years ago. Now, we have to keep this data, and
    we also have to include this data in scaling:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 预测未来的技巧是我们必须保存构建模型时丢弃的值的值。我们基于20年前的历史数据构建了股价模型。现在，我们必须保留这些数据，还必须在缩放时包含这些数据：
- en: '[PRE51]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we have access to the scaled values of the features from the last
    20 years, we can now predict the index prices of the next 20 years using the following
    code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问过去20年的特征值的缩放值，我们可以使用以下代码预测未来20年的指数价格：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This sounds great in theory, but in practice, using this model for making money
    by betting on the forecast is by no means better than gambling in a casino. This
    is just an example model to illustrate prediction; it is definitely not sufficient
    to be used for short-term or long-term speculation on market prices.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上听起来很棒，但在实践中，使用这个模型通过下注预测来赚钱，绝对不比在赌场赌博更好。这只是一个用于说明预测的示例模型；它绝对不足以用于对市场价格的短期或长期投机。
- en: If you look at the values, you can see why this prediction may easily backfire.
    First, there are a few negative values, which are impossible for indices. Then,
    due to a few major market crashes, linear regression made a doomsday forecast
    a point in the future, where the index will drop from more than 3,000 to literally
    zero within a year. Linear regression is not a perfect tool to look ahead 20 years
    based on limited data. Also, note that stock prices are meant to be close to time
    invariant systems. This means that the past does not imply any patterns in the
    future.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这些值，你可以看到为什么这个预测可能会轻易失败。首先，有几个负值，这对于指数来说是不可能的。然后，由于几次重大的市场崩盘，线性回归对未来某个时间点的末日预测进行了预测，其中指数将在一年内从超过3,000点降至零。线性回归并不是基于有限数据向前看20年的完美工具。此外，请注意，股价应接近时间不变系统。这意味着过去并不预示未来有任何模式。
- en: 'Let''s output the prediction belonging to the first ten years:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输出属于前十年的预测：
- en: '[PRE53]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00036.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00036.jpg)'
- en: 'Figure 3.17: Graph for the plot function with a range of 1 to 241 and the label
    predicted as 240'
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.17：范围在1到241之间的绘图函数的图表，预测标签为240
- en: 'The graph is hard to read near the end due to extreme values. Let''s draw our
    conclusions by omitting the last five years and just plotting the first 180 months
    out of the predictions:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于极端值，图表在末尾难以阅读。让我们通过省略最后五年，只绘制预测中的前180个月来得出结论：
- en: '[PRE54]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00037.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00037.jpg)'
- en: 'Figure 3.18: Graph for the plot function with a range of 1 to 181 and the label
    predicted as 180'
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.18：范围在1到181之间的绘图函数的图表，预测标签为180
- en: This is a scary future for the American economy. According to this model, the
    S&P 500 has a bull run for about 2.5-3 years and doesn't recover for a long time.
    Also, notice that our model does not know that index values cannot be negative.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这对美国经济来说是一个令人恐惧的未来。根据这个模型，标普500指数将经历大约2.5-3年的牛市，并且很长时间内无法恢复。此外，请注意，我们的模型并不知道指数值不能为负。
- en: Polynomial and Support Vector Regression
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式和支持向量回归
- en: When performing polynomial regression, the relationship between x and y, or
    using their other names, features and labels, is not a linear equation, but a
    polynomial equation. This means that instead of the `y = a*x+b` equation, we can
    have multiple coefficients and multiple powers of x in the equation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行多项式回归时，x和y之间的关系，或者使用它们的其它名称，特征和标签，不是一个线性方程，而是一个多项式方程。这意味着我们可以在方程中有多多个系数和多个x的幂。
- en: To make matters even more complicated, we can perform polynomial regression
    using multiple variables, where each feature may have coefficients multiplying
    different powers of the feature.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要使事情更加复杂，我们可以使用多个变量进行多项式回归，其中每个特征可能乘以不同幂的特征系数。
- en: Our task is to find a curve that best fits our dataset. Once polynomial regression
    is extended to multiple variables, we will learn the Support Vector Machines model
    to perform polynomial regression.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是找到一个最适合我们的数据集的曲线。一旦多项式回归扩展到多个变量，我们将学习支持向量机模型来进行多项式回归。
- en: Polynomial Regression with One Variable
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单变量多项式回归
- en: 'As a recap, we have performed two types of regression so far:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回顾，我们迄今为止已经执行了两种回归：
- en: 'Simple linear regression: `y = a*x + b`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单线性回归：`y = a*x + b`
- en: 'Multiple linear regression: `y = b + a1 * x1 + a2 * x2 + … + an * xn`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多元线性回归：`y = b + a1 * x1 + a2 * x2 + … + an * xn`
- en: 'We will now learn how to do polynomial linear regression with one variable.
    The equation for polynomial linear regression is as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何使用一个变量进行多项式线性回归。多项式线性回归的方程如下：
- en: '`y = b + a1*x + a2*(x ** 2) + a3*(x ** 3) + … + an * (x ** n)`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`y = b + a1*x + a2*(x ** 2) + a3*(x ** 3) + … + an * (x ** n)`'
- en: have a vector of coefficients `(b, a1, a2, …, an)` multiplying a vector of degrees
    of x in the polynomial, `(1, x**1, x**2, …, x**n)` .
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个系数向量`(b, a1, a2, …, an)`乘以多项式中x的度数向量`(1, x**1, x**2, …, x**n)`。
- en: At times, polynomial regression works better than linear regression. If the
    relationship between labels and features can be described using a linear equation,
    then using linear equation makes perfect sense. If we have a non-linear growth,
    polynomial regression tends to approximate the relationship between features and
    labels better.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，多项式回归比线性回归效果更好。如果标签和特征之间的关系可以用线性方程描述，那么使用线性方程是完美的。如果我们有一个非线性增长，多项式回归往往能更好地近似特征和标签之间的关系。
- en: The simplest implementation of linear regression with one variable was the `polyfit`
    method of the NumPy library. In the next exercise, we will perform multiple polynomial
    linear regression with degrees of 2 and 3.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归的单变量最简单实现是NumPy库中的`polyfit`方法。在下一个练习中，我们将执行二阶和三阶的多项式线性回归。
- en: Note
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Even though our polynomial regression has an equation containing coefficients
    of x ** n, this equation is still referred to as polynomial linear regression
    in the literature. Regression is made linear not because we restrict the usage
    of higher powers of x in the equation, but because the coefficients a1, a2, …,
    and so on are linear in the equation. This means that we use the toolset of linear
    algebra, and work with matrices and vectors to find the missing coefficients that
    minimize the error of the approximation.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的多项式回归有一个包含x的n次方系数的方程，但这个方程在文献中仍被称为多项式线性回归。回归之所以是线性的，并不是因为我们限制了方程中x的高次幂的使用，而是因为系数a1、a2、……等等在方程中是线性的。这意味着我们使用线性代数的工具集，与矩阵和向量一起工作，以找到最小化近似误差的缺失系数。
- en: 'Exercise 9: 1st, 2nd, and 3rd Degree Polynomial Regression'
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：一阶、二阶和三阶多项式回归
- en: 'Perform a 1st, 2nd, and 3rd degree polynomial regression on the following two
    datasets:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下两个数据集上执行一阶、二阶和三阶多项式回归：
- en: '[PRE55]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then plot your results on the graph:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在图表上绘制你的结果：
- en: 'Let''s start with plotting the first example:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从绘制第一个例子开始：
- en: '[PRE56]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output is as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/Image00038.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00038.jpg)'
- en: 'Figure 3.19: Graph showing the first dataset with linear curves'
  id: totrans-376
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.19：显示第一个数据集的线性曲线
- en: As the coefficients are enumerated from left to right in order of decreasing
    degree, we can see that the higher degree coefficients stay close to negligible.
    In other words, the three curves are almost on top of each other, and we can only
    detect a divergence near the right edge. This is because we are working on a dataset
    that can be very well approximated with a linear model.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系数是按照降序排列的，我们可以看到高阶系数接近于可忽略不计。换句话说，这三条曲线几乎重叠在一起，我们只能在右边缘附近检测到偏差。这是因为我们正在处理一个可以用线性模型很好地近似的数据集。
- en: In fact, the first dataset was created out of a linear function. Any nonzero
    coefficients for x**2 and x**3 are the results of overfitting the model based
    on the available data. The linear model is better for predicting values outside
    the range of the training data than any higher degree polynomial.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，第一个数据集是由一个线性函数创建的。对于x的平方和x的三次方，任何非零系数都是基于可用数据过度拟合模型的结果。与任何更高阶的多项式相比，线性模型更适合预测训练数据范围之外的价值。
- en: 'Let''s contrast this behavior with the second example. We know that the Fibonacci
    sequence is non-linear. So, using a linear equation to approximate it is a clear
    case for underfitting. Here, we expect a higher degree polynomic to perform better:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对比第二个例子中的这种行为。我们知道斐波那契序列是非线性的。因此，使用线性方程来近似它是一个明显的欠拟合案例。在这里，我们期望更高阶的多项式表现更好：
- en: '[PRE57]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 3.19: Graph showing second dataset points and three polynomial curves
    ](img/Image00039.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19：显示第二个数据集点和三个多项式曲线的图表](img/Image00039.jpg)'
- en: 'Figure 3.20: Graph showing second dataset points and three polynomial curves'
  id: totrans-383
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.20：显示第二个数据集点和三个多项式曲线的图表
- en: The difference is clear. The quadratic curve fits the points a lot better than
    the linear one. The cubic curve is even better.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 差异很明显。二次曲线比线性曲线更好地拟合点。三次曲线甚至更好。
- en: If you research Binet's formula, you will find out that the Fibonacci function
    is an exponential function, as the xth Fibonacci number is calculated as the xth
    power of a constant. Therefore, the higher degree polynomial we use, the more
    accurate our approximation will be.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究比奈公式，你会发现斐波那契函数是一个指数函数，因为第x个斐波那契数是计算为常数的第x次幂。因此，我们使用的高阶多项式越高，我们的近似就越准确。
- en: Polynomial Regression with Multiple Variables
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多变量多项式回归
- en: 'When we have one variable of degree n, we have n+1 coefficients in the equation:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个n次方变量时，方程中有n+1个系数：
- en: '[PRE58]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Once we deal with multiple features x1, x2, …, xm, and their powers of up to
    the nth degree, we get an m * (n+1) matrix of coefficients. The math will become
    quite lengthy once we start exploring the details and prove how a polynomial model
    works. We will also lose the nice visualizations of two-dimensional curves.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理了多个特征x1, x2, …, xm及其最高n次方，我们就会得到一个m * (n+1)的系数矩阵。一旦我们开始探索细节并证明多项式模型是如何工作的，数学就会变得相当冗长。我们也会失去二维曲线的优美可视化。
- en: Therefore, we will apply the chapters learned in previous section on polynomial
    regression with one variable and omit the math. When training and testing a Linear
    Regression model, we can calculate the mean square error to see how good an approximation
    a model is.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将应用之前章节中学到的关于一元多项式回归的知识，并省略数学推导。在训练和测试线性回归模型时，我们可以计算均方误差来查看模型近似的好坏。
- en: In scikit-learn, the degree of the polynomials used in the approximation is
    a simple parameter in the model.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在scikit-learn中，用于近似的多项式的度数是模型中的一个简单参数。
- en: As polynomial regression is a form of linear regression, we can perform polynomial
    regression without changing the regression model. All we need to do is transform
    the input and keep the linear regression model.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多项式回归是线性回归的一种形式，我们可以在不改变回归模型的情况下执行多项式回归。我们所需做的只是转换输入并保持线性回归模型。
- en: 'The transformation of the input is performed by the `fit_transform` method
    of the `PolynomialFeatures` package:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的转换是通过`PolynomialFeatures`包的`fit_transform`方法完成的：
- en: '[PRE59]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The model scores too well. Chances are, the polynomial model is overfitting
    the dataset.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 模型得分过高。很可能，多项式模型对数据集进行了过拟合。
- en: There is another model in scikit-learn that performs polynomial regression called
    the SVM model, which stands for Support Vector Machines.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn中还有一个执行多项式回归的模型，称为SVM模型，代表支持向量机。
- en: Support Vector Regression
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持向量回归
- en: Support Vector Machines are binary classifiers defined on a vector space. Vector
    Machines divide the state space with a surface. An SVM classifier takes classified
    data and tries to predict where unclassified data belongs. Once the classification
    of a data point is determined, it gets labeled.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 支持向量机是在向量空间上定义的二分类器。向量机通过一个表面来划分状态空间。支持向量机分类器接收已分类的数据，并尝试预测未分类数据所属的位置。一旦确定数据点的分类，它就会被标记。
- en: Support Vector Machines can also be used for regression. Instead of labeling
    data, we can predict future values in a series. The Support Vector Regression
    model uses the space between our data as a margin of error. Based on the margin
    of error, it makes predictions regarding future values.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 支持向量机也可以用于回归。我们不是对数据进行标记，而是可以预测序列中的未来值。支持向量回归模型使用数据之间的空间作为误差范围。基于误差范围，它对未来值做出预测。
- en: If the margin of error is too small, we risk overfitting the existing dataset.
    If the margin of error is too big, we risk underfitting the existing dataset.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果误差范围太小，我们可能会对现有数据集进行过拟合。如果误差范围太大，我们可能会对现有数据集进行欠拟合。
- en: A kernel describes the surface dividing the state space in the case of a classifier.
    A kernel is also used to measure the margin of error in the case of a regressor.
    This kernel can use a linear model, a polynomial model, or many other possible
    models. The default kernel is **RBF** , which stands for **Radial Basis Function**
    .
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 核函数描述了在分类器情况下划分状态空间的表面。核函数也用于测量回归器中的误差范围。这个核可以使用线性模型、多项式模型或许多其他可能的模型。默认核是**RBF**，代表**径向基函数**。
- en: Support Vector Regression is an advanced topic, which is outside the scope of
    this book. Therefore, we will only stick to a walkthrough of how easy it is to
    try out another regression model on our test data.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 支持向量回归是一个高级主题，超出了本书的范围。因此，我们只将介绍如何在测试数据上尝试另一个回归模型的过程。
- en: 'Suppose we have our features and labels in two separate NumPy arrays. Let''s
    recall how we performed linear regression on them:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的特征和标签分别存储在两个NumPy数组中。让我们回顾一下我们是如何对它们执行线性回归的：
- en: '[PRE61]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can perform regression with Support Vector Machines by changing the linear
    model to a support vector model:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将线性模型更改为支持向量模型来使用支持向量机进行回归：
- en: '[PRE62]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00040.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00040.jpg)'
- en: 'Figure 3.21: Graph showing Support Vector regression with a linear model'
  id: totrans-410
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.21：显示使用线性模型的支持向量回归的图表
- en: 'The output is as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE63]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The model score is quite low, and the points don't align on the `y=x` line.
    Prediction with the default values is quite low.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 模型得分相当低，点没有对齐在`y=x`线上。使用默认值进行预测相当低。
- en: 'The output of the model describes the parameters of the Support Vector Machine:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的输出描述了支持向量机的参数：
- en: '[PRE64]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We could fiddle with these parameters to increase the accuracy of the prediction
    by creating a better algorithm.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调整这些参数来通过创建更好的算法来提高预测的准确性。
- en: Support Vector Machines with a 3 Degree Polynomial Kernel
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三次多项式核的支持向量机
- en: 'Let''s switch the kernel of the Support Vector Machine to poly. The default
    degree of the polynomial is 3:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将支持向量机的核切换到poly。多项式的默认次数为3：
- en: '[PRE65]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output is as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image00041.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image00041.jpg)'
- en: 'Figure 3.22: Graph showing Support Vector regression with a polynomial kernel
    of degree 3'
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.22：显示使用三次多项式核的支持向量回归的图表
- en: '[PRE66]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With Support Vector Machines, we often end up with points concentrated in small
    areas. We could change the margin of error to separate the points a bit more.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用支持向量机时，我们经常发现点集中在小区域内。我们可以改变误差范围以使点分离得更开一些。
- en: 'Activity 6: Stock Price Prediction with Quadratic and Cubic Linear Polynomial
    Regression with Multiple Variables'
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动6：使用多变量二次和三次线性多项式回归预测股价
- en: In this section, we will discuss how to perform linear, polynomial, and support
    vector regression with scikit-learn. We will also learn how to find the best fit
    model for a given task. We will be assuming that you are a software engineer at
    a financial institution and your employer wants to know whether linear regression
    or support vector regression is a better fit for predicting stock prices. You
    will have to load all of the data of the S&P 500 from a data source. Then, you
    will need to build a regressor using linear regression, cubic polynomial linear
    regression, and a support vector regression with a polynomial kernel of degree
    3 before separating the training and test data. Plot the test labels and the prediction
    results and compare them with the y=x line. Finally, compare how well the three
    models score.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用scikit-learn执行线性、多项式和支持向量回归。我们还将学习如何为给定任务找到最佳拟合模型。我们将假设你是金融机构的一名软件工程师，你的雇主想知道线性回归或支持向量回归哪个更适合预测股价。你需要从数据源加载S&P
    500的所有数据。然后，你需要使用线性回归、三次多项式线性回归和三次多项式核的支持向量回归构建回归器，在分离训练数据和测试数据之前。绘制测试标签和预测结果，并与y=x线进行比较。最后，比较三个模型的得分情况。
- en: Load the S&P 500 index data using Quandl, and then prepare the data for prediction.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Quandl加载S&P 500指数数据，然后准备数据以进行预测。
- en: Use a polynomial of degree 1 for the evaluation of the model and for the prediction.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一次多项式对模型进行评估和预测。
- en: The closer the dots are to the y=x line, the less error the model works with.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点越接近y=x线，模型的误差就越小。
- en: Perform a linear multiple regression with quadratic polynomials. The only change
    is in the Linear Regression model.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用二次多项式进行线性多重回归。唯一的变化是在线性回归模型中。
- en: Perform Support Vector regression with a polynomial kernel of degree 3.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三次多项式核进行支持向量回归。
- en: The model does not look efficient at all. For some reason, this model clearly
    prefers lower values for the S&P 500 that are completely unrealistic, assuming
    that the stock market does not lose 80% of its value within a day.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型看起来完全不高效。由于某种原因，这个模型明显更偏好S&P 500的较低值，这在假设股市一天内不会损失80%的价值的情况下是完全不切实际的。
- en: Note
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity is available at page 271.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第271页找到。
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned the fundamentals of Linear Regression.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了线性回归的基础知识。
- en: After going through some basic mathematics, we dived into the mathematics of
    linear regression using one variable and multiple variables.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了一些基本数学知识后，我们通过一个变量和多个变量深入研究了线性回归的数学。
- en: Challenges occurring with regression include loading data from external sources
    such as a .csv file, Yahoo Finance, or Quandl were dealt with. After loading the
    data, we learned how to identify the features and labels, how to scale data, and
    how to format data to perform regression.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在回归中遇到的问题包括从外部源（如.csv文件、Yahoo Finance或Quandl）加载数据，这些问题已经得到解决。加载数据后，我们学习了如何识别特征和标签，如何缩放数据以及如何格式化数据以进行回归。
- en: We learned how to train and test a linear regression engine, and how to predict
    the future. Our results were visualized by an easy-to-use Python graph plotting
    library called `pyplot` .
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何训练和测试线性回归引擎，以及如何预测未来。我们的结果通过一个易于使用的Python图形绘图库`pyplot`进行可视化。
- en: A more complex form of linear regression is a linear polynomial regression of
    arbitrary degree. We learned how to define these regression problems on multiple
    variables. We compared their performance to each other on stock price prediction
    problems. As an alternative to polynomial regression, we also introduced Support
    Vector Machines as a regression model and experimented with two kernels.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归的一种更复杂的形式是任意度数的线性多项式回归。我们学习了如何在多个变量上定义这些回归问题。我们比较了它们在股票价格预测问题上的性能。作为多项式回归的替代，我们还介绍了支持向量机作为回归模型，并实验了两种核函数。
- en: You will soon learn about another field inside machine learning. The setup and
    code structure of this machine learning method will be very similar to regression,
    while the problem domain is somewhat different. In the next chapter, you will
    learn the ins and outs of classification.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会了解机器学习领域内的另一个分支。这种机器学习方法的设置和代码结构将与回归非常相似，而问题域则有所不同。在下一章中，你将学习分类的方方面面。
