- en: 'Chapter 10: Novel Trends on Graphs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we described different supervised and unsupervised
    algorithms that can be used in a wide range of problems concerning graph data
    structures. However, the scientific literature on graph machine learning is vast
    and constantly evolving and every month, new algorithms are published. In this
    chapter, we will provide a high-level description of some new techniques and applications
    concerning graph machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be divided into two main parts – advanced algorithms and applications.
    The first part is mainly devoted to describing some interesting new techniques
    in the graph machine learning domain. You will learn about some data sampling
    and data augmentation techniques for graphs based on random walk and generative
    neural networks. Then, you will learn about topological data analysis, a relatively
    novel tool for analyzing high-dimensional data. In the second part, we will provide
    you with some interesting applications of graph machine learning in different
    domains, ranging from biology to geometrical analysis. After reading this chapter,
    you will be aware of how looking at the relationships between data opened the
    door to novel intriguing solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about data augmentation for graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about topological data analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying graph theory in new domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we get started, let's ensure we have the prerequisites mentioned in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using Python 3.6.9 for all our exercises. The following is the list
    of Python libraries that you must install for this chapter using `pip`. For example,
    you can run `pip install networkx==2.5` on the command line, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All the code files relevant to this chapter are available at `URL TO BE DECIDED`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about data augmentation for graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129), *Graph Analysis
    for Credit Card Transactions*, we described how graph machine learning can be
    used to study and automatically detect fraudulent credit card transactions. While
    describing the use case, we faced two main obstacles:'
  prefs: []
  type: TYPE_NORMAL
- en: There were too many nodes in the original dataset to handle. As a consequence,
    the computational cost was too high to be computed. This is why we selected only
    20% of the dataset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the original dataset, we saw that less than 1% of the data had been labeled
    as fraudulent transactions, while the other 99% of the dataset contained genuine
    transactions. This is why, during the edge classification task, we randomly subsampled
    the dataset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The techniques we used to solve these two obstacles, in general, are not optimal.
    For graph data, more complex and innovative techniques are needed to solve the
    task. Moreover, when datasets are highly unbalanced, as we mentioned in [*Chapter
    8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129), *Graph Analysis for Credit
    Card Transactions*, we can solve this using anomaly detection algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will provide a description of some techniques and algorithms
    we can use to solve the aforementioned problems. We will start by describing the
    graph sampling problem and we will finish by describing some graph data augmentation
    techniques. We will share some useful references and Python libraries for both
    of these.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129), *Graph Analysis
    for Credit Card Transactions*, to perform the edge classification task, we started
    our analysis by sampling only 20% of the whole dataset. Unfortunately, this strategy,
    in general, it is not an optimal one. Indeed, the subset of nodes that are selected
    with this simple strategy could generate a subgraph that is not representative
    of the topology of the whole graph. Due to this, we need to define a strategy
    for building a subgraph of a given graph by sampling the right nodes. The process
    of building a (small) subgraph from a given (large) graph by minimizing the loss
    of *topological* information is known as **graph sampling**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good starting point so that we have a full overview of the graph sampling
    algorithm is available in the paper *Little Ball of Fur: A Python Library for
    Graph Sampling*, which can be downloaded from the following URL: [https://arxiv.org/pdf/2006.04311.pdf](https://arxiv.org/pdf/2006.04311.pdf).
    Their Python implementation of using the `networkx` library is available at the
    following URL: [https://github.com/benedekrozemberczki/littleballoffur](https://github.com/benedekrozemberczki/littleballoffur).
    The algorithms that are available in this library can be divided into nodes and
    edges sampling algorithms. These algorithms sample the nodes and edges in the
    graph bundling, respectively. As a result, we get a node- or edge-induced subgraph
    from the original graph. We will leave you to perform the analysis proposed in
    [*Chapter 8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129), *Graph Analysis
    for Credit Card Transactions*, using the different graph sampling strategies available
    in the `littleballoffur` Python package.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring data augmentation techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data augmentation is a common technique when we're dealing with unbalanced data.
    In unbalanced problems, we usually have labeled data from two or more classes.
    Only a few samples are available for one or more classes in the dataset. A class
    that contains a few samples is also known as a *minority* class, while a class
    that contains a large number of samples is known as a *majority* class. For instance,
    in the use case described in [*Chapter 8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129),
    *Graph Analysis for Credit Card Transactions*, we had a clear example of an unbalanced
    dataset. In the input dataset, only 1% of all the available transactions were
    marked as fraudulent (the minority class), while the other 99% were genuine transactions
    (the majority class). When dealing with *classical* datasets, the problem is usually
    solved using random down or up sampling or using data generation algorithms such
    as *SMOTE*. However, for graph data, this process may not be as easy since generating
    new nodes or graphs is not a straightforward process. This is due to the presence
    of complex topological relations. In the last decade, a large range of data augmentation
    graph algorithms have been made. Here, we will introduce two of the latest available
    algorithms, namely *GAug* and *GRAN*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GAug algorithm is a node-based data augmentation algorithm. It is described
    in the paper *Data Augmentation for Graph Neural Networks*, which is available
    at the following URL: [https://arxiv.org/pdf/2006.06830.pdf](https://arxiv.org/pdf/2006.06830.pdf).
    The Python code for this library is available at the following URL: [https://github.com/zhao-tong/GAug](https://github.com/zhao-tong/GAug).
    This algorithm can be useful for use cases where edge or node classification is
    needed, as in the use case provided in [*Chapter 8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129),
    *Graph Analysis for Credit Card Transactions*, where the nodes belonging to the
    minority class can be augmented using the algorithm. As an exercise, you can extend
    on the analysis we proposed in [*Chapter 8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129),
    *Graph Analysis for Credit Card Transactions*, using the GAug algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GRAN algorithm is a graph-based data augmentation algorithm. It is described
    in the paper *Efficient Graph Generation with Graph Recurrent Attention Networks*,
    which is available at the following URL: [https://arxiv.org/pdf/1910.00760.pdf](https://arxiv.org/pdf/1910.00760.pdf).
    The Python code for the library is available at the following URL: [https://github.com/lrjconan/GRAN](https://github.com/lrjconan/GRAN).
    This algorithm is useful for generating new graphs when we''re dealing with graph
    classification/clustering problems. For example, if we''re dealing with an unbalanced
    graph classification problem, it could be useful to create a balance step for
    the dataset using the GRAN algorithm and then perform the classification task.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about topological data analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Topological Data Analysis** (**TDA**) is a rather novel technique that''s
    used to extract features that quantify the *shape of the data*. The idea of this
    approach is that by observing how datapoints are organized in a certain space,
    we can reveal some important information about the process that generated it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main tool for applying TDA is **persistent homology**. The math behind
    this method is quite advanced, so let''s introduce this concept through an example.
    Suppose you have a set of data points distributed on a space, and let''s suppose
    you are "observing" them over time. Points are static (they do not move across
    the space); thus, you will observe those independent points forever. However,
    let''s imagine we can create associations between these data points by connecting
    them together through some well-defined rules. In particular, let''s imagine a
    sphere expanding from these points through time. Each point will have its own
    expanding sphere and, once two spheres collide, an "edge" can be placed by these
    two points. This can be exemplified with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Example of how relationships between points can be created'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Example of how relationships between points can be created
  prefs: []
  type: TYPE_NORMAL
- en: 'The more spheres that collide, the more associations that will be created,
    and the more edges that will be placed. This happens when multiple spheres intersect
    more complex geometrical structures such as triangles, tetrahedrons, and so on
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Example of how connections among points generate geometrical
    structures'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Example of how connections among points generate geometrical structures
  prefs: []
  type: TYPE_NORMAL
- en: When a new geometrical structure appears, we can note its "*birth*" time. On
    the other hand, when an existing geometrical structure disappears (for example,
    it becomes part of a more complex geometrical structure), we can note its "*death*"
    time. The survival time (time between birth and death) of each geometrical structure
    that's observed during the simulation can be used as a new feature for analyzing
    the original dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define the so-called **persistent diagram** by placing each structure''s
    corresponding pair (birth, death) on a two-axis system. Points closer to the diagonal
    normally reflect noise, whereas points distant from the diagonal represent persisting
    features. An example of a persistence diagram is as follows. Notice that we described
    the whole process by using expanding "*spheres*" as an example. In practice, we
    can change the dimension of this expanding shape (for instance, using 2D circles),
    thus producing a set of features for each dimension (commonly indicated using
    the letter *H*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Example of a 2D point cloud (right) and its corresponding persistence
    diagram (left)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Example of a 2D point cloud (right) and its corresponding persistence
    diagram (left)
  prefs: []
  type: TYPE_NORMAL
- en: 'A good Python library for performing topological data analysis is `giotto-tda`,
    which is available at the following URL: [https://github.com/giotto-ai/giotto-tda](https://github.com/giotto-ai/giotto-tda).
    Using the giotto-tda library, it is easy to build the simplicial complex and its
    relative persistence diagram, as shown in the preceding image.'
  prefs: []
  type: TYPE_NORMAL
- en: Topological machine learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know the fundamentals behind TDA, let's see how it can be used for
    machine learning. By providing machine learning algorithms with topological data
    (such as persistent features), we can capture patterns that might be missed by
    other traditional approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we saw that persistence diagrams are useful for describing
    data. Nevertheless, using them to feed machine learning algorithms (such as `RandomForest`)
    is not a good choice. For instance, different persistent diagrams may have different
    numbers of points, and basic algebraic operations would not be well defined.
  prefs: []
  type: TYPE_NORMAL
- en: One common way to overcome such a limitation is to transform diagrams into more
    suitable representations. Embeddings or kernel methods can be used to obtain a
    "*vectorized*" representation of the diagrams. Moreover, advanced representation
    methods such as *persistence images*, *persistence landscapes*, and *B**etti curves*,
    among others, have been shown to be very useful in practical applications. Persistent
    images (*Figure 10.4*), for instance, are bi-dimensional representations of persistence
    diagrams that can easily be fed into convolutional neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several possibilities arise out of this theory, and there is still a connection
    between the findings and deep learning. Several new ideas are being proposed,
    making the subject both hot and fascinating:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Example of a persistent images'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Example of a persistent images
  prefs: []
  type: TYPE_NORMAL
- en: Topological data analysis is a rapidly growing field, especially since it can
    be combined with machine learning techniques. Several scientific papers are published
    on this topic every year and we expect novel exciting applications in the near
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Applying graph theory in new domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, due to there being a more solid theoretical understanding of
    graph machine learning, as well as an increase in available storage space and
    computational power, we can identify a number of domains in which such learning
    theories are spreading. With a bit of imagination, you can start looking at the
    surrounding world as a set of "*nodes*" and "*links*." Our work or study place,
    the technological devices we use every day, and even our brain can be represented
    as networks. In this section, we will look at some examples of how graph theory
    (and graph machine learning) has been applied to, apparently, unrelated domains.
  prefs: []
  type: TYPE_NORMAL
- en: Graph machine learning and neuroscience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The study of the brain by means of graph theory is a prosperous and expanding
    field. Several ways of representing the *brain as a network* have been investigated,
    with the aim of understanding how different parts of the brain (nodes) are *functionally*
    or *structurally* connected to each other.
  prefs: []
  type: TYPE_NORMAL
- en: By means of medical techniques such as **Magnetic Resonance Imaging** (**MRI**),
    a three-dimensional representation of the brain can be obtained. Such an image
    can be processed by different kinds of algorithms to obtain distinct partitions
    of the brain (parcellation).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways we can define connections between those regions, depending
    on whether we are interested in analyzing their functional or structural connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional Magnetic Resonance Imaging** (**fMRI**) is a technique that''s
    used to measure whether a part of the brain is "active" or not. Specifically,
    it measures the **blood-oxygen-level-dependent** (**BOLD**) signal of each region
    (a signal indicating the variation of the level of blood and oxygen at a certain
    time). Then, the *Pearson correlation* between the BOLD series of two brain regions
    of interest can be computed. High correlation means that the two parts are "functionally
    connected," and an edge can be placed between them. An interesting paper on graphically
    analyzing fMRI data is *Graph-based network analysis of resting-state functional
    MRI*, which is available at [https://www.frontiersin.org/articles/10.3389/fnsys.2010.00016/full](https://www.frontiersin.org/articles/10.3389/fnsys.2010.00016/full).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, by using advanced MRI techniques such as **Diffusion Tensor
    Imaging** (**DTI**), we can also measure the strength of the white matter fiber
    bundles physically connecting two brain regions of interest. Thus, we can obtain
    a graph representing the structural connectivity of the brain. A paper where graphs
    neural networks are used in combination with graphs generated from DTI data is
    called *Multiple Sclerosis Clinical Profiles via Graph Convolutional Neural Networks*
    and is available at[https://www.frontiersin.org/articles/10.3389/fnins.2019.00594/full](https://www.frontiersin.org/articles/10.3389/fnins.2019.00594/full).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional and structural connectivity can be analyzed using graph theory. There
    are several studies that enhance significant alterations of such networks related
    to neurodegenerative diseases, such as Alzheimer's, multiple sclerosis, and Parkinson's,
    among others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final result is a graph describing the connection between the different
    brain regions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Connection between brain regions as a graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16069_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Connection between brain regions as a graph
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see how different brain regions can be seen as nodes of a graph,
    while the connections between those regions are edges.
  prefs: []
  type: TYPE_NORMAL
- en: Graph machine learning has been shown to be very useful for this kind of analysis.
    Different studies have been conducted to automatically diagnose a particular pathology
    based on the brain network, thus predicting the evolution of the network (for
    example, identifying potentially vulnerable regions that are likely to be affected
    by the pathology in the future).
  prefs: []
  type: TYPE_NORMAL
- en: Network neuroscience is a promising field, and, in the future, more and more
    insight will be collected from those networks so that we can understand pathological
    alterations and predict a disease's evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Graph theory and chemistry and biology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph machine learning can be applied to chemistry. For example, graphs provide
    a natural method for describing **molecular structures** by treating atoms as
    the nodes of a graph and bonds as their connections. Such methods have been used
    to investigate different aspects of chemical systems, including representing reactions,
    and learning chemical fingerprints (indicating the presence or absence of chemical
    features or substructures), among others.
  prefs: []
  type: TYPE_NORMAL
- en: Several applications can be also found in biology, where many different elements
    can be represented as a graph. **Protein-protein interactions** (**PPI**), for
    example, is one of the most widely studied topics. Here, a graph is constructed,
    where nodes represent protein and edges represent their interaction. Such a method
    allows us to exploit the structural information of PPI networks, which has proved
    to be informative in PPI prediction.
  prefs: []
  type: TYPE_NORMAL
- en: Graph machine learning and computer vision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rise of deep learning, especially **convolutional neural network** (**CNN**)
    techniques, has achieved amazing results in computer vision research. For a wide
    range of tasks, such as image classification, object detection, and semantic segmentation,
    CNNs can be considered as the state-of-the-art. However, recently, central challenges
    in computer vision have started to be addressed using graph machine learning techniques
    – **geometric deep learning** in particular. As we have learned throughout this
    book, there are fundamental differences between the 2D Euclidean domain in which
    images are represented and more complex objects such as 3D shapes and point clouds.
    Restoring the world's 3D geometry from 2D and 3D visual data, scene understanding,
    stereo matching, and depth estimation are only a few examples of what can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Image classification and scene understanding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Image classification, one of the most widely studied tasks in computer vision,
    nowadays dominated by CNN-based algorithms, has started to be addressed from a
    different perspective. Graph neural network models have shown attractive results,
    especially when huge amounts of labeled data is not available. In particular,
    there is a trend in combining these models with *zero-shot and few-shot learning
    techniques*. Here, the goal is to classify classes that the model has never seen
    during training. For instance, this can be achieved by exploiting the knowledge
    of how the unseen object is "semantically" related to the seen ones.
  prefs: []
  type: TYPE_NORMAL
- en: Similar approaches have been also used for scene understanding. Using a relational
    graph between detected objects in a scene provides an interpretable structured
    representation of the image. This can be used to support high-level reasoning
    for various tasks, including captioning and visual question answering, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Shape analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Differently from images, which are represented by a bi-dimensional grid of pixels,
    there are several methods for representing 3D shapes, such as *multi-view images*,
    *depth maps*, *voxels*, *point clouds*, *meshes*, and *implicit surfaces*, among
    others. Nevertheless, when applying machine and deep learning algorithms, such
    representations can be exploited to learn specific geometric features, which can
    be useful for designing a better analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, geometric deep learning techniques have shown promising results.
    For instance, GNN techniques have been successfully applied for finding correspondence
    between deformable shapes, a classical problem that leads to several applications,
    including texture animation and mapping, as well as scene understanding. For those
    of you who are interested, some good resources to help you understand this application
    of graph machine learning are available at [https://arxiv.org/pdf/1611.08097.pdf](https://arxiv.org/pdf/1611.08097.pdf)
    and [http://geometricdeeplearning.com/](http://geometricdeeplearning.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting application of graph machine learning is in recommendation
    systems, which we can use to predict the "rating" or the "preference" that a user
    would assign to an item. In [*Chapter 6*](B16069_06_Final_JM_ePub.xhtml#_idTextAnchor100),
    *Social Network Graphs*, we provided an example of how link prediction can be
    used to build automatic algorithms that provide recommendations to a given user
    and/or customer. In the paper *Graph Neural Networks in Recommender Systems: A
    Survey*, available at [https://arxiv.org/pdf/2011.02260.pdf](https://arxiv.org/pdf/2011.02260.pdf),
    the authors provide an extensive survey of graph machine learning that''s been
    applied to build recommendation systems. More specifically, the authors describe
    different graph machine learning algorithms and their applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided a high-level overview of some emerging graph machine
    learning algorithms and their applications for new domains. At the beginning of
    this chapter, we described, using the example provided in [*Chapter 8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129),
    *Graph Analysis for Credit Card Transactions*, some sampling and augmentation
    algorithms for graph data. We provided some Python libraries that can be used
    to deal with graph sampling and graph data augmentation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by providing a general description of topological data analysis
    and how this technique has recently been used in different domains.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we provided several descriptions of new application domains, such as
    neuroscience chemistry, and biology. We also described how machine learning algorithms
    can also be used to solve other tasks, such as image classification, shape analysis,
    and recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: This is it! In this book, we provided an overview of the most important graph
    machine learning techniques and algorithms. You should now be able to deal with
    graph data and build machine learning algorithms. We hope that you are now in
    possession of more tools in your toolkit and that you will use them to develop
    exciting applications. We also invite you to check the references we provided
    in this book and to address the challenges we proposed in the different chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The world of graph machine learning is fascinating and rapidly evolving. New
    research papers are published every day with incredible findings. As usual, a
    continuous review of the scientific literature is the best way to discover new
    algorithms, and arXiv ([https://arxiv.org/](https://arxiv.org/)) is the best place
    to search for freely available scientific papers.
  prefs: []
  type: TYPE_NORMAL
