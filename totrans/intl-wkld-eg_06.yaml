- en: '*Chapter 4*: Extending the Cloud to the Edge'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：将云扩展到边缘'
- en: In the material leading up to this chapter, all of the development steps were
    performed on your device locally. Local development is useful for learning the
    tools and rapid prototyping but isn't representative of how you would typically
    operate a production device. In this chapter, you will treat your hub device as
    if it were actually deployed in the field and learn how to remotely interact with
    it using the cloud as a deployment engine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前的材料中，所有开发步骤都是在您的设备上本地执行的。本地开发对于学习工具和快速原型设计很有用，但并不代表您通常如何操作生产设备。在本章中，您将把您的中心设备视为实际部署在现场，并学习如何使用云作为部署引擎远程与之交互。
- en: Instead of authoring components on the device, you will learn how to use **Amazon
    Web Services (AWS) IoT Greengrass** to synchronize cloud resources, such as code,
    files, and **machine learning** (**ML**) models, to the edge and update devices
    via deployments. The tools, patterns, and skills you will learn in this chapter
    are important to your goals of extending the cloud to the edge and practicing
    how to manage an edge ML solution. You will connect a new client device to your
    hub device and learn how to bridge connectivity to a cloud solution. Finally,
    you will deploy your first real ML model to the edge. By the end of this chapter,
    you will be as familiar with pushing components and resources out to edge devices
    as you would for a production fleet.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在设备上编写组件，您将学习如何使用**Amazon Web Services (AWS) IoT Greengrass**同步云资源，如代码、文件和**机器学习**（**ML**）模型，到边缘，并通过部署更新设备。您在本章中学习的工具、模式和技能对于您将云扩展到边缘并练习如何管理边缘ML解决方案的目标至关重要。您将连接一个新的客户端设备到您的中心设备，并学习如何建立与云解决方案的连接。最后，您将部署您的第一个真正的ML模型到边缘。到本章结束时，您将熟悉将组件和资源推送到边缘设备，就像您为生产车队所做的那样。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要主题：
- en: Creating and deploying remotely
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程创建和部署
- en: Storing logs in the cloud
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志存储在云端
- en: Synchronizing the state between the edge and the cloud
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在边缘和云之间同步状态
- en: Deploying your first ML model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署您的第一个机器学习模型
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the hands-on steps for this chapter, you should have a hub device
    as defined by the hardware and software requirements in the Hands-on prerequisites
    section of [*Chapter 1*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013)*, Introduction
    to the Data-Driven Edge with Machine Learning*, and that device should be loaded
    with **AWS IoT Greengrass** core software, as defined by the steps from [*Chapter
    2*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032)*, Foundations of Edge Workloads*.
    You will also need access to your **command-and-control** (**C2**) system, typically
    your PC or a laptop that has a web browser, and access to the AWS management console.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的动手实践步骤，您应该拥有一个符合“动手实践先决条件”部分中定义的硬件和软件要求的中心设备[*第1章*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013)*，即《使用机器学习的数据驱动边缘简介*》，该设备应加载**AWS
    IoT Greengrass**核心软件，如[*第2章*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032)*中定义的步骤所示，《边缘工作负载基础*》。您还需要访问您的**指挥与控制**（**C2**）系统，通常是带有网络浏览器的PC或笔记本电脑，以及访问AWS管理控制台。
- en: The resources provided to you for the steps in this chapter are available in
    the GitHub repository under the `chapter4` folder, at [https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter4](https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter4).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章步骤中提供的资源可在GitHub仓库的`chapter4`文件夹中找到，网址为[https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter4](https://github.com/PacktPublishing/Intelligent-Workloads-at-the-Edge/tree/main/chapter4)。
- en: Creating and deploying remotely
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程创建和部署
- en: Up until now, you have been interacting with your IoT Greengrass solution directly
    on the hub device using the IoT Greengrass **command-line interface** (**CLI**).
    Going forward, you will learn how to interact with your IoT Greengrass device
    from your C2 system (laptop or workstation) through the use of the AWS cloud.
    The CLI and local development lifecycle are great for learning the basics of IoT
    Greengrass and rapid iteration on component development. The best practice for
    production solutions is not to deploy the Greengrass CLI component to your devices
    and install new components locally, so next, you will learn how to package your
    components, store them in AWS, and complete remote deployments to your hub device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直通过网关设备直接在IoT Greengrass解决方案上使用IoT Greengrass **命令行界面**（**CLI**）进行交互。从现在开始，您将学习如何通过使用AWS云从您的C2系统（笔记本电脑或工作站）与IoT
    Greengrass设备交互。CLI和本地开发周期非常适合学习IoT Greengrass的基础知识以及组件开发的快速迭代。对于生产解决方案的最佳实践是不将Greengrass
    CLI组件部署到您的设备上并在本地安装新组件，因此接下来您将学习如何打包您的组件，将它们存储在AWS中，并完成对网关设备的远程部署。
- en: Loading resources from the cloud
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从云中加载资源
- en: 'Components can include any number of artifacts defined by the recipe file,
    and those artifacts must be stored somewhere the Greengrass device can access
    them. Artifacts can be static resources of any kind: binary data such as images
    or text, application code such as Python source code or compiled **Java ARchive**
    files (**JARs**), containerized code such as a Docker container, and anything
    else that your component needs a copy of to work, the keywords here being **static**
    and **copy**. Artifacts are resources that your device uses that are copies that
    every other device deploying that component uses. They are also not intended to
    change on the device after deployment.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以包括由配方文件定义的任意数量的工件，并且这些工件必须存储在Greengrass设备可以访问的地方。工件可以是任何类型的静态资源：如图像或文本这样的二进制数据，Python源代码或编译的**Java
    ARchive**文件（**JARs**），容器化代码如Docker容器，以及组件工作所需的任何其他副本，这里的重点在于**静态**和**副本**。工件是设备使用的资源，是其他部署该组件的每个设备都使用的副本。它们也不打算在部署后在设备上更改。
- en: The other kind of resource that components use is **dynamic resources**. A dynamic
    resource gets loaded as a configuration specific to the device or something that
    gets consumed at runtime. Dynamic resources may be ephemeral in that they exist
    only as long as the device is online or a component is running. Some examples
    of dynamic resources are secrets to reference in your code such as an **application
    programming interface** (**API**) key, behavioral settings to include based on
    the device's **identifier** (**ID**) or other metadata, and communication channels
    between any leaf devices (those at terminal points in the solution, such as **Home
    Base Solutions** (**HBS**) appliance monitoring kits) and the Greengrass device
    (such as the HBS hub device), software components, and the cloud.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用的另一种资源是**动态资源**。动态资源作为针对设备特定的配置或运行时消耗的内容被加载。动态资源可能是短暂的，因为它们只存在于设备在线或组件运行期间。动态资源的例子包括在代码中引用的秘密，如**应用程序编程接口**（**API**）密钥，基于设备的**标识符**（**ID**）或其他元数据的设置行为，以及任何叶设备（那些在解决方案终端点的设备，如**Home
    Base Solutions**（**HBS**）设备监控套件）与Greengrass设备（如HBS网关设备）之间的通信通道，软件组件，以及云。
- en: In the first hands-on section of this chapter, you will get familiar with how
    a recipe defines static resources as artifacts and perform your first remote deployment
    with a custom component. Later sections of this chapter will introduce implementations
    for dynamic resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个动手操作部分，您将熟悉配方如何定义静态资源作为工件，并使用自定义组件执行您的第一次远程部署。本章的后续部分将介绍动态资源的实现。
- en: Packaging your components for remote deployment
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包您的组件以进行远程部署
- en: The main difference between local and remote deployment on IoT Greengrass is
    where the component resources come from. In your local development lifecycle,
    you were authoring files on the hub device itself and pointing to folders containing
    recipe and artifact files. For remote deployment, you must store your files in
    the AWS cloud using **Amazon Simple Storage Service** (**Amazon S3**) and update
    your recipes to point at S3 object locations. In the next steps, you will update
    the permissions model of your IoT Greengrass device to be able to read objects
    from S3, package up a component to S3 using the AWS CLI, and create a new remote
    deployment to your hub device.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IoT Greengrass 上本地部署和远程部署之间的主要区别在于组件资源来自哪里。在您的本地开发生命周期中，您是在中心设备本身上编写文件，并指向包含配方和工件文件的文件夹。对于远程部署，您必须使用
    **Amazon Simple Storage Service** (**Amazon S3**) 将您的文件存储在 AWS 云中，并更新您的配方以指向 S3
    对象位置。在接下来的步骤中，您将更新 IoT Greengrass 设备的权限模型，以便能够从 S3 读取对象，使用 AWS CLI 将组件打包到 S3，并创建一个新的远程部署到您的中心设备。
- en: Updating IoT Greengrass permissions
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新 IoT Greengrass 权限
- en: In your initial setup of IoT Greengrass on your hub device, a new role was created
    in the **AWS Identity and Access Management** (**AWS IAM**) service that the IoT
    Greengrass core service uses to get authorization to interact with any AWS services.
    In AWS, the AWS IAM service is where all users, groups, policies, and roles are
    defined that grant access to resources and APIs in your account.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在中心设备上初始设置 IoT Greengrass 时，在 **AWS 身份和访问管理** (**AWS IAM**) 服务中创建了一个新角色，IoT
    Greengrass 核心服务使用该角色来获取与任何 AWS 服务交互的授权。在 AWS 中，AWS IAM 服务是定义所有用户、组、策略和角色的地方，这些用户、组、策略和角色授予了对您账户中资源和服务
    API 的访问权限。
- en: 'A `idtgg` user we defined for initially provisioning your hub device in AWS.
    A **policy** documents the sets of allowed and denied permissions that we attach
    to identities. A **role** is a façade of permissions that authorized users can
    assume to gain those specified permissions. A user gets permissions granted in
    one of three ways. Policies can be directly attached to the user or inherited
    from a group to which they belong. Policies can also be attached to roles that
    users assume for temporary sessions, letting the user perform specific session-based
    tasks following the **principle of least privilege** (**POLP**). By using roles,
    we can define abstract sets of permissions that users can gain for the completion
    of specific tasks to follow the best practice of limiting permission scope. Here
    is a simple illustration of the relationship between a user (one type of security
    principal), a role, a policy, and the permissions granted to the user by assuming
    the role:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 AWS 中定义的一个 `idtgg` 用户，用于最初配置您的中心设备。一个 **策略** 记录了我们附加到身份的允许和拒绝权限集合。一个 **角色**
    是权限的界面，授权用户可以假定以获得那些指定的权限。用户可以通过三种方式获得授权的权限。策略可以直接附加到用户或从他们所属的组继承。策略还可以附加到用户假定的用于临时会话的角色，让用户在遵循
    **最小权限原则** (**POLP**) 的前提下执行特定的基于会话的任务。通过使用角色，我们可以定义用户为完成特定任务而可以获得的抽象权限集合，以遵循限制权限范围的最佳实践。以下是一个用户（一种安全主体类型）、角色、策略以及用户通过假定角色所获得的权限之间关系的简单说明：
- en: '![Figure 4.1 – An IAM user gets temporary permissions and credentials from
    a role'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – IAM 用户从角色获取临时权限和凭证'
- en: '](img/B17595_04_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17595_04_01.jpg)'
- en: Figure 4.1 – An IAM user gets temporary permissions and credentials from a role
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – IAM 用户从角色获取临时权限和凭证
- en: A real-world analogy for users, policies, and roles is when your friend temporarily
    gives you their house key while they are away so that you can water their plants
    or feed their cat. You can think of the role as *Someone Who Can Enter My House*,
    and the house key is the policy that grants access to their house. By trusting
    you with the key, your friend is granting you, the user, a temporary role to enter
    their home. When your task is complete and your friend returns home, you relinquish
    the key and thus end your session in that role. In the digital world, you as the
    user have your own key (such as a public certificate) that identifies you. The
    role and its policy grant your key temporary permission to access the resource
    instead of giving you the only key!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户、策略和角色的现实世界类比是，当您的朋友不在家时暂时把他们的家门钥匙给您，以便您可以为他们的植物浇水或喂他们的猫。您可以将角色视为“可以进入我家的人”，而家门钥匙是授予他们家访问权限的策略。通过把钥匙托付给您，您的朋友在您作为用户的情况下授予了一个临时的角色进入他们的家。当您的任务完成并且您的朋友回家后，您归还钥匙，从而结束在该角色下的会话。在数字世界中，您作为用户有自己的钥匙（例如公共证书），用于识别您。角色及其策略授予您的钥匙临时访问资源的权限，而不是给您唯一的钥匙！
- en: The installation process of IoT Greengrass created a new role named `GreengrassV2TokenExchangeRole`
    and attached to it a policy named `GreengrassV2TokenExchangeRoleAccess` that grants
    access to the APIs for interacting with the AWS IoT Core service and for writing
    logs to Amazon CloudWatch. By default, and as a best security practice, this policy
    does not include access to objects stored in S3\. It is up to you as the solution
    developer to describe which S3 objects your devices should be able to access and
    add that configuration to the role as a new policy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: IoT Greengrass的安装过程创建了一个名为`GreengrassV2TokenExchangeRole`的新角色，并附加了一个名为`GreengrassV2TokenExchangeRoleAccess`的策略，该策略授予访问与AWS
    IoT Core服务交互的API以及将日志写入Amazon CloudWatch的权限。默认情况下，并且作为最佳安全实践，此策略不包括对存储在S3中的对象的访问权限。作为解决方案开发者，您需要描述您的设备应该能够访问哪些S3对象，并将该配置作为新策略添加到角色中。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the rest of this chapter, steps with AWS CLI commands and simple filesystem
    management commands (such as the creation of new directories or files) will be
    written in Unix format for macOS and Linux systems. To get help using commands
    in AWS CLI where there are distinct differences for Windows, such as referencing
    local files as input, please refer to the AWS CLI documentation at [https://docs.aws.amazon.com/cli/latest/userguide/](https://docs.aws.amazon.com/cli/latest/userguide/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，包含AWS CLI命令和简单的文件系统管理命令（如创建新目录或文件）的步骤将以Unix格式编写，适用于macOS和Linux系统。如果您在使用AWS
    CLI时遇到Windows特有的差异，例如将本地文件作为输入引用，请参阅[https://docs.aws.amazon.com/cli/latest/userguide/](https://docs.aws.amazon.com/cli/latest/userguide/)的AWS
    CLI文档。
- en: 'In the next steps, you will use the AWS CLI to create a new bucket in S3, a
    new policy that grants read permissions to objects in that S3 bucket, and then
    attach the new policy to the role used by IoT Greengrass devices. Proceed as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，您将使用AWS CLI在S3中创建一个新的存储桶，一个授予对该S3存储桶中对象读取权限的新策略，然后将该新策略附加到IoT Greengrass设备使用的角色。按照以下步骤操作：
- en: From your C2 system, open the terminal (or run `cmd.exe`/PowerShell on Windows).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的C2系统中，打开终端（或在Windows上运行`cmd.exe`/PowerShell）。
- en: 'Use the AWS CLI to print out your 12-digit account ID by running the following
    command: `aws sts get-caller-identity --query ''Account''` (the output should
    look like this: `012345678912`).'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用AWS CLI通过运行以下命令打印出您的12位账户ID：`aws sts get-caller-identity --query 'Account'`（输出应如下所示：`012345678912`）。
- en: 'Create a new S3 bucket in your account. S3 bucket names share a global namespace
    in AWS. A good practice for naming buckets is to include your AWS account ID as
    a unique string. If a bucket name is already taken, you can add unique text (such
    as your initials) to the name until you find one that is not taken. Use the account
    ID from the previous step and replace the 12-digit account ID placeholder. Be
    sure to update the region if you''re not using the default of `us-west-2`. The
    output should look like this: `aws s3 mb s3://012345678912-hbs-components --region
    us-west-2`.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的账户中创建一个新的S3存储桶。S3存储桶名称在AWS中共享一个全局命名空间。命名存储桶的一个好习惯是包含您的AWS账户ID作为唯一的字符串。如果存储桶名称已被占用，您可以在名称中添加唯一的文本（例如您的首字母缩写）直到找到一个未被占用的名称。使用上一步骤中的账户ID并替换12位账户ID占位符。如果您不是使用默认的`us-west-2`，请确保更新区域。输出应如下所示：`aws
    s3 mb s3://012345678912-hbs-components --region us-west-2`。
- en: 'From here on out, we will refer to this bucket name as `REPLACEME_HBS_COMPONENTS_BUCKET`.
    When you see a command or text in a file with the `REPLACEME_HBS_COMPONENTS_BUCKET`
    placeholder, you need to replace it with the name of your bucket, like this: `012345678912-hbs-components`.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在开始，我们将把这个存储桶名称称为 `REPLACEME_HBS_COMPONENTS_BUCKET`。当你在文件中看到带有 `REPLACEME_HBS_COMPONENTS_BUCKET`
    占位符的命令或文本时，你需要将其替换为你自己的存储桶名称，例如：`012345678912-hbs-components`。
- en: 'Next, you will create a local file to store the content of the new policy that
    grants read access to the objects in your new bucket. You can find a template
    of this file in the GitHub repository for this book at the `chapter4/greengrass_read_s3.json`
    path and update the `REPLACEME_HBS_COMPONENTS_BUCKET` placeholder. If you''re
    creating the file yourself, name it `greengrass_read_s3.json` and add the following
    content (remembering to replace the placeholder!):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，您将创建一个本地文件来存储授予您新存储桶中对象读取访问权限的新策略的内容。您可以在本书的 GitHub 仓库中找到此文件的模板，位于 `chapter4/greengrass_read_s3.json`
    路径，并更新 `REPLACEME_HBS_COMPONENTS_BUCKET` 占位符。如果您自己创建文件，请将其命名为 `greengrass_read_s3.json`
    并添加以下内容（记得替换占位符！）:'
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new policy in IAM with this document as its source: `aws iam create-policy
    --policy-name GreengrassV2ReadComponentArtifacts --policy-document file://greengrass_read_s3.json`.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此文档作为其来源在 IAM 中创建一个新的策略：`aws iam create-policy --policy-name GreengrassV2ReadComponentArtifacts
    --policy-document file://greengrass_read_s3.json`。
- en: 'Add the policy to the IAM role used by IoT Greengrass. Replace the value of
    the `--policy-arn` argument with the `arn` value output from the previous command,
    as follows: `aws iam attach-role-policy --role-name GreengrassV2TokenExchangeRole
    --policy-arn arn:aws:iam::012345678912:policy/ GreengrassV2ReadComponentArtifacts`.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将策略添加到 IoT Greengrass 使用的 IAM 角色中。将 `--policy-arn` 参数的值替换为上一个命令输出的 `arn` 值，如下所示：`aws
    iam attach-role-policy --role-name GreengrassV2TokenExchangeRole --policy-arn
    arn:aws:iam::012345678912:policy/GreengrassV2ReadComponentArtifacts`。
- en: Now, your IoT Greengrass devices, such as the HBS hub device, can read component
    files that are stored in your S3 bucket. Let's cover one more element of how the
    security model works between the hub device and an AWS resource.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的 IoT Greengrass 设备，例如 HBS 网关设备，可以读取存储在您的 S3 存储桶中的组件文件。让我们再了解一下网关设备和 AWS
    资源之间安全模型的一个要素。
- en: Earlier, we described the relationship in AWS IAM between a user, a role, and
    a policy. Your devices don't have any identity as a user in AWS IAM, so how do
    they assume the role? The answer is a feature of AWS IoT Core called the **Credentials
    Provider service**. Your devices do have an identity provisioned in AWS IoT Core
    using an **X.509** private key and public certificate. The credentials provider
    service is a means for connected devices to present their registered public certificates
    in exchange for temporary AWS credentials that have permissions granted through
    an IAM role.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们描述了 AWS IAM 中用户、角色和策略之间的关系。您的设备在 AWS IAM 中没有作为用户的任何身份，那么它们是如何假定角色的呢？答案是
    AWS IoT Core 中的一个功能，称为 **凭证提供者服务**。您的设备在 AWS IoT Core 中使用 **X.509** 私钥和公钥证书配置了身份。凭证提供者服务是连接设备展示其已注册的公钥证书以换取具有通过
    IAM 角色授予的权限的临时 AWS 凭证的机制。
- en: 'Here is a sequence diagram showing the path for your HBS hub device to get
    permissions and ultimately read an object in S3:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个序列图，展示了您的 HBS 网关设备获取权限并最终在 S3 中读取对象的路径：
- en: '![Figure 4.2 – Sequence diagram to fetch temporary credentials'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 获取临时凭证的序列图'
- en: '](img/B17595_04_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17595_04_02.jpg]'
- en: Figure 4.2 – Sequence diagram to fetch temporary credentials
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 获取临时凭证的序列图
- en: As your edge solution adds features that interact with more AWS services, you
    must add permissions to those services using the same process you just completed.
    The same is true for your custom components that interact with AWS since all components
    get permissions through the IAM role of your device's configuration. As the number
    of distinct edge solutions in your account grows, the best practice is to create
    distinct IAM roles per distinct group of devices. For example, each HBS hub will
    have the same solution and can share a common role that defines permissions to
    access AWS. For the next project at HBS using IoT Greengrass, instead of adding
    more permissions to the same IAM role, it is best to create a new role for devices
    of that project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的边缘解决方案添加与更多AWS服务交互的功能，您必须使用您刚刚完成的过程为这些服务添加权限。对于与AWS交互的自定义组件也是如此，因为所有组件都通过设备的配置IAM角色获取权限。随着您账户中不同边缘解决方案数量的增加，最佳实践是为每组不同的设备创建不同的IAM角色。例如，每个HBS枢纽将具有相同的解决方案，可以共享一个定义访问AWS权限的公共角色。对于HBS的下一个使用物联网Greengrass的项目，最好的做法是为该项目的设备创建一个新的角色，而不是向同一个IAM角色添加更多权限。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is a regional quota for the number of roles you can define for your devices
    in AWS IoT. As of this writing, the quota is 100\. This means you don't want to
    create a unique role per Greengrass device, as you will quickly reach the maximum
    quota as you scale. A best practice for a production solution on AWS is to use
    one AWS account per production solution, such as maintaining the fleets of hub
    devices at HBS. A different product line may be deployed in a separate AWS account,
    thus expanding the total number of roles to use.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: AWS IoT为您的设备定义的角色数量有一个区域配额。截至本文撰写时，配额为100。这意味着您不想为每个Greengrass设备创建一个独特的角色，因为随着您扩展规模，您将很快达到最大配额。在AWS上的生产解决方案中，一个最佳实践是每个生产解决方案使用一个AWS账户，例如维护HBS的枢纽设备舰队。不同的产品线可以部署在单独的AWS账户中，从而增加可使用的角色总数。
- en: With the new permissions added, you can move on to the next section, where you
    will package up a new component and register it in the cloud service of IoT Greengrass.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了新权限后，您可以继续到下一节，在那里您将打包一个新的组件并在物联网Greengrass的云服务中注册它。
- en: Registering a component in IoT Greengrass
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在物联网Greengrass中注册组件
- en: In order to remotely deploy a component to your hub device, you must first register
    the component in the cloud service of IoT Greengrass. You will provide a recipe
    file as input to an API, just like you did when using the local IoT Greengrass
    CLI on your device. The recipe file will define the location of all artifacts
    used by the component. These artifacts must be uploaded to an S3 bucket such as
    the one created in the previous step. When IoT Greengrass processes your recipe
    file, it will register a new component in your account that can then be referenced
    in a future deployment to any of your devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将组件远程部署到您的中心设备，您必须首先在物联网Greengrass的云服务中注册该组件。您将提供一个配方文件作为API的输入，就像您在使用设备上的本地物联网Greengrass
    CLI时做的那样。配方文件将定义组件使用的所有工件的位置。这些工件必须上传到S3存储桶，例如在上一步骤中创建的那个。当物联网Greengrass处理您的配方文件时，它将在您的账户中注册一个新的组件，然后可以在未来的任何设备部署中引用它。
- en: 'The first step in registering a component is to add your artifact files to
    the S3 bucket. Only then will you know the addresses of those files in S3 to be
    able to update a recipe that can reference them. In this section, you will upload
    a ZIP archive as an artifact, replace the path to the artifact in the recipe file,
    then register the component in your account using the AWS **software development
    kit** (**SDK**), as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注册组件的第一步是将您的工件文件添加到S3存储桶。只有在这种情况下，您才能知道这些文件在S3中的地址，以便能够更新可以引用它们的配方。在本节中，您将上传一个ZIP存档作为工件，然后在配方文件中替换工件路径，然后使用AWS
    **软件开发工具包**（**SDK**）在您的账户中注册组件，如下所示：
- en: 'From the book''s GitHub repository, change directory to `chapter 4` by running
    the following command: `cd chapter4`.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从书籍的GitHub仓库中，通过运行以下命令切换到`第4章`：`cd chapter4`。
- en: 'Use the AWS SDK to upload the artifact file by running the following command:
    `aws s3 cp artifacts/com.hbs.hub.HelloWithConfig/1.0.0/archive.zip s3://REPLACEME_HBS_COMPONENTS_BUCKET/artifacts/com.hbs.hub.HelloWithConfig/1.0.0/archive.zip`.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用AWS SDK通过运行以下命令上传工件文件：`aws s3 cp artifacts/com.hbs.hub.HelloWithConfig/1.0.0/archive.zip
    s3://REPLACEME_HBS_COMPONENTS_BUCKET/artifacts/com.hbs.hub.HelloWithConfig/1.0.0/archive.zip`。
- en: 'Edit the `recipes/com.hbs.hub.HelloWithConfig-1.0.0.json` file and replace
    the value of the **Uniform Resource Identifier** (**URI**) key with the path to
    your artifact in S3 (the last argument in the previous step). After filling it
    in, it should look something like this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`recipes/com.hbs.hub.HelloWithConfig-1.0.0.json`文件，并将**统一资源标识符**（**URI**）键的值替换为您在S3上的工件路径（上一步中的最后一个参数）。填写完毕后，它应该看起来像这样：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that your artifact is in S3 and your recipe file is updated, you can use
    the AWS SDK to register your new component in the cloud service of IoT Greengrass.
    In the response will be the `aws greengrassv2 create-component-version --inline-recipe
    fileb://recipes/com.hbs.hub.HelloWithConfig-1.0.0.json`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的工件已存放在S3上，配方文件也已更新，您可以使用AWS SDK将新组件注册到IoT Greengrass的云服务中。响应中将是`aws greengrassv2
    create-component-version --inline-recipe fileb://recipes/com.hbs.hub.HelloWithConfig-1.0.0.json`。
- en: 'The preceding command returns a status such as `componentState=REQUESTED` to
    signal that IoT Greengrass is taking steps to register your new component. To
    check on the status of your component registration, run the following command
    (replacing the `--arn` argument with the one found in the output from the previous
    step): `aws greengrassv2 describe-component --arn arn:aws:greengrass:us-west-2:012345678912:components:com.hbs.hub.HelloWithConfig:versions:1.0.0`.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令会返回一个状态，例如`componentState=REQUESTED`，表示IoT Greengrass正在采取措施注册您的新组件。要检查组件注册的状态，请运行以下命令（将`--arn`参数替换为上一步输出的值）：`aws
    greengrassv2 describe-component --arn arn:aws:greengrass:us-west-2:012345678912:components:com.hbs.hub.HelloWithConfig:versions:1.0.0`。
- en: 'When the component is registered in the service, you will see a response to
    this command with the `componentState` value now showing as `DEPLOYABLE`. This
    means the component is now ready for inclusion in a new deployment to a device.
    Before moving on to the deployment, let''s take a look at the recipe file now
    stored by IoT Greengrass with the following command (replace the `--arn` argument
    with your component''s ARN from previous steps): `aws greengrassv2 get-component
    --arn arn:aws:greengrass:us-west-2: 012345678912:components:com.hbs.hub.HelloWithConfig:versions:1.0.0
    --query "recipe" --output text | base64 --decode`. You may notice the recipe file
    doesn''t look exactly like the one you sent to IoT Greengrass. Here''s what the
    `Artifacts` object looks like now:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '当组件在服务中注册后，您将看到此命令的响应，其中`componentState`值现在显示为`DEPLOYABLE`。这意味着组件现在已准备好包含在新部署到设备中。在继续部署之前，让我们看一下IoT
    Greengrass现在存储的配方文件，可以使用以下命令查看（将`--arn`参数替换为上一步中您的组件的ARN）：`aws greengrassv2 get-component
    --arn arn:aws:greengrass:us-west-2: 012345678912:components:com.hbs.hub.HelloWithConfig:versions:1.0.0
    --query "recipe" --output text | base64 --decode`。您可能会注意到配方文件看起来并不完全像您发送给IoT Greengrass的那个。以下是现在的`Artifacts`对象看起来像这样：'
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What's new here are the `Digest` and `Algorithm` keys. This is a security feature
    of IoT Greengrass. When your recipe is registered as a component in the service,
    IoT Greengrass computes a `SHA-256` hash of each artifact file referenced by the
    recipe. The purpose is to ensure that the artifacts eventually downloaded by any
    IoT Greengrass devices have not been modified before use. This also means you
    cannot alter an artifact file stored on S3 after registering the component. To
    update any artifact requires you to register a new version of the component and
    deploy the new component version.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里新增的是`Digest`和`Algorithm`键。这是IoT Greengrass的安全特性。当您的配方被注册为服务中的组件时，IoT Greengrass会计算配方中引用的每个工件文件的`SHA-256`哈希值。其目的是确保任何IoT
    Greengrass设备最终下载的工件在使用前未被修改。这也意味着您在注册组件后不能更改存储在S3上的工件文件。要更新任何工件，您需要注册组件的新版本并部署新组件版本。
- en: 'Two more deltas between this component and components developed locally in
    previous chapters are the use of the decompressed path and artifact permissions.
    Here is a snapshot of the key differences in this recipe file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前章节中本地开发的组件相比，这个组件还有两个差异：使用解压缩路径和工件权限。以下是此配方文件中关键差异的快照：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `Lifecycle` object, you can see the run script that makes reference to
    the `artifacts:decompressedPath` variable. This variable points to the directory
    where Greengrass automatically unarchives your archived artifacts. Files are unpacked
    to a subdirectory with the same name as the archive—in this case, `archive/`.
    We know our `hello.sh` script will reference the adjacent `config.txt` file from
    the same archive. We must tell the run script to change directory to the decompressed
    path and then run the script in order to find the `config.txt` file in the correct
    directory context.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Lifecycle`对象中，你可以看到运行脚本，它引用了`artifacts:decompressedPath`变量。这个变量指向Greengrass自动解压缩你的归档工件所在的目录。文件被解压缩到与归档相同的子目录中——在这个例子中，是`archive/`。我们知道我们的`hello.sh`脚本将引用同一归档中的相邻`config.txt`文件。我们必须告诉运行脚本更改目录到解压缩路径，然后运行脚本，以便在正确的目录上下文中找到`config.txt`文件。
- en: The best practice for your artifacts is to consume them from the `artifacts`
    directory, as downloaded or unpacked by IoT Greengrass, and to use the component's
    work directory, available in the recipe as `work:path`, for files to which your
    component will write data. The `work` directory is the default context for any
    lifecycle script, and that is why we include a `change` directory command before
    running our script artifact.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的工件，最佳实践是从由IoT Greengrass下载或解包的`artifacts`目录中消费它们，并使用组件的工作目录，在配方中作为`work:path`提供，用于你的组件将要写入数据的文件。`work`目录是任何生命周期脚本的默认上下文，这就是为什么我们在运行脚本工件之前包括一个更改目录命令。
- en: The other new inclusion is the `Permission` object, where you can see we are
    setting an `Execute` property to the `OWNER` value. By default, artifacts and
    files from unpacked artifacts have a filesystem permission of `Read` for the component's
    owner (such as the default `ggc_user`). This means a script file in our `archive.zip`
    file would not be executable without a change to the file's permissions. Using
    the `Permission` object for any artifact, we can set the `Read` and `Execute`
    filesystem permissions to any of `NONE`, `OWNER`, or `ALL` (all system users).
    This is also related to why artifacts are write-protected. Artifacts are intended
    to be read-only resources consumed by the component or executable files that should
    not be changed without a revision to the component's definition.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新加入的是`Permission`对象，我们可以看到我们正在将`Execute`属性设置为`OWNER`值。默认情况下，解包的工件和文件对组件的所有者（如默认的`ggc_user`）具有`Read`文件系统权限。这意味着我们的`archive.zip`文件中的脚本文件在没有更改文件权限的情况下是不可执行的。对于任何工件使用`Permission`对象，我们可以将`Read`和`Execute`文件系统权限设置为`NONE`、`OWNER`或`ALL`（所有系统用户）。这也与为什么工件是写保护的有关。工件旨在作为只读资源被组件或不应更改而不修改组件定义的可执行文件使用。
- en: In the next section, you will deploy your newly registered component to your
    device.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将部署你新注册的组件到你的设备上。
- en: Remotely deploying a component
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程部署组件
- en: With your component now available in the IoT Greengrass service, it's time to
    start a remote deployment from your C2 system to your HBS hub device using the
    AWS CLI. This kind of deployment from a remote system using the IoT Greengrass
    cloud service is the standard way by which you will deploy updates to your devices.
    It may not always be a manual step from your developer laptop, but we will cover
    more details about the production pipeline in [*Chapter 8*](B17595_08_Final_SS_ePub.xhtml#_idTextAnchor163),
    *DevOps and MLOps for the Edge*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的组件现在可在IoT Greengrass服务中使用，是时候从你的C2系统使用AWS CLI开始远程部署到你的HBS网关设备了。这种从远程系统使用IoT
    Greengrass云服务进行的部署是你将更新部署到设备的标准方式。这不一定总是从你的开发笔记本电脑上的手动步骤，但我们将更详细地介绍生产管道的更多细节，见[*第8章*](B17595_08_Final_SS_ePub.xhtml#_idTextAnchor163)，*边缘的DevOps和MLOps*。
- en: In the local development lifecycle, the only device that you were deploying
    your component to was the local one. Deployment through the cloud service of IoT
    Greengrass is how you specify multiple target devices. These kinds of deployments
    are how you scale up your ability to manage a fleet of any size that should all
    have the same components running on them. A deployment will also specify rollout
    and success criteria, such as the rate at which to notify devices, how long they
    have to report a successful deployment, how long to wait for components to signal
    they are ready for updates, and what to do if the deployment fails.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发周期中，你部署组件的唯一设备是本地设备。通过物联网Greengrass的云服务进行部署是您指定多个目标设备的方式。这类部署是您扩大管理任何规模机群的能力，这些机群都应该运行相同组件的方法。部署还将指定部署和成功标准，例如通知设备的速率、它们报告成功部署所需的时间、等待组件发出准备更新信号的时长，以及部署失败时应该采取的措施。
- en: 'In the following steps, you will write a file that tells IoT Greengrass about
    the details of your deployment, initiate the deployment, and then verify the deployment''s
    success:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，您将编写一个文件，告知物联网Greengrass有关您的部署细节，启动部署，然后验证部署的成功：
- en: 'You will need the ARN of the `hbshubprototypes` thing group as an argument
    in the initial IoT Greengrass core software installation. The following command
    will fetch the ARN of your thing group that you will use in the next step: `aws
    iot describe-thing-group --thing-group-name hbshubprototypes --query "thingGroupArn"`.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始物联网Greengrass核心软件安装中，您需要将`hbshubprototypes`设备组ARN作为参数。以下命令将获取您将在下一步中使用的设备组ARN：`aws
    iot describe-thing-group --thing-group-name hbshubprototypes --query "thingGroupArn"`。
- en: 'Edit the `chapter4/deployment-hellowithconfig.json` file from the GitHub repository
    and replace the value of `targetArn` with the thing group ARN output from the
    previous step. After editing the file, it should look something like this:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑GitHub仓库中的`chapter4/deployment-hellowithconfig.json`文件，并将`targetArn`的值替换为上一步输出的设备组ARN。编辑文件后，它应该看起来像这样：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start a new deployment to the group containing your hub device using the following
    deployment configuration: `aws greengrassv2 create-deployment --cli-input-json
    file://deployment-hellowithconfig.json`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下部署配置启动对新包含中心设备的组的新部署：`aws greengrassv2 create-deployment --cli-input-json
    file://deployment-hellowithconfig.json`。
- en: 'The previous command starts the deployment process. To check on the status
    of the deployment on a particular device, such as your `hbshub001` device, you
    can use the following command: `aws greengrassv2 list-effective-deployments --core-device-thing-name
    hbshub001`.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的命令启动了部署过程。要检查特定设备（如您的`hbshub001`设备）的部署状态，可以使用以下命令：`aws greengrassv2 list-effective-deployments
    --core-device-thing-name hbshub001`。
- en: 'To validate on your device that the component ran as intended, you can log
    in or use a `sudo less /greengrass/v2/logs/com.hbs.hub.HelloWithConfig.log` as
    follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证您的设备上组件是否按预期运行，您可以登录或使用`sudo less /greengrass/v2/logs/com.hbs.hub.HelloWithConfig.log`如下：
- en: '[PRE5]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, you have completed your first remote deployment to your hub device
    using IoT Greengrass! The overall process is not too different from local development.
    We needed to upload our artifacts to a cloud service such as S3, update the recipe
    file to point to these new artifact locations, and register the component before
    including it in a deployment. The deployment itself also has a few more options
    for specifying which devices to target, behavior for scaling out to a fleet, and
    criteria and behavior of success or failure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用物联网Greengrass完成了对您的中心设备的第一次远程部署！整个过程与本地开发并没有太大的不同。我们需要将我们的工件上传到云服务，如S3，更新配方文件以指向这些新的工件位置，并在将其包含在部署中之前注册组件。部署本身还有一些更多选项，用于指定目标设备、扩展到机群的行为，以及成功或失败的标准和行为。
- en: Each thing group has a 1:1 mapping with a deployment that represents the latest
    configuration each device in that group should be using. When you want to deploy
    a change to a group of devices, you will create a revision to the deployment instead
    of starting an all-new deployment. A revision still takes a deployment configuration
    similar to the one we used in this section and expects an explicit definition
    of all components and configuration, meaning it is not an amendment to the last
    known deployment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事物组与一个部署有一个1:1的映射，该部署代表了该组中每个设备应使用的最新配置。当你想要向一组设备部署更改时，你将创建部署的修订版而不是启动全新的部署。修订版仍然需要一个类似于本节中使用的部署配置，并期望对所有组件和配置的明确定义，这意味着它不是对最后已知部署的修正。
- en: 'You can include a device in multiple thing groups, where each thing group defines
    a deployment of unique configuration and components. For example, you could define
    a thing group of monitoring components that get applied to all HBS devices, and
    pair this with thing groups that specify business logic components based on the
    kind of device it is, such as our smart home hub. A device that belongs to multiple
    thing groups will receive deployment notifications for each group and merge the
    component graph from all of them. Here is an illustration of how we can use thing
    groups to effectively manage the components that get deployed across a fleet of
    devices to build up an aggregate solution:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在多个事物组中包含一个设备，其中每个事物组定义了一个独特的配置和组件的部署。例如，你可以定义一个监控组件的事物组，这些组件将应用于所有HBS设备，并与指定基于设备类型的企业逻辑组件的事物组配对，例如我们的智能家居中心。属于多个事物组的设备将接收到每个组的部署通知，并将从所有组中合并组件图。以下是如何使用事物组有效地管理跨设备群组部署的组件以构建聚合解决方案的说明：
- en: '![Figure 4.3 – Example of aggregating components across group deployments'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – 在组部署中聚合组件的示例]'
- en: '](img/B17595_04_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B17595_04_03.jpg]'
- en: Figure 4.3 – Example of aggregating components across group deployments
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 在组部署中聚合组件的示例
- en: As mentioned earlier, your deployment configuration can specify whether to allow
    components an option to signal they are ready for a restart or update. The value
    of letting components interact with deployment behavior in this way is to prevent
    any loss of data or business process interruption from the component suddenly
    being terminated. The component must include the use of IoT Greengrass `SubscribeToComponentUpdates`
    function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你的部署配置可以指定是否允许组件有一个选项来表示它们已准备好重启或更新。以这种方式让组件与部署行为交互的价值是防止组件突然终止导致数据丢失或业务流程中断。组件必须包含使用IoT
    Greengrass `SubscribeToComponentUpdates`函数的使用。
- en: A component can then respond to component update events and request a deferment
    by publishing a message back over IPC using the `DeferComponentUpdate` command.
    There is a similar operation for components to validate configuration change requests
    with `SubscribeToValidateConfigurationUpdates` and the respective `SendConfigurationValidityReport`
    features. You can learn more about these features from the *References* section
    at the end of this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以通过使用`DeferComponentUpdate`命令通过IPC发布消息来响应组件更新事件并请求延迟。对于组件使用`SubscribeToValidateConfigurationUpdates`和相应的`SendConfigurationValidityReport`功能来验证配置更改请求也有类似的操作。你可以从本章末尾的*参考*部分了解更多关于这些功能的信息。
- en: With your first remote deployment complete and with a better understanding of
    how the deployment service of IoT Greengrass works, let's make it easier to remotely
    troubleshoot your hub device and its components by enabling the publication of
    local logs to the cloud.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你第一次远程部署完成，并对IoT Greengrass的部署服务有了更好的理解，让我们通过启用将本地日志发布到云中来简化远程故障排除你的中心设备和其组件。
- en: Storing logs in the cloud
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中存储日志
- en: An edge solution loads resources from the cloud in order to bootstrap, configure,
    and generally make the local solution ready for runtime. The health of the device
    and the solution should also be reported to the cloud to assist with production
    operations. By default, your HBS hub device checks in with the cloud IoT Greengrass
    service to report connectivity status and the result of the most recent deployment.
    To get more telemetry from the edge solution, such as logs and metrics, you need
    to deploy additional components. In this section, you will deploy a managed component
    that ships component logs up to Amazon CloudWatch, a service for storing and querying
    logs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘解决方案从云中加载资源以进行引导、配置以及通常使本地解决方案为运行时做好准备。设备和解决方案的健康状况也应报告给云，以协助生产操作。默认情况下，您的
    HBS 中心设备会与云 IoT Greengrass 服务进行交互，以报告连接状态和最近部署的结果。要获取来自边缘解决方案的更多遥测数据，例如日志和指标，您需要部署额外的组件。在本节中，您将部署一个管理组件，该组件将组件日志发送到
    Amazon CloudWatch，这是一个用于存储和查询日志的服务。
- en: Storing the logs of our hub devices in the cloud is a best practice and enables
    us to triage devices individually without needing a live connection to the device
    or being physically in front of it. After all, some of these devices may be in
    rather remote locations such as the Alaskan tundra or only come online at scheduled
    times, such as the narwhal-studying submersible from [*Chapter 1*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013),
    *Introduction to the Data-Driven Edge with Machine Learning*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们中心设备的日志存储在云中是一种最佳实践，并使我们能够单独对设备进行分类，而无需与设备建立实时连接或亲自在设备前。毕竟，这些设备可能位于相当偏远的地方，如阿拉斯加苔原，或者只在预定时间上线，例如
    [*第1章*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013) 中提到的 *利用机器学习的数据驱动边缘介绍*
    的海豚研究潜水器。
- en: 'Another benefit of storing logs in the cloud is that you can run queries across
    a fleet of devices to discover insights about fleet performance. For example,
    a simplistic count of lines per device log over a 24-hour period could find outliers
    of *chatty* devices where there is an abnormal amount of activity, which could
    mean the device is processing an unusual amount of data or thrashing resources.
    The following histogram of log activity across our fleet would indicate a potential
    problem for your operations team to triage:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志存储在云中的另一个好处是，您可以在设备群中运行查询，以发现有关群集性能的见解。例如，在 24 小时期间对每个设备日志行数的简单计数可能会发现 *健谈*
    设备的异常，其中存在异常数量的活动，这可能意味着设备正在处理异常数量的数据或资源争用。以下是我们群集中日志活动的直方图可能会表明您的运营团队需要分类的问题：
- en: '![Figure 4.4 – Sample histogram showing device outliers based on log activity'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 基于日志活动的样本直方图，显示设备异常]'
- en: '](img/B17595_04_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17595_04_04.jpg)'
- en: Figure 4.4 – Sample histogram showing device outliers based on log activity
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 基于日志活动的样本直方图，显示设备异常
- en: Since storing logs is such a common use case for an edge solution and also in
    the wider spectrum of cloud application development, IoT Greengrass provides a
    managed component to make it easy to ingest your components' logs. This managed
    component, called `aws.greengrass.LogManager`, is authored and maintained by AWS.
    Managed components are anticipated as fulfilling common requirements of IoT architects
    but deemed as opt-in features that you need to bring in with your deployments.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在边缘解决方案中存储日志是一个常见的用例，并且在更广泛的云应用开发范围内也是如此，因此 IoT Greengrass 提供了一个管理组件，以便轻松摄取您的组件日志。这个名为
    `aws.greengrass.LogManager` 的管理组件由 AWS 编写和维护。管理组件预计将满足物联网架构师的常见需求，但被视为可选功能，您需要在部署时引入。
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The latest version of the `aws.greengrass.LogManager` managed component at the
    time of this writing was *2.2.0*. You may need to update the version based on
    the latest version of IoT Greengrass core software installed when you started
    this book. For the steps in [*Chapter 2*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032),
    *Foundations of Edge Workloads*, IoT Greengrass core software version *2.4.0*
    was used, which is compatible with `LogManager` *2.2.0*. You can see the latest
    dependency information in the *AWS-provided components* documentation link in
    the *References* section found at the end of this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`aws.greengrass.LogManager` 管理组件的最新版本是 *2.2.0*。您可能需要根据您开始本书时安装的 IoT Greengrass
    核心软件的最新版本来更新版本。对于 [*第2章*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032) 中 *边缘工作负载基础*
    的步骤，使用了 IoT Greengrass 核心软件版本 *2.4.0*，它与 `LogManager` *2.2.0* 兼容。您可以在本章末尾的 *参考文献*
    部分的 *AWS提供的组件* 文档链接中查看最新的依赖信息。
- en: 'In the following steps, you will revise the deployment for the `hbshubprototypes`
    group to include the `aws.greengrass.LogManager` managed component. The configuration
    for the `LogManager` component will specify which components to upload log files
    to. Then, you will use the AWS CLI to run a simple query to validate that log
    files are being stored. Proceed as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，您将修改 `hbshubprototypes` 组的部署，以包括 `aws.greengrass.LogManager` 管理组件。`LogManager`
    组件的配置将指定上传日志文件的目标组件。然后，您将使用 AWS CLI 运行一个简单的查询以验证日志文件是否正在存储。按照以下步骤操作：
- en: Edit the `chapter4/deployment-logmanager.json` file to swap the placeholder
    with your account ID. This deployment adds the `LogManager` component. Remember
    that by not specifying other components in the deployment list—such as `com.hbs.hub.HelloWithConfig`,
    which you added in a previous section—they will be removed from the device. We
    will remove `HelloWithConfig` for this deployment so that we can see the runtime
    output to the log file when we add it back. All you need to do is update the `targetArn`
    property to replace the account ID placeholder and save the file.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `chapter4/deployment-logmanager.json` 文件，将占位符替换为您的账户 ID。此部署添加了 `LogManager`
    组件。请记住，由于在部署列表中没有指定其他组件（例如在前面部分添加的 `com.hbs.hub.HelloWithConfig`），它们将从设备中删除。我们将为此部署删除
    `HelloWithConfig`，以便在将其添加回时查看日志文件的运行时输出。您需要做的只是更新 `targetArn` 属性以替换账户 ID 占位符并保存文件。
- en: 'Create a new deployment revision and pass in this new deployment configuration
    file, as follows: `aws greengrassv2 create-deployment --cli-input-json file://deployment-logmanager.json`.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的部署修订版，并传入此新的部署配置文件，如下所示：`aws greengrassv2 create-deployment --cli-input-json
    file://deployment-logmanager.json`。
- en: 'Edit the `chapter4/deployment-logmanager.json` file to once again add the `HelloWithConfig`
    component. We do this to redeploy the component so that the runtime output is
    written to the log again and will then be uploaded to the cloud. Add the following
    bolded lines into the `components` object and save the file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `chapter4/deployment-logmanager.json` 文件，再次添加 `HelloWithConfig` 组件。我们这样做是为了重新部署组件，以便将运行时输出写入日志，然后将其上传到云端。将以下加粗的行添加到
    `components` 对象中并保存文件：
- en: '[PRE6]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a new deployment revision using the same command as before, like this:
    `aws greengrassv2 create-deployment --cli-input-json file://deployment-logmanager.json`.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的相同命令创建一个新的部署修订版，如下所示：`aws greengrassv2 create-deployment --cli-input-json
    file://deployment-logmanager.json`。
- en: Once this deployment is complete, you will start seeing logs in CloudWatch Logs
    within 5 minutes since the configuration for `LogManager` specifies `300` seconds
    as the `periodicUploadIntervalSec` parameter.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此部署完成后，您将在 5 分钟内开始在 CloudWatch 日志中看到日志，因为 `LogManager` 的配置指定了 `periodicUploadIntervalSec`
    参数为 `300` 秒。
- en: 'Use the following command to check on the status of new log groups with the
    prefix: `/aws/greengrass/`: `aws logs describe-log-groups --log-group-name-prefix
    "/aws/greengrass/"`.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查带有前缀 `/aws/greengrass/` 的新日志组的状态：`aws logs describe-log-groups --log-group-name-prefix
    "/aws/greengrass/"`。
- en: 'You know logs are being written to CloudWatch when you see a response such
    as the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您看到如下响应时，您就知道日志正在写入 CloudWatch：
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can query the log group to see devices that are storing logs for this component,
    as follows: `aws logs describe-log-streams --log-group-name /aws/greengrass/UserComponent/us-west-2/com.hbs.hub.HelloWithConfig`.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以查询日志组以查看存储此组件日志的设备，如下所示：`aws logs describe-log-streams --log-group-name /aws/greengrass/UserComponent/us-west-2/com.hbs.hub.HelloWithConfig`。
- en: 'The response, as illustrated in the following code snippet, will show log streams
    named in a `/DATE/thing/THING_NAME` format:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码片段所示，响应将显示以 `/DATE/thing/THING_NAME` 格式命名的日志流：
- en: '[PRE8]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Plug the log group name into the `filter-log-events` command to see the logged
    output of the `HelloWithConfig` component, as follows: `aws logs filter-log-events
    --log-group-name /aws/greengrass/UserComponent/us-west-2/com.hbs.hub.HelloWithConfig
    --filter-pattern stdout`.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将日志组名称插入到 `filter-log-events` 命令中，以查看 `HelloWithConfig` 组件的日志输出，如下所示：`aws logs
    filter-log-events --log-group-name /aws/greengrass/UserComponent/us-west-2/com.hbs.hub.HelloWithConfig
    --filter-pattern stdout`。
- en: 'The output is as follows:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see from this series of instructions how to include the `LogManager`
    component that will automatically ship your components' log files to the cloud
    and how to use the Amazon CloudWatch Logs service to query into your logs. IoT
    Greengrass makes it easy to triage log files of one component across a fleet of
    devices by querying the log group or into individual devices by querying the log
    stream that represents one device's component. For more powerful log analysis
    tooling, you can explore Amazon CloudWatch Logs Insights for aggregation queries
    across log groups, or stream logs into an indexed querying tool such as **Amazon
    Elasticsearch**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这一系列说明中了解如何包含`LogManager`组件，该组件会自动将您的组件日志文件发送到云端，以及如何使用Amazon CloudWatch
    Logs服务查询日志。IoT Greengrass通过查询日志组或通过查询代表单个设备组件的日志流，使得跨设备群组轻松地对单个组件的日志文件进行分类。为了获得更强大的日志分析工具，您可以探索Amazon
    CloudWatch Logs Insights，用于对日志组进行聚合查询，或者将日志流式传输到索引查询工具，如**Amazon Elasticsearch**。
- en: Merging component configuration
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并组件配置
- en: 'Now is a good opportunity to introduce how to merge in component configuration
    at deployment time, which you can see we are doing in deployment with `logmanager.json`.
    If you recall from earlier recipe creation in the *Writing your first component*
    section of [*Chapter 2*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032), *Foundations
    of Edge Workloads*, the recipe can define a `ComponentConfiguration` object that
    specifies the default settings that a component will use at runtime. We used this
    to define a default `World!` text that gets passed into the `HelloWorld` component.
    This kind of component configuration can also be defined at the time of deployment
    to one or more devices to override these defaults. This is useful when setting
    the configuration for distinct groups of devices, such as telling all of our prototype
    devices to use verbose debug-level logging and our production devices to use warning-level
    logging to save on costs. Here is an illustration of that practice in effect:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是介绍如何在部署时合并组件配置的好时机，您可以在部署中使用`logmanager.json`看到我们正在这样做。如果您还记得在[*第2章*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032)“编写您的第一个组件”部分中的早期配方创建，即“边缘工作负载基础”，配方可以定义一个`ComponentConfiguration`对象，该对象指定了组件在运行时将使用的默认设置。我们使用它来定义一个默认的`World!`文本，并将其传递给`HelloWorld`组件。这种组件配置也可以在部署到一台或多台设备时定义，以覆盖这些默认设置。当设置不同设备组的配置时，这很有用，例如，告诉所有我们的原型设备使用详尽的调试级别日志记录，而我们的生产设备使用警告级别日志记录以节省成本。以下是该实践效果的说明图：
- en: '![Figure 4.5 – Overriding configuration for fleets of devices'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 覆盖设备群的配置'
- en: '](img/B17595_04_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17595_04_05.jpg)'
- en: Figure 4.5 – Overriding configuration for fleets of devices
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 覆盖设备群的配置
- en: A deployment can define component configuration using either of two properties,
    `reset` and `merge`. The `reset` property tells the component to restore the configuration
    to whatever the default is for the given configuration key. The `merge` property
    tells the component to apply a new configuration for the given configuration key,
    without affecting existing values of other configuration keys. Using both the
    `reset` and `merge` property on the same configuration key will always first reset
    the value and then merge in the new value. This can be useful for restoring a
    tree of default values and then merging in an update for just one node in the
    tree.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 部署可以使用两个属性中的任何一个来定义组件配置，即`reset`和`merge`。`reset`属性告诉组件将配置恢复到给定配置键的默认值。`merge`属性告诉组件为给定的配置键应用新的配置，而不影响其他配置键的现有值。在同一个配置键上同时使用`reset`和`merge`属性将始终首先重置值，然后合并新值。这可以用于恢复默认值的树，然后合并树中单个节点的更新。
- en: 'If you inspect the `deployment-logmanager.json` file, you can see the deployment-time
    configuration merge we are using to tell the `LogManager` component what to do.
    Here is a pretty-print version of the `merge` object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查`deployment-logmanager.json`文件，您可以看到我们正在使用的部署时配置合并，以告诉`LogManager`组件要做什么。以下是`merge`对象的格式化版本：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Without any merged configuration set in the deployment, the version 2.2.0 `LogManager`
    component used here doesn't actually do anything. You must give it some configuration
    at deployment time to get any logs sent to the cloud.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署中没有设置任何合并配置的情况下，这里使用的版本2.2.0的`LogManager`组件实际上并不做任何事情。您必须在部署时提供一些配置，才能将任何日志发送到云端。
- en: 'In the preceding sample, there is a `logsUploaderConfiguration` configuration
    key that has two child nodes and an interval property. The `systemLogsConfiguration`
    node tells the `LogManager` component to upload to Amazon CloudWatch IoT Greengrass
    system logs such as `greengrass.log`. The `componentLogsConfigurationMap` node
    tells the `LogManager` component how to selectively upload logs for your other
    components. You can see here we are defining a `com.hbs.hub.HelloWithConfig` component
    for inclusion to send logs to the cloud. You would add one object to this list
    for each component to explicitly capture logs. Two best practices to consider
    are outlined here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，有一个`logsUploaderConfiguration`配置键，它有两个子节点和一个间隔属性。`systemLogsConfiguration`节点指示`LogManager`组件将系统日志（如`greengrass.log`）上传到Amazon
    CloudWatch IoT Greengrass。`componentLogsConfigurationMap`节点告诉`LogManager`组件如何选择性地上传其他组件的日志。您可以看到，我们正在定义一个`com.hbs.hub.HelloWithConfig`组件以包含到云中发送日志。您将为每个组件添加一个对象到这个列表中，以明确捕获日志。这里概述了两个最佳实践：
- en: Generate your deployment configuration programmatically and build out the `LogManager`
    configuration based on the other components included in that deployment. A script
    in a build process that inspects the components included in your deployment can
    update the `LogManager` `componentLogsConfigurationMap` node before it gets passed
    to the `CreateDeployment` API.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式生成您的部署配置，并根据该部署中包含的其他组件构建`LogManager`配置。在构建过程中检查您的部署中包含的组件的脚本可以在将其传递给`CreateDeployment`
    API之前更新`LogManager`的`componentLogsConfigurationMap`节点。
- en: Create a thing group, such as `CommonMonitoringTools`, put all of your Greengrass
    devices in it, and set a group-level deployment configuration to capture the system
    logs in the `systemLogsConfiguration` node. All of your devices would then include
    this component and configuration, resulting in a default behavior to upload system
    logs. A separate thing group deployment that represents your application's components
    would then merge the `LogManager` configuration for the `componentLogsConfigurationMap`
    node in order to specify the logs for that application's components. This works
    because two deployments from two different thing groups can stack on a single
    device, effectively merging the configuration of a single component. *Figure 4.3*
    and *Figure 4.5* together illustrate this concept.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个事物组，例如`CommonMonitoringTools`，将所有您的Greengrass设备放入其中，并在`systemLogsConfiguration`节点中设置一个组级部署配置以捕获系统日志。您的所有设备随后将包含此组件和配置，从而实现默认行为以上传系统日志。然后，代表您的应用程序组件的单独事物组部署将合并`componentLogsConfigurationMap`节点的`LogManager`配置，以指定该应用程序组件的日志。这是因为来自两个不同事物组的两个部署可以在单个设备上堆叠，从而有效地合并单个组件的配置。*图4.3*和*图4.5*共同说明了这一概念。
- en: One last note on configuration management is addressing the delta between the
    preceding pretty-printed `deployment-logmanager.json`. At the time of this writing,
    the IoT Greengrass deployment API only accepts the configuration as a string object,
    so the configuration must be defined as JSON and then escaped as a single string
    before sending it to the deployment API. This is more inconvenient when hand-writing
    deployment files but is a simple added step when building deployments programmatically.
    An alternative, in this case, could be to define your deployment files using the
    **YAML Ain't Markup Language** (**YAML**) format instead of JSON because the YAML
    specification has syntactical support for constructing multiline inputs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于配置管理的注意事项是解决前面格式化后的`deployment-logmanager.json`之间的差异。在撰写本文时，IoT Greengrass部署API仅接受配置作为字符串对象，因此配置必须定义为JSON，然后作为单个字符串发送到部署API。当手动编写部署文件时，这会更不方便，但在以编程方式构建部署时，这是一个简单的附加步骤。在这种情况下，可以使用**YAML
    Ain't Markup Language**（**YAML**）格式而不是JSON来定义您的部署文件，因为YAML规范具有构建多行输入的语法支持。
- en: You now have a functioning, managed component for storing your hub's log files
    in the cloud to facilitate remote diagnostics for your edge solution. You know
    how to add more components to the `LogManager` component by merging in new changes
    to the configuration. Through that process, you learned more about the component
    configuration system of IoT Greengrass that will serve you as you create new components
    and build deployments with multiple components working together. In the next section,
    you will learn how leaf devices connected to your hub can exchange messages and
    synchronize the state with the cloud.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经有一个功能齐全、可管理的组件，可以将中枢的日志文件存储在云中，以便远程诊断您的边缘解决方案。您知道如何通过合并新的配置更改到配置中，向`LogManager`组件添加更多组件。通过这个过程，您了解了IoT
    Greengrass的组件配置系统，这将帮助您在创建新组件和构建由多个组件协同工作的部署时提供服务。在下一节中，您将学习如何使连接到您的中枢的叶设备交换消息并与云同步状态。
- en: Synchronizing the state between the edge and the cloud
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在边缘和云之间同步状态
- en: The HBS hub device, if made into a real product, would connect with local devices
    over a network protocol and proxy telemetry and commands with a cloud service.
    In the previous chapter, we used components running on our hub device to interface
    with local hardware interfaces on the **Raspberry Pi Sense HAT**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HBS中枢设备被制成实际产品，它将通过网络协议与本地设备连接，并代理遥测数据和命令与云服务交互。在前一章中，我们使用运行在中枢设备上的组件来与**树莓派Sense
    HAT**上的本地硬件接口进行交互。
- en: This makes sense when the hub device communicates with hardware over serial
    interfaces, but when communicating over a network, those appliance monitoring
    kits won't really be software components running on the hub device using the **Greengrass
    IPC** interface to exchange messages. Instead, they may use a network protocol
    such as **Message Queue Telemetry Transport** (**MQTT**) to exchange messages
    with the hub device over Wi-Fi or Bluetooth.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当中枢设备通过串行接口与硬件通信时，这很有意义，但当通过网络通信时，那些设备监控套件实际上并不是在枢纽设备上运行的软件组件，它们使用**Greengrass
    IPC**接口交换消息。相反，它们可能使用网络协议，如**消息队列遥测传输**（**MQTT**），通过Wi-Fi或蓝牙与枢纽设备交换消息。
- en: In this section, you will deploy new managed components for connecting to leaf
    devices over MQTT and synchronize the state of a leaf device's telemetry to the
    cloud.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将部署新的管理组件，通过MQTT连接到叶设备，并将叶设备的遥测状态同步到云。
- en: Introduction to device shadows
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备阴影简介
- en: By synchronizing state, we mean the end result of keeping two systems up to
    date with the latest value. When working with the edge and cloud, we must acknowledge
    and work with the reality that edge solutions may not currently be connected to
    the cloud service. Our leaf devices and the hub device may work with acquired
    telemetry that has yet to be reported to the cloud. Once the hub device restores
    the connection with the cloud, there must be a mechanism for reconciling the current
    state of the edge and the current state of the cloud.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过同步状态，我们指的是保持两个系统与最新值保持一致的结果。当与边缘和云一起工作时，我们必须承认并处理这样一个现实：边缘解决方案可能目前尚未连接到云服务。我们的叶设备和中枢设备可能正在使用尚未报告给云的已获取遥测数据。一旦中枢设备恢复与云的连接，就必须有一种机制来协调边缘和云的当前状态。
- en: For example, if our hub device is disconnected from the cloud because of a network
    drop, new telemetry will be acquired by the leaf devices and new remote commands
    could be queued up from the cloud service from the customer's mobile application.
    When the connection is restored, something needs to update the device state so
    that everything gets back in sync. For this purpose, AWS IoT Core offers a service
    called **Device Shadow** that acts as a synchronization mechanism for devices
    and the cloud. IoT Greengrass makes this Device Shadow service available at the
    edge via a managed component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的中枢设备因网络中断而与云断开连接，叶设备将获取新的遥测数据，并且来自云服务的新的远程命令可能已在客户的移动应用程序中排队。当连接恢复时，需要更新设备状态，以便一切都能同步。为此，AWS
    IoT Core提供了一种名为**设备阴影**的服务，该服务作为设备和云之间的同步机制。IoT Greengrass通过一个管理组件在边缘提供这种设备阴影服务。
- en: 'A device shadow is a JSON document that summarizes the current state of reported
    data and the desired state. Typically, this means that the device is responsible
    for updating the reported data, and other actors in the system instruct the device
    using the desired state. Let''s say our hub device is supposed to keep the cloud
    informed of the latest temperature measurement from one of the appliance monitoring
    kits. Let''s also say that the customer''s mobile application can send a command
    to restart the monitoring kit as a form of troubleshooting. The following diagram
    illustrates how these messages are stored in the device shadow and reconciled
    after resuming from a network drop event:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设备影子是一个JSON文档，它总结了报告数据的当前状态和期望状态。通常这意味着设备负责更新报告的数据，而系统中的其他参与者则使用期望状态来指导设备。假设我们的中心设备应该将来自某个设备监控套件的最新温度测量值通知云。再假设客户的移动应用程序可以发送一个命令来重启监控套件，作为故障排除的一种形式。以下图表说明了这些消息如何在设备影子中存储，并在从网络中断事件恢复后进行协调：
- en: '![Figure 4.6 – Flow of shadow messages synchronizing after a network disruption'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 网络中断后同步的影子消息流'
- en: '](img/B17595_04_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17595_04_06.jpg]'
- en: Figure 4.6 – Flow of shadow messages synchronizing after a network disruption
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 网络中断后同步的影子消息流
- en: Device shadows are also useful for our edge ML workloads since a component running
    an inference task can subscribe to changes reported by the shadow service, or
    even register its own shadow for exchanging state and commands with the cloud
    and other components running on the Greengrass device.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 设备影子对于我们的边缘机器学习工作负载也非常有用，因为运行推理任务的组件可以订阅影子服务报告的变化，或者甚至注册自己的影子，以便与云和其他在Greengrass设备上运行的组件交换状态和命令。
- en: 'In the *Connecting your first device: sensing at the edge* and *Connecting
    your second device: actuating at the edge* sections of [*Chapter 3*](B17595_03_Final_SS_ePub.xhtml#_idTextAnchor052),
    *Building the Edge*, you implemented IPC in order to let components exchange information
    in real time. Shadows can level up your edge solutions by defining synchronized
    state documents that also get communicated over IPC or even synchronized with
    the cloud. This opens up some interesting use cases that further let you as the
    architect focus on solving business problems without also engineering mechanisms
    for data exchange. Here are a few examples of how ML workloads running as edge
    components can benefit from using shadows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B17595_03_Final_SS_ePub.xhtml#_idTextAnchor052)的“连接您的第一个设备：边缘感知”和“连接您的第二个设备：边缘执行”部分中，您在“构建边缘”部分实现了IPC，以便组件能够实时交换信息。影子可以通过定义同步状态文档来提升您的边缘解决方案，这些文档也可以通过IPC进行通信，甚至与云同步。这为一些有趣的使用案例打开了大门，进一步让您作为架构师专注于解决业务问题，而无需同时设计数据交换机制。以下是一些边缘组件运行的机器学习工作负载如何从使用影子中受益的例子：
- en: '**Reporting and caching application state**: Your ML inference component can
    create a local shadow that stores the latest inference results whenever the ML
    model is used to process new data. If the model is trained to report when there
    is an anomaly detected on new data, the local shadow could store the latest anomaly
    score and confidence rating. That way, other components on the device can subscribe
    to changes in the shadow and alter their behavior based on the output of the ML
    component. This may seem similar to publishing updates over IPC, but the key difference
    here is that components can get values from the shadow whether or not they were
    running at the same time as when the ML component last published the anomaly score.
    In that sense, the shadow is used as a caching mechanism and helps us decouple
    our edge solution.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告和缓存应用程序状态**：您的机器学习推理组件可以在每次使用机器学习模型处理新数据时创建一个本地影子，以存储最新的推理结果。如果模型被训练来报告在新的数据中检测到异常时，本地影子可以存储最新的异常分数和置信度评级。这样，设备上的其他组件可以订阅影子中的变化，并根据机器学习组件的输出改变其行为。这看起来可能类似于通过IPC发布更新，但这里的关键区别是，组件可以从影子中获取值，无论它们是否与机器学习组件上次发布异常分数时同时运行。从这个意义上说，影子被用作缓存机制，帮助我们解耦我们的边缘解决方案。'
- en: '**Sending commands to components**: Shadows can be used to instruct components
    of new commands or desired behavior, even if the component is not currently running.
    For example, if a component crashes or is in some other recovery state at the
    time a command would have otherwise been sent to it, putting that command in a
    shadow ensures it will be delivered to the component when it next enters its running
    state. Combined with synchronizing shadows to the cloud AWS IoT Core service,
    this enables other applications and devices to interact with components at the
    edge in a resilient way.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向组件发送命令**：即使组件当前未运行，也可以使用阴影来指示组件的新命令或期望的行为。例如，如果组件在命令本应发送给它的时间崩溃或处于某种其他恢复状态，将此命令放入阴影中可以确保它在组件下次进入运行状态时被传递。结合将阴影同步到云AWS
    IoT Core服务，这使其他应用程序和设备能够以弹性方式与边缘的组件交互。'
- en: Now that we have introduced state synchronization with shadows, let's move on
    to the hands-on steps for deploying this functionality to your solution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了与阴影的状态同步，让我们继续进行将此功能部署到您的解决方案中的实际步骤。
- en: Steps to deploy components for state synchronization
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署状态同步组件的步骤
- en: IoT Greengrass provides the functionality for connecting leaf devices, storing
    shadows, and synchronizing messages to the cloud with a few separate managed components.
    Those components are an `aws.greengrass.clientdevices.mqtt.Moquette`), `aws.greengrass.ShadowManager`),
    and an `aws.greengrass.clientdevices.mqtt.Bridge`), respectively.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: IoT Greengrass提供了一些分离的托管组件的功能，用于连接叶设备、存储阴影和将消息同步到云。这些组件分别是`aws.greengrass.clientdevices.mqtt.Moquette`）、`aws.greengrass.ShadowManager`）和`aws.greengrass.clientdevices.mqtt.Bridge`）。
- en: 'The following diagram illustrates the architecture of this solution and how
    these components work together to deliver state synchronization for devices:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了此解决方案的架构以及这些组件如何协同工作以实现设备的状态同步：
- en: '![Figure 4.7 – Examples of message flows using managed components'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – 使用托管组件的消息流示例'
- en: '](img/B17595_04_07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17595_04_07.jpg)'
- en: Figure 4.7 – Examples of message flows using managed components
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 使用托管组件的消息流示例
- en: 'By following the next steps of this section, you will create a new deployment
    that enables all three of these managed components to launch a new standalone
    application on your C2 system that connects to your hub device over MQTT and observe
    how the state is synchronized between the edge and the cloud using these features.
    Proceed as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本节的下一步，您将创建一个新的部署，使所有这三个托管组件能够在您的C2系统上启动一个新的独立应用程序，该应用程序通过MQTT连接到您的网关设备，并观察使用这些功能在边缘和云之间如何同步状态。按照以下步骤进行：
- en: 'Update your Greengrass role in AWS IAM to allow the use of the device shadow
    APIs of AWS IoT Core. These steps are specific to AWS IAM and represent a common
    flow of preparing your Greengrass device to use new APIs. Then, do the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS IAM中更新您的Greengrass角色，以允许使用AWS IoT Core的设备阴影API。这些步骤是针对AWS IAM的，代表了一种常见的流程，用于准备您的Greengrass设备使用新API。然后，执行以下操作：
- en: 'From the `chapter4` directory, create a new IAM policy, as follows: `aws iam
    create-policy --policy-name greengrass-use-shadows --policy-document file://greengrass_use_shadows.json
    --description "Allows Greengrass cores to interact with AWS IoT Core device shadows"`.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`chapter4`目录中，创建一个新的IAM策略，如下所示：`aws iam create-policy --policy-name greengrass-use-shadows
    --policy-document file://greengrass_use_shadows.json --description "允许Greengrass核心与AWS
    IoT Core设备阴影交互"`。
- en: 'Copy the policy ARN from the response of the `create-policy` command and use
    it in the `attach-role-policy` command next. It will look like this, but with
    your account number instead: `arn:aws:iam::01234567890:policy/Greengrass-use-shadows`.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`create-policy`命令的响应中复制策略ARN，并在下一个`attach-role-policy`命令中使用它。它看起来像这样，但用您的账户号替换：`arn:aws:iam::01234567890:policy/Greengrass-use-shadows`。
- en: 'Attach the new policy to your Greengrass IAM role, replacing the `policy-arn`
    argument with your own from the previous step, as follows: `aws iam attach-role-policy
    --role-name GreengrassV2TokenExchangeRole --policy-arn arn:aws:iam::01234567890:policy/Greengrass-use-shadows`.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新策略附加到您的Greengrass IAM角色，将上一个步骤中的`policy-arn`参数替换为您自己的，如下所示：`aws iam attach-role-policy
    --role-name GreengrassV2TokenExchangeRole --policy-arn arn:aws:iam::01234567890:policy/Greengrass-use-shadows`。
- en: Edit the `deployment-syncstate.json` file to update the `targetArn` property
    for your account ID. Save the file.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`deployment-syncstate.json`文件以更新您的账户ID的`targetArn`属性。保存文件。
- en: Create a new deployment using the `deployment-syncstate.json` file. Confirm
    the deployment is complete and successful before moving on to the next step. You
    can use the `list-effective-deployments` AWS CLI command to verify or check the
    status in the AWS IoT Greengrass management console at [https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`deployment-syncstate.json`文件创建一个新的部署。在继续下一步之前，请确认部署已完成且成功。您可以使用`list-effective-deployments`
    AWS CLI命令验证或检查在AWS IoT Greengrass管理控制台中的状态，该控制台位于[https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot)。
- en: 'Launch the `local device` client to connect to your hub device over MQTT. From
    the `chapter4/apps` directory of the GitHub repository, run the following command:
    `./client.sh`.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`本地设备`客户端以通过MQTT连接到您的网关设备。从GitHub仓库的`chapter4/apps`目录中，运行以下命令：`./client.sh`。
- en: The script at `apps/client.sh` uses your AWS credentials to register a new device
    in AWS IoT Core, downloads a generated `x.509` private key and certificate, and
    adds the device to the list of associated devices for your Greengrass core. It
    then installs the AWS IoT Device SDK for Python and launches a Python application
    that discovers your hub device on the local network and connects to it for exchanging
    messages over MQTT. The purpose of running this application off of the hub device
    is to demonstrate how Greengrass supports exchanging messages for local devices.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`apps/client.sh`脚本使用您的AWS凭据在AWS IoT Core中注册一个新设备，下载生成的`x.509`私钥和证书，并将设备添加到Greengrass核心关联设备列表中。然后，它安装AWS
    IoT Device SDK for Python并启动一个Python应用程序，该应用程序在本地网络上发现您的网关设备并与之连接，以通过MQTT交换消息。运行此应用程序的目的是演示Greengrass如何支持本地设备的消息交换。'
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If your C2 laptop is not on the same network as your hub device, you can run
    the client application on your hub device. However, you will need to update the
    permissions for the `idtgg` AWS user that was configured on the hub device since
    it does not have the necessary permissions yet. Return to the AWS management console
    for IAM, find the user group named `Provision-IDT-Greengrass`, add a new permission
    by attaching a policy, and choose the policy named `AWSIoTFullAccess`. Then, you
    can run the `client.sh` application on your hub device using the existing credentials
    there from [*Chapter 2*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032), *Foundations
    of Edge Workloads*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的C2笔记本电脑与您的网关设备不在同一网络中，您可以在您的网关设备上运行客户端应用程序。但是，您需要更新在网关设备上配置的`idtgg` AWS用户的权限，因为它还没有必要的权限。返回AWS管理控制台中的IAM，找到名为`Provision-IDT-Greengrass`的用户组，通过附加策略添加新的权限，并选择名为`AWSIoTFullAccess`的策略。然后，您可以使用那里现有的凭据在您的网关设备上运行`client.sh`应用程序，这些凭据可以在[*第2章*](B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032)的*边缘工作负载基础*中找到。
- en: 'The `client.sh` application will publish new messages on a topic dedicated
    to device shadow communications. The topic address is `$aws/things/localdevice/shadow/update`.
    The client reports a randomly generated temperature value as if it were another
    sensor on the local network. You can verify that these messages are making it
    up to the cloud by using the AWS IoT Core management console at [https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot).
    Navigate to `$aws/things/localdevice/shadow/update/accepted` topic to see the
    result of the publishing. Here is an example of what it looks like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.sh`应用程序将在一个专门用于设备影子通信的主题上发布新消息。主题地址是`$aws/things/localdevice/shadow/update`。客户端报告一个随机生成的温度值，就像它是本地网络上的另一个传感器一样。您可以使用AWS
    IoT Core管理控制台在[https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot)验证这些消息是否已上传到云端。导航到`$aws/things/localdevice/shadow/update/accepted`主题以查看发布的结果。以下是一个示例：'
- en: '![Figure 4.8 – Screenshot from AWS IoT Core console of the accepted shadow
    update'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 – AWS IoT Core控制台接受的影子更新的截图'
- en: '](img/B17595_04_08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 – AWS IoT Core控制台接受的影子更新的截图'
- en: Figure 4.8 – Screenshot from AWS IoT Core console of the accepted shadow update
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – AWS IoT Core控制台接受的影子更新的截图
- en: 'You can interact with the local device application through this test client,
    too. You can send a new desired state to the local device and it will merge the
    command into the next reported message. Use the MQTT test client to publish a
    message on the `$aws/things/localdevice/shadow/update` topic with this body: `{"state":{"desired":{"valve":"open"}}}`.
    You should see on your subscription and in the standard output of the `client.sh`
    application activity that it shows the open valve now in the reported state instead
    of the desired state. This means the local device received a command through Greengrass,
    processed the command, and updated its reported state accordingly.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过这个测试客户端与本地设备应用程序进行交互。您可以向本地设备发送一个新的期望状态，并且它将合并命令到下一个报告消息中。使用MQTT测试客户端在`$aws/things/localdevice/shadow/update`主题上发布一条消息，内容如下：`{"state":{"desired":{"valve":"open"}}}`。您应该在您的订阅和在`client.sh`应用程序的标准输出中看到，现在报告状态中的阀门是打开的，而不是期望状态。这意味着本地设备通过Greengrass接收到了命令，处理了该命令，并相应地更新了其报告状态。
- en: You can continue experimenting with this by publishing further messages to the
    desired state through the MQTT test client. A real device would take some action
    in response to the desired state, but this application just copies the command
    from the desired state to the reported state to simulate handling the event.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在MQTT测试客户端中发布更多消息到期望状态来继续实验。实际设备会对期望状态做出一些响应，但此应用程序只是将命令从期望状态复制到报告状态，以模拟处理事件。
- en: To demonstrate the functionality of the MQTT bridge managed component, the `client.py`
    application is also publishing a heartbeat message on another topic at the `dt/localdevice/heartbeat`
    address. The reason for this is that the Shadow Manager component actually handles
    all the synchronization of state for us when using the shadow topics. For any
    other topics and data published, such as this heartbeat behavior, we must use
    the MQTT bridge component to ferry messages from the edge to the cloud (or vice
    versa). Use the MQTT test client to subscribe on `dt/localdevice/heartbeat` to
    see these messages arrive in the cloud.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示MQTT桥接管理组件的功能，`client.py`应用程序也在`dt/localdevice/heartbeat`地址的另一个主题上发布心跳消息。这样做的原因是，当使用影子主题时，影子管理器组件实际上为我们处理了所有状态同步。对于任何其他主题和数据发布，例如这个心跳行为，我们必须使用MQTT桥接组件将消息从边缘传输到云（或反之亦然）。使用MQTT测试客户端订阅`dt/localdevice/heartbeat`以查看这些消息在云中到达。
- en: Something fun to try is to take your hub device offline temporarily and repeat
    the previous step but set the desired state of the valve to `closed`. This will
    demonstrate how the shadow service messages are buffered for delivery the next
    time the Greengrass device comes back online. On your hub device, bring down the
    network connection (either by unplugging the Ethernet cable or disabling Wi-Fi).
    You should see no more messages arriving on either the shadow or heartbeat topics
    in the MQTT test client. Publish a new message in the MQTT test client, such as
    `{"state":{"desired":{"valve":"open"}}}`, and then bring the network connection
    back up. You will see the local device get the new command once the hub device
    reestablishes connectivity as well as a resumption of the heartbeat messages.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一些有趣的事情，比如暂时将您的中心设备离线，并重复之前的步骤，但将阀门期望状态设置为`关闭`。这将演示当Greengrass设备下次上线时，影子服务消息是如何缓冲以供发送的。在您的中心设备上，断开网络连接（无论是通过拔掉以太网电缆还是禁用Wi-Fi）。您应该不会在MQTT测试客户端的影子或心跳主题上看到任何消息到达。在MQTT测试客户端中发布一条新消息，例如`{"state":{"desired":{"valve":"open"}}}`，然后恢复网络连接。您将看到，一旦中心设备重新建立连接，本地设备将接收到新的命令，以及心跳消息的恢复。
- en: Extending the managed components
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展管理组件
- en: The deployed example uses components managed by AWS to establish connectivity
    for local devices over an MQTT broker, sending and receiving messages between
    the edge and the cloud, and synchronizing state with the device's shadow service.
    You can configure these components for your own use cases by merging further configuration
    updates. Let's examine the configuration used in this deployment, then review
    a few more options and best practices.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的示例使用AWS管理的组件，通过MQTT代理为本地设备建立连接，在边缘和云之间发送和接收消息，并与设备的影子服务同步状态。您可以通过合并进一步的配置更新来为您的用例配置这些组件。让我们检查此部署中使用的配置，然后回顾一些更多选项和最佳实践。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For any configuration JSON reviewed in this section, the book is using a pretty-print
    format that doesn't match what you see in the actual deployment files where JSON
    is *stringified* and escaped per the API requirements. This is done for convenience
    and legibility in the book format.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节中审查的任何配置JSON，本书使用的是一种美观打印格式，这与您在实际上部署的文件中看到的格式不匹配，其中JSON根据API要求进行了字符串化和转义。这是为了在书籍格式中方便和易于阅读而进行的。
- en: Shadow Manager
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阴影管理器
- en: 'In the `aws.greengrass.ShadowManager` component configuration of the `deployment-syncstate.json`
    file, we must explicitly define which device shadows will be kept in sync between
    the edge and cloud. The configuration we used defined the shadow to synchronize
    for a device named `localdevice` that matches the client ID of the `apps/client.sh`
    application. Here is the configuration used to achieve that:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`deployment-syncstate.json`文件的`aws.greengrass.ShadowManager`组件配置中，我们必须明确指定哪些设备阴影将在边缘和云之间保持同步。我们使用的配置定义了名为`localdevice`的设备阴影，该设备阴影与`apps/client.sh`应用程序的客户端ID相匹配。以下是实现该配置的配置示例：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A **classic shadow** is a root-level shadow for any device in AWS IoT Core.
    **Named shadows** are children that belong to the device, and a device can have
    any number of additional children shadows to help with **separation of concerns**
    (**SoC**). In this case, just using a classic shadow is sufficient.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**经典阴影**是AWS IoT Core中任何设备的根级阴影。**命名阴影**是属于设备的子项，一个设备可以有任意数量的附加子阴影来帮助**关注点分离**（**SoC**）。在这种情况下，仅使用经典阴影就足够了。'
- en: For each device you want your Greengrass solution to keep in sync, you would
    need the configuration to specify that device in the list of `shadowDocuments`
    where `thingName` is the name of your device that it uses to connect over MQTT
    (AWS IoT Core defines many resources and APIs representing devices as *things*
    per the IoT moniker).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您希望Greengrass解决方案保持同步的每个设备，您需要配置来指定该设备在`shadowDocuments`列表中，其中`thingName`是您用于通过MQTT（AWS
    IoT Core根据物联网的命名约定定义了许多资源和服务API，将设备表示为*事物*）连接的设备名称。
- en: 'Your Greengrass core device is itself a thing registered in AWS IoT Core and
    can use both classic and named shadows. These shadows can be used for representing
    the state of the hub device itself or for components on the hub device to behave
    in coordination with some desired command; for example, sending the desired state
    to the hub device''s shadow to enter a low bandwidth state could get picked up
    by any components running on the device to act accordingly. Enabling shadow synchronization
    for your Greengrass core device has a separate configuration outside of the `shadowDocuments`
    property. Here is an example of how that could look:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Greengrass核心设备本身是在AWS IoT Core中注册的事物，可以使用经典和命名阴影。这些阴影可以用来表示中心设备本身的状态，或者用于中心设备上的组件与某些期望的命令进行协调；例如，将期望状态发送到中心设备的阴影以进入低带宽状态可能会被设备上运行的任何组件捕获并相应地执行。为您的Greengrass核心设备启用阴影同步需要在`shadowDocuments`属性之外进行单独的配置。以下是一个示例：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This section covered what you need to know about shadows in AWS IoT Core and
    how to configure the Shadow Manager component. Next, let's review the MQTT bridge
    component.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了您需要了解的AWS IoT Core中阴影的相关知识以及如何配置阴影管理器组件。接下来，让我们回顾MQTT桥接组件。
- en: MQTT bridge
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MQTT桥接
- en: 'The `aws.greengrass.clientdevices.mqtt.Bridge` component is responsible for
    relaying messages between the three kinds of messaging channels supported by Greengrass.
    The three kinds of messaging channels are listed here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws.greengrass.clientdevices.mqtt.Bridge`组件负责在Greengrass支持的三个消息通道之间中继消息。这三种消息通道如下所示：'
- en: Local IPC topics that components use for messaging
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件用于消息的本地IPC主题
- en: Local MQTT topics enabled by the Moquette MQTT broker component
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moquette MQTT代理组件启用的本地MQTT主题
- en: Cloud MQTT topics from using AWS IoT Core
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS IoT Core的云MQTT主题
- en: Configuring the MQTT bridge enables you to create flows of messages from a topic
    on one channel across the boundary to a topic on another channel—for example,
    copying messages published on the `dt/device1/sensors` IPC topic to the `dt/sensors/all`
    AWS IoT Core topic for cloud ingestion.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 配置MQTT桥接功能使您能够创建消息流，从一个通道的主题跨越边界到另一个通道的主题——例如，将发布在`dt/device1/sensors` IPC主题上的消息复制到`dt/sensors/all`
    AWS IoT Core主题，以便进行云摄入。
- en: 'Similar to the Shadow Manager component, each mapping of source and destination
    topics must be explicitly defined in the component''s configuration. To enable
    the heartbeat messages arriving from the `client.sh` application to the cloud,
    we used the following configuration in the MQTT bridge:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与影子管理组件类似，必须在组件的配置中显式定义源和目标主题的每个映射。为了使来自`client.sh`应用程序的心跳消息到达云端，我们在MQTT网桥中使用了以下配置：
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rather than create one mapping for every single device that used the heartbeat
    pattern, you could make use of MQTT wildcards and update the topic to `dt/+/heartbeat`.
    The best practice is to explicitly define one mapping for each expected device
    and avoid wildcards unless you have a use case where devices may be migrating
    between multiple gateway devices and cannot predict specifically which devices
    may be publishing. Wildcards are great for simplifying manually typed configuration
    and for legibility but introduce a risk of unanticipated behavior. Wildcards are
    also not supported for the `Pubsub` type of topic used for IPC.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每个使用心跳模式的设备创建一个映射，你可以使用MQTT通配符并将主题更新为`dt/+/heartbeat`。最佳实践是为每个预期的设备显式定义一个映射，除非你有设备可能在多个网关设备之间迁移且无法具体预测哪些设备可能会发布的情况，否则应避免使用通配符。通配符非常适合简化手动输入的配置和可读性，但会引入不可预见行为的风险。通配符也不支持用于IPC的`Pubsub`类型主题。
- en: 'Here is another example of using an MQTT bridge to allow delivery of commands
    from other AWS IoT Core devices or applications directly to a component running
    on a Greengrass core. The idea of this example is how we might update the settings
    of all ML-powered components to adjust the rate at which models are used in inference
    activities. Components subscribed over IPC to the topic can receive updates without
    requiring a full Greengrass deployment:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个使用MQTT网桥允许从其他AWS IoT Core设备或应用程序直接向运行在Greengrass核心上的组件发送命令的示例。这个示例的目的是展示我们如何更新所有基于机器学习的组件的设置，以调整推理活动中模型的使用率。订阅了IPC主题的组件可以接收更新，而无需进行完整的Greengrass部署：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You have now finished deploying managed components for the purposes of moving
    messages back and forth between the edge and the cloud. This functionality creates
    a path for local devices to communicate with each other through the hub device,
    for components to interact with cloud services, and any other combination of local
    devices, components, and the cloud exchanging messages. You also learned how AWS
    IoT Core and the Device Shadow service work to synchronize the state for local
    devices and components built on the underlying messaging systems. These tools
    enable you to build edge ML solutions with any kind of messaging requirements
    without writing any code or managing infrastructure for your messaging needs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了部署用于在边缘和云端之间来回移动消息的管理组件。这个功能为本地设备通过中心设备相互通信、组件与云服务交互以及任何其他本地设备、组件和云之间交换消息的组合创建了一条路径。你还学习了AWS
    IoT Core和设备影子服务如何同步基于底层消息系统的本地设备和组件的状态。这些工具使你能够在不编写任何代码或管理消息需求的基础设施的情况下，根据任何类型的消息要求构建边缘机器学习解决方案。
- en: In the next section, you will deploy your first ML model using a combination
    of prebuilt models, inference code, and a custom component for acting on inference
    results.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将使用预构建的模型、推理代码和用于对推理结果采取行动的自定义组件的组合来部署你的第一个机器学习模型。
- en: Deploying your first ML model
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署你的第一个机器学习模型
- en: Now that you are familiar with remote deployments and loading resources from
    the cloud, it is time to deploy your first ML-powered capability to the edge!
    After all, a component making use of ML models is much like other components we
    have deployed. It is a combination of dependencies, runtime code, and static resources
    that are hosted in the cloud.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了远程部署和从云端加载资源，是时候将你的第一个基于机器学习的功能部署到边缘了！毕竟，一个使用机器学习模型的组件就像我们部署的其他组件一样。它是由托管在云端的依赖项、运行时代码和静态资源组合而成的。
- en: Reviewing the ML use case
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查机器学习用例
- en: In this case, the dependencies are packages and libraries for using `OpenCV`
    (an open source library for **computer vision** (**CV**) use cases) and the **Deep
    Learning Runtime** (**DLR**), the runtime code is a preconfigured sample of inference
    code that uses DLR, and the static resources are a preconfigured model store for
    image classification and some sample images. The components deployed in this example
    are all provided and managed by AWS.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，依赖项是用于 `OpenCV`（一个用于计算机视觉（**CV**）用例的开源库）和 **深度学习运行时**（**DLR**）的包和库，运行时代码是使用
    DLR 的预配置推理代码样本，静态资源是预配置的图像分类模型存储和一些示例图像。本例中部署的组件全部由 AWS 提供和管理。
- en: The solution that you will deploy simulates the use case for our HBS device
    hub that performs a simple image classification as part of a home security story
    for our customers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您将部署的解决方案模拟了我们 HBS 设备中心的使用案例，该中心作为我们客户家庭安全故事的一部分执行简单的图像分类。
- en: 'Let''s say an add-on device that HBS customers can buy for their hub is a security
    camera that notifies the customer when a person has approached the front door.
    A camera device takes a picture on an interval or paired with a motion sensor
    and stores that image as a file on the hub device. The hub device then performs
    an inference against that image using a local ML model to identify if any person
    is detected. If so, an audio notification can be played on the hub device or a
    text notification sent to the customer. Here is an illustration of the solution
    and its parts:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个附加设备，HBS 客户可以为其中心购买的是一款安全摄像头，当有人接近前门时，它会通知客户。摄像头设备会定时拍照或与运动传感器配对，并将该图像作为文件存储在中心设备上。然后，中心设备使用本地机器学习模型对该图像进行推理，以识别是否检测到任何人。如果是这样，可以在中心设备上播放音频通知或将文本通知发送给客户。以下是解决方案及其各部分的示意图：
- en: '![Figure 4.9 – Sample architecture for audio notification of subject recognized
    by the camera'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 通过摄像头识别的受识别主题的音频通知示例架构'
- en: '](img/B17595_04_09.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17595_04_09.jpg)'
- en: Figure 4.9 – Sample architecture for audio notification of subject recognized
    by the camera
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 通过摄像头识别的受识别主题的音频通知示例架构
- en: Today, this kind of security capability has many products in the market. However,
    what is not yet common is performing the ML inference at the edge. This presents
    a key opportunity for differentiation because the **total cost of ownership**
    (**TCO**) goes down by saving bandwidth on image transfer to the cloud and saving
    the compute costs of running the ML inference in the cloud. The security solution
    will remain operational even if the customer's internet service is disrupted and
    has no dependency on the availability of a cloud service. There are also tangible
    benefits for processing and notification latency, as well as a privacy story that
    appeals to customers since any image data is kept locally.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，这种安全功能在市场上有很多产品。然而，尚未普及的是在边缘执行机器学习推理。这提供了一个关键的区别机会，因为通过节省图像传输到云端的带宽和节省在云端运行机器学习推理的计算成本，**总拥有成本**（**TCO**）会降低。即使客户的互联网服务中断，安全解决方案也能保持运行，并且不依赖于云服务的可用性。处理和通知延迟也有实际的好处，以及一个吸引客户的隐私故事，因为任何图像数据都保留在本地。
- en: 'This use case demonstrates all four of the key benefits for ML deployed to
    the edge that we covered in [*Chapter 1*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013),
    *Introduction to the Data-Driven Edge with Machine Learning*: latency, availability,
    cost, and governance.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本用例演示了我们已在 [*第 1 章*](B17595_01_Final_SS_ePub.xhtml#_idTextAnchor013) 中介绍的数据驱动边缘机器学习的四个关键优势：延迟、可用性、成本和治理。
- en: Steps to deploy the ML workload
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署机器学习工作负载的步骤
- en: The steps to take for this section are pretty simple, thanks to the managed
    components provided by AWS. There are three components to deploy from the AWS
    catalog and one more custom component to process the inference results. Since
    the target prototype hardware of Raspberry Pi and Sense HAT does not include any
    camera interface, we will lean on the sample image provided in the managed component
    to emulate the sensor. The one custom component serves as our actuator, and it
    will display the inference results on the **light-emitting diode** (**LED**).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本节所需采取的步骤相当简单，多亏了 AWS 提供的托管组件。需要从 AWS 目录部署三个组件，以及一个额外的自定义组件来处理推理结果。由于目标原型硬件
    Raspberry Pi 和 Sense HAT 不包括任何摄像头接口，我们将依赖托管组件中提供的示例图像来模拟传感器。一个自定义组件作为我们的执行器，它将在**发光二极管**（**LED**）上显示推理结果。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not using the target Raspberry Pi and Sense HAT hardware, you must
    alter the steps to use the `com.hbs.hub.ScrollMessageSimulated` component instead.
    Alternatively, you can view inference results using the AWS IoT Core management
    console (covered in *Step 5*), any other MQTT client connecting to AWS IoT Core
    (subscribe to the topic marked in *Step 5*), or review the inference component
    logs (locally on the device or add these logs to the `LogManager` configuration).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用目标Raspberry Pi和Sense HAT硬件，您必须修改步骤以使用 `com.hbs.hub.ScrollMessageSimulated`
    组件。或者，您可以使用AWS IoT Core管理控制台（在第 *5步* 中介绍）查看推理结果，任何连接到AWS IoT Core的其他MQTT客户端（订阅在第
    *5步* 中标记的主题），或查看推理组件日志（在设备本地或将这些日志添加到 `LogManager` 配置中）。
- en: 'The following steps deploy the ML solution to the hub device:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将机器学习解决方案部署到中心设备：
- en: 'Update the Raspberry Pi to install OpenCV dependencies. We are taking a shortcut
    here by manually installing dependencies instead of adding complexity to the example
    (more on this after the steps). Other target platforms should only need `glibc`
    installed, and the managed components will install dependencies as needed. Open
    an `ssh` connection to your Pi or open the Terminal program directly on the device.
    Run the following command: `sudo apt-get install libopenjp2-7 libilmbase23 libopenexr-dev
    libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libgtk-3-0 libwebp-dev`.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Raspberry Pi更新为安装OpenCV依赖项。我们在这里通过手动安装依赖项来简化步骤，而不是增加示例的复杂性（更多内容将在步骤之后介绍）。其他目标平台可能只需要安装
    `glibc`，而托管组件将根据需要安装依赖项。打开到您的Pi的 `ssh` 连接或直接在设备上打开终端程序。运行以下命令：`sudo apt-get install
    libopenjp2-7 libilmbase23 libopenexr-dev libavcodec-dev libavformat-dev libswscale-dev
    libv4l-dev libgtk-3-0 libwebp-dev`。
- en: Create a new custom component in your AWS account from the book repository's
    source for the `com.hbs.hub.ScrollMessage` component. These are the same *1-4
    steps* from the *Registering a component in IoT Greengrass* section. Upload the
    `archive.zip` file for this component to S3, edit the recipe file to point at
    your artifact in S3, then register the new custom component.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的AWS账户中从书籍仓库的源创建一个新的自定义组件，用于 `com.hbs.hub.ScrollMessage` 组件。这些步骤与 *在IoT Greengrass中注册组件*
    部分的 *1-4步骤* 相同。将此组件的 `archive.zip` 文件上传到S3，编辑配方文件以指向S3中的工件，然后注册新的自定义组件。
- en: Edit the `deployment-ml.json` file to update the `targetArn` property, as in
    past sections. Save the file.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `deployment-ml.json` 文件以更新 `targetArn` 属性，如过去章节中所述。保存文件。
- en: 'Create a new deployment using the `deployment-ml.json` file, as follows: `aws
    greengrassv2 create-deployment --cli-input-json file://deployment-ml.json`.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `deployment-ml.json` 文件创建一个新的部署，如下所示：`aws greengrassv2 create-deployment
    --cli-input-json file://deployment-ml.json`。
- en: When the deployment concludes (it can possibly take a few hours to install the
    bundled DLR dependencies on the Pi), you should start seeing new inference results
    appear on your Sense HAT LED matrix. For readers not using the Raspberry Pi with
    Sense HAT, you can view results using the AWS IoT Core management console. Log
    in to [https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot),
    navigate to `ml/dlr/image-classification` ML inference topic.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当部署完成时（在Pi上安装捆绑的DLR依赖项可能需要几个小时），您应该开始在您的Sense HAT LED矩阵上看到新的推理结果。对于不使用带有Sense
    HAT的Raspberry Pi的读者，您可以使用AWS IoT Core管理控制台查看结果。登录到 [https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot)，导航到
    `ml/dlr/image-classification` 机器学习推理主题。
- en: 'If you are using the AWS IoT Core console or an MQTT client to check the inference
    results, they should look something like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用AWS IoT Core控制台或MQTT客户端检查推理结果，它们应该看起来像这样：
- en: '![Figure 4.10 – Screenshot of the inference results in AWS IoT Core'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 – AWS IoT Core中推理结果的截图'
- en: '](img/B17595_04_10.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17595_04_10.jpg)'
- en: Figure 4.10 – Screenshot of the inference results in AWS IoT Core
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – AWS IoT Core中推理结果的截图
- en: 'You have now deployed your first ML workload to the edge! This workload will
    continue to run at a 10-second interval and will process the file found at `/greengrass/v2/packages/artifacts-unarchived/component-name/image_classification/sample_images/cat.jpeg`
    on the hub device. There are a number of ways to extend this example for your
    own testing and use cases, such as the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已将第一个机器学习工作负载部署到边缘！此工作负载将以10秒的间隔持续运行，并将处理在中心设备上找到的文件 `/greengrass/v2/packages/artifacts-unarchived/component-name/image_classification/sample_images/cat.jpeg`。有几种方法可以扩展此示例以供您自己的测试和使用案例，例如以下方法：
- en: '`aws.greengrass.DLRImageClassification` component to specify where to source
    the processed image—for example, you can specify a new directory with the `ImageDirectory`
    parameter and a filename with the `ImageName` parameter. Then, you could create
    a custom component that includes your own images as artifacts and rotates them
    through that filename at that path to see what the classification engine identifies.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`aws.greengrass.DLRImageClassification`组件指定处理图像的来源位置——例如，您可以使用`ImageDirectory`参数指定一个新目录，并使用`ImageName`参数指定一个文件名。然后，您可以创建一个包含您自己的图像作为工件的自定义组件，并在此路径下通过该文件名旋转它们，以查看分类引擎识别的内容。
- en: '`aws.greengrass.DLRImageClassification` component to specify a camera as the
    source for images to classify. For prototyping on the Raspberry Pi device, you
    can connect a **Universal Serial Bus** (**USB**) webcam or the **Raspberry Pi
    Camera Module v2**. More details on how to set up the component to use a camera
    can be found in the *References* section at the end of this chapter.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`aws.greengrass.DLRImageClassification`组件指定一个摄像头作为要分类的图像的源。对于在Raspberry Pi设备上进行原型设计，您可以连接一个**通用串行总线**（**USB**）摄像头或**Raspberry
    Pi Camera Module v2**。有关如何设置组件以使用摄像头的更多详细信息，请参阅本章末尾的*参考*部分。
- en: '**Escalate an event for a type of classified result**: The current workload
    reports all inference results on a specified topic. You could modify the custom
    component that subscribes to these results and only update the actuator when a
    human is classified in the inference results. Alternatively, you could publish
    a message on another topic reserved for alerts and configure AWS IoT Core and
    **Amazon Simple Notification Service** (**Amazon SNS**) to send you an alert when
    a human is detected. For these events, you may also want the detected image to
    be stored for future reference.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对特定分类结果类型的事件进行升级**：当前工作负载报告了指定主题上的所有推理结果。您可以修改订阅这些结果的定制组件，并且仅在推理结果中检测到人类时更新执行器。或者，您可以在另一个预留用于警报的主题上发布消息，并配置AWS
    IoT Core和**Amazon Simple Notification Service**（**Amazon SNS**）在检测到人类时向您发送警报。对于这些事件，您可能还希望将检测到的图像存储起来以供将来参考。'
- en: '**Deploy object detection workload**: This example demonstrated a use case
    for classifying the primary object in the source image. An alternate use case
    is to list all objects detected in the source image. AWS also provides managed
    components for object detection workloads and for CV use cases running on either
    DLR or the TensorFlow framework.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署对象检测工作负载**：本示例演示了将源图像中的主要对象进行分类的使用场景。另一种使用场景是列出源图像中检测到的所有对象。AWS还提供了用于对象检测工作负载以及运行在DLR或TensorFlow框架上的CV用例的托管组件。'
- en: '**Notify of new images available**: The managed component is designed with
    an interval pattern to process the source image against the ML model. You could
    design a variation that subscribes to a local IPC topic and waits for notification
    from another component that an inference is needed and could specify the file
    path in the message.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知新图像可用**：托管组件设计了一个间隔模式来处理源图像与ML模型的匹配。您可以设计一个变体，订阅本地IPC主题，并等待另一个组件的通知，表明需要进行推理，并可以在消息中指定文件路径。'
- en: As mentioned in the step for installing the dependencies on the Raspberry Pi,
    these steps take a shortcut that doesn't reflect the best practices of our solution
    design. Rather than manually installing dependencies on the device, a better way
    is to use IoT Greengrass to install those missing dependencies. This section could
    have walked you through forking the AWS managed components in order to add more
    dependencies in the install lifecycle step, but for the purposes of this exercise
    was deemed not a valuable detour.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如在Raspberry Pi上安装依赖步骤中所述，这些步骤采取了一种捷径，并不反映我们解决方案设计的最佳实践。与其手动在设备上安装依赖项，不如使用IoT
    Greengrass来安装那些缺失的依赖项。本节本可以向您介绍如何分叉AWS托管组件，以便在安装生命周期步骤中添加更多依赖项，但考虑到本练习的目的，认为这不是一个有价值的偏离。
- en: Furthermore, the default behavior of the `aws.greengrass.DLRImageClassification`
    managed component publishes the inference results to a cloud topic on AWS IoT
    Core instead of a local topic on IPC. For workloads that report all activity to
    the cloud, this is the desired behavior. However, given the best practices outlined
    in this book to perform data analysis locally and decouple our components, it
    would be preferred to publish on a local IPC topic and let another component decide
    which messages to escalate to the cloud.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`aws.greengrass.DLRImageClassification`托管组件的默认行为是将推理结果发布到AWS IoT Core上的云主题，而不是IPC上的本地主题。对于将所有活动报告到云的工作负载，这是期望的行为。然而，鉴于本书中概述的最佳实践，在本地执行数据分析并解耦我们的组件，我们更倾向于在本地IPC主题上发布，并让另一个组件决定哪些消息需要升级到云。
- en: This could not be achieved with a simple configuration update as defined in
    version 2.1.3 of the component. Again, a detour to fork the component just to
    swap out the cloud publish for a local publish was not deemed valuable for the
    purposes of this exercise, so the cloud publish behavior is left as-is.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这不能通过简单地更新组件的2.1.3版本中定义的配置来实现。再次强调，为了本练习的目的，将组件分叉以替换云发布为本地发布并不被认为是有价值的，因此云发布行为保持不变。
- en: With your first ML-powered workload deployed, you now have an understanding
    of how ML components are deployed to the edge as a combination of dependencies,
    code, and static resources.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的第一个基于机器学习的作业部署完成，您现在已经了解了机器学习组件是如何作为依赖项、代码和静态资源的组合部署到边缘的。
- en: In this section, you deployed three components as a decoupled set of dependencies,
    runtimes, and models, plus one more custom component that acts upon the inference
    results of your ML model. Together, you have all the basics for extending these
    components to deliver your own image classification and object detection workloads.
    Next, let's summarize everything you have learned in this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您部署了三个组件作为解耦的依赖项、运行时和模型集，再加上一个作用于您机器学习模型推理结果的定制组件。综合来看，您已经拥有了扩展这些组件以提供您自己的图像分类和目标检测工作负载的所有基础知识。接下来，让我们总结一下本章您所学到的一切。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught you the key differences in remote deploying of components
    to your Greengrass devices, how to accelerate your solution development using
    managed components provided by AWS, and getting your first ML workload on your
    prototype hub device. At this point, you have all the basics you need to start
    writing your own components and designing edge solutions. You can even extend
    the managed ML components to get started with some basic CV projects. If you have
    trained ML models and inference code being used in your business today as containerized
    code, you could get started with deploying them to the edge now as custom components.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了将组件远程部署到Greengrass设备的关键差异，如何使用AWS提供的托管组件加速您的解决方案开发，以及如何在原型中心设备上部署您的第一个机器学习作业。到目前为止，您已经拥有了开始编写自己的组件和设计边缘解决方案所需的所有基础知识。您甚至可以扩展托管机器学习组件，以开始一些基本的计算机视觉项目。如果您今天在业务中使用的是作为容器化代码训练的机器学习模型和推理代码，您现在就可以开始将它们作为定制组件部署到边缘。
- en: In the next chapter, [*Chapter 5*](B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090),
    *Ingesting and Streaming Data from the Edge*, you will learn more about how data
    moves throughout the edge in prescriptive structures, models, and transformations.
    Proper handling of data at the edge is important for adding efficiency, resilience,
    and security to your edge ML solutions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（*第五章*[*Chapter 5*](B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090)），*从边缘摄取和流式传输数据*，您将了解数据如何在边缘的规范性结构、模型和转换中移动。在边缘正确处理数据对于增加边缘机器学习解决方案的效率、弹性和安全性至关重要。
- en: Knowledge check
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知识检查
- en: 'Before moving on to the next chapter, test your knowledge by answering these
    questions. The answers can be found at the end of the book:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，通过回答以下问题来测试您的知识。答案可以在书的末尾找到：
- en: What are some examples that differentiate static and dynamic resources of an
    edge component?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些例子可以区分边缘组件的静态资源和动态资源？
- en: Where are your components' artifacts stored so that they can be referenced by
    your recipe files?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的组件工件存储在哪里，以便它们可以被您的配方文件引用？
- en: Can you modify an artifact stored in the cloud after it has been included in
    a registered custom component?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能否修改已包含在已注册的定制组件中的云存储工件？
- en: Why can't you write to artifact files that have been loaded onto the edge device
    through deployment?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么您不能写入通过部署加载到边缘设备的工件文件？
- en: 'True or false: Edge devices can belong to multiple thing groups in the cloud
    AWS IoT Core service and each thing group can have one active Greengrass deployment
    associated with it.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对或错：边缘设备可以属于云 AWS IoT Core 服务中的多个事物组，并且每个事物组可以有一个与之关联的激活 Greengrass 部署。
- en: Can you think of a use case for one edge device to receive deployments from
    multiple thing groups?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到一个用例，其中一个边缘设备可以接收来自多个事物组的部署吗？
- en: 'True or false: A single deployment can reset a component''s configuration and
    apply a merge of a new configuration.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对或错：单个部署可以重置组件的配置并应用新配置的合并。
- en: Which of the following managed components is responsible for deploying a local
    MQTT broker and connecting leaf devices?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个管理组件负责部署本地 MQTT 代理并连接叶设备？
- en: MQTT bridge/Moquette/device shadows
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MQTT 代理桥接/Moquette/设备影子
- en: Which of the following managed components is responsible for synchronizing the
    state between the edge and the cloud?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个管理组件负责在边缘和云之间同步状态？
- en: MQTT bridge/Moquette/device shadows
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MQTT 代理桥接/Moquette/设备影子
- en: Which of the following managed components is responsible for relaying messages
    between communications channels such as MQTT, IPC, and the cloud?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个管理组件负责在 MQTT、IPC 和云等通信渠道之间中继消息？
- en: MQTT bridge/Moquette/device shadows
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MQTT 代理桥接/Moquette/设备影子
- en: How might you design the flow of data from a local IoT sensor to an application
    running ML inference and play an alarm sound over an attached loudspeaker? Think
    about the different communications channels available and our best practice of
    decoupled services. Try sketching it out on paper as if you were proposing the
    design to a colleague.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何设计从本地 IoT 传感器到运行机器学习推理的应用程序的数据流，并通过连接的扬声器播放警报声音？考虑不同的通信渠道和我们的最佳实践——解耦服务。试着在纸上勾勒出来，就像你正在向同事提出设计方案一样。
- en: References
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Take a look at the following resources for additional information on the concepts
    discussed in this chapter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下资源，以获取有关本章讨论的概念的更多信息：
- en: '*Perform sample image classification inference on images from a camera using
    TensorFlow Lite*: [https://docs.aws.amazon.com/greengrass/v2/developerguide/ml-tutorial-image-classification-camera.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/ml-tutorial-image-classification-camera.html)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 TensorFlow Lite 在相机图像上执行样本图像分类推理*：[https://docs.aws.amazon.com/greengrass/v2/developerguide/ml-tutorial-image-classification-camera.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/ml-tutorial-image-classification-camera.html)'
- en: '*AWS-provided components*: [https://docs.aws.amazon.com/greengrass/v2/developerguide/public-components.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/public-components.html)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS 提供的组件*：[https://docs.aws.amazon.com/greengrass/v2/developerguide/public-components.html](https://docs.aws.amazon.com/greengrass/v2/developerguide/public-components.html)'
- en: 'OpenCV website: [https://opencv.org/](https://opencv.org/)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV 网站：[https://opencv.org/](https://opencv.org/)
- en: '*AWS IoT Device Shadow service*: [https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS IoT 设备影子服务*：[https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html)'
- en: '*DLR: Compact Runtime for Machine Learning Models*: [https://neo-ai-dlr.readthedocs.io](https://neo-ai-dlr.readthedocs.io)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DLR：机器学习模型的紧凑型运行时*：[https://neo-ai-dlr.readthedocs.io](https://neo-ai-dlr.readthedocs.io)'
- en: 'TensorFlow website: [https://www.tensorflow.org/](https://www.tensorflow.org/)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow 网站：[https://www.tensorflow.org/](https://www.tensorflow.org/)
