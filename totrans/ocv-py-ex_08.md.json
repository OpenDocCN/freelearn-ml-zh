["```py\nimport sys\n\nimport cv2\nimport numpy as np\n\n# Extract reference contour from the image\ndef get_ref_contour(img):\n    ref_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(ref_gray, 127, 255, 0)\n\n    # Find all the contours in the thresholded image. The values\n    # for the second and third parameters are restricted to a # certain number of possible values. You can learn more # 'findContours' function here: http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n\n    # Extract the relevant contour based on area ratio. We use the # area ratio because the main image boundary contour is # extracted as well and we don't want that. This area ratio # threshold will ensure that we only take the contour inside # the image.\n    for contour in contours:\n        area = cv2.contourArea(contour)\n        img_area = img.shape[0] * img.shape[1]\n        if 0.05 < area/float(img_area) < 0.8:\n            return contour\n\n# Extract all the contours from the image\ndef get_all_contours(img):\n    ref_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(ref_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    return contours\n\nif __name__=='__main__':\n    # Boomerang reference image\n    img1 = cv2.imread(sys.argv[1])\n\n    # Input image containing all the different shapes\n    img2 = cv2.imread(sys.argv[2])\n\n    # Extract the reference contour\n    ref_contour = get_ref_contour(img1)\n\n    # Extract all the contours from the input image\n    input_contours = get_all_contours(img2)\n\n    closest_contour = input_contours[0]\n    min_dist = sys.maxint\n    # Finding the closest contour\n    for contour in input_contours:\n        # Matching the shapes and taking the closest one\n        ret = cv2.matchShapes(ref_contour, contour, 1, 0.0)\n        if ret < min_dist:\n            min_dist = ret\n            closest_contour = contour\n\n    cv2.drawContours(img2, [closest_contour], -1, (0,0,0), 3)\n    cv2.imshow('Output', img2)\n    cv2.waitKey()\n```", "```py\nimport sys\n\nimport cv2\nimport numpy as np\n\n# Input is a color image\ndef get_contours(img):\n    # Convert the image to grayscale\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    # Threshold the input image\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n\n    # Find the contours in the above image\n    contours, hierarchy = cv2.findContours(thresh, 2, 1)\n\n    return contours\n\nif __name__=='__main__':\n    img = cv2.imread(sys.argv[1])\n\n    # Iterate over the extracted contours\n    for contour in get_contours(img):\n        # Extract convex hull from the contour\n        hull = cv2.convexHull(contour, returnPoints=False)\n\n        # Extract convexity defects from the above hull\n        defects = cv2.convexityDefects(contour, hull)\n\n        if defects is None:\n            continue\n\n        # Draw lines and circles to show the defects\n        for i in range(defects.shape[0]):\n            start_defect, end_defect, far_defect, _ = defects[i,0]\n            start = tuple(contour[start_defect][0])\n            end = tuple(contour[end_defect][0])\n            far = tuple(contour[far_defect][0])\n            cv2.circle(img, far, 5, [128,0,0], -1)\n            cv2.drawContours(img, [contour], -1, (0,0,0), 3)\n\n    cv2.imshow('Convexity defects',img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n```", "```py\nimport sys\n\nimport cv2\nimport numpy as np\n\n# Input is a color image\ndef get_contours(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 2, 1)\n    return contours\n\nif __name__=='__main__':\n    img = cv2.imread(sys.argv[1])\n\n    # Iterate over the extracted contours\n    for contour in get_contours(img):\n        orig_contour = contour\n        epsilon = 0.01 * cv2.arcLength(contour, True)\n        contour = cv2.approxPolyDP(contour, epsilon, True)\n\n        # Extract convex hull and the convexity defects\n        hull = cv2.convexHull(contour, returnPoints=False)\n        defects = cv2.convexityDefects(contour,hull)\n\n        if defects is None:\n            continue\n\n        # Draw lines and circles to show the defects\n        for i in range(defects.shape[0]):\n            start_defect, end_defect, far_defect, _ = defects[i,0]\n            start = tuple(contour[start_defect][0])\n            end = tuple(contour[end_defect][0])\n            far = tuple(contour[far_defect][0])\n            cv2.circle(img, far, 7, [255,0,0], -1)\n            cv2.drawContours(img, [orig_contour], -1, (0,0,0), 3)\n\n    cv2.imshow('Convexity defects',img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n```", "```py\nimport sys\n\nimport cv2\nimport numpy as np\n\ndef get_all_contours(img):\n    ref_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(ref_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    return contours\n\nif __name__=='__main__':\n    # Input image containing all the shapes\n    img = cv2.imread(sys.argv[1])\n\n    img_orig = np.copy(img)\n    input_contours = get_all_contours(img)\n    solidity_values = []\n\n    # Compute solidity factors of all the contours\n    for contour in input_contours:\n        area_contour = cv2.contourArea(contour)\n        convex_hull = cv2.convexHull(contour)\n        area_hull = cv2.contourArea(convex_hull)\n        solidity = float(area_contour)/area_hull\n        solidity_values.append(solidity)\n\n    # Clustering using KMeans\n    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)\n    flags = cv2.KMEANS_RANDOM_CENTERS\n    solidity_values = np.array(solidity_values).reshape((len(solidity_values),1)).astype('float32')\n    compactness, labels, centers = cv2.kmeans(solidity_values, 2, criteria, 10, flags)\n\n    closest_class = np.argmin(centers)\n    output_contours = []\n    for i in solidity_values[labels==closest_class]:\n        index = np.where(solidity_values==i)[0][0]\n        output_contours.append(input_contours[index])\n\n    cv2.drawContours(img, output_contours, -1, (0,0,0), 3)\n    cv2.imshow('Output', img)\n\n    # Censoring\n    for contour in output_contours:\n        rect = cv2.minAreaRect(contour)\n        box = cv2.cv.BoxPoints(rect)\n        box = np.int0(box)\n        cv2.drawContours(img_orig,[box],0,(0,0,0),-1)\n\n    cv2.imshow('Censored', img_orig)\n    cv2.waitKey()\n```", "```py\nimport cv2\nimport numpy as np\n\n# Draw rectangle based on the input selection\ndef draw_rectangle(event, x, y, flags, params):\n    global x_init, y_init, drawing, top_left_pt, bottom_right_pt, img_orig\n\n    # Detecting mouse button down event\n    if event == cv2.EVENT_LBUTTONDOWN:\n        drawing = True\n        x_init, y_init = x, y\n\n    # Detecting mouse movement\n    elif event == cv2.EVENT_MOUSEMOVE:\n        if drawing:\n            top_left_pt, bottom_right_pt = (x_init,y_init), (x,y)\n            img[y_init:y, x_init:x] = 255 - img_orig[y_init:y, x_init:x]\n            cv2.rectangle(img, top_left_pt, bottom_right_pt, (0,255,0), 2)\n\n    # Detecting mouse button up event\n    elif event == cv2.EVENT_LBUTTONUP:\n        drawing = False\n        top_left_pt, bottom_right_pt = (x_init,y_init), (x,y)\n        img[y_init:y, x_init:x] = 255 - img[y_init:y, x_init:x]\n        cv2.rectangle(img, top_left_pt, bottom_right_pt, (0,255,0), 2)\n        rect_final = (x_init, y_init, x-x_init, y-y_init)\n\n        # Run Grabcut on the region of interest\n        run_grabcut(img_orig, rect_final)\n\n# Grabcut algorithm\ndef run_grabcut(img_orig, rect_final):\n    # Initialize the mask\n    mask = np.zeros(img_orig.shape[:2],np.uint8)\n\n    # Extract the rectangle and set the region of\n    # interest in the above mask\n    x,y,w,h = rect_final\n    mask[y:y+h, x:x+w] = 1\n\n    # Initialize background and foreground models\n    bgdModel = np.zeros((1,65), np.float64)\n    fgdModel = np.zeros((1,65), np.float64)\n\n    # Run Grabcut algorithm\n    cv2.grabCut(img_orig, mask, rect_final, bgdModel, fgdModel, 5, cv2.GC_INIT_WITH_RECT)\n\n    # Extract new mask\n    mask2 = np.where((mask==2)|(mask==0),0,1).astype('uint8')\n\n    # Apply the above mask to the image\n    img_orig = img_orig*mask2[:,:,np.newaxis]\n\n    # Display the image\n    cv2.imshow('Output', img_orig)\n\nif __name__=='__main__':\n    drawing = False\n    top_left_pt, bottom_right_pt = (-1,-1), (-1,-1)\n\n    # Read the input image\n    img_orig = cv2.imread(sys.argv[1])\n    img = img_orig.copy()\n\n    cv2.namedWindow('Input')\n    cv2.setMouseCallback('Input', draw_rectangle)\n\n    while True:\n        cv2.imshow('Input', img)\n        c = cv2.waitKey(1)\n        if c == 27:\n            break\n\n    cv2.destroyAllWindows()\n```"]