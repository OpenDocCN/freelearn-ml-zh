- en: Chapter 10. Association Analysis and Sequence Mining
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 关联分析和序列挖掘
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Transforming data into transactions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据转换为交易
- en: Displaying transactions and associations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示交易和关联
- en: Mining associations with the Apriori rule
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apriori规则挖掘关联
- en: Pruning redundant rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪枝冗余规则
- en: Visualizing associations rules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化关联规则
- en: Mining frequent itemsets with Eclat
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclat算法挖掘频繁项集
- en: Creating transactions with temporal information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有时间信息的交易
- en: Mining frequent sequential patterns with cSPADE
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cSPADE挖掘频繁顺序模式
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Enterprises accumulate a large amount of transaction data (for example, sales
    orders from retailers, invoices, and shipping documentations) from daily operations.
    Finding hidden relationships in the data can be useful, such as, "What products
    are often bought together?" or "What are the subsequent purchases after buying
    a cell phone?" To answer these two questions, we need to perform association analysis
    and frequent sequential pattern mining on a transaction dataset.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 企业从日常运营中积累大量交易数据（例如，来自零售商的销售订单、发票和运输文件），发现数据中的隐藏关系可能很有用，例如，“哪些产品经常一起购买？”或“购买手机后的后续购买是什么？”为了回答这两个问题，我们需要在事务数据集上执行关联分析和频繁顺序模式挖掘。
- en: Association analysis is an approach to find interesting relationships within
    a transaction dataset. A famous association between products is that *customers
    who buy diapers also buy beer*. While this association may sound unusual, if retailers
    can use this kind of information or rule to cross-sell products to their customers,
    there is a high likelihood that they can increase their sales.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关联分析是一种在事务数据集中寻找有趣关系的方法。一个著名的关于产品的关联是*购买尿布的客户也会购买啤酒*。虽然这种关联听起来可能有些不寻常，但如果零售商能够利用这类信息或规则向客户交叉销售产品，那么他们提高销售额的可能性很高。
- en: Association analysis is used to find a correlation between **itemsets**, but
    what if you want to find out the order in which items are frequently purchased?
    To achieve this, you can adopt frequent sequential pattern mining to find frequent
    subsequences from transaction datasets with temporal information. You can then
    use the mined frequent subsequences to predict customer shopping sequence orders,
    web click streams, biological sequences, and usages in other applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关联分析用于寻找**项集**之间的相关性，但如果你想知道频繁购买的项目顺序，该怎么办？为了实现这一点，你可以采用频繁顺序模式挖掘，从具有时间信息的事务数据集中找到频繁子序列。然后，你可以使用挖掘出的频繁子序列来预测客户购物顺序、网页点击流、生物序列以及其他应用中的使用情况。
- en: In this chapter, we will cover recipes to create and inspect transaction datasets,
    performing association analysis with an Apriori algorithm, visualizing associations
    in various graph formats, and finding frequent itemsets using the Eclat algorithm.
    Lastly, we will create transactions with temporal information and use the cSPADE
    algorithm to discover frequent sequential patterns.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖创建和检查事务数据集的配方，使用Apriori算法执行关联分析，以各种图形格式可视化关联，以及使用Eclat算法查找频繁项集。最后，我们将创建具有时间信息的交易，并使用cSPADE算法发现频繁顺序模式。
- en: Transforming data into transactions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据转换为交易
- en: Before creating a mining association rule, you need to transform the data into
    transactions. In the following recipe, we will introduce how to transform either
    a list, matrix, or data frame into transactions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建挖掘关联规则之前，您需要将数据转换为交易。在下面的配方中，我们将介绍如何将列表、矩阵或数据框转换为交易。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will generate three different datasets in a list, matrix,
    or data frame. We can then transform the generated dataset into transactions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将在一个列表、矩阵或数据框中生成三个不同的数据集。然后，我们可以将生成的数据集转换为交易。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to transform different formats of data into transactions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将不同格式的数据转换为交易：
- en: 'First, you have to install and load the package `arule`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须安装并加载`arule`包：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can then make a list with three vectors containing purchase records:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以创建一个包含三个向量的购买记录列表：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you can use the `as` function to transform the data frame into transactions:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以使用`as`函数将数据框转换为交易：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also transform the matrix format data into transactions:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以将矩阵格式的数据转换为交易：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lastly, you can transform the data frame format datasets into transactions:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以将数据框格式的数据集转换为事务：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before mining frequent itemsets or using the association rule, it is important
    to prepare the dataset by the class of transactions. In this recipe, we demonstrate
    how to transform a dataset from a list, matrix, and data frame format to transactions.
    In the first step, we generate the dataset in a list format containing three vectors
    of purchase records. Then, after we have assigned a transaction ID to each transaction,
    we transform the data into transactions using the `as` function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在挖掘频繁项集或使用关联规则之前，通过事务类别准备数据集非常重要。在本菜谱中，我们演示如何将数据集从列表、矩阵和数据框格式转换为事务。在第一步中，我们生成一个包含三个购买记录向量的列表格式的数据集。然后，在为每个交易分配交易ID之后，我们使用
    `as` 函数将数据转换为事务。
- en: Next, we demonstrate how to transform the data from the matrix format into transactions.
    To denote how items are purchased, one should use a binary incidence matrix to
    record the purchase behavior of each transaction with regard to different items
    purchased. Likewise, we can use an `as` function to transform the dataset from
    the matrix format into transactions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将演示如何将矩阵格式中的数据转换为事务。为了表示项目的购买情况，应使用二元发生矩阵来记录每个交易相对于不同购买项目的购买行为。同样，我们可以使用
    `as` 函数将数据集从矩阵格式转换为事务。
- en: 'Lastly, we illustrate how to transform the dataset from the data frame format
    into transactions. The data frame contains two factor-type vectors: one is a transaction
    ID named `TrID`, while the other shows purchased items (named in `Item`) with
    regard to different transactions. Also, one can use the `as` function to transform
    the data frame format data into transactions.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示如何将数据集从数据框格式转换为事务。数据框包含两个因子类型的向量：一个是名为 `TrID` 的交易ID，另一个显示不同交易中的购买项目（命名为
    `Item`）。此外，可以使用 `as` 函数将数据框格式的数据转换为事务。
- en: See also
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: 'The `transactions` class is used to represent transaction data for rules or
    frequent pattern mining. It is an extension of the `itemMatrix` class. If you
    are interested in how to use the two different classes to represent transaction
    data, please use the `help` function to refer to the following documents:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactions` 类用于表示规则或频繁模式挖掘的事务数据。它是 `itemMatrix` 类的扩展。如果您对如何使用这两个不同的类来表示事务数据感兴趣，请使用
    `help` 函数参考以下文档：'
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Displaying transactions and associations
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示事务和关联
- en: The `arule` package uses its own `transactions` class to store transaction data.
    As such, we must use the generic function provided by `arule` to display transactions
    and association rules. In this recipe, we will illustrate how to display transactions
    and association rules via various functions in the `arule` package.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`arule` 包使用其自己的 `transactions` 类来存储事务数据。因此，我们必须使用 `arule` 提供的通用函数来显示事务和关联规则。在本菜谱中，我们将展示如何通过
    `arule` 包中的各种函数显示事务和关联规则。'
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have completed the previous recipe by generating transactions
    and storing these in the variable, `trans`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已通过生成事务并将这些存储在变量 `trans` 中完成前面的菜谱。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to display transactions and associations:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以显示事务和关联：
- en: 'First, you can obtain a LIST representation of the transaction data:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您可以获取事务数据的 LIST 表示：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, you can use the `summary` function to show a summary of the statistics
    and details of the transactions:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以使用 `summary` 函数显示事务的统计和详细摘要：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can then display transactions using the `inspect` function:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `inspect` 函数显示事务：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition to this, you can filter the transactions by size:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，您还可以根据大小筛选事务：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, you can use the image function to visually inspect the transactions:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，您还可以使用图像函数来直观检查事务：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![How to do it...](img/00201.jpeg)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/00201.jpeg)'
- en: Visual inspection of transactions
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事务的可视检查
- en: 'To visually show the frequency/support bar plot, one can use `itemFrequenctPlot`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了直观地显示频率/支持条形图，可以使用 `itemFrequenctPlot`：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How to do it...](img/00202.jpeg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/00202.jpeg)'
- en: Item frequency bar plot of transactions
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事务项目频率条形图
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As the transaction data is the base for mining associations and frequent patterns,
    we have to learn how to display the associations to gain insights and determine
    how associations are built. The `arules` package provides various methods to inspect
    transactions. First, we use the `LIST` function to obtain the list representation
    of the transaction data. We can then use the `summary` function to obtain information,
    such as basic descriptions, most frequent items, and the transaction length distribution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事务数据是挖掘关联和频繁模式的基石，我们必须学习如何显示关联以获得洞察力并确定关联是如何构建的。`arules`包提供了各种方法来检查事务。首先，我们使用`LIST`函数获取事务数据的列表表示。然后，我们可以使用`summary`函数获取信息，例如基本描述、最频繁的项以及事务长度分布。
- en: Next, we use the `inspect` function to display the transactions. Besides displaying
    all transactions, one can first filter the transactions by size and then display
    the associations by using the `inspect` function. Furthermore, we can use the
    `image` function to visually inspect the transactions. Finally, we illustrate
    how to use the frequency/support bar plot to display the relative item frequency
    of each item.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`inspect`函数显示事务。除了显示所有事务外，您还可以首先通过大小过滤事务，然后使用`inspect`函数显示关联。此外，我们可以使用`image`函数对事务进行视觉检查。最后，我们说明如何使用频率/支持条形图显示每个项目的相对频率。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Besides using `itemFrequencyPlot` to show the frequency/bar plot, you can use
    the `itemFrequency` function to show the support distribution. For more details,
    please use the `help` function to view the following document:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了使用`itemFrequencyPlot`显示频率/条形图外，您还可以使用`itemFrequency`函数显示支持分布。有关更多详细信息，请使用`help`函数查看以下文档：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Mining associations with the Apriori rule
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apriori规则挖掘关联
- en: Association mining is a technique that can discover interesting relationships
    hidden in transaction datasets. This approach first finds all frequent itemsets,
    and generates strong association rules from frequent itemsets. Apriori is the
    most well-known association mining algorithm, which identifies frequent individual
    items first and then performs a breadth-first search strategy to extend individual
    items to larger itemsets until larger frequent itemsets cannot be found. In this
    recipe, we will introduce how to perform association analysis using the Apriori
    rule.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关联挖掘是一种技术，可以挖掘出隐藏在事务数据集中的有趣关系。这种方法首先找到所有频繁项集，然后从频繁项集中生成强关联规则。Apriori是最著名的关联挖掘算法，它首先识别频繁的个体项，然后执行广度优先搜索策略，将个体项扩展到更大的项集，直到无法找到更大的频繁项集。在本食谱中，我们将介绍如何使用Apriori规则进行关联分析。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the built-in transaction dataset, `Groceries`, to
    demonstrate how to perform association analysis with the Apriori algorithm in
    the `arules` package. Please make sure that the `arules` package is installed
    and loaded first.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用内置的事务数据集`Groceries`，演示如何在`arules`包中使用Apriori算法进行关联分析。请确保首先安装并加载`arules`包。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to analyze the association rules:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以分析关联规则：
- en: 'First, you need to load the dataset `Groceries`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要加载数据集`Groceries`：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can then examine the summary of the `Groceries` dataset:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以检查`Groceries`数据集的摘要：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, you can use `itemFrequencyPlot` to examine the relative item frequency
    of itemsets:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以使用`itemFrequencyPlot`检查项集的相对频率：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![How to do it...](img/00203.jpeg)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00203.jpeg)'
- en: The top five item frequency bar plot of groceries transactions
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 食物事务的前五项频率条形图
- en: 'Use `apriori` to discover rules with the support over 0.001 and confidence
    over 0.5:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`apriori`发现支持率超过0.001且置信度超过0.5的规则：
- en: '[PRE16]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can then inspect the first few rules:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以检查前几条规则：
- en: '[PRE17]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can sort rules by confidence and inspect the first few rules:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以根据置信度对规则进行排序并检查前几条规则：
- en: '[PRE18]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The purpose of association mining is to discover associations among items from
    the transactional database. Typically, the process of association mining proceeds
    by finding itemsets that have the support greater than the minimum support. Next,
    the process uses the frequent itemsets to generate strong rules (for example,
    `milk => bread`; a customer who buys milk is likely to buy bread) that have the
    confidence greater than minimum the confidence. By definition, an association
    rule can be expressed in the form of *X=>Y*, where X and Y are disjointed itemsets.
    We can measure the strength of associations between two terms: support and confidence.
    Support shows how much of the percentage of a rule is applicable within a dataset,
    while confidence indicates the probability of both X and Y appearing in the same
    transaction:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关联挖掘的目的是从事务数据库中挖掘项目之间的关联。通常，关联挖掘的过程是通过查找支持度大于最小支持度的项集来进行的。接下来，过程使用频繁项集生成具有大于最小置信度的强规则（例如，`milk
    => bread`；购买牛奶的客户很可能也会购买面包）。根据定义，关联规则可以表示为 *X=>Y* 的形式，其中 X 和 Y 是不相交的项集。我们可以衡量两个术语之间的关联强度：支持度和置信度。支持度表示规则在数据集中适用的百分比，而置信度表示
    X 和 Y 同时出现在同一交易中的概率：
- en: Support = ![How it works...](img/00204.jpeg)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持度 = ![如何工作...](img/00204.jpeg)
- en: Confidence = ![How it works...](img/00205.jpeg)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信度 = ![如何工作...](img/00205.jpeg)
- en: Here, ![How it works...](img/00206.jpeg) refers to the frequency of a particular
    itemset; *N* denotes the populations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![如何工作...](img/00206.jpeg) 指的是特定项集的频率；*N* 表示人口数量。
- en: 'As support and confidence are metrics for the strength rule only, you might
    still obtain many redundant rules with a high support and confidence. Therefore,
    we can use the third measure, lift, to evaluate the quality (ranking) of the rule.
    By definition, lift indicates the strength of a rule over the random co-occurrence
    of X and Y, so we can formulate lift in the following form:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于支持度和置信度是衡量规则强度的指标，你仍然可能会获得许多具有高支持度和置信度的冗余规则。因此，我们可以使用第三个度量，即提升度，来评估规则的质量（排名）。根据定义，提升度表明规则相对于
    X 和 Y 的随机共现的强度，因此我们可以以下形式制定提升度：
- en: Lift = ![How it works...](img/00207.jpeg)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 升力 = ![如何工作...](img/00207.jpeg)
- en: Apriori is the best known algorithm for mining associations, which performs
    a level-wise, breadth-first algorithm to count the candidate itemsets. The process
    of Apriori starts by finding frequent itemsets (a set of items that have minimum
    support) level-wisely. For example, the process starts with finding frequent 1-itemsets.
    Then, the process continues by using frequent 1-itemsets to find frequent 2-itemsets.
    The process iteratively discovers new frequent k+1-itemsets from frequent k-itemsets
    until no frequent itemsets are found.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori 是挖掘关联规则最著名的算法，它执行一种按层级的广度优先算法来计数候选项集。Apriori 的过程从按层级查找频繁项集（具有最小支持度的项集集合）开始。例如，过程从查找频繁的
    1-项集开始。然后，过程继续使用频繁的 1-项集来查找频繁的 2-项集。过程迭代地从频繁的 k-项集中发现新的频繁 k+1-项集，直到没有找到频繁项集。
- en: 'Finally, the process utilizes frequent itemsets to generate association rules:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，过程利用频繁项集生成关联规则：
- en: '![How it works...](img/00208.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00208.jpeg)'
- en: An illustration of Apriori algorithm (Where support = 2)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori 算法示意图（其中支持度 = 2）
- en: In this recipe, we use the Apriori algorithm to find association rules within
    transactions. We use the built-in `Groceries` dataset, which contains one month
    of real-world point-of-sale transaction data from a typical grocery outlet. We
    then use the `summary` function to obtain the summary statistics of the `Groceries`
    dataset. The summary statistics shows that the dataset contains 9,835 transactions,
    which are categorized into 169 categories. In addition to this, the summary shows
    information, such as most frequent items, itemset distribution, and example extended
    item information within the dataset. We can then use `itemFrequencyPlot` to visualize
    the five most frequent items with support over 0.1.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 Apriori 算法在事务中查找关联规则。我们使用内置的 `Groceries` 数据集，它包含来自典型杂货店的现实世界一个月的销售额交易数据。然后，我们使用
    `summary` 函数来获取 `Groceries` 数据集的摘要统计信息。摘要统计显示，数据集包含 9,835 笔交易，分为 169 个类别。此外，摘要还显示了数据集中的信息，例如最频繁的项、项集分布以及数据集中的示例扩展项信息。然后，我们可以使用
    `itemFrequencyPlot` 来可视化支持率超过 0.1 的五个最频繁项。
- en: Next, we apply the Apriori algorithm to search for rules with support over 0.001
    and confidence over 0.5\. We then use the `summary` function to inspect detailed
    information on the generated rules. From the output summary, we find the Apriori
    algorithm generates 5,668 rules with support over 0.001 and confidence over 0.5\.
    Further, we can find the rule length distribution, summary of quality measures,
    and mining information. In the summary of the quality measurement, we find descriptive
    statistics of three measurements, which are support, confidence, and lift. Support
    is the proportion of transactions containing a certain itemset. Confidence is
    the correctness percentage of the rule. Lift is the response target association
    rule divided by the average response.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应用Apriori算法来搜索支持度超过0.001且置信度超过0.5的规则。然后，我们使用 `summary` 函数来检查生成规则的详细信息。从输出摘要中，我们发现Apriori算法生成了5,668条支持度超过0.001且置信度超过0.5的规则。进一步，我们可以找到规则长度分布、质量度量摘要和挖掘信息。在质量度量摘要中，我们发现三个度量（支持度、置信度和提升度）的描述性统计。支持度是包含特定项集的交易比例。置信度是规则的正确百分比。提升度是响应目标关联规则除以平均响应。
- en: To explore some generated rules, we can use the `inspect` function to view the
    first six rules of the 5,668 generated rules. Lastly, we can sort rules by confidence
    and list rules with the most confidence. Therefore, we find that `rich sugar`
    associated to `whole milk` is the most confident rule with the support equal to
    0.001220132, confidence equal to 1, and lift equal to 3.913649.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索一些生成的规则，我们可以使用 `inspect` 函数来查看5,668条生成规则中的前六条规则。最后，我们可以根据置信度对规则进行排序，并列出置信度最高的规则。因此，我们发现与
    `whole milk` 相关的 `rich sugar` 是置信度最高的规则，其支持度为0.001220132，置信度为1，提升度为3.913649。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'For those interested in the research results using the `Groceries` dataset,
    and how the support, confidence, and lift measurement are defined, you can refer
    to the following papers:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对使用 `Groceries` 数据集的研究结果感兴趣的人，以及支持度、置信度和提升度测量是如何定义的，您可以参考以下论文：
- en: Michael Hahsler, Kurt Hornik, and Thomas Reutterer (2006) *Implications of probabilistic
    data modeling for mining association rules*. *In M. Spiliopoulou, R. Kruse*, *C.
    Borgelt*, *A*
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Michael Hahsler，Kurt Hornik 和 Thomas Reutterer（2006）*概率数据建模对挖掘关联规则的影响*。*在 M.
    Spiliopoulou，R. Kruse，C. Borgelt，A* 中
- en: Nuernberger, and W. Gaul, editors, *From Data and Information Analysis to Knowledge
    Engineering, Studies in Classification*, *Data Analysis, and Knowledge Organization*,
    *pages 598–605*. *Springer-Verlag*
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuernberger 和 W. Gaul 编著，*从数据和信息分析到知识工程，分类研究，数据分析与知识组织，第598-605页*。*Springer-Verlag*
- en: 'Also, in addition to using the `summary` and `inspect` functions to inspect
    association rules, you can use `interestMeasure` to obtain additional interest
    measures:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，除了使用 `summary` 和 `inspect` 函数来检查关联规则外，您还可以使用 `interestMeasure` 获取额外的兴趣度量：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pruning redundant rules
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剪枝冗余规则
- en: Among the generated rules, we sometimes find repeated or redundant rules (for
    example, one rule is the super rule or subset of another rule). In this recipe,
    we will show you how to prune (or remove) repeated or redundant rules.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的规则中，我们有时会发现重复或冗余的规则（例如，一条规则是另一条规则的超级规则或子集）。在这个菜谱中，我们将向您展示如何剪枝（或删除）重复或冗余的规则。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you have to complete the previous recipe by generating rules
    and have it stored in the variable `rules`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您必须通过生成规则并存储在变量 `rules` 中来完成前面的菜谱。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to prune redundant rules:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以剪枝冗余规则：
- en: 'First, follow these steps to find redundant rules:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤查找冗余规则：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can then remove redundant rules:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以移除冗余规则：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The two main constraints of association mining are to choose between the support
    and confidence. For example, if you use a high support threshold, you might remove
    rare item rules without considering whether these rules have a high confidence
    value. On the other hand, if you choose to use a low support threshold, the association
    mining can produce huge sets of redundant association rules, which make these
    rules difficult to utilize and analyze. Therefore, we need to prune redundant
    rules so we can discover meaningful information from these generated rules.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关联挖掘的两个主要约束是在支持度和置信度之间进行选择。例如，如果你使用高的支持度阈值，你可能会移除稀有的项目规则，而不考虑这些规则是否具有高的置信度值。另一方面，如果你选择使用低的支持度阈值，关联挖掘可能会产生大量的冗余关联规则，这使得这些规则难以利用和分析。因此，我们需要剪枝冗余规则，以便从这些生成的规则中找到有意义的信息。
- en: In this recipe, we demonstrate how to prune redundant rules. First, we search
    for redundant rules. We sort the rules by a lift measure, and then find subsets
    of the sorted rules using the `is.subset` function, which will generate an `itemMatrix`
    object. We can then set the lower triangle of the matrix to NA. Lastly, we compute
    `colSums` of the generated matrix, of which `colSums >=1` indicates that the specific
    rule is redundant.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们演示了如何剪枝冗余规则。首先，我们搜索冗余规则。我们根据提升度对规则进行排序，然后使用`is.subset`函数找到排序规则的子集，这将生成一个`itemMatrix`对象。然后，我们可以将矩阵的下三角设置为NA。最后，我们计算生成的矩阵的`colSums`，其中`colSums
    >=1`表示该特定规则是冗余的。
- en: After we have found the redundant rules, we can prune these rules from the sorted
    rules. Lastly, we can examine the pruned rules using the `inspect` function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们找到冗余规则后，我们可以从排序规则中剪除这些规则。最后，我们可以使用`inspect`函数检查剪枝规则。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In order to find subsets or supersets of rules, you can use the `is.superset`
    and `is.subset` functions on the association rules. These two methods may generate
    an `itemMatrix` object to show which rule is the superset or subset of other rules.
    You can refer to the `help` function for more information:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了找到规则的子集或超集，你可以在关联规则上使用`is.superset`和`is.subset`函数。这两种方法可能会生成一个`itemMatrix`对象来显示哪个规则是其他规则的子集或超集。你可以参考`help`函数获取更多信息：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Visualizing association rules
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联规则的可视化
- en: Besides listing rules as text, you can visualize association rules, making it
    easier to find the relationship between itemsets. In the following recipe, we
    will introduce how to use the `aruleViz` package to visualize the association
    rules.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以文本形式列出规则外，你还可以可视化关联规则，这有助于找到项目集之间的关系。在下面的菜谱中，我们将介绍如何使用`aruleViz`包来可视化关联规则。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will continue using the `Groceries` dataset. You need to
    have completed the previous recipe by generating the pruned rule `rules.pruned`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续使用`Groceries`数据集。你需要完成上一个菜谱，生成剪枝规则`rules.pruned`。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to visualize the association rule:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以可视化关联规则：
- en: 'First, you need to install and load the package `arulesViz`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要安装并加载`arulesViz`包：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can then make a scatter plot from the pruned rules:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以从剪枝规则中制作散点图：
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![How to do it...](img/00209.jpeg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00209.jpeg)'
- en: The scatter plot of pruned association rules
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 剪枝关联规则的散点图
- en: 'Additionally, to prevent overplotting, you can add jitter to the scatter plot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了防止重叠，你可以在散点图中添加抖动：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![How to do it...](img/00210.jpeg)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00210.jpeg)'
- en: The scatter plot of pruned association rules with jitters
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关联规则剪枝散点图带有抖动
- en: 'We then produce new rules with `soda` on the left-hand side using the Apriori
    algorithm:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用Apriori算法在左侧使用`soda`生成新规则：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, you can plot `soda_rule` in a graph plot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以在图形图中绘制`soda_rule`：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![How to do it...](img/00211.jpeg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00211.jpeg)'
- en: Graph plot of association rules
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关联规则的图形图
- en: 'Also, the association rules can be visualized in a balloon plot:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，关联规则还可以在气球图中可视化：
- en: '[PRE28]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![How to do it...](img/00212.jpeg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00212.jpeg)'
- en: Balloon plot of association rules
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关联规则的气球图
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Besides presenting association rules as text, one can use `arulesViz` to visualize
    association rules. The `arulesViz` is an `arules` extension package, which provides
    many visualization techniques to explore association rules. To start using `arulesViz`,
    first install and load the package `arulesViz`. We then use the pruned rules generated
    in the previous recipe to make a scatter plot. As per the figure in step 2, we
    find the rules are shown as points within the scatter plot, with the x-axis in
    support and y-axis in confidence. The shade of color shows the lift of the rule;
    the darker the shade, the higher the lift. Next, in order to prevent overplotting
    points, we can include the jitter as an argument in the control list. The plot
    with the jitter added is provided in the figure in step 3.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以文本形式呈现关联规则之外，还可以使用`arulesViz`来可视化关联规则。`arulesViz`是`arules`的扩展包，它提供了许多可视化技术来探索关联规则。要开始使用`arulesViz`，首先安装并加载`arulesViz`包。然后我们使用前一个菜谱中生成的剪枝规则制作散点图。根据步骤2中的图，我们发现规则在散点图中显示为点，x轴表示支持度，y轴表示置信度。颜色的深浅显示了规则的提升度；颜色越深，提升度越高。接下来，为了防止点重叠，我们可以在控制列表中包含jitter作为参数。添加了jitter的图在步骤3中的图中提供。
- en: In addition to plotting the rules in a scatter plot, `arulesViz` enables you
    to plot rules in a graph and grouped matrix. Instead of printing all the rules
    on a single plot, we choose to produce new rules with `soda` on the left-hand
    side. We then sort the rules by using the lift and visualize the rules in the
    graph in the figure in step 4\. From the graph, every itemset is presented in
    a vertex and their relationship is presented in an edge. The figure (step 4) shows
    it is clear that the rule with `soda` on the left-handside to `whole milk` on
    the right-handside has the maximum support, for the size of the node is greatest.
    Also, the rule shows that `soda` on the left-hand side to `bottled water` on the
    right-hand side has the maximum lift as the shade of color in the circle is the
    darkest. We can then use the same data with `soda` on the left-handside to generate
    a grouped matrix, which is a balloon plot shown in the figure in step 5, with
    the left-handside rule as column labels and the right-handside as row labels.
    Similar to the graph plot in the figure in step 4, the size of the balloon in
    the figure in step 5 shows the support of the rule, and the color of the balloon
    shows the lift of the rule.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在散点图中绘制规则之外，`arulesViz`还允许您在图中和分组矩阵中绘制规则。我们不是在单个图中打印所有规则，而是选择使用`soda`在左侧生成新规则。然后我们使用提升排序规则，并在步骤4中的图中可视化规则。从图中可以看出，左侧的`soda`到右侧的`全脂牛奶`的规则具有最大的支持度，因为节点的大小最大。此外，该规则显示左侧的`soda`到右侧的`瓶装水`具有最大的提升度，因为圆圈的颜色最深。然后我们可以使用左侧带有`soda`的相同数据生成一个分组矩阵，这是一个在步骤5中的图中显示的气球图，左侧规则作为列标签，右侧作为行标签。类似于步骤4中的图中的图，步骤5中的图中的气球大小显示了规则的支持度，气球的颜色显示了规则的提升度。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'In this recipe, we introduced three visualization methods to plot association
    rules. However, `arulesViz` also provides features to plot parallel coordinate
    plots, double-decker plots, mosaic plots, and other related charts. For those
    who are interested in how these plots work, you may refer to: Hahsler, M., and
    Chelluboina, S. (2011). *Visualizing association rules: Introduction to the R-extension
    package arulesViz. R project module*.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们介绍了三种可视化方法来绘制关联规则。然而，`arulesViz`也提供了绘制平行坐标图、双层图、马赛克图和其他相关图表的功能。对于那些对如何实现这些图表感兴趣的人，您可以参考：Hahsler,
    M. 和 Chelluboina, S. (2011). *可视化关联规则：R扩展包arulesViz的介绍。R项目模块*。
- en: 'In addition to generating a static plot, you can generate an interactive plot
    by setting interactive equal to TRUE through the following steps:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了生成静态图之外，您可以通过以下步骤通过将交互设置为TRUE来生成交互式图：
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![See also](img/00213.jpeg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![另请参阅](img/00213.jpeg)'
- en: The interactive scatter plots
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 交互式散点图
- en: Mining frequent itemsets with Eclat
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eclat挖掘频繁项集
- en: In addition to the Apriori algorithm, you can use the Eclat algorithm to generate
    frequent itemsets. As the Apriori algorithm performs a breadth-first search to
    scan the complete database, the support counting is rather time consuming. Alternatively,
    if the database fits into the memory, you can use the Eclat algorithm, which performs
    a depth-first search to count the supports. The Eclat algorithm, therefore, performs
    quicker than the Apriori algorithm. In this recipe, we introduce how to use the
    Eclat algorithm to generate frequent itemsets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Apriori算法外，您还可以使用Eclat算法来生成频繁项集。由于Apriori算法执行广度优先搜索以扫描整个数据库，支持度计数相当耗时。如果数据库可以放入内存中，您可以使用Eclat算法，它执行深度优先搜索来计数支持度。因此，Eclat算法比Apriori算法运行得更快。在这个食谱中，我们将介绍如何使用Eclat算法生成频繁项集。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will continue using the dataset `Groceries` as our input
    data source.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将继续使用数据集`Groceries`作为我们的输入数据源。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to generate a frequent itemset using the Eclat
    algorithm:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用Eclat算法生成频繁项集：
- en: 'Similar to the Apriori method, we can use the `eclat` function to generate
    the frequent itemset:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与Apriori方法类似，我们可以使用`eclat`函数来生成频繁项集：
- en: '[PRE30]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can then obtain the summary information from the generated frequent itemset:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以从生成的频繁项集中获取汇总信息：
- en: '[PRE31]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Lastly, we can examine the top ten support frequent itemsets:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以检查前十个支持度最高的频繁项集：
- en: '[PRE32]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we introduce another algorithm, Eclat, to perform frequent itemset
    generation. Though Apriori is a straightforward and easy to understand association
    mining method, the algorithm has the disadvantage of generating huge candidate
    sets and performs inefficiently in support counting, for it takes multiple scans
    of databases. In contrast to Apriori, Eclat uses equivalence classes, depth-first
    searches, and set intersections, which greatly improves the speed in support counting.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们介绍另一个算法，Eclat，用于执行频繁项集生成。尽管Apriori是一种简单易懂的关联挖掘方法，但该算法的缺点是生成巨大的候选集，在支持度计数方面效率低下，因为它需要多次扫描数据库。相比之下，Eclat使用等价类、深度优先搜索和集合交集，这大大提高了支持度计数的速度。
- en: 'In Apriori, the algorithm uses a horizontal data layout to store transactions.
    On the other hand, Eclat uses a vertical data layout to store a list of transaction
    IDs (`tid`) for each item. Then, Eclat determines the support of any k+1-itemset
    by intersecting tid-lists of two k-itemsets. Lastly, Eclat utilizes frequent itemsets
    to generate association rules:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apriori算法中，算法使用水平数据布局来存储事务。另一方面，Eclat使用垂直数据布局来存储每个项目的交易ID列表（`tid`）。然后，Eclat通过交集两个k-item集的tid列表来确定任何k+1-item集的支持度。最后，Eclat利用频繁项集来生成关联规则：
- en: '![How it works...](img/00214.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00214.jpeg)'
- en: An illustration of Eclat algorithm
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Eclat算法的说明
- en: Similar to the recipe using the Apriori algorithm, we can use the `eclat` function
    to generate a frequent itemset with a given support (assume support = 2 in this
    case) and maximum length.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用Apriori算法的食谱类似，我们可以使用`eclat`函数来生成具有给定支持度（本例中假设支持度为2）和最大长度的频繁项集。
- en: '![How it works...](img/00215.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00215.jpeg)'
- en: Generating frequent itemset
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 生成频繁项集
- en: 'We can then use the `summary` function to obtain summary statistics, which
    include: most frequent items, itemset length distributions, summary of quality
    measures, and mining information. Finally, we can sort frequent itemsets by the
    support and inspect the top ten support frequent itemsets.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`summary`函数来获取汇总统计信息，包括：最频繁的项目、项集长度分布、质量度量摘要和挖掘信息。最后，我们可以按支持度对频繁项集进行排序，并检查前十个支持度最高的频繁项集。
- en: See also
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Besides Apriori and Eclat, another popular association mining algorithm is **FP-Growth**.
    Similar to Eclat, this takes a depth-first search to count supports. However,
    there is no existing R package that you can download from CRAN that contains this
    algorithm. However, if you are interested in knowing how to apply the FP-growth
    algorithm in your transaction dataset, you can refer to Christian Borgelt's page
    at [http://www.borgelt.net/fpgrowth.html](http://www.borgelt.net/fpgrowth.html)
    for more information.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了Apriori和Eclat，另一个流行的关联挖掘算法是**FP-Growth**。与Eclat类似，它也采用深度优先搜索来计数支持度。然而，目前没有可以从CRAN下载的R包包含此算法。但是，如果您对在事务数据集中应用FP-growth算法感兴趣，您可以参考Christian
    Borgelt的页面[http://www.borgelt.net/fpgrowth.html](http://www.borgelt.net/fpgrowth.html)以获取更多信息。
- en: Creating transactions with temporal information
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有时间信息的交易
- en: In addition to mining interesting associations within the transaction database,
    we can mine interesting sequential patterns using transactions with temporal information.
    In the following recipe, we demonstrate how to create transactions with temporal
    information.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在事务数据库中挖掘有趣的关联之外，我们还可以使用带有时间信息的交易挖掘有趣的序列模式。在下面的菜谱中，我们展示了如何创建带有时间信息的交易。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will generate transactions with temporal information. We
    can use the generated transactions as the input source for frequent sequential
    pattern mining.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将生成带有时间信息的交易。我们可以使用生成的交易作为频繁序列模式挖掘的输入源。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to create transactions with temporal information:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建带有时间信息的交易：
- en: 'First, you need to install and load the package `arulesSequences`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要安装并加载包`arulesSequences`：
- en: '[PRE33]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can first create a list with purchasing records:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以先创建一个包含购买记录的列表：
- en: '[PRE34]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can then turn the list into transactions and add temporal information:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以将列表转换为交易并添加时间信息：
- en: '[PRE35]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, you can use the `inspect` function to inspect the transactions:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以使用`inspect`函数来检查交易：
- en: '[PRE36]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can then obtain the summary information of the transactions with the temporal
    information:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以获取带有时间信息的交易的摘要信息：
- en: '[PRE37]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also read the transaction data in a basket format:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以以篮子格式读取事务数据：
- en: '[PRE38]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Before mining frequent sequential patterns, you are required to create transactions
    with the temporal information. In this recipe, we introduce two methods to obtain
    transactions with temporal information. In the first method, we create a list
    of transactions, and assign a transaction ID for each transaction. We use the
    `as` function to transform the list data into a transaction dataset. We then add
    `eventID` and `sequenceID` as temporal information; `sequenceID` is the sequence
    that the event belongs to, and `eventID` indicates when the event occurred. After
    generating transactions with temporal information, one can use this dataset for
    frequent sequential pattern mining.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在挖掘频繁序列模式之前，你必须创建带有时间信息的事务。在这个菜谱中，我们介绍了两种获取带有时间信息的事务的方法。在第一种方法中，我们创建一个事务列表，并为每个事务分配一个事务ID。我们使用`as`函数将列表数据转换为事务数据集。然后我们添加`eventID`和`sequenceID`作为时间信息；`sequenceID`是事件所属的序列，`eventID`表示事件发生的时间。在生成带有时间信息的交易后，可以使用这个数据集进行频繁序列模式挖掘。
- en: In addition to creating your own transactions with temporal information, if
    you already have data stored in a text file, you can use the `read_basket` function
    from `arulesSequences` to read the transaction data into the basket format. We
    can also read the transaction dataset for further frequent sequential pattern
    mining.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建自己的带有时间信息的交易之外，如果你已经有一个存储在文本文件中的数据，你可以使用`arulesSequences`中的`read_basket`函数将事务数据读取到篮子格式。我们还可以读取事务数据集以进行进一步的频繁序列模式挖掘。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'The `arulesSequences` function provides two additional data structures, `sequences`
    and `timedsequences`, to present pure sequence data and sequence data with the
    time information. For those who are interested in these two collections, please
    use the help function to view the following documents:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arulesSequences`函数提供了两个额外的数据结构，`sequences`和`timedsequences`，用于表示纯序列数据和带时间信息的序列数据。对于对这些两个集合感兴趣的人，请使用帮助函数查看以下文档：'
- en: '[PRE39]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Mining frequent sequential patterns with cSPADE
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cSPADE挖掘频繁序列模式
- en: In contrast to association mining, which only discovers relationships between
    itemsets, we may be interested in exploring patterns shared among transactions
    where a set of itemsets occurs sequentially.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅发现项集之间关系的关联挖掘不同，我们可能对探索在一系列项集按顺序发生的事务中共享的模式感兴趣。
- en: One of the most famous frequent sequential pattern mining algorithms is the
    **Sequential PAttern Discovery using Equivalence classes** (**SPADE**) algorithm,
    which employs the characteristics of a vertical database to perform an intersection
    on an ID list with an efficient lattice search and allows us to place constraints
    on mined sequences. In this recipe, we will demonstrate how to use cSPADE to mine
    frequent sequential patterns.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的频繁序列模式挖掘算法之一是**使用等价类的序列模式发现**（**SPADE**）算法，该算法利用垂直数据库的特性在ID列表上执行高效格搜索，并允许我们对挖掘的序列施加约束。在本食谱中，我们将演示如何使用cSPADE来挖掘频繁序列模式。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you have to complete the previous recipes by generating transactions
    with the temporal information and have it stored in the variable `trans`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您必须通过生成带有时间信息的交易并存储在变量`trans`中来完成前面的食谱。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to mine the frequent sequential patterns:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以挖掘频繁序列模式：
- en: 'First, you can use the `cspade` function to generate frequent sequential patterns:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您可以使用`cspade`函数生成频繁序列模式：
- en: '[PRE40]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can then examine the summary of the frequent sequential patterns:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以检查频繁序列模式的摘要：
- en: '[PRE41]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Transform a generated sequence format data back to the data frame:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的序列格式数据转换回数据框：
- en: '[PRE42]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The object of sequential pattern mining is to discover sequential relationships
    or patterns in transactions. You can use the pattern mining result to predict
    future events, or recommend items to users.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 序列模式挖掘的目标是在事务中发现序列关系或模式。您可以使用模式挖掘结果来预测未来事件，或向用户推荐项目。
- en: 'One popular method of sequential pattern mining is SPADE. SPADE uses a vertical
    data layout to store a list of IDs. In these, each input sequence in the database
    is called SID, and each event in a given input sequence is called EID. The process
    of SPADE is performed by generating patterns level-wisely by an Apriori candidate
    generation. In detail, SPADE generates subsequent n-sequences from joining (n-1)-sequences
    from the intersection of ID lists. If the number of sequences is greater than
    the **minimum support** (**minsup**), we can consider the sequence to be frequent
    enough. The algorithm stops until the process cannot find more frequent sequences:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 序列模式挖掘的一种流行方法是SPADE。SPADE使用垂直数据布局来存储ID列表。在这些列表中，数据库中的每个输入序列被称为SID，给定输入序列中的每个事件被称为EID。SPADE的过程是通过按层次生成Apriori候选来进行的。具体来说，SPADE通过从ID列表的交集生成(n-1)-序列来生成后续的n-序列。如果序列的数量大于**最小支持度**（**minsup**），我们可以认为序列足够频繁。算法停止，直到无法找到更多频繁序列为止：
- en: '![How it works...](img/00216.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00216.jpeg)'
- en: An illustration of SPADE algorithm
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: SPADE算法的说明
- en: In this recipe, we illustrate how to use a frequent sequential pattern mining
    algorithm, cSPADE, to mine frequent sequential patterns. First, as we have transactions
    with temporal information loaded in the variable `trans`, we can use the `cspade`
    function with the support over 0.75 to generate frequent sequential patterns in
    the `sequences` format. We can then obtain summary information, such as most frequent
    items, sequence size distributions, a summary of quality measures, and mining
    information. Lastly, we can transform the generated `sequence` information back
    to the data frame format, so we can examine the sequence and support of frequent
    sequential patterns with the support over 0.75.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们说明了如何使用频繁序列模式挖掘算法cSPADE来挖掘频繁序列模式。首先，由于我们已经将带有时间信息的交易加载到变量`trans`中，我们可以使用`cspade`函数，支持度超过0.75，以`sequences`格式生成频繁序列模式。然后我们可以获取总结信息，例如最频繁的项目、序列大小分布、质量度量摘要和挖掘信息。最后，我们可以将生成的`sequence`信息转换回数据框格式，这样我们就可以检查支持度超过0.75的频繁序列模式的序列和支持度。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: 'If you are interested in the concept and design of the SPADE algorithm, you
    can refer to the original published paper: M. J. Zaki. (2001). *SPADE: An Efficient
    Algorithm for Mining Frequent Sequences. Machine Learning Journal*, 42, 31–60.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果您对SPADE算法的概念和设计感兴趣，您可以参考原始发表的论文：M. J. Zaki. (2001). *SPADE: An Efficient
    Algorithm for Mining Frequent Sequences. Machine Learning Journal*, 42, 31–60。'
