- en: Chapter 10. Association Analysis and Sequence Mining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data into transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying transactions and associations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining associations with the Apriori rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pruning redundant rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing associations rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining frequent itemsets with Eclat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating transactions with temporal information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining frequent sequential patterns with cSPADE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprises accumulate a large amount of transaction data (for example, sales
    orders from retailers, invoices, and shipping documentations) from daily operations.
    Finding hidden relationships in the data can be useful, such as, "What products
    are often bought together?" or "What are the subsequent purchases after buying
    a cell phone?" To answer these two questions, we need to perform association analysis
    and frequent sequential pattern mining on a transaction dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Association analysis is an approach to find interesting relationships within
    a transaction dataset. A famous association between products is that *customers
    who buy diapers also buy beer*. While this association may sound unusual, if retailers
    can use this kind of information or rule to cross-sell products to their customers,
    there is a high likelihood that they can increase their sales.
  prefs: []
  type: TYPE_NORMAL
- en: Association analysis is used to find a correlation between **itemsets**, but
    what if you want to find out the order in which items are frequently purchased?
    To achieve this, you can adopt frequent sequential pattern mining to find frequent
    subsequences from transaction datasets with temporal information. You can then
    use the mined frequent subsequences to predict customer shopping sequence orders,
    web click streams, biological sequences, and usages in other applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover recipes to create and inspect transaction datasets,
    performing association analysis with an Apriori algorithm, visualizing associations
    in various graph formats, and finding frequent itemsets using the Eclat algorithm.
    Lastly, we will create transactions with temporal information and use the cSPADE
    algorithm to discover frequent sequential patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data into transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before creating a mining association rule, you need to transform the data into
    transactions. In the following recipe, we will introduce how to transform either
    a list, matrix, or data frame into transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will generate three different datasets in a list, matrix,
    or data frame. We can then transform the generated dataset into transactions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to transform different formats of data into transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you have to install and load the package `arule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then make a list with three vectors containing purchase records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can use the `as` function to transform the data frame into transactions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also transform the matrix format data into transactions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, you can transform the data frame format datasets into transactions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before mining frequent itemsets or using the association rule, it is important
    to prepare the dataset by the class of transactions. In this recipe, we demonstrate
    how to transform a dataset from a list, matrix, and data frame format to transactions.
    In the first step, we generate the dataset in a list format containing three vectors
    of purchase records. Then, after we have assigned a transaction ID to each transaction,
    we transform the data into transactions using the `as` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we demonstrate how to transform the data from the matrix format into transactions.
    To denote how items are purchased, one should use a binary incidence matrix to
    record the purchase behavior of each transaction with regard to different items
    purchased. Likewise, we can use an `as` function to transform the dataset from
    the matrix format into transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we illustrate how to transform the dataset from the data frame format
    into transactions. The data frame contains two factor-type vectors: one is a transaction
    ID named `TrID`, while the other shows purchased items (named in `Item`) with
    regard to different transactions. Also, one can use the `as` function to transform
    the data frame format data into transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `transactions` class is used to represent transaction data for rules or
    frequent pattern mining. It is an extension of the `itemMatrix` class. If you
    are interested in how to use the two different classes to represent transaction
    data, please use the `help` function to refer to the following documents:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Displaying transactions and associations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `arule` package uses its own `transactions` class to store transaction data.
    As such, we must use the generic function provided by `arule` to display transactions
    and association rules. In this recipe, we will illustrate how to display transactions
    and association rules via various functions in the `arule` package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure that you have completed the previous recipe by generating transactions
    and storing these in the variable, `trans`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to display transactions and associations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can obtain a LIST representation of the transaction data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can use the `summary` function to show a summary of the statistics
    and details of the transactions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then display transactions using the `inspect` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition to this, you can filter the transactions by size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, you can use the image function to visually inspect the transactions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00201.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Visual inspection of transactions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To visually show the frequency/support bar plot, one can use `itemFrequenctPlot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00202.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Item frequency bar plot of transactions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the transaction data is the base for mining associations and frequent patterns,
    we have to learn how to display the associations to gain insights and determine
    how associations are built. The `arules` package provides various methods to inspect
    transactions. First, we use the `LIST` function to obtain the list representation
    of the transaction data. We can then use the `summary` function to obtain information,
    such as basic descriptions, most frequent items, and the transaction length distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `inspect` function to display the transactions. Besides displaying
    all transactions, one can first filter the transactions by size and then display
    the associations by using the `inspect` function. Furthermore, we can use the
    `image` function to visually inspect the transactions. Finally, we illustrate
    how to use the frequency/support bar plot to display the relative item frequency
    of each item.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides using `itemFrequencyPlot` to show the frequency/bar plot, you can use
    the `itemFrequency` function to show the support distribution. For more details,
    please use the `help` function to view the following document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Mining associations with the Apriori rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Association mining is a technique that can discover interesting relationships
    hidden in transaction datasets. This approach first finds all frequent itemsets,
    and generates strong association rules from frequent itemsets. Apriori is the
    most well-known association mining algorithm, which identifies frequent individual
    items first and then performs a breadth-first search strategy to extend individual
    items to larger itemsets until larger frequent itemsets cannot be found. In this
    recipe, we will introduce how to perform association analysis using the Apriori
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the built-in transaction dataset, `Groceries`, to
    demonstrate how to perform association analysis with the Apriori algorithm in
    the `arules` package. Please make sure that the `arules` package is installed
    and loaded first.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to analyze the association rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to load the dataset `Groceries`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then examine the summary of the `Groceries` dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can use `itemFrequencyPlot` to examine the relative item frequency
    of itemsets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00203.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The top five item frequency bar plot of groceries transactions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `apriori` to discover rules with the support over 0.001 and confidence
    over 0.5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then inspect the first few rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can sort rules by confidence and inspect the first few rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of association mining is to discover associations among items from
    the transactional database. Typically, the process of association mining proceeds
    by finding itemsets that have the support greater than the minimum support. Next,
    the process uses the frequent itemsets to generate strong rules (for example,
    `milk => bread`; a customer who buys milk is likely to buy bread) that have the
    confidence greater than minimum the confidence. By definition, an association
    rule can be expressed in the form of *X=>Y*, where X and Y are disjointed itemsets.
    We can measure the strength of associations between two terms: support and confidence.
    Support shows how much of the percentage of a rule is applicable within a dataset,
    while confidence indicates the probability of both X and Y appearing in the same
    transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: Support = ![How it works...](img/00204.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidence = ![How it works...](img/00205.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, ![How it works...](img/00206.jpeg) refers to the frequency of a particular
    itemset; *N* denotes the populations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As support and confidence are metrics for the strength rule only, you might
    still obtain many redundant rules with a high support and confidence. Therefore,
    we can use the third measure, lift, to evaluate the quality (ranking) of the rule.
    By definition, lift indicates the strength of a rule over the random co-occurrence
    of X and Y, so we can formulate lift in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: Lift = ![How it works...](img/00207.jpeg)
  prefs: []
  type: TYPE_NORMAL
- en: Apriori is the best known algorithm for mining associations, which performs
    a level-wise, breadth-first algorithm to count the candidate itemsets. The process
    of Apriori starts by finding frequent itemsets (a set of items that have minimum
    support) level-wisely. For example, the process starts with finding frequent 1-itemsets.
    Then, the process continues by using frequent 1-itemsets to find frequent 2-itemsets.
    The process iteratively discovers new frequent k+1-itemsets from frequent k-itemsets
    until no frequent itemsets are found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the process utilizes frequent itemsets to generate association rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of Apriori algorithm (Where support = 2)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we use the Apriori algorithm to find association rules within
    transactions. We use the built-in `Groceries` dataset, which contains one month
    of real-world point-of-sale transaction data from a typical grocery outlet. We
    then use the `summary` function to obtain the summary statistics of the `Groceries`
    dataset. The summary statistics shows that the dataset contains 9,835 transactions,
    which are categorized into 169 categories. In addition to this, the summary shows
    information, such as most frequent items, itemset distribution, and example extended
    item information within the dataset. We can then use `itemFrequencyPlot` to visualize
    the five most frequent items with support over 0.1.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we apply the Apriori algorithm to search for rules with support over 0.001
    and confidence over 0.5\. We then use the `summary` function to inspect detailed
    information on the generated rules. From the output summary, we find the Apriori
    algorithm generates 5,668 rules with support over 0.001 and confidence over 0.5\.
    Further, we can find the rule length distribution, summary of quality measures,
    and mining information. In the summary of the quality measurement, we find descriptive
    statistics of three measurements, which are support, confidence, and lift. Support
    is the proportion of transactions containing a certain itemset. Confidence is
    the correctness percentage of the rule. Lift is the response target association
    rule divided by the average response.
  prefs: []
  type: TYPE_NORMAL
- en: To explore some generated rules, we can use the `inspect` function to view the
    first six rules of the 5,668 generated rules. Lastly, we can sort rules by confidence
    and list rules with the most confidence. Therefore, we find that `rich sugar`
    associated to `whole milk` is the most confident rule with the support equal to
    0.001220132, confidence equal to 1, and lift equal to 3.913649.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For those interested in the research results using the `Groceries` dataset,
    and how the support, confidence, and lift measurement are defined, you can refer
    to the following papers:'
  prefs: []
  type: TYPE_NORMAL
- en: Michael Hahsler, Kurt Hornik, and Thomas Reutterer (2006) *Implications of probabilistic
    data modeling for mining association rules*. *In M. Spiliopoulou, R. Kruse*, *C.
    Borgelt*, *A*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nuernberger, and W. Gaul, editors, *From Data and Information Analysis to Knowledge
    Engineering, Studies in Classification*, *Data Analysis, and Knowledge Organization*,
    *pages 598–605*. *Springer-Verlag*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, in addition to using the `summary` and `inspect` functions to inspect
    association rules, you can use `interestMeasure` to obtain additional interest
    measures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Pruning redundant rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the generated rules, we sometimes find repeated or redundant rules (for
    example, one rule is the super rule or subset of another rule). In this recipe,
    we will show you how to prune (or remove) repeated or redundant rules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have to complete the previous recipe by generating rules
    and have it stored in the variable `rules`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to prune redundant rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, follow these steps to find redundant rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then remove redundant rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two main constraints of association mining are to choose between the support
    and confidence. For example, if you use a high support threshold, you might remove
    rare item rules without considering whether these rules have a high confidence
    value. On the other hand, if you choose to use a low support threshold, the association
    mining can produce huge sets of redundant association rules, which make these
    rules difficult to utilize and analyze. Therefore, we need to prune redundant
    rules so we can discover meaningful information from these generated rules.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we demonstrate how to prune redundant rules. First, we search
    for redundant rules. We sort the rules by a lift measure, and then find subsets
    of the sorted rules using the `is.subset` function, which will generate an `itemMatrix`
    object. We can then set the lower triangle of the matrix to NA. Lastly, we compute
    `colSums` of the generated matrix, of which `colSums >=1` indicates that the specific
    rule is redundant.
  prefs: []
  type: TYPE_NORMAL
- en: After we have found the redundant rules, we can prune these rules from the sorted
    rules. Lastly, we can examine the pruned rules using the `inspect` function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to find subsets or supersets of rules, you can use the `is.superset`
    and `is.subset` functions on the association rules. These two methods may generate
    an `itemMatrix` object to show which rule is the superset or subset of other rules.
    You can refer to the `help` function for more information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visualizing association rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides listing rules as text, you can visualize association rules, making it
    easier to find the relationship between itemsets. In the following recipe, we
    will introduce how to use the `aruleViz` package to visualize the association
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will continue using the `Groceries` dataset. You need to
    have completed the previous recipe by generating the pruned rule `rules.pruned`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to visualize the association rule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install and load the package `arulesViz`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then make a scatter plot from the pruned rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00209.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The scatter plot of pruned association rules
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, to prevent overplotting, you can add jitter to the scatter plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00210.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The scatter plot of pruned association rules with jitters
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then produce new rules with `soda` on the left-hand side using the Apriori
    algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can plot `soda_rule` in a graph plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00211.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Graph plot of association rules
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, the association rules can be visualized in a balloon plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00212.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Balloon plot of association rules
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides presenting association rules as text, one can use `arulesViz` to visualize
    association rules. The `arulesViz` is an `arules` extension package, which provides
    many visualization techniques to explore association rules. To start using `arulesViz`,
    first install and load the package `arulesViz`. We then use the pruned rules generated
    in the previous recipe to make a scatter plot. As per the figure in step 2, we
    find the rules are shown as points within the scatter plot, with the x-axis in
    support and y-axis in confidence. The shade of color shows the lift of the rule;
    the darker the shade, the higher the lift. Next, in order to prevent overplotting
    points, we can include the jitter as an argument in the control list. The plot
    with the jitter added is provided in the figure in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to plotting the rules in a scatter plot, `arulesViz` enables you
    to plot rules in a graph and grouped matrix. Instead of printing all the rules
    on a single plot, we choose to produce new rules with `soda` on the left-hand
    side. We then sort the rules by using the lift and visualize the rules in the
    graph in the figure in step 4\. From the graph, every itemset is presented in
    a vertex and their relationship is presented in an edge. The figure (step 4) shows
    it is clear that the rule with `soda` on the left-handside to `whole milk` on
    the right-handside has the maximum support, for the size of the node is greatest.
    Also, the rule shows that `soda` on the left-hand side to `bottled water` on the
    right-hand side has the maximum lift as the shade of color in the circle is the
    darkest. We can then use the same data with `soda` on the left-handside to generate
    a grouped matrix, which is a balloon plot shown in the figure in step 5, with
    the left-handside rule as column labels and the right-handside as row labels.
    Similar to the graph plot in the figure in step 4, the size of the balloon in
    the figure in step 5 shows the support of the rule, and the color of the balloon
    shows the lift of the rule.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we introduced three visualization methods to plot association
    rules. However, `arulesViz` also provides features to plot parallel coordinate
    plots, double-decker plots, mosaic plots, and other related charts. For those
    who are interested in how these plots work, you may refer to: Hahsler, M., and
    Chelluboina, S. (2011). *Visualizing association rules: Introduction to the R-extension
    package arulesViz. R project module*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to generating a static plot, you can generate an interactive plot
    by setting interactive equal to TRUE through the following steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![See also](img/00213.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The interactive scatter plots
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mining frequent itemsets with Eclat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the Apriori algorithm, you can use the Eclat algorithm to generate
    frequent itemsets. As the Apriori algorithm performs a breadth-first search to
    scan the complete database, the support counting is rather time consuming. Alternatively,
    if the database fits into the memory, you can use the Eclat algorithm, which performs
    a depth-first search to count the supports. The Eclat algorithm, therefore, performs
    quicker than the Apriori algorithm. In this recipe, we introduce how to use the
    Eclat algorithm to generate frequent itemsets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will continue using the dataset `Groceries` as our input
    data source.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to generate a frequent itemset using the Eclat
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the Apriori method, we can use the `eclat` function to generate
    the frequent itemset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then obtain the summary information from the generated frequent itemset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we can examine the top ten support frequent itemsets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we introduce another algorithm, Eclat, to perform frequent itemset
    generation. Though Apriori is a straightforward and easy to understand association
    mining method, the algorithm has the disadvantage of generating huge candidate
    sets and performs inefficiently in support counting, for it takes multiple scans
    of databases. In contrast to Apriori, Eclat uses equivalence classes, depth-first
    searches, and set intersections, which greatly improves the speed in support counting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Apriori, the algorithm uses a horizontal data layout to store transactions.
    On the other hand, Eclat uses a vertical data layout to store a list of transaction
    IDs (`tid`) for each item. Then, Eclat determines the support of any k+1-itemset
    by intersecting tid-lists of two k-itemsets. Lastly, Eclat utilizes frequent itemsets
    to generate association rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of Eclat algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the recipe using the Apriori algorithm, we can use the `eclat` function
    to generate a frequent itemset with a given support (assume support = 2 in this
    case) and maximum length.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Generating frequent itemset
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the `summary` function to obtain summary statistics, which
    include: most frequent items, itemset length distributions, summary of quality
    measures, and mining information. Finally, we can sort frequent itemsets by the
    support and inspect the top ten support frequent itemsets.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides Apriori and Eclat, another popular association mining algorithm is **FP-Growth**.
    Similar to Eclat, this takes a depth-first search to count supports. However,
    there is no existing R package that you can download from CRAN that contains this
    algorithm. However, if you are interested in knowing how to apply the FP-growth
    algorithm in your transaction dataset, you can refer to Christian Borgelt's page
    at [http://www.borgelt.net/fpgrowth.html](http://www.borgelt.net/fpgrowth.html)
    for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating transactions with temporal information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to mining interesting associations within the transaction database,
    we can mine interesting sequential patterns using transactions with temporal information.
    In the following recipe, we demonstrate how to create transactions with temporal
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will generate transactions with temporal information. We
    can use the generated transactions as the input source for frequent sequential
    pattern mining.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create transactions with temporal information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install and load the package `arulesSequences`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can first create a list with purchasing records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then turn the list into transactions and add temporal information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can use the `inspect` function to inspect the transactions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then obtain the summary information of the transactions with the temporal
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also read the transaction data in a basket format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before mining frequent sequential patterns, you are required to create transactions
    with the temporal information. In this recipe, we introduce two methods to obtain
    transactions with temporal information. In the first method, we create a list
    of transactions, and assign a transaction ID for each transaction. We use the
    `as` function to transform the list data into a transaction dataset. We then add
    `eventID` and `sequenceID` as temporal information; `sequenceID` is the sequence
    that the event belongs to, and `eventID` indicates when the event occurred. After
    generating transactions with temporal information, one can use this dataset for
    frequent sequential pattern mining.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to creating your own transactions with temporal information, if
    you already have data stored in a text file, you can use the `read_basket` function
    from `arulesSequences` to read the transaction data into the basket format. We
    can also read the transaction dataset for further frequent sequential pattern
    mining.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `arulesSequences` function provides two additional data structures, `sequences`
    and `timedsequences`, to present pure sequence data and sequence data with the
    time information. For those who are interested in these two collections, please
    use the help function to view the following documents:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Mining frequent sequential patterns with cSPADE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to association mining, which only discovers relationships between
    itemsets, we may be interested in exploring patterns shared among transactions
    where a set of itemsets occurs sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most famous frequent sequential pattern mining algorithms is the
    **Sequential PAttern Discovery using Equivalence classes** (**SPADE**) algorithm,
    which employs the characteristics of a vertical database to perform an intersection
    on an ID list with an efficient lattice search and allows us to place constraints
    on mined sequences. In this recipe, we will demonstrate how to use cSPADE to mine
    frequent sequential patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have to complete the previous recipes by generating transactions
    with the temporal information and have it stored in the variable `trans`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to mine the frequent sequential patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can use the `cspade` function to generate frequent sequential patterns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then examine the summary of the frequent sequential patterns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transform a generated sequence format data back to the data frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object of sequential pattern mining is to discover sequential relationships
    or patterns in transactions. You can use the pattern mining result to predict
    future events, or recommend items to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'One popular method of sequential pattern mining is SPADE. SPADE uses a vertical
    data layout to store a list of IDs. In these, each input sequence in the database
    is called SID, and each event in a given input sequence is called EID. The process
    of SPADE is performed by generating patterns level-wisely by an Apriori candidate
    generation. In detail, SPADE generates subsequent n-sequences from joining (n-1)-sequences
    from the intersection of ID lists. If the number of sequences is greater than
    the **minimum support** (**minsup**), we can consider the sequence to be frequent
    enough. The algorithm stops until the process cannot find more frequent sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of SPADE algorithm
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we illustrate how to use a frequent sequential pattern mining
    algorithm, cSPADE, to mine frequent sequential patterns. First, as we have transactions
    with temporal information loaded in the variable `trans`, we can use the `cspade`
    function with the support over 0.75 to generate frequent sequential patterns in
    the `sequences` format. We can then obtain summary information, such as most frequent
    items, sequence size distributions, a summary of quality measures, and mining
    information. Lastly, we can transform the generated `sequence` information back
    to the data frame format, so we can examine the sequence and support of frequent
    sequential patterns with the support over 0.75.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are interested in the concept and design of the SPADE algorithm, you
    can refer to the original published paper: M. J. Zaki. (2001). *SPADE: An Efficient
    Algorithm for Mining Frequent Sequences. Machine Learning Journal*, 42, 31–60.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
