["```py\ncmake_minimum_required (VERSION 2.6)\n\ncmake_policy(SET CMP0012 NEW)\n\nPROJECT(Chapter4_Phototool)\n\n# Requires OpenCV\nFIND_PACKAGE( OpenCV 3.0.0 REQUIRED )\n\ninclude_directories(${OpenCV_INCLUDE_DIRS})\nlink_directories(${OpenCV_LIB_DIR})\n\nADD_EXECUTABLE( ${PROJECT_NAME} main.cpp )\nTARGET_LINK_LIBRARIES( ${PROJECT_NAME} ${OpenCV_LIBS} )\n```", "```py\ncmake_minimum_required (VERSION 2.6)\ncmake_policy(SET CMP0012 NEW)\n```", "```py\nPROJECT(Chapter4_Phototool)\n```", "```py\n# Requires OpenCV\nFIND_PACKAGE( OpenCV 3.0.0 REQUIRED )\nMESSAGE(\"OpenCV version : ${OpenCV_VERSION}\")\n```", "```py\ninclude_directories(${OpenCV_INCLUDE_DIRS})\nlink_directories(${OpenCV_LIB_DIR})\n```", "```py\nADD_EXECUTABLE( ${PROJECT_NAME} main.cpp )\nTARGET_LINK_LIBRARIES( ${PROJECT_NAME} ${OpenCV_LIBS} ) \n```", "```py\n// OpenCV includes\n#include \"opencv2/core/utility.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/highgui.hpp\"\nusing namespace cv;\n// OpenCV command line parser functions\n// Keys accecpted by command line parser\nconst char* keys =\n{\n    \"{help h usage ? | | print this message}\"\n    \"{@image | | Image to process}\"\n};\n```", "```py\nint main( int argc, const char** argv )\n{\n    CommandLineParser parser(argc, argv, keys);\n    parser.about(\"Chapter 4\\. PhotoTool v1.0.0\");\n    //If requires help show\n    if (parser.has(\"help\"))\n    {\n        parser.printMessage();\n        return 0;\n    }\n```", "```py\nString imgFile= parser.get<String>(0);\n\n    // Check if params are correctly parsed in his variables\n    if (!parser.check())\n    {\n        parser.printErrors();\n        return 0;\n    }\n```", "```py\n    // Load image to process\n    img= imread(imgFile);\n    // Create window\n    namedWindow(\"Input\");\n```", "```py\n    // Create UI buttons\n    createButton(\"Show histogram\", showHistoCallback, NULL, QT_PUSH_BUTTON, 0);\n    createButton(\"Equalize histogram\", equalizeCallback, NULL, QT_PUSH_BUTTON, 0);\n    createButton(\"Lomography effect\", lomoCallback, NULL, QT_PUSH_BUTTON, 0);\n    createButton(\"Cartonize effect\", cartoonCallback, NULL, QT_PUSH_BUTTON, 0);\n```", "```py\n    // Show image\n    imshow(\"Input\", img);\n    waitKey(0);\n    return 0;\n```", "```py\nvoid showHistoCallback(int state, void* userData)\n{\n    // Separate image in BRG\n    vector<Mat> bgr;\n    split( img, bgr );\n\n    // Create the histogram for 256 bins\n    // The number of possibles values [0..255]\n    int numbins= 256;\n\n    /// Set the ranges ( for B,G,R) ), last is not included\n    float range[] = { 0, 256 } ;\n    const float* histRange = { range };\n\n    Mat b_hist, g_hist, r_hist;\n\n    calcHist( &bgr[0], 1, 0, Mat(), b_hist, 1, &numbins, &histRange );\n    calcHist( &bgr[1], 1, 0, Mat(), g_hist, 1, &numbins, &histRange );\n    calcHist( &bgr[2], 1, 0, Mat(), r_hist, 1, &numbins, &histRange );\n\n    // Draw the histogram\n    // We go to draw lines for each channel\n    int width= 512;\n    int height= 300;\n    // Create image with gray base\n    Mat histImage( height, width, CV_8UC3, Scalar(20,20,20) );\n\n  // Normalize the histograms to height of image\n  normalize(b_hist, b_hist, 0, height, NORM_MINMAX );\n  normalize(g_hist, g_hist, 0, height, NORM_MINMAX );\n  normalize(r_hist, r_hist, 0, height, NORM_MINMAX );\n\n  int binStep= cvRound((float)width/(float)numbins);\n  for( int i=1; i< numbins; i++)\n  {\n    line( histImage, \n      Point( binStep*(i-1), height-cvRound(b_hist.at<float>(i-1) ) ),\n        Point( binStep*(i), height-cvRound(b_hist.at<float>(i) ) ),\n          Scalar(255,0,0));\n    line( histImage, \n      Point( binStep*(i-1), height-cvRound(g_hist.at<float>(i-1) ) ),\n        Point( binStep*(i), height-cvRound(g_hist.at<float>(i) ) ),\n          Scalar(0,255,0));\n    line( histImage, \n      Point( binStep*(i-1), height-cvRound(r_hist.at<float>(i-1) ) ),\n        Point( binStep*(i), height-cvRound(r_hist.at<float>(i) ) ),\n          Scalar(0,0,255));\n    }\n    imshow(\"Histogram\", histImage);\n}\n```", "```py\n// Separate image in BRG\n    vector<Mat> bgr;\n    split( img, bgr );\n```", "```py\nint numbins= 256;\n```", "```py\n    /// Set the ranges ( for B,G,R) )\n    float range[] = { 0, 256 } ;\n    const float* histRange = { range };\n    Mat b_hist, g_hist, r_hist;\n```", "```py\ncalcHist( &bgr[0], 1, 0, Mat(), b_hist, 1, &numbins, &histRange );\n    calcHist( &bgr[1], 1, 0, Mat(), g_hist, 1, &numbins, &histRange );\n    calcHist( &bgr[2], 1, 0, Mat(), r_hist, 1, &numbins, &histRange );\n```", "```py\n// Draw the histogram\n    // We go to draw lines for each channel\n    int width= 512;\n    int height= 300;\n    // Create image with gray base\n    Mat histImage( height, width, CV_8UC3, Scalar(20,20,20) );\n```", "```py\n    // Normalize the histograms to height of image\n    normalize(b_hist, b_hist, 0, height, NORM_MINMAX );\n    normalize(g_hist, g_hist, 0, height, NORM_MINMAX );\n    normalize(r_hist, r_hist, 0, height, NORM_MINMAX );\n```", "```py\nint binStep= cvRound((float)width/(float)numbins);\n  for( int i=1; i< numbins; i++)\n  {\n    line( histImage, \n      Point( binStep*(i-1), height-cvRound(b_hist.at<float>(i-1) ) ),\n        Point( binStep*(i), height-cvRound(b_hist.at<float>(i) ) ),\n          Scalar(255,0,0));\n    line( histImage, \n      Point( binStep*(i-1), height-cvRound(g_hist.at<float>(i-1) ) ),\n        Point( binStep*(i), height-cvRound(g_hist.at<float>(i) ) ),\n          Scalar(0,255,0));\n    line( histImage, \n      Point( binStep*(i-1), height-cvRound(r_hist.at<float>(i-1) ) ),\n        Point( binStep*(i), height-cvRound(r_hist.at<float>(i) ) ),\n          Scalar(0,0,255));\n    }\n```", "```py\n    imshow(\"Histogram\", histImage);\n```", "```py\nvoid equalizeCallback(int state, void* userData)\n{\n    Mat result;\n    // Convert BGR image to YCbCr\n    Mat ycrcb;\n    cvtColor( img, ycrcb, COLOR_BGR2YCrCb);\n\n    // Split image into channels\n    vector<Mat> channels;\n    split( ycrcb, channels );\n\n    // Equalize the Y channel only\n    equalizeHist( channels[0], channels[0] );\n\n    // Merge the result channels\n    merge( channels, ycrcb );\n\n    // Convert color ycrcb to BGR\n    cvtColor( ycrcb, result, COLOR_YCrCb2BGR );\n\n    // Show image\n    imshow(\"Equalized\", result);\n}\n```", "```py\n    Mat result;\n        // Convert BGR image to YCbCr\n        Mat ycrcb;\n        cvtColor( img, ycrcb, COLOR_BGR2YCrCb);\n    ```", "```py\n    // Split image into channels\n        vector<Mat> channels;\n        split( ycrcb, channels );\n    ```", "```py\n        // Equalize the Y channel only\n        equalizeHist( channels[0], channels[0] );\n    ```", "```py\n        // Merge the result channels\n        merge( channels, ycrcb );\n\n        // Convert color ycrcb to BGR\n        cvtColor( ycrcb, result, COLOR_YCrCb2BGR );\n\n        // Show image\n        imshow(\"Equalized\", result);\n    ```", "```py\nvoid lomoCallback(int state, void* userData)\n{\n    Mat result;\n\n    const double exponential_e = std::exp(1.0);\n    // Create Lookup table for color curve effect\n    Mat lut(1, 256, CV_8UC1);\n    for (int i=0; i<256; i++)\n    {\n        float x= (float)i/256.0; \n        lut.at<uchar>(i)= cvRound( 256 * (1/(1 + pow(exponential_e, -((x-0.5)/0.1)) )) );\n    }\n\n    // Split the image channels and apply curve transform only to red channel\n    vector<Mat> bgr;\n    split(img, bgr);\n    LUT(bgr[2], lut, bgr[2]);\n    // merge result\n    merge(bgr, result);\n\n    // Create image for halo dark\n    Mat halo( img.rows, img.cols, CV_32FC3, Scalar(0.3,0.3,0.3) );\n    // Create circle \n    circle(halo, Point(img.cols/2, img.rows/2), img.cols/3, Scalar(1,1,1), -1); \n    blur(halo, halo, Size(img.cols/3, img.cols/3));\n\n    // Convert the result to float to allow multiply by 1 factor\n    Mat resultf;\n    result.convertTo(resultf, CV_32FC3);\n\n    // Multiply our result with halo\n    multiply(resultf, halo, resultf);\n\n    // convert to 8 bits\n    resultf.convertTo(result, CV_8UC3);\n\n    // show result\n    imshow(\"Lomograpy\", result);\n}\n```", "```py\nconst double exponential_e = std::exp(1.0);\n    // Create Lookup table for color curve effect\n    Mat lut(1, 256, CV_8UC1);\n    Uchar* plut= lut.data;\n    for (int i=0; i<256; i++)\n    {\n        double x= (double)i/256.0; \n        plut[i]= cvRound( 256.0 * (1.0/(1.0 + pow(exponential_e, -((x-0.5)/0.1)) )) );\n    }\n```", "```py\n    // Split the image channels and apply curve transform only to red channel\n    vector<Mat> bgr;\n    split(img, bgr);\n```", "```py\nLUT(bgr[2], lut, bgr[2]);\n```", "```py\n// merge result\n    merge(bgr, result);\n```", "```py\n// Create image for halo dark\n    Mat halo( img.rows, img.cols, CV_32FC3, Scalar(0.3,0.3,0.3) );\n    // Create circle \n    circle(halo, Point(img.cols/2, img.rows/2), img.cols/3, Scalar(1,1,1), -1); \n```", "```py\n    blur(halo, halo, Size(img.cols/3, img.cols/3));\n```", "```py\n    // Convert the result to float to allow multiply by 1 factor\n    Mat resultf;\n    result.convertTo(resultf, CV_32FC3);\n```", "```py\n    // Multiply our result with halo\n    multiply(resultf, halo, resultf);\n```", "```py\n    // convert to 8 bits\n    resultf.convertTo(result, CV_8UC3);\n\n    // show result\n    imshow(\"Lomograpy\", result);\n```", "```py\nvoid cartoonCallback(int state, void* userData)\n{\n    /** EDGES **/\n    // Apply median filter to remove possible noise\n    Mat imgMedian;\n    medianBlur(img, imgMedian, 7);\n\n    // Detect edges with canny\n    Mat imgCanny;\n    Canny(imgMedian, imgCanny, 50, 150);\n\n    // Dilate the edges\n    Mat kernel= getStructuringElement(MORPH_RECT, Size(2,2));\n    dilate(imgCanny, imgCanny, kernel);\n\n    // Scale edges values to 1 and invert values\n    imgCanny= imgCanny/255;\n    imgCanny= 1-imgCanny;\n\n    // Use float values to allow multiply between 0 and 1\n    Mat imgCannyf;\n    imgCanny.convertTo(imgCannyf, CV_32FC3);\n\n    // Blur the edgest to do smooth effect\n    blur(imgCannyf, imgCannyf, Size(5,5));\n\n    /** COLOR **/\n    // Apply bilateral filter to homogenizes color\n    Mat imgBF;\n    bilateralFilter(img, imgBF, 9, 150.0, 150.0);\n\n    // truncate colors\n    Mat result= imgBF/25;\n    result= result*25;\n\n    /** MERGES COLOR + EDGES **/\n    // Create a 3 channles for edges\n    Mat imgCanny3c;\n    Mat cannyChannels[]={ imgCannyf, imgCannyf, imgCannyf};\n    merge(cannyChannels, 3, imgCanny3c);\n\n    // Convert color result to float \n    Mat resultf;\n    result.convertTo(resultf, CV_32FC3);\n\n    // Multiply color and edges matrices\n    multiply(resultf, imgCanny3c, resultf);\n\n    // convert to 8 bits color\n    resultf.convertTo(result, CV_8UC3);\n\n    // Show image\n    imshow(\"Result\", result);\n\n}\n```", "```py\nMat imgMedian;\nmedianBlur(img, imgMedian, 7);\n```", "```py\n// Detect edges with canny\nMat imgCanny;\nCanny(imgMedian, imgCanny, 50, 150);\n```", "```py\n    // Dilate the edges\n    Mat kernel= getStructuringElement(MORPH_RECT, Size(2,2));\n    dilate(imgCanny, imgCanny, kernel);\n```", "```py\n    // Scale edges values to 1 and invert values\n    imgCanny= imgCanny/255;\n    imgCanny= 1-imgCanny;\n```", "```py\n    // Use float values to allow multiply between 0 and 1\n    Mat imgCannyf;\n    imgCanny.convertTo(imgCannyf, CV_32FC3);\n```", "```py\n// Blur the edgest to do smooth effect\n    blur(imgCannyf, imgCannyf, Size(5,5));\n```", "```py\n// Apply bilateral filter to homogenizes color\n    Mat imgBF;\n    bilateralFilter(img, imgBF, 9, 150.0, 150.0);\n```", "```py\n// truncate colors\n    Mat result= imgBF/25;\n    result= result*25;\n```", "```py\n// Create a 3 channles for edges\n    Mat imgCanny3c;\n    Mat cannyChannels[]={ imgCannyf, imgCannyf, imgCannyf};\n    merge(cannyChannels, 3, imgCanny3c);\n```", "```py\n    // Convert color result to float \n    Mat resultf;\n    result.convertTo(resultf, CV_32FC3);\n\n    // Multiply color and edges matrices\n    multiply(resultf, imgCanny3c, resultf);\n```", "```py\n// convert to 8 bits color\n    resultf.convertTo(result, CV_8UC3);\n\n    // Show image\n    imshow(\"Result\", result);\n```"]