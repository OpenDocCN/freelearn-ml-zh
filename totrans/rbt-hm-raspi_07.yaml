- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning and Shopping for More Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a beginner robot platform up and running. The robot can drive around,
    and we have a pair of sensors already wired in. However, it becomes more interesting
    and useful if we add other sensors and devices – perhaps also a way to control
    the robot remotely!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at some of the devices we will use and what types
    they are, learning more about robot sensors in general. Then, we will look at
    actual device part numbers and plan where to put our devices on the robot, where
    there is space for them, and test-fitting them. Next, we will look at a purchase
    list to build this. Finally, we will build a sensor bracket for our robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing device types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning what to add and where
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shopping list – parts and where to find them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following software and computer setup:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A printer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeCAD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following robot-related hardware is required:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot build from previous chapters and a Micro USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sharp or fresh-blade plastic cutter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A metal ruler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin vise drill with 0.5 mm, 2 mm, and 3 mm **High-Speed Steel** (**HSS**)/twist
    bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety goggles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flat work area with good lighting, free of interruptions or being nudged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standoff or mounting kit with M2 and M3 standoffs, bolts, and nuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screwdrivers with appropriate ends for the bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M2 and M3 spanners to tighten bolts and standoffs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find all the FreeCAD designs, along with printable templates for this
    chapter, on GitHub at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-07](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-07).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sensors are how our robot collects information. You’ve already seen and used
    one – the encoders. You were also introduced to absolute versus relative sensors
    in [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), *Measuring Movement with Encoders
    on Raspberry Pi Pico*, so what additional sensors can we consider? And how do
    we interface with them?
  prefs: []
  type: TYPE_NORMAL
- en: Sensors collect information from devices on the robot, making closed-control
    feedback loops. Sensors can also collect information about the world around the
    robot, what is present there, or how it has changed in response to the robot’s
    motions.
  prefs: []
  type: TYPE_NORMAL
- en: Analog sensor types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly talked about analog and digital in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015).
    Analog sensors create a varying voltage, whereas digital sensors output only 1s
    and 0s – binary – using two fixed voltages.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Pico has a 12-bit **Analog-to-Digital Converter** (**ADC**) supporting
    analog sensors connected to 4 pins. Analog inputs are suitable for simple light
    sensors and variable resistors as inputs. However, analog sensors are less repeatable
    than digital sensors, and usually, one pin equals one sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Timed pulses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way that sensors can vary continuously is by using timing. For example,
    the HC-SR04 ultrasonic distance sensor outputs a pulse based on the detected distance.
    Timing this pulse provides the reading. These tend to need dedicated pins. These
    pulses can be measured using the PIO system we saw in the last chapter. These
    are digital in the sense that they only use binary inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Data bus sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Groups of digital pins can form buses, addressing and reading from many devices,
    including sensors. They have a complexity cost but allow for more interesting
    data. These have controllers of their own, often containing calibration data to
    account for variations in sensor manufacturing. In addition, the controllers do
    some sensor decoding and processing, reducing the code you’ll need. Example buses
    are USB, I2C, Serial, and SPI.
  prefs: []
  type: TYPE_NORMAL
- en: The robot block diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use a block diagram for our robot to get a simplified view of our robot
    and what we will connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may look like the wiring schematic, but it shows the logical relationships
    between things instead of physical connections or placements. The following diagram
    shows where the robot is now before we add more sensors to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Block diagram of the robot ](img/Figure_7.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Block diagram of the robot
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows our robot in block diagram form. In the middle, in
    a darker shade, is Raspberry Pi Pico, the central controller for this robot. Pico
    connects to the motor controller, which drives the motors. The motors have dashed
    lines to the encoders since they indirectly influence them, and the encoders,
    in turn, send data back to Pico, forming a feedback loop. Finally, with a dashed
    outline at the top of the diagram is your computer, connected via USB. It is dashed
    here because this is a temporary connection – notice there is a bidirectional
    arrow here.
  prefs: []
  type: TYPE_NORMAL
- en: We will add more blocks to this diagram as we enhance our robot. Let us see
    the devices we will be adding.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing device types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add other sensors and Bluetooth to communicate with our robot. We will
    look in depth at each in later chapters, but we should know enough to consider
    which we will buy. This section will involve taking a brief overview, making some
    trade-offs, and choosing the parts to use.
  prefs: []
  type: TYPE_NORMAL
- en: Distance sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Distance sensors, briefly mentioned in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015),
    let the robot sense its situation and surroundings to avoid or follow obstacles.
    Some kinds only return if a distance has crossed a threshold, but the more suitable
    types return a sensed distance value. We will focus on this latter type.
  prefs: []
  type: TYPE_NORMAL
- en: Most distance sensors bounce a beam from objects and measure their return time
    or angle to determine the distance. For example, clap opposite a wall in a large
    open space, and you will hear how long your echo takes to return. If you move
    further from the wall, the return time will be longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'These fall into two major categories: sound-based and light-based. Each has
    pros and cons. Let’s see some common types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Distance sensor types ](img/Figure_7.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Distance sensor types
  prefs: []
  type: TYPE_NORMAL
- en: The first sensor in the preceding figure is the VL53L1X, a light sensor. These
    sensors are lighter and significantly faster than the sound ones and use invisible
    infrared light. However, some can be confused by other sources of IR light, including
    bright sunlight.
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand sensor is a sound-based distance sensor, the HC-SR04, identifiable
    by the two cans. It uses ultrasonic sounds outside the normal range of human hearing.
    Sound sensors can be confused by secondary sounds, vibrations, and some surfaces
    – for example, fabrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table compares their attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sensor Type** | **HC-SR04+ Ultrasonic** | **VL53L1X** **IR Light** |'
  prefs: []
  type: TYPE_TB
- en: '| *Module size* | 45 mm x 20 mm x 12 mm | 19 mm x 19 mm x 3.2 mm |'
  prefs: []
  type: TYPE_TB
- en: '| *Weight* | 8-10 grams | 3-5 grams |'
  prefs: []
  type: TYPE_TB
- en: '| *Pin usage* | 2 per device, not sharable, specific | 2 I2C pins, sharable
    with other I2C devices |'
  prefs: []
  type: TYPE_TB
- en: '| *Speed* | Slow | Fast |'
  prefs: []
  type: TYPE_TB
- en: '| *Max range* | 4 m | 1.2 m |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – Distance sensor comparison
  prefs: []
  type: TYPE_NORMAL
- en: Based on the attributes in the table, the light-based sensors are more suitable
    for our Raspberry Pi Pico robot due to being smaller and lighter and having the
    ability to share an I2C bus. We will use two of these sensors facing forward on
    either side to determine where the closest object is and to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Distance sensors give the robot an awareness of its surroundings, but what about
    the robot’s orientation? We’ll see a sensor for this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Inertial measurement unit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An **Inertial Measurement Unit** (**IMU**) lets us detect the robot’s orientation.
    It can give us an absolute orientation and usually combine three sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: A gyroscope – measuring relative rotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An accelerometer – measuring accelerations, and using gravity, figuring out
    which way is down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A magnetometer – measuring magnetic fields, looking for magnetic poles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code can combine the data from these sensors to create an orientation relative
    to gravity and the magnetic north. Some also include a temperature sensor. We
    describe the IMU sensor count with **Degrees of Freedom** (**DOF**). Each combination
    of direction and type of measurement is a DOF – for example, acceleration on the
    *x*-axis is one, and rotation on the *x*-axis is another. Having all three sensors
    is described as 9-DOF, so we should stick with these types.
  prefs: []
  type: TYPE_NORMAL
- en: IMU devices usually use the I2C bus and can share it with other devices, including
    the distance sensor shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: Effective use of an IMU requires **sensor fusion**, combining calibrated readings
    from multiple sensors into a helpful form – in this case, an absolute orientation
    of the robot. Some sensor modules have this ability on board. You want this to
    offload the handling from Raspberry Pi Pico, and you will not need to write the
    code for this fusion.
  prefs: []
  type: TYPE_NORMAL
- en: The BNO055 is a great choice; it is common, and has libraries for CircuitPython
    and some convenient interfaces, with an onboard processor doing the sensor fusion
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: We now have considered a few sensors, but what about control? The next device
    we will look at is Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been driving our robot tethered to a computer for starting programs
    and getting feedback; this is not ideal. However, we can add Bluetooth capability
    to our Raspberry Pi Pico and communicate to it from our computer or even a smartphone
    wirelessly.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B18001_09.xhtml#_idTextAnchor189), *Teleoperating the Raspberry
    Pi Pico Robot with Bluetooth LE*, we will consider other options and trade-offs
    we can make, discussing alternative solutions to Bluetooth **Low Energy** (**LE**).
    While it is not the only option, the AdaFruit Bluefruit LE UART Friend ADA 2479
    module achieves a balance between complexity and cost that works for this project.
  prefs: []
  type: TYPE_NORMAL
- en: This module uses two pins to communicate, with optional pins for extended functionality.
    We will use two pins for a serial port, also known as a **Universal Asynchronous
    Receiver-Transmitter** (**UART**). This allows us to send and receive data easily.
  prefs: []
  type: TYPE_NORMAL
- en: It will be used in [*Chapter 9*](B18001_09.xhtml#_idTextAnchor189), *Teleoperating
    the Raspberry Pi Pico Robot with Bluetooth*, for remote driving and sensor monitoring
    with Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: Device pin usage summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We require 2 I2C buses for all these devices – at 4 pins each, for the IMU and
    distance sensors, and 1 UART with 2 pins for Bluetooth, this consumes a total
    of 10 pins. Our existing motors used 4 pins each, totaling 8 pins. We have used
    18 pins from Raspberry Pi Pico’s potential 30, which means you have plenty of
    pins for expanding this robot.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have ideas for remote operation and sensors, we can consider adding
    them to our robot.
  prefs: []
  type: TYPE_NORMAL
- en: Planning what to add and where
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The product pages for these devices usually include their dimensions. Depending
    on which exact breakout you buy, you may need to adapt these designs. Let us use
    some known models and make a rough test fit to turn into a design.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth and IMU mounting plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Bluetooth and IMU should be above the rest of the robot. The IMU’s magnetic
    sensors should not be near the motors and encoders. Putting the Bluetooth higher
    improves the signal. This rough drawing shows the plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Rough sketch of the shelf ](img/Figure_7.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Rough sketch of the shelf
  prefs: []
  type: TYPE_NORMAL
- en: The Bluetooth and IMU, shown in the figure as darker boxes, could be placed
    on a shelf to distance them from interference with the motors. This shelf, shown
    in transparent white in the preceding figure, is mounted on standoffs, shown as
    darker bolt holes. This rough part is superimposed on a FreeCAD sketch to show
    where it goes.
  prefs: []
  type: TYPE_NORMAL
- en: We are likely, at least while we are developing this robot, to change the wiring
    more frequently than the batteries, so we can mount the shelf above the batteries
    using the standoff kit we’ve already bought.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to plan the distance sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Distance sensor mounting plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The distance sensors should be at the front of the robot. The following rough
    sketch shows how they could be mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Rough sketch of the distance sensors mounted on the chassis
    ](img/Figure_7.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Rough sketch of the distance sensors mounted on the chassis
  prefs: []
  type: TYPE_NORMAL
- en: We can use brackets to mount two sensors facing forward, as shown in *Figure
    7**.4*. We can make these by sawing sections from right-angled cover trim for
    walls. We will use bolts to hold the sensor on the bracket and the bracket on
    the robot. We can add slots for the pin headers.
  prefs: []
  type: TYPE_NORMAL
- en: The headers for the distance sensors are male, and we have a breadboard with
    female holes. To connect these, we will need more than the precut wires. Male-to-female
    jumper wires should do for this.
  prefs: []
  type: TYPE_NORMAL
- en: The shelf and brackets are a little more complicated than the styrene rod construction
    before. We will look at how we put them together below – but first, let us shop.
  prefs: []
  type: TYPE_NORMAL
- en: Shopping list – parts and where to find them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve collected enough information to buy the parts we’ll need. Let us see what
    exact parts I recommend.
  prefs: []
  type: TYPE_NORMAL
- en: 'You bought parts in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015), and used
    some of these items in previous chapters. However, you should still have stock
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Styrene 3 mm sheet – these usually come in packs of a few, so you’ll have a
    few around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standoff kits with 2 mm, 2.5mm, and 3 mm standoffs, bolts, and screws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.54 mm pitch straight breakaway single-row headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I then recommend the following additional parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The Adafruit 2742 BNO055 IMU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adafruit Bluefruit LE UART Friend ADA 2479 module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x Pimoroni PIM373 VL53L1X **Time-of-Flight** (**ToF**) sensor breakouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-female extension jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 30 mm PVC right-angle cover trim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are also going to need some additional tools as we make more interesting
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A medium hacksaw or tenon saw to cut the cover trim.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clamp to hold the plastic when sawing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of needle files for making wiring slots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, some side cutters may make it easier to make the slots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital calipers for making finer measurements in small spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About 200 mm strip of wood, roughly 30 mm wide by 20 mm tall to assist in cutting
    the trim. An offcut will do, but it must be straight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the same suppliers from [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015),
    *Planning a Robot with Raspberry Pi Pico*, for the parts and tools. Now that we
    know what to buy, we need to plan how to mount it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have parts and rough ideas for how to mount our sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Using the techniques learned in [*Chapter 3*](B18001_03.xhtml#_idTextAnchor055),
    *Designing a Robot Chassis in FreeCAD*, we can model these brackets and shelves
    in FreeCAD. You can also get these designs from GitHub at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-07](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-07).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows what this looks like in FreeCAD 3D View:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The chassis with the sensor mounts ](img/Figure_7.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – The chassis with the sensor mounts
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, there is a 3D view of the robot in FreeCAD. At the
    rear, above the batteries, is a shelf for the Bluetooth and IMU. There are bolt
    holes under this in the chassis.
  prefs: []
  type: TYPE_NORMAL
- en: At the front of the figure are the two brackets for the distance sensors, with
    mounting holes for the sensors and slots cut out for the connection header to
    poke through.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take a closer look at each sensor mounting design.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the shelf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will make the shelf with styrene. The following diagram shows the suggested
    dimensions for the shelf layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Rear shelf drawing ](img/Figure_7.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Rear shelf drawing
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows the shelf. The width of the lower chassis drives the top
    150 mm dimension. The side dimension should be enough for the parts to rest on,
    but you could base it on the scrap styrene material you have left from [*Chapter
    4*](B18001_04.xhtml#_idTextAnchor080), *Building a Robot around Pico*, if that
    is slightly smaller. Just ensure that the bolt holes match the shelf and the chassis.
    We can model them as a single part.
  prefs: []
  type: TYPE_NORMAL
- en: You can sketch this part in **Sketch Main** on the **XY** plane. Use **Chassis
    Outline** as a guide with external geometry. Make sure the supports will not interfere
    with the battery box. The pockets are defined by the dimensions of the IMU and
    Bluetooth modules, as found on their product pages, with a few extra millimeters
    for wiggle room.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shelf needs to be 30 mm above the chassis. The following figure shows
    how:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The shelf sketch ](img/Figure_7.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – The shelf sketch
  prefs: []
  type: TYPE_NORMAL
- en: Select the sketch for the shelf outline (`30.00 mm`. This value will place the
    shelf above the chassis and batteries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch can be padded into 3D using the same ShapeBinder and pad techniques
    discussed before. The following figure shows how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – 3D padded shelf ](img/Figure_7.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – 3D padded shelf
  prefs: []
  type: TYPE_NORMAL
- en: This image shows the shelf padded to 3 mm in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to use ShapeBinders and a pocket to cut the holes in the `ChassisPlate`
    part.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to build the shelf part from these designs.
  prefs: []
  type: TYPE_NORMAL
- en: Cutting the shelf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the techniques from [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080),
    *Building a Robot around Pico*, to cut this. Let’s start by creating a FreeCAD
    drawing to use as a template. The following figure shows the drawing and how to
    use it to make the part:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Drilling the shelf  ](img/Figure_7.09_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Drilling the shelf
  prefs: []
  type: TYPE_NORMAL
- en: The left part of the preceding image shows the drawings taped carefully onto
    the part. If the tape is slipping, try using a glue stick instead. Ensure that
    you’ve secured the paper template to the plastic and that you can remove it again
    later.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080), *Building a Robot
    around Pico*, use a tiny drill bit to dot the corners of these rectangles. We
    drill the outline dots through the paper and then follow up with the drill holes
    (3 mm) using a hand drill, leaving the paper in place. Placing some old wood underneath
    saves you from leaving holes in the cutting mat.
  prefs: []
  type: TYPE_NORMAL
- en: 'The holes give us a guide. The following figure shows us how we should cut
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Cutting the shelf ](img/Figure_7.10_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Cutting the shelf
  prefs: []
  type: TYPE_NORMAL
- en: The top of *Figure 7**.10* shows the dot for cutting alongside a larger 3 mm
    hole. We have removed the paper, as some of the lines will be very close to the
    edge when using scrap. These cuts will be easier without the paper.
  prefs: []
  type: TYPE_NORMAL
- en: Next, as the bottom-left panel shows, line up the metal ruler with two of the
    dots for an edge – for example, the top line of the left inside pocket – and using
    a fresh, sharp blade, let the point of the blade find the hole in the top-left
    corner. You should then be able to follow the ruler and line nearly – but not
    all the way – to the other hole. Again, this cut is a light score, and we’ll make
    many cuts coming from both sides to keep it between the corners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cut until the scores go nearly all the way through. The following figure shows
    how to extract it from the sheet and finish this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Finishing the shelf ](img/Figure_7.11_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Finishing the shelf
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.11* shows the stages of finishing the part. In the top-left panel,
    flexing the panel has snapped off a section – when scored deeply, this will snap
    quite nicely. The closer edges may require you to cut through with the knife.'
  prefs: []
  type: TYPE_NORMAL
- en: The top-right panel shows this part snapped out of its sheet fully. It is a
    bit sharp and has some burrs, so we sand it as shown in the bottom-right panel.
    Low grit (600) should be enough to take off most of the burrs and round the corners
    for a nicer finish.
  prefs: []
  type: TYPE_NORMAL
- en: You should end up with something like the bottom-right panel. This shelf there
    looks ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the rear shelf ready to assemble, we can look at designing
    the front sensor brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the front sensor brackets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using our rough designs and the dimensions of the right-angle trim, we can
    turn these plans into more formal designs and drawings. The following figure shows
    a close-up of the sensor brackets with dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Drawings of the sensor brackets ](img/Figure_7.12_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Drawings of the sensor brackets
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows the side, front, and top views of the bracket. There are M2
    bolt holes on both sides and a rectangular slot on the front to let through the
    header connections. The height and length of the brackets depend on the right-angle
    trim size. The bracket is 24 mm long to accommodate the Pimoroni distance sensor.
    I used calipers to measure the holes in the Pimoroni sensor for this drawing.
  prefs: []
  type: TYPE_NORMAL
- en: I suggest sketching the top view on the chassis plate, with one rectangle plus
    a construction mirror line between the holes – that way, you can make shape binders
    for the base of the bracket. I’ve aligned the front of these with the front line
    of the chassis and padded the bracket bases. Next, you make pockets for the holes
    in `ChassisPlate` and the bracket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch these brackets symmetrically, as you did for the motors, and make them
    42 mm apart. Then create a sketch on the **XZ** plane for the front of the brackets
    (100 mm forward). Next, pad the tall part up 30 mm from the bases and use the
    XZ sketch to cut pockets. The following picture shows the brackets in 2D on the
    chassis plate and how this looks in 3D:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – The brackets design on the chassis ](img/Figure_7.13_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – The brackets design on the chassis
  prefs: []
  type: TYPE_NORMAL
- en: The top part of the figure shows a drawing of the brackets dimensioned and lined
    up on `ChassisPlate`. The lower panel shows a 3D view of these parts on the model.
  prefs: []
  type: TYPE_NORMAL
- en: This design is enough to create the drawing shown in *Figure 7**.13*, and in
    the next section, we will use it to make this part.
  prefs: []
  type: TYPE_NORMAL
- en: Cutting the sensor brackets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now take this design to the workshop and cut these parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how to mark the first two cuts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Marking out bracket cuts ](img/Figure_7.14_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Marking out bracket cuts
  prefs: []
  type: TYPE_NORMAL
- en: The figure starts with using a ruler to mark 24 mm for the width of the bracket.
    I am using the clamp to keep the angle trim in place. Then, follow up with the
    square to get a straight line. The middle picture shows this line going around
    the part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last image shows the waste side shaded, so you know where to cut. A cut
    is not 0 mm, so err on the side of it being too big. Look at the following figure
    for information on cutting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Cutting the sensor brackets ](img/Figure_7.15_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Cutting the sensor brackets
  prefs: []
  type: TYPE_NORMAL
- en: The top panel of the preceding figure shows clamping the right-angled trim with
    the strip of wood supporting it. This wood should stop short of the line you cut
    at and supports the angled trim while you cut it.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom panel shows me cutting in on the right-angled bend, which is easier
    than cutting by the sides.
  prefs: []
  type: TYPE_NORMAL
- en: The material will flex as you get to the end and have cut through one side.
    You need to support the other end and slow down the saw strokes when this happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cut 2 of these 24-mm lengths. These parts will be rough and require finishing
    with sandpaper, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – The parts ready for smoothing ](img/Figure_7.16_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – The parts ready for smoothing
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding figure shows, the parts have very rough edges. You will need
    to use multiple passes of the grades of sandpaper to smooth both the brackets
    as the figure shows. For a nice finish, you could round the corners.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to drill out holes as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Drilling holes into the sensor brackets ](img/Figure_7.17_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Drilling holes into the sensor brackets
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.17* shows the parts in a clamp and marked with a pattern to assist
    drilling – this has a middle line, then holes on either side. I use calipers for
    this; however, my drawings are not perfect, and yours do not need to be either.'
  prefs: []
  type: TYPE_NORMAL
- en: Start each hole with a smaller drill bit, then open it to 2 mm. This material,
    uPVC, is tougher than styrene and takes more effort to get through. There are
    drill holes on the front and through the base of this bracket. Make these before
    continuing to the slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toughest part will be drilling out the slots. The following figure shows
    how to cut this slot out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Cutting and filing out the slots ](img/Figure_7.18_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – Cutting and filing out the slots
  prefs: []
  type: TYPE_NORMAL
- en: The top-left panel in the preceding figure shows me making a hole with a 3-mm
    bit. Make holes along the length of the slot, as shown in the top-right panel.
    They do not need to be perfectly constrained in the slot but closely inside.
  prefs: []
  type: TYPE_NORMAL
- en: As the bottom-left panel shows, choose a needle file with a corner (angular)
    profile, and push it into the holes to break them out. You could optionally use
    side cutters to join the holes. Then, when you have joined the holes, file the
    slot out into a rectangle. Finally, when you have made a wider shape, use a wide
    flat needle file to make a letterbox profile.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom right shows that the hole only needs to be big enough to accommodate
    the plastic pin header body. At that point, you can stop filing.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now manufactured the shelf plates and the brackets. However, we still
    need to modify the chassis plate and fit them.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the chassis plate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The chassis plate needs eight additional holes to accommodate the new fittings.
    You should be able to use your FreeCAD designs to get the following drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Drawing of the chassis plate with sensor mounting holes ](img/Figure_7.19_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – Drawing of the chassis plate with sensor mounting holes
  prefs: []
  type: TYPE_NORMAL
- en: At the top of this drawing, representing the robot’s rear, is the shelf, with
    4 additional 3 mm holes to drill, 2 on either side, for putting in the shelf standoffs.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the figure (the front of the robot) are four additional holes
    at the front of the chassis, 2 mm wide for bolting on the brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this part, we have marked out the dimensions on the drawing, and we will
    use calipers to mark these holes before drilling them, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Measuring and marking out the chassis plate holes ](img/Figure_7.20_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Measuring and marking out the chassis plate holes
  prefs: []
  type: TYPE_NORMAL
- en: In the top panel of *Figure 7**.20*, I use the straight edge at the top of the
    calipers to mark one of the rear shelf holes at 4 mm from the edge. The panel
    in the bottom left shows the holes for the rear shelf marked out this way, and
    the bottom right shows the holes for the brackets.
  prefs: []
  type: TYPE_NORMAL
- en: While not essential, marking and drilling the chassis plate with the upper deck
    parts and wheels removed is easier. When you have completed these steps, just
    be sure to put them back as specified in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: You can drill out the holes in the usual way, starting with the smaller diameter
    drill bit, then making the bracket holes 2 mm, and the shelf holes 3 mm. After
    drilling the uPVC, you will notice how much easier they are to drill!
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to assemble the robot again.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now get into the exciting business of adding new sections, starting
    with the shelf, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Assembling the Bluetooth and IMU shelf ](img/Figure_7.21_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – Assembling the Bluetooth and IMU shelf
  prefs: []
  type: TYPE_NORMAL
- en: The top-left panel in the preceding figure shows the robot alongside the shelf
    panel and a set of standoffs. As shown in the top-right panel, you may need to
    join two standoffs to clear the battery box.
  prefs: []
  type: TYPE_NORMAL
- en: As the bottom panels show, you then bolt the standoffs into the robot base,
    with nuts to support them underneath. Bolt the shelf layer on top of the standoffs;
    this should look like the bottom-right panel. I’ve also added a hook-and-loop
    dot for the Bluetooth module. We will leave the IMU side to add standoffs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to add in the sensor front-facing brackets, as the following
    figure shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Assembling the front-facing brackets ](img/Figure_7.22_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Assembling the front-facing brackets
  prefs: []
  type: TYPE_NORMAL
- en: As the top of *Figure 7**.22* shows, we need an M2 bolt and nut for each bracket.
    Bolt these into the holes at the front of the chassis.
  prefs: []
  type: TYPE_NORMAL
- en: The chassis now looks like the bottom panel. This robot is now ready for us
    to start experimenting with sensors. We will not bolt the sensors in just yet,
    as we have wiring to do for them, which we will get to in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about more sensor and device types. We then revisited
    our robot, planning where to add these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter showed a shopping list for these parts and then used dimensions
    from the product pages of these parts to make CAD drawings. The CAD drawings let
    us visualize what we wanted in 3D. Next, we fabricated parts from these drawings.
  prefs: []
  type: TYPE_NORMAL
- en: We revisited manufacturing parts and used a variation on the template technique
    to make the brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we assembled all these parts and now have a robot base ready to add
    sensors. We will wire in and program these sensors in the following chapters,
    starting with the distance sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These exercises will help further develop the skills learned in this chapter.
    As we have not attached the switch to the chassis, we can use it to practice these
    skills:'
  prefs: []
  type: TYPE_NORMAL
- en: The sensor brackets are facing directly forward. The robot would have better
    sensor coverage and look better if you aligned the sensors with an angled front.
    This will likely require using other FreeCAD constraints or skills.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shelf is flat and uses a hook-and-loop to hold devices. Using FreeCAD, could
    you design another layer with recesses for the peripheral boards? Could you then
    use the skills learned here to build it? You may require a coping saw for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We referenced these datasheets and product pages in the text:'
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit Bluefruit UART LE Friend product page with dimensions – [https://www.adafruit.com/product/2479](https://www.adafruit.com/product/2479)
    and [https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/downloads](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/downloads)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adafruit BNO055 breakout page with dimensions – [https://www.adafruit.com/product/2472](https://www.adafruit.com/product/2472)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pimoroni VL53L1 breakout page with dimensions – [https://shop.pimoroni.com/products/vl53l1x-breakout](https://shop.pimoroni.com/products/vl53l1x-breakout)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further information on Bluetooth LE, consider *Building Bluetooth Low Energy
    Systems* by Muhammad Usama bin Aftab. This dives into the details of wireless
    network communication systems suitable for use in the **Internet of Things** (**IoT**).
    IoT concepts translate well into robotics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out more about sawing, check out the following guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Little Saw – A Workshopshed Guide to Cutting Tools* by *Andy Clarke* has
    excellent information on cutting different materials well. This little book shows
    the suitable saws and the right ways to use them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
