<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer080">
    <h1 class="chapterNumber">2</h1>
    <h1 class="chapterTitle" id="_idParaDest-36">Managing and Understanding Data</h1>
    <p class="normal">A key early component of any machine learning project involves managing and understanding data. Although this may not be as gratifying as building and deploying models—the stages in which you begin to see the fruits of your labor—it is unwise to ignore this important preparatory work.</p>
    <p class="normal">Any learning algorithm is only as good as its training data, and in many cases, this data is complex, messy, and spread across multiple sources and formats. Due to this complexity, often the largest portion of effort invested in machine learning projects is spent on data preparation and exploration.</p>
    <p class="normal">This chapter approaches data preparation in three ways. The first section discusses the basic data structures R uses to store data. You will become very familiar with these structures as you create and manipulate datasets. The second section is practical, as it covers several functions that are used for getting data in and out of R. In the third section, methods for understanding data are illustrated while exploring a real-world dataset.</p>
    <p class="normal">By the end of this chapter, you will understand:</p>
    <ul>
      <li class="bulletList">How to use R’s basic data structures to store and manipulate values</li>
      <li class="bulletList">Simple functions to get data into R from common source formats</li>
      <li class="bulletList">Typical methods to understand and visualize complex data</li>
    </ul>
    <p class="normal">The ways R handles data will dictate the ways you must work with data, so it is helpful to understand R’s data structures before jumping directly into data preparation. However, if you are already familiar with R programming, feel free to skip ahead to the section on data preprocessing.</p>
    <div class="note">
      <p class="normal">All code files for this book can be found at <a href="https://github.com/PacktPublishing/Machine-Learning-with-R-Fourth-Edition"><span class="url">https://github.com/PacktPublishing/Machine-Learning-with-R-Fourth-Edition</span></a></p>
    </div>
    <h1 class="heading-1" id="_idParaDest-37">R data structures</h1>
    <p class="normal">There are <a id="_idIndexMarker136"/>numerous types of data structures found in programming languages, each with strengths and weaknesses suited to specific tasks. Since R is a programming language used widely for statistical data analysis, the data structures it utilizes were designed with this type of work in mind.</p>
    <p class="normal">The R data structures used most frequently in machine learning are vectors, factors, lists, arrays, matrices, and data frames. Each is tailored to a specific data management task, which makes it important to understand how they will interact in your R project. In the sections that follow, we will review their similarities and differences.</p>
    <h2 class="heading-2" id="_idParaDest-38">Vectors</h2>
    <p class="normal">The<a id="_idIndexMarker137"/> fundamental R <a id="_idIndexMarker138"/>data structure is a <strong class="keyWord">vector</strong>, which stores an ordered set of values called <strong class="keyWord">elements</strong>. A <a id="_idIndexMarker139"/>vector can contain any number of elements. However, all of a vector’s elements must be of the same type; for instance, a vector cannot contain both numbers and text. To determine the type of vector <code class="inlineCode">v</code>, use the <code class="inlineCode">typeof(v)</code> command. Note that R is a <strong class="keyWord">case-sensitive</strong> language, which means that lower-case <code class="inlineCode">v</code> and upper-case <code class="inlineCode">V</code> could represent two different vectors. This is also true for R’s built-in functions and keywords, so be sure to always use the correct capitalization when typing R commands or expressions.</p>
    <p class="normal">Several vector types are commonly used in machine learning: <code class="inlineCode">integer</code> (numbers without decimals), <code class="inlineCode">double</code> (numbers with decimals), <code class="inlineCode">character</code> (text data, also commonly called “string” data), and <code class="inlineCode">logical</code> (<code class="inlineCode">TRUE</code> or <code class="inlineCode">FALSE</code> values). Some R functions will report both <code class="inlineCode">integer</code> and <code class="inlineCode">double</code> vectors as <code class="inlineCode">numeric</code>, while others distinguish between the two; generally, this distinction is unimportant. Vectors of logical values are used often in R, but notice that the <code class="inlineCode">TRUE</code> and <code class="inlineCode">FALSE</code> values must be written in all caps. This is slightly different from some other programming languages.</p>
    <p class="normal">There are also two special values that are relevant to all vector types: <code class="inlineCode">NA</code>, which indicates a <em class="italic">missing</em> value, and <code class="inlineCode">NULL</code>, which is used to indicate the absence of <em class="italic">any</em> value. Although these two may seem to be synonymous, they are indeed slightly different. The <code class="inlineCode">NA</code> value is a placeholder for something else and therefore has a length of one, while the <code class="inlineCode">NULL</code> value is truly empty and has a length of zero.</p>
    <p class="normal">It is <a id="_idIndexMarker140"/>tedious<a id="_idIndexMarker141"/> to enter large amounts of data by hand, but simple vectors can be created by using the <code class="inlineCode">c()</code> combine function. The vector can also be given a name using the arrow <code class="inlineCode">&lt;-</code> operator. This is R’s assignment operator, used much like the <code class="inlineCode">=</code> assignment operator used in many other programming languages.</p>
    <div class="packt_tip">
      <p class="normal">R also allows the use of the <code class="inlineCode">=</code> operator for assignment, but it is considered a poor coding style according to commonly accepted style guidelines.</p>
    </div>
    <p class="normal">For example, let’s construct a set of vectors containing data on three medical patients. We’ll create a character vector named <code class="inlineCode">subject_name</code> to store the three patient names, a numeric vector named <code class="inlineCode">temperature</code> to store each patient’s body temperature in degrees Fahrenheit, and a logical vector named <code class="inlineCode">flu_status</code> to store each patient’s diagnosis (<code class="inlineCode">TRUE</code> if they have influenza, <code class="inlineCode">FALSE</code> otherwise). As shown in the following code, the three vectors are:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject_name &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-string">"John Doe"</span>, <span class="hljs-string">"</span><span class="hljs-string">Jane Doe"</span>, <span class="hljs-string">"Steve Graves"</span>)
&gt; temperature &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">98.1</span>, <span class="hljs-number">98.6</span>, <span class="hljs-number">101.4</span>)
&gt; flu_status &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-literal">FALSE</span>, <span class="hljs-literal">FALSE</span>, <span class="hljs-literal">TRUE</span>)
</code></pre>
    <p class="normal">Values stored in R vectors retain their order. Therefore, data for each patient can be accessed using their position in the set, beginning at <code class="inlineCode">1</code>, then supplying this number inside square brackets (that is, <code class="inlineCode">[</code> and <code class="inlineCode">]</code>) following the name of the vector. For instance, to obtain the temperature value for patient Jane Doe, the second patient, simply type:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; temperature[<span class="hljs-number">2</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 98.6
</code></pre>
    <p class="normal">R offers a variety of methods to extract data from vectors. A range of values can be obtained using the colon operator. For instance, to obtain the body temperature of the second and third patients, type:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; temperature[<span class="hljs-number">2:3</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 98.6 101.4
</code></pre>
    <p class="normal">Items can be excluded by specifying a negative item number. To exclude the second patient’s temperature data, type:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; temperature[<span class="hljs-number">-2</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1]  98.1 101.4
</code></pre>
    <p class="normal">It is also <a id="_idIndexMarker142"/>sometimes useful to specify a logical vector indicating whether each item should be included. For example, to include the first two temperature readings but exclude the third, type:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; temperature[<span class="hljs-built_in">c</span>(<span class="hljs-literal">TRUE</span>, <span class="hljs-literal">TRUE</span>, <span class="hljs-literal">FALSE</span>)]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 98.1 98.6
</code></pre>
    <p class="normal">The <a id="_idIndexMarker143"/>importance of this type of operation is clearer with the realization that the result of a logical expression like <code class="inlineCode">temperature &gt; 100</code> is a logical vector. This expression returns <code class="inlineCode">TRUE</code> or <code class="inlineCode">FALSE</code> depending on whether the temperature is greater than 100 degrees Fahrenheit, which indicates a fever. Therefore, the following commands will identify the patients exhibiting a fever:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; fever &lt;- temperature &gt; <span class="hljs-number">100</span>
&gt; subject_name[fever]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] "Steve Graves"
</code></pre>
    <p class="normal">Alternatively, the logical expression can also be moved inside the brackets, which returns the same result in a single step:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject_name[temperature &gt; <span class="hljs-number">100</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] "Steve Graves"
</code></pre>
    <p class="normal">As you will see shortly, the vector provides the foundation for many other R data structures and can be combined with programming expressions to complete more complex operations for selecting data and constructing new features. Therefore, knowing the various vector operations is crucial for working with data in R.</p>
    <h2 class="heading-2" id="_idParaDest-39">Factors</h2>
    <p class="normal">Recall <a id="_idIndexMarker144"/>from <em class="chapterRef">Chapter 1</em>, <em class="italic">Introducing Machine Learning</em>, that nominal features represent a characteristic with categories of values. Although it is possible to use a character vector to store nominal data, R provides a data structure specifically for this task. </p>
    <p class="normal">A <strong class="keyWord">factor</strong> is a special type of vector that is solely used for representing categorical or ordinal data. In the medical dataset we are building, we might use a factor to represent the patients’ biological sex and record two categories: male and female.</p>
    <p class="normal">Why use<a id="_idIndexMarker145"/> factors rather than character vectors? One advantage of factors is that the category labels are stored only once. Rather than storing <code class="inlineCode">MALE</code>, <code class="inlineCode">MALE</code>, <code class="inlineCode">FEMALE</code>, the computer may store <code class="inlineCode">1</code>, <code class="inlineCode">1</code>, <code class="inlineCode">2</code>, which can reduce the memory needed to store the values. Additionally, many machine learning algorithms handle nominal and numeric features differently. Coding categorical features as factors allows R to treat the categorical features appropriately.</p>
    <div class="packt_tip">
      <p class="normal">A factor should not be used for character vectors with values that don’t truly fall into categories. If a vector stores mostly unique values such as names or identification codes like social security numbers, keep it as a character vector.</p>
    </div>
    <p class="normal">To create a factor from a character vector, simply apply the <code class="inlineCode">factor()</code> function. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; gender &lt;- factor(<span class="hljs-built_in">c</span>(<span class="hljs-string">"MALE"</span>, <span class="hljs-string">"FEMALE"</span>, <span class="hljs-string">"MALE"</span>))
&gt; gender
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] MALE   FEMALE MALE
Levels: FEMALE MALE
</code></pre>
    <p class="normal">Notice that when the <code class="inlineCode">gender</code> factor was displayed, R printed additional information about its levels. The levels comprise the set of possible categories the factor could take, in this case, <code class="inlineCode">MALE</code> or <code class="inlineCode">FEMALE</code>.</p>
    <p class="normal">When we <a id="_idIndexMarker146"/>create factors, we can add additional levels that may not appear in the original data. Suppose we created another factor for blood type, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; blood &lt;- factor(<span class="hljs-built_in">c</span>(<span class="hljs-string">"O"</span>, <span class="hljs-string">"AB"</span>, <span class="hljs-string">"A"</span>),
            levels = <span class="hljs-built_in">c</span>(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"AB"</span>, <span class="hljs-string">"O"</span>))
&gt; blood
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] O  AB A
Levels: A B AB O
</code></pre>
    <p class="normal">When <a id="_idIndexMarker147"/>we defined the <code class="inlineCode">blood</code> factor, we specified an additional vector of four possible blood types using the <code class="inlineCode">levels</code> parameter. As a result, even though our data includes only blood types O, AB, and A, all four types are retained with the <code class="inlineCode">blood</code> factor, as the output shows. Storing the additional level allows for the possibility of adding patients with the other blood type in the future. It also ensures that if we were to create a table of blood types, we would know that type B exists, despite it not being found in our initial data.</p>
    <p class="normal">The factor data structure also allows us to include information about the order of a nominal feature’s categories, which provides a method for creating ordinal features. For example, suppose we have data on the severity of patient symptoms, coded in increasing order of severity from mild, to moderate, to severe. We indicate the presence of ordinal data by providing the factor’s levels in the desired order, listed ascending from lowest to highest, and setting the <code class="inlineCode">ordered</code> parameter to <code class="inlineCode">TRUE</code> as shown:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; symptoms &lt;- factor(<span class="hljs-built_in">c</span>(<span class="hljs-string">"SEVERE"</span>, <span class="hljs-string">"MILD"</span>, <span class="hljs-string">"MODERATE"</span>),
               levels = <span class="hljs-built_in">c</span>(<span class="hljs-string">"MILD"</span>, <span class="hljs-string">"MODERATE"</span>, <span class="hljs-string">"SEVERE"</span>),
               ordered = <span class="hljs-literal">TRUE</span>)
</code></pre>
    <p class="normal">The resulting <code class="inlineCode">symptoms</code> factor now includes information about the requested order. Unlike our prior factors, the levels of this factor are separated by <code class="inlineCode">&lt;</code> symbols to indicate the presence of a sequential order from <code class="inlineCode">MILD</code> to <code class="inlineCode">SEVERE</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; symptoms
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] SEVERE   MILD     MODERATE
Levels: MILD &lt; MODERATE &lt; SEVERE
</code></pre>
    <p class="normal">A helpful feature of ordered factors is that logical tests work as you would expect. For instance, we can<a id="_idIndexMarker148"/> test whether each patient’s symptoms are more severe than moderate:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; symptoms &gt; <span class="hljs-string">"MODERATE"</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1]  TRUE FALSE FALSE
</code></pre>
    <p class="normal">Machine learning algorithms <a id="_idIndexMarker149"/>capable of modeling ordinal data will expect ordered factors, so be sure to code your data accordingly.</p>
    <h2 class="heading-2" id="_idParaDest-40">Lists</h2>
    <p class="normal">A <strong class="keyWord">list</strong> is<a id="_idIndexMarker150"/> a<a id="_idIndexMarker151"/> data structure, much like a vector, in that it is used for storing an ordered set of elements. However, where a vector requires all its elements to be the same type, a list allows different R data types to be collected. Due to this flexibility, lists are often used to store various types of input and output data and sets of configuration parameters for machine learning models.</p>
    <p class="normal">To illustrate lists, consider <a id="_idIndexMarker152"/>the medical patient dataset we have been constructing, with data for three patients stored in six vectors. If we wanted to display all the data for the first patient, we would need to enter five R commands:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject_name[<span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] "John Doe"
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; temperature[<span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 98.1
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; flu_status[<span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] FALSE
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; gender[<span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] MALE
Levels: FEMALE MALE
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; blood[<span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] O
Levels: A B AB O
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; symptoms[<span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] SEVERE
Levels: MILD &lt; MODERATE &lt; SEVERE
</code></pre>
    <p class="normal">If we expect to examine the patient’s data again in the future, rather than retyping these commands, a list allows us to group all the values into one object we can use repeatedly.</p>
    <p class="normal">Similar to creating a vector with <code class="inlineCode">c()</code>, a list is created using the <code class="inlineCode">list()</code> function, as shown in the following example. One notable difference is that when a list is constructed, each component in the sequence should be given a name. The names are not strictly required, but allow the values to be accessed later by name rather than by numbered<a id="_idIndexMarker153"/> position and a mess of square brackets. To create a list with named components for the first patient’s values, type the following:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject1 &lt;- <span class="hljs-built_in">list</span>(fullname = subject_name[<span class="hljs-number">1</span>],
                   temperature = temperature[<span class="hljs-number">1</span>],
                   flu_status = flu_status[<span class="hljs-number">1</span>],
                   gender = gender[<span class="hljs-number">1</span>],
                   blood = blood[<span class="hljs-number">1</span>],
                   symptoms = symptoms[<span class="hljs-number">1</span>])
</code></pre>
    <p class="normal">This patient’s data is now collected in the <code class="inlineCode">subject1</code> list:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject1
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">$fullname
[1] "John Doe"
$temperature
[1] 98.1
$flu_status
[1] FALSE
$gender
[1] MALE
Levels: FEMALE MALE
$blood
[1] O
Levels: A B AB O
$symptoms
[1] SEVERE
Levels: MILD &lt; MODERATE &lt; SEVERE
</code></pre>
    <p class="normal">Note that<a id="_idIndexMarker154"/> the values are labeled with the names we specified in the preceding command. As a list retains order like a vector, its components can be accessed using numeric positions, as shown here for the <code class="inlineCode">temperature</code> value:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject1[<span class="hljs-number">2</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">$temperature
[1] 98.1
</code></pre>
    <p class="normal">The result of using vector-style operators on a list object is another list object, which is a subset of the original list. For example, the preceding code returned a list with a single <code class="inlineCode">temperature</code> component. To instead return a single list item in its <em class="italic">native</em> data type, use double brackets (<code class="inlineCode">[[</code> and <code class="inlineCode">]]</code>) when selecting the list component. For example, the following command returns a numeric vector of length 1:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject1[[<span class="hljs-number">2</span>]]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 98.1
</code></pre>
    <p class="normal">For<a id="_idIndexMarker155"/> clarity, it <a id="_idIndexMarker156"/>is often better to access list components by name, by appending a <code class="inlineCode">$</code> and the component name to the list name as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject1$temperature
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 98.1
</code></pre>
    <p class="normal">Like the double-bracket notation, this returns the list component in its native data type (in this case, a numeric vector of length 1).</p>
    <div class="packt_tip">
      <p class="normal">Accessing the value by name also ensures that the correct item is retrieved even if the order of the list elements is changed later.</p>
    </div>
    <p class="normal">It is possible to obtain several list items by specifying a vector of names. The following returns a subset of the <code class="inlineCode">subject1</code> list, which contains only the <code class="inlineCode">temperature</code> and <code class="inlineCode">flu_status</code> components:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; subject1[<span class="hljs-built_in">c</span>(<span class="hljs-string">"temperature"</span>, <span class="hljs-string">"flu_status"</span>)]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">$temperature
[1] 98.1
$flu_status
[1] FALSE
</code></pre>
    <p class="normal">Entire datasets could be constructed using lists, and lists of lists. For example, you might consider creating a <code class="inlineCode">subject2</code> and <code class="inlineCode">subject3</code> list and grouping these into a list object named <code class="inlineCode">pt_data</code>. However, constructing a dataset in this way is common enough that R provides a specialized data structure specifically for this task.</p>
    <h2 class="heading-2" id="_idParaDest-41">Data frames</h2>
    <p class="normal">By far<a id="_idIndexMarker157"/> the most important R data structure for machine learning is the <strong class="keyWord">data frame</strong>, a <a id="_idIndexMarker158"/>structure analogous to a spreadsheet or database in that it has both rows and columns of data. In R terms, a data frame can be understood as a list of vectors or factors, each having exactly the same number of values. Because the data frame is literally a list of vector-type objects, it combines aspects of both vectors and lists.</p>
    <p class="normal">Let’s create a <a id="_idIndexMarker159"/>data frame for our patient dataset. Using the patient data vectors we created previously, the <code class="inlineCode">data.frame()</code> function combines them into a data frame:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data &lt;- data.frame(subject_name, temperature, 
                        flu_status, gender, blood, symptoms)
</code></pre>
    <p class="normal">When<a id="_idIndexMarker160"/> displaying the <code class="inlineCode">pt_data</code> data frame, we see that the structure is quite different from the data structures we’ve worked with previously:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">  subject_name temperature flu_status gender blood symptoms
1     John Doe        98.1      FALSE   MALE     O   SEVERE
2     Jane Doe        98.6      FALSE FEMALE    AB     MILD
3 Steve Graves       101.4       TRUE   MALE     A MODERATE
</code></pre>
    <p class="normal">Compared to one-dimensional vectors, factors, and lists, a data frame has two dimensions and is displayed in a tabular format. Our data frame has one row for each patient and one column for each vector of patient measurements. In machine learning terms, the data frame’s rows are the examples, and the columns are the features or attributes.</p>
    <p class="normal">To extract entire columns (vectors) of data, we can take advantage of the fact that a data frame is simply a list of vectors. Like lists, the most direct way to extract a single element is by referring to it by name. For example, to obtain the <code class="inlineCode">subject_name</code> vector, type:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data$subject_name
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] "John Doe"     "Jane Doe"     "Steve Graves"
</code></pre>
    <p class="normal">Like lists, a vector of names can be used to extract multiple columns from a data frame:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[<span class="hljs-built_in">c</span>(<span class="hljs-string">"temperature"</span>, <span class="hljs-string">"flu_status"</span>)]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">  temperature flu_status
1        98.1      FALSE
2        98.6      FALSE
3       101.4       TRUE
</code></pre>
    <p class="normal">When we request data frame columns by name, the result is a data frame containing all rows of data for the specified columns. The command <code class="inlineCode">pt_data[2:3]</code> will also extract the <code class="inlineCode">temperature</code> and <code class="inlineCode">flu_status</code> columns. However, referring to the columns by name results in clear and easy-to-maintain R code, which will not break if the data frame is later reordered.</p>
    <p class="normal">To <a id="_idIndexMarker161"/>extract specific values from the data frame, methods like those <a id="_idIndexMarker162"/>for accessing values in vectors are used. However, there is an important distinction—because the data frame is two-dimensional, both the desired rows and columns must be specified. Rows are specified first, followed by a comma, followed by the columns in a format like this: <code class="inlineCode">[rows, columns]</code>. As with vectors, rows and columns are counted beginning at one.</p>
    <p class="normal">For instance, to extract the value in the first row and second column of the patient data frame, use the following command:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 98.1
</code></pre>
    <p class="normal">If you would like more than a single row or column of data, specify vectors indicating the desired rows and columns. The following statement will pull data from the first and third rows and the second and fourth columns:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[<span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), <span class="hljs-built_in">c</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">  temperature gender
1        98.1   MALE
3       101.4   MALE
</code></pre>
    <p class="normal">To refer to every row or every column, simply leave the row or column portion blank. For example, to extract all rows of the first column:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[, <span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] "John Doe"     "Jane Doe"     "Steve Graves"
</code></pre>
    <p class="normal">To extract all columns for the first row:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[<span class="hljs-number">1</span>, ]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">  subject_name temperature flu_status gender blood symptoms
1     John Doe        98.1      FALSE   MALE     O   SEVERE
</code></pre>
    <p class="normal">And to extract everything:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[ , ]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">  subject_name temperature flu_status gender blood symptoms
1     John Doe        98.1      FALSE   MALE     O   SEVERE
2     Jane Doe        98.6      FALSE FEMALE    AB     MILD
3 Steve Graves       101.4       TRUE   MALE     A MODERATE
</code></pre>
    <p class="normal">Of course, columns are better accessed by name rather than position, and negative signs can<a id="_idIndexMarker163"/> be used to exclude rows or columns of data. Therefore, the <a id="_idIndexMarker164"/>output of the command:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[<span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), <span class="hljs-built_in">c</span>(<span class="hljs-string">"temperature"</span>, <span class="hljs-string">"gender"</span>)]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">  temperature gender
1        98.1   MALE
3       101.4   MALE
</code></pre>
    <p class="normal">is equivalent to:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[<span class="hljs-number">-2</span>, <span class="hljs-built_in">c</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">-6</span>)]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">  temperature gender
1        98.1   MALE
3       101.4   MALE
</code></pre>
    <p class="normal">We often need to create new columns in data frames—perhaps, for instance, as a function of existing columns. For example, we may need to convert the Fahrenheit temperature readings in the patient data frame into the Celsius scale. To do this, we simply use the assignment operator to assign the result of the conversion calculation to a new column name as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data$temp_c &lt;- (pt_data$temperature - 32) * (<span class="hljs-number">5</span> / <span class="hljs-number">9</span>)
</code></pre>
    <p class="normal">To confirm the calculation worked, let’s compare the new Celsius-based <code class="inlineCode">temp_c</code> column to the previous Fahrenheit-scale <code class="inlineCode">temperature</code> column:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data[<span class="hljs-built_in">c</span>(<span class="hljs-string">"temperature"</span>, <span class="hljs-string">"temp_c"</span>)]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">  temperature   temp_c
1        98.1 36.72222
2        98.6 37.00000
3       101.4 38.55556
</code></pre>
    <p class="normal">Seeing these side by side, we can confirm that the calculation has worked correctly.</p>
    <p class="normal">As these types of operations are crucial for much of the work we will do in upcoming chapters, it is important to become very familiar with data frames. You might try practicing similar operations with the patient dataset, or even better, use data from one of your own projects—the functions to load your own data files into R will be described later in this chapter.</p>
    <h2 class="heading-2" id="_idParaDest-42">Matrices and arrays</h2>
    <p class="normal">In addition<a id="_idIndexMarker165"/> to data frames, R provides other structures that store values in tabular form. A <strong class="keyWord">matrix</strong> is <a id="_idIndexMarker166"/>a data structure that represents a two-dimensional table with rows and columns of data. Like vectors, R matrices can contain only one type of data, although they are most often used for mathematical operations and therefore typically store only numbers.</p>
    <p class="normal">To create a<a id="_idIndexMarker167"/> matrix, simply supply a vector of data to the <code class="inlineCode">matrix()</code> function, along with a parameter specifying the number of rows (<code class="inlineCode">nrow</code>) or number of columns (<code class="inlineCode">ncol</code>). For example, to create a 2x2 matrix storing the numbers one to four, we can use the <code class="inlineCode">nrow</code> parameter to request the data be divided into two rows:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; m &lt;- matrix(<span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), nrow = <span class="hljs-number">2</span>)
&gt; m
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">     [,1] [,2]
[1,]    1    3
[2,]    2    4
</code></pre>
    <p class="normal">This is equivalent to the matrix produced using <code class="inlineCode">ncol = 2</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; m &lt;- matrix(<span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), ncol = <span class="hljs-number">2</span>)
&gt; m
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">     [,1] [,2]
[1,]    1    3
[2,]    2    4
</code></pre>
    <p class="normal">You will notice that R loaded the first column of the matrix first before loading the second column. This is <a id="_idIndexMarker168"/>called <strong class="keyWord">column-major order</strong>, which is R’s default method for loading matrices.</p>
    <div class="packt_tip">
      <p class="normal">To override this default setting and load a matrix by rows, set the parameter <code class="inlineCode">byrow = TRUE</code> when creating the matrix.</p>
    </div>
    <p class="normal">To illustrate this further, let’s see what happens if we add more values to the matrix. With six values, requesting two rows creates a matrix with three columns:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; m &lt;- matrix(<span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>), nrow = <span class="hljs-number">2</span>)
&gt; m
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
</code></pre>
    <p class="normal">Requesting two columns creates a matrix with three rows:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; m &lt;- matrix(<span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>), ncol = <span class="hljs-number">2</span>)
&gt; m
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
</code></pre>
    <p class="normal">As with<a id="_idIndexMarker169"/> data frames, values in matrices can be extracted using <code class="inlineCode">[row, column]</code> notation. For instance, <code class="inlineCode">m[1, 1]</code> will return the value <code class="inlineCode">1</code> while <code class="inlineCode">m[3, 2]</code> will extract <code class="inlineCode">6</code> from the <code class="inlineCode">m</code> matrix. Additionally, entire rows or columns can be requested:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; m[1, ]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 1 4
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; m[, <span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 1 2 3
</code></pre>
    <p class="normal">Closely related <a id="_idIndexMarker170"/>to the matrix structure is <a id="_idIndexMarker171"/>the <strong class="keyWord">array</strong>, which is a multidimensional table of data. Where a matrix has rows and columns of values, an array has rows, columns, and one or more additional layers of values. Although we will occasionally use matrices in later chapters, the use of arrays is unnecessary within the scope of this book.</p>
    <h1 class="heading-1" id="_idParaDest-43">Managing data with R</h1>
    <p class="normal">One of the<a id="_idIndexMarker172"/> challenges faced while working with massive datasets involves <a id="_idIndexMarker173"/>gathering, preparing, and otherwise managing data from a variety of sources. Although we will cover data preparation, data cleaning, and data management in depth by working on real-world machine learning tasks in later chapters, this section highlights the basic functionality for getting data in and out of R.</p>
    <h2 class="heading-2" id="_idParaDest-44">Saving, loading, and removing R data structures</h2>
    <p class="normal">When you’ve <a id="_idIndexMarker174"/>spent a lot of time getting a data frame into the desired form, you shouldn’t need to recreate your work each time you restart your R session. </p>
    <p class="normal">To save data structures to a file that can be reloaded later or transferred to another system, the <code class="inlineCode">save()</code> function can be used to write one or more R data structures to the location specified by the <code class="inlineCode">file</code> parameter. R data files have an <code class="inlineCode">.RData</code> or <code class="inlineCode">.rda</code> extension.</p>
    <p class="normal">Suppose you had three objects named <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> that you would like to save to a permanent file. These might be vectors, factors, lists, data frames, or any other R object. To save them to a file named <code class="inlineCode">mydata.RData</code>, use the following command:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; save(x, y, z, file = <span class="hljs-string">"mydata.RData"</span>)
</code></pre>
    <p class="normal">The <code class="inlineCode">load()</code> command can recreate any data structures that have been saved to an <code class="inlineCode">.RData</code> file. To load the <code class="inlineCode">mydata.RData</code> file created in the preceding code, simply type:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; load(<span class="hljs-string">"mydata.RData"</span>)
</code></pre>
    <p class="normal">This will recreate the <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> data structures in your R environment.</p>
    <div class="packt_tip">
      <p class="normal">Be careful what you are loading! All data structures stored in the file you are importing with the <code class="inlineCode">load()</code> command will be added to your workspace, even if they overwrite something else you are working on.</p>
    </div>
    <p class="normal">Alternatively, the <code class="inlineCode">saveRDS()</code> function can be used to save a single R object to a file. Although it is much like the <code class="inlineCode">save()</code> function, a key distinction is that the corresponding <code class="inlineCode">loadRDS()</code> function allows the object to be loaded with a different name to the original object. For this reason, <code class="inlineCode">saveRDS()</code> may be safer to use when transferring R objects across projects, because it reduces the risk of accidentally overwriting existing objects in the R environment.</p>
    <p class="normal">The <code class="inlineCode">saveRDS()</code> function is especially helpful for saving machine learning model objects. Because some machine learning algorithms take a long time to train the model, saving the model to an <code class="inlineCode">.rds</code> file can help avoid a long re-training process when a project is resumed. For example, to save a model object named <code class="inlineCode">my_model</code> to a file named <code class="inlineCode">my_model.rds</code>, use the following syntax:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; saveRDS(my_model, file = <span class="hljs-string">"my_model.rds"</span>)
</code></pre>
    <p class="normal">To load <a id="_idIndexMarker175"/>the model, use the <code class="inlineCode">readRDS()</code> function and assign the result an object name as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; my_model &lt;- readRDS(<span class="hljs-string">"my_model.rds"</span>)
</code></pre>
    <p class="normal">After you’ve been working in an R session for some time, you may have accumulated unused data structures. In RStudio, these objects are visible in the <strong class="screenText">Environment</strong> tab of the interface, but it is also possible to access these objects programmatically using the listing function <code class="inlineCode">ls()</code>, which returns a vector of all data structures currently in memory. </p>
    <p class="normal">For example, if you’ve been following along with the code in this chapter, the <code class="inlineCode">ls()</code> function returns the following:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; ls()
</code></pre>
    <pre class="programlisting con"><code class="hljs-con"> [1] "blood"        "fever"        "flu_status"   "gender"      
 [5] "m"            "pt_data"      "subject_name" "subject1"    
 [9] "symptoms"     "temperature"
</code></pre>
    <p class="normal">R automatically clears<a id="_idIndexMarker176"/> all data structures from memory upon quitting the session, but for large objects, you may want to free up the memory sooner. The remove function <code class="inlineCode">rm()</code> can be used for this purpose. For example, to eliminate the <code class="inlineCode">m</code> and <code class="inlineCode">subject1</code> objects, simply type:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; rm(m, subject1)
</code></pre>
    <p class="normal">The <code class="inlineCode">rm()</code> function can also be supplied with a character vector of object names to remove. This works with the <code class="inlineCode">ls()</code> function to clear the entire R session:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; rm(<span class="hljs-built_in">list</span> = ls())
</code></pre>
    <div class="packt_tip">
      <p class="normal">Be very careful when executing the preceding code, as you will not be prompted before your objects are removed!</p>
    </div>
    <p class="normal">If you need to wrap up your R session in a hurry, the <code class="inlineCode">save.image()</code> command will write your entire session to a file simply called <code class="inlineCode">.RData</code>. By default, when quitting R or RStudio, you will be asked if you would like to create this file. R will look for this file the next time you start R, and if it exists, your session will be recreated just as you had left it.</p>
    <h2 class="heading-2" id="_idParaDest-45">Importing and saving datasets from CSV files</h2>
    <p class="normal">It is<a id="_idIndexMarker177"/> common for public datasets to be stored in text files. Text files can be read on virtually any computer or operating system, which <a id="_idIndexMarker178"/>makes the format nearly universal. They can also be exported and imported from and to programs such as Microsoft Excel, providing a quick and easy way to work with spreadsheet data.</p>
    <p class="normal">A <strong class="keyWord">tabular</strong> (as in “table”) data file<a id="_idIndexMarker179"/> is structured in matrix form, such that each line of text reflects one example, and each example has the same number of features. The feature values on each line are separated by a predefined symbol known <a id="_idIndexMarker180"/>as a <strong class="keyWord">delimiter</strong>. Often, the first line of a tabular data file lists the names of the data columns. This is <a id="_idIndexMarker181"/>called a <strong class="keyWord">header</strong> line.</p>
    <p class="normal">Perhaps the most <a id="_idIndexMarker182"/>common tabular text file format is the <strong class="keyWord">comma-separated values</strong> (<strong class="keyWord">CSV</strong>) file, which, as the name suggests, uses the comma as a delimiter. CSV files can be imported to and exported from many common applications. A CSV file representing the medical dataset constructed previously could be stored as:</p>
    <pre class="programlisting con"><code class="hljs-con">subject_name,temperature,flu_status,gender,blood_type
John Doe,98.1,FALSE,MALE,O
Jane Doe,98.6,FALSE,FEMALE,AB
Steve Graves,101.4,TRUE,MALE,A
</code></pre>
    <p class="normal">Given a patient data file named <code class="inlineCode">pt_data.csv</code> located in the R working directory, the <code class="inlineCode">read.csv()</code> function can be used as follows to load the file into R:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data &lt;- read.csv(<span class="hljs-string">"pt_data.csv"</span>)
</code></pre>
    <p class="normal">This will read the CSV file into a data frame titled <code class="inlineCode">pt_data</code>. If your dataset resides outside the R working directory, the full path to the CSV file (for example, <code class="inlineCode">"/path/to/mydata.csv"</code>) can be used when calling the <code class="inlineCode">read.csv()</code> function.</p>
    <p class="normal">By default, R assumes that the CSV file includes a header line listing the names of the features in the dataset. If a CSV file does not have a header, specify the option <code class="inlineCode">header = FALSE</code> as shown in the following command, and R will assign generic feature names by numbering the columns sequentially as <code class="inlineCode">V1</code>, <code class="inlineCode">V2</code>, and so on:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data &lt;- read.csv(<span class="hljs-string">"pt_data.csv"</span>, header = <span class="hljs-literal">FALSE</span>)
</code></pre>
    <p class="normal">As an important historical note, in versions of R prior to 4.0, the <code class="inlineCode">read.csv()</code> function automatically converted all character type columns into factors due to a <code class="inlineCode">stringsAsFactors</code> parameter that was set to <code class="inlineCode">TRUE</code> by default. This feature was occasionally helpful, especially on the smaller and simpler datasets used in the earlier years of R. However, as datasets have become larger and more complex, this feature began to cause more problems than it solved. Now, starting with version 4.0, R sets <code class="inlineCode">stringsAsFactors = FALSE</code> by default. If you are certain that every character column in a CSV file is truly a factor, it is possible to convert them using the following syntax:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pt_data &lt;- read.csv(<span class="hljs-string">"pt_data.csv"</span>, stringsAsFactors = <span class="hljs-literal">TRUE</span>)
</code></pre>
    <p class="normal">We will <a id="_idIndexMarker183"/>set <code class="inlineCode">stringsAsFactors = TRUE</code> occasionally throughout the book, when working with datasets in which all character columns are truly factors.</p>
    <p class="normal">Getting<a id="_idIndexMarker184"/> results data out of R can be almost as important as getting it in! To save a data frame to a CSV file, use the <code class="inlineCode">write.csv()</code> function. For a data frame named <code class="inlineCode">pt_data</code>, simply enter:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; write.csv(pt_data, file = <span class="hljs-string">"pt_data.csv"</span>, row.names = <span class="hljs-literal">FALSE</span>)
</code></pre>
    <p class="normal">This will write a CSV file with the name <code class="inlineCode">pt_data.csv</code> to the R working folder. The <code class="inlineCode">row.names</code> parameter overrides R’s default setting, which is to output row names in the CSV file. Generally, this output is unnecessary and will simply inflate the size of the resulting file.</p>
    <div class="packt_tip">
      <p class="normal">For more sophisticated control over reading in files, note that <code class="inlineCode">read.csv()</code> is a special case of the <code class="inlineCode">read.table()</code> function, which can read tabular data in many different forms. This includes other delimited formats such as <strong class="keyWord">tab-separated values</strong> (<strong class="keyWord">TSV</strong>) and <a id="_idIndexMarker185"/>vertical bar (<code class="inlineCode">|</code>) delimited files. For more detailed information on the <code class="inlineCode">read.table()</code> family of functions, refer to the R help page using the <code class="inlineCode">?read.table</code> command.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-46">Importing common dataset formats using RStudio</h2>
    <p class="normal">For more <a id="_idIndexMarker186"/>complex importation scenarios, the <a id="_idIndexMarker187"/>RStudio Desktop software offers a simple interface, which will guide you through the process of writing R code that can be used to load the data into your project. Although it has always been relatively easy to load plaintext data formats like CSV, importing other common analytical data formats like Microsoft Excel (<code class="inlineCode">.xls</code> and <code class="inlineCode">.xlsx</code>), SAS (<code class="inlineCode">.sas7bdat</code> and <code class="inlineCode">.xpt</code>), SPSS (<code class="inlineCode">.sav</code> and <code class="inlineCode">.por</code>), and Stata (<code class="inlineCode">.dta</code>) was once a tedious and time-consuming process, requiring knowledge of specific tricks and tools across multiple <a id="_idIndexMarker188"/>R packages. Now, the functionality <a id="_idIndexMarker189"/>is available via the <strong class="screenText">Import Dataset</strong> command near the upper right of the RStudio interface, as shown in <em class="italic">Figure 2.1</em>:</p>
    <p class="normal"><img alt="Graphical user interface, application  Description automatically generated" src="../Images/B17290_02_01.png"/></p>
    <p class="packt_figref">Figure 2.1: RStudio’s “Import Dataset” feature provides options to load data from a variety of common formats</p>
    <p class="normal">Depending on the data format selected, you may be prompted to install R packages that are required for the functionality in question. Behind the scenes, these packages will translate the data format so that it can be used in R. You will then be presented with a dialog box allowing you to choose the options for the data import process and see a live preview of how the data will appear in R as these changes are made. </p>
    <p class="normal">The following screenshot illustrates the process of importing a Microsoft Excel version of the used cars dataset using the <code class="inlineCode">readxl</code> package (<a href="https://readxl.tidyverse.org"><span class="url">https://readxl.tidyverse.org</span></a>), but the process is similar for any of the dataset formats:</p>
    <p class="normal"><img alt="Graphical user interface, application  Description automatically generated" src="../Images/B17290_02_02.png"/></p>
    <p class="packt_figref">Figure 2.2: The data import dialog provides a “Code Preview” that can be copy-and-pasted into your R code file</p>
    <p class="normal">The <strong class="screenText">Code Preview</strong> in <a id="_idIndexMarker190"/>the bottom-right <a id="_idIndexMarker191"/>of this dialog provides the R code to perform the importation with the specified options. Selecting the <strong class="screenText">Import</strong> button will immediately execute the code; however, a better practice is to copy and paste the code into your R source code file, so that you can re-import the dataset in future sessions. </p>
    <div class="packt_tip">
      <p class="normal">The <code class="inlineCode">read_excel()</code> function RStudio uses to load Excel data creates an R object called a “tibble” rather than a data frame. The differences are so subtle that you may not even notice! However, tibbles are an important R innovation enabling new ways to work with data frames. The tibble and its functionality are discussed in <em class="chapterRef">Chapter 12</em>, <em class="italic">Advanced Data Preparation</em>.</p>
    </div>
    <p class="normal">The RStudio interface has made it easier than ever to work with data in a variety of formats, but more advanced functionality exists for working with large datasets. In particular, if you have data residing in database platforms like Microsoft SQL, MySQL, PostgreSQL, and others, it is possible to connect R to such databases to pull the data into R, or even utilize the database hardware itself to perform big data computations prior to bringing the results into R. <em class="chapterRef">Chapter 15</em>, <em class="italic">Making Use of Big Data</em>, introduces these techniques and provides instructions for connecting to common databases using RStudio.</p>
    <h1 class="heading-1" id="_idParaDest-47">Exploring and understanding data</h1>
    <p class="normal">After<a id="_idIndexMarker192"/> collecting data and loading it into R data structures, the next step in the machine learning process involves examining the data in detail. It is during this step that you will begin to explore the data’s features and examples and realize the peculiarities that make your data unique. The better you understand your data, the better you will be able to match a machine learning model to your learning problem.</p>
    <p class="normal">The best way to learn the process of data exploration is by example. In this section, we will explore the <code class="inlineCode">usedcars.csv</code> dataset, which contains actual data about used cars advertised for sale on a popular US website in the year 2012.</p>
    <div class="packt_tip">
      <p class="normal">The <code class="inlineCode">usedcars.csv</code> dataset is available for download on the Packt Publishing support page for this book. If you are following along with the examples, be sure that this file has been downloaded and saved to your R working directory.</p>
    </div>
    <p class="normal">Since the dataset is stored in CSV form, we can use the <code class="inlineCode">read.csv()</code> function to load the data into an R data frame:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; usedcars &lt;- read.csv(<span class="hljs-string">"usedcars.csv"</span>)
</code></pre>
    <p class="normal">Using the <code class="inlineCode">usedcars</code> data frame, we will now assume the role of a data scientist who has the task of understanding the used car data. Although data exploration is a fluid process, the steps can be imagined as a sort of investigation in which questions about the data are answered. The exact questions may vary across projects, but the types of questions are always similar. </p>
    <p class="normal">You should be able to adapt the basic steps of this investigation to any dataset you like, whether large or small.</p>
    <figure class="mediaobject"><img alt="A picture containing text, toy, vector graphics, automaton  Description automatically generated" src="../Images/B17290_02_03.png"/></figure>
    <p class="packt_figref">Figure 2.3: “Do pricing algorithms get a test drive?” (image created by Midjourney AI with the prompt of “cute cartoon robot buying a used car”)</p>
    <h2 class="heading-2" id="_idParaDest-48">Exploring the structure of data</h2>
    <p class="normal">The first <a id="_idIndexMarker193"/>questions to ask in an investigation of a new dataset should be about how the dataset is organized. If you are fortunate, your source will provide a <strong class="keyWord">data dictionary</strong>, a <a id="_idIndexMarker194"/>document that describes the dataset’s features. In our case, the used car data does not come with this documentation, so we’ll need to create our own.</p>
    <p class="normal">The <code class="inlineCode">str()</code> function provides a method for displaying the structure of R objects, such as data frames, vectors, or lists. It can be used to create the basic outline for our data dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; str(usedcars)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">'data.frame':	150 obs. of  6 variables:
 $ year        : int  2011 2011 2011 2011 ...
 $ model       : chr  "SEL" "SEL" "SEL" "SEL" ...
 $ price       : int  21992 20995 19995 17809 ...
 $ mileage     : int  7413 10926 7351 11613 ...
 $ color       : chr  "Yellow" "Gray" "Silver" "Gray" ...
 $ transmission: chr  "AUTO" "AUTO" "AUTO" "AUTO" ...
</code></pre>
    <p class="normal">For such a simple command, we learn a wealth of information about the dataset. The statement <code class="inlineCode">150 obs</code> informs us that the data includes 150 <strong class="keyWord">observations</strong>, which is just another way of saying that the dataset contains 150 rows or examples. The number of observations is often simply abbreviated as <em class="italic">n</em>. </p>
    <p class="normal">Since we know that the data describes used cars, we can now presume that we have examples of n = 150 automobiles for sale.</p>
    <p class="normal">The <code class="inlineCode">6 variables</code> statement refers to the six features that were recorded in the data. The<a id="_idIndexMarker195"/> term <strong class="keyWord">variable</strong> is borrowed from the field of statistics, and simply means a mathematical object that <a id="_idIndexMarker196"/>can take various values—like the <em class="italic">x</em> and <em class="italic">y</em> variables you might solve for in an algebraic equation. These features, or variables, are listed by name on separate lines. Looking at the line for the feature called <code class="inlineCode">color</code>, we note some additional details:</p>
    <pre class="programlisting con"><code class="hljs-con">$ color       : chr  "Yellow" "Gray" "Silver" "Gray" ...
</code></pre>
    <p class="normal">After the variable’s name, the <code class="inlineCode">chr</code> label tells us that the feature is the character type. In this dataset, three of the variables are character while three are noted as <code class="inlineCode">int</code>, which refers to the integer type. Although the <code class="inlineCode">usedcars</code> dataset includes only character and integer features, you are also likely to encounter <code class="inlineCode">num</code>, or numeric type, when using non-integer data. Any factors would be listed as the <code class="inlineCode">factor</code> type. Following each variable’s type, R presents a sequence of the first few feature values. The values <code class="inlineCode">"Yellow" "Gray" "Silver" "Gray"</code> are the first four values of the <code class="inlineCode">color</code> feature.</p>
    <p class="normal">Applying a bit of subject-area knowledge to the feature names and values allows us to make some assumptions about what the features represent. <code class="inlineCode">year</code> could refer to the year the vehicle was manufactured, or it could specify the year the advertisement was posted. We’ll have to investigate this feature later in more detail, since the four example values (<code class="inlineCode">2011 2011 2011 2011</code>) could be used to argue for either possibility. The <code class="inlineCode">model</code>, <code class="inlineCode">price</code>, <code class="inlineCode">mileage</code>, <code class="inlineCode">color</code>, and <code class="inlineCode">transmission</code> most likely refer to the characteristics of the car for sale.</p>
    <p class="normal">Although our data appears to have been given meaningful names, this is not always the case. Sometimes datasets have features with nonsensical names or codes, like <code class="inlineCode">V1</code>. In these cases, it may be necessary to do additional sleuthing to determine what a feature represents. Still, even with helpful feature names, it is always prudent to be skeptical about the provided labels. Let’s investigate further.</p>
    <h2 class="heading-2" id="_idParaDest-49">Exploring numeric features</h2>
    <p class="normal">To investigate <a id="_idIndexMarker197"/>the numeric features in the used car data, we will<a id="_idIndexMarker198"/> employ a common set of measurements for describing<a id="_idIndexMarker199"/> values known as <strong class="keyWord">summary statistics</strong>. The <code class="inlineCode">summary()</code> function displays several common summary statistics. Let’s look at a single feature, <code class="inlineCode">year</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; summary(usedcars$year)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">   Min. 1st Qu.  Median    Mean  3rd Qu.   Max.
   2000    2008    2009    2009    2010    2012
</code></pre>
    <p class="normal">Ignoring the <a id="_idIndexMarker200"/>meaning of the values for now, the fact that we see numbers such as <code class="inlineCode">2000</code>, <code class="inlineCode">2008</code>, and <code class="inlineCode">2009</code> leads us to believe that <code class="inlineCode">year</code> indicates the year of manufacture rather than the<a id="_idIndexMarker201"/> year the advertisement was posted, since we know the vehicle listings were obtained in 2012.</p>
    <p class="normal">By supplying a vector of column names, we can also use the <code class="inlineCode">summary()</code> function to obtain summary statistics for several numeric columns at the same time:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; summary(usedcars[<span class="hljs-built_in">c</span>(<span class="hljs-string">"price"</span>, <span class="hljs-string">"mileage"</span>)])
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">     price          mileage      
 Min.   : 3800   Min.   :  4867  
 1st Qu.:10995   1st Qu.: 27200  
 Median :13592   Median : 36385  
 Mean   :12962   Mean   : 44261  
 3rd Qu.:14904   3rd Qu.: 55124  
 Max.   :21992   Max.   :151479  
</code></pre>
    <p class="normal">The six summary statistics provided by the <code class="inlineCode">summary()</code> function are simple, yet powerful tools for investigating data. They can be divided into two types: measures of center and measures of spread.</p>
    <h3 class="heading-3" id="_idParaDest-50">Measuring the central tendency – mean and median</h3>
    <p class="normal">Measures<a id="_idIndexMarker202"/> of <strong class="keyWord">central tendency</strong> are<a id="_idIndexMarker203"/> a class of statistics used to identify a value that falls in the middle of a set of data. You are most likely already familiar with one common measure of center: the average. In common use, when something is deemed average, it falls somewhere between the extreme ends of the scale. An average student might have marks falling in the middle of their classmates’. An average weight is neither unusually light nor heavy. In general, an average item is typical and not too unlike the others in its group. You might think of it as an exemplar by which all the others are judged.</p>
    <p class="normal">In statistics, the average is also <a id="_idIndexMarker204"/>known<a id="_idIndexMarker205"/> as the <strong class="keyWord">mean</strong>, which is a measurement defined as the sum of all values divided by the number of values. For example, to calculate the mean income in a group of three people with incomes of $36,000, $44,000, and $56,000, we could type:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; (<span class="hljs-number">36000</span> + <span class="hljs-number">44000</span> + <span class="hljs-number">56000</span>) / <span class="hljs-number">3</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 45333.33
</code></pre>
    <p class="normal">R also provides a <code class="inlineCode">mean()</code> function, which calculates the mean for a vector of numbers:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; mean(<span class="hljs-built_in">c</span>(<span class="hljs-number">36000</span>, <span class="hljs-number">44000</span>, <span class="hljs-number">56000</span>))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 45333.33
</code></pre>
    <p class="normal">The <a id="_idIndexMarker206"/>mean income of this group of people is about $45,333. Conceptually, this can be imagined as the income each person would have if the total income was divided equally across every person.</p>
    <p class="normal">Recall that the preceding <code class="inlineCode">summary()</code> output listed mean values for <code class="inlineCode">price</code> and <code class="inlineCode">mileage</code>. These values suggest that the typical used car in this dataset was listed at a price of $12,962 and had an odometer reading of 44,261. What does this tell us about our data? We can note that because the average price is relatively low, we might expect that the dataset contains economy-class cars. Of course, the data could also include late-model luxury cars with high mileage, but the relatively low mean mileage statistic doesn’t provide evidence to support this hypothesis. On the other hand, it doesn’t provide evidence to ignore the possibility either. We’ll need to keep this in mind as we examine the data further.</p>
    <p class="normal">Although the mean is by far the most cited statistic for measuring the center of a dataset, it is not always the most appropriate one. Another <a id="_idIndexMarker207"/>commonly used measure of central tendency is<a id="_idIndexMarker208"/> the <strong class="keyWord">median</strong>, which is the value that occurs at the midpoint of an ordered list of values. As with the mean, R provides a <code class="inlineCode">median()</code> function, which we can apply to our salary data as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; median(<span class="hljs-built_in">c</span>(<span class="hljs-number">36000</span>, <span class="hljs-number">44000</span>, <span class="hljs-number">56000</span>))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 44000
</code></pre>
    <p class="normal">So, because the middle value is <code class="inlineCode">44000</code>, the median income is $44,000.</p>
    <div class="note">
      <p class="normal">If a dataset has an even number of values, there is no middle value. In this case, the median is commonly calculated as the average of the two values at the center of the ordered list. For example, the median of the values 1, 2, 3, and 4 is 2.5.</p>
    </div>
    <p class="normal">At first glance, it <a id="_idIndexMarker209"/>seems like the median and mean are very similar measures. Certainly, the mean value of $45,333 and the median value of $44,000 are not very far apart. Why have two measures of central tendency? The reason relates to the fact that the mean and median are affected differently by values falling at the far ends of the range. In particular, the<a id="_idIndexMarker210"/> mean is highly<a id="_idIndexMarker211"/> sensitive to <strong class="keyWord">outliers</strong>, or values that are atypically high or low relative to the majority of data. A more nuanced take on outliers will be presented in <em class="chapterRef">Chapter 11</em>, <em class="italic">Being Successful with Machine Learning</em>, but for now, we can consider them extreme values that tend to shift the mean higher or lower relative to the median, because the median is largely insensitive to the outlying values.</p>
    <p class="normal">Recall again the reported median values in the <code class="inlineCode">summary()</code> output for the used car dataset. Although the mean and median for price are similar (differing by approximately five percent), there is a much larger difference between the mean and median for mileage. For mileage, the mean of 44,261 is more than 20 percent larger than the median of 36,385. Since the mean is more sensitive to extreme values than the median, the fact that the mean is much higher than the median might lead us to suspect that there are some used cars with extremely high mileage values relative to the others in the dataset. To investigate this further, we’ll need to add additional summary statistics to our analysis.</p>
    <h3 class="heading-3" id="_idParaDest-51">Measuring spread – quartiles and the five-number summary</h3>
    <p class="normal">The mean <a id="_idIndexMarker212"/>and median provide ways to quickly summarize<a id="_idIndexMarker213"/> values, but these measures of center tell us little about whether there is diversity in the measurements. To measure the diversity, we need to employ another type of summary statistics concerned with the <strong class="keyWord">spread</strong> of the data, or how tightly or loosely the values are spaced. Knowing about the spread provides a sense of the data’s highs and lows, and whether most values are like or unlike the mean and median.</p>
    <p class="normal">The <strong class="keyWord">five-number summary</strong> is a<a id="_idIndexMarker214"/> set of five statistics<a id="_idIndexMarker215"/> that roughly depict the spread of a feature’s values. All five statistics are included in the <code class="inlineCode">summary()</code> function output. Written in order, they are:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Minimum (<code class="inlineCode">Min.</code>)</li>
      <li class="numberedList">First quartile, or Q1 (<code class="inlineCode">1st Qu.</code>)</li>
      <li class="numberedList">Median, or Q2 (<code class="inlineCode">Median</code>)</li>
      <li class="numberedList">Third quartile, or Q3 (<code class="inlineCode">3rd Qu.</code>)</li>
      <li class="numberedList">Maximum (<code class="inlineCode">Max.</code>)</li>
    </ol>
    <p class="normal">As you would expect, the minimum and maximum are the most extreme feature values, indicating the smallest and largest values respectively. R provides the <code class="inlineCode">min()</code> and <code class="inlineCode">max()</code> functions to calculate these for a vector.</p>
    <p class="normal">The span <a id="_idIndexMarker216"/>between the minimum and maximum value is known as the range. In R, the <code class="inlineCode">range()</code> function returns both the minimum and maximum value:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; <span class="hljs-built_in">range</span>(usedcars$price)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1]  3800 21992
</code></pre>
    <p class="normal">Combining <code class="inlineCode">range()</code> with the difference function <code class="inlineCode">diff()</code> allows you to compute the range statistic with a single line of code:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; diff(<span class="hljs-built_in">range</span>(usedcars$price))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 18192
</code></pre>
    <p class="normal">One quarter of the dataset’s values fall below the first quartile (Q1), and another quarter is above the third quartile (Q3). Along with the median, which is the midpoint of the data values, the quartiles divide a dataset into four portions, each containing 25 percent of the values.</p>
    <p class="normal">Quartiles <a id="_idIndexMarker217"/>are <a id="_idIndexMarker218"/>a special case of a type of statistic called <strong class="keyWord">quantiles</strong>, which<a id="_idIndexMarker219"/> are numbers that divide data into equally sized quantities. In<a id="_idIndexMarker220"/> addition to quartiles, commonly used quantiles include <strong class="keyWord">tertiles</strong> (three parts), <strong class="keyWord">quintiles</strong> (five parts), <strong class="keyWord">deciles</strong> (10 parts), and <strong class="keyWord">percentiles</strong> (100 parts). Percentiles are<a id="_idIndexMarker221"/> often used to describe the ranking of a value; for <a id="_idIndexMarker222"/>instance, a student whose test score was ranked at the 99th percentile performed better than or equal to 99 percent of the other test takers.</p>
    <p class="normal">The middle 50 percent of data, found between the first and third quartiles, is of particular interest because it is a simple measure of spread. The difference between Q1 and Q3 is known as the <strong class="keyWord">interquartile range</strong> (<strong class="keyWord">IQR</strong>), and<a id="_idIndexMarker223"/> can be calculated with the <code class="inlineCode">IQR()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; IQR(usedcars$price)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 3909.5
</code></pre>
    <p class="normal">We could have also <a id="_idIndexMarker224"/>calculated this value by hand from the <code class="inlineCode">summary()</code> output for the <code class="inlineCode">usedcars$price</code> vector by computing <code class="inlineCode">14904 – 10995 = 3909</code>. The small difference between our calculation and the <code class="inlineCode">IQR()</code> output is due to the fact that R automatically rounds the <code class="inlineCode">summary()</code> output.</p>
    <p class="normal">The <code class="inlineCode">quantile()</code> function <a id="_idIndexMarker225"/>provides a versatile tool for identifying quantiles for a set of values. By default, <code class="inlineCode">quantile()</code> returns the five-number summary. Applying the function to the <code class="inlineCode">usedcars$price</code> vector results in the same summary statistics as before:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; quantile(usedcars$price)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">     0%     25%     50%     75%    100%
 3800.0 10995.0 13591.5 14904.5 21992.0
</code></pre>
    <div class="packt_tip">
      <p class="normal">When computing quantiles, there are many methods for handling ties among sets of values with no single middle value. The <code class="inlineCode">quantile()</code> function allows you to specify among nine different tie-breaking algorithms by specifying the <code class="inlineCode">type</code> parameter. If your project requires a precisely defined quantile, it is important to read the function documentation using the <code class="inlineCode">?quantile</code> command.</p>
    </div>
    <p class="normal">By supplying an additional <code class="inlineCode">probs</code> parameter for a vector denoting cut points, we can obtain arbitrary quantiles, such as the 1st and 99th percentiles:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; quantile(usedcars$price, probs = <span class="hljs-built_in">c</span>(<span class="hljs-number">0.01</span>, <span class="hljs-number">0.99</span>))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">      1%      99%
 5428.69 20505.00
</code></pre>
    <p class="normal">The sequence function <code class="inlineCode">seq()</code> generates vectors of evenly spaced values. This makes it easy to obtain other slices of data, such as the quintiles (five groups) shown in the following command:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; quantile(usedcars$price, seq(from = <span class="hljs-number">0</span>, to = <span class="hljs-number">1</span>, by = <span class="hljs-number">0.20</span>))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">     0%     20%     40%     60%     80%    100%
 3800.0 10759.4 12993.8 13992.0 14999.0 21992.0
</code></pre>
    <p class="normal">Equipped with an understanding of the five-number summary, we can re-examine the used car <code class="inlineCode">summary()</code> output. For <code class="inlineCode">price</code>, the minimum was $3,800 and the maximum was $21,992. Interestingly, the difference between the minimum and Q1 is about $7,000, as is the difference between Q3 and the maximum; yet, the difference from Q1 to the median to Q3 is <a id="_idIndexMarker226"/>roughly $2,000. This suggests that the lower and upper 25 percent of values are more widely dispersed than the middle 50 percent of values, which seem to be more tightly grouped around the center. We also see a similar trend with <code class="inlineCode">mileage</code>. As you will learn later in this chapter, this pattern of spread is common enough that it has been called a “normal” distribution of data.</p>
    <p class="normal">The spread of <code class="inlineCode">mileage</code> also <a id="_idIndexMarker227"/>exhibits another interesting property—the difference between Q3 and the maximum is far greater than that between the minimum and Q1. In other words, the larger values are far more spread out than the smaller values. This finding helps explain why the mean value is much greater than the median. Because the mean is sensitive to extreme values, it is pulled higher, while the median stays in relatively the same place. This is an important property, which becomes more apparent when the data is presented visually.</p>
    <h3 class="heading-3" id="_idParaDest-52">Visualizing numeric features – boxplots</h3>
    <p class="normal">Visualizing <a id="_idIndexMarker228"/>numeric features can help diagnose data problems that might negatively affect machine learning model performance. A common visualization of the five-number summary <a id="_idIndexMarker229"/>is a <strong class="keyWord">boxplot</strong>, also known as a <strong class="keyWord">box-and-whisker</strong> plot. The <a id="_idIndexMarker230"/>boxplot displays the center and spread of a numeric variable in a format that allows you to quickly obtain a sense of its range and skew or compare it to other features.</p>
    <p class="normal">Let’s look at a boxplot for the used car price and mileage data. To obtain a boxplot for a numeric vector, we will use the <code class="inlineCode">boxplot()</code> function. We will also specify a pair of extra parameters, <code class="inlineCode">main</code> and <code class="inlineCode">ylab</code>, to add a title to the figure and label the <em class="italic">y</em> axis (the vertical axis), respectively. The commands to create the <code class="inlineCode">price</code> and <code class="inlineCode">mileage</code> boxplots are:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; boxplot(usedcars$price, main = <span class="hljs-string">"Boxplot of Used Car Prices"</span>,
          ylab = <span class="hljs-string">"Price ($)"</span>)
&gt; boxplot(usedcars$mileage, main = <span class="hljs-string">"Boxplot of Used Car Mileage"</span>,
          ylab = <span class="hljs-string">"Odometer (mi.)"</span>)
</code></pre>
    <p class="normal">R will produce figures as follows:</p>
    <figure class="mediaobject"><img alt="Chart, box and whisker chart  Description automatically generated" src="../Images/B17290_02_04.png"/></figure>
    <p class="packt_figref">Figure 2.4: Boxplots of used car price and mileage data</p>
    <p class="normal">A <a id="_idIndexMarker231"/>boxplot <a id="_idIndexMarker232"/>depicts the five-number summary using horizontal lines and dots. The horizontal lines forming the box in the middle of each figure represent Q1, Q2 (the median), and Q3 when reading the plot from bottom to top. The median is denoted by the dark line, which lines up with $13,592 on the vertical axis for <code class="inlineCode">price</code> and 36,385 mi. on the vertical axis for <code class="inlineCode">mileage</code>.</p>
    <div class="packt_tip">
      <p class="normal">In simple boxplots, such as those in the preceding diagram, the box width is arbitrary and does not illustrate any characteristic of the data. For more sophisticated analyses, it is possible to use the shape and size of the boxes to facilitate comparisons of the data across several groups. To learn more about such features, begin by examining the <code class="inlineCode">notch</code> and <code class="inlineCode">varwidth</code> options in the R <code class="inlineCode">boxplot()</code> documentation by typing the <code class="inlineCode">?boxplot</code> command.</p>
    </div>
    <p class="normal">The minimum and maximum values can be illustrated using whiskers that extend below and above the box; however, a widely used convention only allows the whiskers to extend to a minimum or maximum of 1.5 times the IQR below Q1 or above Q3. Any values that fall beyond this threshold are considered outliers and are denoted as circles or dots. For example, recall that the IQR for <code class="inlineCode">price</code> was 3,909 with Q1 of 10,995 and Q3 of 14,904. An outlier is therefore any value that is less than 10995 - 1.5 * 3909 = 5131.5 or greater than 14904 + 1.5 * 3909 = 20767.5.</p>
    <p class="normal">The <code class="inlineCode">price</code> boxplot shows two outliers on both the high and low ends. On the <code class="inlineCode">mileage</code> boxplot, there are <a id="_idIndexMarker233"/>no outliers on the low end and thus the bottom whisker extends to the minimum<a id="_idIndexMarker234"/> value of 4,867. On the high end, we see several outliers beyond the 100,000-mile mark. These outliers are responsible for our earlier finding, which noted that the mean value was much greater than the median.</p>
    <h3 class="heading-3" id="_idParaDest-53">Visualizing numeric features – histograms</h3>
    <p class="normal">A <strong class="keyWord">histogram</strong> is <a id="_idIndexMarker235"/>another way to visualize the spread of a<a id="_idIndexMarker236"/> numeric feature. It is like a boxplot in that it divides the feature values into a predefined number of portions or <strong class="keyWord">bins</strong>, which act as containers for values. Their similarities end there, however. Where a boxplot creates four portions containing the same number of values but varying in range, a histogram uses a larger number of portions of identical range and allows the bins to contain different numbers of values.</p>
    <p class="normal">We can create a histogram for the used car <code class="inlineCode">price</code> and <code class="inlineCode">mileage</code> data using the <code class="inlineCode">hist()</code> function. As we did with the boxplot, we will specify a title for the figure using the <code class="inlineCode">main</code> parameter and label the <em class="italic">x</em> axis with the <code class="inlineCode">xlab</code> parameter. The commands to create the histograms are:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; hist(usedcars$price, main = <span class="hljs-string">"Histogram of Used Car Prices"</span>,
       xlab = <span class="hljs-string">"Price ($)"</span>)
&gt; hist(usedcars$mileage, main = <span class="hljs-string">"Histogram of Used Car Mileage"</span>,
       xlab = <span class="hljs-string">"Odometer (mi.)"</span>)
</code></pre>
    <p class="normal">This produces the following diagrams:</p>
    <figure class="mediaobject"><img alt="Chart, histogram  Description automatically generated" src="../Images/B17290_02_05.png"/></figure>
    <p class="packt_figref">Figure 2.5: Histograms of used car price and mileage data</p>
    <p class="normal">The <a id="_idIndexMarker237"/>histogram is<a id="_idIndexMarker238"/> composed of a series of bars with heights indicating the count, or <strong class="keyWord">frequency</strong>, of values falling within each of the equal-width bins partitioning the values. The vertical lines that separate the bars, as labeled on the horizontal axis, indicate the start and end points of the range of values falling within the bin.</p>
    <div class="packt_tip">
      <p class="normal">You may have noticed that the preceding histograms have differing numbers of bins. This is because the <code class="inlineCode">hist()</code> function attempts to identify the optimal number of bins for the feature’s range. If you’d like to override this default, use the <code class="inlineCode">breaks</code> parameter. Supplying an integer such as <code class="inlineCode">breaks = 10</code> creates exactly 10 bins of equal width, while supplying a vector such as <code class="inlineCode">c(5000, 10000, 15000, 20000)</code> creates bins that break at the specified values.</p>
    </div>
    <p class="normal">On the <code class="inlineCode">price</code> histogram, each of the 10 bars spans an interval of $2,000, beginning at $2,000 and ending at $22,000. The tallest bar in the center of the figure covers the range from $12,000 to $14,000 and has a frequency of 50. Since we know our data includes 150 cars, we know that one-third of all the cars are priced from $12,000 to $14,000. Nearly 90 cars—more than half—are priced from $12,000 to $16,000.</p>
    <p class="normal">The <code class="inlineCode">mileage</code> histogram includes eight bars representing bins of 20,000 miles each, beginning at 0 and ending at 160,000 miles. Unlike the <code class="inlineCode">price</code> histogram, the tallest bar is not in the center of the data, but on the left-hand side of the diagram. The 70 cars contained in this bin have odometer readings from 20,000 to 40,000 miles.</p>
    <p class="normal">You might also<a id="_idIndexMarker239"/> notice that the shape of the two histograms is somewhat different. It seems that the used car prices tend to be evenly divided on both sides of the middle, while the car mileages stretch further to the right.</p>
    <p class="normal">This <a id="_idIndexMarker240"/>characteristic is known<a id="_idIndexMarker241"/> as <strong class="keyWord">skew</strong>, or more specifically right skew, because the values on the high end (right side) are far more spread out than the values on the low end (left side). As shown in the following diagram, histograms of skewed data look stretched on one of the sides:</p>
    <p class="normal"><img alt="A picture containing text, furniture, mirror, table  Description automatically generated" src="../Images/B17290_02_06.png"/></p>
    <p class="packt_figref">Figure 2.6: Three skew patterns visualized with idealized histograms</p>
    <p class="normal">The ability to quickly diagnose such patterns in our data is one of the strengths of the histogram as a data exploration tool. This will become even more important as we start examining other patterns of spread in numeric data.</p>
    <h3 class="heading-3" id="_idParaDest-54">Understanding numeric data – uniform and normal distributions</h3>
    <p class="normal">Histograms, boxplots, and <a id="_idIndexMarker242"/>statistics describing the center <a id="_idIndexMarker243"/>and spread provide ways to examine the distribution of a feature’s values. A variable’s <strong class="keyWord">distribution</strong> describes how likely a value<a id="_idIndexMarker244"/> is to fall within various ranges.</p>
    <p class="normal">If all values are equally likely to occur—say, for instance, in a dataset recording the values rolled on a fair six-sided die—the distribution is said to be uniform. A uniform distribution is easy to detect with a histogram because the bars are approximately the same height. The histogram may look something like the following diagram:</p>
    <figure class="mediaobject"><img alt="Shape, rectangle  Description automatically generated" src="../Images/B17290_02_07.png"/></figure>
    <p class="packt_figref">Figure 2.7: A uniform distribution visualized with an idealized histogram</p>
    <p class="normal">It’s important to note that not all random events are uniform. For instance, rolling a weighted six-sided trick die would result in some numbers coming up more often than others. While each roll of the die results in a randomly selected number, they are not equally likely.</p>
    <p class="normal">The used <a id="_idIndexMarker245"/>car <code class="inlineCode">price</code> and <code class="inlineCode">mileage</code> data are also clearly not uniform, since some values are seemingly far more likely to occur than others. In fact, on the <code class="inlineCode">price</code> histogram, it seems that values become less likely to occur as they are further away from both sides of the center bar, which results in a bell-shaped distribution of data. This <a id="_idIndexMarker246"/>characteristic is so common in real-world data that it is the hallmark of the so-called <strong class="keyWord">normal distribution</strong>. The stereotypical bell-shaped curve of the normal distribution is shown in the following diagram:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B17290_02_08.png"/></figure>
    <p class="packt_figref">Figure 2.8: A normal distribution visualized with an idealized histogram</p>
    <p class="normal">Although there are numerous types of non-normal distributions, many real-world phenomena generate data that can be described by the normal distribution. Therefore, the normal distribution’s properties have been studied in detail.</p>
    <h3 class="heading-3" id="_idParaDest-55">Measuring spread – variance and standard deviation</h3>
    <p class="normal">Distributions <a id="_idIndexMarker247"/>allow us to characterize a large number of values using a smaller number of parameters. The normal distribution, which describes many types of real-world data, can be defined with just two: center and spread. The center of the normal distribution is defined by its mean value, which we have used before. The spread is measured <a id="_idIndexMarker248"/>by a statistic called <a id="_idIndexMarker249"/>the <strong class="keyWord">standard deviation</strong>.</p>
    <p class="normal">To calculate the standard deviation, we must first<a id="_idIndexMarker250"/> obtain the <strong class="keyWord">variance</strong>, which<a id="_idIndexMarker251"/> is defined as the average of the squared differences between each value and the mean value. In mathematical notation, the variance of a set of <em class="italic">n</em> values in a set named <em class="italic">x</em> is defined by the following formula:</p>
    <p class="center"><img alt="" src="../Images/B17290_02_001.png"/></p>
    <p class="normal">In this formula, the Greek letter <em class="italic">mu</em> (written as <em class="italic"><img alt="" src="../Images/B17290_02_003.png"/></em>) denotes the mean of the values, and the variance itself is denoted by the Greek letter <em class="italic">sigma</em> squared (written as <em class="italic"><img alt="" src="../Images/B17290_02_004.png"/></em>).</p>
    <p class="normal">The standard deviation is the square root of the variance, and is denoted by sigma (written as <em class="italic"><img alt="" src="../Images/B17290_02_005.png"/></em>) as shown in the following formula:</p>
    <p class="center"><img alt="" src="../Images/B17290_02_002.png"/></p>
    <p class="normal">In R, the <code class="inlineCode">var()</code> and <code class="inlineCode">sd()</code> functions save us the trouble of calculating the variance and standard deviation by hand. For example, computing the variance and standard deviation of the <code class="inlineCode">price</code> and <code class="inlineCode">mileage</code> vectors, we find:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; var(usedcars$price)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 9749892
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; sd(usedcars$price)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 3122.482
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; var(usedcars$mileage)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 728033954
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; sd(usedcars$mileage)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 26982.1
</code></pre>
    <p class="normal">When interpreting the variance, larger numbers indicate that the data is spread more widely around the mean. The standard deviation indicates, on average, how much each value differs from the mean.</p>
    <div class="note">
      <p class="normal">If you compute these statistics by hand using the formulas in the preceding diagrams, you will obtain a slightly different result than the built-in R functions. This is because the preceding formulas use the population variance (which divides by <em class="italic">n</em>), while R uses the sample variance (which divides by <em class="italic">n - 1</em>). Except for very small datasets, the distinction is minor.</p>
    </div>
    <p class="normal">The<a id="_idIndexMarker252"/> standard <a id="_idIndexMarker253"/>deviation can be <a id="_idIndexMarker254"/>used to quickly estimate how extreme a given value is under the assumption that it came from a normal distribution. The <strong class="keyWord">68–95–99.7 rule</strong> states that 68 <a id="_idIndexMarker255"/>percent of values in a normal distribution fall within one standard deviation of the mean, while 95 percent and 99.7 percent of values fall within two and three standard deviations, respectively. This is illustrated in the following diagram:</p>
    <figure class="mediaobject"><img alt="Chart, diagram, histogram  Description automatically generated" src="../Images/B17290_02_09.png"/></figure>
    <p class="packt_figref">Figure 2.9: The percent of values within one, two, and three standard deviations of a normal distribution’s mean</p>
    <p class="normal">Applying this information to the used car data, we know that the mean and standard deviation of <code class="inlineCode">price</code> were $12,962 and $3,122 respectively. Therefore, by assuming that the prices are normally distributed, approximately 68 percent of cars in our data were advertised at prices between $12,962 - $3,122 = $9,840 and $12,962 + $3,122 = $16,804.</p>
    <div class="packt_tip">
      <p class="normal">Although, strictly speaking, the 68–95–99.7 rule only applies to normal distributions, the basic principle applies to almost any data; values more than three standard deviations away from the mean tend to be exceedingly rare events.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-56">Exploring categorical features</h2>
    <p class="normal">If you <a id="_idIndexMarker256"/>recall, the <a id="_idIndexMarker257"/>used car dataset contains three categorical features: <code class="inlineCode">model</code>, <code class="inlineCode">color</code>, and <code class="inlineCode">transmission</code>. Additionally, although <code class="inlineCode">year</code> is stored as a numeric vector, each year can be imagined as a category applying to multiple cars. We might therefore consider treating it as categorical as well.</p>
    <p class="normal">In contrast to numeric data, categorical data is typically examined using tables rather than summary statistics. A table that presents a single categorical feature is known as a <strong class="keyWord">one-way table</strong>. The <code class="inlineCode">table()</code> function can be used to generate one-way tables for the used car data:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; table(usedcars$year)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012
   3    1    1    1    3    2    6   11   14   42   49   16    1
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; table(usedcars$model)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con"> SE SEL SES
78  23  49
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">&gt; table(usedcars$color)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con"> Black   Blue   Gold   Gray  Green    Red Silver  White Yellow
    35     17      1     16      5     25     32     16      3
</code></pre>
    <p class="normal">The <code class="inlineCode">table()</code> output lists the categories of the nominal variable and a count of the number of values falling into each category. Since we know there are 150 used cars in the dataset, we can determine that roughly one-third of all the cars were manufactured in 2010, given that 49/150 = 0.327.</p>
    <p class="normal">R can also perform the calculation of table proportions directly, by using the <code class="inlineCode">prop.table()</code> command on a table produced by the <code class="inlineCode">table()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; model_table &lt;- table(usedcars$model)
&gt; prop.table(model_table)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">       SE       SEL       SES
0.5200000 0.1533333 0.3266667
</code></pre>
    <p class="normal">The results of <code class="inlineCode">prop.table()</code> can be combined with other R functions to transform the output. Suppose we would like to display the results in percentages with a single decimal place. We can do this by multiplying the proportions by 100, then using the <code class="inlineCode">round()</code> function while specifying <code class="inlineCode">digits = 1</code>, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; color_table &lt;- table(usedcars$color)
&gt; color_pct &lt;- prop.table(color_table) * <span class="hljs-number">100</span>
&gt; <span class="hljs-built_in">round</span>(color_pct, digits = <span class="hljs-number">1</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">Black   Blue   Gold   Gray  Green    Red Silver  White Yellow
 23.3   11.3    0.7   10.7    3.3   16.7   21.3   10.7    2.0
</code></pre>
    <p class="normal">Although this<a id="_idIndexMarker258"/> includes the same information as the default <code class="inlineCode">prop.table()</code> output, the changes make it easier to read. The results show that black is <a id="_idIndexMarker259"/>the most common color, with nearly a quarter (23.3 percent) of all advertised cars. Silver is a close second with 21.3 percent, and red is third with 16.7 percent.</p>
    <h3 class="heading-3" id="_idParaDest-57">Measuring the central tendency – the mode</h3>
    <p class="normal">In <a id="_idIndexMarker260"/>statistics terminology, the <strong class="keyWord">mode</strong> of a feature <a id="_idIndexMarker261"/>is the value occurring most often. Like the mean and<a id="_idIndexMarker262"/> median, the mode is another measure of central tendency. It is typically used for categorical data, since the mean and median are not defined for nominal variables.</p>
    <p class="normal">For example, in the used car data, the mode of <code class="inlineCode">year</code> is 2010, while the modes for the <code class="inlineCode">model</code> and <code class="inlineCode">color</code> variables are <code class="inlineCode">SE</code> and <code class="inlineCode">Black</code>, respectively. A variable may have more than one mode; a variable with a single<a id="_idIndexMarker263"/> mode is <strong class="keyWord">unimodal</strong>, while a variable with two <a id="_idIndexMarker264"/>modes is <strong class="keyWord">bimodal</strong>. Data with multiple modes is more generally <a id="_idIndexMarker265"/>called <strong class="keyWord">multimodal</strong>.</p>
    <div class="packt_tip">
      <p class="normal">Although you might suspect that you could use the <code class="inlineCode">mode()</code> function, R uses this to obtain the type of variable (as in numeric, list, and so on) rather than the statistical mode. Instead, to find the statistical mode, simply look at the <code class="inlineCode">table()</code> output for the category with the greatest number of values.</p>
    </div>
    <p class="normal">The mode or modes are used in a qualitative sense to gain an understanding of important values. Even so, it would be dangerous to place too much emphasis on the mode since the most common value is not necessarily a majority. For instance, although black was the single most common car color, it was only about a quarter of all advertised cars.</p>
    <p class="normal">It is best to think about the modes in relation to the other categories. Is there one category that dominates all others, or are there several? Thinking about modes this way may help to generate testable hypotheses by raising questions about what makes certain values more common than others. If black and silver are common used car colors, we might believe that the data represents luxury cars, which tend to be sold in more conservative colors. Alternatively, these colors could indicate economy cars, which are sold with fewer color options. We will keep these questions in mind as we continue to examine this data. </p>
    <p class="normal">Thinking about <a id="_idIndexMarker266"/>the modes as common values allows us to apply the concept of the statistical mode to numeric data. Strictly speaking, it would be unlikely to have a mode for a continuous variable, since no two values are likely to repeat. However, if we think about modes as the highest bars on a histogram, we can discuss the modes of variables such as <code class="inlineCode">price</code> and <code class="inlineCode">mileage</code>. It can be helpful to consider the mode when exploring numeric data, particularly to examine whether the data is multimodal.</p>
    <figure class="mediaobject"><img alt="A picture containing graphical user interface  Description automatically generated" src="../Images/B17290_02_10.png"/></figure>
    <p class="packt_figref">Figure 2.10: Hypothetical distributions of numeric data with one and two modes</p>
    <h2 class="heading-2" id="_idParaDest-58">Exploring relationships between features</h2>
    <p class="normal">So far, we have <a id="_idIndexMarker267"/>examined variables one at a time, calculating only <strong class="keyWord"><a id="_idIndexMarker268"/></strong><strong class="keyWord">univariate</strong> statistics. During our investigation, we raised questions that we were unable to answer before:</p>
    <ul>
      <li class="bulletList">Does the <code class="inlineCode">price</code> and <code class="inlineCode">mileage</code> data imply that we are examining only economy-class cars, or are there luxury cars with high mileage?</li>
      <li class="bulletList">Do relationships between <code class="inlineCode">model</code> and <code class="inlineCode">color</code> provide insight into the types of cars we are examining?</li>
    </ul>
    <p class="normal">These types of questions can be addressed by<a id="_idIndexMarker269"/> looking <a id="_idIndexMarker270"/>at <strong class="keyWord">bivariate</strong> relationships, which consider the relationship between two variables. Relationships of more than two variables are<a id="_idIndexMarker271"/> called <strong class="keyWord">multivariate</strong> relationships. Let’s <a id="_idIndexMarker272"/>begin with the bivariate case.</p>
    <h3 class="heading-3" id="_idParaDest-59">Visualizing relationships – scatterplots</h3>
    <p class="normal">A <strong class="keyWord">scatterplot</strong> is a <a id="_idIndexMarker273"/>diagram that visualizes a bivariate relationship<a id="_idIndexMarker274"/> between numeric features. It is a two-dimensional figure in which dots are drawn on a coordinate plane using the values of one feature to provide the horizontal <em class="italic">x</em> coordinates, and the values of another feature to provide the vertical <em class="italic">y</em> coordinates. Patterns in the placement of dots reveal underlying associations between the two features.</p>
    <p class="normal">To answer our <a id="_idIndexMarker275"/>question about the relationship between <code class="inlineCode">price</code> and <code class="inlineCode">mileage</code>, we will examine a scatterplot. We’ll use the <code class="inlineCode">plot()</code> function, along with the <code class="inlineCode">main</code>, <code class="inlineCode">xlab</code>, and <code class="inlineCode">ylab</code> parameters used previously to label the diagram.</p>
    <p class="normal">To use <code class="inlineCode">plot()</code>, we need to specify <code class="inlineCode">x</code> and <code class="inlineCode">y</code> vectors containing the values used to position the dots on the figure. Although the conclusions would be the same regardless of the variable used to supply the <em class="italic">x</em> and <em class="italic">y</em> coordinates, convention dictates that the <em class="italic">y</em> variable is the one that is presumed to depend on the other (and is therefore known as the <strong class="keyWord">dependent variable</strong>). Since <a id="_idIndexMarker276"/>a seller cannot modify a car’s odometer reading, mileage is unlikely to be dependent on the car’s price. Instead, our hypothesis is that a car’s price depends on the odometer mileage. Therefore, we will select <code class="inlineCode">price</code> as the dependent <em class="italic">y</em> variable.</p>
    <p class="normal">The full command to create our scatterplot is:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; plot(x = usedcars$mileage, y = usedcars$price,
       main = <span class="hljs-string">"Scatterplot of Price vs. Mileage"</span>,
       xlab = <span class="hljs-string">"Used Car Odometer (mi.)"</span>,
       ylab = <span class="hljs-string">"Used Car Price ($)"</span>)
</code></pre>
    <p class="normal">This produces the following scatterplot:</p>
    <figure class="mediaobject"><img alt="Chart, scatter chart  Description automatically generated" src="../Images/B17290_02_11.png"/></figure>
    <p class="packt_figref">Figure 2.11: The relationship between used car price and mileage</p>
    <p class="normal">Using the <a id="_idIndexMarker277"/>scatterplot, we notice a clear relationship between the price of a used car and the odometer reading. To read the plot, examine how the values of the <em class="italic">y</em> axis variable change as the values on the <em class="italic">x</em> axis increase. In this case, car prices tend to be lower as the mileage increases. If you have ever sold or shopped for a used car, this is not a profound insight.</p>
    <p class="normal">Perhaps a more <a id="_idIndexMarker278"/>interesting finding is the fact that there are very few cars that have both high price and high mileage, aside from a lone outlier at about 125,000 miles and $14,000. The absence of more points like this provides evidence to support the conclusion that our dataset is unlikely to include any high-mileage luxury cars. All the most expensive cars in the data, particularly those above $17,500, seem to have extraordinarily low mileage, which implies that we could be looking at a single type of car that retails for a price of around $20,000 when new.</p>
    <p class="normal">The relationship we’ve observed between car prices and mileage is known as a negative association because it forms a pattern of dots in a line sloping downward. A positive association would appear to form a line sloping upward. A flat line, or a seemingly random scattering of dots, is evidence that the two variables are not associated at all. The strength of a linear association between two variables is measured by a statistic known as <strong class="keyWord">correlation</strong>. Correlations <a id="_idIndexMarker279"/>are discussed in detail in <em class="chapterRef">Chapter 6</em>, <em class="italic">Forecasting Numeric Data – Regression Methods</em>, which covers methods for modeling linear relationships.</p>
    <div class="packt_tip">
      <p class="normal">Keep in mind that not all associations form straight lines. Sometimes the dots form a U shape or V shape, while sometimes the pattern seems to be weaker or stronger for increasing values of the <em class="italic">x</em> or <em class="italic">y</em> variable. Such patterns imply that the relationship between the two variables is not linear, and thus correlation would be a poor measure of their association.</p>
    </div>
    <h3 class="heading-3" id="_idParaDest-60">Examining relationships – two-way cross-tabulations</h3>
    <p class="normal">To examine <a id="_idIndexMarker280"/>a relationship <a id="_idIndexMarker281"/>between two nominal variables, a <strong class="keyWord">two-way cross-tabulation</strong> is <a id="_idIndexMarker282"/>used (also known as a <strong class="keyWord">crosstab</strong> or <strong class="keyWord">contingency table</strong>). A <a id="_idIndexMarker283"/>cross-tabulation <a id="_idIndexMarker284"/>is like a scatterplot in that it allows you to examine how the values of one variable vary by the values of another. The format is a table in which the rows are the levels of one variable, while the columns are the levels of another. Counts in each of the table’s cells indicate the number of values falling into the row and column combination.</p>
    <p class="normal">To answer our earlier question about whether there is a relationship between <code class="inlineCode">model</code> and <code class="inlineCode">color</code>, we will examine a crosstab. There are several functions to produce two-way tables in R, including <code class="inlineCode">table()</code>, which we used before for one-way tables. The <code class="inlineCode">CrossTable()</code> function in the <code class="inlineCode">gmodels</code> package by Gregory R. Warnes is perhaps the most user-friendly, as it presents the row, column, and margin percentages in a single table, saving us the trouble of computing them ourselves. To install the <code class="inlineCode">gmodels</code> package if you haven’t already done so using the instructions in the prior chapter, use the following command:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; install.packages(<span class="hljs-string">"gmodels"</span>)
</code></pre>
    <p class="normal">After the package installs, type <code class="inlineCode">library(gmodels)</code> to load the package. Although you only need to install the package once, you will need to load the package with the <code class="inlineCode">library()</code> command during each R session in which you plan to use the <code class="inlineCode">CrossTable()</code> function.</p>
    <p class="normal">Before proceeding<a id="_idIndexMarker285"/> with our analysis, let’s simplify our project by reducing the number of levels in the <code class="inlineCode">color</code> variable. This variable has nine levels, but we don’t really need this much detail. What we are truly interested in is whether the car’s color is conservative. Toward this end, we’ll divide the nine colors into two groups—the first group will include the conservative colors black, gray, silver, and white; the second group will include blue, gold, green, red, and yellow. We’ll <a id="_idIndexMarker286"/>create a logical vector indicating whether the car’s color is conservative by our definition. The following returns <code class="inlineCode">TRUE</code> if the car is one of the four conservative colors, and <code class="inlineCode">FALSE</code> otherwise:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; usedcars$conservative &lt;-
    usedcars$color %in% <span class="hljs-built_in">c</span>(<span class="hljs-string">"Black"</span>, <span class="hljs-string">"Gray"</span>, <span class="hljs-string">"Silver"</span>, <span class="hljs-string">"White"</span>)
</code></pre>
    <p class="normal">You may have noticed a new command here. The <code class="inlineCode">%in%</code> operator returns <code class="inlineCode">TRUE</code> or <code class="inlineCode">FALSE</code> for each value in the vector on the left-hand side of the operator, indicating whether the value is found in the vector on the right-hand side. In simple terms, you can translate this line as “is the used car color in the set of black, gray, silver, and white?”</p>
    <p class="normal">Examining the <code class="inlineCode">table()</code> output for our newly created variable, we see that about two-thirds of the cars have conservative colors while one-third do not:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; table(usedcars$conservative)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">FALSE  TRUE
   51    99
</code></pre>
    <p class="normal">Now, let’s look<a id="_idIndexMarker287"/> at a cross-tabulation to see how the proportion of conservatively colored cars varies by model. Since we’re assuming that the model of car dictates the choice of color, we’ll treat the conservative color indicator as the dependent (<code class="inlineCode">y</code>) variable. The <code class="inlineCode">CrossTable()</code> command is therefore:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; CrossTable(x = usedcars$model, y = usedcars$conservative)
</code></pre>
    <p class="normal">This <a id="_idIndexMarker288"/>results in the following table:</p>
    <pre class="programlisting con"><code class="hljs-con">       Cell Contents                                           
|-------------------------|
|                       N |
| Chi-square-contribution |
|           N / Row Total |
|           N / Col Total |
|         N / Table Total |
|-------------------------|
Total Observations in Table:  150
                       | usedcars$conservative                 
       usedcars$model  |   FALSE  |       TRUE  |  Row Total  |
-----------------------|----------|-------------|-------------|
                    SE |       27 |          51 |          78 |
                       |    0.009 |       0.004 |             |
                       |    0.346 |       0.654 |       0.520 |
                       |    0.529 |       0.515 |             |
                       |    0.180 |       0.340 |             |
-----------------------|----------|-------------|-------------|
                   SEL |        7 |          16 |          23 |
                       |    0.086 |       0.044 |             |
                       |    0.304 |       0.696 |       0.153 |
                       |    0.137 |       0.612 |             |
                       |    0.047 |       0.107 |             |
-----------------------|----------|-------------|-------------|
                   SES |       17 |          32 |          49 |
                       |    0.007 |       0.004 |             |
                       |    0.347 |       0.653 |       0.327 |
                       |    0.333 |       0.323 |             |
                       |    0.113 |       0.213 |             |
-----------------------|----------|-------------|-------------|
          Column Total |       51 |          99 |         150 |
                       |    0.340 |       0.660 |             |
-----------------------|----------|-------------|-------------|
</code></pre>
    <p class="normal">The <code class="inlineCode">CrossTable()</code> output is <a id="_idIndexMarker289"/>dense with numbers, but the legend at the top (labeled <code class="inlineCode">Cell Contents</code>) indicates how to interpret each value. The table rows indicate the three models of used cars: <code class="inlineCode">SE</code>, <code class="inlineCode">SEL</code>, and <code class="inlineCode">SES</code> (plus an additional row for the total across all models). The columns indicate whether the car’s color is conservative (plus a column totaling across both types of color).</p>
    <p class="normal">The first <a id="_idIndexMarker290"/>value in each cell indicates the number of cars with that combination of model and color. The proportions indicate each cell’s contribution to the chi-square statistic, the row total, the column total, and the table’s overall total.</p>
    <p class="normal">What we are most interested in is the proportion of conservative cars for each model. The row proportions tell us that 0.654 (65 percent) of <code class="inlineCode">SE</code> cars are colored conservatively, in comparison to 0.696 (70 percent) of <code class="inlineCode">SEL</code> cars, and 0.653 (65 percent) of <code class="inlineCode">SES</code>. These differences are relatively small, which suggests that there are no substantial differences in the types of colors chosen for each model of car.</p>
    <p class="normal">The<a id="_idIndexMarker291"/> chi-square values refer to the cell’s contribution in <a id="_idIndexMarker292"/>the <strong class="keyWord">Pearson’s chi-squared test</strong> for independence between two variables. Although a complete discussion of the statistics behind this test is highly technical, the test measures how likely it is that the difference in cell counts in the table is due to chance alone, which can help us confirm our hypothesis that the differences by group are not substantial. Beginning by adding the cell contributions for the six cells in the table, we find <em class="italic">0.009 + 0.004 + 0.086 + 0.044 + 0.007 + 0.004 = 0.154</em>. This is the chi-squared test statistic.</p>
    <p class="normal">To calculate the probability that this statistic is observed under the hypothesis that there is no association between the variables, we pass the test statistic to the <code class="inlineCode">pchisq()</code> function as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; pchisq(<span class="hljs-number">0.154</span>, df = <span class="hljs-number">2</span>, lower.tail = <span class="hljs-literal">FALSE</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 0.9258899
</code></pre>
    <p class="normal">The <code class="inlineCode">df</code> parameter refers to the degrees of freedom, which is a component of the statistical test related to the number of rows and columns in the table; again, ignoring what it means, it can be computed as (<em class="italic">rows - 1</em>) * (<em class="italic">columns - 1</em>), or 1 for a 2x2 table and 2 for the 3x2 table used here. Setting <code class="inlineCode">lower.tail = FALSE</code> requests the right-tailed probability of about 0.926, which can be understood intuitively as the probability of obtaining a test statistic of at least 0.154 or greater due to chance alone. </p>
    <p class="normal">If the probability of the chi-squared test is very low—perhaps below ten, five, or even one percent—it provides strong evidence that the two variables are associated, because the observed association in the table is unlikely to have happened by chance. In our case, the probability is much closer to 100 percent than to 10 percent, so it is unlikely we are observing an association between <code class="inlineCode">model</code> and <code class="inlineCode">color</code> for cars in this dataset.</p>
    <p class="normal">Rather than computing this by hand, you can also obtain the chi-squared test results by adding an additional parameter specifying <code class="inlineCode">chisq = TRUE</code> when calling the <code class="inlineCode">CrossTable()</code> function. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">&gt; CrossTable(x = usedcars$model, y = usedcars$conservative,
               chisq = <span class="hljs-literal">TRUE</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">Pearson's Chi-squared test 
------------------------------------------------------------
Chi^2 =  0.1539564     d.f. =  2     p =  0.92591
</code></pre>
    <p class="normal">Note that, aside <a id="_idIndexMarker293"/>from slight differences due to rounding, this produces the same chi-squared test statistic and probability as was computed by hand.</p>
    <div class="packt_tip">
      <p class="normal">The chi-squared test performed here is one of many types of formal hypothesis testing that can be performed using traditional statistics. If you’ve ever heard the phrase “statistically significant,” it means a statistical test like chi-squared (or one of many others) was performed, and it reached a “significant” level—typically, a probability less than five percent. Although hypothesis testing is somewhat beyond the scope of this book, it will be encountered again briefly in <em class="chapterRef">Chapter 6</em>, <em class="italic">Forecasting Numeric Data – Regression Methods</em>.</p>
    </div>
    <h1 class="heading-1" id="_idParaDest-61">Summary</h1>
    <p class="normal">In this chapter, we learned about the basics of managing data in R. We started by taking an in-depth look at the structures used for storing various types of data. The foundational R data structure is the vector, which is extended and combined into more complex data types, such as lists and data frames. The data frame is an R data structure that corresponds to the notion of a dataset having both features and examples. R provides functions for reading and writing data frames to spreadsheet-like tabular data files.</p>
    <p class="normal">We then explored a real-world dataset containing the prices of used cars. We examined numeric variables using common summary statistics of center and spread, and visualized relationships between prices and odometer readings with a scatterplot. Next, we examined nominal variables using tables. In examining the used car data, we followed an exploratory process that can be used to understand any dataset. These skills will be required for the other projects throughout this book.</p>
    <p class="normal">Now that we have spent some time understanding the basics of data management with R, you are ready to begin using machine learning to solve real-world problems. In the next chapter, we will tackle our first classification task using nearest neighbor methods. You may be surprised to discover that with just a few lines of R code, a machine can achieve human-like performance on a challenging medical diagnosis task.</p>
    <h1 class="heading-1" id="_idParaDest-62">Join our book’s Discord space</h1>
    <p class="normal">Join our Discord community to meet like-minded people and learn alongside more than 4000 people at:</p>
    <p class="normal"><a href="https://packt.link/r"><span class="url">https://packt.link/r</span></a></p>
    <p class="normal"><img alt="" src="../Images/r.jpg"/></p>
  </div>
</body></html>