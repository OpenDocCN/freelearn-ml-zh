["```py\n$ sudo port install py36-pyfftw\n```", "```py\n$ pip install --user pyFFTW\n```", "```py\n$ pip install --user pyFFTW==0.10.4\n```", "```py\nimport collections\nimport threading\nimport timeit\n\nimport numpy\nimport cv2\nimport wx\n\nimport pyfftw.interfaces.cache\nfrom pyfftw.interfaces.scipy_fftpack import fft\nfrom pyfftw.interfaces.scipy_fftpack import ifft\nfrom scipy.fftpack import fftfreq\n\nimport ResizeUtils\nimport WxUtils\n```", "```py\nclass LazyEyes(wx.Frame):\n\n    def __init__(self, maxHistoryLength=360,\n                 minHz=5.0/6.0, maxHz=1.0,\n                 amplification=32.0, numPyramidLevels=2,\n                 useLaplacianPyramid=True,\n                 useGrayOverlay=True,\n                 numFFTThreads=4, numIFFTThreads=4,\n                 cameraDeviceID=0, imageSize=(640, 480),\n                 title='Lazy Eyes'):\n```", "```py\n        self.mirrored = True\n\n        self._running = True\n\n        self._capture = cv2.VideoCapture(cameraDeviceID)\n        size = ResizeUtils.cvResizeCapture(\n                self._capture, imageSize)\n        w, h = size\n\n        self._image = None\n\n        self._imageFrontBuffer = None\n        self._imageFrontBufferLock = threading.Lock()\n```", "```py\n        self._useGrayOverlay = useGrayOverlay\n        if useGrayOverlay:\n            historyShape = (maxHistoryLength,\n                            h >> numPyramidLevels,\n                            w >> numPyramidLevels)\n        else:\n            historyShape = (maxHistoryLength,\n                            h >> numPyramidLevels,\n                            w >> numPyramidLevels, 3)\n```", "```py\n        self._maxHistoryLength = maxHistoryLength\n        self._history = numpy.empty(historyShape,\n                                    numpy.float32)\n        self._historyTimestamps = collections.deque() \n```", "```py\n        self._numPyramidLevels = numPyramidLevels\n        self._useLaplacianPyramid = useLaplacianPyramid\n\n        self._minHz = minHz\n        self._maxHz = maxHz\n        self._amplification = amplification\n\n        self._numFFTThreads = numFFTThreads\n        self._numIFFTThreads = numIFFTThreads\n```", "```py\n        pyfftw.interfaces.cache.enable()\n        pyfftw.interfaces.cache.set_keepalive_time(1.0)\n```", "```py\n        style = wx.CLOSE_BOX | wx.MINIMIZE_BOX | \\\n                wx.CAPTION | wx.SYSTEM_MENU | \\\n                wx.CLIP_CHILDREN\n        wx.Frame.__init__(self, None, title=title,\n                          style=style, size=size)\n\n        self.Bind(wx.EVT_CLOSE, self._onCloseWindow)\n\n        quitCommandID = wx.NewId()\n        self.Bind(wx.EVT_MENU, self._onQuitCommand,\n                  id=quitCommandID)\n        acceleratorTable = wx.AcceleratorTable([\n            (wx.ACCEL_NORMAL, wx.WXK_ESCAPE,\n             quitCommandID)\n        ])\n        self.SetAcceleratorTable(acceleratorTable)\n\n        self._videoPanel = wx.Panel(self, size=size)\n        self._videoPanel.Bind(\n                wx.EVT_ERASE_BACKGROUND,\n                self._onVideoPanelEraseBackground)\n        self._videoPanel.Bind(\n                wx.EVT_PAINT, self._onVideoPanelPaint)\n\n        self._videoBitmap = None\n\n        self._fpsStaticText = wx.StaticText(self)\n\n        border = 12\n\n        controlsSizer = wx.BoxSizer(wx.HORIZONTAL)\n        controlsSizer.Add(self._fpsStaticText, 0,\n                          wx.ALIGN_CENTER_VERTICAL)\n\n        rootSizer = wx.BoxSizer(wx.VERTICAL)\n        rootSizer.Add(self._videoPanel)\n        rootSizer.Add(controlsSizer, 0,\n                      wx.EXPAND | wx.ALL, border)\n        self.SetSizerAndFit(rootSizer)\n\n        self._captureThread = threading.Thread(\n                target=self._runCaptureLoop)\n        self._captureThread.start()\n```", "```py\n    def _onCloseWindow(self, event):\n        self._running = False\n        self._captureThread.join()\n        pyfftw.interfaces.cache.disable()\n        self.Destroy()\n```", "```py\n    def _onQuitCommand(self, event):\n        self.Close() \n```", "```py\n    def _onVideoPanelEraseBackground(self, event):\n        pass\n\n    def _onVideoPanelPaint(self, event):\n\n        self._imageFrontBufferLock.acquire()\n\n        if self._imageFrontBuffer is None:\n            self._imageFrontBufferLock.release()\n            return\n\n        # Convert the image to bitmap format.\n        self._videoBitmap = \\\n            WxUtils.wxBitmapFromCvImage(self._imageFrontBuffer)\n\n        self._imageFrontBufferLock.release()\n\n        # Show the bitmap.\n        dc = wx.BufferedPaintDC(self._videoPanel)\n        dc.DrawBitmap(self._videoBitmap, 0, 0)\n```", "```py\n    def _runCaptureLoop(self):\n\n        while self._running:\n            success, self._image = self._capture.read(\n                    self._image)\n            if self._image is not None:\n                self._applyEulerianVideoMagnification()\n                if (self.mirrored):\n                    self._image[:] = numpy.fliplr(self._image)\n\n                # Perform a thread-safe swap of the front and\n                # back image buffers.\n                self._imageFrontBufferLock.acquire()\n                self._imageFrontBuffer, self._image = \\\n                        self._image, self._imageFrontBuffer\n                self._imageFrontBufferLock.release()\n\n                # Send a refresh event to the video panel so\n                # that it will draw the image from the front\n                # buffer.\n                self._videoPanel.Refresh()\n```", "```py\n    def _applyEulerianVideoMagnification(self):\n\n        timestamp = timeit.default_timer()\n\n        if self._useGrayOverlay:\n            smallImage = cv2.cvtColor(\n                    self._image, cv2.COLOR_BGR2GRAY).astype(\n                            numpy.float32)\n        else:\n            smallImage = self._image.astype(numpy.float32)\n```", "```py\n        # Downsample the image using a pyramid technique.\n        i = 0\n        while i < self._numPyramidLevels:\n            smallImage = cv2.pyrDown(smallImage)\n            i += 1\n        if self._useLaplacianPyramid:\n            smallImage[:] -= \\\n                cv2.pyrUp(cv2.pyrDown(smallImage))\n```", "```py\n        historyLength = len(self._historyTimestamps)\n\n        if historyLength < self._maxHistoryLength - 1:\n\n            # Append the new image and timestamp to the\n            # history.\n            self._history[historyLength] = smallImage\n            self._historyTimestamps.append(timestamp)\n\n            # The history is still not full, so wait.\n            return\n```", "```py\n        if historyLength == self._maxHistoryLength - 1:\n            # Append the new image and timestamp to the\n            # history.\n            self._history[historyLength] = smallImage\n            self._historyTimestamps.append(timestamp)\n```", "```py\n        else:\n            # Drop the oldest image and timestamp from the\n            # history and append the new ones.\n            self._history[:-1] = self._history[1:]\n            self._historyTimestamps.popleft()\n            self._history[-1] = smallImage\n            self._historyTimestamps.append(timestamp)\n\n        # The history is full, so process it.\n```", "```py\n        # Find the average length of time per frame.\n        startTime = self._historyTimestamps[0]\n        endTime = self._historyTimestamps[-1]\n        timeElapsed = endTime - startTime\n        timePerFrame = \\\n                timeElapsed / self._maxHistoryLength\n        fps = 1.0 / timePerFrame\n        wx.CallAfter(self._fpsStaticText.SetLabel,\n                     'FPS: %.1f' % fps)\n```", "```py\n        # Apply the temporal bandpass filter.\n        fftResult = fft(self._history, axis=0,\n                        threads=self._numFFTThreads)\n```", "```py\n        frequencies = fftfreq(\n                self._maxHistoryLength, d=timePerFrame)\n        lowBound = (numpy.abs(\n                frequencies - self._minHz)).argmin()\n        highBound = (numpy.abs(\n                frequencies - self._maxHz)).argmin()\n        fftResult[:lowBound] = 0j\n        fftResult[highBound:-highBound] = 0j\n        fftResult[-lowBound:] = 0j\n```", "```py\n        ifftResult = ifft(fftResult, axis=0,\n                          threads=self._numIFFTThreads) \n```", "```py\n        # Amplify the result and overlay it on the\n        # original image.\n        overlay = numpy.real(ifftResult[-1]) * \\\n                          self._amplification\n        i = 0\n        while i < self._numPyramidLevels:\n            overlay = cv2.pyrUp(overlay)\n            i += 1\n        if self._useGrayOverlay:\n            overlay = cv2.cvtColor(overlay,\n                                   cv2.COLOR_GRAY2BGR)\n        cv2.add(self._image, overlay, self._image,\n                dtype=cv2.CV_8U)\n```", "```py\ndef main():\n    app = wx.App()\n    lazyEyes = LazyEyes()\n    lazyEyes.Show()\n    app.MainLoop()\n\nif __name__ == '__main__':\n    main() \n```", "```py\n    lazyEyes = LazyEyes(maxHistoryLength=360,\n                        minHz=5.0/6.0, maxHz=1.0,\n                        amplification=32.0,\n                        numPyramidLevels=2,\n                        useLaplacianPyramid=True,\n                        useGrayOverlay=True,\n                        numFFTThreads=4,\n                        numIFFTThreads=4,\n                        imageSize=(640, 480))\n```", "```py\n    lazyEyes = LazyEyes(useLaplacianPyramid=False,\n                        useGrayOverlay=False,\n                        imageSize=(320, 240)) \n```", "```py\n    lazyEyes = LazyEyes(minHz=1.4, maxHz=1.5,\n                        useLaplacianPyramid=False,\n                        useGrayOverlay=False,\n                        imageSize=(320, 240)) \n```"]