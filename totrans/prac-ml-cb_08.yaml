- en: Chapter 8. Reinforcement Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains - the stocks regime switching model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markov chains - the multi-channel attribution model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markov chains - the car rental agency service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Markov chains - vehicle service at the gas station
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monte Carlo simulations - calibrated hull and white short-rates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**The Markov chain**: A sequence  of trials of an experiment is a Markov chain
    if the outcome of each experiment is one of the set of discrete states, and the
    outcome of the experiment is dependent only on the present state and not of any
    of the past states. The probability of changing from one state to another state
    is represented as![Introduction](img/image_08_001.jpg). It is called a transition
    probability. The transition probability matrix is an n × n matrix such that each
    element of the matrix is non-negative and each row of the matrix sums to one.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous time Markov chains**: Continuous-time Markov chains can be labeled
    as transition systems augmented with rates that have discrete states. The states
    have continuous time-steps and the delays are exponentially distributed. Continuous-time
    Markov chains are suited to model reliability models, control systems, biological
    pathways, chemical reactions, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monte Carlo simulations**: Monte Carlo simulation  is a stochastic simulation
    of system behavior. The simulation uses sampling experiments to be performed on
    the model and then conducts numerical experiments using the computer to obtain
    a statistical understanding of the system behavior. Monte Carlo simulations are
    used to construct theories for observed behavior of complicated systems, predict
    future behavior of a system, and study effects on final results based upon input
    and parameter changes within a system. The stochastic simulation is a way of experimenting
    with a system to find ways to improve or better understand the system behavior.
    It uses random numbers that are uniformly distributed over the interval [0, 1].
    These uniformly distributed random numbers are used for the generation of stochastic
    variables from various probability distributions. Sampling experiments are then
    generated, which are associated with the modeling of system behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains - the stocks regime switching model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few decades, a lot of studies have been conducted on the analysis
    and forecasting of volatility. Volatility is the degree of variation of a trading
    price series over time as measured by the standard deviation of returns. Models
    of stock returns assume that the returns follow a geometric Brownian motion. This
    implies that over any discrete time interval, the return on stocks is log normally
    distributed and that returns in non-overlapping intervals are independent. Studies
    have found that this model fails to capture extreme price movements and stochastic
    variability in the volatility parameter. Stochastic volatility takes discrete
    values, switching between these values randomly. This is the basis of the **regime-switching
    lognormal process** (**RSLN**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform the Markov chains regime switching model we shall be using
    data collected from the Stock's dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dataset called `StocksRegimeSwitching.csv` shall be used. This dataset
    is available in csv format and called `StocksRegimeSwitching.csv`. The dataset
    is in the standard format. There are 66 rows of data. There are seven variables.
    The numeric variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LRY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LRV`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LRC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LVS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LGS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-numeric variable is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to load the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.2 (2015-08-14).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships between the variables.
    We''ll begin by importing the CSV data file called `StocksRegimeSwitching.csv`.
    We will be saving the data to the `MarkovSwitchData` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Attaching the dataset. The `attach()` function attaches the dataset to the
    search path. The dataset is searched when evaluating the variables. `MarkovSwitchData`
    is passed as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `MarkovSwitchData` data frame. The `head()` function returns the
    first part of the `MarkovSwitchData` data frame. The `MarkovSwitchData` data frame
    is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the dimension of the `MarkovSwitchData` data frame. The `dim()`function
    returns the dimension of the `MarkovSwitchData` frame. The `MarkovSwitchData`
    data frame is passed as an input parameter. The result clearly states that there
    are 66 rows of data and seven single columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the summary of the `MarkovSwitchData` data frame. The `summary()`
    function is a multipurpose function. The `summary()` function is a generic function
    that provides a summary of the data related to the individual object or data frame.
    The `MarkovSwitchData` data frame is passed as an R object to the `summary()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring the data](img/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - preparing the regression model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A regression model will be prepared on the dataset. Regression analysis is used
    when two or more variables are thought to be systematically connected by a linear
    relationship. Regression models are used to predict one variable from another
    variable. They provide a prediction about the past, present, and future events,
    based on information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining the dependent variable. The `cbind()` function is used to define the
    dependent variable. The function takes in the `LVS` data frame. The resulting
    data frame is stored in the `yLogValueStocks` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `yLogValueStocks` frame. The `head()` function returns the first
    part of the `yLogValueStocks` frame. The `yLogValueStocks` frame is passed as
    an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the regression model](img/image_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `cbind ()` function takes in the `LGS` data frame. The resulting data frame
    is stored in the `yLogGrowthStocks` data frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Printing the `yLogGrowthStocks` frame. The `head()` function returns the first
    part of the `yLogGrowthStocks` data frame. The `yLogGrowthStocks` frame is passed
    as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the regression model](img/image_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Defining the independent variable The `cbind()` function is used to define
    the dependent variable. The function takes in the `LRY`, `LRC`, `INT`, `LRV` data
    frames. The resulting data frame is stored in the `x` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an **ordinary least square** (**OLS**) regression equation. The `lm()`
    function is used to fit linear models. The model to be fitted is represented symbolically
    by `yLogValueStocks~x`. The result is then stored in the `olsLogValueStocks` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `olsLogValueStocks` data frame. The `summary()`
    function is used to provide a summary of the data related to the individual object
    or data frame. The `olsLogValueStocks` data frame is passed as an R object to
    the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the regression model](img/image_08_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating an ordinary least square regression equation. The model to be fitted
    is represented symbolically by `yLogGrowthStocks~x`. The result is then stored
    in the `olsLogGrowthStocks` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `olsLogGrowthStocks` data frame. The `olsLogGrowthStocks`
    data frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing the regression model](img/image_08_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - preparing the Markov-switching model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Markov switching model involves multiple equations that can characterize
    the time series behaviors in different regimes. The model is able to capture complex
    dynamic patterns by switching between structures. The current value of the state
    variable depends on the immediate past value, which is controlled by the Markovian
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Markov switching model for the value of stocks. The `msmFit()` function
    implements a Markov switching models using the EM algorithm, as follows. `olsLogValueStocks`
    is of the object class of the `lm` type. `k = 2` represents the estimated number
    of regimes. The result is stored in the `MarkovSwtchLogValueStocks` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `MarkovSwtchLogValueStocks` data frame as follows.
    The `MarkovSwtchLogValueStocks` data frame is passed as an R object to the `summary()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing the Markov-switching model](img/image_08_009.jpg)![Step
    4 - preparing the Markov-switching model](img/image_08_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating a Markov switching model for growth stocks. The `msmFit()` function
    implements the Markov switching model using the EM algorithm. `olsLogGrowthStocks`
    is of the object class of the `lm` type. `k = 2` represents the estimated number
    of regimes. The result is stored in the `MarkoSwtchLogGrowthStocks` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the summary of the `MarkoSwtchLogGrowthStocksdata` frame. The `MarkoSwtchLogGrowthStocks`
    data frame is passed as an R object to the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing the Markov-switching model](img/image_08_011.jpg)![Step
    4 - preparing the Markov-switching model](img/image_08_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - plotting the regime probabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we shall be plotting the regime probabilities that have been calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotting the regime probabilities for the value of stocks. The `par()` function
    is used to query the graphical parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plotProb()` function creates each plot for each regime. The plot contains
    smoothed and filtered probabilities. `MarkovSwtchLogValueStocks` is passed as
    an object of type `MSM.lm`. The `which = 1` value represents the subset of the
    plots that is required. Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the regime probabilities](img/image_08_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plotProb()` function creates each plot for each regime. The plot contains
    smoothed and filtered probabilities. `MarkovSwtchLogValueStocks` is passed as
    an object of the `MSM.lm` type. The `which = 2` value represents the plot of the
    regime with the response variable against the smoothed probabilities. Use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the regime probabilities](img/image_08_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plotProb()` function creates each plot for each regime. `MarkoSwtchLogGrowthStocks`
    is passed as an object of the `MSM.lm` type. The `which = 1` value represents
    the subset of the plots that is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the regime probabilities](img/image_08_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plotProb()` function creates each plot for each regime. `MarkoSwtchLogGrowthStocks`
    is passed as an object of the `MSM.lm` type. The `which = 2` value represents
    the plot of the regime with the response variable against the smoothed probabilities.
    Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - plotting the regime probabilities](img/image_08_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 6 - testing the Markov switching model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we shall run a set of diagnostic tests on the Markov switching model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ploting the regime probabilities for the value of stocks. The `par()` function
    is used to query graphical parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the plots for the residual analysis. The `plotDiag()` function plots
    the residuals against the fitted values. `MarkovSwtchLogValueStocks` is passed
    as an object of the `MSM.lm` type. The `which = 1` value represents the subset
    of the plots is that required. The `which=1` value represents the plot of residuals
    against fitted values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - testing the Markov switching model](img/image_08_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plotDiag()` function plots the residuals against the fitted values. `MarkovSwtchLogValueStocks`
    is passed as an object of the `MSM.lm` type. `which = 2` represents the subset
    of the plots that is required. `which=2` represents the Normal Q-Q plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - testing the Markov switching model](img/image_08_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plotDiag()` function plots the residuals against the fitted values. `MarkoSwtchLogGrowthStocks`
    is passed as an object of the `MSM.lm` type. `which = 3` represents the subset
    of the plots that is required. `which=3` represents the ACF/PACF of residuals
    and the ACF/PACF of square residuals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - testing the Markov switching model](img/image_08_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plotDiag()` function plots the residuals against the fitted values. `MarkoSwtchLogGrowthStocks`
    is passed as an object of the `MSM.lm` type. `which = 1` represents the subset
    of the plots that is required. `which = 1` represents the plot of residuals against
    fitted values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - testing the Markov switching model](img/image_08_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plotDiag()` function plots the residuals against the fitted values. `MarkoSwtchLogGrowthStocks`
    is passed as an object of the `MSM.lm` type. `which = 2` represents the subset
    of the plots that is required. `which=2` represents the Normal Q-Q plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - testing the Markov switching model](img/image_08_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `plotDiag()` function plots the residuals against the fitted values. `MarkoSwtchLogGrowthStocks`
    is passed as an object of the `MSM.lm` type. `which = 3` represents the subset
    of the plots that is required. `which=3` represents the ACF/PACF of residuals
    and the ACF/PACF of square residuals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 6 - testing the Markov switching model](img/image_08_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Markov chains - the multi-channel attribution model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A customer's journey undergoes a path of different channels before a purchase
    on an e-commerce website. Multi-channel attribution assigns a value to each step
    in the journey. The question is how one can identify the value in the actions
    people take on your website that lead to a conversion. Commonly, businesses use
    "last click" attribution, which means assigning all the conversion value to the
    last step in the journey or "first click" attribution. The first step in developing
    multi-channel attribution analytics is to understand the customer's journey -
    from awareness through purchase to after-purchase support. The ultimate goal is
    to develop loyal customers who spend a significant money on purchases, recommend
    the brand to others, and it potentially becomes a brand.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform a Markov chains multi-channel attribution model we shall
    be simulating customer journeys containing three unique channels.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - preparing the dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First load the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.2 (2015-08-14).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the data sample: The `c()` function combines arguments to form a vector.
    All the arguments passed to the function are combined to form a common type that
    is the type of the returned value. The `data.frame()` function creates a tightly
    coupled data frame that is the collection of variables that share many of the
    properties of matrices and of lists. We will be saving the data to the `datafrm1`
    data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the `datafrm1` data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 - preparing the dataset](img/image_08_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 2 - preparing the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Preparing the Markov model. The `markov_model()` function estimates the k-order
    Markov model from customer journey data. `datafrm1` is the data frame that contains
    the customer journeys as defined. The `var_path` variable has the names of the
    columns that contain the journey path. The `var_conv` variable represents the
    name of the columns containing total conversions. The `var_null` variable represents
    the columns containing total paths that do not lead to conversions. `out_more
    = TRUE` returns the transition probabilities between channels and removal effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the estimated k-order Markov model is stored in the `model1`
    data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `model1` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - preparing the model](img/image_08_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Extract the result attribution from the `model1data` frame as follows. The
    result is then stored in the `datafrmresult1` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting the `transition_matrix` attribution from the `model1data` frame
    as follows. The result is then stored in the `datafrmtransmatrix1` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Reshaping the data frame. The result of the reshaped data frame is stored in
    `datafrmtransmatrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrmtransmatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - preparing the model](img/image_08_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - plotting the Markov graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Extracting the `transition_matrix` attribution from the `model1` data frame.
    The result is then stored in the `datafrmtransmatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the `datafrmtransmatrix` data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the `datafrmdummy` data sample. The `c()` function combines arguments
    to form a vector. All the arguments passed to the function are combined to form
    a common type that is the type of the returned value. The `data.frame()` function
    creates a tightly coupled data frame that is the collection of variables that
    share many of the properties of matrices and of lists. We will be saving the data
    to the `datafrmdummy` data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrmtransmatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Combining the columns as follows*.* `rbind()` takes a sequence of data frames
    and combines them. `datafrmtransmatrix` and `df_dummy` are passed as input parameters.
    The result is then the `datafrmtransmatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrmtransmatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Order the channels as follows. `factor()` as a function is used to encode a
    vector as a factor. `datafrmtransmatrix$channel_from` is passed as a vector of
    data. `levels = c(''(start)'', ''(conversion)'', ''(null)'', ''c1'', ''c2'', ''c3'')`
    represents an optional vector of the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrmtransmatrix$channel_from` data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Ordering the channels as follows. `datafrmtransmatrix$channel_to` is passed
    as a vector of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Print `datafrmtransmatrix$channel_to` the data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Reshaping the data frame. The result of the reshaped data frame is stored in
    `datafrmtransmatrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrmtransmatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the Markov chain object. `matrix()` as a function creates a matrix
    from a given set of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `transitionmatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a Markov chain object. The `transitionMatrix` will be a transition
    matrix, that is, all entries will be probabilities and either all rows or all
    columns will sum up to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `transitionmatrix1` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the Markov graph](img/image_08_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - simulating the dataset of customer journeys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `data.frame()` function creates a tightly coupled data frame that is the
    collection of variables that share many of the properties of matrices and of lists.
    We will be saving the data to the `datafrm2` data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrm2` frame. The `head()` function returns the first part
    of the `datafrm2` frame. The `datafrm2` frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - simulating the dataset of customer journeys](img/image_08_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Converting the character objects to date objects. `datafrm2$date` represents
    the object to be converted. `origin = "2016-01-01"` represents the `Date` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating the vectors after converting to characters. Add the `channel_`
    object to the channel. `datafrm2$channel` represents the data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrm2` frame. The `head()` function returns the first part
    of the `datafrm2` frame. The `datafrm2` frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - simulating the dataset of customer journeys](img/image_08_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Aggregating the channels to the paths for each customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrm2` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - simulating the dataset of customer journeys](img/image_08_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preparing the Markov models. The `markov_model()` function estimates the k-order
    Markov model from customer journey data. `datafrm2` is the data frame that contains
    the customer journeys as defined. `var_path` has the names of the columns that
    contain the journey path. `var_conv` represents the name of the columns containing
    total conversions. `var_null` represents the columns containing total paths that
    do not lead to conversions. `out_more = TRUE` returns the transition probabilities
    between channels and removal effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the estimated k-order Markov model is stored in the `model2`
    data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrmheuristic` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - simulating the dataset of customer journeys](img/image_08_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrmfirsttouch` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - simulating the dataset of customer journeys](img/image_08_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `datafrmfirsttouch` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - simulating the dataset of customer journeys](img/image_08_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Merging the two data frames by common columns. The result is stored in the
    `heuristicmodel2` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `heuristicmodel2` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - simulating the dataset of customer journeys](img/image_08_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Merging all the models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `allmodels` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - simulating the dataset of customer journeys](img/image_08_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - preparing a transition matrix heat map for real data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Plotting the heatmap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the maximum value of all the arguments present in the `datafrmplottransition$transition_probability`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of `t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - preparing a transition matrix heat map for real data](img/image_08_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - preparing a transition matrix heat map for real data](img/image_08_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Markov chains - the car rental agency service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose a car rental agency has three locations in Ottawa: A downtown location
    (labeled A), A East End location (labeled B), and a West End location (labeled
    C). The agency has a group of delivery drivers to serve all three locations. The
    agency''s statistician has determined the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Of the calls to the `Downtown` location, 30% are delivered in the Downtown area,
    30% are delivered in the `East` end, and 40% are delivered in the `West` end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of the calls to the `East` end location, 40% are delivered in the downtown area,
    40% are delivered in the `East` end, and 20% are delivered in the `West` end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of the calls to the `West` end location, 50% are delivered in the Downtown area,
    30% are delivered in the `East` end, and 20% are delivered in the `West` end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After making a delivery, a driver goes to the nearest location to make the next
    delivery. This way, the location of a specific driver is determined only by their
    previous location.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - preparing the dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Load the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.2 (2015-08-14).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the data sample. The `c()` function combines arguments to form a vector.
    All the arguments passed to the function are combined to form a common type that
    is the type of the returned value. We will be saving the data to the `RentalStates`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of `RentalStates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 - preparing the dataset](img/image_08_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the matrix. The `matrix()` function creates a matrix from the given
    set of values. The `byrow = T` matrix is filled by rows. `nrow = 3` represents
    the desired number of rows. The `c()` function combines arguments to form a vector.
    All the arguments passed to the function are combined to form a common type that
    is the type of the returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of `RentalTransitionMatrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 - preparing the dataset](img/image_08_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 2 - preparing the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a Markov chain object. The `new()` function creates object of the
    type `markovchain`. States represents the `RentalStates` as defined previously.
    `byrow = T matrix` is filled by rows. The result is then stored in the data frame `mcRental`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `mcRental` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - preparing the model](img/image_08_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Accessing the transition matrix by calling the `mcRental` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - preparing the model](img/image_08_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Ploting the `mcRental` object. `plot()` is a generic function to plot R objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - preparing the model](img/image_08_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating the transition probability. `transitionProbability` `()` provides
    direct access to transition probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - preparing the model](img/image_08_050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - improving the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calculating the probability of being in Downtown in two trips; Downtown to
    Downtown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the probability of going Downtown from the East location; East
    to Downtown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the probability of going Downtown from the West location; West
    to Downtown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Squaring the `mcRental` matrix to calculate the probability, we will be downtown
    in two trips:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Checking the probability that we will be downtown in 20 trips using the `mcRental`
    matrix probability calculation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Checking the probability that we will be downtown in three trips using the
    `mcRental` matrix probability calculation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This method returns the stationary vector in matrix form of a markovchain object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the summary of `mcRental`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Extracting the conditional distribution of the subsequent state, given the
    current state. `mcRental` is the markov chain object that is passed while `"Downtown"`
    is the next state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - improving the model](img/image_08_059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Continuous Markov chains - vehicle service at a gas station
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A gas station has a single pump. There is no space for vehicles to wait. If
    a vehicle arrives at the pump and there is no place the vehicle leaves without
    filling at the pump. Vehicles arrive at the gas station following a Poisson process
    with a rate of 3/20 vehicles per minute. Of the vehicles arriving at the pump,
    75% are cars and 25% are motorcycles. The refueling time can be modeled with an
    exponential random variable with a mean of eight minutes for cars and three minutes
    for motorcycles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform continuous Markov chains for vehicle service at a gas station
    we shall be simulating data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - preparing the dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Load the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.2 (2015-08-14)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing the vehicle arrival rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `ArrivalRate` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 - preparing the dataset](img/image_08_060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Initializing the service rate of the vehicles and create the data sample. The
    `c()` function combines arguments to form a vector. All the arguments passed to
    the function are combined to form a common type that is the type of the returned
    value. We will be saving the data to the `ServiceRate` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `ServiceRate` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 - preparing the dataset](img/image_08_061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Initializing the probability of the arrival of the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a transition matrix. `matrix()` as a function creates a matrix from
    a given set of values. The result is stored in the `TransitionMatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `TransitionMatrix` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 - preparing the dataset](img/image_08_062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Initializing the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 - computing the theoretical resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Solving the linear system of equations. `solve()` is used to compute the linear
    equation. `t(A)` represents the transition matrix while `B` is the vector. The
    result is then stored in `P`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `P` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - computing the theoretical resolution](img/image_08_063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Computing the theoretical resolution. `sum()` computes the sum. The result
    is then stored in `Resolution`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `Resolution` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - computing the theoretical resolution](img/image_08_064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - verifying the convergence of a theoretical solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simulating the system and verify that it converges to a theoretical solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Defining the `option.1` function. A `create_trajectory()` function creates the
    trajectory object of car and motorcycle types. These objects comprise a chain
    of activities that is to be attached to a generator object. Activities for seizing
    the pump object by name are carried out. `amount=1` means the number of objects
    that require to be seized. The `timeout()` function inserts the delays based on
    the user definition. The `timeout()` function also takes in the `rexp()` function
    that randomly generates the exponential distribution with a rate defined as `ServiceRate[1]
    = 1/8` for the `car` object and `ServiceRate[1] = 1/3` for the `motorcycle` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then a simulator object is created as follows. The method initializes a simulation
    environment. The `car` and `motorcycle` objects are created with the exponential
    distribution with the rate defined as `p*ArrivalRate` where `ArrivalRate = 0.15`.
    Then a new generator of arrivals in a simulation environment is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Defining the `option.2` function. Define a single generator for all kinds of
    vehicles and a single trajectory. In order to distinguish between cars and motorcycles,
    define a branch after seizing the resource to select the proper service time.
  prefs: []
  type: TYPE_NORMAL
- en: A `create_trajectory()` function creates the trajectory object of the `vehicle`
    type. This object comprises a chain of activities that is to be attached to a
    generator object. Activities for seizing the pump object by name are carried out.
    `amount=1` means the number of objects that are required to be seized. The `create_trajectory()`
    function then calls the `timeout()` function that inserts the delays based on
    the user definition. The `timeout()` function, also takes in the `rexp()` function
    which randomly generates the exponential distribution with the rate defined as
    `ServiceRate[1] = 1/8` for a car object and `ServiceRate[1] = 1/3` for a `motorcycle`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then a simulator object is created as follows. The method initializes a simulation
    environment. The `car` and `motorcycle` objects are created with the exponential
    distribution with the rate defined as `p*ArrivalRate. ArrivalRate = 0.15`. The
    `run()` function then continues to run until the user-defined time out, as mentioned
    in `until=t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining the `option.3` function. `option.2` adds an unnecessary overhead.
    An additional call is made to select the branch, and therefore performance decreases.
    Select the service time directly inside the `timeout()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the options created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 - plotting the results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Plotting the results. `plot_resource_usage()` is used to plot the usage of
    a resource over the simulation time frame. `gas.station` represents a single simmer
    environment. `"pump"` represents the name of the resource. `items="system"` refers
    to the components of the resource to be plotted. The result is then stored in
    an object of `ggplot2` type graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - plotting the results](img/image_08_065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Monte Carlo simulations - calibrated Hull and White short-rates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monte Carlo simulation is a stochastic simulation of system behavior. The simulation
    uses sampling experiments to be performed on the model and it then conducts numerical
    experiments using the computer to obtain a statistical understanding of the system
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform Monte Carlo simulations for calibrated hull and white short-rates,
    data is taken from sample code that has been shipped with `QuantLib` 0.3.10, market
    data used to construct the term structure of interest rates and swaption volatility
    matrix with corresponding maturities and tenors.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - installing the packages and libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Load the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.2.2 (2015-08-14)'
  prefs: []
  type: TYPE_NORMAL
- en: In order to make part of the `Quantlib` package accessible to the R environment
    `RQuantLib` is used. The `Quantlib` package provides a comprehensive software
    framework for quantitative finance. The goal of the `RQuantLib` is to provide
    source libraries for modeling, trading, sources, either local or remote sources.
    GSPC is assets.
  prefs: []
  type: TYPE_NORMAL
- en: '`type="binary"` indicates the type of package to be downloaded and installed.
    This means that the nature of the package to be installed is not a source package.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - initializing the data and variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Initializing the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of `delta_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - initializing the data and variables](img/image_08_066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Initializing the variables from the sample code integrated with `QuantLib`
    0.3.10\. A list specifying the `tradeDate` (month/day/year), `settleDate`, forward
    rate time span `dt`, and two curve construction options: `interpWhat` (with possible
    values discount, forward, and zero) and `interpHow` (with possible values linear,
    loglinear, and spline). spline here means cubic spline interpolation of the `interpWhat`
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is then stored in the `params` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Initializing the market data. The term structure is constructed for interest
    rates, deposits, and swaps. The result is then stored in `TermQuotes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Initializing the `Swaptionmaturities`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of `SwaptionMaturities`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - initializing the data and variables](img/image_08_067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Initializing the swap tenors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of `SwapTenors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - initializing the data and variables](img/image_08_068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Initializing the volatility matrix. The `matrix()` function creates a matrix
    from the given set of values. `ncol=5` denotes the number of desired of columns.
    `byrow=TRUE` means the matrix is filled by rows. The result is then stored in
    `VolatilityMatrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 - pricing the Bermudan swaptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Price the Bermudan swaption as follows. `BermudanSwaption` is part of the `Quantlib`
    package. This is accessible to the R environment using `RQuantLib`. `BermudanSwaption`
    prices a Bermudan swaption with specified strike and maturity (in years), after
    calibrating the selected short-rate model to an input swaption volatility matrix.
    Swaption maturities and swap tenors are in years. It is assumed that the Bermudan
    swaption is exercisable on each reset date of the underlying swaps. Passing `params`,
    `TermQuotes`, `SwaptionMaturities`, `SwapTenors`, and `VolatilityMatrix` as inputs
    is used to compute Bermudan swaption. The result is stored in `BermudanSwaption`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BermudanSwaption` valuation is displayed. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - pricing the Bermudan swaptions](img/image_08_069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the summary of `BermudanSwaption`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - pricing the Bermudan swaptions](img/image_08_070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Printing the valuations of `BermudanSwaption`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - pricing the Bermudan swaptions](img/image_08_071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - constructing the spot term structure of interest rates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Initializing the vector of times at which to return the discount factors, forward
    rates, and zero rates. Times are specified such that the largest time plus `delta_t`
    does not exceed the longest maturity of the instruments used for calibration (no
    extrapolation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '`DiscountCurve` constructs the spot term structure of interest rates based
    on input market data including the settlement date, deposit rates, and swap rates.
    It returns the corresponding discount factors, zero rates, and forward rates for
    a vector of times that is specified as input. params represents a list that specifies
    the `tradeDate` (month/day/year), `settleDate`, forward rate time span, and two
    curve construction options: `interpWhat` (with possible values discount, forward,
    and zero) and `interpHow` (with possible values `linear`, `loglinear`, and `spline`).
    spline here means cubic spline interpolation of the `interpWhat` value. `TermQuotes`
    represents market quotes to construct the spot term structure of interest rates.
    Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the internal structure of the `DiscountCurve` data frame. The `str()`
    function displays the internal structure of the data frame. The `DiscountCurve`
    is passed as an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - constructing the spot term structure of interest rates](img/image_08_072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding the maturity time at which to return the discount factors, forward
    rates, and zero rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of maturities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - constructing the spot term structure of interest rates](img/image_08_073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding zero coupon rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of zero coupon rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - constructing the spot term structure of interest rates](img/image_08_074.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding discount factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the discount factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - constructing the spot term structure of interest rates](img/image_08_075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - simulating Hull-White short-rates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting the time horizons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the number of simulations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of `sigma`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Simulating Gaussian shocks. `simshocks()` create a simulated version of correlated
    or dependent Gaussian shocks for risk factors. `n = NoSimulations` denotes number
    of simulations. `horizon = 5` means the time horizons. `frequency = monthly`.
    The result is then stored in the `GaussianShocks` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '`simdiff()` makes simulations of diffusion processes. `n = NoSimulations` represents
    the number of independent observations. `frequency = freq` is monthly. `model
    = "OU"` stands for the Ornstein-Uhlenbeck method. `x0 = 0` is the starting value
    of the process. `eps = GaussianShocks` represents Gaussian shocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the forward rates. `ts()` creates time series objects. `replicate(nb.sims,
    DiscountCurve$forwards)` creates a vector of time-series values. `start = start(x)`
    represents the time of the first observation. `deltat = deltat(x)` represents
    the fraction of the sampling period between successive observations. The result
    is then stored in the `ForwardRates` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating regular sequences. `from = 0`, `to = horizon` denotes the starting
    and end values of sequences. `by = delta_t` denotes the increments in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating the short-term rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating stochastic discount values. `r = ShortRates` denotes the short
    term rates, `X = 1` denotes the asset''s price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the mean of stochastic discount values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the values of `MonteCarloPrices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the zero rates of stochastic discount values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the values of `MonteCarloZeroRates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Performing the student t test on the difference between stochastic discount
    terms and market prices. `t.test(x)` performs the t test. `conf.int` means confidence
    interval for the mean appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The `head()` function returns the first part of the `ConfidenceInterval` frame.
    The `ConfidenceInterval` frame is passed as an input parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the graphical parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '`esgplotbands()` plots color bands confidence intervals as follows. `ShortRates`
    represents the confidence interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the **Monte Carlo v/s Market n Zero Rates** as follows. maturities,
    `MonteCarloZeroRates` represents the time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding a sequence of points at the specified coordinates of the plot between
    maturities, `MonteCarloZeroRates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the Monte Carlo v/s Market Prices as follows. maturities, `MonteCarloPrices`
    represents the time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding a sequence of points at the specified coordinates of the plot between
    maturities, `MonteCarloPrices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 5 - simulating Hull-White short-rates](img/image_08_085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
