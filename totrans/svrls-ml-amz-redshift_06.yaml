- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building Classification Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建分类模型
- en: In this chapter, you will learn about classification algorithms used in **machine**
    **learning** (**ML**). You will learn about the various methods that Redshift
    offers when you create classification models. This chapter will provide detailed
    examples of both **binary** and **multi-class classification models** and show
    you how to solve business problems with these modeling techniques. By the end
    of this chapter, you will be in a position to identify whether a business problem
    is a classification or not, identify the right method that Redshift offers in
    training, and build a model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解在 **机器学习**（**ML**）中使用的分类算法。你将了解 Redshift 在创建分类模型时提供的各种方法。本章将提供二元和**多类别分类模型**的详细示例，并展示如何使用这些建模技术解决业务问题。到本章结束时，你将能够确定一个业务问题是否为分类问题，确定
    Redshift 在训练中提供的正确方法，并构建模型。
- en: 'In this chapter, we will go through the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要内容：
- en: An introduction to classification algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类算法简介
- en: Creating a model syntax with user guidance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有用户指导的模型语法
- en: Training a binary classification model using the XGBoost algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XGBoost 算法训练二元分类模型
- en: Training a multi-class classification model using the Linear Learner model type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线性学习器模型类型训练多类别分类模型
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires a web browser and access to the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要网络浏览器以及访问以下内容：
- en: An AWS account
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 账户
- en: An Amazon Redshift Serverless endpoint
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Amazon Redshift 无服务器端点
- en: Amazon Redshift Query Editor v2
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Redshift 查询编辑器 v2
- en: Completing the *Getting started with Amazon Redshift Serverless* section in
    [*Chapter 1*](B19071_01.xhtml#_idTextAnchor015)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成 [*第 1 章*](B19071_01.xhtml#_idTextAnchor015) 中的 *Amazon Redshift 无服务器入门* 部分
- en: 'You can find the code used in this chapter here: [https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章使用的代码：[https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/).
- en: An introduction to classification algorithms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类算法简介
- en: '**Classification** is the process of categorizing any kind of entity or class
    so that it is better understood and analyzed. The classifying process usually
    happens as part of a pre-setup business process (for example, tagging a product
    as defective or good after observing it), or through a return process (for example,
    tagging a product as defective after the customer returned it as defective). In
    either event, the important point is classifying an entity – in this case, a product
    into a class (i.e., defective or not).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类**是将任何实体或类别进行分类的过程，以便更好地理解和分析。分类过程通常作为预设置的业务流程的一部分发生（例如，在观察产品后将其标记为有缺陷或良好），或通过退货流程（例如，在客户将产品退回为有缺陷后将其标记为有缺陷）。在任何情况下，重要的是对实体进行分类——在这种情况下，将产品分类到类别中（即，有缺陷或无缺陷）。'
- en: '*Figure 6**.1* shows data that has been classified into two classes using three
    input variables. The figure shows where a pair of **Input** and **Output** data
    points are categorized into two classes. When output labels consist of only two
    classes, it is called a **binary** **classification** problem:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.1* 展示了使用三个输入变量被分类到两个类别的数据。该图显示了**输入**和**输出**数据点被分类到两个类别的情况。当输出标签只包含两个类别时，它被称为**二元**
    **分类**问题：'
- en: '![Figure 6.1 – Binary classification](img/B19071_06_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 二元分类](img/B19071_06_01.jpg)'
- en: Figure 6.1 – Binary classification
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 二元分类
- en: 'If the output variable consists of more than two classes – for example, predicting
    whether a fruit is an apple, an orange, or a pear – then it is called **multi-class
    classification**. *Figure 6**.2* shows data that has been classified into multiple
    classes based on a set of three input variables. The figure shows a multi-class
    classification chart, illustrating how input and output pairs are classified into
    three classes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出变量包含两个以上的类别——例如，预测一个水果是苹果、橙子还是梨——那么它被称为**多类别分类**。*图 6.2* 展示了基于三个输入变量被分类到多个类别的数据。该图显示了一个多类别分类图，说明了输入和输出对如何被分类到三个类别：
- en: '![Figure 6.2 – Multi-class classification](img/B19071_06_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 多类别分类](img/B19071_06_02.jpg)'
- en: Figure 6.2 – Multi-class classification
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 多类别分类
- en: The classification process can also happen on data that does not have classes
    defined yet. Let us continue to understand how this is possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 分类过程也可以发生在尚未定义类别的数据上。让我们继续了解这是如何可能的。
- en: It is not always the case that your entities are grouped or categorized in a
    certain way. For example, if you want to analyze your customers’ purchase history
    or clickstream activity, or if you want to group similar customers based on demographics
    or shopping behavior, then classification algorithms come in handy to analyze
    the data and group similar data points into clusters. This type of classification
    modeling is called **unsupervised learning**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是您的实体以某种方式分组或分类。例如，如果您想分析客户的购买历史或点击流活动，或者如果您想根据人口统计或购物行为将类似客户分组，那么分类算法就派上用场，用于分析数据并将相似数据点聚类。这种类型的分类建模称为
    **无监督学习**。
- en: Establishing classes helps the analysis process – for example, once products
    are tagged to a class label, you can easily retrieve a list of defective products
    that are returned and then further study the characteristics, such as store location,
    the demographics of the customer who returned the product, and the season when
    a product was returned most. How and when classes are defined and established
    enables businesses to conduct a deep-dive analysis, not only answering questions
    such as where and what but also training an ML model on historical data and classes,
    and predicting which class an entity will fall into.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 建立类别有助于分析过程——例如，一旦产品被标记为某个类别标签，您就可以轻松检索出退货的次品产品列表，然后进一步研究其特征，例如商店位置、退货产品的客户的
    demographics 以及产品退货最多的季节。如何以及何时定义和建立类别，使企业能够进行深入分析，不仅回答诸如在哪里和什么的问题，而且还在历史数据和类别上训练
    ML 模型，并预测实体将落入哪个类别。
- en: 'Common use cases where classification models are useful include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的分类模型有用武之地的场景包括以下几种：
- en: Customer behavior prediction
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户行为预测
- en: Document or image classification
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档或图像分类
- en: Spam filtering
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防垃圾邮件过滤
- en: In this chapter, we will show you how to create different classification models
    that Redshift offers you. Amazon Redshift provides **XGBoost**, **multilayer perceptron**
    (**MLP**), and **Linear Learner algorithms** to train and build a classification
    model.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何创建 Redshift 提供的不同分类模型。Amazon Redshift 提供了 **XGBoost**、**多层感知器**（**MLP**）和
    **线性学习器算法**来训练和构建分类模型。
- en: In this chapter, you will begin the journey of learning about supervised classification
    models by building binary classification models, using XGBoost, and a multi-class
    classification model, using linear learner. MLP models will be covered in [*Chapter
    9*](B19071_09.xhtml#_idTextAnchor157), whereas unsupervised classification modeling
    will be covered in [*Chapter 8*](B19071_08.xhtml#_idTextAnchor139).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将通过构建二元分类模型开始学习监督分类模型，使用 XGBoost 和使用线性学习器的多类别分类模型。MLP 模型将在 [*第 9 章*](B19071_09.xhtml#_idTextAnchor157)
    中介绍，而无监督分类建模将在 [*第 8 章*](B19071_08.xhtml#_idTextAnchor139) 中介绍。
- en: Now, we will walk you through the detailed syntax of creating models with Redshift
    ML.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向您详细介绍使用 Redshift ML 创建模型的详细语法。
- en: Diving into the Redshift CREATE MODEL syntax
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解 Redshift 的 CREATE MODEL 语法
- en: In [*Chapter 4*](B19071_04.xhtml#_idTextAnchor057)*,* we saw different variations
    of the Redshift `CREATE MODEL` command and how a data analyst, citizen data scientist,
    or data scientist can operate the `CREATE MODEL` command, with varying degrees
    of complexity. In this section, we will introduce you to a citizen data scientist
    persona, who is not fully aware of statistics but has good knowledge about identifying
    what algorithm to use and what problem type can be applied to a business problem.
    In the Redshift ML world, this type of model creation is known as **CREATE MODEL
    with** **user guidance**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B19071_04.xhtml#_idTextAnchor057) 中，我们看到了 Redshift `CREATE MODEL`
    命令的不同变体以及数据分析师、公民数据科学家或数据科学家如何以不同复杂度操作 `CREATE MODEL` 命令。在本节中，我们将向您介绍一个公民数据科学家角色，他并不完全了解统计学，但对识别要使用的算法和可以将哪种问题类型应用于业务问题有很好的了解。在
    Redshift ML 世界中，这种类型的模型创建被称为 **带有用户指导的** **CREATE MODEL**。
- en: We are going to explore the model type and problem type parameters of the `CREATE
    MODEL` statement. As part of *CREATE MODEL with user guidance*, you also have
    the option of setting a preprocessor, but we will leave that topic for [*Chapter
    10*](B19071_10.xhtml#_idTextAnchor178).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前文所述，我们将探索`CREATE MODEL`语句中的模型类型和问题类型参数。作为`CREATE MODEL with user guidance`的一部分，您还可以选择设置一个预处理程序，但我们将把这个话题留到[*第10章*](B19071_10.xhtml#_idTextAnchor178)中。
- en: As an ML model creator, you will decide what algorithm to use and what problem
    type to address. Redshift ML still performs the feature engineering of independent
    variables behind the scenes. For example, out of 20 features, Redshift ML will
    automatically identify the categorical variables and numeric variables and create
    one-hot-encoded value or standardization of numerical variables where applicable,
    along with various other tasks required to complete the model training.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为ML模型创建者，您将决定使用哪种算法以及解决哪种问题类型。Redshift ML仍然在幕后执行独立变量的特征工程。例如，在20个特征中，Redshift
    ML将自动识别分类变量和数值变量，并在适用的情况下创建单热编码值或数值变量的标准化，以及完成模型训练所需的各种其他任务。
- en: In summary, you let Redshift ML handle the bulk of data preparation tasks for
    ML. As a model creator, you come up with an algorithm to be used and a problem
    type to be solved. By preselecting an algorithm type and problem type, Redshift
    ML will reduce the training type, as it trains the model on other algorithms and
    problem types. Compared to the full `AUTO` CREATE MODEL statement that we created
    in [*Chapter 5*](B19071_05.xhtml#_idTextAnchor068), *CREATE MODEL with user guidance*
    takes less time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，您让Redshift ML处理大部分数据准备任务。作为模型创建者，您提出要使用的算法和要解决的问题类型。通过预选算法类型和问题类型，Redshift
    ML将减少训练类型，因为它将在其他算法和问题类型上训练模型。与我们在[*第5章*](B19071_05.xhtml#_idTextAnchor068)中创建的完整`AUTO`
    `CREATE MODEL`语句相比，*带有用户指导的CREATE MODEL*需要更少的时间。
- en: As mentioned in the previous section, we will use the XGBoost algorithm for
    binary classification and the linear learner algorithm for multi-class classification.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，我们将使用XGBoost算法进行二元分类，使用线性学习器算法进行多类分类。
- en: 'You can learn more about XGBoost here: [https://docs.aws.amazon.com/sagemaker/latest/dg/XGBoost.html](https://docs.aws.amazon.com/sagemaker/latest/dg/XGBoost.html).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多关于XGBoost的信息：[https://docs.aws.amazon.com/sagemaker/latest/dg/XGBoost.html](https://docs.aws.amazon.com/sagemaker/latest/dg/XGBoost.html)。
- en: 'And you can learn more about Linear Learner here: [https://docs.aws.amazon.com/sagemaker/latest/dg/linear-learner.html](https://docs.aws.amazon.com/sagemaker/latest/dg/linear-learner.html).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在以下链接中了解更多关于Linear Learner的信息：[https://docs.aws.amazon.com/sagemaker/latest/dg/linear-learner.html](https://docs.aws.amazon.com/sagemaker/latest/dg/linear-learner.html)。
- en: Using a simple `CREATE MODEL` statement, Redshift ML will use SageMaker Autopilot
    to automatically determine the problem type, algorithm, and the best model type
    to use.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的`CREATE MODEL`语句，Redshift ML将使用SageMaker Autopilot自动确定问题类型、算法以及最佳模型类型。
- en: 'With Redshift ML, you can influence a model by providing user guidance. You
    can choose `model_type`, `problem_type`, and `objective` when you issue the `CREATE
    MODEL` statement. You can find more details on the syntax and options here: [https://docs.aws.amazon.com/redshift/latest/dg/r_create_model_use_cases.html](https://docs.aws.amazon.com/redshift/latest/dg/r_create_model_use_cases.html).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Redshift ML，您可以通过提供用户指导来影响模型。当您发出`CREATE MODEL`语句时，您可以选择`model_type`、`problem_type`和`objective`。您可以在以下链接中找到关于语法和选项的更多详细信息：[https://docs.aws.amazon.com/redshift/latest/dg/r_create_model_use_cases.html](https://docs.aws.amazon.com/redshift/latest/dg/r_create_model_use_cases.html)。
- en: So far, we have discussed the basics of the Redshift ML `CREATE MODEL` syntax
    and how you can provide guidance, such as model type and objective, or choose
    to let Redshift ML automatically choose these for you.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Redshift ML `CREATE MODEL`语法的基础知识以及您如何提供指导，例如模型类型和目标，或者选择让Redshift
    ML自动为您选择这些。
- en: Now, you will learn how to create a binary classification model and specify
    the XGBoost algorithm.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将学习如何创建一个二元分类模型并指定XGBoost算法。
- en: Training a binary classification model using the XGBoost algorithm
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XGBoost算法训练二元分类模型
- en: 'Binary classification models are used to solve the problem of predicting one
    class of two possible classes – for example, predicting whether it will rain or
    not. The goal is to learn about past data points and figure out which one of the
    target buckets a particular data point will fall into. The typical use cases of
    a binary classification model are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 二分类模型用于解决预测两个可能类别中的一个类别的问题——例如，预测是否会下雨。目标是了解过去的数据点，并确定特定数据点将落入哪个目标桶中。二分类模型的典型用例如下：
- en: Predicting whether a patient suffers from a disease
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测患者是否患有疾病
- en: Predicting whether a customer will churn or not
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测客户是否会流失
- en: Predicting behavior – for example, whether a customer will file an appeal or
    not
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测行为——例如，客户是否会提出上诉
- en: 'In the next few sections, we will go through the following steps to achieve
    our goal of creating a binary classification model to be used to run inference
    queries:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将通过以下步骤来实现创建用于运行推理查询的二分类模型的目标：
- en: Defining the business problem
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义业务问题
- en: Uploading and analyzing data
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传和分析数据
- en: Creating the model
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模型
- en: Running prediction queries against the model
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对模型运行预测查询
- en: Establishing the business problem
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确立业务问题
- en: To build our binary classification problem, we will take a look at a banking
    campaign issue. Banks spend a lot of money on marketing campaigns targeted toward
    their customers so that they will subscribe to their products. It is very important
    that banks build efficiency into their campaign, and this can be done by learning
    the last campaign dataset and predicting future campaign results. We will work
    on predicting whether a banking customer will subscribe to a banking product offer
    of a term deposit.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的二分类问题，我们将研究一个银行营销问题。银行在针对客户的营销活动中投入了大量资金，以便他们订阅其产品。银行在营销活动中建立效率非常重要，这可以通过学习最后的市场营销数据集并预测未来的营销结果来实现。我们将致力于预测银行客户是否会订阅银行产品的定期存款优惠。
- en: Uploading and analyzing the data
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传和分析数据
- en: We are going to work on a bank marketing dataset in this section. The data is
    related to direct marketing campaigns of a Portuguese banking institution. Imagine
    you are a marketing analyst and your goal is to increase the amount of deposits
    by offering a term deposit to your customers. It is very important that marketing
    campaigns target customers appropriately. You will create a model using Redshift
    ML to predict whether a customer is likely to accept the term deposit offer. This
    dataset is sourced from [https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究一个银行营销数据集。这些数据与葡萄牙一家银行的直接营销活动相关。想象一下，你是一名营销分析师，你的目标是通过对客户提供定期存款来增加存款额。确保营销活动针对适当的客户是非常重要的。你将使用Redshift
    ML创建一个模型，以预测客户是否可能接受定期存款的优惠。此数据集来源于[https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing)。
- en: Dataset citation
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集引用
- en: '[Moro et al., 2014] S. Moro, P. Cortez and P. Rita. *A Data-Driven Approach
    to Predict the Success of Bank Telemarketing. Decision Support Systems*, Elsevier,
    62:22–31, June 2014'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[Moro等人，2014] S. Moro, P. Cortez 和 P. Rita. *基于数据驱动的银行电话营销成功率预测方法*，《决策支持系统》，Elsevier，62:22–31，2014年6月'
- en: The classification goal is to predict whether the client will subscribe (yes/no)
    to a term deposit (the *y* variable).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 分类目标是预测客户是否会（是/否）订阅定期存款（*y*变量）。
- en: The dataset has columns such as age, job, marital status, education level, and
    employment status.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集包含诸如年龄、工作、婚姻状况、教育水平和就业状况等列。
- en: 'Metadata about these columns can also be found at the UCI ML repository website
    here: [https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列的元数据也可以在UCI ML仓库网站上找到：[https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing)。
- en: As you can see from the preceding link, there are 20 independent variables and
    1 dependent variable (*y*). We can use any or all of these independent variables
    as input to our `CREATE MODEL` statement to be able to predict the outcome, *y*,
    which indicates whether the customer is likely to accept the offer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述链接所示，有20个独立变量和1个因变量（*y*）。我们可以将这些独立变量中的任何一个或全部作为`CREATE MODEL`语句的输入，以便预测结果，*y*表示客户是否可能接受该优惠。
- en: 'After successfully connecting to Redshift as an admin or database developer,
    create the schema and load data into Amazon Redshift using the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功连接到 Redshift 作为管理员或数据库开发者后，按照以下步骤创建模式并将数据加载到 Amazon Redshift 中：
- en: Navigate to Redshift **query editor v2**, and connect to the **Serverless**
    endpoint and the **dev** database.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 Redshift **查询编辑器 v2**，并连接到 **无服务器** 端点和 **dev** 数据库。
- en: Rename the `Chap6`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名 `Chap6`。
- en: 'The following screenshot shows the serverless connection, the database set
    to **dev**, and the query editor page saved as **Chap6**:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了无服务器连接，数据库设置为 **dev**，查询编辑器页面保存为 **Chap6**：
- en: "![Figure 6.3 – Query Editor \uFEFFv2](img/B19071_06_03.jpg)"
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – Query Editor v2](img/B19071_06_03.jpg)'
- en: Figure 6.3 – Query Editor v2
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – Query Editor v2
- en: 'Now, using the following line of code, create the schema. This schema is where
    all the tables and data needed for this chapter will be created and maintained:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码行创建模式。此模式是创建和维持本章所需的所有表和数据的地方：
- en: '[PRE0]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will see output like this, indicating that your schema is created:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下输出，表示你的模式已创建：
- en: '![Figure 6.4 – Schema created](img/B19071_06_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 创建的模式](img/B19071_06_04.jpg)'
- en: Figure 6.4 – Schema created
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 创建的模式
- en: 'The following code will create the `bank_details_training` table to store data
    to train the model, and the `bank_details_inference` table to store data to run
    the inference queries. Note that we have already split our input dataset into
    these two datasets for you. All of the SQL commands used in this chapter can be
    found here: [https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter6/chapter6.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter6/chapter6.sql).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将创建 `bank_details_training` 表以存储用于训练模型的数据，以及 `bank_details_inference` 表以存储用于运行推理查询的数据。请注意，我们已经将我们的输入数据集分割成这两个数据集供你使用。本章中使用的所有
    SQL 命令都可以在这里找到：[https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter6/chapter6.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter6/chapter6.sql)。
- en: 'Run the following code from GitHub to create the training and inference tables
    in Query Editor v2:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub 运行以下代码以在 Query Editor v2 中创建训练和推理表：
- en: '[PRE1]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will see output like this to verify that your tables have been created
    successfully:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下输出以验证你的表已成功创建：
- en: '![Figure 6.5 – Tables created successfully](img/B19071_06_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 成功创建的表](img/B19071_06_05.jpg)'
- en: Figure 6.5 – Tables created successfully
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 成功创建的表
- en: Now that you have created the tables, run the commands in *step 5* using Query
    Editor v2 to load the data, using the S3 buckets provided.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了表，请使用 Query Editor v2 运行 *步骤 5* 中的命令来加载数据，使用提供的 S3 存储桶。
- en: 'Load the sample data into the tables created in *step 4* by using the following
    command, which can be found on GitHub. Note that we use the `COPY` command to
    load this data from Amazon S3:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将样本数据加载到在 *步骤 4* 中创建的表中，该命令可在 GitHub 上找到。请注意，我们使用 `COPY` 命令从 Amazon S3
    加载数据：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Analyze the customer term deposit subscription table by creating a histogram
    chart. First, run the following command again using Query Editor v2:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建直方图图表分析客户定期存款订阅表。首先，再次使用 Query Editor v2 运行以下命令：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can see in the result set that **36548** customers did not choose the bank’s
    offer and **4640** did accept. You can also use the chart feature in Query Editor
    v2 to create a bar chart. Click on the **Chart** option found on the right-hand
    side in the **Result** pane:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在结果集中看到，**36548** 名客户没有选择银行的优惠，而 **4640** 名客户接受了。你还可以使用 Query Editor v2 中的图表功能创建条形图。在
    **结果** 面板右侧点击 **图表** 选项：
- en: '![Figure 6.6 – The subscription results and the Chart option](img/B19071_06_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 订阅结果和图表选项](img/B19071_06_06.jpg)'
- en: Figure 6.6 – The subscription results and the Chart option
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 订阅结果和图表选项
- en: 'You will get the following result after choosing **Bar** for **Type**, **y**
    for the **X** value, and **customer_count** for the **Y** value:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **类型** 为 **条形图**，**X** 值为 **y**，**Y** 值为 **customer_count** 后，你将得到以下结果：
- en: '![Figure 6.7 – A chart of customer acceptance](img/B19071_06_07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 客户接受度图表](img/B19071_06_07.jpg)'
- en: Figure 6.7 – A chart of customer acceptance
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 客户接受度图表
- en: Now that we have our data loaded, we can create our model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载数据，我们可以创建我们的模型。
- en: Using XGBoost to train a binary classification model
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 XGBoost 训练二元分类模型
- en: In this section, you will specify `MODEL_TYPE` and `PROBLEM_TYPE` to create
    a binary classification model using the XGBoost algorithm. We will now address
    the banking campaign problem. The goal of this model is to predict whether a customer
    will subscribe to a term deposit or not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将指定`MODEL_TYPE`和`PROBLEM_TYPE`以使用XGBoost算法创建一个二元分类模型。我们现在将讨论银行营销活动问题。该模型的目标是预测客户是否会订阅定期存款。
- en: We will set `MODEL_TYPE` as `XGBoost` and `PROBLEM_TYPE` as `BINARY_CLASSIFICATION`.
    We will use the default `IAM_ROLE`. We also need to specify the S3 bucket where
    the model artifacts will be stored and, additionally, set `MAX_RUNTIME` to `3600`
    (in seconds).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`MODEL_TYPE`设置为`XGBoost`，将`PROBLEM_TYPE`设置为`BINARY_CLASSIFICATION`。我们将使用默认的`IAM_ROLE`。此外，我们还需要指定模型工件将存储的S3桶，并且另外设置`MAX_RUNTIME`为`3600`（秒）。
- en: 'The following is the code to create the model. You will find the complete code
    along with all the SQL commands needed for the chapter at [https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/chapter6.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/chapter6.sql):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建模型编写的代码。您将在[https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/chapter6.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/chapter6.sql)找到完整的代码以及本章所需的全部SQL命令：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By setting `MODEL_TYPE` to `XGBoost` and `PROBLEM_TYPE` to `BINARY_CLASSIFICATION`,
    we guide Redshift ML to only search for the best XGBoost model in this training
    run. If this is left as default, Redshift ML checks whether other classification
    models can be applied to the dataset.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`MODEL_TYPE`设置为`XGBoost`并将`PROBLEM_TYPE`设置为`BINARY_CLASSIFICATION`，我们指导Redshift
    ML仅在这次训练运行中搜索最佳的XGBoost模型。如果保留为默认值，Redshift ML将检查是否可以将其他分类模型应用于数据集。
- en: Since the **SageMaker AutoPilot algorithm** does not have to test other model
    types or determine the problem type, the end result will be less training time.
    In this example, SageMaker Autopilot takes care of selecting the objective type,
    adjusting hyperparameters, and handling the data preprocessing steps.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**SageMaker AutoPilot算法**无需测试其他模型类型或确定问题类型，因此最终结果将减少训练时间。在本例中，SageMaker Autopilot负责选择目标类型、调整超参数和处理数据预处理步骤。
- en: 'To check the status of the model, run the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查模型的状态，请运行以下命令：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will get the following result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下结果：
- en: '![Figure 6.8 – Showing the model output](img/B19071_06_08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 显示模型输出](img/B19071_06_08.jpg)'
- en: Figure 6.8 – Showing the model output
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 显示模型输出
- en: From the preceding screenshot, we can see that the model is still under training.
    Also, note that Redshift ML picks up the `CREATE MODEL` statement. Other parameters,
    such as the objective, hyperparameters, and preprocessing, are still auto-handled
    by Redshift ML.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图可以看出，模型仍在训练中。此外，请注意Redshift ML拾取了`CREATE MODEL`语句。其他参数，如目标、超参数和预处理，仍然由Redshift
    ML自动处理。
- en: The **predict_term_deposit** parameter under **Function Name** is used to generate
    predictions, which we will use in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在**函数名称**下的**predict_term_deposit**参数用于生成预测，我们将在下一节中使用它。
- en: 'Run the `SHOW MODEL` command again after some time to check whether model training
    is complete. From the following screenshot, you can see that **Model State** is
    **READY** and **F1** has been selected as the objective for model evaluation.
    The **F1** score is **0.646200**, or 64%. The closer this number is to 1, the
    better the model score:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间后再次运行`SHOW MODEL`命令，以检查模型训练是否完成。从以下屏幕截图可以看出，**模型状态**为**就绪**，并且**F1**已被选为模型评估的目标。**F1**分数为**0.646200**，或64%。这个数字越接近1，模型分数就越好：
- en: '![Figure 6.9 – Showing the model output](img/B19071_06_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 显示模型输出](img/B19071_06_09.jpg)'
- en: Figure 6.9 – Showing the model output
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 显示模型输出
- en: 'Let’s run the following query against our training data to validate the F1
    score:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们针对我们的训练数据运行以下查询以验证F1分数：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can see in the following output that our accuracy is very good at almost
    94%:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下输出中看到，我们的准确度非常好，接近94%：
- en: '![Figure 6.10 – The accuracy results](img/B19071_06_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 准确度结果](img/B19071_06_10.jpg)'
- en: Figure 6.10 – The accuracy results
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 准确度结果
- en: Now that the model training is complete, we will use the function created to
    run prediction queries.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型训练已完成，我们将使用创建的函数来运行预测查询。
- en: Running predictions
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行预测
- en: 'Let us run some predictions on our inference dataset to see how many customers
    are predicted to subscribe to the term deposit. Run the following SQL statement
    in Query Editor v2:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的推理数据集上运行一些预测，以查看有多少客户被预测为订阅定期存款。在Query Editor v2中运行以下SQL语句：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should get the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 6.11 – Prediction results](img/B19071_06_11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 预测结果](img/B19071_06_11.jpg)'
- en: Figure 6.11 – Prediction results
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 预测结果
- en: We can see that **642** customers are predicted to accept the offer to subscribe
    to the term deposit, and **3477** are predicted to not accept the offer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到**642**名客户被预测为会接受定期存款订阅的报价，而**3477**名客户被预测为不会接受报价。
- en: Prediction probabilities
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测概率
- en: 'Amazon Redshift ML now provides the capability to get the probability of a
    prediction for binary and multi-class classification problems. Note that in the
    output of the `SHOW MODEL` command in *Figure 6**.9*, an additional function name
    has been created called `predict_term_deposit_prob`. Run the following query to
    check the probability that married customers with management jobs and between
    35 and 45 years of age will accept the term deposit offer:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Redshift ML现在提供了获取二元和多类分类问题预测概率的能力。请注意，在*图6*.9的`SHOW MODEL`命令输出中，已创建一个名为`predict_term_deposit_prob`的附加函数名。运行以下查询以检查已婚且从事管理工作且年龄在35至45岁之间的客户接受定期存款报价的概率：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see the following results:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下结果：
- en: '![Figure 6.12 – Probability results](img/B19071_06_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – 概率结果](img/B19071_06_12.jpg)'
- en: Figure 6.12 – Probability results
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 概率结果
- en: You can see in the first row a **0.99985629** probability of a *false* prediction
    and only a **0.00014372** probability of a *true* prediction.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到第一行有一个**0.99985629**的**错误**预测概率，以及只有**0.00014372**的**正确**预测概率。
- en: 'You can also modify the preceding query to see the probability of the customers
    that are predicted to accept the term deposit offer. Run the following SQL command
    in Query Editor v2:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以修改前面的查询以查看被预测为接受定期存款报价的客户概率。在Query Editor v2中运行以下SQL命令：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will see similar results as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下类似的结果：
- en: '![Figure 6.13 – The probability results for customers accepting the term offer](img/B19071_06_13.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13 – 客户接受条款报价的概率结果](img/B19071_06_13.jpg)'
- en: Figure 6.13 – The probability results for customers accepting the term offer
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – 客户接受条款报价的概率结果
- en: 'In [*Chapter 5*](B19071_05.xhtml#_idTextAnchor068), you learned how to determine
    feature importance by running an explainability report. Run the following query
    to see which inputs contributed most to the model prediction:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B19071_05.xhtml#_idTextAnchor068)中，您学习了如何通过运行可解释性报告来确定特征重要性。运行以下查询以查看哪些输入对模型预测贡献最大：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Take the result and copy it to the editor so that it is easier to read, as
    shown in *Figure 6**.14*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果复制到编辑器中，以便更容易阅读，如图*6*.14所示：
- en: '![Figure 6.14 – The explainability report](img/B19071_06_14.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 可解释性报告](img/B19071_06_14.jpg)'
- en: Figure 6.14 – The explainability report
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 可解释性报告
- en: This shows that `pdays` has the most importance and that `poutcome` has the
    least.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`pdays`的重要性最高，而`poutcome`的重要性最低。
- en: Now that you have built a binary classification model, let us move on and try
    building a multi-class classification model.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经构建了一个二元分类模型，让我们继续尝试构建一个多类分类模型。
- en: Training a multi-class classification model using the Linear Learner model type
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线性学习模型类型训练多类分类模型
- en: In this section, you will learn how to build a multi-class classification model
    in Amazon Redshift ML using the linear learner algorithm.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用线性学习算法在Amazon Redshift ML中构建多类分类模型。
- en: 'To do this, we will use a customer segmentation dataset from Kaggle: [https://www.kaggle.com/datasets/vetrirah/customer](https://www.kaggle.com/datasets/vetrirah/customer).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用来自Kaggle的客户细分数据集：[https://www.kaggle.com/datasets/vetrirah/customer](https://www.kaggle.com/datasets/vetrirah/customer)。
- en: You will use this dataset to train a model to classify customers into one of
    four segments (`A`, `B`, `C`, or `D`). By segmenting customers, you can better
    understand the customer and do targeted marketing to customers, with product offerings
    that are relevant to them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用此数据集来训练一个模型，将客户分类到四个细分市场之一（`A`、`B`、`C`或`D`）。通过细分客户，您可以更好地了解客户，并对他们进行有针对性的营销，提供与他们相关的产品。
- en: 'Our data has already been split into training and testing sets and is stored
    in the following S3 locations:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据已经分为训练集和测试集，并存储在以下 S3 位置：
- en: '`s3://packt-serverless-ml-redshift/chapter06/segmentation/train.csv`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s3://packt-serverless-ml-redshift/chapter06/segmentation/train.csv`'
- en: '`s3://packt-serverless-ml-redshift/chapter06/segmentation/test.csv`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s3://packt-serverless-ml-redshift/chapter06/segmentation/test.csv`'
- en: 'After successfully connecting to Redshift as an admin or database developer,
    load data into Amazon Redshift as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功连接到 Redshift 作为管理员或数据库开发者后，按照以下方式将数据加载到 Amazon Redshift 中：
- en: Navigate to Redshift **query editor v2**, and connect to the **Serverless**
    endpoint and the **dev** database.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 Redshift **查询编辑器 v2**，并连接到 **无服务器** 端点和 **dev** 数据库。
- en: Use the same schema and query editor page you created for the binary classification
    exercise (see the *Uploading and analyzing the* *data* section).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用为二进制分类练习创建的相同模式和查询编辑器页面（见 *上传和分析数据* 部分）。
- en: Create the train and test tables and load the data using the following SQL commands
    in Query Editor v2\. These SQL commands can be found at
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 SQL 命令在 Query Editor v2 中创建训练表和测试表并加载数据。这些 SQL 命令可以在
- en: '[https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter6/chapter6.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter6/chapter6.sql):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter6/chapter6.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter6/chapter6.sql):'
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that the data has loaded, let’s do some analysis of our training data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经加载，让我们对我们的训练数据进行一些分析。
- en: 'Analyze the training data by executing the following SQL command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下 SQL 命令分析训练数据：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should get the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 6.15 – Segmentation](img/B19071_06_15.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 分割](img/B19071_06_15.jpg)'
- en: Figure 6.15 – Segmentation
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 分割
- en: Our training dataset has a total of 8,068 customer records. From this sample,
    we can see that segments **C**, **B**, and **A** are very similar and that more
    customers are in segment **D**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的训练数据集总共有 8,068 条客户记录。从这个样本中，我们可以看到细分 **C**、**B** 和 **A** 非常相似，并且更多客户位于细分
    **D** 中。
- en: We will use the input from the training dataset to predict the customer segment,
    using the linear learner algorithm.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用训练数据集的输入来预测客户细分，使用线性学习器算法。
- en: Using Linear Learner to predict the customer segment
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用线性学习器预测客户细分
- en: '**Linear learner** is a supervised learning algorithm and one of the model
    types you can use to solve classification or regression problems.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性学习器**是一种监督学习算法，是您可以使用来解决分类或回归问题的模型类型之一。'
- en: For multi-class classification problems, we have more than two labels (or targets)
    that we will try to predict, compared to exactly two labels for binary classification
    problems. We will show you how to use linear learner to solve regression problems
    in [*Chapter 7*](B19071_07.xhtml#_idTextAnchor111).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多类分类问题，与二进制分类问题的确切两个标签相比，我们将尝试预测的标签（或目标）超过两个。我们将向您展示如何使用线性学习器在 [*第 7 章*](B19071_07.xhtml#_idTextAnchor111)
    中解决回归问题。
- en: With linear learner, you can achieve a significant increase in speed compared
    to traditional hyperparameter optimization techniques, making it very convenient.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性学习器，与传统的超参数优化技术相比，你可以实现速度的显著提升，这使得它非常方便。
- en: We will provide a training set with data that contains our input or observations
    about the data, and the label that represents the value we want to predict. We
    can optionally provide certain combinations of preprocessors to certain sets of
    columns.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一个包含我们的输入或关于数据的观察以及代表我们想要预测的值的标签的训练集。我们可以选择性地为某些列的组合提供预处理器。
- en: In this section, you will apply user guidance techniques by providing `MODEL_TYPE`,
    `PROBLEM_TYPE`, and `OBJECTIVE` to create a multi-class classification model using
    the linear learner algorithm. The goal of this model is to predict the segment
    for each customer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将通过提供 `MODEL_TYPE`、`PROBLEM_TYPE` 和 `OBJECTIVE` 来应用用户指导技术，使用线性学习器算法创建一个多类分类模型。该模型的目标是预测每个客户的细分。
- en: We will set `MODEL_TYPE` as `LINEAR_LEARNER` and `PROBLEM_TYPE` as `MULTICLASS_CLASSIFICATION`.
    We will leave other options as default.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置 `MODEL_TYPE` 为 `LINEAR_LEARNER` 和 `PROBLEM_TYPE` 为 `MULTICLASS_CLASSIFICATION`。我们将其他选项保留为默认设置。
- en: 'Let us execute the following code in Query Editor v2 to train the model:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Query Editor v2 中执行以下代码来训练模型：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To check the status of the model, run the following command in Query Editor
    v2:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查模型的状态，请在Query Editor v2中运行以下命令：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should get the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 6.16 – Showing the model output](img/B19071_06_16.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16 – 显示模型输出](img/B19071_06_16.jpg)'
- en: Figure 6.16 – Showing the model output
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 显示模型输出
- en: You can see that the model is now in the `CREATE` `MODEL` statement.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到模型现在在`CREATE` `MODEL`语句中。
- en: Now that the model is trained, it is time to evaluate its quality.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型已经训练好了，是时候评估其质量了。
- en: Evaluating the model quality
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估模型质量
- en: When you issue the `CREATE MODEL` command, Amazon SageMaker will automatically
    divide your data into testing and training in the background so that it can determine
    the accuracy of the model. If you look at the `validation:multiclass_accuracy`
    key from the `SHOW MODEL` output, you will see a value of **0.535028**, which
    means our model can correctly pick the segment 53% of the time. Ideally, we prefer
    a value closer to 1.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发出`CREATE MODEL`命令时，Amazon SageMaker会自动在后台将你的数据分为测试和训练，以便确定模型的准确度。如果你查看`SHOW
    MODEL`输出的`validation:multiclass_accuracy`键，你会看到一个值为**0.535028**，这意味着我们的模型可以在53%的时间内正确选择细分市场。理想情况下，我们更喜欢接近1的值。
- en: 'We can also run a validation query to check our accuracy rates. In the following
    query, note that we select the actual segmentation, and then we use the function
    that was generated by our `CREATE MODEL` command to get the predicted segmentation
    to do the comparison:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以运行一个验证查询来检查我们的准确率。在以下查询中，请注意我们选择了实际的细分，然后我们使用由我们的`CREATE MODEL`命令生成的函数来获取预测的细分以进行比较：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We get the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![Figure 6.17 – The model accuracy](img/B19071_06_17.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17 – 模型准确度](img/B19071_06_17.jpg)'
- en: Figure 6.17 – The model accuracy
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 模型准确度
- en: This output shows that we are very close to the score of **.535028** when we
    compare the number of times the model correctly predicted the segment against
    the total number of input records.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示，当我们比较模型正确预测细分市场的次数与总输入记录数时，我们非常接近**.535028**的分数。
- en: Now that we have checked the model accuracy, we are ready to run prediction
    queries against the test dataset.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了模型准确度，我们就可以运行针对测试数据集的预测查询了。
- en: Running prediction queries
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行预测查询
- en: 'Now that we have our model and have done validation, we can run our prediction
    query against our test set so that we can segment our prospective customers, based
    on customer IDs. You can see that we now use our function against the test table
    to get the predicted segment:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模型并进行了验证，我们可以运行预测查询来测试集，以便根据客户ID对潜在客户进行细分。你可以看到我们现在使用我们的函数对测试表进行操作以获取预测的细分：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first 10 customers are shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了前10位客户：
- en: '![Figure 6.18 – The predicted segment](img/B19071_06_18.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – 预测的细分市场](img/B19071_06_18.jpg)'
- en: Figure 6.18 – The predicted segment
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 预测的细分市场
- en: 'Let’s see how the new prospective customers are spread across the various segments:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看新潜在客户是如何分布在各个细分市场中的：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can see here how many prospective customers are in each segment:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每个细分市场中有多少潜在客户：
- en: '![Figure 6.19 – The customer count by segment](img/B19071_06_19.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19 – 按细分市场的客户数量](img/B19071_06_19.jpg)'
- en: Figure 6.19 – The customer count by segment
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 按细分市场的客户数量
- en: Now that you have this information, your marketing team is ready to target their
    efforts on these prospective customers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了这些信息，你的营销团队就可以开始针对这些潜在客户进行努力了。
- en: Let’s now take a look at some other options you can use to solve this multi-class
    classification problem.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看你可以使用的一些其他选项来解决这个多类分类问题。
- en: Exploring other CREATE MODEL options
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索其他CREATE MODEL选项
- en: We can also create this model in a couple of different ways, which we will explore
    in the following sections. It is important to understand the different options
    available so that you can experiment and choose the approach that gives you the
    best model.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以几种不同的方式创建此模型，我们将在以下章节中探讨。了解可用的不同选项非常重要，这样你就可以进行实验并选择给你带来最佳模型的方案。
- en: In the first example, we will not provide any user guidance, such as specifying
    `MODEL_TYPE`, `PROBLEM_TYPE`, or `OBJECTIVE`. Use this approach if you are new
    to ML and want to let SageMaker Autopilot determine this for you.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们不会提供任何用户指导，例如指定`MODEL_TYPE`、`PROBLEM_TYPE`或`OBJECTIVE`。如果你是机器学习的新手，希望让SageMaker
    Autopilot为你确定这些，请使用这种方法。
- en: Then, in the next example, you can see how you can provide `PROBLEM_TYPE` and
    `OBJECTIVE`. As a more experienced user of ML, you should now recognize which
    `PROBLEM_TYPE` and `OBJECTIVE` instances are best for your use case. When you
    provide these inputs, it will speed up the model training process, since SageMaker
    Autopilot will only train using the provided user guidance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在下一个示例中，您可以看到如何提供`PROBLEM_TYPE`和`OBJECTIVE`。作为一个更有经验的机器学习用户，您现在应该能够识别出哪些`PROBLEM_TYPE`和`OBJECTIVE`实例最适合您的用例。当您提供这些输入时，将加速模型训练过程，因为SageMaker
    Autopilot将仅使用提供的用户指导进行训练。
- en: Creating a model with no user guidance
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建无用户指导的模型
- en: 'In this approach, we let SageMaker Autopilot choose `MODEL_TYPE`, `PROBLEM_TYPE`,
    and `OBJECTIVE`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们让SageMaker Autopilot选择`MODEL_TYPE`、`PROBLEM_TYPE`和`OBJECTIVE`：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that we have only provided the basic settings. We did not specify `MODEL_TYPE`,
    `PROBLEM_TYPE`, or `OBJECTIVE`. Amazon Redshift ML and SageMaker will automatically
    figure out that this is a multi-class classification problem and use the best
    model type. As an additional exercise, run this `CREATE MODEL` command, and then
    run the `SHOW MODEL` command. It will show you the `MODEL_TYPE` parameter that
    Amazon SageMaker used to train the model.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只提供了基本设置。我们没有指定`MODEL_TYPE`、`PROBLEM_TYPE`或`OBJECTIVE`。Amazon Redshift
    ML和SageMaker将自动确定这是一个多类分类问题，并使用最佳模型类型。作为额外的练习，运行这个`CREATE MODEL`命令，然后运行`SHOW MODEL`命令。它将显示Amazon
    SageMaker用于训练模型的`MODEL_TYPE`参数。
- en: Creating a model with some user guidance
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建具有一些用户指导的模型
- en: 'In this example, we will provide `PROBLEM_TYPE` and `OBJECTIVE`, but we will
    let Amazon SageMaker determine `MODEL_TYPE`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将提供`PROBLEM_TYPE`和`OBJECTIVE`，但我们将让Amazon SageMaker确定`MODEL_TYPE`：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, we let Amazon Redshift ML and Amazon SageMaker determine `MODEL_TYPE`,
    and we pass in `PROBLEM_TYPE` and `OBJECTIVE`. When you have some free time, experiment
    with the different methods of creating the models, and note the differences you
    see in the time it takes to train the model, and also compare the accuracy and
    other outputs of the `SHOW` `MODEL` command.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们让Amazon Redshift ML和Amazon SageMaker确定`MODEL_TYPE`，并传入`PROBLEM_TYPE`和`OBJECTIVE`。当您有空闲时间时，尝试不同的模型创建方法，并注意您在模型训练时间上看到的不同，以及比较`SHOW`
    `MODEL`命令的准确性和其他输出。
- en: You can also create multi-class classification models using XGBoost, which we
    will cover in [*Chapter 10*](B19071_10.xhtml#_idTextAnchor178).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用XGBoost创建多类分类模型，我们将在[*第10章*](B19071_10.xhtml#_idTextAnchor178)中介绍。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed classification models in detail and looked at
    their common use cases. We also explained the `CREATE MODEL` syntax for classification
    models, where you provide guidance to train a model by supplying the model type
    and objective.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了分类模型，并探讨了它们的常见用例。我们还解释了分类模型的`CREATE MODEL`语法，其中您通过提供模型类型和目标来指导训练模型。
- en: You learned how to do binary classification and multi-class classification with
    Amazon Redshift ML and how to use the XGBoost and linear learner algorithms. We
    also showed you how to check the status of your models, validate them for accuracy,
    and write SQL queries to run predictions on your test dataset.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习了如何使用Amazon Redshift ML进行二分类和多类分类，以及如何使用XGBoost和线性学习算法。我们还向您展示了如何检查模型状态，验证其准确性，并编写SQL查询在测试数据集上运行预测。
- en: In the next chapter, we will show you how to build regression models using Amazon
    Redshift ML.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您展示如何使用Amazon Redshift ML构建回归模型。
