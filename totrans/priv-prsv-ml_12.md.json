["```py\ndef simple_encryption(text, shift):\n    \"\"\"\n    Encrypts the given text using the Caesar Cipher algorithm.\n    \"\"\"\n    result = \"\"\n# Loop through each character in the text\n    for i in range(len(text)):\n        char = text[i]\n# If the character is a letter, shift its position in the alphabet\n        if char.isalpha():\n            if char.isupper():\n                result += chr((ord(char) + shift - 65) % 26 + 65)\n            else:\n                result += chr((ord(char) + shift - 97) % 26 + 97)\n        else:\n            result += char\n    return result\nsimple_encryption(\"Privacy Preserved Machine Learning\",5)\n```", "```py\n'Uwnafhd Uwjxjwaji Rfhmnsj Qjfwsnsl'\n```", "```py\nfrom Crypto.Cipher import AES\nfrom Crypto.Random import get_random_bytes\ndef aes_encrypt(key, plaintext):\n# initialization vector to random bytes\n    ini_vec = get_random_bytes(AES.block_size)\n# Create the AES cipher object with the given key\n    aes_ciper = AES.new(key, AES.MODE_CBC, ini_vec)\n# Pad the plaintext to a multiple of the block size\n    plaintext = pad_plain_text(plaintext, AES.block_size)\n# Encrypt the plaintext using the AES cipher object\n    ciphertext = aes_ciper.encrypt(plaintext)\n    return ini_vec + ciphertext\ndef aes_decrypt(key, ciphertext):\n    ini_vec = ciphertext[:AES.block_size]\n    cipher = AES.new(key, AES.MODE_CBC, ini_vec)\n    plaintext = cipher.decrypt(ciphertext[AES.block_size:])\n    plaintext = unpad_decrypted_text(plaintext, AES.block_size)\n    return plaintext.decode('utf-8')\ndef pad_plain_text(data, block_size):\n    padding_length = block_size – (len(data) % block_size)\n    padding = bytes([padding_length] * padding_length)\n    return data + padding\ndef unpad_decrypted_text(data, block_size):\n    padding_length = data[-1]\n    if padding_length < 1 or padding_length > block_size:\n        raise ValueError(\"Padding is not Valid \")\n    padding = data[-padding_length:]\n    if not all(padding[i] == padding_length for i in range(padding_length)):\n        raise ValueError(\"Padding is not Valid \")\n    return data[:-padding_length]\nkey = b'ThisIsASecretKey'\nplaintext = b'Privacy Preserved Machine Learning'\nciphertext = aes_encrypt(key, plaintext)\nprint('Encrypted message:', ciphertext)\ndecrypted_plaintext = aes_decrypt(key, ciphertext)\nprint('Decrypted message:', decrypted_plaintext)\n```", "```py\nEncrypted message: b'\\xe3\\x00\\xe8\\x10\\xc6E\\x0cn\\x1bO,\\x89-\\x8d\\xee\\xb3\\xc6\\x1a\\xbf\\x95\\\\l\\x0e\\x8d\\xb0\\xaa\\x93\\xf4_$?h\\x1a`O\\xf4N\\x89!4\\xf7(\\xd3\\x8e\\xde\\xc7\\xf7\\xb8\\x87\\xea\\n5W\\x8e\\xa5D\\xec]\\x80\\xa8+\\x92?\\xa9'\nDecrypted message: Privacy Preserved Machine Learning\n```", "```py\nimport hashlib\nimport random\n# Example dataset\ndataset = [\n    {\"name\": \"Alice\", \"age\": 23, \"email\": \"alice@example.com\"},\n    {\"name\": \"Bob\", \"age\": 32, \"email\": \"bob@example.com\"},\n    {\"name\": \"Gandhi\", \"age\": 55, \"email\": \"gandhi@example.com\"},\n]\n# Create a random salt value for anonymization\nsalt = str(random.getrandbits(128))\n# Loop through the dataset and anonymize each record\nfor record in dataset:\n# Hash the name and email using the salt value name_hash = hashlib.sha256((record['name'] +salt).encode()).hexdigest() email_hash = hashlib.sha256((record['email'] + salt).encode()).hexdigest()\n# Replace the original name and email with the hashed values\nrecord['name'] = name_hash\nrecord['email'] = email_hash\nprint(dataset)\n```", "```py\n[{'name': 'e807ef3ca985de8ef481ddf8af4d3ac4c34089519cf225a7863306ced0a691fa', 'age': 23, 'email': '474f2b3dce2701b08651d64364ab5e83575e9bd8ff7e0e14d654afbdf19f6683'}, {'name': '36cbc209f7afaba2a3a4d8830c2b85b3813f467f4bf442bb439b3f112be00bd0', 'age': 32, 'email': '6a7b3de0488fc3a81436b5c70e943ca7139c93d1832430db2e6bac3f2c25cce5'}, {'name': '096aca9f2b7872c89b9c71ff1a649e7fe53fc7eb1a04354792ea58aaee3bbecf', 'age': 55, 'email': 'e15e4e48f0161e7a64b8ef604e6d9bd5d9d6f2da3c8d848268aeec0ff5da2ef8'}]\n```", "```py\nimport hashlib\n# Define a function to hash a given string using SHA256 Algorithm\ndef hash_string(s):\n    return hashlib.sha256(s.encode()).hexdigest()\n# Define a function to de-identify a given input data\ndef deidentify_data(data):\n# Remove leading/trailing whitespace and convert to lowercase\n    data = data.strip().lower()\n# Hash the name using SHA-256\n    hashed_data = hash_string(name)\n# Return the hashed data\n    return hashed_data\n# input\nperson_name = \"Sundar P\"\nhashed_name = deidentify_data(person_name)\nprint(hashed_name)\n```", "```py\n\"6cea57c2fb6cbc2a40411135005760f241fffc3e5e67ab99882726431037f908\"\"\n```", "```py\npip3 install phe\n```", "```py\nimport phe as paillier\npubkey, privkey = paillier.generate_paillier_keypair(n_length=1024)\nprint(\"public key\",pubkey)\nprint(\"private key\", privkey)\npublic key <PaillierPublicKey 18dced683d>\nprivate key <PaillierPrivateKey for <PaillierPublicKey 18dced683d>>\nplaintext = 15\nciphertext = pubkey.encrypt(plaintext)\n# Perform homomorphic operations on the ciphertext data\nciphertext1 = ciphertext * 3\nciphertext2 = ciphertext + ciphertext1\nciphertext3 = ciphertext1 + 250\nciphertext4 = ciphertext3 - ciphertext2\n# Decrypt the resulting ciphertext data\ndecrypted1 = privkey.decrypt(ciphertext1)\ndecrypted2 = privkey.decrypt(ciphertext2)\ndecrypted3 = privkey.decrypt(ciphertext3)\ndecrypted4 = privkey.decrypt(ciphertext4)\n# Print the decrypted results\nprint(\"ciphertext1 decrypted: \", decrypted1)\nprint(\"ciphertext2 decrypted: \", decrypted2)\nprint(\"ciphertext3 decrypted: \", decrypted3)\nprint(\"ciphertext4 decrypted: \", decrypted4)\nciphertext1 decrypted:  45\nciphertext2 decrypted:  60\nciphertext3 decrypted:  295\nciphertext3 decrypted:  235\nciphertext1 : <phe.paillier.EncryptedNumber object at 0x7fd51856afa0>\nciphertext2 : <phe.paillier.EncryptedNumber object at 0x7fd5185c3580>\nciphertext3 : <phe.paillier.EncryptedNumber object at 0x7fd51856ac70>\nciphertext4 : <phe.paillier.EncryptedNumber object at 0x7fd5185c3460>\n```", "```py\nm1=15\nm2=20\npubkey.encrypt(m1) * pubkey.encrypt(m2)\nFile ~/Library/Python/3.8/lib/python/site-packages/phe/paillier.py:508, in EncryptedNumber.__mul__(self, other)\n    506 \"\"\"Multiply by an int, float, or EncodedNumber.\"\"\"\n    507 if isinstance(other, EncryptedNumber):\n--> 508 raise NotImplementedError('Good luck with that...')\n    510 if isinstance(other, EncodedNumber):\n    511     encoding = other\nNotImplementedError: Good luck with that...\n```", "```py\npip3 install tenseal\n```", "```py\nimport tenseal as ts\n# Step 1: Create context\ncontext = ts.context(\n              ts.SCHEME_TYPE.CKKS,\n              poly_modulus_degree=8192,\n              coeff_mod_bit_sizes=[60, 40, 40, 60]\n        )\ncontext.generate_galois_keys()\ncontext.global_scale = 2**40\n# Step 2: Create and encrypt data\ndata1 = [1.0, 2.0, 3.0, 4.0]\ndata2 = [5.0, 6.0, 7.0, 8.0]\nencrypted_data1 = ts.ckks_vector(context, data1)\nencrypted_data2 = ts.ckks_vector(context, data2)\n# Step 3: Perform operations on encrypted data\nencrypted_sum = encrypted_data1 + encrypted_data2\nencrypted_product = encrypted_data1 * encrypted_data2\nencrypted_dot_product = encrypted_data1.dot(encrypted_data2)\nmatrix_a = [[73],[69],[87],[45],]\nmat_product = encrypted_data1.matmul(matrix_a)\n# Step 4: Decrypt result\nsum_result = encrypted_sum.decrypt()\nproduct_result = encrypted_product.decrypt()\ndot_product_result = encrypted_dot_product.decrypt()\nmat_result = mat_product.decrypt()\nprint(\"Sum: \", sum_result)\nprint(\"Product: \", product_result)\nprint(\"Dot product: \", dot_product_result)\nprint(\"Matrix Multiplication : \", mat_result)\nSum: [6.000000000650802, 8.000000001433328, 10.0000000008995, 12.000000000314097]\nProduct: [5.000000671234171, 12.000001615240716, 21.000002823083314, 32.000004292130704]\nDot product: [70.00000937472286]\nMatrix Multiplication : [652.000087556169]\n```", "```py\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nurl=\"fraud_transactions.csv\"\ndf_actual = pd.read_csv(url, sep=\",\")\ndf_actual.head()\ndf_transactions = df_actual[['CUSTOMER_ID','TERMINAL_ID','TX_AMOUNT','TX_FRAUD']]\ndf_transactions\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import StratifiedShuffleSplit\nX = df_transactions.drop('TX_FRAUD', axis=1)\ny = df_transactions['TX_FRAUD']\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\nX_train = X_train.values\nX_test = X_test.values\ny_train = y_train.values\ny_test = y_test.values\nfrom sklearn.model_selection import cross_val_score\nlogreg = LogisticRegression(random_state=0)\nlogreg.fit(X_train, y_train)\ntraining_score = cross_val_score(logreg, X_train, y_train, cv=2)\nprint('Logistic Regression Cross Validation Score: ', round(training_score.mean() * 100, 2).astype(str) + '%')\nimport numpy as np\nnp.sum(logreg.predict(X_test) == y_test)/X_test.shape[0]\nlogreg.intercept_[0], logreg.coef_[0]\n```", "```py\n(-1168.308115256604,\n array([-2.47724513e-05, 3.17749573e-06, 1.54748556e+01]))\n### Encrypt the Weights and Bias ( intercept) using paillier encryption\nimport phe as paillier\npubkey, privkey = paillier.generate_paillier_keypair(n_length=1024)\ncoef = logreg.coef_[0, :]\nencrypted_weights = [pubkey.encrypt(coef[i]) for i in range(coef.shape[0])]\nencrypted_intercept =pubkey.encrypt(logreg.intercept_[0])\nprint(encrypted_weights)\n[<phe.paillier.EncryptedNumber object at 0x7ff005a9c9d0>, <phe.paillier.EncryptedNumber object at 0x7fefe3b2c520>, <phe.paillier.EncryptedNumber object at 0x7ff010760cd0>]\nprint(encrypted_intercept)\n<phe.paillier.EncryptedNumber at 0x7fefb812f100>\n### calculate score using encrypted weights for the 100 sample in the tests data and calculate the accuracy\ny=np.zeros(100)\nfor i in range(1,100):\n    c1 = X_test[i][0]\n    c2 = X_test[i][1]\n    c3 = X_test[i][2]\n    score = encrypted_intercept\n    score += c1 * encrypted_weights[0] + c2 * encrypted_weights[1] + c3 * encrypted_weights[2]\n    dscore = privkey.decrypt(score)\n    y[i] = dscore\nprint(y[0],y_test[0])\nerror = np.mean(np.sign(y) != y_test[1:100])\nprint(error)\nOutput:\n0.0 0\n1.0\n```", "```py\nimport random\n# Define two parties\nBank1_data = [0.1, 0.2, 0.3]\nBank2_data = [0.5, 0.6, 0.7]\n# Define the computation\ndef compute(x, y):\n# Multiply the input data element-wise\n    z = [x[i] * y[i] for i in range(len(x))]\n# Sum the result\n    result = sum(z)\n    return result\n# Randomly generate private keys for the parties\nBank1_key = random.randint(0, 1000)\nBank2_key = random.randint(0, 1000)\n# Bank1 encrypts their data using Bank1 private key\nBank1_encrypted_data = [x + Bank1_key for x in Bank1_data]\n# Bank2 encrypts their data using Bank2 private key\nBank2_encrypted_data = [x + Bank2_key for x in Bank2_data]\n# The parties send their encrypted data to each other\nBank1_received_data = Bank2_encrypted_data\nBank2_received_data = Bank1_encrypted_data\n# The parties compute the multiplication of their data\nBank1_result = compute(Bank1_data, Bank2_received_data)\nprint(Bank1_result)\nBank2_result = compute(Bank2_data, Bank1_received_data)\nprint(Bank2_result)\n# The parties add their private keys to the result\nfinal_result = Bank1_result + Bank1_key + Bank2_result + Bank2_key\nprint(\"Result:\", final_result)\noutput this program as follows :\n31.34\n1669.6999999999998\nResult: 2680.04\n```", "```py\nimport random\n# Set up the scenario\nsecret_number = 42 # The secret number the Prover wants to prove knowledge of\nupper_bound = 100  # The upper bound of the possible values for the secret number\n# Generate random values for the parameters used in the ZKPK\na = random.randint(1, upper_bound)  # Random value for the first parameter\nb = random.randint(1, upper_bound)  # Random value for the second parameter\nr = random.randint(1, upper_bound)  # Random value for the blinding factor\n# Calculate the commitments\ncommitment_x = (a * secret_number + b) % upper_bound\ncommitment_r = (a * r + b) % upper_bound\n# Send the commitments to the Verifier\nprint(\"Prover sends commitments: \", commitment_x, commitment_r)\n# Verifier sends a random challenge value to the Prover\nchallenge = random.randint(0, 1)\n# Prover responds with the value of the secret number or the blinding factor, depending on the challeng\nif challenge == 0:\n    response = secret_number\nelse:\n    response = r\n# Verifier checks the response against the commitments\nif challenge == 0:\n    if (a * response + b) % upper_bound == commitment_x:\n        print(\"Prover has proven knowledge of the secret number!\")\n    else:\n        print(\"Prover has failed to prove knowledge of the secret number.\")\nelse:\n    if (a * response + b) % upper_bound == commitment_r:\n        print(\"Prover has proven knowledge of the blinding factor!\")\n    else:\n        print(\"Prover has failed to prove knowledge of the blinding factor.\")\nProver sends commitments: 39 94\nProver has proven knowledge of the blinding factor!\n```"]