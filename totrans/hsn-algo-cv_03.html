<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Array and Matrix Operations</h1>
                
            
            <article>
                
<p class="calibre2">Now that we're past the first part of the book and the introductions and fundamental concepts in computer vision, we can start with the computer vision algorithms and functions provided by the OpenCV library, which more or less cover any computer vision topic that comes to mind, with optimized implementations. As we learned in the previous chapters, OpenCV uses a modular structure to categorize the computer vision functionalities contained in it. We'll move forward with the topics in this book with a similar structure in mind, so that the skills learned are related to each other in each chapter, not just from a theoretical point of view, but also from a hands-on perspective.</p>
<p class="calibre2">In the previous chapter, we learned about the relationship between images and matrices, and covered the most crucial functionalities of the <kbd class="calibre13">Mat</kbd> class, such as constructing it using a given width, height, and type. We also learned how to read images from disk, a network feed, video files, or cameras. During the process, we learned how to access pixels in an image using various methods. We can now start with actual image- and pixel-modification and manipulation functionalities.</p>
<p class="calibre2">In this chapter, we're going to learn about a large number of functions and algorithms that are used to deal with images, either for calculating a value that might be useful in another process or for directly modifying the values of the pixels in an image. Almost all of the algorithms presented in this chapter are based on the fact that images are essentially matrices, and also the fact that matrices are implemented using arrays of data, hence the name of this chapter!</p>
<p class="calibre2">We'll start this chapter by covering the functionalities within the <kbd class="calibre13">Mat</kbd> class itself, which are few, but quite important when it comes to the creation of initial matrices and so on. Then, we'll move on to learn about a large number of per-element (or element-wise) algorithms. These algorithms, as we'll learn by going through many hands-on examples, apply a specific operation on each individual element of a matrix and they are not concerned with any other element (or pixel). Finally, we'll learn about matrix and array operations that are not element-wise and the result may depend on the whole image or groups of elements. This will all clear up as we move forward with the algorithms in this chapter. It's important to note that all of the algorithms and functions in this chapter are contained within the core module of OpenCV library.</p>
<p class="calibre2">By the end of this chapter, you'll have a better understanding of the following:</p>
<ul class="calibre10">
<li class="calibre11">Operations contained in the <kbd class="calibre13">Mat</kbd> class</li>
<li class="calibre11">Element-wise matrix operations</li>
<li class="calibre11">Matrix and array-wise operations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Technical requirements</h1>
                
            
            <article>
                
<ul class="calibre10">
<li class="calibre11">An IDE to develop C++ or Python applications</li>
<li class="calibre11">The OpenCV library</li>
</ul>
<p class="calibre2">Refer to <span class="calibre12"><a target="_blank" href="part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4" class="calibre9">Chapter 2</a>, <em class="calibre7">Getting Started with OpenCV</em></span>, for more information about how to set up a personal computer and make it ready for developing computer vision applications using OpenCV library.</p>
<p class="calibre2">You can use the following URL to download the source codes and examples for this chapter: <a href="https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter03" class="calibre9"><span>https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter03</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operations contained in the Mat class</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we're going to go through the set of mathematical and other operations that are contained inside the <kbd class="calibre13">Mat</kbd> class itself. Even though there is no general pattern of usage for the functions in the <kbd class="calibre13">Mat</kbd> class, most of them are related to creating a new matrix, whether it is using an existing one or from scratch. So, let's start.</p>
<div class="packt_infobox"><span class="calibre38">During the course of the book, the words image, matrix, the </span><kbd class="calibre29">Mat</kbd> <span class="calibre38">class, and so on will be used interchangeably, and they all mean the same thing, unless explicitly stated. Take this chance to get used to the idea of thinking about images in terms of matrices, just like a computer vision expert would do.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cloning a matrix</h1>
                
            
            <article>
                
<p class="calibre2">You can use <kbd class="calibre13">Mat::clone</kbd> to create a completely independent clone of a <kbd class="calibre13">Mat</kbd> object. Note that this function creates a full copy of the image with its own allocated space in memory. Here's how it's used:</p>
<pre class="calibre33">Mat clone = image.clone(); </pre>
<p class="calibre2">You can also use the <kbd class="calibre13">copyTo</kbd> function to do the same, as seen here:</p>
<pre class="calibre33">Mat clone; 
image.copyTo(clone); </pre>
<p class="calibre2">In both of the preceding code examples, <kbd class="calibre13">image</kbd> is the original matrix (or image) that is read from an image, camera, or produced in any possible way prior to performing the cloning operation. From now on, and in all of the examples in this and upcoming chapters, <kbd class="calibre13">image</kbd> is simply a <kbd class="calibre13">Mat</kbd> object that is the source of our operations, unless otherwise stated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Calculating the cross-product</h1>
                
            
            <article>
                
<p class="calibre2">You can use <kbd class="calibre13">Mat::cross</kbd> to calculate the cross-product of two <kbd class="calibre13">Mat</kbd> objects that have three floating-point elements, as seen in the following example:</p>
<pre class="calibre33">Mat A(1, 1, CV_32FC3), 
   B(1, 1, CV_32FC3); 
 
A.at&lt;Vec3f&gt;(0, 0)[0] = 0; 
A.at&lt;Vec3f&gt;(0, 0)[1] = 1; 
A.at&lt;Vec3f&gt;(0, 0)[2] = 2; 
 
B.at&lt;Vec3f&gt;(0, 0)[0] = 3; 
B.at&lt;Vec3f&gt;(0, 0)[1] = 4; 
B.at&lt;Vec3f&gt;(0, 0)[2] = 5; 
 
Mat AxB = A.cross(B); 
Mat BxA = B.cross(A);</pre>
<p class="calibre2">Obviously, <kbd class="calibre13">AxB</kbd> is not the same as <kbd class="calibre13">BxA</kbd> in the cross-product of two vectors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Extracting a diagonal</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre13">Mat::diag</kbd> can be used to extract a diagonal from a <kbd class="calibre13">Mat</kbd> object, as seen in the following example:</p>
<pre class="calibre15">int D = 0; // or +1, +2, -1, -2 and so on 
Mat dg = image.diag(D); </pre>
<p class="calibre2">This function accepts an index parameter that can be used to extract additional diagonals beside the main diagonal, as depicted in the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00019.gif" class="calibre39"/></div>
<p class="calibre2">If <strong class="calibre4">D=0</strong>, then the extracted diagonal will contain <strong class="calibre4">1</strong>, <strong class="calibre4">6</strong>, <strong class="calibre4">11</strong>, and <strong class="calibre4">16</strong>, which is the main diagonal. But depending on the value of <strong class="calibre4">D</strong>, the extracted diagonal will be above or below the main diagonal, as seen in the preceding diagram.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Calculating the dot product</h1>
                
            
            <article>
                
<p class="calibre2">To calculate the dot product, or scalar product, or inner product of two matrices, you can use the <kbd class="calibre13">Mat::dot</kbd> function, as seen here:</p>
<pre class="calibre33">double result = A.dot(B); </pre>
<p class="calibre2">In this, <kbd class="calibre13">A</kbd> and <kbd class="calibre13">B</kbd> are both OpenCV <kbd class="calibre13">Mat</kbd> objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Learning about the identity matrix</h1>
                
            
            <article>
                
<p class="calibre2">Identity matrices are created using the <kbd class="calibre13">Mat::eye</kbd> function in OpenCV. Here's an example:</p>
<pre class="calibre33">Mat id = Mat::eye(10, 10, CV_32F); </pre>
<p class="calibre2">In case you need a value other than the ones in the identity matrix diagonal, you can use a <kbd class="calibre13">scale</kbd> parameter:</p>
<pre class="calibre33">double scale = 0.25; 
Mat id = Mat::eye(10, 10, CV_32F) * scale; </pre>
<p class="calibre2">Another way of creating an identity matrix is by using the <kbd class="calibre13">setIdentity</kbd> function. Make sure to check the OpenCV documentation for more information about this function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matrix inversion</h1>
                
            
            <article>
                
<p class="calibre2">You can use the <kbd class="calibre13">Mat::inv</kbd> function to invert a matrix:</p>
<pre class="calibre33">Mat inverted = m.inv(); </pre>
<p class="calibre2">Note that you can supply a matrix decomposition type to the <kbd class="calibre13">inv</kbd> function, which can be an entry in the <kbd class="calibre13">cv::DecompTypes</kbd> enum.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Element-wise matrix multiplication</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre13">Mat::mul</kbd> can be used to perform an element-wise multiplication of two <kbd class="calibre13">Mat</kbd> objects. Needless to say, this same function can also be used for element-wise division. Here's an example:</p>
<pre class="calibre33">Mat result = A.mul(B); </pre>
<p class="calibre2">You can also supply an additional <kbd class="calibre13">scale</kbd> parameter that will be used to scale the result. Here's another example:</p>
<pre class="calibre33">double scale = 0.75; 
Mat result = A.mul(B, scale);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The ones and zeroes matrix</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre13">Mat::ones</kbd> and <kbd class="calibre13">Mat::zeroes</kbd> can be used to create a matrix of a given size with all of its elements set to one or zero, respectively. These matrices are usually used to create initializer matrices. Here are some examples:</p>
<pre class="calibre33">Mat m1 = Mat::zeroes(240, 320, CV_8UC1); 
Mat m2 = Mat::ones(240, 320, CV_8UC1); </pre>
<p class="calibre2">In case you need to create a matrix that is filled with a value other than ones, you can use something like the following:</p>
<pre class="calibre33">Mat white = Mat::ones(240, 320, CV_8UC1) * 255; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Transposing a matrix</h1>
                
            
            <article>
                
<p class="calibre2">You can use <kbd class="calibre13">Mat::t</kbd> to transpose a matrix. Here's an example:</p>
<pre class="calibre33">Mat transpose = image.t(); </pre>
<p class="calibre2">Here's an example that demonstrates the transposition of an image:</p>
<div class="cdpaligncenter"><img src="../images/00020.jpeg" class="calibre40"/></div>
<p class="calibre2">The image on the left is the original image and the image on the right is the transpose of the original image. As you can see, the result is a rotated (clockwise) and flipped (vertically) version of the original image. As you'll learn later in this chapter, <kbd class="calibre13">transpose</kbd>, or the <kbd class="calibre13">Mat::t</kbd> function, can be used in conjunction with the <kbd class="calibre13">flip</kbd> function to rotate or flip/mirror an image in all possible directions.</p>
<div class="packt_infobox"><span class="calibre38">Transposing</span> a transpose matrix is the same as the original matrix, and running the following code will result in the original image itself:<br class="calibre41"/>
<br class="calibre41"/>
<kbd class="calibre29">Mat org = image.t().t();</kbd></div>
<p class="calibre2">Another way of calculating the transpose of a matrix is by using the <kbd class="calibre13">transpose</kbd> function. Here's an example of how this function is used:</p>
<pre class="calibre33">transpose(mat, trp); </pre>
<p class="calibre2">In which <kbd class="calibre13">mat</kbd> and <kbd class="calibre13">trp</kbd> are both <kbd class="calibre13">Mat</kbd> objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reshaping a Mat object</h1>
                
            
            <article>
                
<p class="calibre2">A <kbd class="calibre13">Mat</kbd> object can be reshaped using the <kbd class="calibre13">Mat::reshape</kbd> function. Note that reshaping, in this sense, means changing the number of channels and rows of an image. Here's an example:</p>
<pre class="calibre33">int ch = 1; 
int rows = 200; 
Mat rshpd = image.reshape(ch, rows); </pre>
<p class="calibre2">Note that passing a value of zero as the number of channels means that the number of channels will stay the same as the source. Similarly, passing a value of zero as the number of rows means the number of rows in the image will stay the same.</p>
<p class="calibre2">Note that <kbd class="calibre13">Mat::resize</kbd> is another useful function for reshaping a matrix, but it only allows changing the number of rows in an image. Another function that can come in handy when reshaping matrices or dealing with the number of elements in a matrix, is the <kbd class="calibre13">Mat::total</kbd> function, which returns the total number of elements in an image.</p>
<p class="calibre2">That's about it for the functionalities embedded into the <kbd class="calibre13">Mat</kbd> class itself. Make sure to go through the <kbd class="calibre13">Mat</kbd> class documentation and familiarize yourself with possible variants of the methods you just learned in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Element-wise matrix operations</h1>
                
            
            <article>
                
<p class="calibre2">Per-element or element-wise matrix operations are mathematical functions and algorithms in computer vision that work on individual elements of a matrix or, in other words, pixels of an image. It's important to note that element-wise operations can be parallelized, which fundamentally means that the order in which the elements of a matrix are processed is not important. This specification is the most important feature that separates the functions and algorithms in this section and the upcoming sections of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Basic operations</h1>
                
            
            <article>
                
<p class="calibre2">OpenCV provides all the necessary functions and overloaded operators that you need to perform all four basic operations of addition, subtraction, multiplication, and division between two matrices or a matrix and a scalar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The addition operation</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">add</kbd> function and the <kbd class="calibre13">+</kbd> operator can be used to add the elements of two matrices, or a matrix and a scalar, as seen in the following examples:</p>
<pre class="calibre15">Mat image = imread("Test.png"); 
Mat overlay = imread("Overlay.png"); 
Mat result; 
add(image, overlay, result); </pre>
<p class="calibre2">You can replace the last line in the preceding code with the following:</p>
<pre class="calibre33">result = image + overlay; </pre>
<p class="calibre2">The following image demonstrates the resulting image of an add operation of two images:</p>
<div class="cdpaligncenter"><img src="../images/00021.jpeg" class="calibre42"/></div>
<p class="calibre2">In case, you want to add a single scalar value to all elements of a <kbd class="calibre13">Mat</kbd> object, you can simply use something similar to the following:</p>
<pre class="calibre33">result = image + 80; </pre>
<p class="calibre2">If the preceding code is executed on a grayscale image, the result will be brighter than the source image. Note that if the image has three channels, you must use a three-item vector instead of a single value. For instance, to be able to make an RGB image brighter, you can use the following:</p>
<pre class="calibre33">result = image + Vec3b(80, 80, 80); </pre>
<p class="calibre2">Here's an image depicting the brighter result image, when the preceding code is executed on it:</p>
<div class="cdpaligncenter"><img src="../images/00022.jpeg" class="calibre43"/></div>
<p class="calibre2">In the preceding example codes, simply increase the added value to get an even brighter image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Weighted addition</h1>
                
            
            <article>
                
<p class="calibre2">Besides the simple addition of two images, you can also use the weighted addition function to consider a weight for each of the two images that are being added. Think of it as setting an opacity level for each of the participants in an <kbd class="calibre13">add</kbd> operation. To perform a weighted addition, you can use the <kbd class="calibre13">addWeighted</kbd> function:</p>
<pre class="calibre33">double alpha = 1.0; // First image weight 
double beta = 0.30; // Second image weight 
double gamma = 0.0; // Added to the sum 
addWeighted(image, alpha, overlay, beta, gamma, result); </pre>
<p class="calibre2">If executed on the sample pictures from the previous section with the add example, the result would be similar to the following:</p>
<div class="cdpaligncenter"><img src="../images/00023.jpeg" class="calibre44"/></div>
<p class="calibre2">Notice the transparent text that is similar to the watermark usually applied by photo-editing applications. Notice the comments in the code regarding the <kbd class="calibre13">alpha</kbd>, <kbd class="calibre13">beta</kbd>, and <kbd class="calibre13">gamma</kbd> values? Obviously, providing a <kbd class="calibre13">beta</kbd> value of <kbd class="calibre13">1.0</kbd> would have made this example exactly the same as a regular <kbd class="calibre13">add</kbd> function with no transparency for the overlay text.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The subtraction operation</h1>
                
            
            <article>
                
<p class="calibre2">Similar to adding two <kbd class="calibre13">Mat</kbd> objects to each other, you can also subtract all elements of one image from another using the <kbd class="calibre13">subtract</kbd> function or the <kbd class="calibre13">-</kbd> operator. Here's an example:</p>
<pre class="calibre33">Mat image = imread("Test.png"); 
Mat overlay = imread("Overlay.png"); 
Mat result; 
subtract(image, overlay, result); </pre>
<p class="calibre2">The last line in the preceding code can also be replaced with this:</p>
<pre class="calibre33">result = image - overlay; </pre>
<p class="calibre2">Here's the result of the subtraction operation if we used the same two images from the previous examples:</p>
<div class="cdpaligncenter"><img src="../images/00024.jpeg" class="calibre45"/></div>
<p class="calibre2">Notice how the subtraction of higher pixel values (brighter pixels) from the source image results in the dark color of the overlay text. Also note that the subtraction operation depends on the order of its operands, unlike addition. Try swapping the operands and see what happens for yourself.</p>
<p class="calibre2">Just like addition, it's also possible to multiply a constant number with all of the pixels of an image. You can guess that subtraction of a constant value from all pixels will result in a darker image (depending on the subtracted value) which is the opposite of the addition operation. Here's an example of making an image darker with a simple subtraction operation:</p>
<pre class="calibre33">result = image - 80;</pre>
<p class="calibre2">In case the source image is a three-channel RGB image, you need to use a vector as the second operand:</p>
<pre class="calibre33">result = image - Vec3b(80, 80, 80); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The multiplication and division operations</h1>
                
            
            <article>
                
<p class="calibre2">Similar to addition and subtraction, you can also multiply all elements of a <kbd class="calibre13">Mat</kbd> object with all elements of another <kbd class="calibre13">Mat</kbd> object. The same can be done with the division operation. Again, both operations can be performed with a matrix and a scalar. Multiplication can be done using OpenCV's <kbd class="calibre13">multiply</kbd> function (similar to the <kbd class="calibre13">Mat::mul</kbd> function), while division can be performed using the <kbd class="calibre13">divide</kbd> function.</p>
<p class="calibre2">Here are some examples:</p>
<pre class="calibre33">double scale = 1.25; 
multiply(imageA, imageB, result1, scale); 
divide(imageA, imageB, result2, scale); </pre>
<p class="calibre2"><kbd class="calibre13">scale</kbd> in the preceding code is an additional parameter that can be supplied to the <kbd class="calibre13">multiply</kbd> and <kbd class="calibre13">divide</kbd> functions to scale all of the elements in the result <kbd class="calibre13">Mat</kbd> object. You can also perform multiplication or division with a scalar, as seen in the following examples:</p>
<pre class="calibre33">resultBrighter = image * 5; 
resultDarker = image / 5; </pre>
<p class="calibre2">Obviously, the preceding code will produce two images, one that is five times brighter and one that is five times darker than the original image. The important thing to note here is that, unlike addition and subtraction, the resulting image will not be homogeneously brighter or darker, and you'll notice that brighter areas become much brighter and vice versa. The reason for this is obviously the effect of multiplication and division operations, in which the value of brighter pixels grows or drops much faster than smaller values after the operation. It's interesting to note that this same technique is used in most photo-editing applications to brighten or darken the bright areas of an image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bitwise logical operations</h1>
                
            
            <article>
                
<p class="calibre2">Just like basic operations, you can also perform bitwise logical operations on all of the elements of two matrices or a matrix and a scalar. For this reason, you can use the following functions:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">bitwise_not</kbd></li>
<li class="calibre11"><kbd class="calibre13">bitwise_and</kbd></li>
<li class="calibre11"><kbd class="calibre13">bitwise_or</kbd></li>
<li class="calibre11"><kbd class="calibre13">bitwise_xor</kbd></li>
</ul>
<p class="calibre2">It's immediately recognizable from their names that these functions can perform <kbd class="calibre13">Not</kbd>, <kbd class="calibre13">And</kbd>, <kbd class="calibre13">Or</kbd>, and <kbd class="calibre13">Exclusive OR</kbd> operations, but let's see how they're used in detail with some hands-on examples:</p>
<p class="calibre2">First things first, the <kbd class="calibre13">bitwise_not</kbd> function is used to invert all the bits of all pixels in an image. This function has the same effect as the inversion operation that can be found in most photo editing applications. Here's how it's used:</p>
<pre class="calibre33">bitwise_not(image, result); </pre>
<p class="calibre2">The preceding code can be replaced with the following too, which uses an overloaded bitwise <kbd class="calibre13">not</kbd> operator (<kbd class="calibre13">~</kbd>) in C++:</p>
<pre class="calibre33">result = ~image; </pre>
<p class="calibre2">If the image is a monochrome black and white image, the result will contain an image with all white pixels replaced with black and vice versa. In case the image is an RGB color image, the result will be inverted (in the sense of its binary pixel values), which is depicted in the following example image:</p>
<div class="cdpaligncenter"><img src="../images/00025.jpeg" class="calibre46"/></div>
<p class="calibre2">The <kbd class="calibre13">bitwise_and</kbd> function, or the <kbd class="calibre13">&amp;</kbd> operator, is used to perform a bitwise <kbd class="calibre13">And</kbd> operation on pixels from two images or pixels from an image and a scalar. Here is an example:</p>
<pre class="calibre33">bitwise_and(image, mask, result); </pre>
<p class="calibre2">You can simply use the <kbd class="calibre13">&amp;</kbd> operator and write the following instead:</p>
<pre class="calibre33">result = image &amp; mask; </pre>
<p class="calibre2">The <kbd class="calibre13">bitwise_and</kbd> function can be easily used to mask and extract certain areas in images. For instance, the following image is a demonstration of how <kbd class="calibre13">bitwise_and</kbd> results in an image that passes the white pixels and removes the black pixels:</p>
<div class="cdpaligncenter"><img src="../images/00026.jpeg" class="calibre47"/></div>
<p class="calibre2">Besides masking certain areas of an image, the bitwise <kbd class="calibre13">And</kbd> operation can be used to filter out a channel altogether. To be able to do this, you need to use the second form of the <kbd class="calibre13">&amp;</kbd> operator, which takes a matrix and a scalar and performs the <kbd class="calibre13">And</kbd> operation between all pixels and that value. Here is an example code that can be used to mask (zero out) the green color channel in an RGB color image:</p>
<pre class="calibre33">result = image &amp; Vec3b(0xFF, 0x00, 0xFF); </pre>
<p class="calibre2">Now, let's move on to the next bitwise operation, the <kbd class="calibre13">Or</kbd> operation. The <kbd class="calibre13">bitwise_or</kbd> and <kbd class="calibre13">|</kbd> operators can both be used to perform a bitwise <kbd class="calibre13">Or</kbd> operation on two images, or an image and a scalar. Here is an example:</p>
<pre class="calibre33">bitwise_or(image, mask, result);</pre>
<p class="calibre2">Similar to the bitwise <kbd class="calibre13">And</kbd> operation, you can use the <kbd class="calibre13">|</kbd> operator in the <kbd class="calibre13">Or</kbd> operation and simply write the following instead of the preceding code:</p>
<pre class="calibre33">result = image | mask; </pre>
<p class="calibre2">If the <kbd class="calibre13">And</kbd> operation was used to pass through the non-zero pixels (or non-black pixels), then it can be said that the <kbd class="calibre13">Or</kbd> operation is used to pass through the pixel with the higher value (or brighter) in any of its input images. Here's the result of performing the bitwise <kbd class="calibre13">Or</kbd> operation on the previous example images:</p>
<div class="cdpaligncenter"><img src="../images/00027.jpeg" class="calibre48"/></div>
<p class="calibre2">Similar to bitwise <kbd class="calibre13">And</kbd> <span class="calibre12">operation</span><span class="calibre12">, you can also use bitwise</span> <kbd class="calibre13">Or</kbd><span class="calibre12"> operation to update an individual channel or all the pixels of an image. Here is an example code that shows how you can update only the green channel in an RGB image to have the maximum possible value (which is 255, or hexadecimal</span> <kbd class="calibre13">FF</kbd><span class="calibre12">) in all of its pixels and leave the other channels as they are:</span></p>
<pre class="calibre33">result = image | Vec3b(0x00, 0xFF, 0x00); </pre>
<p class="calibre2">Finally, you can use <kbd class="calibre13">bitwise_xor</kbd>, or the <kbd class="calibre13">^</kbd> operator to perform an <kbd class="calibre13">Exclusive Or</kbd> between the pixels of two images, or an image and a scalar. Here is an example:</p>
<pre class="calibre33">bitwise_xor(image, mask, result); </pre>
<p class="calibre2">Or simply use the <kbd class="calibre13">^</kbd> operator and write the following instead:</p>
<pre class="calibre33">result = image ^ mask;</pre>
<p class="calibre2">Here is the resulting image, if the <kbd class="calibre13">Exclusive Or</kbd> operation is performed on the example image from the preceding section:</p>
<div class="cdpaligncenter"><img src="../images/00028.jpeg" class="calibre49"/></div>
<p class="calibre2">Notice how this operation leads to the inversion of the pixels in the masked area? Think about the reason behind this by writing down the pixel values on a paper and trying to calculate the result by yourself. <kbd class="calibre13">Exclusive Or</kbd>, and all bitwise operations, can be used for many other computer vision tasks if their behavior is clearly understood.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The comparison operations</h1>
                
            
            <article>
                
<p class="calibre2">Comparing two images with each other (or given values) can be quite useful, especially for producing masks that can be used in various other algorithms, whether it is for tracking some object of interest in an image or performing an operation on an isolated (masked) region of an image. OpenCV provides a handful of functions to perform element-wise comparisons. For instance, the <kbd class="calibre13">compare</kbd> function can be used to compare two images with each other. Here's how:</p>
<pre class="calibre33">compare(image1, image2, result, CMP_EQ); </pre>
<p class="calibre2">The first two parameters are the first and second image that will participate in the comparison. The <kbd class="calibre13">result</kbd> will be saved into a third <kbd class="calibre13">Mat</kbd> object, and the last parameter, which must be an entry from the <kbd class="calibre13">CmpTypes</kbd> enum, is used to select the type of comparison, which can be any of the following:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">CMP_EQ</kbd>: Means that the first image equals the second image</li>
<li class="calibre11"><kbd class="calibre13">CMP_GT</kbd>: Means that the first image is greater than the second image</li>
<li class="calibre11"><kbd class="calibre13">CMP_GE</kbd>: Means that the first image is greater than or equal to the second image</li>
<li class="calibre11"><kbd class="calibre13">CMP_LT</kbd>: Means that the first image is less than the second image</li>
<li class="calibre11"><kbd class="calibre13">CMP_LE</kbd>: Means that the first image is less than or equal to the second image</li>
<li class="calibre11"><kbd class="calibre13">CMP_NE</kbd>: Means that the first image is not equal to the second image</li>
</ul>
<div class="packt_infobox">Note that we are still talking about element-wise operations, so when we say <em class="calibre50">first image is less than or equal to the second image</em>, what we actually mean is <em class="calibre50">each individual pixel in the first image contains a value less than or equal to its exact corresponding pixel in the second image</em>, and so on.</div>
<p class="calibre2">Note that you can also use the overloaded C++ operators to achieve the same goal as the <kbd class="calibre13">compare</kbd> function. Here is how, for each individual comparison type:</p>
<pre class="calibre33">result = image1 == image2; // CMP_EQ 
result = image1 &gt; image2; // CMP_GT 
result = image1 &gt;= image2; // CMP_GE 
result = image1 &lt; image2; // CMP_LT 
result = image1 &lt;= image2; // CMP_LE 
result = image1 != image2; // CMP_NE </pre>
<p class="calibre2">The <kbd class="calibre13">inRange</kbd> function, which is another useful comparison function in OpenCV, can be used to find the pixels that have a value between a certain lower bound, and higher bound values. You can use any existing image as the boundary value matrices, or you can create them by yourself. Here's an example code that can be used to find the pixel values between <kbd class="calibre13">0</kbd> and <kbd class="calibre13">50</kbd> in a grayscale image:</p>
<pre class="calibre33">Mat lb = Mat::zeros(image.rows, 
                    image.cols, 
                    image.type()); 
Mat hb = Mat::ones(image.rows, 
                   image.cols, 
                   image.type()) * 50; 
inRange(image, lb, hb, result); </pre>
<p class="calibre2">Note that <kbd class="calibre13">lb</kbd> and <kbd class="calibre13">hb</kbd> are both <kbd class="calibre13">Mat</kbd> objects of the same size and type of source image, except <kbd class="calibre13">lb</kbd> is filled with zeroes and <kbd class="calibre13">hb</kbd> is filled with the value of <kbd class="calibre13">50</kbd>. This way, when <kbd class="calibre13">inRange</kbd> is called, it checks each individual pixel in the source image with their corresponding pixels in <kbd class="calibre13">lb</kbd> and <kbd class="calibre13">hb</kbd> and sets the corresponding pixel in the result to white if the value fits between the provided boundaries.</p>
<p class="calibre2">The following image depicts the result of the <kbd class="calibre13">inRange</kbd> function when it is executed on our example image:</p>
<div class="cdpaligncenter"><img src="../images/00029.gif" class="calibre51"/></div>
<p class="calibre2">The <kbd class="calibre13">min</kbd> and <kbd class="calibre13">max</kbd> functions, as it can be easily guessed from their names, are two other comparison functions that can be used to compare two images (element-wise) and find out the minimum or maximum pixel values. Here's an example:</p>
<pre class="calibre33">min(image1, image2, result); </pre>
<p class="calibre2">Or you can use <kbd class="calibre13">max</kbd> to find the maximum:</p>
<pre class="calibre33">max(image1, image2, result); </pre>
<p class="calibre2">Simply put, these two functions compare the pixels of two images of the same size and type and set the corresponding pixel in the result matrix to the minimum or maximum pixel value from the input images.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The mathematical operations</h1>
                
            
            <article>
                
<p class="calibre2">Besides the functions we've learned about so far, OpenCV also provides a number of functions to deal with element-wise mathematical operations. In this section, we're going to go through them briefly, but you can, and you should experiment with them by yourself to make sure that you're familiar with them, and you can comfortably use them in your projects.</p>
<p class="calibre2">The element-wise mathematical functions in OpenCV are as follows:</p>
<ul class="calibre10">
<li class="calibre11">The <kbd class="calibre13">absdiff</kbd> function can be used to calculate the absolute difference between the pixels of two images of the same size and type or an image and a scalar. Here's an example:</li>
</ul>
<pre class="calibre30">absdiff(image1, image2, result);</pre>
<p class="calibre31">In the preceding code, <kbd class="calibre13">image1</kbd>, <kbd class="calibre13">image2</kbd>, and <kbd class="calibre13">result</kbd> are all <kbd class="calibre13">Mat</kbd> objects, and each element in the result represents the absolute difference between corresponding pixels in <kbd class="calibre13">image1</kbd> and <kbd class="calibre13">image2</kbd>.</p>
<ul class="calibre10">
<li class="calibre11">The <kbd class="calibre13">exp</kbd> function can be used to calculate the exponential of all elements in a matrix:</li>
</ul>
<pre class="calibre30">exp(mat, result); </pre>
<ul class="calibre10">
<li class="calibre11">The <kbd class="calibre13">log</kbd> function can be used to calculate the natural logarithm of every element in a matrix:</li>
</ul>
<pre class="calibre30">log(mat, result); </pre>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">pow</kbd> can be used to raise all of the elements in a matrix to a given power. This function requires a matrix and a <kbd class="calibre13">double</kbd> value that will be the power value. Here's an example:</li>
</ul>
<pre class="calibre30">pow(mat, 3.0, result); </pre>
<ul class="calibre10">
<li class="calibre11">The <kbd class="calibre13">sqrt</kbd> function is used to calculate the square root of all elements in a matrix, and it's used as follows:</li>
</ul>
<pre class="calibre30">sqrt(mat, result); </pre>
<div class="packt_infobox">Functions such as <kbd class="calibre29">log</kbd> and <kbd class="calibre29">pow</kbd> should not be confused with the functions of the same name in standard C++ libraries. For better readability of your code, consider using the <kbd class="calibre29">cv</kbd> namespace before the function name in your C++ code. For instance, you can call the <kbd class="calibre29">pow</kbd> function as follows:<br class="calibre41"/>
<kbd class="calibre29">cv::pow(image1, 3.0, result);</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matrix and array-wise operations</h1>
                
            
            <article>
                
<p class="calibre2">Unlike the functions and algorithms that we've seen so far in this chapter, the algorithms in this section perform an atomic and complete operation on the image (or matrix) itself and are not considered element-wise operations in the sense that has been described so far. If you recall, the rule of thumb for element-wise operations was that they can be easily parallelized since the resulting matrix is dependent on corresponding pixels of two images, whereas the functions and algorithms we'll learn about in this chapter are not easily parallelizable, or the resulting pixels and values might have little or nothing at all to do with their corresponding source pixels, or quite the opposite, the resulting pixels might depend on some or all of the input pixels at the same time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Making borders for extrapolation</h1>
                
            
            <article>
                
<p class="calibre2">As you'll see in this and upcoming chapters, one of the most important issues to handle when dealing with many computer vision algorithms is extrapolation, or to put it simply, the assumption of the non-existing pixels outside of an image. You might be wondering, why would I need to think about the non-existing pixels, and the simplest answer is that there are many computer vision algorithms that work with not just a single pixel, but also with their surrounding pixels. In such cases, when the pixel is in the middle of an image, there are no issues. But for the pixels at the borders of the image (for instance, in the topmost row), some of the surrounding pixels will fall outside of the image. That is exactly where you need to think about extrapolation and the assumption of non-existing pixels. Are you going to simply assume those pixels have zero values? Maybe it's better to assume they have the same value as the border pixels? These questions are all taken care of in an OpenCV function called <kbd class="calibre13">copyMakeBorder</kbd>.</p>
<p class="calibre2"><kbd class="calibre13">copyMakeBorder</kbd> allows us to form borders outside an image and provides enough customizations to deal with all possible scenarios. Let's see how <kbd class="calibre13">copyMakeBorder</kbd> is used with a couple of simple examples:</p>
<pre class="calibre33">int top = 50; 
int bottom = 50; 
int left = 50; 
int right = 50; 
BorderTypes border = BORDER_REPLICATE; 
copyMakeBorder(image, 
               result, 
               top, 
               bottom, 
               left, 
               right, 
               border); </pre>
<p class="calibre2">As seen in the preceding example, <kbd class="calibre13">copyMakeBorder</kbd> accepts an input image and produces a <kbd class="calibre13">result</kbd> image, just like most of the OpenCV functions we've learned about so far. In addition, this function must be provided with four integer values that represent the number of pixels that are added to the <kbd class="calibre13">top</kbd>, <kbd class="calibre13">bottom</kbd>, <kbd class="calibre13">left</kbd>, and <kbd class="calibre13">right</kbd> side of the image. However, the most important parameter that must be provided here is the <kbd class="calibre13">border</kbd> type parameter, which must be an entry of the <kbd class="calibre13">BorderTypes</kbd> enum. Here are a few of the most commonly used <kbd class="calibre13">BorderType</kbd> values:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">BORDER_CONSTANT</kbd></li>
<li class="calibre11"><kbd class="calibre13"><kbd class="calibre52">BORDER_REPLICATE</kbd></kbd></li>
<li class="calibre11"><kbd class="calibre13">BORDER_REFLECT</kbd></li>
<li class="calibre11"><kbd class="calibre13">BORDER_WRAP</kbd></li>
</ul>
<p class="calibre2">Note that when <kbd class="calibre13">BORDER_CONSTANT</kbd> is used as the border type parameter, an additional scalar parameter must be provided to the <kbd class="calibre13">copyMakeBorder</kbd> function, which represents the constant color value of the created border. If this value is omitted, zero (or black) is assumed. The following image demonstrates the output of the <kbd class="calibre13">copyMakeBorder</kbd> function when it is executed on our example image:</p>
<div class="cdpaligncenter"><img src="../images/00030.jpeg" class="calibre53"/></div>
<p class="calibre2"><kbd class="calibre13">copyMakeBorder</kbd>, and many other OpenCV functions, use the <kbd class="calibre13">borderInterpolate</kbd> function, internally, to calculate the position of the donor pixel used for the extrapolation and creating the non-existing pixels. You won't need to call this function directly yourself, so we'll leave it for you to explore and discover on your own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Flipping (mirroring) and rotating images</h1>
                
            
            <article>
                
<p class="calibre2">You can use the <kbd class="calibre13">flip</kbd> function to flip or mirror an image. This function can be used to flip an image around the <em class="calibre7">x</em> or <em class="calibre7">y</em> axes, or both, depending on the provided flip <kbd class="calibre13">code</kbd>. Here's how this function is used:</p>
<pre class="calibre15">int code = +1; 
flip(image, result, code);</pre>
<p class="calibre2">If <kbd class="calibre13">code</kbd> is zero, the input image will be flipped/mirrored vertically (around the <em class="calibre7">x</em> axis), if <kbd class="calibre13">code</kbd> is a positive value, the input image will be flipped/mirrored horizontally (around the <em class="calibre7">y</em> axis), and if <kbd class="calibre13">code</kbd> is a negative value, the input image will be flipped/mirrored around both the <em class="calibre7">x</em> and <em class="calibre7">y</em> axes at the same time.</p>
<p class="calibre2">On the other hand, to rotate an image, you can use the <kbd class="calibre13">rotate</kbd> function. What you need to take care of, when calling the <kbd class="calibre13">rotate</kbd> function, is providing a correct rotation flag, as seen in the following example:</p>
<pre class="calibre15">RotateFlags rt = ROTATE_90_CLOCKWISE; 
rotate(image, result, rt); </pre>
<p class="calibre2">The <kbd class="calibre13">RotateFlag</kbd> enum can be one of the following self-explanatory constant values:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">ROTATE_90_CLOCKWISE</kbd></li>
<li class="calibre11"><kbd class="calibre13">ROTATE_180</kbd></li>
<li class="calibre11"><kbd class="calibre13">ROTATE_90_COUNTERCLOCKWISE</kbd></li>
</ul>
<p class="calibre2">Here's an image that depicts all possible results of the <kbd class="calibre13">flip</kbd> and <kbd class="calibre13">rotate</kbd> functions. Notice that the result of flip around both axes is the same as a 180-degree rotation in the following resulting images:</p>
<div class="cdpaligncenter"><img src="../images/00031.jpeg" class="calibre54"/></div>
<div class="packt_infobox">As mentioned previously in this chapter, <kbd class="calibre29">Mat::t</kbd>, or the transpose of a matrix, can also be used to rotate an image when used in conjunction with the <kbd class="calibre29">flip</kbd> function.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Working with channels</h1>
                
            
            <article>
                
<p class="calibre2">OpenCV provides a handful of functions to deal with channels, whether we need to merge, split, or perform various actions on them. In this section, we're going to learn how to split an image to its consisting channels or make a multi-channel image using multiple single-channel images. So, let's start.</p>
<p class="calibre2">You can use the <kbd class="calibre13">merge</kbd> function to merge a number of single-channel <kbd class="calibre13">Mat</kbd> objects and create a new multi-channel <kbd class="calibre13">Mat</kbd> object, as seen in the following sample code:</p>
<pre class="calibre33">Mat channels[3] = {ch1, ch2, ch3}; 
merge(channels, 3, result); </pre>
<p class="calibre2">In the preceding code, <kbd class="calibre13">ch1</kbd>, <kbd class="calibre13">ch2</kbd>, and <kbd class="calibre13">ch3</kbd> are all single-channel images of the same size. The result will be a three-channel <kbd class="calibre13">Mat</kbd> object.</p>
<p class="calibre2">You can also use the <kbd class="calibre13">insertChannel</kbd> function to insert a new channel into an image. Here's how:</p>
<pre class="calibre33">int idx = 2; 
insertChannel(ch, image, idx); </pre>
<p class="calibre2">In the preceding code, <kbd class="calibre13">ch</kbd> is a single channel <kbd class="calibre13">Mat</kbd> object, <kbd class="calibre13">image</kbd> is the matrix we want to add an additional channel into it, and <kbd class="calibre13">idx</kbd> refers to the zero-based index number of the position where the channel will be inserted.</p>
<p class="calibre2">The <kbd class="calibre13">split</kbd> function can be used to perform exactly the opposite of the <kbd class="calibre13">merge</kbd> function, which is splitting a multi-channel image to create a number of single-channel images. Here's an example:</p>
<pre class="calibre33">Mat channels[3]; 
split(image, channels); </pre>
<p class="calibre2">The <kbd class="calibre13">channels</kbd> array in the preceding code will contain three single-channel images of the same size that correspond to each individual channel in the image.</p>
<p class="calibre2">To be able to extract a single channel from an image, you can use the <kbd class="calibre13">extractChannel</kbd> function:</p>
<pre class="calibre33">int idx = 2; 
Mat ch; 
extractChannel(image, ch, idx); </pre>
<p class="calibre2">In the preceding code, quite obviously, the channel at position <kbd class="calibre13">idx</kbd> will be extracted from the image and saved in <kbd class="calibre13">ch</kbd>.</p>
<p class="calibre2">Even though <kbd class="calibre13">merge</kbd>, <kbd class="calibre13">split</kbd>, <kbd class="calibre13">insertChannel</kbd>, and <kbd class="calibre13">extractChannel</kbd> are enough for most use cases, you still might need a more complex shuffling, extraction, or manipulation of the channels in an image. For this reason, OpenCV provides a function called <kbd class="calibre13">mixChannels</kbd>, which allows a much more advanced way of handling channels. Let's see how <kbd class="calibre13">mixChannels</kbd> is used with an example case. Let's say we want to shift all of the channels of an image to the right. To be able to perform such a task, we can use the following sample code:</p>
<pre class="calibre33">Mat image = imread("Test.png"); 
Mat result(image.rows, image.cols, image.type()); 
 
vector&lt;int&gt; fromTo = {0,1, 
                      1,2, 
                      2,0}; 
mixChannels(image, result, fromTo); </pre>
<p class="calibre2">The only important piece of code in the preceding example is the <kbd class="calibre13">fromTo</kbd> vector, which must contain pairs of values that correspond to the channel number in the source and destination. The channels are, as always, 0-index based, so 0, 1 means the first channel in the source image will be copied to the second channel in the result and so on.</p>
<div class="packt_infobox">It's worth noting that all previous functions in this section (merge, split, and so on), are a partial case of the <kbd class="calibre29">mixChannels</kbd> function.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mathematical functions</h1>
                
            
            <article>
                
<p class="calibre2">The functions and algorithms that we'll learn about in this section are solely used for mathematical calculations of a non-element-wise nature, as opposed to what we saw earlier on in this chapter. They include simple functions, such as <kbd class="calibre13">mean</kbd> or <kbd class="calibre13">sum</kbd> or more complex operations, such as the discrete Fourier transform. Let's browse through some of the most important ones with hands-on examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matrix inversion</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">invert</kbd> function can be used to calculate the inverse of a matrix. This should not to be confused with the <kbd class="calibre13">bitwise_not</kbd> function, which inverts each and every bit in the pixels of an image. The <kbd class="calibre13">invert</kbd> function is not an element-wise function, and the inversion method needs to be provided as a parameter to this function. Here's an example:</p>
<pre class="calibre33">DecompTypes dt = DECOMP_LU; 
invert(image, result, dt); </pre>
<p class="calibre2">The <kbd class="calibre13">DecompTypes</kbd> enum contains all possible entries that can be used in the <kbd class="calibre13">invert</kbd> function as the decomposition type. Here they are:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">DECOMP_LU</kbd></li>
<li class="calibre11"><kbd class="calibre13">DECOMP_SVD</kbd></li>
<li class="calibre11"><kbd class="calibre13">DECOMP_EIG</kbd></li>
<li class="calibre11"><kbd class="calibre13">DECOMP_CHOLESKY</kbd></li>
<li class="calibre11"><kbd class="calibre13">DECOMP_QR</kbd></li>
</ul>
<p class="calibre2">Refer to the OpenCV documentation for the <kbd class="calibre13">DecompTypes</kbd> enum if you're interested in a detailed description of each and every decomposition method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mean and sum of elements</h1>
                
            
            <article>
                
<p class="calibre2">You can calculate the mean, or the average value of the elements in a matrix, by using the <kbd class="calibre13">mean</kbd> function. Here is an example that shows how to read an image and calculate and display the mean value of all of its individual channels:</p>
<pre class="calibre33">Mat image = imread("Test.png"); 
Mat result; 
Scalar m = mean(image); 
cout &lt;&lt; m[0] &lt;&lt; endl; 
cout &lt;&lt; m[1] &lt;&lt; endl; 
cout &lt;&lt; m[2] &lt;&lt; endl; </pre>
<p class="calibre2">You can use the <kbd class="calibre13">sum</kbd> function exactly the same way, to calculate the sum of elements in a matrix:</p>
<pre class="calibre33">Scalar s = sum(image); </pre>
<p class="calibre2">OpenCV also includes a <kbd class="calibre13">meanStdDev</kbd> function that can be used to calculate the mean and standard deviation of all elements in the matrix at the same time. Here is an example:</p>
<pre class="calibre33">Scalar m; 
Scalar stdDev; 
meanStdDev(image, m, stdDev); </pre>
<p class="calibre2">Similar to the <kbd class="calibre13">mean</kbd> function, the <kbd class="calibre13">meanStdDev</kbd> function also calculates the results for each individual channel separately.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Discrete Fourier transformation</h1>
                
            
            <article>
                
<p class="calibre2">A discrete Fourier transformation of a 1D or 2D array, or in other words—an image, is one of the many ways to analyze an image in computer vision. The interpretation of the result depends completely on the field it is being used for and that is not what we are concerned with in this book, however, how to perform a discrete Fourier transformation is what we're going to learn in this section.</p>
<p class="calibre2">Simply put, you can use the <kbd class="calibre13">dft</kbd> function to calculate the Fourier transformation of an image. However, there are some preparations needed before the <kbd class="calibre13">dft</kbd> function can be safely called. The same applies to the result of the Fourier transformation. Let's break this down with an example code, and by calculating and displaying the Fourier transformation of our example image used in the previous sections.</p>
<p class="calibre2">The <kbd class="calibre13">dft</kbd> function can process matrices of certain sizes (powers of 2, such as 2, 4, and 8) a lot more efficiently, that is why it is always best to increase the size of our matrix to the nearest optimum size and pad it with zeroes before calling the <kbd class="calibre13">dft</kbd> function. This can be done by using the <kbd class="calibre13">getOptimalDFTSize</kbd> function. Assuming that <kbd class="calibre13">image</kbd> is the input image that we want to calculate its discrete Fourier transformation, we can write the following code to calculate and resize it to the optimum size for the <kbd class="calibre13">dft</kbd> function:</p>
<pre class="calibre33">int optRows = getOptimalDFTSize( image.rows ); 
int optCols = getOptimalDFTSize( image.cols ); 
 
Mat resizedImg; 
copyMakeBorder(image, 
               resizedImg, 
               0, 
               optRows - image.rows, 
               0, 
               optCols - image.cols, 
               BORDER_CONSTANT, 
               Scalar::all(0)); </pre>
<p class="calibre2">As you can see, the <kbd class="calibre13">getOptimalDFTSize</kbd> function must be called twice, for rows and columns separately. You are already familiar with the <kbd class="calibre13">copyMakeBorder</kbd> function. Resizing an image and padding the new pixels with zeroes (or any other desired value) is one of countless example use cases for the <kbd class="calibre13">copyMakeBorder</kbd> function.</p>
<p class="calibre2">The rest is quite easy, we need to form a two-channel image and pass it to the <kbd class="calibre13">dft</kbd> function and get the complex (real and imaginary) result in the same matrix. This will later simplify the process of displaying the result. Here's how it's done:</p>
<pre class="calibre33">vector&lt;Mat&gt; channels = {Mat_&lt;float&gt;(resizedImg), 
                   Mat::zeros(resizedImg.size(), CV_32F)}; 
 
Mat complexImage; 
merge(channels, complexImage); 
 
dft(complexImage, complexImage); </pre>
<p class="calibre2">We have already learned how to use the <kbd class="calibre13">merge</kbd> function. The only important thing to note in the preceding code is the fact that the result is saved into the same image as the input. <kbd class="calibre13">complexImage</kbd> now contains two channels, one for the real and the other for the imaginary part of the discrete Fourier transformation. That's it! We now have our result, however, to be able to display it, we must calculate the magnitude of the result. Here's how it's done:</p>
<pre class="calibre33">split(complexImage, channels); 
 
Mat mag; 
magnitude(channels[0], channels[1], mag); </pre>
<p class="calibre2">In the preceding code, we have split the complex result into its consisting channels and then calculated the magnitude using the <kbd class="calibre13">magnitude</kbd> function. Theoretically, <kbd class="calibre13">mag</kbd> is a displayable result, but in reality, it contains values much higher than what is displayable using OpenCV, so we need to perform a couple of conversions before being able to display it. First, we need to make sure the result is in the logarithmic scale, by performing the following conversion:</p>
<pre class="calibre33">mag += Scalar::all(1); 
log(mag, mag); </pre>
<p class="calibre2">Next, we must make sure the result values are scaled and normalized to fit between <kbd class="calibre13">0.0</kbd> and <kbd class="calibre13">1.0</kbd>, to be displayable by the <kbd class="calibre13">imshow</kbd> function in OpenCV. You need to use the <kbd class="calibre13">normalize</kbd> function for this reason:</p>
<pre class="calibre33">normalize(mag, mag, 0.0, 1.0, CV_MINMAX);</pre>
<p class="calibre2">You can now try to display the result using the <kbd class="calibre13">imshow</kbd> function. Here's an example that displays the result of the discrete Fourier transformation:</p>
<div class="cdpaligncenter"><img src="../images/00032.gif" class="calibre55"/></div>
<p class="calibre2">The problem with this result is that the quadrants need to be swapped before the origin of the result is at the center of the image. The following image depicts how the four quadrants of the result must be swapped before the result has an origin point at the center:</p>
<div class="cdpaligncenter"><img src="../images/00033.jpeg" class="calibre56"/></div>
<p class="calibre2">The following is the code needed to swap the four quadrants of the Fourier transform result. Notice how we first find the center of the result, then create four <strong class="calibre4">region of interest</strong> (<strong class="calibre4"><span class="calibre12">ROI</span></strong>) matrices, and then swap them:</p>
<pre class="calibre33">int cx = mag.cols/2; 
int cy = mag.rows/2; 
 
Mat Q1(mag, Rect(0, 0, cx, cy)); 
Mat Q2(mag, Rect(cx, 0, cx, cy)); 
Mat Q3(mag, Rect(0, cy, cx, cy)); 
Mat Q4(mag, Rect(cx, cy, cx, cy)); 
 
Mat tmp; 
Q1.copyTo(tmp); 
Q4.copyTo(Q1); 
tmp.copyTo(Q4); 
 
Q2.copyTo(tmp); 
Q3.copyTo(Q2); 
tmp.copyTo(Q3); </pre>
<p class="calibre2">The <kbd class="calibre13">dft</kbd> function accepts an additional parameter that can be used to further customize its behavior. This parameter can be a combination of values from the <kbd class="calibre13">DftFlags</kbd> enum. For instance, to perform an inverse Fourier transformation, you need to call the <kbd class="calibre13">dft</kbd> function with the <kbd class="calibre13">DFT_INVERSE</kbd> parameter:</p>
<pre class="calibre15">dft(input, output, DFT_INVERSE); </pre>
<p class="calibre2">This can also be done by using the <kbd class="calibre13">idft</kbd> function:</p>
<pre class="calibre33">idft(input, output); </pre>
<p class="calibre2">Make sure to check out the <kbd class="calibre13">DftFlags</kbd> enum and the <kbd class="calibre13">dft</kbd> function documentation for more information about how the discrete Fourier transform is implemented in OpenCV.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Generating random numbers</h1>
                
            
            <article>
                
<p class="calibre2">Random number generation is one of the most widely used algorithms in computer vision, especially when it comes to testing an existing algorithm with random values between given ranges. When using the OpenCV library, you can use the following functions to produce values or matrices containing random values:</p>
<ul class="calibre10">
<li class="calibre11">The <kbd class="calibre13">randn</kbd> function can be used to fill a matrix or an array with random numbers with a given mean value and standard deviation. Here's how this function is used:</li>
</ul>
<pre class="calibre30">randn(rmat, mean, stddev); </pre>
<ul class="calibre10">
<li class="calibre11">The <kbd class="calibre13">randu</kbd> function, similar to the <kbd class="calibre13">randn</kbd> function, is used to fill an array with random values, however, instead of mean and standard deviation, this function uses a lower band and higher band (both inclusive) for the produced random values. Here's an example:</li>
</ul>
<pre class="calibre30">randu(rmat, lowBand, highBand);</pre>
<ul class="calibre10">
<li class="calibre11">The <kbd class="calibre13">randShuffle</kbd> function, as it can be guessed from its title, is used to randomly shuffle the contents of an array or matrix. It is used as simply as it is depicted in the following example:</li>
</ul>
<pre class="calibre30">randShuffle(array); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The search and locate functions</h1>
                
            
            <article>
                
<p class="calibre2">When working on your computer vision projects, you'll be faced with countless scenarios and cases in which you'll need to look for certain pixels, or the maximum values (brightest point), and so on. The OpenCV library contains a number of functions that can be used for this same purpose, and they are the subject of this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Locating non-zero elements</h1>
                
            
            <article>
                
<p class="calibre2">Locating, or counting, non-zero elements can come in quite handy, especially when looking for specific regions in an image after a threshold operation, or when looking for the area covered by a specific color. OpenCV contains the <kbd class="calibre13">findNonZero</kbd> and <kbd class="calibre13">countNonZero</kbd> functions, which simply allow you to find or count the pixels with non-zero (or bright) values in an image.</p>
<p class="calibre2">Here is an example that depicts how you can use the <kbd class="calibre13">findNonZero</kbd> function to find the first non-black pixel in a grayscale image and print its position:</p>
<pre class="calibre33">Mat image = imread("Test.png", IMREAD_GRAYSCALE); 
Mat result; 
vector&lt;Point&gt; idx; 
findNonZero(image, idx); 
if(idx.size() &gt; 0) 
    cout &lt;&lt; idx[0].x &lt;&lt; "," &lt;&lt; idx[0].y &lt;&lt; endl; </pre>
<p class="calibre2">Here is another example code that shows how you can find the percentage of black pixels in a grayscale image:</p>
<pre class="calibre33">Mat image = imread("Test.png", IMREAD_GRAYSCALE); 
Mat result; 
int nonZero = countNonZero(image); 
float white = float(nonZero) / float(image.total()); 
float black = 1.0 - white; 
cout &lt;&lt; black &lt;&lt; endl;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Locating minimum and maximum elements</h1>
                
            
            <article>
                
<p class="calibre2">Locating the brightest (maximum) and darkest (minimum) points in an image or matrix are two of the most important types of searches within images in computer vision, especially after performing certain types of thresholding algorithms, or template-matching functions (which we'll learn about in the upcoming chapters). OpenCV provides the following two functions to locate global minimum and maximum values, along with their positions is a matrix:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">minMaxIdx</kbd></li>
<li class="calibre11"><kbd class="calibre13">minMaxLoc</kbd></li>
</ul>
<p class="calibre2">The <kbd class="calibre13">minMaxLoc</kbd> function searches the whole image (only single-channel images) for the brightest and darkest points and returns the value of the brightest and darkest pixel, along with their positions, whereas the <kbd class="calibre13">minMaxIdx</kbd> function returns a pointer to the found minimum and maximum position, instead of a position (the <kbd class="calibre13">Point</kbd> object with <em class="calibre7">x</em> and <em class="calibre7">y</em>). Here's how the <kbd class="calibre13">minMaxLoc</kbd> function is used:</p>
<pre class="calibre33">double minVal, maxVal; 
Point minLoc, maxLoc; 
minMaxLoc(image, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc); </pre>
<p class="calibre2">This is an example of using the <kbd class="calibre13">minMaxIdx</kbd> function:</p>
<pre class="calibre33">double minVal, maxVal; 
int minIdx, maxIdx; 
minMaxIdx(image, &amp;minVal, &amp;maxVal, &amp;minIdx, &amp;maxIdx); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Lookup table transformation</h1>
                
            
            <article>
                
<p class="calibre2">In computer vision, replacing pixels with new values based on their value from a given table that contains the required replacement is called <strong class="calibre4">lookup table transformation</strong>. This might sound a bit confusing at first but it's a very powerful and simple method for modifying images using lookup tables. Let's see how it's done with a hands-on example.</p>
<p class="calibre2">Let's assume we have an example image and we need to replace the bright pixels (with a value greater than <kbd class="calibre13">175</kbd>) with absolute white, dark pixels (with a value less than <kbd class="calibre13">125</kbd>) with absolute black, and leave the rest of the pixels as they are. To perform such a task, we can simply use a lookup table <kbd class="calibre13">Mat</kbd> object along with the <kbd class="calibre13">LUT</kbd> function in OpenCV:</p>
<pre class="calibre33">Mat lut(1, 256, CV_8UC1); 
for(int i=0; i&lt;256; i++) 
{ 
    if(i &lt; 125) 
        lut.at&lt;uchar&gt;(0, i) = 0; 
    else if(i &gt; 175) 
        lut.at&lt;uchar&gt;(0, i) = 255; 
    else 
        lut.at&lt;uchar&gt;(0, i) = i; 
} 
 
Mat result; 
LUT(image, lut, result); </pre>
<p class="calibre2">The following image depicts the result of this lookup table transformation when it is executed on our example image. As you can see, the lookup table transformation can be executed on both color (on the right) and grayscale (on the left) images:</p>
<div class="cdpaligncenter"><img src="../images/00034.jpeg" class="calibre57"/></div>
<p class="calibre2">Using the <kbd class="calibre13">LUT</kbd> function wisely can lead to many creative solutions for computer vision problems where replacing pixels with a given value is desired.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">What we saw in this chapter was a taste of what can be done using matrix and array operations in computer vision with the OpenCV library. We started the chapter with nothing but a firm background in the fundamental concepts of computer vision from the previous chapters, and we ended up learning about lots of algorithms and functions using hands-on examples. We learned about ones, zeroes, identity matrix, transpose, and other functions embedded into the heart of the <kbd class="calibre13">Mat</kbd> class. Then, we continued on to learn about many element-wise algorithms. We are now totally capable of performing element-wise matrix operations, such as basic operations, comparisons, and bitwise operations. Finally, we learned about the non-element-wise operations in the OpenCV core module. Making borders, modifying channels, and discrete Fourier transformation were among the many algorithms we learned to use in this chapter.</p>
<p class="calibre2">In the next chapter, we're going to learn about computer vision algorithms used for filtering, drawing, and other functions. Topics covered in the upcoming chapter are essential before you step into the world of advanced computer vision development and algorithms used for highly complex tasks, such as face or object detection and tracking.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Questions</h1>
                
            
            <article>
                
<ol class="calibre14">
<li value="1" class="calibre11">Which of the element-wise mathematical operations and bitwise operations would produce the exact same results?</li>
<li value="2" class="calibre11">What is the purpose of the <kbd class="calibre13">gemm</kbd> function in OpenCV? What is the equivalent of <kbd class="calibre13">A*B</kbd> with the <kbd class="calibre13">gemm</kbd> function?</li>
<li value="3" class="calibre11">Use the <kbd class="calibre13">borderInterpolate</kbd> function to calculate the value of a non-existing pixel at point <kbd class="calibre13">(-10, 50)</kbd>, with a border type of <kbd class="calibre13">BORDER_REPLICATE</kbd>. What is the function call required for such a calculation?</li>
<li value="4" class="calibre11">Create the same identity matrix as in the <em class="calibre26">Learning about the dentity matrix</em> section of this chapter, but use the <kbd class="calibre13">setIdentity</kbd> function instead of the <kbd class="calibre13">Mat::eye</kbd> function.</li>
<li value="5" class="calibre11">Write a program using the <kbd class="calibre13">LUT</kbd> function (lookup table transformation) that performs the same task as <kbd class="calibre13">bitwise_not</kbd> (invert colors) when executed on grayscale and color (RGB) images.</li>
<li value="6" class="calibre11">Besides normalizing the values of a matrix, the <kbd class="calibre13">normalize</kbd> function can be used to brighten or darken images. Write the required function call to darken and brighten a grayscale image using the <kbd class="calibre13">normalize</kbd> function.</li>
<li value="7" class="calibre11">Remove the blue channel (first channel) from an image (BGR image created using the <kbd class="calibre13">imread</kbd> function) using the <kbd class="calibre13">merge</kbd> and <kbd class="calibre13">split</kbd> functions.</li>
</ol>


            </article>

            
        </section>
    </body></html>