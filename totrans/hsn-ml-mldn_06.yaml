- en: Classification Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With regression models behind us, it is now time to dive into classification
    models. In this chapter, we will examine the math behind classification models,
    as well as the various applications of classification models. In addition, we
    will build two new ML.NET classification applications: the first, a binary classification
    example that will predict if a car''s price is a good deal or not, akin to what
    you would find on a car purchase website; the other application, a multi-class
    classification application that categorizes emails. Finally, we will explore how
    to evaluate a classification model with the properties ML.NET exposes in classification
    models.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down classification models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a binary classification application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi-class classification application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating a classification model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking down classification models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting
    Started with Machine Learning and ML.NET*, classification is broken down into
    two main categories—two-class and multi-class. In a two-class classifier, also
    known as a binary classifier, the prediction simply returns 0 or 1\. In a multi-class
    problem, a pre-selected range of return labels, such as virus types or car types,
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several binary classification model types available in the machine
    learning ecosystem to choose from, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AveragedPerceptronTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SdcaLogisticRegressionBinaryTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SdcaNonCalibratedBinaryTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SymbolicSgdLogisticRegressionBinaryTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LbfgsLogisticRegressionBinaryTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LightGbmBinaryTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FastTreeBinaryTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FastForestBinaryTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GamBinaryTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FieldAwareFactorizationMachineTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PriorTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinearSvmTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The car-value application we will be creating later in this chapter utilizes
    the `FastTreeBinaryTrainer` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'ML.NET also provides the following multi-class classifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LightGbmMulticlassTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SdcaMaximumEntropyMulticlassTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SdcaNonCalibratedMulticlassTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LbfgsMaximumEntropyMulticlassTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NaiveBayesMulticlassTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneVersusAllTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PairwiseCouplingTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the multi-class classifier example application, we will be using the `SdcaMaximumEntropyMulticlassTrainer`
    model. The reason for this is that **Stochastic Dual Coordinate Ascents** (**SDCAs**)
    can provide a good default performance without tuning.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a classification trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the two types of classification, which should you choose? As stated earlier
    in this chapter, compared to regression models, your prediction output type will
    decide between binary and multi-class classification. Does your problem simply
    predict a value of true or false, or does it provide a more varied output based
    on a pre-defined value set? If your answer is the former, you need to use a binary
    classification. If the latter, you will need to use a multi-class classification.
    In this chapter, we will demonstrate both model prediction types.
  prefs: []
  type: TYPE_NORMAL
- en: For specific binary classification trainers, SDCA, LightGBM, and FastTree are
    the most popular options, as well as the most documented.
  prefs: []
  type: TYPE_NORMAL
- en: For specific multi-class classification trainers, LightGBM and SDCA are the
    most popular and best-documented options.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a binary classification application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the application we will be creating is a car-value predictor.
    Given a set of attributes tied to a car, one can predict if the price is a good
    deal or not. The attributes included in this example aren't a definitive list
    of attributes, nor should they be used as-is in a production environment. However,
    one could use this as a starting point for predicting a simple true-or-false answer
    based on several attributes.
  prefs: []
  type: TYPE_NORMAL
- en: As with previous chapters, the complete project code, sample dataset, and project
    files can be downloaded here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter04](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously mentioned, for this binary classification application, we will
    be using the FastTree trainer.
  prefs: []
  type: TYPE_NORMAL
- en: FastTree is based on the **Multiple Additive Regression Trees** (**MART**) gradient
    boosting algorithm. Gradient boosting is a very popular technique, in which a
    series of trees are built in a step-wise manner before ultimately selecting the
    best tree. MART takes this approach a step further by learning an ensemble of
    regression trees that use scalar values in their leaves.
  prefs: []
  type: TYPE_NORMAL
- en: The FastTree trainer doesn't require normalization but does require all of the
    feature columns to use a `float` variable type and the label column to be a `bool`
    variable type.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about MART, Cornell University has a paper from 2015 on the
    subject: [https://arxiv.org/abs/1505.01866](https://arxiv.org/abs/1505.01866.).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on the project architecture and code we created in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml),
    *Regression Model*, the major change architecturally in this example is the mechanism
    for input. For this application, since we are using the FastTree algorithm, this
    requires referencing the `Microsoft.ML.FastTree` NuGet package (version 1.3.1
    is the latest at the time of this writing).If you are building this project from
    scratch and do not remember how to add a NuGet reference, please refer back to [Chapter
    2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting Up the ML.NET Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the project. The new addition to the solution is the `testdata.csv` file,
    which we will review here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68e93a35-367b-4d5d-a63d-6e0dad029632.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sampledata.csv` file contains 18 rows of random data. Feel free to adjust
    the data to fit your own observations or to adjust the trained model. Here is
    a snippet of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each of these rows contains the value for the properties in the newly created
    `CarInventory` class that we will review later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, in this chapter, we added the `testdata.csv` file that contains
    additional data points to test the newly trained model against and evaluate. Here
    is a snippet of the data inside of `testdata.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Diving into the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this application, as noted in the previous section, we are building on top
    of the work completed in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml),
    *Regression Model*. For this deep dive, we are going to focus solely on the code
    that was changed for this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes that were changed or added are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CarInventory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CarInventoryPrediction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Predictor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CarInventory class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CarInventory` class is the container class that contains the data to both
    predict and train our model. These columns map in order of the sample data reviewed
    previously. If you begin experimenting with new features and add to the following
    class, ensure you increment the array index appropriately, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The CarInventoryPrediction class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CarInventoryPrediction` class contains the properties mapped to our prediction
    output, in addition to the `Score` and `Probability` properties used for model
    evaluation. The `PredictedLabel` property contains our classification result,
    not the label as in previous chapters, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Predictor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a couple of changes in this class to handle the employment-prediction
    scenario, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is in the prediction call itself. As you probably guessed,
    the `TSrc` and `TDst` arguments need to be adjusted to utilize both of the new
    classes we created, `CarInventory` and `CarInventoryPrediction`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we are no longer simply passing in the string and building an object
    on the fly, we need to first read in the file as text. We then deserialize the
    JSON into our `CarInventory`object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to adjust the output of our prediction to match our new `CarInventoryPrediction`properties,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Trainer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `Trainer` class, several modifications need to be made to support
    binary classification, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is the check to ensure the test filename exists, shown in
    the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then build the data process pipeline using the `NormalizeMeanVariance` transform
    method we used in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression
    Model*,on the inputted values, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create the `FastTree` trainer with the label from the `CarInventory`
    class and the normalized mean variance, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Later on, after you have run the application, consider tweaking the number of
    leaves and the number of trees to see how both the model metrics and your prediction
    probability percentage change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we call the `Regression.Evaluate` method to provide regression-specific
    metrics, followed by a `Console.WriteLine` call to provide these metrics to your
    console output. We will go into detail about what each of these means in the last
    section of the chapter, but for now, the code can be seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we evaluate the model we just trained, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we output all of the classification metrics. We will detail each of
    these in the next section, but for now, the code can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Program class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only change in the `Program` class is the help text to indicate usage for
    the trainer to accept the test file, shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we modify the `switch`/`case` statement to support the additional
    parameter to the `Train` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the application, the process is nearly identical to the sample application
    in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression Model*,
    with the addition of passing in the test dataset when training, described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the training on the command line, as we did in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml),
    *Getting Started with Machine Learning and ML.NET*, we simply pass in the following
    command (assuming you are using the included sample dataset and test dataset):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note the expanded output to include several metric data points—we will go through
    what each one of these means at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'After training the model, build a sample JSON file and save it as `input.json`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the model with this file, simply pass in the filename to the built application,
    and the predicted output will appear, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to modify the values and see how the prediction changes based on
    the dataset on which the model was trained. A few areas of experimentation from
    this point might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add some additional features based on your own car-buying experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `sampledata.csv` file to include your own car-buying experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the sample application to have a **graphical user interface** (**GUI**)
    to make running predictions easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi-class classification application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we will now create a multi-class classification application,
    categorizing email into one of three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Friend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flushing out this example for a production application would more than likely
    include significantly more categories in addition to more features. However, this
    is a good starting point to demonstrate a multi-class classification use case.
  prefs: []
  type: TYPE_NORMAL
- en: As with other examples, the complete project code, sample dataset, and project
    files can be downloaded here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter04-multiclass](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter04-multiclass).
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously mentioned, for this multi-class classification application we
    will be using the `SdcaMaximumEntropy` trainer.
  prefs: []
  type: TYPE_NORMAL
- en: The `SdcaMaximumEntropy` class, as the name implies, is based on the SDCA we
    deep dove into in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression
    Model*, and uses empirical risk minimization, which optimizes based on the training
    data. This does leave a potential for outliers or anomalies to greatly affect
    the predict performance. Therefore, when using this trainer, provide the trainer
    with ample sampling of expected data, to avoid both overfitting and potential
    errors when predicting data.
  prefs: []
  type: TYPE_NORMAL
- en: The `SdcaMaximumEntropy` trainer, unlike the previous binary classification
    example, does require normalization. In addition, caching is not required; however,
    we do utilize caching when building the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on the project architecture and code created earlier in this chapter,
    there are no new NuGet packages to include in this project, as SDCA trainers are
    considered core trainers. The major change is in the `Training` pipeline, which
    we will go into in further detail later on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7df2ac8b-d10d-460b-9d8a-5cfde49e58b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sampledata.csv` file contains six rows of random data. Feel free to adjust
    the data to fit your own observations or to adjust the trained model. Here is
    a snippet of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Each of these rows contains the value for the properties in the newly created
    `Email` class that we will review later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, in this chapter, we added the `testdata.csv` file that contains
    additional data points to test the newly trained model against. Here is a snippet
    of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Diving into the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this application, as noted earlier, we are building on top of the work completed
    in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression Model*.
    For this deep dive, we are going to focus solely on the code that was changed
    for this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes that were changed or added are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailPrediction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Predictor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Email class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Email` class is the container class that contains the data to both predict
    and train our model. These columns map in order to the sample data reviewed previously.
    If you begin experimenting with new features and add to this list, ensure you
    increment the array index appropriately, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The EmailPrediction class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EmailPrediction` class contains the property mapped to our prediction
    output used for model evaluation. In the following code block, we are returning
    the `Category` value (string value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Predictor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a couple of changes in this class to handle the email categorization
    prediction scenario, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is in the prediction call itself. As you probably guessed,
    the `TSrc` and `TDst` arguments need to be adjusted to utilize both of the new
    classes we created, `Email` and `EmailPrediction`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we are no longer simply passing in the string and building an object
    on the fly, we need to first read in the file as text. We then deserialize the
    JSON into our `Email`object, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to adjust the output of our prediction to match our new `EmailPrediction`properties,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The Trainer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a couple of changes in this class to handle the email categorization
    prediction scenario, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we read in the `trainingFileName` string and typecast it to an `Email`
    object, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create our pipeline mapping our input properties to `FeaturizeText`
    transformations before appending our SDCA trainer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we load in our test data, run the `MultiClassClassification` evaluation,
    and then output the four model evaluation properties, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the application, the process is nearly identical to the sample application
    in [Chapter 3](8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml), *Regression Model*,
    with the addition of passing in the test dataset when training:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the training on the command line as we did in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml),
    *Getting Started with Machine Learning and ML.NET*, simply pass in the following
    command (assuming you are using the included sample dataset and test dataset):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note the expanded output to include several metric data points—we will go through
    what each one of these means at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'After training the model, build a sample JSON file and save it as `input.json`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the model with this file, simply pass in the filename to the built application,
    and the predicted output will show, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to modify the values and see how the prediction changes based on
    the dataset on which the model was trained. A few areas of experimentation from
    this point might be to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more sample and test data based on your own emails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add more categories based on your own emails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand the features, such as the date of sending, and the IP address of the
    sender.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating a classification model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in previous chapters, evaluating a model is a critical part of
    the overall model-building process. A poorly trained model will only provide inaccurate
    predictions. Fortunately, ML.NET provides many popular attributes to calculate
    model accuracy, based on a test set at the time of training, to give you an idea
    of how well your model will perform in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ML.NET, as noted earlier in the sample applications, there are several properties
    that comprise the `CalibratedBinaryClassificationMetrics` class object. In [Chapter
    2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting Up the ML.NET Environment*,
    we reviewed some of these properties. However, now that we have a more complex
    example and have learned how to evaluate regression models, let us dive into the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area Under ROC Curve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F1 Score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area Under Precision-Recall Curve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, we will also look at the following four metrics returned by the
    `MulticlassClassificationMetrics` object used in the multi-class classification
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Micro Accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macro Accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log Loss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log-Loss Reduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections, we will break down how these values are calculated, and
    detail the ideal values to look for.
  prefs: []
  type: TYPE_NORMAL
- en: Accuracy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accuracy is the proportion of correct predictions to incorrect predictions in
    the test dataset.
  prefs: []
  type: TYPE_NORMAL
- en: You will want to be as close to a value of 100%, but not exactly 100%. As seen
    in our binary classification example, we received 88.89%—close to 100%, but not
    quite. If you see a 100% score when experimenting, you are more than likely seeing
    a case of overfitting.
  prefs: []
  type: TYPE_NORMAL
- en: Area Under ROC Curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Area Under ROC Curve, also commonly referred to as AUC, is the measurement of
    the area under the curve.
  prefs: []
  type: TYPE_NORMAL
- en: As with Accuracy, a value close to 100% is ideal. If you are seeing values of
    less than 50%, your model either needs more features and/or more training data.
  prefs: []
  type: TYPE_NORMAL
- en: F1 Score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F1 Score is the harmonic mean of both precision and recall.
  prefs: []
  type: TYPE_NORMAL
- en: A value close to or equal to 100% is preferred. A value of 0 indicates your
    precision is completely inaccurate. As shown in our binary classification example,
    we received 87.50%.
  prefs: []
  type: TYPE_NORMAL
- en: Area Under Precision-Recall Curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Area Under Precision-Recall Curve, also commonly referred to as AUPRC, is the
    measure of successful prediction. This value should be inspected when your dataset
    is imbalanced into one classification.
  prefs: []
  type: TYPE_NORMAL
- en: As with AUC and Accuracy, a value close to 100% is preferred, as this indicates
    you have a high recall. As shown in our binary classification example, we received
    a 100% AUPRC value.
  prefs: []
  type: TYPE_NORMAL
- en: Micro Accuracy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Micro Accuracy evaluates if every sample-class pair contributes equally to the
    accuracy metric.
  prefs: []
  type: TYPE_NORMAL
- en: A value close to or equal to 1 is preferred. As shown in our example application
    with the sample and test datasets, a value of 1 was achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Macro Accuracy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macro Accuracy evaluates if every class pair contributes equally to the accuracy
    metric.
  prefs: []
  type: TYPE_NORMAL
- en: A value close to or equal to 1 is preferred. As shown in our example application
    with the sample and test datasets, a value of 1 was achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Log Loss
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log Loss is an evaluation metric describing the accuracy of the classifier.
    Log Loss takes into account the difference between the model's prediction and
    the actual classification.
  prefs: []
  type: TYPE_NORMAL
- en: A value close to 0 is preferred, as a value of 0 indicates the model's prediction
    on the test set is perfect. As shown in our example application with the sample
    and test datasets, a value of .1 was achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Log-Loss Reduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log-Loss Reduction is simply an evaluation metric describing the accuracy of
    the classifier as compared to a random prediction.
  prefs: []
  type: TYPE_NORMAL
- en: A value close to or equal to 1 is preferred, as the model's relative accuracy
    improves as the value approaches 1\. As shown in our example application with
    the sample and test datasets, a value of .856 was achieved, meaning the probability
    of guessing the correct answer is 85.6%.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we have deep-dived into classification models.
    We have also created and trained our first binary classification application,
    using FastTree and ML.NET, to predict how good a car's price is. We also created
    our first multi-class classification application using an SDCA trainer to categorize
    emails. Lastly, we also dove into how to evaluate a classification model and the
    various properties that ML.NET exposes to achieve a proper evaluation of your
    classification models.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deep dive into clustering algorithms with ML.NET
    and creating a file-type classifier.
  prefs: []
  type: TYPE_NORMAL
