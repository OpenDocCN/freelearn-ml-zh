- en: '*Chapter 10*: Steering, Throttle, and Brake Control'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about more methods for controlling the steering,
    throttle, and brake using techniques from the field of control systems. If you
    recall [*Chapter 8*](B16322_08_Final_NM_ePUB.xhtml#_idTextAnchor182), *Behavioral
    Cloning*, you learned how to steer a car using a neural network and camera images.
    While this most closely mimics how a human drives a car, it can be resource-intensive
    due to the computational needs of neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: There are more traditional and less resource-intensive methods for controlling
    a vehicle. The most widely used of these is the **PID** (short for **Proportional,
    Integral, Derivative**) controller, which you will implement in CARLA to drive
    your car around the simulated town.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another method that is widely used in self-driving cars, called
    the **MPC** (short for **Model Predictive Controller**). The MPC focuses on simulating
    trajectories, calculating the cost of each trajectory, and selecting the trajectory
    with the minimum cost. We will walk through some example code that you could implement
    in place of the PID you will learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do you need controls?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a PID in CARLA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example MPC in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have gained knowledge of why we need controls,
    and the skills to select a controller for a given application. You will also know
    how to implement a PID controller in Python and get exposure to an MPC controller
    example written in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will require the following software and libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.7, available at [https://www.python.org/downloads/](https://www.python.org/downloads/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CARLA Simulator 0.9.9, available at [https://carla.readthedocs.io/en/latest/start_quickstart/#carla-installation](https://carla.readthedocs.io/en/latest/start_quickstart/#carla-installation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NumPy module, which can be installed with the `pip3 install numpy` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GPU is highly recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for the chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter10)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action videos for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/2T7WnKo](https://bit.ly/2T7WnKo)'
  prefs: []
  type: TYPE_NORMAL
- en: Why do you need controls?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This may seem completely obvious since you are trying to build a self-driving
    car, but let's cover it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: When you build a self-driving car, what are you trying to achieve? The ultimate
    goal is to get the vehicle to move from a start position to a destination by commanding
    actuators such as the steering, throttle, and brakes. Historically, the commands
    to these actuators have been provided by you, the human driver, via the steering
    wheel, and the throttle and brake pedals. Now you are trying to remove yourself
    as the thing responsible for primary driving tasks. So, what do you put in place
    of yourself? A controller!
  prefs: []
  type: TYPE_NORMAL
- en: What is a controller?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A controller is simply an algorithm that takes some type of error signal and
    transforms it into an actuation signal to achieve a desired setpoint for a given
    process. Let''s define some of these terms as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Control Variable** (**CV**) or process variable is the variable that you
    would like to control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **setpoint** is the desired value of the CV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **error** is the difference between the current state of the CV and the
    **setpoint**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **actuation** is the signal sent to the process to influence the reduction
    of the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **process** is the system being controlled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may see the **process** sometimes called the *plant* or the *transfer function*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, let's say that you are trying to maintain your self-driving car
    within the bounds of the lane it is driving in. The center of the lane would be
    the **setpoint**. You first need to know the **error**, or how far you are away
    from the lane center – let's call this your **Cross-Track Error** (**CTE**). You
    then need to determine what **actuation** command you need to safely return the
    car (aka the **process**) to the center of the lane, thereby minimizing the car's
    CTE. Ultimately, think of the controller as a function that is continually trying
    to minimize the car's **error** for a given CV relative to the **setpoint** of
    that variable.
  prefs: []
  type: TYPE_NORMAL
- en: So to achieve this, let's review the types of controllers available.
  prefs: []
  type: TYPE_NORMAL
- en: Types of controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a vast multitude of controllers that have been invented and implemented
    in control systems. The following is a sample of the different types of controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: The PID controller and its offshoots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimal control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robust control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-space control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear-quadratic control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Controllers can also be categorized by the types of systems they are used in,
    such as the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear versus nonlinear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analog (continuous) versus digital (discrete)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single Input, Single Output** (**SISO**) versus **Multiple Input, Multiple
    Output** (**MIMO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By far the most common and widely used controllers in self-driving cars are
    the PID and MPC. PID controllers are used in SISO systems, while MPCs can be used
    in MIMO systems. This will be useful to remember when you consider which type
    of controller to select for your self-driving car. For example, if you only want
    to control the speed of the vehicle by implementing cruise control, you may want
    to select a SISO controller such as the PID. Conversely, if you want to control
    multiple outputs, such as the steering angle and speed in a single controller,
    you may choose to implement a MIMO controller such as the MPC.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will be introduced to the basics of PIDs in preparation
    to understand the code you will learn.
  prefs: []
  type: TYPE_NORMAL
- en: PID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PID controller is the most ubiquitous form of control system, and has more
    than a century of research and implementation behind it. It has many flavors and
    subtle tweaks that can be made for specific applications. Here you will focus
    on learning the basics and implementing a simple controller for both the lateral
    and longitudinal control of your self-driving car. You will need both longitudinal
    and lateral PID controllers since PID is a SISO controller. Refer to the following
    figure which shows a typical PID block diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – PID block diagram](img/Figure_10.1_B16322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – PID block diagram
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a simple example of controlling the temperature in your home using
    *Figure 10.1*. Your home likely has a thermostat that allows you to set the temperature
    you would like. We will call the temperature you have chosen the **setpoint**
    or *r(t)*. The instantaneous temperature in your home is the **CV** or *y(t)*.
    Now your thermostat's job is to use the heater/cooler in your home to drive the
    temperature (the CV) in your home to the **setpoint**. The CV, *y(t)*, is fed
    back to a subtraction block to determine the **error**, *e(t) = r(t) - y(t)*,
    between the temperature you want in the home and the current temperature. The
    **error** is then passed to the P, I, and D control terms, which will each be
    multiplied by a **gain** value (usually represented by *K*), which are in turn
    summed together to produce the control input into your heater/cooler. Your heater/cooler
    has a certain power capacity, and your home has a certain volume of air. The combination
    of the heater/cooler capacity and the volume of your home determines how quickly
    your home will heat up or cool down when a new **setpoint** is chosen. This is
    known as the **process**, plant, or *transfer function* of your home. The process
    represents how a system's CV will respond to a change in **setpoint**, also known
    as the *step response*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph shows an example step response for a system. At time *t=0*,
    the **setpoint** (shown by the dotted line) is stepped from 0 to 0.95\. The response
    of the system is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Step response example](img/Figure_10.2_B16322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Step response example
  prefs: []
  type: TYPE_NORMAL
- en: We can see that this system and controller combined have created a response
    that will overshoot the setpoint and oscillate around it unil the response eventually
    settles on the setpoint value.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a control system that is more relevant to this book would
    be the cruise control system in a self-driving car. In this case, the car's current
    speed is the CV, the desired speed is the setpoint, and the physical dynamics
    of the car and motor are the process. You will see later how to implement a cruise
    controller as well as a steering controller.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's understand what the proportional, integral, and derivative control
    terms of PID mean.
  prefs: []
  type: TYPE_NORMAL
- en: Pedal to the metal!
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever thought about how you decide how much to press the throttle pedal
    when you are driving?
  prefs: []
  type: TYPE_NORMAL
- en: What factors determine how much you mash the pedal?
  prefs: []
  type: TYPE_NORMAL
- en: –Is it how fast you are going versus how much faster you want to go?
  prefs: []
  type: TYPE_NORMAL
- en: –Does it have to do with how quickly you are approaching your target speed?
  prefs: []
  type: TYPE_NORMAL
- en: –Do you continually check your speed to make sure you haven't drifted from your
    target speed?
  prefs: []
  type: TYPE_NORMAL
- en: Think about all of these as we race through the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start discussing the P, I, and D control terms, we need to define
    what the **gain** is.
  prefs: []
  type: TYPE_NORMAL
- en: The **gain** is a scaling factor used to weight a control term more or less
    heavily in the total control input to the **process**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what proportional means
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the cruise control example, you are trying to match your car''s speed to
    a setpoint speed. The difference between the setpoint speed and your car''s current
    speed is called the **error**. When the car''s speed is below the setpoint, the
    error is positive, and when it is above the setpoint, the error is negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The proportional control term simply takes ![](img/Formula_10_002.png) and
    multiplies it by a scaling factor known as the proportional **gain**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_003.png)'
  prefs: []
  type: TYPE_IMG
- en: What this means is that the larger the **error**, the larger the control input
    to the process, or in the case of cruise control, the larger the throttle input.
    This makes sense, right?
  prefs: []
  type: TYPE_NORMAL
- en: Let's check this with some actual numbers. First, let's define the throttle
    as going from 0 to 100%. Next, let's map that to the acceleration of a car, say,
    that of the Tesla Model X, at 37 m/s2\. *Ludicrous Mode*! So, 100% of the throttle
    gives an acceleration of 37 m/ s2.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your setpoint speed is 100 km/h and you start from 0 km/h, then your current
    error is 100 km/h. Then, if you want maximum acceleration with an error of 100
    km/h, you could set your proportional gain to be 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_004.png)'
  prefs: []
  type: TYPE_IMG
- en: As your error in speed decreases, the throttle would also decrease until you
    reach a throttle input of zero at the point when the error is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait! Zero throttle means we are coasting. This would work great if there was
    no friction, air resistance, and so on, but we all know that isn''t the case.
    This means that you would never really stay at the target speed and would rather
    oscillate just below our target speed, leaving us with a steady-state bias:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Steady-state bias in a proportional controller](img/Figure_10.3_B16322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Steady-state bias in a proportional controller
  prefs: []
  type: TYPE_NORMAL
- en: Oh no – how do we maintain our target speed? No fear, we have the mighty integrator
    that can help bring us up to speed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the integral term
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Introducing the mighty integrator! The integrator term in PID seeks to address
    any steady-state bias in the system. It does this by integrating all the past
    errors in the system. Really, this just means that it is summing up all the errors
    we have seen at each time step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then take the total error and scale it with a gain, *K*I, like we did with
    the proportional term. Then, we use this result as a control input to the system
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_006.png)'
  prefs: []
  type: TYPE_IMG
- en: In your cruise control example, the Model X's speed only briefly achieved the
    setpoint speed and then quickly dipped back down below as the proportional input
    became zero and the air resistance slowed it down. This means that if you summed
    up all the errors over time you would find that they are always positive and continue
    to grow.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the further we go in time, the larger the integrator term, `total_error`speed,
    becomes. This means that if you choose `K`I appropriately, the throttle commanded
    will be greater than zero even when the instantaneous error is zero. Remember,
    we sum all the control terms to get the total throttle input. So far, we have
    the P and I terms, which give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Nice! Now you are oscillating around the setpoint instead of being biased below
    it. But you may ask, *how can we prevent the constant overshooting and undershooting
    of the speed setpoint, and instead stabilize at a nice smooth throttle application?*
    I thought you would never ask!
  prefs: []
  type: TYPE_NORMAL
- en: Derivative control to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Derivative term
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last trouble you must overcome is adjusting your throttle as you approach
    the setpoint without overshooting it. The derivative term helps with this by adjusting
    the throttle based on how quickly you are approaching the setpoint. In terms of
    the error, this means the rate of change of the error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the preceding formula is simplified, we get the following, where `d` denotes
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the error is decreasing – meaning you are approaching the setpoint – the
    derivative term will be negative. This means that the derivative term will aim
    to reduce your total throttle since the throttle is now given by the sum of all
    the P, I, and D control terms. The following equation shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_010.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay, you now know what each part of PID means in real terms. The real trick
    is tuning your `K`P, `K`I, and `K`D gains to make the car's speed and acceleration
    act as you want them to. That is beyond the scope of this book, but there are
    some great references at the end of the chapter for learning more about this.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn about a more modern form of controller that is very popular
    in self-driving cars today – the MPC.
  prefs: []
  type: TYPE_NORMAL
- en: Pump the brakes!
  prefs: []
  type: TYPE_NORMAL
- en: What would you call a negative throttle?
  prefs: []
  type: TYPE_NORMAL
- en: MPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **MPC** is a modern and very versatile controller that is used in MIMO systems.
    This is perfect for your self-driving car, since you have multiple inputs such
    as the throttle, brake, and steering torque. You also have multiple outputs such
    as the lateral position relative to the lane and the car's speed. As you learned
    previously, PID would require two separate controllers (lateral and longitudinal)
    to control the car. With MPC you can do this all in one beautiful controller.
  prefs: []
  type: TYPE_NORMAL
- en: MPC has become popular in recent years due to the increase in computing speed,
    which allows for the *online* optimization that is required to perform real-time
    driving tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can learn what the MPC does, let''s first contemplate what your
    magical brain does when you drive a car:'
  prefs: []
  type: TYPE_NORMAL
- en: You select a destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You plan your route (waypoints).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You execute your route within the bounds of the traffic laws, your car's dynamics
    and performance (*Ludicrous Mode, engage!*), your time constraints (*I'm late
    for a life-changing interview!*), and the traffic around you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MPC works like you
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you really think about how you drive, you are continually assessing the state
    of the cars around you, your car, the time until your destination, your position
    in the lane, your distance from the car in front of yours, the traffic signs and
    signals, your speed, your throttle position, your steering torque, your brake
    position, and so much more! At the same time, you are continually simulating various
    maneuvers you can execute based on the current state of traffic – for instance,
    *there is a car in the lane to my left so I can't go there*, *the car in front
    of me is going really slow*, *there isn't a car in the lane to my right but one
    is approaching quickly*, and *I need to get to this interview and I am running
    late*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are also constantly weighing the cost of each maneuver if executed, based
    on the following cost considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cost of being late to the interview: high!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cost of breaking the law: high!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cost of causing an accident: unfathomable!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cost of using Ludicrous Mode: medium!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cost of damaging your car: *is there something higher than infinity? Let''s
    pick that!*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You then quickly estimate the cost of any of your possible maneuvers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Passing in the left lane means I could crash into the car next to me and potentially
    cause an accident or damage my car, and still probably miss my interview.* The
    cost: astronomical!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I could continue in my lane behind this sloth of a car. This will make me
    late*. The cost: high!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Passing in the right lane will require Ludicrous Mode acceleration to make
    sure the approaching car doesn''t hit me*. The cost: medium!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You choose the last of the preceding options, since it has the lowest cost of
    the simulated maneuvers based on the costs you have ascribed to each consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Great, you have chosen a maneuver! Now you need to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: You smash the Ludicrous Mode button for 5 seconds while you cinch your seatbelt
    until it feels like a boa constrictor and you chop your blinker on as if you were
    the *Karate Kid*! You grip the steering wheel with white-knuckle fury and then
    put the pedal to the metal as you visualize the power and majesty of the extra
    35 horses that thrust you back into your seat. You simultaneously crank the steering
    wheel to rail you into the right lane and fly by the sloth with adrenaline and
    a smug grin plastered on your face as you watch the previously approaching car
    fading into oblivion behind you!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are blissfully satisfied with your maneuver, you start the entire
    process over for the next maneuver and repeat until you arrive safely and on time
    for your interview! You did it!
  prefs: []
  type: TYPE_NORMAL
- en: MPC pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MPC takes a similar approach to dynamic driving tasks that humans do. MPC simply
    formalizes the driving tasks into mathematics and physics (with less thrill and
    excitement). The steps are very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Establish constraints such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vehicle''s dynamic model for estimating its state in the next time step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The minimum turn radius
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum steering angle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum throttle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum brake
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum lateral jerk (a derivative of acceleration)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum longitudinal acceleration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Establish the cost functions, including the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cost of not being at the desired state
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of using actuators
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of sequential actuations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of using the throttle with steering
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of crossing lane lines
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of collisions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, simulate possible trajectories and the associated control inputs that
    obey the mathematical cost and constraints for the next *N* time steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an optimization algorithm to select the simulated trajectory with the lowest
    cost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the control inputs for one time step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the state of the system at the new time step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 3–6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a lot more detail in each of these steps and you are encouraged to
    learn more by following the links in the *Further reading* section at the end
    of the chapter. For now, here are some quick guidelines to think about.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sample time, TS**:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the discrete time step at which you repeat *steps* *3–7* of the MPC
    pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, TS is selected so that there are at least 10 time steps in the open-loop
    rise time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prediction horizon, N**:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the number of time steps into the future for which you will simulate
    the car state and control inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, 20 time steps are used to cover the open-loop response of the car.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also examine the following figure, which illustrates many of the concepts
    and parameters you''ve learned that constitute the MPC problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Concepts and parameters that constitute the MPC problem](img/Figure_10.4_B16322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Concepts and parameters that constitute the MPC problem
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick description of each of the parameters shown in the preceding
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Reference Trajectory** is the desired trajectory of the controlled variable;
    for example, the lateral position of the vehicle in the lane.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Predicted Output** is the prediction of the controlled variable state
    after the predicted control input has been applied. It is informed by the dynamic
    model of the system, the constraints, and the previously measured output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Measured Output** is the measured past state of the controlled variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Predicted Control Input** is the system's prediction of the control actuations
    that must be performed to achieve the predicted output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Past Control Input** is the actual control actuations that were performed
    in the past, leading up to the current state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MPC is a powerful though resource-intensive control algorithm that can sometimes
    simplify your architecture by allowing MIMO to fit into a single module.
  prefs: []
  type: TYPE_NORMAL
- en: This is a lot to take in at once, but if you have made it this far, you are
    in luck! In the next section, we will dive into the real code that you can use
    to control your self-driving car in CARLA using PID!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing PID in CARLA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on making it to the truly fun and hands-on portion of this chapter.
    You have learned a lot so far about PIDs and MPCs. Now it is time to put that
    knowledge to use!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will walk through all the relevant code that is available
    on GitHub for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars)'
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to apply the equations and concepts of PID in Python and
    then interface with CARLA.
  prefs: []
  type: TYPE_NORMAL
- en: First, you will need to install CARLA.
  prefs: []
  type: TYPE_NORMAL
- en: Installing CARLA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CARLA project has a Linux and Windows Quick Start guide available at [https://carla.readthedocs.io/en/latest/start_quickstart/](https://carla.readthedocs.io/en/latest/start_quickstart/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux, the CARLA files will be located here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this folder you will find a `/bin/` folder that contains the executable
    simulator script, which you can run with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `–opengl` tag runs the simulator using OpenGL instead of Vulkan. Depending
    on your system setup and GPU, you may drop `–opengl`. You should see a simulator
    environment window pop up that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – CARLA simulator environment opening](img/Figure_10.5_B16322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – CARLA simulator environment opening
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, you will be primarily working from the `examples` folders
    located at the following destinations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux: `/opt/carla-simulator/PythonAPI/examples`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: `WindowsNoEditor\PythonAPI\examples`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This folder contains all the example CARLA scripts that teach you the basics
    of the CARLA API. In this folder, you will find a script called `automatic_control.py`,
    which is the basis of the script you will be working with throughout the rest
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have installed and successfully run the simulator, you will clone
    the `Packt-Town04-PID.py` script that contains the PID controller.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning Packt-Town04-PID.py
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the repository for this chapter under `Chapter10` at [https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars).
  prefs: []
  type: TYPE_NORMAL
- en: You can clone the entire repo to any location on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then need to link the `Packt-Town04-PID.py` script into the `examples`
    folder previously discussed. You can use this command in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the script and have linked it to the correct location within
    CARLA, let's walk through the code and what it does.
  prefs: []
  type: TYPE_NORMAL
- en: Walking through your Packt-Town04-PID.py control script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `Packt-Town04-PID.py` code is based on the `automatic_control.py` example
    script and is pieced together from the relevant snippets of code located in the
    `/opt/carla-simulator/PythonAPI/carla/agents` subfolders, namely, the following
    scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`behavior_agent.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local_planner.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controller.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`agent.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very good way to learn how to interact with the CARLA simulator and
    learn the API without having to write everything from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the CARLA module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you now look at `Packt-Town04-PID.py`, the first thing that you might notice
    after the usual imports is this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This block loads an egg file containing the code for CARLA, which is in the
    `/opt/carla-simulator/PythonAPI/carla/dist/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Classes of interest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After this, you will probably notice that the code is organized into the following
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`World`: The virtual world where our vehicle moves, including the map and all
    the actors (such as vehicles, pedestrians, and sensors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyboardControl`: This reacts to the keys pressed by the user and has some
    logic to convert the binary on/off keys for steering, braking, and accelerating
    to a wider range of values, based on how much time they are pressed, making the
    car much easier to control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HUD`: This renders all the information related to the simulation including
    the speed, steering, and throttle. It manages the notifications that can show
    some information to the user for a few seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FadingText`: This class is used by the `HUD` class to show notifications that
    disappear after a few seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelpText`: This class displays some text using `pygame`, a gaming library
    used by CARLA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollisionSensor`: This is a sensor that can detect collisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LaneInvasionSensor`: This is a sensor that can detect that you crossed a lane
    line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GnssSensor`: This is a GPS/GNSS sensor that provides the GNSS position inside
    the OpenDRIVE map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CameraManager`: This is a class that manages the camera and prints it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Agent`: This is the base class to define an agent in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AgentState`: This is a class to represent the possible states of the agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BehaviorAgent`: This class implements an agent that navigates the world to
    reach a destination by computing the shortest possible path to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalPlanner`: This class implements a trajectory to follow by generating
    waypoints on the fly. It also calls the `VehiclePIDController` class with the
    appropriate gains. This is where the magic happens for this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VehiclePIDController`: This class calls the lateral and longitudinal controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PIDLongitudinalController`: This class holds the PID math that you have been
    learning about for cruise control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PIDLateralController`: This class holds the PID math for steering control
    to keep your car following the waypoints generated by the `LocalPlanner` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a couple of other notable methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main()`: This is mostly dedicated to parsing the arguments received by the
    OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`game_loop()`: This mostly initializes `pygame`, the CARLA client, and all
    the related objects. It also implements the game loop where, 60 times per second,
    the keys are analyzed and the most updated image is shown on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `game_loop()` method you will find where to set the world map. It
    is currently set to `Town04`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Car personalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are a car enthusiast who would like to choose your car model and color,
    you can do so with this code inside the `World()` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Spawn point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next thing you may want to change is the spawn point of the vehicle in
    the map. You can do this by picking a different index for `spawn_points[0]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have gone through your customization and understand the layout
    of the classes and what they do, we will now dive into the meat of this chapter's
    code – the PID controllers!
  prefs: []
  type: TYPE_NORMAL
- en: PIDLongitudinalController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is your cruise control and is responsible for actuating the throttle and
    brake. Do you remember earlier when we tickled your brain and asked what a negative
    throttle would be called? Well, the answer here is the brake. So any time the
    controller calculates a negative throttle input, it will actuate the brake with
    the control value.
  prefs: []
  type: TYPE_NORMAL
- en: Gains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This gains class is initialized with the PID gains that have been tuned by
    the CARLA team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The values are set back in the `LocalPlanner` class in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Gain scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Notice that there are different gains based on highway versus city driving.
    The gains are scheduled in `LocalPlanner` based on the current speed of the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: PID math
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'And now for the PID implementation math you have been waiting for! The `_pid_control()`
    method contains the heart of the PID controller and the calculations that you
    learned in the *PID* subsection of the *Types of controllers* section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we calculate the error in the speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add the current error to the error buffer so we can use it later to
    calculate the integral and derivative terms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, if the error buffer has at least two values in it, we calculate the integral
    and derivative terms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we calculate the derivative term by subtracting the previous error value
    from the current error value and divide that by the **sampling time**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we calculate the integral term by summing all the errors we have seen
    and multiplying by the **sampling time**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we don''t have enough in the buffer, we simply set our integral and derivative
    terms to zero:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we calculate the control input by summing all the gain-weighted PID
    terms and returning the value clipped to ±1.0\. Recall the math for this is as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_10_011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The throttle is commanded if the value is positive, otherwise, the brake is
    commanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know the basic math for a PID, you will now see how to implement
    this in the lateral PID controller.
  prefs: []
  type: TYPE_NORMAL
- en: PIDLateralController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is your steering control and is responsible for actuating the steering
    angle.
  prefs: []
  type: TYPE_NORMAL
- en: Gains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class is initialized with the PID gains that have been tuned by the CARLA
    team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The values set back in the `LocalPlanner` class are in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Gain scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Notice that there are different gains based on highway versus city driving
    just as there were for the longitudinal control. The gains are scheduled in `LocalPlanner`
    based on the current speed of the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: PID math
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The math for the lateral control is a little different but has the same basic
    principle. Again, the math is in the `_pid_control()` method. Let''s see how to
    go about it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we find the starting point of our vehicle vector in global coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we find the end of our vehicle vector in global coordinates using the
    yaw angle of the vehicle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create the vehicle vector, which is the direction our vehicle is pointing
    in global coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we calculate the vector from the vehicle''s position to the next waypoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we find the angle between the vehicle vector and the vector pointing
    from the vehicle location to the waypoint. This is essentially our steering error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we find the cross product of the two vectors to determine which side
    of the waypoint we are on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we adjust the angle `_dot` value to be negative if the cross product
    was negative:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we append the current steering error to our error buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, if the error buffer has at least two values in it, we calculate the integral
    and derivative terms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we calculate the derivative term by subtracting the previous error value
    from the current error value and divide by the **sampling time**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we calculate the integral term by summing all the errors we have seen
    and multiplying by the sampling time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we don''t have enough in the buffer, we simply set our integral and derivative
    terms to zero:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we calculate the control input by summing all the gain-weighted PID
    terms and returning the value clipped to ±1.0\. We haven''t seen this yet for
    steering, but it works the same as for speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_10_012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A negative steering angle simply means *turn left* while positive means *turn
    right*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have learned how to implement the PID control in Python, it is
    time to see it working!
  prefs: []
  type: TYPE_NORMAL
- en: Running the script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should first ensure that you have started the CARLA simulator by running
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in a new Terminal window, you can run the `Packt-Town04-PID.py` script
    and watch the magic unfold. The command to run the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a new window pop up that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Packt-Town04-PID.py runtime window](img/Figure_10.6_B16322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Packt-Town04-PID.py runtime window
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You made a car steer and accelerate itself using nothing but
    a keyboard and your newfound knowledge! In the next section, you will learn how
    to apply an MPC controller using C++.
  prefs: []
  type: TYPE_NORMAL
- en: An example MPC in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A full implementation of MPC is beyond the scope of this chapter but you can
    review this example implementation written in C++ at [https://github.com/Krishtof-Korda/CarND-MPC-Project-Submission/blob/master/src/MPC.cpp](https://github.com/Krishtof-Korda/CarND-MPC-Project-Submission/blob/master/src/MPC.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: The following example will walk you through the implementation of an MPC module
    that you can use in place of a PID controller for both lateral and longitudinal
    control. Recall that MPC is a MIMO system, meaning you can control multiple outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows all the basic components and code you''ll need
    to build an MPC controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, use the following code to fit a polynomial to your **prediction horizon**
    waypoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following code to calculate cross-tracking errors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following code to calculate orientation errors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we use `MPC.cpp` to structure the vector so that it can be passed to an
    optimizer. The optimizer takes all the state and actuator variables in a single
    vector. So, here, you will establish the start index of each variable in the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, assign all the adjustable weights for your costs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, you can establish your cost functions based on those weights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this, you must add a cost, if you are at the relative state compared to
    the reference state. In other words, add a cost for not being on the desired path,
    heading, or velocity, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you need to add a cost for the use of actuators. This helps minimize
    the actuations if they are not needed. Think of this as the car likes to be lazy
    and will only command an actuation if the cost is low enough:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you need to add a cost for sequential use of the actuators. This will
    help minimize oscillatory use of the actuators, such as when a new driver jumps
    between the throttle and the brake clumsily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, it''s a good idea to add a cost for using the throttle while at high
    steering angles. You don''t want to mash the throttle in the middle of a turn
    and spin out of control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, establish the initial constraints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we''ve done this, we can establish the vehicle model constraints based
    on the state variable and the `t+1`; that is, the current time step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the variables for the state at time `t`; that is, the previous
    time step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you need to ensure you only consider the actuation at time `t`. So, here,
    we only consider the steering (`delta0`) and the acceleration (`a0`) at time `t`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you need the constraint of the waypoint line you are trying to follow.
    This is done by creating a polynomial that''s fitted to the waypoints. This is
    dependent on the number of coefficients. For example, a second-order polynomial
    will have three coefficients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the same coefficients, you can establish the constraint for the desired
    heading of the car:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you need to create constraints for the vehicle model. In this case,
    a simplified vehicle model known as the bicycle model can be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! You now have at least an example of how to code an MPC in C++. You can
    take this basic example and translate it to any language that you need for your
    control application. You have another weapon in your arsenal of control knowledge!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You now have a lateral and longitudinal controller for a self-driving
    car! You should be proud of what you have learned and applied in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned about the two most ubiquitous controllers, namely, the PID
    and MPC. You learned that PIDs are well suited for SISO systems and are very efficient,
    but require several controllers to control multiple outputs. Meanwhile, you also
    learned that MPCs are suited for MIMO systems with enough resources to continually
    optimize in real time at each time step.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you have trudged through the minutia of the mathematics and models
    and emerged with your very own PID controller implemented in CARLA and Python.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you are going to learn how to build maps and localize your
    self-driving car so you always know where you are in the world!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having read this chapter, you should be able to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What controller type is best suited for a vehicle with lower computing resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the integral term of a PID controller correct for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the derivative term of a PID controller correct for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a cost and a constraint in an MPC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Control theory: [https://en.wikipedia.org/wiki/Control_theory#Main_control_strategies](https://en.wikipedia.org/wiki/Control_theory#Main_control_strategies)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Self-Tuning PID Controller for Autonomous Car Tracking in Urban Traffic*:
    [http://oa.upm.es/30015/1/INVE_MEM_2013_165545.pdf](http://oa.upm.es/30015/1/INVE_MEM_2013_165545.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Twiddle algorithm for tuning PID controllers: [https://martin-thoma.com/twiddle/](https://martin-thoma.com/twiddle/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lateral Tracking Control for the Intelligent Vehicle Based on Adaptive PID
    Neural Network*: [https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492364/](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492364/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MPC-Based Approach to Active Steering for Autonomous Vehicle Systems*: [https://borrelli.me.berkeley.edu/pdfpub/pub-6.pdf](https://borrelli.me.berkeley.edu/pdfpub/pub-6.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kinematic and Dynamic Vehicle Models for Autonomous Driving Control Design*:
    [https://borrelli.me.berkeley.edu/pdfpub/IV_KinematicMPC_jason.pdf](https://borrelli.me.berkeley.edu/pdfpub/IV_KinematicMPC_jason.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
