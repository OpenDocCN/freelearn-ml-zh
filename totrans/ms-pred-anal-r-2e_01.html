<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;Gearing Up for Predictive Modeling"><div class="book" id="E9OE2-c6198d576bbb4f42b630392bd61137d7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Gearing Up for Predictive Modeling</h1></div></div></div><p class="calibre8">In this first chapter, we'll start by establishing a common language for models and taking a deep view of the predictive modeling process. Much of predictive modeling involves the key concepts of statistics and machine learning, and this chapter will provide a brief tour of the core features of these fields that are essential knowledge for a predictive modeler. In particular, we'll emphasize the importance of knowing how to evaluate a model that is appropriate to the type of problem we are trying to solve. Finally, we will showcase our first model, the k-nearest neighbors model, as well as <code class="email">caret</code>, a very useful R package for predictive modelers.</p></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Gearing Up for Predictive Modeling">
<div class="book" title="Models"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Models</h1></div></div></div><p class="calibre8">Models <a id="id0" class="calibre1"/>are at the heart of predictive analytics and, for this reason, we'll begin our journey by talking about models and what they look like. In simple terms, a model is a representation of a state, process, or system that we want to understand and reason about. We make models so that we can draw inferences from them and, more importantly for us in this book, make predictions about the world. Models come in a multitude of different formats and flavors, and we will explore some of this diversity in this book. Models can be equations linking quantities that we can observe or measure; they can also be a set of rules. A simple model with which most of us are familiar from school is Newton's Second Law of Motion. This states that the net sum of force acting on an object causes the object to accelerate in the direction of the force applied and at a rate proportional to the resulting magnitude of the force and inversely proportional to the object's mass.</p><p class="calibre8">We often summarize this information via an equation using the letters <span class="strong"><em class="calibre9">F</em></span>, <span class="strong"><em class="calibre9">m</em></span>, and <span class="strong"><em class="calibre9">a</em></span> for the quantities involved. We also use the capital Greek letter sigma (<span class="strong"><em class="calibre9">Σ</em></span>) to indicate that we are summing over the force and arrows above the letters that are vector quantities (that is, quantities that have both magnitude and direction):</p><div class="mediaobject"><img src="../images/00002.jpeg" alt="Models" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">This simple but powerful model allows us to make some predictions about the world. For example, if we apply a known force to an object with a known mass, we can use the model to predict how much it will accelerate. Like most models, this model makes some assumptions and generalizations. For example, it assumes that the color of the object, the temperature of the environment it is in, and its precise coordinates in space are all irrelevant to <a id="id1" class="calibre1"/>how the three quantities specified by the model interact with each other. Thus, models abstract away the myriad of details of a specific instance of a process or system in question, in this case the particular object in whose motion we are interested, and limit our focus only to properties that matter.</p><p class="calibre8">Newton's second law is not the only possible model to describe the motion of objects. Students of physics soon discover other more complex models, such as those taking into account relativistic mass. In general, models are considered more complex if they take a larger number of quantities into account or if their structure is more complex. For example, nonlinear models are generally more complex than linear models. Determining which model to use in practice isn't as simple as picking a more complex model over a simpler model. In fact, this is a central theme that we will revisit time and again as we progress through the many different models in this book. To build our intuition as to why this is so, consider the case where our instruments that measure the mass of the object and the applied force are very noisy. Under these circumstances, it might not make sense to invest in using a more complicated model, as we know that the additional accuracy in the prediction won't make a difference because of the noise in the inputs. Another situation where we may want to use the simpler model is when, in our application, we simply don't need the extra accuracy. A third situation arises where a more complex model involves a quantity that we have no way of measuring. Finally, we might not want to use a more complex model if it turns out that it takes too long to train or make a prediction because of its complexity.</p></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Gearing Up for Predictive Modeling">
<div class="book" title="Models">
<div class="book" title="Learning from data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec07" class="calibre1"/>Learning from data</h2></div></div></div><p class="calibre8">In this book, the models we will study have two important and defining characteristics. The first <a id="id2" class="calibre1"/>of these is that we will not use mathematical reasoning or logical induction to produce a model from known facts, nor will we build models from technical specifications or business rules; instead, the field of predictive analytics builds models from data. More specifically, we will assume that for any given predictive task that we want to accomplish, we will start with some data that is in some way related to (or derived from) the task at hand. For example, if we want to build a model to predict annual rainfall in various parts of a country, we might have collected (or have the means to collect) data on rainfall at different locations, while measuring potential quantities of interest, such as the height above sea level, latitude, and longitude. The power of building a model to perform our predictive task stems from the fact that we will use examples of rainfall measurements at a finite list of locations to predict the rainfall in places where we did not collect any data.</p><p class="calibre8">The <a id="id3" class="calibre1"/>second important characteristic of the problems for which we will build models is that, during the process of building a model from some data to describe a particular phenomenon, we are bound to encounter some source of randomness. We will <a id="id4" class="calibre1"/>refer to this as the <span class="strong"><strong class="calibre2">stochastic</strong></span> or <span class="strong"><strong class="calibre2">nondeterministic component</strong></span> of the model. It may be the case that the system itself that we are trying to model doesn't <a id="id5" class="calibre1"/>have any inherent randomness in it, but it is the data that contains a random component. A good example of a source of randomness <a id="id6" class="calibre1"/>in data is the measurement of errors from readings taken for quantities such as temperature. A model that contains no inherent stochastic component is known as a <span class="strong"><strong class="calibre2">deterministic model</strong></span>, Newton's second law being a good example of this. A stochastic model is one that assumes that there is an intrinsic source of randomness to the process being modeled. Sometimes, the source of this randomness arises from the fact that it is impossible to measure all the variables that are most <a id="id7" class="calibre1"/>likely impacting a system, and we simply choose to model this using probability. A well-known example of a purely stochastic model is rolling an unbiased six-sided die. Recall that, in probability, we use the term <span class="strong"><strong class="calibre2">random variable</strong></span> to describe the value of a particular outcome of an experiment or of a random process. In our die example, we can define the random variable, <span class="strong"><em class="calibre9">Y</em></span>, as the number of dots on the side that lands face up after a single roll of the die, resulting in the following model:</p><div class="mediaobject"><img src="../images/00003.jpeg" alt="Learning from data" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">This model <a id="id8" class="calibre1"/>tells us that the probability of rolling a particular digit, say, 3, is one in six. Notice that we are not making a definite prediction on the outcome <a id="id9" class="calibre1"/>of a particular roll of the die; instead, we are saying that each outcome is equally likely.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">Probability is a term that is commonly used in everyday speech, but at the same time sometimes results in confusion with regard to its actual interpretation. It turns out that there are a number of different ways of interpreting probability. Two commonly cited interpretations are <span class="strong"><strong class="calibre2">Frequentist probability</strong></span> and <span class="strong"><strong class="calibre2">Bayesian probability</strong></span>. Frequentist probability is associated with repeatable experiments, such as rolling a one-sided die. In this case, the probability of seeing the digit 3, is just the relative proportion of the digit 3 coming up if this experiment were to be repeated an infinite number of times. Bayesian probability is associated with a subjective degree of belief or surprise at seeing a particular outcome and can, therefore, be used to give meaning to one-off events, such as the probability of a presidential candidate winning an election. In our die rolling experiment, we are as surprised to see the number 3 come up as with any other number. Note that in both cases, we are still talking about the same probability numerically (1/6); only the interpretation differs.</p></div><p class="calibre8">In the case of the die model, there aren't any variables that we have to measure. In most cases, however, we'll be looking at predictive models that involve a number of independent variables <a id="id10" class="calibre1"/>that are measured, and these will be used to predict a dependent variable. Predictive modeling draws on many diverse fields and as a result, depending on the particular literature you consult, you will often find different names for these. Let's load a dataset into R before we expand on this point. R comes with a number of commonly cited datasets already loaded, and we'll pick what is probably the most famous of all, the <span class="strong"><em class="calibre9">iris dataset</em></span>:</p><div class="informalexample"><pre class="programlisting">&gt; head(iris, n = 3)
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">To see what other datasets come bundled with R, we can use the <code class="email">data()</code> command to obtain a list of datasets along with a short description of each. If we modify the data from a dataset, we can reload it by providing the name of the dataset in question as an input parameter to the <code class="email">data()</code>command; for example, <code class="email">data(iris)</code> reloads the iris dataset.</p></div><p class="calibre8">The <code class="email">iris</code> dataset consists of measurements made on a total of 150 flower samples of three different species of iris. In the preceding code, we can see that there are four measurements made on each sample, namely the lengths and widths of the flower petals and sepals. The iris dataset is often used as a typical benchmark for different models that can predict <a id="id11" class="calibre1"/>the species of an iris flower sample, given the four previously mentioned <a id="id12" class="calibre1"/>measurements. Collectively, the sepal length, sepal width, petal <a id="id13" class="calibre1"/>length, and petal width are referred to as <span class="strong"><strong class="calibre2">features</strong></span>, <span class="strong"><strong class="calibre2">attributes</strong></span>, <span class="strong"><strong class="calibre2">predictors</strong></span>, <span class="strong"><strong class="calibre2">dimensions</strong></span>, or <span class="strong"><strong class="calibre2">independent variables</strong></span> in literature. In this book, we prefer to use <a id="id14" class="calibre1"/>the word feature, but other terms are equally valid. Similarly, the species <a id="id15" class="calibre1"/>column in the data frame is what we are trying to predict <a id="id16" class="calibre1"/>with our <a id="id17" class="calibre1"/>model, and so it is referred to <a id="id18" class="calibre1"/>as the <span class="strong"><strong class="calibre2">dependent variable</strong></span>, <span class="strong"><strong class="calibre2">output</strong></span>, or <span class="strong"><strong class="calibre2">target</strong></span>. Again, in this book, we will prefer one form for consistency, and will use output. Each row in the data frame corresponding to a single data point is referred to as an <span class="strong"><strong class="calibre2">observation</strong></span>, though it typically involves observing the values of a number of features.</p><p class="calibre8">As we <a id="id19" class="calibre1"/>will be using datasets, such as the iris data described earlier, to build our predictive models, it also helps to establish some symbol conventions. Here, the conventions are quite common in most of the literature. We'll use the capital letter, <span class="strong"><em class="calibre9">Y</em></span>, to refer to the output variable, and subscripted capital letter, <span class="strong"><em class="calibre9">X<sub class="calibre14">i</sub></em></span>, to denote the <span class="strong"><em class="calibre9">i<sup class="calibre15">th</sup></em></span> feature. For example, in our iris dataset, we have four features that we could refer to as <span class="strong"><em class="calibre9">X<sub class="calibre14">1</sub></em></span> through <span class="strong"><em class="calibre9">X<sub class="calibre14">4</sub></em></span>. We will use lower-case <a id="id20" class="calibre1"/>letters for individual observations, so that <span class="strong"><em class="calibre9">x<sub class="calibre14">1</sub></em></span> corresponds to the first observation. Note that <span class="strong"><em class="calibre9">x<sub class="calibre14">1</sub></em></span> itself is a vector of feature components, <span class="strong"><em class="calibre9">x<sub class="calibre14">ij</sub></em></span>, so that <span class="strong"><em class="calibre9">x<sub class="calibre14">12</sub></em></span> refers to the value of the second feature in the first observation. We'll try to use double suffixes sparingly and we won't use arrows or any other form of vector notation for simplicity. Most often, we will be discussing either observations or features and so the case of the variable will make it clear to the reader which of these two is being referenced.</p><p class="calibre8">When thinking about a predictive model using a dataset, we are generally making the assumption that for a model with <span class="strong"><em class="calibre9">n</em></span> features, there is a true or ideal function, <span class="strong"><em class="calibre9">f</em></span>, that maps the features to the output:</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Learning from data" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">We'll refer <a id="id21" class="calibre1"/>to this function as our <span class="strong"><strong class="calibre2">target function</strong></span>. In practice, as we train our model using the data available to us, we will produce our own function that we hope is a good estimate for the target function. We can represent this by using a caret on top of the symbol <span class="strong"><em class="calibre9">f</em></span> to denote our predicted function, and also for the output, <span class="strong"><em class="calibre9">Y</em></span>, since the output of our predicted function is the predicted output. Our predicted output will, unfortunately, not always agree with the actual output for all observations (in our data or in general):</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Learning from data" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Given this, we can essentially summarize predictive modeling as a process that produces a function to predict a quantity, while minimizing the error it makes compared to the target function. A good question we can ask at this point is, Where does the error come from? Put differently, why are we generally not able to exactly reproduce the underlying target function by analyzing a dataset?</p><p class="calibre8">The answer to this question is that in reality there are several potential sources of error that we must deal with. Remember that each observation in our dataset contains values for <span class="strong"><em class="calibre9">n</em></span> features, and so we can think about our observations geometrically as points in an <span class="strong"><em class="calibre9">n</em></span>-dimensional feature space. In this space, our underlying target function should pass through these points by the very definition of the target function. If we now think about this general problem of fitting a function to a finite set of points, we will quickly realize that there <a id="id22" class="calibre1"/>are actually infinite functions that could pass through the same set of points. The process of predictive modeling involves making a choice in the type of model that we will use for the data, thereby constraining the range of possible target functions to which we can fit our data. At the same time, the data's inherent randomness cannot be removed no matter what model we select. These ideas lead us to an <a id="id23" class="calibre1"/>important distinction in the types of error that we encounter during modeling, namely the <span class="strong"><strong class="calibre2">reducible error</strong></span> and the <span class="strong"><strong class="calibre2">irreducible error</strong></span>, respectively.</p><p class="calibre8">The reducible <a id="id24" class="calibre1"/>error essentially refers to the error that we as predictive modelers can minimize by selecting a model structure that makes valid assumptions about the process being modeled and whose predicted function takes the same form as the underlying target function. For example, as we shall see in the next chapter, a linear model imposes a linear relationship between its features in order to compose the output. </p><p class="calibre8">This restrictive assumption means that, no matter what training method we use, how much data we have, and how much computational power we throw in, if the features aren't linearly related in the real world, then our model will necessarily produce an error for at least some possible observations. By contrast, an example of an irreducible error arises when trying to build a model with an insufficient feature set. This is typically the norm and not the exception. Often, discovering what features to use is one of the most time-consuming activities of building an accurate model.</p><p class="calibre8">Sometimes, we may not be able to directly measure a feature that we know is important. At other times, collecting the data for too many features may simply be impractical or too costly. Furthermore, the solution to this problem is not simply a question of adding as many features as possible. Adding more features to a model makes it more complex and we run the risk of adding a feature that is unrelated to the output, thus introducing noise in our model. This also means that our model function will have more inputs and will, therefore, be a function in a higher dimensional space. </p><p class="calibre8">Some of the potential practical consequences of adding more features to a model include increasing the time it will take to train the model, making convergence on a final solution harder, and actually reducing model accuracy under certain circumstances, such as with highly correlated features. Finally, another source of an irreducible error that we must live with is the error in measuring our features so that the data itself may be noisy.</p><p class="calibre8">Reducible errors can be minimized not only through selecting the right model, but also by ensuring that the model is trained correctly. Thus, reducible errors can also come from not finding the right specific function to use, given the model assumptions. For example, even when we have correctly chosen to train a linear model, there are infinitely many linear combinations of the features that we could use. Choosing the model parameters correctly, which in this case would be the coefficients of the linear model, is also an aspect of minimizing the reducible error. Of course, a large part of training a model correctly involves <a id="id25" class="calibre1"/>using a good optimization procedure to fit the model. In this book, we will at least give a high-level intuition of how each model that we study is trained. We generally avoid delving deeply into the mathematics of how optimization procedures work, but we do give pointers to the relevant literature for the interested reader to find out more.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Gearing Up for Predictive Modeling">
<div class="book" title="Models">
<div class="book" title="The core components of a model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec08" class="calibre1"/>The core components of a model</h2></div></div></div><p class="calibre8">So far <a id="id26" class="calibre1"/>we've established some central notions behind models and a common language to talk about data. In this section, we'll look at what the core components of a statistical model are. The primary components are typically:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A set of equations with parameters that need to be tuned</li><li class="listitem">Some data that is representative of a system or process that we are trying to model</li><li class="listitem">A concept that describes the model's goodness of fit</li><li class="listitem">A method to update the parameters to improve the model's goodness of fit</li></ul></div><p class="calibre8">As we'll see in this book, most models, such as neural networks, linear regression, and support vector machines, have certain parameterized equations that describe them. Let's look at a linear model attempting to predict the output, <span class="strong"><em class="calibre9">Y</em></span>, from three input features, which we will call <span class="strong"><em class="calibre9">X<sub class="calibre14">1</sub></em></span>, <span class="strong"><em class="calibre9">X<sub class="calibre14">2</sub></em></span>, and <span class="strong"><em class="calibre9">X<sub class="calibre14">3</sub></em></span>:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="The core components of a model" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">This model has exactly one equation describing it and this equation provides the linear structure of the model. The equation is parameterized by four parameters, known as coefficients in this case, and they are the four <span class="strong"><em class="calibre9">β</em></span> parameters. In the next chapter, we will see exactly what roles these play, but for this discussion, it is important to note that a linear model is an example of a parameterized model. The set of parameters is typically much smaller than the amount of data available.</p><p class="calibre8">Given a set of equations and some data, we then talk about training the model. This involves assigning values to the model's parameters so that the model describes the data more accurately. We typically employ certain standard measures that describe a model's goodness of fit to the data, which is how well the model describes the training data. The training process is usually an iterative procedure that involves performing computations on the data so that new values for the parameters can be computed in order to increase the model's goodness of fit. For example, a model can have an objective or error function. By differentiating this and setting it to zero, we can find the combination of parameters that gives us the minimum error. Once we finish this process, we refer to the model as a trained <a id="id27" class="calibre1"/>model and say that the model has learned from the data. These terms are derived from the machine learning literature, although there is often a parallel made with statistics, a field that has its own nomenclature for this process. We will mostly use terms from machine learning in this book.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Gearing Up for Predictive Modeling">
<div class="book" title="Models">
<div class="book" title="Our first model – k-nearest neighbors"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec09" class="calibre1"/>Our first model – k-nearest neighbors</h2></div></div></div><p class="calibre8">In order <a id="id28" class="calibre1"/>to put some of the ideas in this chapter into perspective, we will present our first model for this book, <span class="strong"><strong class="calibre2">k-nearest neighbors</strong></span>, which is commonly <a id="id29" class="calibre1"/>abbreviated as <span class="strong"><strong class="calibre2">kNN</strong></span>. In a nutshell, this simple approach actually avoids building an explicit model to describe how the features in our data combine to produce a target function. Instead, it relies on the notion that, if we are trying to make a prediction on a data point that we have never seen before, we will look inside our original training data and find the <span class="strong"><em class="calibre9">k</em></span> observations that are most similar to our new data point. We can then use some kind of <a id="id30" class="calibre1"/>averaging technique on the known value of the target function for these <span class="strong"><strong class="calibre2">k neighbors</strong></span> to compute a prediction. Let's use our iris dataset to understand this by way of an example. Suppose that we collect a new unidentified sample of an iris flower with the following measurements:</p><div class="informalexample"><pre class="programlisting">&gt; new_sample
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
4.8          2.9          3.7          1.7</pre></div><p class="calibre8">We would like to use the kNN algorithm in order to predict which species of flower we should use to identify our new sample. The first step in using the kNN algorithm is to determine the k-nearest neighbors of our new sample. In order to do this, we will have to give a <a id="id31" class="calibre1"/>more precise definition of what it means for two observations to be similar to each other. A common approach is to compute a numerical distance between two observations in the feature space. The intuition is that two observations that are similar will be close to each other in the feature space and therefore, the distance between them will be small. To compute the distance between two observations in the feature space, we often use the <span class="strong"><strong class="calibre2">Euclidean distance</strong></span>, which is the length of a straight line between two points. The Euclidean distance between two observations, <span class="strong"><em class="calibre9">x<sub class="calibre14">1</sub></em></span> and <span class="strong"><em class="calibre9">x<sub class="calibre14">2</sub></em></span>, is computed as follows:</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Our first model – k-nearest neighbors" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Recall that the second suffix, <span class="strong"><em class="calibre9">j</em></span>, in the preceding formula corresponds to the <span class="strong"><em class="calibre9">j<sup class="calibre15">th</sup></em></span> feature. So, what this formula is essentially telling us is that for every feature, take the square of the difference in values of the two observations, sum up all these squared differences, and then take the square root of the result. There are many other possible definitions of distance, but this is one of the most frequently encountered in the kNN setting. We'll see more distance metrics in <a class="calibre1" title="Chapter 11. Topic Modeling" href="part0082_split_000.html#2E6E41-c6198d576bbb4f42b630392bd61137d7">Chapter 11</a>, <span class="strong"><em class="calibre9">Recommendation Systems</em></span>.</p><p class="calibre8">In order <a id="id32" class="calibre1"/>to find the nearest neighbors of our new sample iris flower, we'll have to compute the distance to every point in the iris dataset and then sort the results. We'll begin by subsetting the iris data frame to include only our features, thus excluding the species column, which is what we are trying to predict. We'll then define our own function to compute the Euclidean distance. Next, we'll use this to compute the distance to every iris observation in our data frame using the <code class="email">apply()</code> function. Finally, we'll use the <code class="email">sort()</code> function of R with the <code class="email">index.return</code> parameter set to <code class="email">TRUE</code>, so that we also get back the indexes of the row numbers in our iris data frame corresponding to each distance computed:</p><div class="informalexample"><pre class="programlisting">&gt; iris_features &lt;- iris[1:4]
&gt; dist_eucl &lt;- function(x1, x2) sqrt(sum((x1 - x2) ^ 2))
&gt; distances &lt;- apply(iris_features, 1,
                     function(x) dist_eucl(x, new_sample))
&gt; distances_sorted &lt;- sort(distances, index.return = T)

&gt; str(distances_sorted)
List of 2
 $ x : num [1:150] 0.574 0.9 0.9 0.949 0.954 ...
 $ ix: int [1:150] 60 65 107 90 58 89 85 94 95 99 ...</pre></div><p class="calibre8">The <code class="email">$x</code> attribute contains the actual values of the distances computed between our sample iris flower and the observations in the iris data frame. The <code class="email">$ix</code> attribute contains the row numbers of the corresponding observations. If we want to find the five nearest neighbors, we can subset our original iris data frame using the first five entries from the <code class="email">$ix</code> attribute as the row numbers:</p><div class="informalexample"><pre class="programlisting">&gt; nn_5 &lt;- iris[distances_sorted$ix[1:5],]
&gt; nn_5
    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
60           5.2         2.7          3.9         1.4 versicolor
65           5.6         2.9          3.6         1.3 versicolor
107          4.9         2.5          4.5         1.7 virginica
90           5.5         2.5          4.0         1.3 versicolor
58           4.9         2.4          3.3         1.0 versicolor</pre></div><p class="calibre8">As we can see, four of the five nearest neighbors to our sample are the <span class="strong"><em class="calibre9">versicolor</em></span> species, while the remaining one is the <span class="strong"><em class="calibre9">virginica</em></span> species. For this type of problem where we are picking a class label, we can use a majority vote as our averaging technique to make our final prediction. Consequently, we would label our new sample as belonging to the versicolor species. Notice that setting the value of <span class="strong"><em class="calibre9">k</em></span> to an odd number is a good idea, because it makes it less likely that we will have to contend with tie votes (and completely eliminates ties when the number of output labels is two). </p><p class="calibre8">In the case of a tie, the convention is usually to <a id="id33" class="calibre1"/>just resolve it by randomly picking among the tied labels. Notice that nowhere in this process have we made any attempt to describe how our <a id="id34" class="calibre1"/>four features are related to our output. As a result, we often refer to the kNN model as a <span class="strong"><strong class="calibre2">lazy learner</strong></span> because essentially, all it has done is memorize the training data and use it directly during a prediction. We'll have more to say about our kNN model, but first we'll return to our general discussion on models and discuss different ways to classify them.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Types of model"><div class="book" id="F8902-c6198d576bbb4f42b630392bd61137d7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Types of model</h1></div></div></div><p class="calibre8">With a <a id="id35" class="calibre1"/>broad idea of the basic components of a model, we are ready to explore some of the common distinctions that modelers use to categorize different models.</p></div>

<div class="book" title="Types of model">
<div class="book" title="Supervised, unsupervised, semi-supervised, and reinforcement learning models"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec10" class="calibre1"/>Supervised, unsupervised, semi-supervised, and reinforcement learning models</h2></div></div></div><p class="calibre8">We've <a id="id36" class="calibre1"/>already looked at the iris dataset, which consists of four <a id="id37" class="calibre1"/>features and one output variable, namely the species variable. Having the output variable available for all the observations in the training data is the <a id="id38" class="calibre1"/>defining characteristic of the <span class="strong"><strong class="calibre2">supervised learning</strong></span> setting, which represents the most frequent scenario encountered. In a nutshell, the advantage <a id="id39" class="calibre1"/>of training <a id="id40" class="calibre1"/>a model under the supervised learning setting is that we have the correct answer that we should be predicting for the data points in our training data. As we <a id="id41" class="calibre1"/>saw in the previous section, kNN is a model that uses supervised learning, because the model makes its prediction for an input point by combining the values of the output variable for a small number of neighbors to that point. In this book, we will primarily focus on supervised learning.</p><p class="calibre8">Using the availability of the value of the output variable as a way to discriminate between different models, we can also envisage a second scenario in which the output variable is not specified. This is known as the <span class="strong"><strong class="calibre2">unsupervised learning</strong></span> setting. An unsupervised version of the iris dataset would consist of only the four features. If we don't have the species output variable available to us, then we clearly have no idea as to which species each observation refers to. Indeed, we won't know how many species of flower are represented in the dataset, or how many observations belong to each species. At first glance, it would seem that without this information, no useful predictive task could be carried out. In fact, what we can do is examine the data and create groups of observations based on how similar they are to each other, using the four features available to us. This process is known as <span class="strong"><strong class="calibre2">clustering</strong></span>. One benefit of clustering is that we can discover natural groups of data points in <a id="id42" class="calibre1"/>our data; for example, we might be able to discover that <a id="id43" class="calibre1"/>the flower samples in an unsupervised version of our <a id="id44" class="calibre1"/>iris set form three distinct groups that correspond <a id="id45" class="calibre1"/>to three different <a id="id46" class="calibre1"/>species.</p><p class="calibre8">Between <a id="id47" class="calibre1"/>unsupervised and supervised methods, which are two absolutes <a id="id48" class="calibre1"/>in terms of the availability of the output variable, reside the <span class="strong"><strong class="calibre2">semi-supervised</strong></span> and <span class="strong"><strong class="calibre2">reinforcement learning</strong></span> settings. Semi-supervised models are built using data for which a (typically quite small) fraction contains the values for the output variable, while the rest of the data is completely unlabeled. Many such models first use the labeled portion of the dataset in order to train the model coarsely, then incorporate the unlabeled data by projecting labels predicted by the model trained up this point.</p><p class="calibre8">In a reinforcement learning setting the output variable is not available, but other information that is directly linked with the output variable is provided. One example is predicting the next best move to win a chess game, based on data from complete chess games. Individual chess moves do not have output values in the training data, but for every game, the collective sequence of moves for each player resulted in either a win or a loss. Due to space constraints, semi-supervised and reinforcement settings aren't covered in this book.</p></div></div>

<div class="book" title="Types of model">
<div class="book" title="Parametric and nonparametric models"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec11" class="calibre1"/>Parametric and nonparametric models</h2></div></div></div><p class="calibre8">In a previous <a id="id49" class="calibre1"/>section, we noted how most of the models we <a id="id50" class="calibre1"/>will encounter are <span class="strong"><strong class="calibre2">parametric models</strong></span>, and we saw an example of a simple linear model. Parametric <a id="id51" class="calibre1"/>models have the characteristic that they tend to define a <span class="strong"><strong class="calibre2">functional form</strong></span>. This means that they reduce the problem of selecting between all possible functions for the target function to a particular family of functions that form a parameter set. Selecting the specific function that will define the model essentially involves selecting precise values for the parameters. So, returning to our example of a three-feature linear model, we can see that we have the two following possible choices of parameters (the choices are infinite, of course; here we just demonstrate two specific ones):</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Parametric and nonparametric models" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Here, we have used a subscript on the output <span class="strong"><em class="calibre9">Y</em></span> variable to denote the two different possible models. Which of these might be a better choice? The answer is that it depends on the data. If we apply each of our models on the observations in our dataset, we will get the predicted output for every observation. With supervised learning, every observation in our training <a id="id52" class="calibre1"/>data is labeled with the correct value of the output variable. To assess our model's goodness of fit, we can define an error function that measures the degree to which our predicted outputs differ from the correct outputs. We then use this to pick between our two candidate models in this case, but more generally to iteratively improve a model by moving through a sequence of progressively better candidate models.</p><p class="calibre8">Some <a id="id53" class="calibre1"/>parametric models are more flexible than linear models, meaning that they can be used to capture a greater variety of possible functions. Linear models, which require that the output be a linearly weighted combination of the input features, are considered strict. We can intuitively see that a more flexible model is more likely to allow us to approximate our input data with greater accuracy; however, when we look at overfitting, we'll see that this is not always a good thing. Models that are more flexible also tend to be more complex and, thus, training them often proves to be harder than training less flexible models.</p><p class="calibre8">Models <a id="id54" class="calibre1"/>are not necessarily parameterized, in fact, the class of models that have no parameters is known (unsurprisingly) as <span class="strong"><strong class="calibre2">nonparametric models</strong></span>. Nonparametric models generally make no assumptions on the particular form of the output <a id="id55" class="calibre1"/>function. There are different ways of constructing a target function without parameters. <span class="strong"><strong class="calibre2">Splines</strong></span> are a common example of a nonparametric model. The key idea behind splines is that we envisage the output function, whose form is unknown to us, as being defined exactly at the points that correspond to all the observations in our training data. Between the points, the function is locally interpolated using smooth polynomial functions. Essentially, the output function is built in a piecewise manner in the space between the points in our training data. Unlike most scenarios, splines will guarantee 100% accuracy on the training data, whereas it is perfectly normal to have some errors in our training data. Another good example of a nonparametric model is the k-nearest neighbor algorithm that we've already seen.</p></div></div>

<div class="book" title="Types of model">
<div class="book" title="Regression and classification models"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec12" class="calibre1"/>Regression and classification models</h2></div></div></div><p class="calibre8">The distinction <a id="id56" class="calibre1"/>between <span class="strong"><strong class="calibre2">regression</strong></span> and <span class="strong"><strong class="calibre2">classification</strong></span> models has to <a id="id57" class="calibre1"/>do with the type of output we are trying to predict, and is <a id="id58" class="calibre1"/>generally relevant to supervised learning. Regression <a id="id59" class="calibre1"/>models try to predict a numerical or quantitative value, such as the stock market index, the amount of rainfall, or the cost of a project. Classification models try to predict a value from a finite (though still possibly large) set of classes or categories. Examples of this include predicting the topic of a website, the next word that will be typed by a user, a person's gender, or whether a patient has a particular disease given a series of symptoms. The majority of models that we will study in this book fall quite neatly into one of these two categories, although a few, such as neural networks, <a id="id60" class="calibre1"/>can be adapted to solve both types of problem. It is important to stress here that the distinction made is on the output only, and not on <a id="id61" class="calibre1"/>whether the feature values that are used to predict the output are quantitative or qualitative themselves. In general, features can be encoded in a way that allows both qualitative and quantitative features to be used in regression and classification models alike. Earlier, when we built a kNN model to predict the species of iris based on measurements of flower samples, we were solving a classification problem as our species output variable could take only one of three distinct labels. </p><p class="calibre8">The kNN approach can also be used in a regression setting; in this case, the model combines the numerical values of the output variable for the selected nearest neighbors by taking the mean or median in order to make its final prediction. Thus, kNN is also a model that can be used in both regression and classification settings.</p></div></div>

<div class="book" title="Types of model">
<div class="book" title="Real-time and batch machine learning models"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec13" class="calibre1"/>Real-time and batch machine learning models</h2></div></div></div><p class="calibre8">Predictive <a id="id62" class="calibre1"/>models can use <span class="strong"><strong class="calibre2">real-time machine learning</strong></span> or they can involve <span class="strong"><strong class="calibre2">batch learning</strong></span>. The term real-time machine learning <a id="id63" class="calibre1"/>can refer to two different scenarios, although it certainly does not refer to the idea that real-time machine learning involves <a id="id64" class="calibre1"/>making a prediction in real time, that is, within a <a id="id65" class="calibre1"/>predefined time limit that is typically small. For example, once trained, a neural network model can produce its prediction of the output using only a few computations (depending on the number of inputs and network layers). This is not, however, what we mean when we talk about real-time machine learning.</p><p class="calibre8">A good example of a model that uses real-time machine learning is a weather predictor that uses a stream of incoming readings from various meteorological instruments. Here, the real-time aspect of the model refers to the fact that we are taking only a recent window of readings in order to predict the weather. The further we go back in time, the less relevant the readings will be and we can, thus, choose to use only the latest information in order to make our prediction. Of course, models that are to be used in a real-time setting must also be able to compute their predictions quickly—it is not of much use if it takes hours for a system taking measurements in the morning to compute a prediction for the evening, as by the time the computation ends, the prediction won't be of much value.</p><p class="calibre8">When talking about models that take into account information obtained over a recent time frame to make a prediction, we generally refer to models that have been trained on data that is assumed to be representative of all the data for which the model will be asked to make a prediction in the future. A second interpretation of real-time machine learning arises when we describe models that detect that the properties of the process being modeled <a id="id66" class="calibre1"/>have shifted in some way. We will <a id="id67" class="calibre1"/>focus on examples of the first kind in this book when we look at time series models.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The process of predictive modeling"><div class="book" id="G6PI2-c6198d576bbb4f42b630392bd61137d7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>The process of predictive modeling</h1></div></div></div><p class="calibre8">By looking <a id="id68" class="calibre1"/>at some of the different characterizations of models, we've already hinted at various steps of the predictive modeling process. In this section, we will present these steps in a sequence and make sure we understand how each of these contributes to the overall success of the endeavor.</p></div>

<div class="book" title="The process of predictive modeling">
<div class="book" title="Defining the model's objective"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec14" class="calibre1"/>Defining the model's objective</h2></div></div></div><p class="calibre8">In a nutshell, the first step of every project is to figure out precisely what the desired outcome is, as this <a id="id69" class="calibre1"/>will help steer us to make good decisions throughout the course of the project. In a predictive analytics project, this question involves drilling into the type of prediction that we want to make and understanding the task in detail. For example, suppose we are trying to build a model that predicts employee churn for a company. We first need to define this task precisely, while trying to avoid making the problem overly broad or overly specific. We could measure churn as the percentage of new full time hires that defect from the company within their first six months. Notice that once we properly define the problem, we have already made some progress in thinking about what data we will have to work with. For example, we won't have to collect data from part-time contractors or interns. This task also means that we should collect data from our own company only, but at the same time recognize that our model might not necessarily be applicable to make predictions for the workforce of a different company. If we are only interested in churn, it also means that we won't need to make predictions about employee performance or sick days (although it wouldn't hurt to ask the person for whom we are building the model, to avoid surprises in the future).</p><p class="calibre8">Once we have a precise enough idea of the model we want to build, the next logical question to ask is what sort of performance we are interested in achieving, and how we will measure this. That is to say, we need to define a performance metric for our model and then a minimum threshold of acceptable performance. We will go into substantial detail on how to assess the performance of models in this book. For now, we want to emphasize that, although it is not unusual to talk about assessing the performance of a model after we have trained it on some data, in practice it is important to remember that defining the expectations and performance target for our model is something that a predictive modeler should discuss with the stakeholders of a project at the very beginning. Models are never perfect and it is easy to spiral into a mode of forever trying to improve performance. Clear performance goals are not only useful in guiding us to decide which methods to use, but also in knowing when our model is good enough.</p><p class="calibre8">Finally, we also need to think about the data that will be available to us when the time comes to collect it, and the context in which the model will be used. For example, suppose we <a id="id70" class="calibre1"/>know that our employee churn model will be used as one of the factors that determine whether a new applicant in our company will be hired. In this context, we should only collect data from our existing employees who were available before they were hired. We cannot use the result of their first performance review, as this data won't be available for a prospective applicant.</p></div></div>

<div class="book" title="The process of predictive modeling">
<div class="book" title="Collecting the data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec15" class="calibre1"/>Collecting the data</h2></div></div></div><p class="calibre8">Training a <a id="id71" class="calibre1"/>model to make predictions is often a data-intensive venture, and if there is one thing that you can never have too much of in this business, it is data. Collecting the data can often be the most time- and resource-consuming part of the entire process, which is why it is so critical that the first step of defining the task and identifying the right data to be collected is done properly. When we learn about how a model such as logistic regression works we often do this by way of an example dataset and this is largely the approach we'll follow in this book. Unfortunately, we don't have a way to simulate the process of collecting the data, and it may seem that most of the effort is spent on training and refining a model. When learning about models using existing datasets, we should bear in mind that a lot of effort has usually gone into collecting, curating, and preprocessing the data. We will look at data preprocessing more closely in a subsequent section.</p><p class="calibre8">While we are collecting data, we should always keep in mind whether we are collecting the right kind of data. Many of the sanity checks that we perform on data during preprocessing also apply during collection, in order for us to spot whether we have made a mistake early on in the process. For example, we should always check that we measure features correctly and in the right units. We should also make sure that we collect data from sources that are sufficiently recent, reliable, and relevant to the task at hand. In the employee churn model we described in the previous section, as we collect information about past employees we should ensure that we are consistent in measuring our features. For example, when measuring how many days a person has been working in our company, we should consistently use either calendar days or business days. We must also check that when collecting dates, such as when a person joined or left the company, we invariably either use the US format (month followed by day) or the European format (day followed by month) and do not mix the two, otherwise a date like 03/05/2014 will be ambiguous. We should also try to get information from as broad a sample as possible and not introduce a hidden bias in our data collection. For example, if we wanted a general model for employee churn, we would not want to collect data from only female employees or employees from a single department.</p><p class="calibre8">How do we know when we have collected enough data? Early on when we are collecting the data and have not built and tested any model, it is impossible to tell how much data we will eventually need, and there aren't any simple rules of thumb that we can follow. We can, however, anticipate that certain characteristics of our problem will require more data. For example, when building a classifier that will learn to predict from one of three classes, we may want to check whether we have enough observations representative of each class.</p><p class="calibre8">The greater <a id="id72" class="calibre1"/>the number of output classes we have, the more data we will need to collect. Similarly, for regression models, it is also useful to check that the range of the output variable in the training data corresponds to the range that we would like to predict. If we are building a regression model that covers a large output range, we will also need to collect more data compared to a regression model that covers a smaller output range under the same accuracy requirements.</p><p class="calibre8">Another important factor to help us estimate how much data we will need, is the desired model performance. Intuitively, the higher the accuracy that we need for our model, the more data we should collect. We should also be aware that improving model performance is not a linear process. Getting from 90 to 95% accuracy can often require more effort and a lot more data, compared to making the leap from 70 to 90%. Models that have fewer parameters or are simpler in their design, such as linear regression models, often tend to need less data than more complex models such as neural networks. Finally, the greater the number of features that we want to incorporate into our model, the greater the amount of data we should collect. In addition, we should be aware of the fact that this requirement for additional data is also not going to be linear. That is to say, building a model with twice the number of features often requires much more than twice the amount of original data. This should be readily apparent, if we think of the number of different combinations of inputs our model will be required to handle. Adding twice the number of dimensions results in far more than twice the number of possible input combinations. To understand this, suppose we have a model with three input features, each of which takes 10 possible values. We have <span class="strong"><em class="calibre9">10<sup class="calibre15">3</sup></em></span>
<span class="strong"><em class="calibre9"> = 1000</em></span> possible input combinations. Adding a single extra feature that also takes 10 values raises this to 10,000 possible combinations, which is much more than twice the number of our initial input combinations.</p><p class="calibre8">There <a id="id73" class="calibre1"/>have been attempts to obtain a more quantifiable view of whether we have enough data for a particular dataset, but we will not have time to cover them in this book. A good place to start learning more about this area of predictive modeling is to study <span class="strong"><strong class="calibre2">learning curves</strong></span>. In a nutshell, with this approach we build consecutive models on the same dataset by starting off with a small portion of the data and successively adding more. The idea is that if throughout this process the predictive accuracy on testing data always improves without tapering off, we probably could benefit from obtaining more data. As a final note for the data collection phase, even if we think we have enough data, we should always consider how much it would cost us (in terms of time and resources) in order to get more data, before making the choice to stop collecting and begin modeling.</p></div></div>

<div class="book" title="The process of predictive modeling">
<div class="book" title="Picking a model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec16" class="calibre1"/>Picking a model</h2></div></div></div><p class="calibre8">Once we <a id="id74" class="calibre1"/>are clear on the prediction task, and we have the right kind of data, the next step is to pick our first model. To begin with, there is no best model overall, not even a best model using a few rules of thumb. In most cases, it makes sense to start off with a simple model, such as a Naïve Bayes model or a logistic regression in the case of a classification task, or a linear model in the case of regression. A simple model will give us a starting baseline performance, which we can then strive to improve. A simple model to start off with might also help in answering useful questions, such as how each feature contributes to the result, that is, how important is each feature and is the relationship with the output positively or negatively correlated. Sometimes, this kind of analysis itself warrants the production of a simple model first, followed by a more complex one, which will be used for the final prediction.</p><p class="calibre8">Sometimes a simple model might give us enough accuracy for the task at hand so that we won't need to invest more effort in order to give us a little bit extra. On the other hand, a simple model will often end up being inadequate for the task, requiring us to pick something more complicated. Choosing a more complex model over a simpler one is not always a straightforward decision, even if we can see that the accuracy of the complex model will be much better. Certain constraints, such as the number of features we have or the availability of data, may prevent us from moving to a more complex model. Knowing how to choose a model involves understanding the various strengths and limitations of the models in our toolkit. For every model we encounter in this book, we will pay particular attention to learning these points. In a real-world project, to help guide our decision, we often go back to the task requirements and ask a few questions, such as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">What type of task do we have? Some models are only suited for particular tasks such as regression, classification, or clustering.</li><li class="listitem">Does the model need to explain its predictions? Some models, such as decision trees, are better at giving insights that are easily interpretable to explain why they made a particular prediction.</li><li class="listitem">Do we have any constraints on prediction time?</li><li class="listitem">Do we need to update the model frequently and is training time, therefore, important?</li><li class="listitem">Does the model work well if we have highly correlated features?</li><li class="listitem">Does the model scale well for the number of features and amount of data that we have available? If we have massive amounts of data, we may need a model whose training procedure can be parallelized to take advantage of parallel computer architectures, for example.</li></ul></div><p class="calibre8">In practice, even if our first analysis points towards a particular model, we will most likely want <a id="id75" class="calibre1"/>to try out a number of options before making our final decision.</p></div></div>

<div class="book" title="The process of predictive modeling">
<div class="book" title="Pre-processing the data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec17" class="calibre1"/>Pre-processing the data</h2></div></div></div><p class="calibre8">Before we <a id="id76" class="calibre1"/>can use our data to train our model, we typically need to preprocess it. In this section, we will discuss a number of common <a id="id77" class="calibre1"/>preprocessing steps that we usually perform. Some of these are necessary in order to detect and resolve problems in our data, while others are useful in order to transform our data and make them applicable to the model we have chosen.</p><div class="book" title="Exploratory data analysis"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Exploratory data analysis</h3></div></div></div><p class="calibre8">Once we <a id="id78" class="calibre1"/>have some data and have decided to start working on a particular model, the very first thing we'll want to do is to look at the data itself. This is not necessarily a very structured part of the process; it mostly involves understanding <a id="id79" class="calibre1"/>what each feature measures and getting a sense of the data we have collected. It is really important to understand what each feature represents and the units in which it is measured. It is also a really good idea to check the consistent use of units. We sometimes call this investigative process of exploring and visualizing our data <span class="strong"><strong class="calibre2">exploratory data analysis</strong></span>.</p><p class="calibre8">An excellent practice is to use the <code class="email">summary()</code> function of R on our data frame to obtain some basic metrics for each feature, such as the mean and variance, as well as the largest and smallest values. Sometimes, it is easy to spot that a mistake has been made in data collection through inconsistencies in the data. For example, for a regression problem, multiple observations with identical feature values but wildly different outputs may (depending on the application) be a signal that there are erroneous measurements. Similarly, it is a good idea to know whether there are any features that have been measured in the presence of significant noise. This may sometimes lead to a different choice of model or it may mean that the feature should be ignored.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8">Another useful function used to summarize features in a data frame is the <code class="email">describe()</code> function in the <code class="email">psych</code> package. This returns information about how skewed each feature is, as well as the usual measures of a location (such as the mean and median) and dispersion (such as the standard deviation).</p></div><p class="calibre8">An essential part of exploratory data analysis is to use plots to visualize our data. There is a diverse array of plots that we can use depending on the context. For example, we might want to create box plots of our numerical features to visualize ranges and quartiles. Bar plots and mosaic plots are useful to visualize the proportions of our data under different combinations of values for categorical input features. We won't go into further detail on information <a id="id80" class="calibre1"/>visualization, as this is a field in its own <a id="id81" class="calibre1"/>right.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">R is an excellent platform to create visualizations. The <code class="email">base</code> R package provides a number of different functions to plot data. Two excellent packages to create more advanced plots are <code class="email">lattice</code> and <code class="email">ggplot2</code>. Good references for these two, which also cover principles used to make effective visualizations, are <span class="strong"><em class="calibre9">Lattice: Multivariate Data Visualization with R</em></span> and <span class="strong"><em class="calibre9">ggplot2: Elegant Graphics for Data Analysis</em></span>, both of which are published by Springer under the Use R! series.</p></div></div><div class="book" title="Feature transformations"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Feature transformations</h3></div></div></div><p class="calibre8">Often, we'll <a id="id82" class="calibre1"/>find that our numerical features are measured on scales that are completely different from each other. For example, we might measure a person's body temperature in degrees Celsius, so the numerical values will typically be in the range of 36-38. At the same time, we might also measure a person's white blood cell count per microliter of blood. This feature generally takes values in the thousands. If we are to use these features as an input to an algorithm, such as kNN, we'd find that the large values of the white blood cell count feature dominate the Euclidean distance calculation. We could have several features in our input that are important and useful for classification, but if they were measured on scales that produce numerical values much smaller than one thousand, we'd essentially be picking our nearest neighbors mostly on the basis <a id="id83" class="calibre1"/>of a single feature, namely the white blood cell count. This problem comes up often and applies to many models, not just kNN. We handle this by transforming (also referred to as scaling) our input features before using them in our model.</p><p class="calibre8">We'll discuss three popular options for feature scaling. When we know that our input features are close to being normally distributed, one possible transformation to use is <span class="strong"><strong class="calibre2">Z-score normalization</strong></span>, which works by subtracting the mean and dividing it by the standard deviation:</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Feature transformations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">
<span class="strong"><em class="calibre9">E(x)</em></span> is the expectation or mean of <span class="strong"><em class="calibre9">x</em></span>, and the standard deviation is the square root of the variance of <span class="strong"><em class="calibre9">x</em></span>, written as <span class="strong"><em class="calibre9">Var(x)</em></span>. Notice that as a result of this transformation, the new feature will be centered on a mean of zero and will have unit variance. Another possible transformation, which is better when the input is uniformly distributed, is to scale all the features and outputs so that they lie within a single interval, typically the unit interval <span class="strong"><em class="calibre9">[0,1]</em></span>:</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Feature transformations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">A <a id="id84" class="calibre1"/>third option is known as the <span class="strong"><strong class="calibre2">Box-Cox transformation</strong></span>. This is often applied when our input features are highly skewed (asymmetric) and our <a id="id85" class="calibre1"/>model requires the input features to be normally distributed or symmetrical at the very least:</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Feature transformations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">As <span class="strong"><em class="calibre9">λ</em></span> is in the denominator, it must take a value other than zero. The transformation is actually defined for a zero-valued <span class="strong"><em class="calibre9">λ</em></span>: in this case, it is given by the natural logarithm of the input feature, <span class="strong"><em class="calibre9">ln(x)</em></span>. Notice that this is a parameterized transform and so there is a need to specify a concrete value of <span class="strong"><em class="calibre9">λ</em></span>. There are various ways to estimate an appropriate value for <span class="strong"><em class="calibre9">λ</em></span> from the data itself. Indicatively, we'll mention a technique to do this, known as cross-validation, which we will encounter later on in this book in <a class="calibre1" title="Chapter 5. Neural Networks" href="part0045_split_000.html#1AT9A1-c6198d576bbb4f42b630392bd61137d7">Chapter 5</a>, <span class="strong"><em class="calibre9">Support Vector Machines</em></span>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">The original reference for the Box-Cox transformation is a paper published in 1964 by the Journal of the Royal Statistical Society, titled <span class="strong"><em class="calibre9">An analysis of Transformations</em></span> and authored by <span class="strong"><em class="calibre9">G. E. P. Box</em></span> and <span class="strong"><em class="calibre9">D. R. Cox</em></span>.</p></div><p class="calibre8">To get a feel for how these transformations work in practice, we'll try them out on the <code class="email">Sepal.Length</code> feature from our iris dataset. Before we do this, however, we'll introduce the first R package that we will be working with, <code class="email">caret</code>.</p><p class="calibre8">The <code class="email">caret</code> package is a very useful package that has a number of goals. It provides a number of helpful functions that are commonly used in the process of predictive modeling, from data preprocessing and visualization, to feature selection and resampling techniques. It also features a unified interface for many predictive modeling functions and provides functionalities for parallel processing.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">The definitive reference for predictive modeling using the <code class="email">caret</code> package is a book called <span class="strong"><em class="calibre9">Applied Predictive Modeling</em></span>, written by <span class="strong"><em class="calibre9">Max Kuhn</em></span> and <span class="strong"><em class="calibre9">Kjell Johnson</em></span> and published by <span class="strong"><em class="calibre9">Springer</em></span>. <span class="strong"><em class="calibre9">Max Kuhn</em></span> is the principal author of the <code class="email">caret</code> package itself. The book also comes with a companion website at <a class="calibre1" href="http://appliedpredictivemodeling.com">http://appliedpredictivemodeling.com</a>.</p></div><p class="calibre8">When we transform our input features on the data we use to train our model, we must remember <a id="id86" class="calibre1"/>that we will need to apply the same transformation to the features of later inputs that we will use at prediction time. For this reason, transforming data using the <code class="email">caret</code> package is done in two steps. In the first step, we use the <code class="email">preProcess()</code> function that stores the parameters of the transformations to be applied to the data, and in the second step, we use the <code class="email">predict()</code> function to actually compute the transformation. We tend to use the <code class="email">preProcess()</code> function only once, and then the <code class="email">predict()</code> function every time we need to apply the same transformation to some data. The <code class="email">preProcess()</code> function takes a data frame with some numerical values as its first input, and we will also specify a vector containing the names of the transformations to be applied to the <code class="email">method</code> parameter. The <code class="email">predict()</code> function then takes the output of the previous function along with the data we want to transform, which in the case of the training data itself may well be the same data frame. Let's see all this in action:</p><div class="informalexample"><pre class="programlisting">&gt; library("caret")
&gt; iris_numeric &lt;- iris[1:4]
&gt; pp_unit &lt;- preProcess(iris_numeric, method = c("range"))
&gt; iris_numeric_unit &lt;- predict(pp_unit, iris_numeric)
&gt; pp_zscore &lt;- preProcess(iris_numeric, method = c("center", "scale"))
&gt; iris_numeric_zscore &lt;- predict(pp_zscore, iris_numeric)
&gt; pp_boxcox &lt;- preProcess(iris_numeric, method = c("BoxCox"))
&gt; iris_numeric_boxcox &lt;- predict(pp_boxcox, iris_numeric)</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Downloading the example code:</strong></span>
</p><p class="calibre8">You can download the example code files from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre8">We've created three new versions of the numerical features of the iris data, with the difference being that in each case we used a different transformation. We can visualize the effects of our transformations by plotting the density of the <code class="email">Sepal.Length</code> feature for each scaled data frame using the <code class="email">density()</code> function and plotting the results, as shown here:</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Feature transformations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Notice that the Z-score and unit interval transformations preserve the overall shape of the density <a id="id87" class="calibre1"/>while shifting and scaling the values, whereas the Box-Cox transformation also changes the overall shape, resulting in a density that is less skewed than the original.</p></div><div class="book" title="Encoding categorical features"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>Encoding categorical features</h3></div></div></div><p class="calibre8">Many models, from linear regression to neural networks, require all the inputs to be numerical, and <a id="id88" class="calibre1"/>so we often need a way to encode categorical fields on a numerical scale. For example, if we have a size feature that takes values in the set <span class="strong"><em class="calibre9">{small, medium, large}</em></span>, we may want to represent this with the numerical values 1, 2, and 3, respectively. In the case of ordered categories, such as the size feature just described, this mapping probably makes sense.</p><p class="calibre8">The number 3 is the largest on this scale and this corresponds to the <span class="strong"><em class="calibre9">large</em></span> category, which is further away from the <span class="strong"><em class="calibre9">small</em></span> category, represented by the number 1 than it is from the <span class="strong"><em class="calibre9">medium</em></span> category, represented by the value 2. Using this scale is only one possible mapping, and in particular, it forces the <span class="strong"><em class="calibre9">medium</em></span> category to be equidistant from the <span class="strong"><em class="calibre9">large</em></span> and <span class="strong"><em class="calibre9">small</em></span> categories, which may or may not be appropriate based on our knowledge <a id="id89" class="calibre1"/>about the specific feature. In the case of unordered categories, such as brands or colors, we generally avoid mapping them onto a single numerical scale. For example, if we mapped the set <span class="strong"><em class="calibre9">{blue, green, white, red, orange}</em></span> to the numbers one through five, respectively, then this scale is arbitrary and there is no reason why <span class="strong"><em class="calibre9">red</em></span> is closer to <span class="strong"><em class="calibre9">white</em></span> and far from <span class="strong"><em class="calibre9">blue</em></span>. To overcome this, we create a series of indicator features, <span class="strong"><em class="calibre9">I<sub class="calibre14">i</sub></em></span>, which take the following form:</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Encoding categorical features" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">We need as many indicator features as we have categories, so for our color example, we would create five indicator features. In this case, <span class="strong"><em class="calibre9">I<sub class="calibre14">1</sub></em></span>, might be:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Encoding categorical features" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In this way, our original color feature will be mapped to five indicator features and for every observation, only one of these indicator features takes the value 1 and the rest will be 0 as each observation will involve one color value in our original feature. Indicator features are binary features as they only take on two values: 0 and 1.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">We may often encounter an alternative approach that uses only <span class="strong"><em class="calibre9">n-1</em></span> binary features to encode <span class="strong"><em class="calibre9">n</em></span> levels of a factor. This is done by choosing one level to be the reference level and it is indicated where each one of the <span class="strong"><em class="calibre9">n-1</em></span> binary features takes the value 0. This can be more economical on the number of features and avoids introducing a linear dependence between them, but it violates the property that all features are equidistant from each other.</p></div></div><div class="book" title="Missing data"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec04" class="calibre1"/>Missing data</h3></div></div></div><p class="calibre8">Sometimes, data contains missing values, where, for certain observations, some features were unavailable <a id="id90" class="calibre1"/>or could not properly be measured. For example, suppose that in our iris dataset, we lost the measurement for a particular observation's petal length. We would then have a missing value for this flower sample in the <code class="email">Petal.Length</code> feature. Most models do not have an innate ability to handle missing data. Typically, a missing value appears in our data as a blank entry or the symbol <span class="strong"><em class="calibre9">NA</em></span>. We should check whether missing values are actually present in our data, but have been erroneously assigned a value, such as <span class="strong"><em class="calibre9">0</em></span>, which is often a very legitimate feature value.</p><p class="calibre8">Before deciding how to handle missing data, especially when our approach will be to simply throw away observations with missing values, we should recognize that the particular <a id="id91" class="calibre1"/>values that are missing might follow a pattern. Concretely, we often distinguish between different so-called mechanisms for missing values. In the ideal <span class="strong"><strong class="calibre2">Missing Completely At Random</strong></span> (<span class="strong"><strong class="calibre2">MCAR</strong></span>) scenario, missing values occur independently from the true values of the features in which they occur, as well as from all other features. In this scenario, if we are missing a value for the length of a particular iris flower petal, then this occurs independently from how long the <a id="id92" class="calibre1"/>flower petal actually was and the value of any other feature, such as whether the observation was from the <span class="strong"><em class="calibre9">versicolor</em></span> species or the <span class="strong"><em class="calibre9">setosa</em></span> species. The <span class="strong"><strong class="calibre2">Missing At Random</strong></span> (<span class="strong"><strong class="calibre2">MAR</strong></span>) scenario is a less ideal situation. Here, a missing value is independent of the true value of the feature in question, but may be correlated with another feature. An example of this scenario is when missing petal length values <a id="id93" class="calibre1"/>mostly occur in the <span class="strong"><em class="calibre9">setosa</em></span> samples in our iris dataset, as long as they still occur independently of the true petal length values. </p><p class="calibre8">In the <span class="strong"><strong class="calibre2">Missing Not At Random</strong></span> (<span class="strong"><strong class="calibre2">MNAR</strong></span>) scenario, which is the most problematic case, there is some sort of a pattern that explains when values might be missing based on the true values of the feature itself. For example, if we had difficulty in measuring very small petal lengths and ended up with missing values as a result, simply removing the incomplete samples would result in a sample of observations with above average petal lengths, and so our data would be biased.</p><p class="calibre8">There are a number of ways to handle missing values, but we will not delve deeply into this problem in this book. In the rare cases where we have missing values, we will exclude them from our datasets, but be aware that in a real project, we would investigate the source of the missing values in order to be sure that we can do this safely. Another approach is to attempt to guess or impute the missing values. The kNN algorithm itself is one way to do this by finding the nearest neighbors of a sample with a missing value in one feature. This is done by using a distance computation that excludes the dimension that contains the missing value. The missing value is then computed as the mean of the values of the nearest neighbors in this dimension.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8">The interested reader can find a detailed treatment of how to handle missing values in <span class="strong"><em class="calibre9">Statistical Analysis with Missing Data</em></span>, <span class="strong"><em class="calibre9">Second Edition</em></span>, by <span class="strong"><em class="calibre9">Roderick J. A. Little</em></span> and <span class="strong"><em class="calibre9">Donald B. Rubin</em></span>, published by Wiley.</p></div></div><div class="book" title="Outliers"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec05" class="calibre1"/>Outliers</h3></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Outliers</strong></span> are <a id="id94" class="calibre1"/>also a problem that often needs to be addressed. An outlier is a particular observation that is very far from the rest of the data in one or more of its features. In some cases, this may represent an actual rare circumstance that is a legitimate behavior for the system we are trying to model. In other cases, it may be that there has been an error in measurement. For example, when reporting the ages of people, a value of 110 might be an outlier, which could happen because of a reporting error on an actual value of 11. It could also be the result of a valid, albeit extremely rare measurement. Often, the domain of our problem will give us a good indication of whether outliers are likely to be measurement errors or not, and if so, as part of preprocessing the data, we will often want to exclude outliers from our data completely. In <a class="calibre1" title="Chapter 2. Tidying Data and Measuring Performance" href="part0019_split_000.html#I3QM1-c6198d576bbb4f42b630392bd61137d7">Chapter 2</a>, <span class="strong"><em class="calibre9">Linear Regression</em></span>, we will look at outlier exclusion in more detail.</p></div><div class="book" title="Removing problematic features"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec06" class="calibre1"/>Removing problematic features</h3></div></div></div><p class="calibre8">Preprocessing <a id="id95" class="calibre1"/>a dataset can also involve the decision to drop some of the features if we know that they will cause us problems with our model. A common example is when two or more features are highly correlated with each other. In R, we can easily compute pairwise correlations on a data frame using the <code class="email">cor()</code> function:</p><div class="informalexample"><pre class="programlisting">&gt; cor(iris_numeric)
             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length    1.0000000  -0.1175698    0.8717538   0.8179411
Sepal.Width    -0.1175698   1.0000000   -0.4284401  -0.3661259
Petal.Length    0.8717538  -0.4284401    1.0000000   0.9628654
Petal.Width     0.8179411  -0.3661259    0.9628654   1.0000000</pre></div><p class="calibre8">Here, we can see that the <code class="email">Petal.Length</code> feature is very highly correlated with the <code class="email">Petal.Width</code> feature, with the correlation exceeding 0.96. The <code class="email">caret</code> package offers the <code class="email">findCorrelation()</code> function, which takes a correlation matrix as an input, and the optional <code class="email">cutoff</code> parameter, which specifies a threshold for the absolute value of a pairwise correlation. This then returns a (possibly zero length) vector that shows the columns to be removed from our data frame due to correlation. The default setting of <code class="email">cutoff</code> is 0.9:</p><div class="informalexample"><pre class="programlisting">&gt; iris_cor &lt;- cor(iris_numeric)
&gt; findCorrelation(iris_cor)
[1] 3
&gt; findCorrelation(iris_cor, cutoff = 0.99)
integer(0)
&gt; findCorrelation(iris_cor, cutoff = 0.80)
[1] 3 4</pre></div><p class="calibre8">An alternative approach to removing correlation is a complete transformation of the entire feature <a id="id96" class="calibre1"/>space as is done in many methods for <a id="id97" class="calibre1"/>dimensionality reduction, such as <span class="strong"><strong class="calibre2">Principal Component Analysis</strong></span> (<span class="strong"><strong class="calibre2">PCA</strong></span>) and <span class="strong"><strong class="calibre2">Singular Value Decomposition</strong></span> (<span class="strong"><strong class="calibre2">SVD</strong></span>). We'll see <a id="id98" class="calibre1"/>the former shortly, and the latter we'll visit in <a class="calibre1" title="Chapter 11. Topic Modeling" href="part0082_split_000.html#2E6E41-c6198d576bbb4f42b630392bd61137d7">Chapter 11</a>, <span class="strong"><em class="calibre9">Recommendation Systems</em></span>.</p><p class="calibre8">In a <a id="id99" class="calibre1"/>similar vein, we might want to remove features that are <span class="strong"><strong class="calibre2">linear combinations</strong></span> of each other. By linear combination of features, we mean a sum of features where each feature is multiplied by a scalar constant. To see how <code class="email">caret</code> deals with these, we will create a new iris data frame with two additional columns, which we will call <code class="email">Cmb</code> and <code class="email">Cmb.N</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&gt; new_iris &lt;- iris_numeric
&gt; new_iris$Cmb &lt;- 6.7 * new_iris$Sepal.Length –
                  0.9 * new_iris$Petal.Width
&gt; set.seed(68)
&gt; new_iris$Cmb.N &lt;- new_iris$Cmb +   
                    rnorm(nrow(new_iris), sd = 0.1)
&gt; options(digits = 4)
&gt; head(new_iris,n = 3)
  Sepal.Length Sepal.Width Petal.Length Petal.Width   Cmb Cmb.N
1          5.1         3.5          1.4         0.2 33.99 34.13
2          4.9         3.0          1.4         0.2 32.65 32.63
3          4.7         3.2          1.3         0.2 31.31 31.27</pre></div><p class="calibre8">As we can see, <code class="email">Cmb</code> is a perfect linear combination of the <code class="email">Sepal.Length</code> and <code class="email">Petal.Width</code> features. <code class="email">Cmb.N</code> is a feature that is the same as <code class="email">Cmb</code>, but with some added Gaussian noise with a mean of zero and a very small standard deviation (<span class="strong"><em class="calibre9">0.1</em></span>), so that the values are very close to those of <code class="email">Cmb</code>. The <code class="email">caret</code> package can detect exact linear combinations of features, though not if the features are noisy, using the <code class="email">findLinearCombos()</code> function:</p><div class="informalexample"><pre class="programlisting">&gt; findLinearCombos(new_iris)
$linearCombos
$linearCombos[[1]]
[1] 5 1 4

$remove
[1] 5</pre></div><p class="calibre8">As we can see, the function only suggests that we should remove the fifth feature (<code class="email">Cmb</code>) from our data frame, because it is an exact linear combination of the first and fourth features. Exact linear combinations are rare, but can sometimes arise when we have a very large number of features and redundancy occurs between them. Both correlated features as well as linear combinations are an issue with linear regression models, as we shall soon see in <a class="calibre1" title="Chapter 2. Tidying Data and Measuring Performance" href="part0019_split_000.html#I3QM1-c6198d576bbb4f42b630392bd61137d7">Chapter 2</a>, <span class="strong"><em class="calibre9">Linear Regression</em></span>. In this chapter, we'll also see a method of detecting features that are very nearly linear combinations of each other.</p><p class="calibre8">A final issue that we'll look at for problematic features, is the issue of having features that do not vary at all in our dataset, or that have near zero variance. For some models, having these <a id="id100" class="calibre1"/>types of feature does not cause us problems. For others, it may create problems and we'll demonstrate why this is the case. As in the previous example, we'll create a new iris data frame, as follows:</p><div class="informalexample"><pre class="programlisting">&gt; newer_iris &lt;- iris_numeric
&gt; newer_iris$ZV &lt;- 6.5
&gt; newer_iris$Yellow &lt;- ifelse(rownames(newer_iris) == 1, T, F
&gt; head(newer_iris, n = 3)
  Sepal.Length Sepal.Width Petal.Length Petal.Width  ZV Yellow
1          5.1         3.5          1.4         0.2 6.5   TRUE
2          4.9         3.0          1.4         0.2 6.5  FALSE
3          4.7         3.2          1.3         0.2 6.5  FALSE</pre></div><p class="calibre8">The <code class="email">ZV</code> column has the constant number of <code class="email">6.5</code> for all observations. The <code class="email">Yellow</code> column is a fictional column that records whether an observation had some yellow color on the petal. All the observations, except the first, are made to have this feature set to <code class="email">FALSE</code> and so this is a near zero variance column. The <code class="email">caret</code> package uses a definition of near zero variance that checks whether the number of unique values that a feature takes as compared to the overall number of observations is very small, or whether the ratio of the most common value to the second most common value (referred to as the frequency ratio) is very high. The <code class="email">nearZeroVar()</code> function applied to a data frame returns a vector containing the features that have zero or near zero variance. By setting the <code class="email">saveMetrics</code> parameter to <code class="email">TRUE</code>, we can see more information about the features in our data frame:</p><div class="informalexample"><pre class="programlisting">&gt; nearZeroVar(newer_iris)
[1] 5 6
&gt; nearZeroVar(newer_iris, saveMetrics = T)
             freqRatio percentUnique zeroVar   nzv
Sepal.Length     1.111       23.3333   FALSE FALSE
Sepal.Width      1.857       15.3333   FALSE FALSE
Petal.Length     1.000       28.6667   FALSE FALSE
Petal.Width      2.231       14.6667   FALSE FALSE
ZV               0.000        0.6667    TRUE  TRUE
Yellow         149.000        1.3333   FALSE  TRUE</pre></div><p class="calibre8">Here, we can see that the <code class="email">ZV</code> column has been identified as a zero variance column (which is also by definition a near zero variance column). The <code class="email">Yellow</code> column does have a nonzero variance, but its high frequency ratio and low unique value percentage make it a near zero variance column. In practice, we tend to remove zero variance columns, as they don't have any information to give to our model. Removing near zero variance columns, however, is tricky and should be done with care. To understand this, consider the fact that a model for species prediction, using our newer iris dataset, might learn that if a sample has yellow in its petals, then regardless of all other predictors, we would predict the <span class="strong"><em class="calibre9">setosa</em></span> species, as this is the species that corresponds to the only observation in our entire dataset <a id="id101" class="calibre1"/>that had the color yellow in its petals. This might indeed be true in reality, in which case, the yellow feature is informative and we should keep it. On the other hand, the presence of the color yellow on iris petals may be completely random and non-indicative of species, but also an extremely rare event. This would explain why only one observation in our dataset had the yellow color in its petals. In this case, keeping the feature is dangerous because of the aforementioned conclusion. Another potential problem with keeping this feature will become apparent when we look at splitting our data into training and test sets, as well as other cases of data splitting, such as cross-validation, described in <a class="calibre1" title="Chapter 5. Neural Networks" href="part0045_split_000.html#1AT9A1-c6198d576bbb4f42b630392bd61137d7">Chapter 5</a>, <span class="strong"><em class="calibre9">Support Vector Machines</em></span>. Here, the issue is that one split in our data may lead to unique values for a near zero variance column, for example, only <code class="email">FALSE</code> values for our <code class="email">Yellow</code> iris column.</p></div></div></div>

<div class="book" title="The process of predictive modeling">
<div class="book" title="Feature engineering and dimensionality reduction"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec18" class="calibre1"/>Feature engineering and dimensionality reduction</h2></div></div></div><p class="calibre8">The number <a id="id102" class="calibre1"/>and type of features that we use with a model is one of the most important decisions that we will make in the predictive <a id="id103" class="calibre1"/>modeling process. Having the right features for a model will ensure that we have sufficient evidence on which to base a prediction. On the flip side, the number of features that we work with is precisely the number of dimensions that the model has. A large number of dimensions can be the source <a id="id104" class="calibre1"/>of several complications. High dimensional problems often suffer from <span class="strong"><strong class="calibre2">data sparsity</strong></span>, which means that because of the number of dimensions available, the range of possible combinations of values across all the features grows so large that it is unlikely that we will ever collect enough data in order to have enough representative <a id="id105" class="calibre1"/>examples for training. In a similar vein, we often talk about the <span class="strong"><strong class="calibre2">curse of dimensionality</strong></span>. This describes the fact that, because of the overwhelmingly large space of possible inputs, data points that we have collected are likely to be far away from each other in the feature space. As a result, local methods, such as k-nearest neighbors, that make predictions using observations in the training data that are close to the point for which we are trying to make a prediction, will not work as well in high dimensions. A large feature set is also problematic in that it may significantly increase the time needed to train (and predict, in some cases) our model.</p><p class="calibre8">Consequently, there are two types of process that feature engineering involves. The first of these, which grows the feature space, is the design of new features based on features within our data. Sometimes, a new feature that is a product or ratio of two original features might work better. There are many ways to combine existing features into new ones, and often it is expert knowledge from the problem's particular application domain that might help guide us. In general though, this process takes experience and a lot of trial and error. Note that there is no guarantee that adding a new feature will not degrade performance. Sometimes, adding a feature that is very noisy or highly correlated with an existing feature may actually cause us to lose accuracy.</p><p class="calibre8">The second <a id="id106" class="calibre1"/>process in feature engineering is feature reduction or shrinkage, which reduces the size of the feature space. In the <a id="id107" class="calibre1"/>previous section on data preprocessing, we looked at how we can detect individual features that may be problematic for our model <a id="id108" class="calibre1"/>in some way. <span class="strong"><strong class="calibre2">Feature selection</strong></span> refers to the process in which the subset of features that are the most informative for our target output is selected <a id="id109" class="calibre1"/>from the original pool of features. Some methods, such as tree-based models, have built-in feature selection, as we shall see in <a class="calibre1" title="Chapter 6. Support Vector Machines" href="part0055_split_000.html#1KEEU2-c6198d576bbb4f42b630392bd61137d7">Chapter 6</a>, <span class="strong"><em class="calibre9">Tree-based Methods</em></span>. In <a class="calibre1" title="Chapter 2. Tidying Data and Measuring Performance" href="part0019_split_000.html#I3QM1-c6198d576bbb4f42b630392bd61137d7">Chapter 2</a>, <span class="strong"><em class="calibre9">Linear Regression</em></span>, we'll also explore methods to perform <a id="id110" class="calibre1"/>feature selection for linear models. </p><p class="calibre8">Another way to reduce the overall number of features, a concept known as <span class="strong"><strong class="calibre2">dimensionality reduction</strong></span>, is to transform the entire set of features into a completely new set of features that are fewer in number. A classic example of this is <span class="strong"><strong class="calibre2">Principal Component Analysis</strong></span> (<span class="strong"><strong class="calibre2">PCA</strong></span>).</p><p class="calibre8">In a nutshell, PCA creates a new set of input features, known as <span class="strong"><strong class="calibre2">principal components</strong></span>, all of <a id="id111" class="calibre1"/>which are linear combinations of the original input features. For the first principal component, the linear combination weights are chosen in order to capture the maximum amount of variation in the data. If we could visualize the first principal component as a line in the original feature space, this would be the line in which the data varies the most. It also happens to be the line that is closest to all the data points in the original feature space. Every subsequent principal component attempts to capture a line of maximum variation, but in such a way that the new principal component is uncorrelated with the previous ones already computed. Thus, the second principal component selects the linear combination of original input features that have the highest degree of variation in the data, while being uncorrelated with the first principal component.</p><p class="calibre8">The principal components are ordered naturally in descending order according to the amount of variation that they capture. This allows us to perform dimensionality reduction in a simple manner by keeping the first <span class="strong"><em class="calibre9">N</em></span> components, where we choose <span class="strong"><em class="calibre9">N</em></span> so that the components chosen incorporate a minimum amount of the variance from the original dataset. We won't go into the details of the underlying linear algebra necessary to compute the principal components.</p><p class="calibre8">Instead, we'll direct our attention to the fact that this process is sensitive to the variance and scale of the original features. For this reason, we often scale our features before carrying out this process. To visualize how useful PCA can be, we'll once again turn to our faithful iris dataset. We can use the <code class="email">caret</code> package to carry out PCA. To do this, we specify <code class="email">pca</code> in the <code class="email">method</code> parameter of the <code class="email">preProcess()</code> function. We can also use the <code class="email">thresh</code> parameter, which specifies the minimum variance we must retain. We'll explicitly use the value <code class="email">0.95</code> so that we retain 95% of the variance of the original data, but note that this is also the default value of this parameter:</p><div class="informalexample"><pre class="programlisting">&gt; pp_pca &lt;- preProcess(iris_numeric,  method = c("BoxCox", "center", "scale", "pca"), thresh = 0.95)
&gt; iris_numeric_pca &lt;- predict(pp_pca, iris_numeric)
&gt; head(iris_numeric_pca, n = 3)
     PC1     PC2
1 -2.304 -0.4748
2 -2.151  0.6483
3 -2.461  0.3464</pre></div><p class="calibre8">As a <a id="id112" class="calibre1"/>result of this transformation, we are now left with only two features, so we can conclude that the first two principal components of the numerical iris features incorporate over 95% of the variation in the data.</p><p class="calibre8">If we <a id="id113" class="calibre1"/>are interested in learning the weights that were used to compute the principal components, we can inspect the <code class="email">rotation</code> attribute of the <code class="email">pp_pca</code> object:</p><div class="informalexample"><pre class="programlisting">&gt; options(digits = 2)
&gt; pp_pca$rotation
               PC1    PC2
Sepal.Length  0.52 -0.386
Sepal.Width  -0.27 -0.920
Petal.Length  0.58 -0.049
Petal.Width   0.57 -0.037</pre></div><p class="calibre8">This means that the first principal component, <code class="email">PC1</code>, was computed as follows:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Feature engineering and dimensionality reduction" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Sometimes, instead of directly specifying a threshold for the total variance captured by the principal <a id="id114" class="calibre1"/>components, we might want to examine a plot of each principal component and its variance. This is known as a <span class="strong"><strong class="calibre2">scree plot</strong></span>, and we can build this by first performing PCA and indicating that we want to keep all the components. To do this, instead of specifying a variance threshold, we set the <code class="email">pcaComp</code> parameter, which is the number of principal components we want to keep. We will set this to <code class="email">4</code>, which includes all of them, remembering that the total number of principal components is the same as the total number of original features or dimensions we started out with. We will then compute the variance and cumulative variance of these components and store it in a data frame. Finally, we will plot this in the figure that follows, noting that the numbers in brackets <a id="id115" class="calibre1"/>are cumulative percentages <a id="id116" class="calibre1"/>of variance captured:</p><div class="informalexample"><pre class="programlisting">&gt; pp_pca_full &lt;- preProcess(iris_numeric,  method = c("BoxCox", "center", "scale", "pca"), pcaComp = 4)
&gt; iris_pca_full &lt;- predict(pp_pca_full, iris_numeric)
&gt; pp_pca_var &lt;- apply(iris_pca_full, 2, var)
&gt; iris_pca_var &lt;- data.frame(Variance = round(100 * pp_pca_var / sum(pp_pca_var), 2), CumulativeVariance = round(100 * cumsum(pp_pca_var) / sum(pp_pca_var), 2))
&gt; iris_pca_var
    Variance CumulativeVariance
PC1    73.45              73.45
PC2    22.82              96.27
PC3     3.20              99.47
PC4     0.53             100.00</pre></div><div class="mediaobject"><img src="../images/00016.jpeg" alt="Feature engineering and dimensionality reduction" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">As we can see, the first principal component accounts for 73.45% of the total variance in the iris dataset, while together with the second component, the total variance captured is 96.27%. PCA is an unsupervised method for dimensionality reduction that does <a id="id117" class="calibre1"/>not make use of the output variable even when it is available. Instead, it looks at the data geometrically in the feature space. This means that we cannot ensure that PCA will give us a new feature space that will <a id="id118" class="calibre1"/>perform well in our prediction problem, beyond the computational advantages of having fewer features. These advantages might make PCA a viable choice even when there is reduction in model accuracy as <a id="id119" class="calibre1"/>long as this reduction is small and acceptable for the specific task. As a final note, we should point out that weights of the principal components, often referred to as <span class="strong"><strong class="calibre2">loadings,</strong></span> are unique within a sign flip as long as they have been normalized. In cases where we have perfectly correlated features or perfect linear combinations we will obtain a few principal components that are exactly zero.</p></div></div>

<div class="book" title="The process of predictive modeling">
<div class="book" title="Training and assessing the model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec19" class="calibre1"/>Training and assessing the model</h2></div></div></div><p class="calibre8">In our <a id="id120" class="calibre1"/>earlier discussion of parametric models, we saw that they come with a procedure to train the model using a set of training data. Nonparametric models will typically either perform lazy learning, in which case there <a id="id121" class="calibre1"/>really isn't an actual training procedure at all beyond memorizing the training data, or, as in the case of splines, will perform local <a id="id122" class="calibre1"/>computations on the training data.</p><p class="calibre8">Either way, if we are to assess the performance of our model, we need to split our data into a <span class="strong"><strong class="calibre2">training set</strong></span> and a <span class="strong"><strong class="calibre2">test set</strong></span>. The key idea is that we want to assess our model based on how we expect it to perform on unseen future data. We do this by using the test set, which <a id="id123" class="calibre1"/>is a portion (typically 15-30%) of the data we collected and set aside for this purpose and haven't used during training. For example, one possible divide is to have a training set with 80% of the observations in our original data, and a test set with the remaining 20%. The reason why we need a test set is that we cannot use the training set to fairly assess our model performance, since we fit our model to the training data and it does not represent data that we haven't seen before. From a prediction standpoint, if our goal was to maximize performance on our training data alone, then the best thing to do would be to simply memorize the input data along with the desired output values and our model would thus be a simple look-up table!</p><p class="calibre8">A good question to ask would be. How do we decide how much data to use for training and testing? There is a trade-off that is involved here that makes the answer to this question nontrivial. On the one hand, we would like to use as much data as possible in our training set, so that the model has more examples from which to learn. On the other hand, we would like to have a large test set so that we can test our trained model using many examples in order to minimize the variance of our estimate of the model's predictive performance. If we only have a handful of observations in our test set, then we cannot really generalize about how our model performs on unseen data overall.</p><p class="calibre8">Another factor that comes into play is how much starting data we have collected. If we have very little data, we may have to use a larger amount in order to train our model, such as an 85-15 split. If we have enough data, then we might consider a 70-30 split so that we can get a more accurate prediction on our test set.</p><p class="calibre8">To split <a id="id124" class="calibre1"/>a dataset using the <code class="email">caret</code> package, we can use the <code class="email">createDataPartition()</code> function to create a sampling vector containing the <a id="id125" class="calibre1"/>indices of the rows we will use in our training set. These are selected by randomly sampling the rows until a specified proportion of the rows have been sampled, using the <code class="email">p</code> parameter:</p><div class="informalexample"><pre class="programlisting">&gt; set.seed(2412)
&gt; iris_sampling_vector &lt;- createDataPartition(iris$Species, p = 0.8, list = FALSE)</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre8">It is good practice, when reporting the results of a statistical analysis involving a random number generation, to apply the <code class="email">set.seed()</code> function on a randomly chosen but fixed number. This function ensures that the random numbers that are generated from the next function call involving random number generation will be the same every time the code is run. This is done so that others who read the analysis are able to reproduce the results exactly. Note that if we have several functions in our code that perform random number generation, or the same function is called multiple times, we should ideally apply <code class="email">set.seed()</code> before each one of them.</p></div><p class="calibre8">Using our sampling vector, which we created for the iris dataset, we can construct our training and test sets. We'll do this for a few versions of the iris dataset that we built earlier when we experimented with different feature transformations:</p><div class="informalexample"><pre class="programlisting">&gt; iris_train     &lt;- iris_numeric[iris_sampling_vector,]
&gt; iris_train_z   &lt;- iris_numeric_zscore[iris_sampling_vector,]
&gt; iris_train_pca &lt;- iris_numeric_pca[iris_sampling_vector,]
&gt; iris_train_labels &lt;- iris$Species[iris_sampling_vector]
&gt;
&gt; iris_test        &lt;- iris_numeric[-iris_sampling_vector,]
&gt; iris_test_z      &lt;- iris_numeric_zscore[-iris_sampling_vector,]
&gt; iris_test_pca    &lt;- iris_numeric_pca[-iris_sampling_vector,]
&gt; iris_test_labels &lt;- iris$Species[-iris_sampling_vector]</pre></div><p class="calibre8">We are now in a position to build and test three different models for the iris dataset. These are in turn, the unnormalized model, a model where the input features have been centered and scaled with a Z-score transformation, and the PCA model with two principal components. We could use our test set in order to measure the predictive performance of each of these models after we build them; however, this would mean that, in our final estimate of unseen accuracy, we will have used the test set in the model selection, thus producing <a id="id126" class="calibre1"/>a biased estimate. For this reason, we often <a id="id127" class="calibre1"/>maintain a separate split of the data, usually as large as the test set, known as the <span class="strong"><strong class="calibre2">validation set</strong></span>. This is used to tune model <a id="id128" class="calibre1"/>parameters, such as <span class="strong"><em class="calibre9">k</em></span> in kNN, and among different encodings and transformations of the input features before using the test set to predict unseen performance. In <a class="calibre1" title="Chapter 5. Neural Networks" href="part0045_split_000.html#1AT9A1-c6198d576bbb4f42b630392bd61137d7">Chapter 5</a>, <span class="strong"><em class="calibre9">Support Vector Machines</em></span>, we'll discuss an alternative to this approach known as cross-validation.</p><p class="calibre8">Once we have split our data, trained our model by following the relevant training procedure that it requires, and tuned our model parameters, we then have to assess its performance on the test set. Typically, we won't find the same performance on our test set as on our training set. Sometimes, we may even find that the performance we see when we deploy our model does not match what we expected to see, based on the performance on our training or test sets. There are a number of possible reasons for this disparity in performance. The first of these is that the data we may have collected may either not be representative of the process that we are modeling, or that there are certain combinations of feature inputs that we simply did not encounter in our training data. This could produce results that are inconsistent with our expectations. This situation can happen both in the real world, but also with <a id="id129" class="calibre1"/>our test set if it contains outliers, for example. Another common situation is the problem of model <span class="strong"><strong class="calibre2">overfitting</strong></span>.</p><p class="calibre8">Overfitting is a problem in which some models, especially more flexible models, perform well on their training dataset, but perform significantly worse on an unseen test set. This occurs when a model matches the observations in the training data too closely and fails to generalize on unseen data. Put differently, the model is picking up on spurious details and variations in a training dataset, which are not representative of the underlying population as a whole. Overfitting is one of the key reasons why we do not choose our model based on its performance on the training data. Other sources of discrepancy between training and test <a id="id130" class="calibre1"/>data performance are model bias and variance. Together, these actually form a well-known trade-off in statistical modeling known as the <span class="strong"><strong class="calibre2">bias-variance tradeoff</strong></span>.</p><p class="calibre8">The variance of a statistical model refers to how much the model's predicted function would change, should a differently chosen training set (but generated from the exact same process or system that we are trying to predict as the original) be used to train the model. A low variance is desired because essentially, we don't want to predict a very different function with a different training set that is generated from the same process. Model bias refers to the errors inherently introduced in the predicted function, as a result of the limitation as to what functional forms the specific model can learn. For example, linear models introduce bias when trying to approximate nonlinear functions because they can only learn linear functions. The ideal scenario for a good predictive model is to have both a low variance and a low bias. It is important for a predictive modeler to be aware of the fact that there is a bias-variance trade-off that arises from the choice of models. Models that are typically more complex because of the fact that they make fewer assumptions on the target <a id="id131" class="calibre1"/>function are prone to less bias, but higher variance than simpler but more restrictive models, such as linear models. This is because <a id="id132" class="calibre1"/>more complex models are able to approximate the training data more closely due to their flexibility, but as a result, they are more sensitive to changes in training data. This, of course, is also related to the problem of overfitting that complex models often exhibit.</p><p class="calibre8">We can actually see the effects of overfitting by first training some kNN models on our iris datasets. There are a number of packages that offer an implementation of the kNN algorithm, but we will use the <code class="email">knn3()</code> function provided by the <code class="email">caret</code> package with which we are familiar. To train a model using this function, all we have to do is provide it with a data frame that contains the numerical input features, a vector of output labels, and <code class="email">k</code>, the number of nearest neighbors we want to use for the prediction:</p><div class="informalexample"><pre class="programlisting">&gt; knn_model     &lt;- knn3(iris_train, iris_train_labels, k = 5)
&gt; knn_model_z   &lt;- knn3(iris_train_z, iris_train_labels, k = 5)
&gt; knn_model_pca &lt;- knn3(iris_train_pca, iris_train_labels, k = 5)</pre></div><p class="calibre8">To see the effect of different values of <code class="email">k</code>, we will use the iris PCA model that is conveniently available in two dimensions for us to visualize and repeatedly train:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Training and assessing the model" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In the <a id="id133" class="calibre1"/>preceding plots, we have used different symbols <a id="id134" class="calibre1"/>to denote data points corresponding <a id="id135" class="calibre1"/>to different species. The lines shown in the plots correspond to the <span class="strong"><strong class="calibre2">decision boundaries</strong></span> between the different species, which are the class labels of our output variable. Notice that using a low value of <code class="email">k</code>, such as <code class="email">1</code>, captures local variations in the data very closely and, as a result, the decision boundaries are very irregular. A higher value of <code class="email">k</code> uses many neighbors to create a prediction, resulting in a smoothing effect and smoother decision boundaries. Tuning <code class="email">k</code> in kNN is an example of tuning a model parameter to balance the effect of overfitting.</p><p class="calibre8">We haven't mentioned any specific performance metrics in this section. There are different measures of model quality relevant to regression and classification, and we will address these after we wrap up our discussion on the predictive modeling process.</p></div></div>

<div class="book" title="The process of predictive modeling">
<div class="book" title="Repeating with different models and final model selection"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch01lvl2sec20" class="calibre1"/>Repeating with different models and final model selection</h2></div></div></div><p class="calibre8">During the <a id="id136" class="calibre1"/>first iteration of this process (and this is very much an iterative process!), we usually arrive at this stage, having trained <a id="id137" class="calibre1"/>and assessed a simple model. Simple models usually allow us to get to a quick and dirty solution with minimum effort, thus giving us an early sense of how far away we are from a model that will make predictions with reasonable accuracy. Simple models are also great at giving us a baseline level of performance against which we can benchmark the performance of future models. As modelers, we often acquire a preference toward one method over others, but it is important to remember that it is generally well worth the effort to try out different approaches to a problem and use the data to help us decide which one we should end up using.</p><p class="calibre8">Before picking the final model, it is worth considering whether it might be a good idea to use more than one model to solve our problem. In <a class="calibre1" title="Chapter 7. Tree-Based Methods" href="part0062_split_000.html#1R42S1-c6198d576bbb4f42b630392bd61137d7">Chapter 7</a>, <span class="strong"><em class="calibre9">Ensemble Methods</em></span>, we spend an entire chapter studying techniques that involve many models working together to boost the predictive accuracy of the overall system.</p></div></div>

<div class="book" title="The process of predictive modeling">
<div class="book" title="Deploying the model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch01lvl2sec21" class="calibre1"/>Deploying the model</h2></div></div></div><p class="calibre8">Once we <a id="id138" class="calibre1"/>have chosen the final model to use, we want to finalize its implementation so that the end users can use it reliably. Programmers <a id="id139" class="calibre1"/>refer to this process as <span class="strong"><strong class="calibre2">deploying to production</strong></span>. This is where sound software engineering principles become extremely important. The following guidelines offer some useful advice:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The model should be optimized to improve the speed at which it computes predictions. For example, this means ensuring that any features that are computed at runtime are done so efficiently.</li><li class="listitem">The model should be well documented. The final input features should be clearly defined, and the method and data used for training should be stored so that it can easily be retrained if changes need to be made. The original performance on the training and test set should also be stored as a reference for subsequent improvements.</li><li class="listitem">The model's performance should be monitored over time. This is important, not only as a means of verifying that the model works as intended, but also in order to catch any potential data shifts. If the process that is being modeled changes over time, it is likely that our model performance will degrade and this will signal the need for a new model to be trained.</li><li class="listitem">The software used to implement the model should be properly tested using standard unit and integration tests. Often, we will use a lot of existing R packages whose functions have already undergone testing, but the final deployment of a model may require us to write some additional code ourselves, such as for feature computation.</li><li class="listitem">The deployed <a id="id140" class="calibre1"/>model should be able to handle errors in the input. For example, if some of the input features are missing, it should be made very clear to the user why the model is unable to make a prediction through appropriate error messages. Errors and warnings should also be logged, especially if the model is deployed for continuous predictions in real-time settings.</li></ul></div></div></div>
<div class="book" title="Summary" id="H5A41-c6198d576bbb4f42b630392bd61137d7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we explored the fundamental ideas surrounding predictive models. We saw that there are many ways to categorize models, learning important distinctions in the process, such as supervised versus unsupervised learning and regression versus classification. Next, we outlined the steps involved in building a predictive model, starting from the process of data collection all the way to model evaluation and deployment. Critically, this process is an iterative one, and most often we arrive at our final model after having tried out and trained several different models.</p><p class="calibre8">We also introduced our first model, the k-nearest neighbor model, which is useful in performing classification and regression alike. kNN is a very flexible model that doesn't make any explicit assumptions about the underlying data. Thus, it can fit a very complex decision boundary. It is a lazy learner, in that it doesn't construct a model to describe the relationship between the input features and the output variable. Thus, it doesn't require a long period of training. On the other hand, for data with many dimensions, it may take a long time to produce a prediction, and because the model needs to remember all the training data in order to find the nearest neighbors of a target point, it often also requires a lot of memory. kNN doesn't distinguish between the importance of different features, and the fact that it uses a distance metric in its prediction means that, on the one hand, it does not have any built-in way to handle missing data and, on the other, it often requires features to be transformed to similar scales. Finally, the model can be tuned by choosing an appropriate value of <span class="strong"><em class="calibre9">k</em></span>, the number of nearest neighbors, to balance the degree of overfitting. With a firm grounding in the basics of the predictive modeling process, we will look at linear regression in the next chapter.</p></div></body></html>