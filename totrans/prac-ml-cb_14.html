<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Case Study - Forecast of Electricity Consumption"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Case Study - Forecast of Electricity Consumption</h1></div></div></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec58"/>Introduction</h1></div></div></div><p>Electricity is the only commodity that is produced and consumed simultaneously; therefore, a perfect balance between supply and consumption in the electricity power market must always be maintained. Forecasting electricity consumption is of national interest to any country since electricity is a key source of energy. A reliable forecast of energy consumption, production, and distribution meets the stable and long-term policy. The presence of economies of scale, focus on environmental concerns, regulatory requirements, and a favorable public image, coupled with inflation, rapidly rising energy prices, the emergence of alternative fuels and technologies, changes in life styles, and so on, has generated the need to use modeling techniques which capture the effect of factors such as prices, income, population, technology, and other economic, demographic, policy, and technological variables.</p><p>Underestimation could lead to under-capacity utilization, which would result in poor quality of service including localized brownouts, or even blackouts. While on the other hand, an overestimation could lead to the authorization of a plant that may not be needed for several years. The requirement is to ensure optimal phasing of investments, a long-term consideration, and rationalizing pricing structures and designing demand-side management programs, to meet the nature of short- or medium-term needs. The forecast further drives various plans and decisions on investment, construction, and conservation.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec72"/>Getting ready</h2></div></div></div><p>In order to carry out forecasting of electricity consumption, we shall be using a dataset collected on smart meter data with time series aggregated by four located industries.</p><div class="section" title="Step 1 - collecting and describing data"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec176"/>Step 1 - collecting and describing data</h3></div></div></div><p>The dataset titled <code class="literal">DT_4_ind</code> shall be used. The numeric variable is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">value</code></li></ul></div><p>The non-numeric variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">date_time</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">week</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code></li></ul></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec73"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring data"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec177"/>Step 2 - exploring data</h3></div></div></div><p>The following packages need to be loaded as a first step to be carried out:</p><pre class="programlisting">    
<span class="strong"><strong>&gt; install.packages("feather")</strong></span>
<span class="strong"><strong>&gt; install.packages("data.table")</strong></span>
<span class="strong"><strong>&gt; install.packages("ggplot2")</strong></span>
<span class="strong"><strong>&gt; install.packages("plotly")</strong></span>
<span class="strong"><strong>&gt; install.packages("animation")</strong></span>
<span class="strong"><strong>&gt; library(feather)</strong></span>
<span class="strong"><strong>&gt; library(data.table)</strong></span>
<span class="strong"><strong>&gt; library(ggplot2)</strong></span>
<span class="strong"><strong>&gt; library(plotly)</strong></span>
<span class="strong"><strong>&gt; library(animation)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Version info: Code for this page was tested in R version 3.2.2</p></div></div><p>Let's explore the data and understand the relationships between the variables.</p><p>Checking whether an object is <code class="literal">as.data.table()</code>: Binary columnar serialization for data frames is carried out using <code class="literal">feather</code>. In order to share, read, and write data across data analysis languages easily, <code class="literal">feather</code> is used. The <code class="literal">read_feather()</code> function is used to read feather files.</p><p>We'll begin by importing the <code class="literal">DT_4_ind</code> dataset. We will be saving the data to the <code class="literal">AggData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; AggData &lt;- as.data.table(read_feather("d:/DT_4_ind"))</strong></span>
</pre><p>Exploring the internal structure of the <code class="literal">AggData</code> data frame: The <code class="literal">str()</code> function displays the internal structure of the data frame. <code class="literal">AggData</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; str(AggData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_001.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Printing the <code class="literal">AggData</code> frame. The <code class="literal">head()</code> function returns the first part of the base data frame. The <code class="literal">AggData</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(AggData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_002.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Plotting the aggregated time series data of electricity consumption by industry.</p><p>The <code class="literal">ggplot()</code> function declares the input data frame for a graphic and specifies the set of plot aesthetics intended to be common throughout. <code class="literal">data = AggData</code> is the dataset to be used for plotting while <code class="literal">aes()</code> describes how variables in the data are mapped to visual properties. <code class="literal">geom_line()</code> produces the single line that tries to connect all the observations:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; ggplot(data = AggData, aes(x = date, y = value)) +</strong></span>
<span class="strong"><strong>    + geom_line() + </strong></span>
<span class="strong"><strong>    + facet_grid(type ~ ., scales = "free_y") +</strong></span>
<span class="strong"><strong>    + theme(panel.border = element_blank(),</strong></span>
<span class="strong"><strong>    + panel.background = element_blank(),</strong></span>
<span class="strong"><strong>    + panel.grid.minor = element_line(colour = "grey90"),</strong></span>
<span class="strong"><strong>    + panel.grid.major = element_line(colour = "green"),</strong></span>
<span class="strong"><strong>    + panel.grid.major.x = element_line(colour = "red"),</strong></span>
<span class="strong"><strong>    + axis.text = element_text(size = 10),</strong></span>
<span class="strong"><strong>    + axis.title = element_text(size = 12, face = "bold"),</strong></span>
<span class="strong"><strong>    + strip.text = element_text(size = 9, face = "bold")) +</strong></span>
<span class="strong"><strong>    + labs(title = "Electricity Consumption - Industry", x = "Date", y = "Load (kW)")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_003.jpg" alt="Step 2 - exploring data"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>It is important to note that the consumption of the industry Food Sales &amp; Storage does not change much during holidays compared to others.</p></div></div></div><div class="section" title="Step 3 - time series - regression analysis"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec178"/>Step 3 - time series - regression analysis</h3></div></div></div><p>
The regression model is formulated as follows:
</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_004.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>
Variables (inputs) are of two types of seasonal dummy variables--daily
<span class="inlinemediaobject"><img src="graphics/image_14_005.jpg" alt="Step 3 - time series - regression analysis"/></span> and weekly 
<span class="inlinemediaobject"><img src="graphics/image_14_006.jpg" alt="Step 3 - time series - regression analysis"/></span>
. 
<span class="inlinemediaobject"><img src="graphics/image_14_007.jpg" alt="Step 3 - time series - regression analysis"/></span> is the electricity consumption at the time 
<span class="emphasis"><em>i</em></span>
, where 
<span class="inlinemediaobject"><img src="graphics/image_14_008.jpg" alt="Step 3 - time series - regression analysis"/></span> are the regression coefficients to be estimated.
</p><p>Printing the contents of the <code class="literal">AggData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; AggData</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_009.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Transforming the characters of weekdays to integers: The <code class="literal">as.factor()</code> function is used to encode a vector as a factor. The <code class="literal">as.integer()</code> function creates the <code class="literal">AggData[, week]</code> object of the integer type:</p><pre class="programlisting">
<span class="strong"><strong>&gt; AggData[, week_num := as.integer(as.factor(AggData[, week]))]</strong></span>
</pre><p>Printing the contents of the <code class="literal">AggData</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>&gt; AggData</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_010.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Extracting unique industry types from the <code class="literal">AggData</code> data frame using the following:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; n_type &lt;- unique(AggData[, type])
</strong></span>
</pre><p>Printing the contents of the data frame <code class="literal">n_type</code> after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; n_type
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_011.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Extracting unique dates from the <code class="literal">AggData</code> data frame using the following:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; n_date &lt;- unique(AggData[, date])
</strong></span>
</pre><p>Extracting unique weekdays from the <code class="literal">AggData</code> data frame using the following:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; n_weekdays &lt;- unique(AggData[, week])
</strong></span>
</pre><p>Setting the <code class="literal">period</code> value using the following:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; period &lt;- 48
</strong></span>
</pre><p>
Performing regression analysis on a sample dataset.
</p><p>We extract education (schools) buildings over a period of 2 weeks. The result is stored in the <code class="literal">data_reg</code> data frame. 
<code class="literal">n_type[2]</code>represents education buildings and <code class="literal">n_date[57:70]</code>denotes a 2-week period:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; data_reg &lt;- AggData[(type == n_type[2] &amp; date %in% n_date[57:70])]
</strong></span>
</pre><p>Printing the contents of the <code class="literal">data_reg</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; data_reg
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_012.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Plotting the sample dataset of education (school buildings) over a period of 2 weeks (February 27 to March 12)</p><p>The <code class="literal">ggplot()</code> function declares the input data frame for a graphic and specifies the set of plot aesthetics intended to be common throughout. <code class="literal">data_reg</code> is the dataset to be used for plotting while <code class="literal">aes()</code> describes how variables in the data are mapped to visual properties. <code class="literal">geom_line()</code> produces the single line that tries to connect all the observations:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; ggplot(data_reg, aes(date_time, value)) +</strong></span>
<span class="strong"><strong>    + geom_line() +</strong></span>
<span class="strong"><strong>    + theme(panel.border = element_blank(),</strong></span>
<span class="strong"><strong>    + panel.background = element_blank(),</strong></span>
<span class="strong"><strong>    + panel.grid.minor = element_line(colour = "grey90"),</strong></span>
<span class="strong"><strong>    + panel.grid.major = element_line(colour = "green"),</strong></span>
<span class="strong"><strong>    + panel.grid.major.x = element_line(colour = "red"),</strong></span>
<span class="strong"><strong>    + axis.text = element_text(size = 10),</strong></span>
<span class="strong"><strong>    + axis.title = element_text(size = 12, face = "bold")) </strong></span>
<span class="strong"><strong>    + labs(title = "Regression Analysis - Education Buildings", x = "Date", y = "Load (kW)")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_013.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Extracting the number of rows from the <code class="literal">data_reg</code> data frame:
</p><pre class="programlisting">
<span class="strong"><strong>
&gt; N &lt;- nrow(data_reg)
</strong></span>
</pre><p>
Calculating the number of days in the training set:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; trainset_window &lt;- N / period
</strong></span>
</pre><p>
Creating independent seasonal dummy variables--daily 
<span class="inlinemediaobject"><img src="graphics/image_14_014.jpg" alt="Step 3 - time series - regression analysis"/></span> and weekly 
<span class="inlinemediaobject"><img src="graphics/image_14_015.jpg" alt="Step 3 - time series - regression analysis"/></span>
. The daily seasonal value is extracted from 
<span class="emphasis"><em>1,.....period, 1,.......period</em></span>
 for 48 vectors of daily variables. The weekly value is extracted from 
<code class="literal">week_num</code>
. The result is then stored in one vector, 
<code class="literal">matrix_train</code>
:
</p><pre class="programlisting">
<span class="strong"><strong>
&gt; matrix_train &lt;- data.table(Load = data_reg[, value], Daily = as.factor(rep(1:period, trainset_window)), Weekly = as.factor(data_reg[, week_num]))
</strong></span>
</pre><p>Printing the contents of the <code class="literal">matrix_train</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; matrix_train
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_016.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Creating a linear model. The <code class="literal">lm()</code> function fits the linear models: <code class="literal">Load ~ 0 + .</code> is the formula. Since <code class="literal">lm()</code> automatically adds to the linear model intercept, we define it now as <code class="literal">0</code>. <code class="literal">data = matrix_train</code> defines the data frame which contains the data:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; linear_model_1 &lt;- lm(Load ~ 0 + ., data = matrix_train)
</strong></span>
</pre><p>Printing the contents of the <code class="literal">linear_model_1</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; linear_model_1
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_017.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Producing result summaries of the model <code class="literal">linear_model_1</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary_1 &lt;- summary(linear_model_1)</strong></span>
</pre><p>Printing the contents of the <code class="literal">summary_1</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; summary_1
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_018.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_019.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Extracting the coefficient of determination using the <code class="literal">r.squared</code> attribute from the <code class="literal">summary_1</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; paste("R-squared: ", round(summary_1$r.squared, 3), ", p-value of F test: ", 1-pf(summary_1$fstatistic[1], summary_1$fstatistic[2], summary_1$fstatistic[3]))</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_14_020.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Creating one <code class="literal">data.table</code> from a list of <code class="literal">data_reg</code> and <code class="literal">linear_model_1</code>
:
</p><pre class="programlisting">
<span class="strong"><strong>
&gt; datas &lt;- rbindlist(list(data_reg[, .(value, date_time)], data.table(value = linear_model_1$fitted.values, data_time = data_reg[, date_time])))
</strong></span>
</pre><p>Printing the contents of the <code class="literal">datas</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; datas
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_021.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>Plotting fitted values for <code class="literal">linear_model_1</code>
.
</p><p>
<code class="literal">data = datas</code> is the dataset to be used for plotting while <code class="literal">aes()</code> describes how variables in the data are mapped to visual properties. <code class="literal">geom_line()</code> produces the single line that tries to connect all the observations:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; ggplot(data = datas, aes(date_time, value, group = type, colour = type)) + geom_line(size = 0.8) + theme_bw() +
</strong></span>
<span class="strong"><strong>
+ labs(x = "Time", y = "Load (kW)", title = "Fit from Multiple Linear Regression")
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_022.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>
Plotting fitted values versus residual values.</p><p>
<code class="literal">data</code> is the dataset to be used for plotting while <code class="literal">aes()</code> describes how variables in the data are mapped to visual properties:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ggplot(data = data.table(Fitted_values =
linear_model_2$fitted.values, Residuals = linear_model_2$residuals),
aes(Fitted_values, Residuals)) + geom_point(size = 1.7)
+ geom_hline(yintercept = 0, color = "red", size = 1) +
+ labs(title = "Fitted values vs Residuals")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_023.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>
The function first gives the standardized residual from the linear model. It then calculates the 
<code class="literal">1Q</code>
 and 
<code class="literal">4Q</code> lines. Then, the quantile distribution is generated from the normal distribution. The slope and intercept is then calculated which is then plotted:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; ggQQ &lt;- function(lm) {</strong></span>
<span class="strong"><strong>    # extracting residuals from the fit</strong></span>
<span class="strong"><strong>    + d &lt;- data.frame(std.resid = rstandard(lm))</strong></span>
<span class="strong"><strong>    # calculate 1Q, 4Q line</strong></span>
<span class="strong"><strong>    + y &lt;- quantile(d$std.resid[!is.na(d$std.resid)], c(0.25, 0.75))</strong></span>
<span class="strong"><strong>    # calculate 1Q, 4Q line</strong></span>
<span class="strong"><strong>    + x &lt;- qnorm(c(0.25, 0.75))</strong></span>
<span class="strong"><strong>    + slope &lt;- diff(y)/diff(x)</strong></span>
<span class="strong"><strong>    + int &lt;- y[1L] - slope * x[1L]</strong></span>
<span class="strong"><strong>    + </strong></span>
<span class="strong"><strong>    + p &lt;- ggplot(data = d, aes(sample = std.resid)) +</strong></span>
<span class="strong"><strong>    + stat_qq(shape = 1, size = 3) + </strong></span>
<span class="strong"><strong>    + labs(title = "Normal Q-Q", </strong></span>
<span class="strong"><strong>    + x = "Theoretical Quantiles", </strong></span>
<span class="strong"><strong>    + y = "Standardized Residuals") + </strong></span>
<span class="strong"><strong>    + geom_abline(slope = slope, intercept = int, linetype = "dashed",</strong></span>
<span class="strong"><strong>    + size = 1, col = "firebrick1") </strong></span>
<span class="strong"><strong>    + return(p)</strong></span>
<span class="strong"><strong>    + }</strong></span>
</pre><p>
We can plot Q-Q with the following command:
</p><pre class="programlisting">
<span class="strong"><strong>
&gt; ggQQ(linear_model_1)
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_024.jpg" alt="Step 3 - time series - regression analysis"/></div><p>
</p><p>As is clearly visible, the points are not normal as they are away from the red line. The measurements during the day were moved constantly by the estimated coefficient of the week variable, but the behavior during the day wasn't captured. We need to capture this behavior because weekends, especially, behave absolutely differently.</p></div><div class="section" title="Step 4 - time series - improving regression analysis"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec179"/>Step 4 - time series - improving regression analysis</h3></div></div></div><p>Creating a linear model: The <code class="literal">lm()</code> function fits the linear models. <code class="literal">Load ~ 0 + Daily + Weekly + Daily:Weekly</code> is the new formula. Since <code class="literal">lm()</code> automatically adds to the linear model intercept, we define it now as <code class="literal">0</code>. <code class="literal">data = matrix_train</code> defines the data frame which contains the data:</p><pre class="programlisting">
<span class="strong"><strong>&gt; linear_model_2 &lt;- lm(Load ~ 0 + Daily + Weekly + Daily:Weekly, data = matrix_train)</strong></span>
</pre><p>Printing the contents of the <code class="literal">linear_model_2</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; linear_model_2
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_025.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>Comparing R-squared values from the summaries of the <code class="literal">linear_model_1</code> and <code class="literal">linear_model_2</code> models:</p><pre class="programlisting">
<span class="strong"><strong>&gt; c(Previous = summary(linear_model_1)$r.squared, New = summary(linear_model_2)$r.squared)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_026.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>There is a significant improvement in the R-squared value of the second model.</p><p>Comparing the residuals of the <code class="literal">linear_model_1</code> and <code class="literal">linear_model_2</code> models graphically:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; ggplot(data.table(Residuals = c(linear_model_1$residuals, linear_model_2$residuals), Type = c(rep("Multiple Linear Reg - simple", nrow(data_reg)), rep("Multiple Linear Reg with interactions", nrow(data_reg)))), aes(Type, Residuals, fill = Type)) + geom_boxplot()</strong></span>
<span class="strong"><strong>    &gt; ggplotly()</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_027.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>Details of residuals of <code class="literal">linear_model_1</code>.</p><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_028.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>Details of residuals of <code class="literal">linear_model_2</code>.</p><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_029.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>Creating one <code class="literal">data.table</code> from a list of <code class="literal">data_reg</code> and <code class="literal">linear_model_2</code>
:
</p><pre class="programlisting">
<span class="strong"><strong>
&gt; datas &lt;- rbindlist(list(data_reg[, .(value, date_time)], data.table(value = linear_model_2$fitted.values, data_time = data_reg[, date_time])))
</strong></span>
</pre><p>Printing the contents of the <code class="literal">datas</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; datas
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_030.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>
Adding 
<code class="literal">Real</code>
 and 
<code class="literal">Fitted</code>
 columns to 
<code class="literal">datas</code>:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; datas[, type := rep(c("Real", "Fitted"), each = nrow(data_reg))]
</strong></span>
</pre><p>Printing the contents of the <code class="literal">datas</code> data frame after the change:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; datas
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_031.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>Plotting fitted values for <code class="literal">linear_model_2</code>
.
</p><p>
<code class="literal">data = datas</code> is the dataset to be used for plotting while <code class="literal">aes()</code> describes how variables in the data are mapped to visual properties. <code class="literal">geom_line()</code> produces the single line that tries to connect all the observations:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; ggplot(data = datas, aes(date_time, value, group = type, colour =
type)) + geom_line(size = 0.8) + theme_bw() +
+ labs(x = "Time", y = "Load (kW)", title = "Fit from Multiple Linear
Regression")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_032.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>The fitted and real values closely match compared to the earlier plot of <code class="literal">linear_model_1</code>.</p><p>
Plotting fitted values versus residual values. <code class="literal">Data</code> is the dataset to be used for plotting while <code class="literal">aes()</code> describes how variables in the data are mapped to visual properties:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; ggplot(data = data.table(Fitted_values = linear_model_2$fitted.values, Residuals = linear_model_2$residuals), aes(Fitted_values, Residuals)) + geom_point(size = 1.7) 
</strong></span>
<span class="strong"><strong>
+ geom_hline(yintercept = 0, color = "red", size = 1) +
</strong></span>
<span class="strong"><strong>
+ labs(title = "Fitted values vs Residuals")
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_033.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p><p>The plots appear to be closer to the residual line compared to the earlier plot of <code class="literal">linear_model_1</code>.</p><p>We can plot Plotting Q-Q using the following:</p><pre class="programlisting">
<span class="strong"><strong>
&gt; ggQQ(linear_model_2)
</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_034.jpg" alt="Step 4 - time series - improving regression analysis"/></div><p>
</p></div><div class="section" title="Step 5 - building a forecasting model"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec180"/>Step 5 - building a forecasting model</h3></div></div></div><p>We can define a function to return the forecast for a 1 week ahead prediction. The input parameters are <code class="literal">data</code> and <code class="literal">set_of_date</code>:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; predWeekReg &lt;- function(data, set_of_date){</strong></span>
<span class="strong"><strong>    + #creating the dataset by dates</strong></span>
<span class="strong"><strong>    + data_train &lt;- data[date %in% set_of_date] </strong></span>
<span class="strong"><strong>    + N &lt;- nrow(data_train)</strong></span>
<span class="strong"><strong>    +</strong></span>
<span class="strong"><strong>    + # number of days in the train set</strong></span>
<span class="strong"><strong>    + window &lt;- N / period # number of days in the train set</strong></span>
<span class="strong"><strong>    +</strong></span>
<span class="strong"><strong>    + #1, ..., period, 1, ..., period - daily season periods</strong></span>
<span class="strong"><strong>    + #feature "week_num"- weekly season</strong></span>
<span class="strong"><strong>    + matrix_train &lt;- data.table(Load = data_train[, value],</strong></span>
<span class="strong"><strong>    + Daily = as.factor(rep(1:period, window)),</strong></span>
<span class="strong"><strong>    + Weekly = as.factor(data_train[, week_num]))</strong></span>
<span class="strong"><strong>    +</strong></span>
<span class="strong"><strong>    + #creating linear model.</strong></span>
<span class="strong"><strong>    + # formula - Load ~ 0 + Daily + Weekly + Daily:Weekly</strong></span>
<span class="strong"><strong>    + # dataset - data = matrix_train</strong></span>
<span class="strong"><strong>    + lm_m &lt;- lm(Load ~ 0 + Daily + Weekly + Daily:Weekly, data = matrix_train)</strong></span>
<span class="strong"><strong>    + </strong></span>
<span class="strong"><strong>    + #forecast of one week ahead</strong></span>
<span class="strong"><strong>    + pred_week &lt;- predict(lm_m, matrix_train[1:(7*period), -1, with = FALSE])</strong></span>
<span class="strong"><strong>    + return(as.vector(pred_week))</strong></span>
<span class="strong"><strong>    + }</strong></span>
</pre><p>Defining the mean absolute percentage error for evaluating the forecast:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; mape &lt;- function(real, pred){</strong></span>
<span class="strong"><strong>    + return(100 * mean(abs((real - pred)/real)))</strong></span>
<span class="strong"><strong>    + }</strong></span>
</pre><p>Setting the training set of the length for 2 weeks, therefore deducting 2. A forecast for 50 weeks will be produced. Using a sliding window approach for training forecasting is done for every type of industry:</p><pre class="programlisting">
<span class="strong"><strong>&gt; n_weeks &lt;- floor(length(n_date)/7) - 2</strong></span>
</pre><p>Printing the number of weeks:</p><pre class="programlisting">
<span class="strong"><strong>&gt; n_weeks</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_035.jpg" alt="Step 5 - building a forecasting model"/></div><p>
</p><p>Calculating the forecast for each type of industry for 1 week ahead.</p><p>Calling the function to return the forecast for a 1 week ahead prediction for the <code class="literal">AggData</code> commercial property and dataset:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lm_pred_weeks_1 &lt;- sapply(0:(n_weeks-1), function(i)</strong></span>
<span class="strong"><strong>    + predWeekReg(AggData[type == n_type[1]], n_date[((i*7)+1):((i*7)+7*2)]))</strong></span>
</pre><p>Calling the function to return the forecast for a 1 week ahead prediction for the <code class="literal">AggData</code> - education and date set:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lm_pred_weeks_2 &lt;- sapply(0:(n_weeks-1), function(i)</strong></span>
<span class="strong"><strong>    + predWeekReg(AggData[type == n_type[2]], n_date[((i*7)+1):((i*7)+7*2)]))</strong></span>
</pre><p>Calling the function to return the forecast for a 1 week ahead prediction for the <code class="literal">AggData</code> food and sales and date set:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lm_pred_weeks_3 &lt;- sapply(0:(n_weeks-1), function(i)</strong></span>
<span class="strong"><strong>    + predWeekReg(AggData[type == n_type[3]], n_date[((i*7)+1):((i*7)+7*2)]))</strong></span>
</pre><p>Calling the function to return the forecast for a 1 week ahead prediction for the <code class="literal">AggData</code> lighting industry and date set:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lm_pred_weeks_4 &lt;- sapply(0:(n_weeks-1), function(i)</strong></span>
<span class="strong"><strong>    + predWeekReg(AggData[type == n_type[4]], n_date[((i*7)+1):((i*7)+7*2)]))</strong></span>
</pre><p>Calculate the mean absolute percentage error for each type of industry for evaluating the forecasts. Call the function to return the mean absolute percentage. Calculate the error for evaluating the forecast for the <code class="literal">AggData</code> lighting industry and date set:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lm_err_mape_1 &lt;- sapply(0:(n_weeks-1), function(i)</strong></span>
<span class="strong"><strong>    + mape(AggData[(type == n_type[1] &amp; date %in% n_date[(15+(i*7)):(21+(i*7))]), value],</strong></span>
<span class="strong"><strong>    + lm_pred_weeks_1[, i+1]))</strong></span>
</pre><p>Printing the <code class="literal">lm_err_mape_1</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; lm_err_mape_1</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_036.jpg" alt="Step 5 - building a forecasting model"/></div><p>
</p><p>Calling the function to return the mean absolute percentage error for evaluating the forecast for the <code class="literal">AggData</code> education and date set:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lm_err_mape_2 &lt;- sapply(0:(n_weeks-1), function(i)</strong></span>
<span class="strong"><strong>    + mape(AggData[(type == n_type[2] &amp; date %in% n_date[(15+(i*7)):(21+(i*7))]), value],</strong></span>
<span class="strong"><strong>    + lm_pred_weeks_2[, i+1]))</strong></span>
</pre><p>Printing <code class="literal">lm_err_mape_2</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; lm_err_mape_2</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_037.jpg" alt="Step 5 - building a forecasting model"/></div><p>
</p><p>Calling the function to return the mean absolute percentage error for evaluating the forecast for the <code class="literal">AggData</code> food and sales and date set:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lm_err_mape_3 &lt;- sapply(0:(n_weeks-1), function(i)</strong></span>
<span class="strong"><strong>    + mape(AggData[(type == n_type[3] &amp; date %in% n_date[(15+(i*7)):(21+(i*7))]), value],</strong></span>
<span class="strong"><strong>    + lm_pred_weeks_3[, i+1]))</strong></span>
</pre><p>Printing the <code class="literal">lm_err_mape_3</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; lm_err_mape_3</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_038.jpg" alt="Step 5 - building a forecasting model"/></div><p>
</p><p>Calling the function to return the mean absolute percentage error for evaluating the forecast for the <code class="literal">AggData</code> lighting industry and date set:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; lm_err_mape_4 &lt;- sapply(0:(n_weeks-1), function(i)</strong></span>
<span class="strong"><strong>    + mape(AggData[(type == n_type[4] &amp; date %in% n_date[(15+(i*7)):(21+(i*7))]), value],</strong></span>
<span class="strong"><strong>    + lm_pred_weeks_4[, i+1]))</strong></span>
</pre><p>Printing the <code class="literal">lm_err_mape_4data</code> frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; lm_err_mape_4</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_039.jpg" alt="Step 5 - building a forecasting model"/></div><p>
</p></div><div class="section" title="Step 6 - plotting the forecast for a year"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec181"/>Step 6 - plotting the forecast for a year</h3></div></div></div><p>Plotting the results:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>You need to have ImageMagick-7.0.4-Q16 installed for <code class="literal">saveGIF</code> to work.</p></div></div><pre class="programlisting">
<span class="strong"><strong>    &gt; datas &lt;- data.table(value = c(as.vector(lm_pred_weeks_1),</strong></span>
<span class="strong"><strong>    AggData[(type == n_type[1]) &amp; (date %in% n_date[-c(1:14,365)]), value]),</strong></span>
<span class="strong"><strong>    date_time = c(rep(AggData[-c(1:(14*48), (17473:nrow(AggData))), date_time], 2)),</strong></span>
<span class="strong"><strong>    type = c(rep("MLR", nrow(lm_pred_weeks_1)*ncol(lm_pred_weeks_1)),</strong></span>
<span class="strong"><strong>    rep("Real", nrow(lm_pred_weeks_1)*ncol(lm_pred_weeks_1))),</strong></span>
<span class="strong"><strong>    week = c(rep(1:50, each = 336), rep(1:50, each = 336)))</strong></span>


<span class="strong"><strong>    &gt; saveGIF({</strong></span>
<span class="strong"><strong>    oopt = ani.options(interval = 0.9, nmax = 50)</strong></span>
<span class="strong"><strong>    for(i in 1:ani.options("nmax")){</strong></span>
<span class="strong"><strong>    print(ggplot(data = datas[week == i], aes(date_time, value, group = type, colour = type)) +</strong></span>
<span class="strong"><strong>    geom_line(size = 0.8) +</strong></span>
<span class="strong"><strong>    scale_y_continuous(limits = c(min(datas[, value]), max(datas[, value]))) + </strong></span>
<span class="strong"><strong>    theme(panel.border = element_blank(), panel.background = element_blank(),</strong></span>
<span class="strong"><strong>    panel.grid.minor = element_line(colour = "grey90"),</strong></span>
<span class="strong"><strong>    panel.grid.major = element_line(colour = "grey90"),</strong></span>
<span class="strong"><strong>    panel.grid.major.x = element_line(colour = "grey90"),</strong></span>
<span class="strong"><strong>    title = element_text(size = 15),</strong></span>
<span class="strong"><strong>    axis.text = element_text(size = 10),</strong></span>
<span class="strong"><strong>    axis.title = element_text(size = 12, face = "bold")) +</strong></span>
<span class="strong"><strong>    labs(x = "Time", y = "Load (kW)",</strong></span>
<span class="strong"><strong>    title = paste("Forecast of MLR (", n_type[1], "); ", "week: ", i, "; MAPE: ",</strong></span>
<span class="strong"><strong>    round(lm_err_mape_1[i], 2), "%", sep = "")))</strong></span>
<span class="strong"><strong>    ani.pause()</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    }, movie.name = "industry_1.gif", ani.height = 450, ani.width = 750)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_040.jpg" alt="Step 6 - plotting the forecast for a year"/></div><p>
</p><p>
<span class="strong"><strong>
</strong></span>
</p><div class="mediaobject"><img src="graphics/image_14_041.jpg" alt="Step 6 - plotting the forecast for a year"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_042.jpg" alt="Step 6 - plotting the forecast for a year"/></div><p>
</p><p>
<span class="strong"><strong>
</strong></span>
</p><div class="mediaobject"><img src="graphics/image_14_043.jpg" alt="Step 6 - plotting the forecast for a year"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_044.jpg" alt="Step 6 - plotting the forecast for a year"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_045.jpg" alt="Step 6 - plotting the forecast for a year"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_046.jpg" alt="Step 6 - plotting the forecast for a year"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_14_047.jpg" alt="Step 6 - plotting the forecast for a year"/></div><p>
</p><p>The preceding results prove that the consumption of the electricity pattern is based on external factors such as holidays, weather, nature of property, and so on. The consumption pattern is very stochastic in nature.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>The aim is to introduce to the reader the application of multiple linear regressions for forecasting double seasonal time series. It is very effective to include interactions of independent variables to ensure the effectiveness of the model.</p></div></div></div></div></div></div></body></html>