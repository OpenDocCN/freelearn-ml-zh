["```py\n#include opencv2/opencv.hpp; \n#include vector; \n\nusing namespace std; \nusing namespace cv; \n\nMat binarize(Mat input)  \n{   \n   //Uses otsu to threshold the input image \n   Mat binaryImage; \n   cvtColor(input, input, COLOR_BGR2GRAY); \n   threshold(input, binaryImage, 0, 255, THRESH_OTSU); \n\n   //Count the number of black and white pixels \n   int white = countNonZero(binaryImage); \n   int black = binaryImage.size().area() - white; \n\n   //If the image is mostly white (white background), invert it \n   return white black ? binaryImage : ~binaryImage; \n}\n```", "```py\nauto kernel = getStructuringElement(MORPH_CROSS, Size(3,3)); \nMat dilated; \ndilate(input, dilated, kernel, cv::Point(-1, -1), 5); \nimshow(\"Dilated\", dilated); \n```", "```py\nvector;vector;Point;contours; \nfindContours(dilated, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);  \n```", "```py\n//For each contour \n\nvector;RotatedRect; areas; \nfor (const auto& contour : contours)  \n{   \n   //Find it's rotated rect \n   auto box = minAreaRect(contour); \n\n   //Discard very small boxes \n   if (box.size.width 20 || box.size.height 20) \n         continue; \n\n   //Discard squares shaped boxes and boxes  \n   //higher than larger \n   double proportion = box.angle -45.0 ? \n         box.size.height / box.size.width :  \n         box.size.width / box.size.height; \n\n   if (proportion 2)  \n         continue; \n\n   //Add the box \n   areas.push_back(box); \n}\n```", "```py\nvector RotatedRect; findTextAreas(Mat input)\n```", "```py\nMat deskewAndCrop(Mat input, const RotatedRect& box) \n{ \n   double angle = box.angle;      \n   auto size = box.size; \n\n   //Adjust the box angle \n   if (angle -45.0)  \n   { \n        angle += 90.0;\n         std::swap(size.width, size.height);         \n   } \n\n   //Rotate the text according to the angle \n   auto transform = getRotationMatrix2D(box.center, angle, 1.0); \n   Mat rotated; \n   warpAffine(input, rotated, transform, input.size(), INTER_CUBIC); \n\n   //Crop the result \n   Mat cropped; \n   getRectSubPix(rotated, size, box.center, cropped); \n   copyMakeBorder(cropped,cropped,10,10,10,10,BORDER_CONSTANT,Scalar(0)); \n   return cropped; \n}\n```", "```py\nint main(int argc, char* argv[])  \n{ \n   //Loads the ticket image and binarize it \n   auto ticket = binarize(imread(\"ticket.png\"));     \n   auto regions = findTextAreas(ticket); \n\n   //For each region \n   for (const auto& region : regions) { \n         //Crop  \n         auto cropped = deskewAndCrop(ticket, region); \n\n         //Show \n         imshow(\"Cropped text\", cropped); \n         waitKey(0);  \n         destroyWindow(\"Border Skew\"); \n   } \n} \n```", "```py\nvcpkg install tesseract:x86-windows-static\n```", "```py\nvckpg install tesseract:x64-windows-static\n```", "```py\nbrew install tesseract\n```", "```py\nbrew install tesseract --all-languages \n```", "```py\n#include opencv2/opencv.hpp; \n#include tesseract/baseapi.h; \n\n#include vector; \n#include fstream; \n```", "```py\ntesseract::TessBaseAPI ocr; \n```", "```py\nconst char* identifyText(Mat input, const char* language = \"eng\")  \n{   \n   ocr.Init(NULL, language, tesseract::OEM_TESSERACT_ONLY);     \n   ocr.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK); \n   ocr.SetImage(input.data, input.cols, input.rows, 1, input.step); \n\n   const char* text = ocr.GetUTF8Text(); \n   cout  \"Text:\"  endl; \n   cout  text  endl; \n   cout  \"Confidence: \"  ocr.MeanTextConf() endl; \n\n    // Get the text     \n   return text; \n} \n```", "```py\nint Init(const char* datapath, const char* language, \n OcrEngineMode oem)\n```", "```py\nocr.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK); \n```", "```py\nvoid SetImage(const unsigned char* imagedata, int width, \n int height, int bytes_per_pixel, int bytes_per_line);\n```", "```py\n   auto text = ocr.GetUTF8Text(); \n   cout  \"Text:\"  endl; \n   cout  text  endl; \n   cout  \"Confidence: \"  ocr.MeanTextConf()  endl; \n```", "```py\nint main(int argc, char* argv[])  \n{ \n   //Loads the ticket image and binarize it \n   Mat ticket = binarize(imread(\"ticket.png\"));     \n   auto regions = findTextAreas(ticket); \n\n   std::ofstream file;  \n   file.open(\"ticket.txt\", std::ios::out | std::ios::binary); \n\n   //For each region \n   for (const auto& region : regions) { \n         //Crop  \n         auto cropped = deskewAndCrop(ticket, region); \n         auto text = identifyText(cropped, \"por\"); \n\n         file.write(text, strlen(text)); \n         file endl; \n   } \n\n   file.close(); \n} \n```", "```py\nfile.open(\"ticket.txt\", std::ios::out | std::ios::binary); \n```", "```py\nfile.write(text, strlen(text)); \n```"]