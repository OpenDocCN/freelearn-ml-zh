- en: '2'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: AI with Search Techniques and Games
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于搜索技术和游戏的 AI
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Build a simple game AI with Python based on static rules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 基于静态规则构建简单的游戏 AI
- en: Determine the role of heuristics in Game AI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定启发式在游戏 AI 中的作用
- en: Employ search techniques and pathfinding algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用搜索技术和路径查找算法
- en: Implement game AI for two-player games with the Minmax algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现使用 Minmax 算法的两人游戏 AI
- en: In this chapter, we will be looking at creating intelligent agents.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨创建智能体。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we understood the significance of an intelligent agent.
    We also examined the game states for a game AI. In this chapter, we will focus
    on how to create and introduce intelligence into an agent.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了智能体的意义。我们还检查了游戏 AI 的游戏状态。在本章中，我们将专注于如何创建并引入智能体中的智能。
- en: We will look at reducing the number of states in the state space and analyze
    the stages that a game board can undergo and make the environment work in such
    a way that we win. By the end of this chapter, we will have a Tic-Tac-Toe player
    who never loses a match.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究减少状态空间中的状态数量，分析游戏棋盘可能经历的阶段，并使环境以我们获胜的方式工作。到本章结束时，我们将拥有一个永远不会输掉比赛的井字棋玩家。
- en: 'Exercise 4: Teaching the Agent to Win'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：教会智能体获胜
- en: In this exercise, we will see how the steps needed to win can be reduced. We
    will be making the agent that we developed in the previous chapter detect situations
    where it can win a game. Compare the number of possible states to the random play
    as an example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何减少赢得所需的步骤。我们将使我们在上一章中开发的智能体检测它能够赢得游戏的情况。以随机游戏为例，比较可能的状态数量。
- en: We will be defining two functions, `ai_move` and `all_moves_from_board` . We
    will create `ai_move` so that it returns a move that will consider its own previous
    moves. If the game can be won in that move, `ai_move` will select that move.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义两个函数，`ai_move` 和 `all_moves_from_board`。我们将创建 `ai_move`，使其返回一个考虑其先前移动的移动。如果在该移动中可以赢得游戏，`ai_move`
    将选择该移动。
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s test the application with a game loop. Whenever the AI has the opportunity
    to win the game, it will always place the X in the right cell:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过游戏循环测试应用程序。每当 AI 有机会赢得游戏时，它总是会将 X 放在正确的单元格中：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To count all the possible moves, we have to change the `all_moves_from_board`
    function to include this improvement. We must do this so that, if the game is
    won by `AI_SIGN` , it will return that value:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了计算所有可能的移动，我们必须将 `all_moves_from_board` 函数更改为包括这个改进。我们必须这样做，以便如果游戏被 `AI_SIGN`
    赢得，它将返回该值：
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We then generate all possible moves. As soon as we find a move that wins the
    game for the AI, we return it. We do not care whether the AI has multiple options
    to win the game in one move – we just return the first possibility. If the AI
    cannot win, we return all possible moves.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们生成所有可能的移动。一旦我们找到一个为 AI 赢得游戏的移动，我们就返回它。我们不在乎 AI 是否在一次移动中有多个赢得游戏的机会 - 我们只返回第一个可能性。如果
    AI 无法赢得游戏，我们返回所有可能的移动。
- en: 'Let''s see what this means in terms of counting all of the possibilities at
    each step:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这在对每一步计算所有可能性方面意味着什么：
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Activity 2: Teaching the Agent to Realize Situations When It Defends Against
    Losses'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动二：教会智能体意识到防御损失的情况
- en: 'In this section, we will discuss how to make the computer player play better
    so that we can reduce the state space and the number of losses. We will force
    the computer to defend against the player putting their third sign in a row, column,
    or diagonal line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何让计算机玩家玩得更好，以便我们可以减少状态空间和损失的数量。我们将迫使计算机防御玩家连续放置第三个标记的情况，即行、列或对角线：
- en: Create a function called `player_can_win` that takes all the moves from the
    board using the `all_moves_from_board` function and iterates over it using a variable
    called `next_move` . On each iteration, it checks whether the game can be won
    by the sign, and then it returns true or false.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `player_can_win` 的函数，该函数使用 `all_moves_from_board` 函数从棋盘获取所有移动，并使用一个名为
    `next_move` 的变量遍历它。在每次迭代中，它检查游戏是否可以通过标记赢得，然后返回 true 或 false。
- en: Extend the AI's move so that it prefers making safe moves. A move is safe if
    the opponent cannot win the game in the next step.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展 AI 的移动，使其更倾向于做出安全的移动。一个移动是安全的，如果对手在下一步无法赢得游戏。
- en: Test the new application. You will find that the AI has made the correct move.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试新应用程序。你会发现AI已经做出了正确的移动。
- en: Place this logic in the state space generator and check how well the computer
    player is doing by generating all possible games.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个逻辑放入状态空间生成器中，并通过生成所有可能的比赛来检查计算机玩家的表现。
- en: We not only got rid of almost two thirds of the possible games again, but most
    of the time, the AI player either wins or settles for a draw. Despite our efforts
    to make the AI better, it can still lose in 962 ways. We will eliminate all of
    these losses in the next activity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅又去掉了几乎所有三分之二的可能比赛，而且大多数时候，AI玩家要么获胜，要么接受平局。尽管我们努力使AI变得更好，但它仍然有962种失败的方式。我们将在下一个活动中消除所有这些损失。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 261.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第261页找到。
- en: 'Activity 3: Fixing the First and Second Moves of the AI to Make it Invincible'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动三：修复AI的第一和第二次移动以使其无敌
- en: 'This section will discuss how an exhaustive search can be focused so that it
    can find moves that are more useful than others. We will be reducing the possible
    games by hardcoding the first and the second move:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论如何将穷举搜索集中在更有用的移动上。我们将通过硬编码第一和第二次移动来减少可能的比赛：
- en: Count the number of empty fields on the board and make a hardcoded move in case
    there are 9 or 7 empty fields. You can experiment with different hardcoded moves.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算棋盘上空格的数量，并在有9个或7个空格的情况下进行硬编码移动。你可以尝试不同的硬编码移动。
- en: Occupying any corner, and then occupying the opposite corner, leads to no losses.
    If the opponent occupied the opposite corner, making a move in the middle results
    in no losses.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 占据任何角落，然后占据对角角落，都不会导致损失。如果对手占据了对角角落，在中部移动会导致没有损失。
- en: After fixing the first two steps, we only need to deal with 8 possibilities
    instead of 504\. We also guided the AI into a state, where the hardcoded rules
    were enough to never lose a game.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复前两个步骤后，我们只需要处理8种可能性，而不是504种。我们还引导AI进入一个状态，其中硬编码的规则足以永远不会输掉比赛。
- en: Note
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 263.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第263页找到。
- en: 'Let''s summarize the important techniques that we applied to reduce the state
    space:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们应用以减少状态空间的重要技术：
- en: '**Empirical simplification** : We accepted that the optimal first move is a
    corner move. We simply hardcoded a move instead of considering alternatives to
    focus on other aspects of the game. In more complex games, empirical moves are
    often misleading. The most famous chess AI victories often contain a violation
    of the common knowledge of chess grandmasters.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**经验简化**：我们接受最佳第一次移动是角落移动。我们简单地硬编码了一个移动，而不是考虑替代方案，以关注游戏的其它方面。在更复杂的游戏中，经验移动往往是误导性的。最著名的国际象棋AI胜利往往包含违反象棋大师的常识。'
- en: '**Symmetry** : After we started with a corner move, we noticed that positions
    1, 3, 7, and 9 are equivalent from the perspective of winning the game. Even though
    we didn''t take this idea further, notice that we could even rotate the table
    to reduce the state space even further, and consider all four corner moves as
    the exact same move.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对称性**：在我们开始使用角落移动后，我们注意到位置1、3、7和9在赢得游戏的角度上是等效的。即使我们没有进一步发展这个想法，请注意，我们甚至可以旋转桌子以进一步减少状态空间，并将所有四个角落移动视为完全相同的移动。'
- en: '**Reduction of different permutations leading to the same state** : Suppose
    we can make the moves A or B and suppose our opponent makes move X, where X is
    not equal to either move A or B. If we explore the sequence A, X, B, and we start
    exploring the sequence B, X, then we don''t have to consider the sequence B, X,
    A. This is because the two sequences lead to the exact same game state, and we
    have already explored a state containing these three moves before.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**减少导致相同状态的不同的排列**：假设我们可以移动A或B，假设我们的对手移动X，其中X不等于移动A或B。如果我们探索序列A、X、B，然后我们开始探索序列B、X，那么我们不需要考虑序列B、X、A。这是因为这两个序列导致完全相同的状态，我们之前已经探索了一个包含这三个移动的状态。'
- en: '**Forced moves for the player** : When a player collects two signs horizontally,
    vertically, or diagonally, and the third cell in the row is empty, we are forced
    to occupy that empty cell either to win the game, or to prevent the opponent from
    winning the game. Forced moves may imply other forced moves, which reduces the
    state space even further.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对玩家的强制移动**：当一个玩家在水平、垂直或对角线上收集到两个标记，并且该行的第三个单元格为空时，我们被迫占据那个空单元格，要么是为了赢得游戏，要么是为了防止对手赢得游戏。强制移动可能意味着其他强制移动，这进一步减少了状态空间。'
- en: '**Forced moves for the opponent** : When a move from the opponent is clearly
    optimal, it does not make sense to consider scenarios when the opponent does not
    make the optimal move. When the opponent can win the game by occupying a cell,
    it does not matter whether we go on a long exploration of the cases when the opponent
    misses the optimal move. We save a lot less by not exploring cases when the opponent
    fails to prevent us from winning the game. This is because after the opponent
    makes a mistake, we will simply win the game.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对对手的强制移动**：当对手的移动明显是最佳选择时，考虑对手不做出最佳移动的情况是没有意义的。当对手可以通过占据一个单元格来赢得游戏时，我们是否对对手错过最佳移动的情况进行长期探索并不重要。我们不探索对手未能阻止我们赢得游戏的情况可以节省很多。这是因为在对手犯错误后，我们简单地赢得游戏。'
- en: '**Random move** : When we can''t decide and don''t have the capacity to search,
    we move randomly. Random moves are almost always inferior to a search-based educated
    guess, but at times, we have no other choice.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机移动**：当我们无法决定且没有搜索能力时，我们会随机移动。随机移动几乎总是不如基于搜索的有根据的猜测，但有时我们别无选择。'
- en: Heuristics
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启发式方法
- en: In this topic, we will formalize informed search techniques by defining and
    applying heuristics to guide our search.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将通过定义和应用启发式方法来形式化有信息搜索技术。
- en: Uninformed and Informed Search
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无信息和有信息搜索
- en: In the Tic-Tac-Toe example, we implemented a greedy algorithm that first focused
    on winning, and then focused on not losing. When it comes to winning the game
    immediately, the greedy algorithm is optimal, because there is never a better
    step than winning the game. When it comes to not losing, it matters how we avoid
    the loss. Our algorithm simply chose a random safe move without considering how
    many winning opportunities we have created.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在井字棋的例子中，我们实现了一个贪婪算法，首先关注获胜，然后关注不输。当涉及到立即赢得游戏时，贪婪算法是最佳的，因为没有比赢得游戏更好的步骤。当涉及到不输时，我们如何避免损失很重要。我们的算法只是简单地选择一个安全的随机移动，而不考虑我们创造了多少获胜机会。
- en: Breadth First Search and Depth First Search are uninform, because they consider
    all possible states in the game. An informed search explores the space of available
    states intelligently.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索和深度优先搜索是无信息的，因为它们考虑了游戏中所有可能的状态。有信息搜索智能地探索可用状态的空间。
- en: Creating Heuristics
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建启发式方法
- en: 'If we want to make better decisions, we apply heuristics to guide the search
    in the right direction by considering longer-term utility. This way, we can make
    a more informed decision in the present based on what could happen in the future.
    This can also help us solve problems faster. We can construct heuristics as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要做出更好的决策，我们会应用启发式方法，通过考虑长期效用来引导搜索的正确方向。这样，我们可以根据未来可能发生的情况，在现在做出更明智的决策。这也可以帮助我们更快地解决问题。我们可以如下构建启发式方法：
- en: Educated guesses on the utility of making a move in the game
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对游戏中移动的效用进行有根据的猜测
- en: Educated guesses on the utility of a given game state from the perspective of
    a player
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从玩家视角对给定游戏状态的效用进行有根据的猜测
- en: Educated guesses on the distance from our goal
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们目标距离的有根据的猜测
- en: Heuristics are functions that evaluate a game state or a transition to a new
    game state based on their utility. Heuristics are the cornerstones of making a
    search problem informed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式方法是评估游戏状态或过渡到新游戏状态的函数，基于它们的效用。启发式方法是使搜索问题有信息的基础。
- en: In this book, we will use utility and cost as negated terms. Maximizing utility
    and minimizing the cost of a move are considered synonyms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用效用和成本作为否定术语。最大化效用和最小化移动成本被认为是同义的。
- en: A commonly used example for a heuristic evaluation function occurs in pathfinding
    problems. Suppose we are looking for a path in the tree of states that leads us
    to a goal state. Each step has an associated cost symbolizing travel distance.
    Our goal is to minimize the cost of reaching a goal state.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于启发式评估函数的常用例子出现在路径查找问题中。假设我们正在寻找一条路径，这条路径在状态树中通向目标状态。每一步都有一个相关的成本，象征着旅行距离。我们的目标是使达到目标状态的成本最小化。
- en: 'The following is an example heuristic for solving the pathfinding problem:
    take the coordinates of the current state and the goal. Regardless of the paths
    connecting these points, calculate the distance between these points. The distance
    of two points in a plane is the length of the straight line connecting the points.
    This heuristic is called the Euclidean distance.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于解决路径查找问题的启发式示例：取当前状态和目标状态的坐标。无论连接这些点的路径如何，计算这些点之间的距离。平面内两点之间的距离是连接这些点的直线长度。这种启发式被称为欧几里得距离。
- en: Suppose we define a pathfinding problem in a maze, where we can only move up,
    down, left, or right. There are a few obstacles in the maze that block our moves.
    A heuristic we can use to evaluate how close we are from the goal state is called
    the Manhattan distance, which is defined as the sum of the horizontal and vertical
    distances between the corresponding coordinates of the current state and the end
    state.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在迷宫中定义一个路径查找问题，我们只能向上、向下、向左或向右移动。迷宫中有几个障碍物阻挡了我们的移动。我们可以用来评估我们离目标状态有多近的启发式称为曼哈顿距离，它被定义为当前状态和最终状态对应坐标的水平距离和垂直距离之和。
- en: Admissible and Non-Admissible Heuristics
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可接受和非可接受启发式
- en: The two heuristics we just defined on pathfinding problems are called admissible
    heuristics when used on their given problem domain. Admissible means that we may
    underestimate the cost of reaching the end state but that we never overestimate
    it. In the next topic, we will explore an algorithm that finds the shortest path
    between the current state and the goal state. The optimal nature of this algorithm
    depends on whether we can define an admissible heuristic function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在路径查找问题中定义的两个启发式，当在给定的问题域中使用时，被称为可接受启发式。可接受意味着我们可能会低估达到最终状态的成本，但我们永远不会高估它。在下一个主题中，我们将探讨一个寻找当前状态和目标状态之间最短路径的算法。这个算法的最优性取决于我们是否可以定义一个可接受启发式函数。
- en: An example of a non-admissible heuristic is the Manhattan distance applied on
    a two-dimensional map. Imagine that there is a direct path between our current
    state and the goal state. The current state is at the coordinates (2, 5), and
    the goal state is at the coordinates (5, 1).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非可接受启发式的例子是将曼哈顿距离应用于二维地图。想象一下，从我们的当前状态到目标状态有一条直接路径。当前状态位于坐标（2，5），目标状态位于坐标（5，1）。
- en: 'The Manhattan distance of the two nodes is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 两个节点之间的曼哈顿距离如下：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we overestimated the cost of traveling from the current node to the goal,
    the Manhattan distance is not admissible when we can move diagonally.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们高估了从当前节点到目标状态的旅行成本，当我们可以斜向移动时，曼哈顿距离不是可接受的。
- en: Heuristic Evaluation
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启发式评估
- en: Create a heuristic evaluation of a Tic-Tac-Toe game state from the perspective
    of the starting player.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从起始玩家的角度创建一个井字棋游戏状态的启发式评估。
- en: We can define the utility of a game state or the utility of a move. Both work,
    because the utility of the game state can be defined as the utility of the move
    leading to it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义游戏状态或移动的效用。两者都适用，因为游戏状态的效用可以定义为导致该状态的移动的效用。
- en: '**Heuristic 1: Simple Evaluation of the Endgame**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**启发式1：简单评估终局**'
- en: 'Let''s define a simple heuristic by evaluating a board: we can define the utility
    of a game state or the utility of a move. Both work, because the utility of the
    game state can be defined as the utility of the move leading to it. The utility
    for the game can be:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过评估棋盘来定义一个简单的启发式：我们可以定义游戏状态或移动的效用。两者都适用，因为游戏状态的效用可以定义为导致该状态的移动的效用。游戏的效用可以是：
- en: +1, if the state implies that the AI player will win the game
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态意味着AI玩家将赢得游戏，则返回+1
- en: -1, if the state implies that the AI player will lose the game
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态意味着AI玩家将输掉游戏，则返回-1
- en: 0, if a draw has been reached or no clear winner can be identified from the
    current state
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经达到平局或无法从当前状态中识别出明确的胜者，则返回0
- en: This heuristic is simple, because anyone can look at a board and analyze whether
    a player is about to win.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启发式方法很简单，因为任何人都可以查看棋盘并分析玩家是否即将获胜。
- en: The utility of this heuristic depends on whether we can play many moves in advance.
    Notice that we cannot even win the game within five steps. We saw in topic A that
    by the time we reach step 5, we have 13,680 possible combinations leading to it.
    In most of these 13,680 cases, our heuristic returns zero.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启发式方法的效用取决于我们能否提前玩很多步。请注意，我们甚至无法在五步内赢得游戏。我们在主题A中看到，当我们达到第5步时，有13,680种可能的组合。在这些13,680种情况中的大多数，我们的启发式方法返回零。
- en: If our algorithm does not look deeper than these five steps, we are completely
    clueless on how to start the game. Therefore, we could invent a better heuristic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的算法没有超过这五步，我们对如何开始游戏完全一无所知。因此，我们可以发明一个更好的启发式方法。
- en: '**Heuristic 2: Utility of a Move**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**启发式2：移动的效用**'
- en: 'Two AI signs in a row, column, or diagonal, and the third cell is empty: +1000
    for the empty cell.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一行、一列或对角线上有两个AI符号，第三个单元格为空：空单元格+1000分。
- en: 'Opponent has two in a row, column, or diagonally, and the third cell is empty:
    +100 for the empty cell.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手在一行、一列或对角线上有两个连续的符号，第三个单元格为空：空单元格+100分。
- en: 'One AI signs in a row, column, or diagonal, and the other two cells are empty:
    +10 for the empty cells.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个AI符号在一行、一列或对角线上，其他两个单元格为空：空单元格+10分。
- en: 'No AI or opponent signs in a row, column, or diagonal: +1 for the empty cells.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有AI或对手的符号在一行、一列或对角线上：空单元格+1分。
- en: Occupied cells get a value of minus infinity. In practice, due to the nature
    of the rules, -1 will also do.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被占据的单元格得到负无穷大的值。在实践中，由于规则的性质，-1也足够了。
- en: Why do we use a multiplicator factor of 10 for the four rules? Because there
    are eight possible ways of making three in a row, column, and diagonal. So, even
    by knowing nothing about the game, we are certain that a lower-level rule may
    not accumulate to override a higher-level rule. In other words, we will never
    defend against the opponent's moves if we can win the game.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用10的乘数因子来计算这四条规则？因为在一行、一列和对角线上，有八种可能的方式组成三个连续的符号。所以，即使我们对这个游戏一无所知，我们也可以确定低级规则可能不会累积到覆盖高级规则。换句话说，如果我们能赢得游戏，我们永远不会防御对手的移动。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 备注
- en: As the job of our opponent is also to win, we can compute this heuristic from
    the opponent's point of view. Our task is to maximize this value too so that we
    can defend against the optimal plays of our opponent. This is the idea behind
    the Minmax algorithm as well. If we wanted to convert this heuristic to a heuristic
    describing the current board, we could compute the heuristic value for all open
    cells and take the maximum of the values for the AI character so that we can maximize
    our utility.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对手的任务也是获胜，我们可以从对手的角度计算这个启发式方法。我们的任务是最大化这个值，以便我们可以防御对手的最佳策略。这也是Minmax算法背后的思想。如果我们想将这个启发式方法转换为描述当前棋盘的启发式方法，我们可以计算所有开放单元格的启发式值，并取AI字符值的最大值，以便我们可以最大化我们的效用。
- en: 'For each board, we will create a utility matrix. For example, consider the
    following board:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个棋盘，我们将创建一个效用矩阵。例如，考虑以下棋盘：
- en: '![Figure 2.1 Tic-tac-toe game state](img/Image00006.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1井字棋游戏状态](img/Image00006.jpg)'
- en: 'Figure 2.1: Tic-Tac-Toe game state'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.1：井字棋游戏状态
- en: 'From here, we can construct its utility matrix:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以构建它的效用矩阵：
- en: '![Figure 2.2 Tic-Tac-Toe game utility matrix](img/Image00007.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2井字棋游戏效用矩阵](img/Image00007.jpg)'
- en: 'Figure 2.2: Tic-Tac-Toe game utility matrix'
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.2：井字棋游戏效用矩阵
- en: On the second row, the left cell is not very useful if we were to select it.
    Note that if we had a more optimal utility function, we would reward blocking
    the opponent.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，如果我们选择左边的单元格，它并不是很有用。请注意，如果我们有一个更优化的效用函数，我们会奖励阻止对手。
- en: The two cells of the third column both get a 10-point boost for two in a row.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列的两个单元格都因为有两个连续的符号而得到10分的提升。
- en: The top-right cell also gets 100 points for defending against the diagonal of
    the opponent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 右上角的单元格也因为防御对手的对角线而得到100分。
- en: From this matrix, it is evident that we should choose the top-right move.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个矩阵中，很明显我们应该选择右上角的移动。
- en: We can use this heuristic both to guide us toward an optimal next move, or to
    give a more educated score on the current board by taking the maximum of these
    values. We have technically used parts of this heuristic in Topic A in the form
    of hardcoded rules. Note, though, that the real utility of heuristics is not the
    static evaluation of a board, but the guidance it provides on limiting the search
    space.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个启发式方法来指导我们走向最佳下一步，或者通过取这些值的最大值来对当前棋盘给出一个更明智的评分。我们在主题A中实际上已经以硬编码规则的形式使用了这个启发式方法的一部分。然而，需要注意的是，启发式方法的真正效用不是对棋盘的静态评估，而是它提供的在限制搜索空间方面的指导。
- en: 'Exercise 5: Tic-Tac-Toe Static Evaluation with a Heuristic Function'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：使用启发式函数的井字棋静态评估
- en: Perform static evaluation on the Tic-Tac-Toe game using heuristic function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用启发式函数对井字棋游戏进行静态评估。
- en: In this section, we will create a function that takes the Utility vector of
    possible moves, takes three indices inside the utility vector representing a triple,
    and returns a function. The returned function expects a points parameter and modifies
    the Utilities vector such that it adds points to each cell in the (i, j, k) triple,
    as long as the original value of that cell is non-negative. In other words, we
    increase the utility of empty cells only.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个函数，该函数接受可能的移动的效用向量，接受效用向量内部的三个索引表示一个三元组，并返回一个函数。返回的函数期望一个点数参数，并修改效用向量，使得在(i,
    j, k)三元组中的每个单元格增加点数，只要该单元格的原始值是非负的。换句话说，我们只增加空单元格的效用。
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now have everything to create the utility matrix belonging to any board
    constellation:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建任何棋盘配置的效用矩阵所需的一切：
- en: '[PRE8]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will now create a function that strictly selects the move with the highest
    utility value. If multiple moves have thise same utility, the function returns
    both moves.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个函数，该函数严格选择具有最高效用值的移动。如果有多个移动具有相同的效用值，该函数将返回这两个移动。
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's run the application.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行这个应用程序。
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output will be as follows:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using Heuristics for an Informed Search
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用启发式方法进行信息搜索
- en: We have not experienced the real power of heuristics yet, as we made moves without
    the knowledge of the effects of our future moves, thus effecting reasonable play
    from our opponents.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有真正体验到启发式方法的威力，因为我们是在不知道未来移动效果的情况下进行移动的，因此影响了对手的合理游戏。
- en: This is why a more accurate heuristic leads to more losses than simply hardcoding
    the first two moves in the game. Note that in previous topic, we selected these
    two moves based on statistics we generated based on running the game with fixed
    first moves. This approach is essentially what heuristic search should be all
    about. Static evaluation cannot compete with generating hundreds of thousands
    of future states and selecting a play that maximizes our rewards.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么一个更精确的启发式方法会导致比简单地硬编码游戏的前两步更多的损失。注意，在前一个主题中，我们是根据基于运行具有固定第一步的游戏所生成的统计数据来选择这两个移动的。这种方法本质上就是启发式搜索应该关注的内容。静态评估无法与生成数以万计的未来状态并选择最大化我们奖励的玩法相竞争。
- en: Types of Heuristics
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启发式方法的类型
- en: Therefore, a more accurate heuristic leads to more losses than simply hardcoding
    the first two moves in the game. Note that in Topic A, we selected these two moves
    based on statistics I generated based on running the game with fixed first moves.
    This approach is essentially what a heuristic search should be all about. Static
    evaluation cannot compete with generating hundreds of thousands of future states
    and selecting a play that maximizes our rewards.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个更精确的启发式方法会导致比简单地硬编码游戏的前两步更多的损失。注意，在主题A中，我们是根据基于运行具有固定第一步的游戏所生成的统计数据来选择这两个移动的。这种方法本质上就是启发式搜索应该关注的内容。静态评估无法与生成数以万计的未来状态并选择最大化我们奖励的玩法相竞争。
- en: This is because our heuristics are not exact, and most likely not admissible
    either.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是因为我们的启发式方法并不精确，而且很可能也不是可接受的。
- en: 'We saw in the preceding exercise that heuristics are not always optimal: in
    the first topic, we came up with rules that allowed the AI to always win the game
    or finish with a draw. These heuristics allowed the AI to win very often, at the
    expense of losing in a few cases.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我们看到了启发式方法并不总是最优的：在第一个主题中，我们提出了允许AI总是赢得游戏或以平局结束的规则。这些启发式方法使AI在大多数情况下都能获胜，但在少数情况下会失败。
- en: A heuristic is said to be admissible if we may underestimate the utility of
    a game state, but we never overestimate it.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们可以低估游戏状态的效用，但永远不会高估它，那么一个启发式方法被认为是可接受的。
- en: In the Tic-Tac-Toe example, we likely overestimated the utility in a few game
    states. Why? Because we ended up with a loss twelve times. A few of the game states
    that led to a loss had a maximum heuristic score. To prove that our heuristic
    is not admissible, all we need to do is find a potentially winning game state
    that we ignored while choosing a game state that led to a loss.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在井字棋的例子中，我们可能高估了一些游戏状态的价值。为什么？因为我们最终输了十二次。导致失败的一些游戏状态具有最大的启发式分数。为了证明我们的启发式方法不可接受，我们只需要找到一个可能获胜的游戏状态，这个状态在我们选择导致失败的游戏状态时被忽略了。
- en: 'There are two more features that describe heuristics: Optimal and Complete:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 描述启发式方法的还有两个特性：最优和完全：
- en: '**Optimal heuristics** always find the best possible solution.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最优启发式**总是找到最佳可能的解决方案。'
- en: '**Complete heuristics** have two definitions, depending on how we define the
    problem domain. In a loose sense, a heuristic is said to be complete if it always
    finds a solution. In a strict sense, a heuristic is said to be complete if it
    finds all possible solutions. Our Tic-Tac-Toe heuristic is not complete, because
    we ignored many possible winning states on purpose, favoring a losing state.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全启发式**有两个定义，这取决于我们如何定义问题域。在广义上，如果启发式方法总是找到解决方案，则称其为完全的。在狭义上，如果启发式方法找到所有可能的解决方案，则称其为完全的。我们的井字棋启发式方法不是完全的，因为我们故意忽略了许多可能的获胜状态，而选择了失败状态。'
- en: Pathfinding with the A* Algorithm
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用A*算法进行路径查找
- en: In the first two topics, we learned how to define an intelligent agent, and
    how to create a heuristic that guides the agent toward a desired state. We learned
    that this was not perfect, because at times we ignored a few winning states in
    favor of a few losing states.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个主题中，我们学习了如何定义智能体，以及如何创建一个引导智能体向目标状态前进的启发式方法。我们了解到这并不完美，因为有时我们为了几个失败状态而忽略了几个获胜状态。
- en: 'We will now learn a structured and optimal approach so that we can execute
    a search for finding the shortest path between the current state and the goal
    state: the **A*** (**"A star" instead of "A asterisk"** ) algorithm:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习一种结构化和最优的方法，以便我们可以执行搜索以找到当前状态和目标状态之间的最短路径：**A*算法**（"A star"而不是"A asterisk"）：
- en: '![Figure 2.3 Shortest pathfinding game board](img/Image00008.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 最短路径查找游戏棋盘](img/Image00008.jpg)'
- en: 'Figure 2.3: Finding the shortest path in a maze'
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.3：在迷宫中找到最短路径
- en: 'For a human, it is simple to find the shortest path, by merely looking at the
    image. We can conclude that there are two potential candidates for the shortest
    path: route one starts upwards, and route two starts to the left. However, the
    AI does not know about these options. In fact, the most logical first step for
    a computer player would be moving to the square denoted by the number 3 in the
    following diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类来说，通过仅仅查看图像就能找到最短路径很简单。我们可以得出结论，存在两个潜在的最短路径候选者：一条路径向上开始，另一条路径向左开始。然而，AI并不知道这些选项。实际上，对于计算机玩家来说，最合逻辑的第一步是移动到以下图中标记为数字3的方格：
- en: 'Why? Because this is the only step that decreases the distance between the
    starting state and the goal state. All other steps initially move away from the
    goal state:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为这是唯一一个减少起始状态和目标状态之间距离的步骤。所有其他步骤最初都远离目标状态：
- en: '![Figure 2.4 Shortest pathfinding game board with Utilities](img/Image00009.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 最短路径查找游戏棋盘带有效用](img/Image00009.jpg)'
- en: 'Figure 2.4: Shortest pathfinding game board with utilities'
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.4：带有效用的最短路径查找游戏棋盘
- en: 'Exercise 6: Finding the Shortest Path to Reach a Goal'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：找到达到目标的最短路径
- en: 'The steps to find the shortest path are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最短路径的步骤如下：
- en: Describe the board, the initial state, and the final state using Python. Create
    a function that returns a list of possible successor states.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python描述棋盘、初始状态和最终状态。创建一个函数，该函数返回可能的后继状态列表。
- en: 'We will use tuples, where the first coordinate denotes the row number from
    1 to 7, and the second coordinate denotes the column number from 1 to 9:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用元组，其中第一个坐标表示从1到7的行号，第二个坐标表示从1到9的列号：
- en: '[PRE12]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will use array comprehension to generate the successor states in the following
    way. We move one left and one right from the current column, as long as we stay
    on the board. We move one up and one down from the current row, as long as we
    stay on the board. We take the new coordinates, generate all four possible tuples,
    and filter the results so that the new states can''t be in the Obstacles list.
    It also makes sense to exclude moves that return to a field we had visited before
    to avoid infinite loops:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用数组推导来生成以下方式的后继状态。我们从当前列向左和向右移动一个单位，只要我们保持在棋盘上。我们从当前行向上和向下移动一个单位，只要我们保持在棋盘上。我们取新的坐标，生成所有四个可能的元组，并过滤结果，以确保新的状态不能在障碍物列表中。同时，排除回到我们之前访问过的场地的移动也是有意义的，以避免无限循环：
- en: '[PRE13]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Exercise 7: Finding the Shortest Path Using BFS'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 7：使用 BFS 寻找最短路径
- en: 'To find the shortest path, follow these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到最短路径，请按照以下步骤操作：
- en: Find the shortest path by using the BFS algorithm.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 BFS 算法找到最短路径。
- en: Recall the basic BFS implementation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾基本的 BFS 实现。
- en: 'We have to modify this implementation to include the cost. Let''s measure the
    cost:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须修改这个实现以包含成本。让我们测量成本：
- en: '[PRE14]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output will be as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE15]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see that a simple BFS algorithm successfully determines the cost from
    the start node to any nodes, including the target node. Let''s measure the number
    of steps required to find the goal node:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到，一个简单的 BFS 算法成功地确定了从起始节点到任何节点（包括目标节点）的成本。让我们测量找到目标节点所需的步数：
- en: '[PRE16]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The end node has been reached in 110 steps:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标节点在 110 步后到达：
- en: '[PRE18]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will now learn an algorithm that can find the shortest path from the start
    node to the goal node: the A* algorithm.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习一个可以找到从起始节点到目标节点的最短路径的算法：A* 算法。
- en: Introducing the A* Algorithm
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍 A* 算法
- en: 'A* is a complete and optimal heuristic search algorithm that finds the shortest
    possible path between the current game state and the winning state. The definition
    of complete and optimal in this state are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: A* 是一种完整且最优的启发式搜索算法，它可以在当前游戏状态和获胜状态之间找到可能的最短路径。在此状态下，完整和最优的定义如下：
- en: Complete means that A* always finds a solution.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整意味着 A* 总是能找到解决方案。
- en: Optimal means that A* will find the best solution.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最优意味着 A* 将找到最佳解决方案。
- en: 'To set up the A* algorithm, we need the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 A* 算法，我们需要以下内容：
- en: An initial state
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始状态
- en: A description of the goal states
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述目标状态
- en: Admissible heuristics to measure progress toward the goal state
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可行的启发式方法来衡量通向目标状态的过程
- en: A way to generate the next steps toward the goal
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种生成通向目标下一步的方法
- en: 'Once the setup is complete, we execute the A* algorithm using the following
    steps on the initial state:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完成，我们将按照以下步骤在初始状态下执行 A* 算法：
- en: We generate all possible next steps.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成所有可能的后继步骤。
- en: We store these children in the order of their distance from the goal.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将按照它们与目标距离的顺序存储这些子节点。
- en: We select the child with the best score first and repeat these three steps on
    the child with the best score as the initial state. This is the shortest path
    to get to a node from the starting node.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先选择得分最高的子节点，然后以得分最高的子节点作为初始状态重复这三个步骤。这是从起始节点到达节点的最短路径。
- en: '`distance_from_end( node )` is an admissible heuristic estimation showing how
    far we are from the goal node.'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`distance_from_end( node )` 是一个可接受的启发式估计，显示了我们从目标节点有多远。'
- en: 'In pathfinding, a good heuristic can be the Euclidean distance. If the current
    node is (x, y) and the goal node is (u, v), then:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径查找中，一个好的启发式方法是欧几里得距离。如果当前节点是 (x, y) 且目标节点是 (u, v)，那么：
- en: '*distance_from_end( node ) = sqrt( abs( x – u ) ** 2 + abs( y – v ) ** 2 )*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*distance_from_end( node ) = sqrt( abs( x – u ) ** 2 + abs( y – v ) ** 2 )*'
- en: 'Where:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '`sqrt` is the square root function. Don''t forget to import it from the math
    library.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqrt` 是平方根函数。别忘了从 math 库中导入它。'
- en: '`abs` is the absolute value function. `abs( -2 )` = `abs( 2 )` = `2` .'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abs` 是绝对值函数。`abs( -2 )` = `abs( 2 )` = `2` 。'
- en: '`x ** 2` is *x* raised to the second power.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x ** 2` 是 *x* 的平方。'
- en: We will use the `distance_from_start` matrix to store the distances from the
    start node. In the algorithm, we will refer to this costs matrix as `distance_from_start(
    n1 )` . For any node, `n1` , that has coordinates `(x1, y1)` , this distance is
    equivalent to `distance_from_start[x1][y1]` .
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `distance_from_start` 矩阵来存储从起始节点到距离。在算法中，我们将把这个成本矩阵称为 `distance_from_start(
    n1 )` 。对于任何具有坐标 `(x1, y1)` 的节点 `n1` ，这个距离等同于 `distance_from_start[x1][y1]` 。
- en: We will use the `succ( n )` notation to generate a list of successor nodes from
    `n` .
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `succ( n )` 符号从 `n` 生成后继节点列表。
- en: 'Let''s see the pseudo-code of the algorithm:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看算法的伪代码：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Regarding the retrieval of the shortest path, we can make use of the costs
    matrix. This matrix contains the distance of each node on the path from the start
    node. As cost always decreases when walking backward, all we need to do is start
    with the end node and walk backward greedily toward decreasing costs:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于检索最短路径，我们可以利用成本矩阵。这个矩阵包含从起始节点到路径上每个节点的距离。由于在向后行走时成本总是减少，我们只需要从终点开始，贪婪地向减少的成本方向行走：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A* shines when we have one Start state and one Goal state. The complexity of
    the A* algorithm is `O( E )` , where `E` stands for all possible edges in the
    field. In our example, we have up to four edges leaving any node: up, down, left,
    and right.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个起始状态和一个目标状态时，A* 算法表现得尤为出色。A* 算法的复杂度是 `O( E )`，其中 `E` 代表场中所有可能的边。在我们的例子中，任何节点最多有四个离开的边：上、下、左和右。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'To sort the frontier list in the proper order, we must use a special Python
    data structure: a priority queue.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按正确顺序对前沿列表进行排序，我们必须使用特殊的 Python 数据结构：优先队列。
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Why is it important that the heuristic used by the algorithm is admissible?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么算法使用的启发式函数必须是可接受的很重要？
- en: 'Because this is how we guarantee the optimal nature of the algorithm. For any
    node `x` , we are measuring the sum of the following: The distances from the start
    node to `x` The estimated distance from `x` to the end node. If the estimation
    never overestimates the distance from `x` to the end node, we will never overestimate
    the total distance. Once we are at the goal node, our estimation is zero, and
    the total distance from the start to the end becomes an exact number.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这就是我们保证算法最优性的方法。对于任何节点 `x`，我们测量以下总和：从起始节点到 `x` 的距离，从 `x` 到终点节点的估计距离。如果估计永远不会高估
    `x` 到终点节点的距离，我们就永远不会高估总距离。一旦我们到达目标节点，我们的估计为零，从起始点到终点的总距离就变成了一个确切的数字。
- en: We can be sure that our solution is optimal because there are no other items
    in the priority queue that have a lower estimated cost. Given that we never overestimate
    our costs, we can be sure that all of the nodes in the frontier of the algorithm
    have either similar total costs or higher total costs than the path we found.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确信我们的解决方案是最优的，因为优先队列中没有其他项目具有更低的估计成本。鉴于我们从未高估我们的成本，我们可以确信算法前沿的所有节点要么具有与找到的路径相似的总成本，要么具有更高的总成本。
- en: 'Implement the A* algorithm to find the path with the lowest cost in the following
    game field:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下游戏场景中实现 A* 算法以找到最低成本的路径：
- en: '![ Figure 2.5 Shortest pathfinding game board](img/Image00010.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 最短路径查找游戏板](img/Image00010.jpg)'
- en: 'Figure 2.5: Shortest pathfinding game board'
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.5：最短路径查找游戏板
- en: 'We''ll reuse the initialization code from the game-modeling exercise:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用游戏建模练习中的初始化代码：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have also written code to initialize the cost matrix:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还编写了初始化成本矩阵的代码：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will omit the function to update costs because we will do so inside the
    A* algorithm:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将省略更新成本的函数，因为我们将在 A* 算法内部执行此操作：
- en: 'Let''s initialize the A* algorithm''s frontier and internal lists. For frontier,
    we will use a Python PriorityQueue. Do not directly execute this code, because
    we will use these four lines inside the A* search function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们初始化 A* 算法的前沿和内部列表。对于前沿，我们将使用 Python PriorityQueue。请勿直接执行此代码，因为我们将在 A* 搜索函数内部使用这四行：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now it is time to implement a heuristic function that measures the distance
    between the current node and the goal node using the algorithm we saw in the theory
    section:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现一个启发式函数，该函数使用我们在理论部分看到的算法来衡量当前节点和目标节点之间的距离：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last step is the translation of the A* algorithm into the functioning code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 A* 算法转换为可执行的代码：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are a few differences between our implementation and the original algorithm:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实施方案与原始算法之间有一些差异：
- en: We defined a `distance_from_start` function to make it easier and more semantic
    to access the `costs` matrix. Note that we number the node indices starting with
    1, while in the matrix, indices start with zero. Therefore, we subtract 1 from
    the node values to get the indices.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `distance_from_start` 函数，使其更容易且更具语义地访问 `costs` 矩阵。请注意，我们从 1 开始编号节点索引，而在矩阵中，索引从
    0 开始。因此，我们从节点值中减去 1 以获得索引。
- en: When generating the successor nodes, we automatically ruled out nodes that are
    in the Internal set. `successors = succ(node, internal)` makes sure that we only
    get the neighbors whose examination is not yet closed, meaning that their score
    is not necessarily optimal.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成后续节点时，我们自动排除了内部集合中的节点。`successors = succ(node, internal)` 确保我们只得到那些尚未完成检查的邻居，这意味着它们的分数不一定是最优的。
- en: As a consequence, we may skip the step check, as internal nodes will never end
    up in `succ( n )` .
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，我们可能可以跳过步骤检查，因为内部节点永远不会出现在`succ( n )`中。
- en: As we are using a priority queue, we have to determine the estimated priority
    of node s before inserting it. We will only insert the node to frontier, though,
    if we know that this node does not have an entry with a lower score.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是优先队列，在插入节点s之前，我们必须确定节点s的估计优先级。然而，我们只会将节点插入到边界，如果我们知道这个节点没有比它分数更低的条目。
- en: It may happen that node s is already in the frontier queue with a higher score.
    In this case, we remove this entry before inserting it to the right place in the
    priority queue. When we find the end node, we simply return the length of the
    shortest path instead of the path itself.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生节点s已经在边界队列中，但分数更高的情况。在这种情况下，我们在将其插入到优先队列的正确位置之前，先删除这个条目。当我们找到终点节点时，我们只需返回最短路径的长度，而不是路径本身。
- en: 'To get a bit more information on the execution, let''s print this information
    to the console. To follow what the A* algorithm does, execute this code and study
    the logs:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取更多关于执行的信息，让我们将这些信息打印到控制台。为了跟踪A*算法的执行过程，执行以下代码并研究日志：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have seen that the A * search returns the right values. The question is,
    how can we reconstruct the whole path?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到A*搜索返回了正确的值。问题是，我们如何重建整个路径？
- en: 'Remove the print statements from the code for clarity and continue with the
    A* algorithm that we implemented in step 4\. Instead of returning the length of
    the shortest path, we have to return the path itself. We will write a function
    that extracts this path by walking backward from the end node, analyzing the costs
    matrix. Do not define this function globally yet. We will define it as a local
    function in the A* algorithm that we created previously:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，从代码中删除print语句，并继续使用我们在第4步中实现的A*算法。我们不仅要返回最短路径的长度，还要返回路径本身。我们将编写一个函数，通过从终点节点向后遍历，分析成本矩阵来提取此路径。暂时不要在全局定义此函数。我们将将其定义为之前创建的A*算法中的局部函数：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we know how to deconstruct the path, let''s return it inside the A*
    algorithm:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何分解路径，让我们将其返回到A*算法中：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Technically, we do not need to reconstruct the path from the costs matrix. We
    could record the parent node of each node in a matrix, and simply retrieve the
    coordinates to save a bit of searching.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们不需要从成本矩阵中重建路径。我们可以在矩阵中记录每个节点的父节点，并简单地检索坐标以节省一些搜索。
- en: A* Search in Practice Using the simpleai Library
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用simpleai库进行A*搜索实践
- en: The `simpleai` library is available on GitHub, and contains many popular AI
    tools and techniques.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`simpleai`库可在GitHub上找到，并包含许多流行的AI工具和技术。'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can access the library at [https://github.com/simpleai-team/simpleai](https://github.com/simpleai-team/simpleai)
    . The documentation of the Simple AI library can be accessed here: [http://simpleai.readthedocs.io/en/latest/](http://simpleai.readthedocs.io/en/latest/)
    .To access the `simpleai` library, first you have to install it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过[https://github.com/simpleai-team/simpleai](https://github.com/simpleai-team/simpleai)
    访问该库。Simple AI库的文档可以在这里访问：[http://simpleai.readthedocs.io/en/latest/](http://simpleai.readthedocs.io/en/latest/)。要访问`simpleai`库，首先你必须安装它：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once simpleai has been installed, you can import classes and functions from
    the simpleai library in the Jupyter QtConsole of Python:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了simpleai，你就可以在Python的Jupyter QtConsole中导入simpleai库中的类和函数：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Search Problem** gives you a frame for defining any search problems. The
    `astar` import is responsible for executing the A* algorithm inside the search
    problem.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索问题**为你提供了一个定义任何搜索问题的框架。`astar`导入负责在搜索问题中执行A*算法。'
- en: For simplicity, we have not used classes in the previous code examples to focus
    on the algorithms in a plain old style without any clutter. The `simpleai` library
    will force us to use classes, though.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们在之前的代码示例中没有使用类，以便在没有杂乱的情况下专注于算法。不过，`simpleai`库将迫使我们使用类。
- en: 'To describe a search problem, you need to provide the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述一个搜索问题，你需要提供以下信息：
- en: '**constructor** : This initializes the state space, thus describing the problem.
    We will make the Size, Start, End, and Obstacles values available in the object
    by adding it to these as properties. At the end of the constructor, don''t forget
    to call the super constructor, and don''t forget to supply the initial state.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**constructor**：此函数初始化状态空间，从而描述问题。我们将通过将这些值添加为属性来使Size、Start、End和Obstacles值在对象中可用。在构造函数的末尾，别忘了调用超构造函数，别忘了提供初始状态。'
- en: '**actions( state )** : This returns a list of actions that we can perform from
    a given state. We will use this function to generate the new states. Semantically,
    it would make more sense to create action constants such as UP, DOWN, LEFT, and
    RIGHT, and then interpret these action constants as a result. However, in this
    implementation, we will simply interpret an action as "move to `(x, y)` ", and
    represent this command as `(x, y)` . This function contains more-or-less the logic
    that we implemented in the `succ` function before, except that we won''t filter
    the result based on a set of visited nodes.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**actions( state )**：此函数返回从给定状态可以执行的动作列表。我们将使用此函数来生成新状态。从语义上讲，创建动作常量如UP、DOWN、LEFT和RIGHT，然后将这些动作常量解释为结果会更合理。然而，在这个实现中，我们将简单地解释一个动作为“移动到`(x,
    y)`”，并将此命令表示为`(x, y)`。此函数包含的逻辑与我们在`succ`函数中实现的逻辑大致相同，只是我们不会根据一组已访问节点过滤结果。'
- en: '**result( state0, action)** : This returns the new state of action applied
    on the state0.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**result( state0, action)**：此函数返回在state0上应用动作后的新状态。'
- en: '**is_goal( state )** : This returns true if the state is a goal state. In our
    implementation, we will have to compare the state to the end state coordinates.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_goal( state )**：如果状态是目标状态，则此函数返回true。在我们的实现中，我们将不得不将状态与最终状态坐标进行比较。'
- en: '**cost( self, state, action, newState )** : This is the cost of moving from
    state to `newState` via action. In our example, the cost of a move is uniformly
    1:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cost( self, state, action, newState )**：这是通过动作从状态移动到`newState`的成本。在我们的例子中，移动的成本是均匀的1：'
- en: '[PRE38]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `simpleai` library made the search description a lot easier than the manual
    implementation. All we need to do is define a few basic methods, and then we have
    access to an effective search implementation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`simpleai`库使搜索描述比手动实现容易得多。我们只需要定义几个基本方法，然后我们就可以访问有效的搜索实现了。'
- en: Game AI with the Minmax Algorithm and Alpha-Beta Pruning
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用最小-最大算法和Alpha-Beta剪枝的游戏AI
- en: In the first two topics, we saw how hard it was to create a winning strategy
    for a simple game such as Tic-Tac-Toe. The last topic introduced a few structures
    for solving search problems with the A* algorithm. We also saw that tools such
    as the `simpleai` library help us reduce the effort we put in to describe a task
    with code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个主题中，我们看到了创建一个简单游戏如井字棋的获胜策略是多么困难。最后一个主题介绍了几种使用A*算法解决搜索问题的结构。我们还看到，像`simpleai`库这样的工具帮助我们减少用代码描述任务所付出的努力。
- en: We will use all of this knowledge to supercharge our game AI skills and solve
    more complex problems.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用所有这些知识来提升我们的游戏AI技能并解决更复杂的问题。
- en: Search Algorithms for Turn-Based Multiplayer Games
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮流制多人游戏的搜索算法
- en: Turn-based multiplayer games such as Tic-Tac-Toe are similar to pathfinding
    problems. We have an initial state, and we have a set of end states, where we
    win the game.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 轮流制多人游戏，如井字棋，与路径查找问题类似。我们有一个初始状态，我们有一组目标状态，在那里我们赢得游戏。
- en: The challenge with turn-based multiplayer games is the combinatoric explosion
    of the opponent's possible moves. This difference justifies treating turn-based
    games differently than a regular pathfinding problem.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 轮流制多人游戏的挑战在于对手可能移动的组合爆炸。这种差异使得将轮流制游戏与常规路径查找问题区别对待是合理的。
- en: For instance, in the Tic-Tac-Toe game, from an empty board, we can select one
    of the nine cells and place our sign there, assuming we start the game. Let's
    denote this algorithm with the function `succ` , symbolizing the creation of successor
    states. Consider we have the initial state denoted by `Si` .
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在井字棋游戏中，从一个空板中，我们可以选择九个单元格中的一个，并将我们的标志放在那里，假设我们开始游戏。让我们用函数`succ`表示这个算法，表示后继状态的创建。考虑我们有一个用`Si`表示的初始状态。
- en: '`succ(Si) returns [ S1, S2, ..., Sn ]` , where `S1, S2, ..., Sn` are successor
    states:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`succ(Si)`返回`[ S1, S2, ..., Sn ]`，其中`S1, S2, ..., Sn`是后继状态：'
- en: '![Figure 2.6 Tree diagram denoting the successor states of the function](img/Image00011.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6表示函数后继状态的树状图](img/Image00011.jpg)'
- en: 'Figure 2.6: Tree diagram denoting the successor states of the function'
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.6：表示函数后继状态的树状图
- en: 'Then, the opponent also makes a move, meaning that from each possible state,
    we have to examine even more states:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对手也进行了一步移动，这意味着从每个可能的状态，我们必须检查更多的状态：
- en: '![Figure 2.7 Tree diagram denoting parent-successor relationships](img/Image00012.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 表示父-后继关系的树状图](img/Image00012.jpg)'
- en: 'Figure 2.7: Tree diagram denoting parent-successor relationships'
  id: totrans-257
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.7：表示父-后继关系的树状图
- en: 'The expansion of possible future states stops in one of two cases:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的未来状态的扩展在两种情况下停止：
- en: The game ends
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束
- en: Due to resource limitations, it is not worth explaining any more moves beyond
    a certain depth for a state with a certain utility
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于资源限制，对于具有特定效用的状态，在某个深度以上的移动不值得进一步解释
- en: Once we stop expanding, we have to make a static heuristic evaluation of the
    state. This is exactly what we did in the first two topics, when choosing the
    best move; however, we never considered future states.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们停止扩展，就必须对状态进行静态启发式评估。这正是我们在前两个主题中在选择最佳移动时所做的事情；然而，我们从未考虑过未来的状态。
- en: Therefore, even though our algorithm became more and more complex, without using
    the knowledge of possible future states, we had a hard time detecting whether
    our current move would likely be a winner or a loser. The only way for us to take
    control of the future was to change our heuristic knowing how many games we would
    win, lose, or tie in the future. We could either maximize our wins or minimize
    our losses. We still didn't dig deeply enough to see whether our losses could
    have been avoided through smarter play on the AI's end.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我们的算法变得越来越复杂，但没有使用对未来状态的了解，我们很难检测我们的当前移动是否可能是一个赢家或输家。我们控制未来的唯一方法是通过改变启发式方法，了解我们将来会赢多少场、输多少场或平局。我们可以最大化我们的胜利或最小化我们的损失。我们仍然没有深入挖掘，看看我们的损失是否可以通过AI端更聪明的玩法来避免。
- en: All of these problems can be avoided by digging deeper into future states and
    recursively evaluating the utility of the branches. To consider future states,
    we will learn the Minmax algorithm and its variant, the Negamax algorithm.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都可以通过深入挖掘未来状态并递归评估分支的效用来避免。为了考虑未来状态，我们将学习最小-最大算法及其变体，即Negamax算法。
- en: The Minmax Algorithm
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小-最大算法
- en: 'Suppose there''s a game where a heuristic function can evaluate a game state
    from the perspective of the AI player. For instance, we used a specific evaluation
    for the Tic-Tac-Toe exercise:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个游戏，启发式函数可以从AI玩家的角度评估游戏状态。例如，我们在井字棋练习中使用了特定的评估：
- en: +1,000 points for a move that won the game
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赢得游戏的移动加1,000分
- en: +100 points for a move preventing the opponent from winning the game
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止对手赢得游戏的移动加100分
- en: +10 points for a move creating two in a row, column, or diagonal
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两行、列或对角线的移动加10分
- en: +1 point for a move creating one in a row, column, or diagonal
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一行、列或对角线的一个移动加1分
- en: This static evaluation is very easy to implement on any node. The problem is,
    as we go deep into the tree of all possible future states, we don't know what
    to do with these scores yet. This is where the Minmax algorithm comes into play.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种静态评估在任何节点上都非常容易实现。问题是，当我们深入到所有可能未来状态的树中时，我们还不知道如何处理这些分数。这就是最小-最大算法发挥作用的地方。
- en: 'Suppose we construct a tree with each possible move that could be performed
    by each player up to a certain depth. At the bottom of the tree, we evaluate each
    option. For the sake of simplicity, let''s assume that we have a search tree that
    looks as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们构建一个树，其中包含每个玩家可以执行的可能移动，直到一定深度。在树的底部，我们评估每个选项。为了简化起见，让我们假设我们有一个如下所示的搜索树：
- en: '![Figure 2.8 Example of search tree up to a certain depth](img/Image00013.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 搜索树到一定深度的示例](img/Image00013.jpg)'
- en: 'Figure 2.8: Example of search tree up to a certain depth'
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.8：搜索树到一定深度的示例
- en: The AI plays with X, and the player plays with O. A node with X means that it's
    X's turn to move. A node with O means it's O's turn to act.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: AI用X玩，玩家用O玩。带有X的节点意味着轮到X移动。带有O的节点意味着轮到O行动。
- en: 'Suppose there are all O leaves at the bottom of the tree, and we didn''t compute
    any more values because of resource limitations. Our task is to evaluate the utility
    of the leaves:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设树底部的所有O都是叶子节点，由于资源限制，我们没有计算更多的值。我们的任务是评估叶子的效用：
- en: '![Figure 2.9 Example of search tree with possible moves](img/Image00014.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 具有可能移动的搜索树示例](img/Image00014.jpg)'
- en: 'Figure 2.9: Example of search tree with possible moves'
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.9：具有可能移动的搜索树示例
- en: 'We have to select the best possible move from our perspective, because our
    goal is to maximize the utility of our move. This aspiration to maximize our gains
    represents the Max part in the Minmax algorithm:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从我们的角度选择最佳可能的移动，因为我们的目标是最大化我们移动的效用。这种最大化收益的愿望代表了MinMax算法中的Max部分：
- en: '![Figure 2.10 Example of search tree with best possible move](img/Image00015.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 具有最佳移动的搜索树示例](img/Image00015.jpg)'
- en: 'Figure 2.10: Example of search tree with best possible move'
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.10：具有最佳移动的搜索树示例
- en: 'If we move one level higher, it is our opponent''s turn to act. Our opponent
    picks the value that is the least beneficial to us. This is because our opponent''s
    job is to minimize our chances of winning the game. This is the Min part of the
    Minmax algorithm:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再往上一层，就轮到对手行动。对手选择对我们最不利的值。这是因为对手的职责是降低我们赢得游戏的机会。这是MinMax算法中的Min部分：
- en: '![Figure 2.11 Example of search tree demonstrating MinMax algorithm](img/Image00016.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 MinMax算法的搜索树示例](img/Image00016.jpg)'
- en: 'Figure 2.11: Minimizing the chances of winning the game'
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.11：最小化赢得游戏的机会
- en: At the top, we can choose between a move with utility 101 and another move with
    utility 21\. As we are maximizing our value, we should pick 101.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们可以在具有效用值101的移动和另一个具有效用值21的移动之间进行选择。由于我们正在最大化我们的价值，我们应该选择101。
- en: '![Figure 2.12 Search tree maximizing the utility](img/Image00017.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 最大化效用值的搜索树](img/Image00017.jpg)'
- en: 'Figure 2.12: Maximizing the chances of winning the game'
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.12：最大化赢得游戏的机会
- en: 'Let''s see how we can implement this idea:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现这个想法：
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is the Minmax algorithm. We evaluate the leaves from our perspective.
    Then, from the bottom-up, we apply a recursive definition:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是MinMax算法。我们从自己的角度评估叶子节点。然后，从下往上，我们应用递归定义：
- en: Our opponent plays optimally by selecting the worst possible node from our perspective.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手通过从我们的角度选择最坏可能的节点来最优地玩游戏。
- en: We play optimally by selecting the best possible node from our perspective.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过从我们的角度选择最佳可能的节点来最优地玩游戏。
- en: 'We need a few more considerations to understand the application of the Minmax
    algorithm on the Tic-Tac-Toe game:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑更多因素来理解MinMax算法在井字棋游戏中的应用：
- en: '`is_end_state` is a function that determines whether the state should be evaluated
    instead of digging deeper, either because the game has ended, or because the game
    is about to end using forced moves. Using our utility function, it is safe to
    say that as soon as we reach a score of 1,000 or higher, we have effectively won
    the game. Therefore, `is_end_state` can simply check the score of a node and determine
    whether we need to dig deeper.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_end_state`是一个函数，用于确定是否应该评估状态而不是进一步挖掘，要么是因为游戏已经结束，要么是因为游戏即将通过强制移动结束。使用我们的效用函数，我们可以安全地说，一旦我们达到1000分或更高，我们就已经有效地赢得了游戏。因此，`is_end_state`可以简单地检查节点的分数并确定我们是否需要进一步挖掘。'
- en: Although the `successors` function only depends on the state, it is practical
    to pass the information of whose turn it is to make a move. Therefore, don't hesitate
    to add an argument if needed; you don't have to follow the pseudocode.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`successors`函数只依赖于状态，但在实际操作中，传递谁轮到移动的信息是有用的。因此，如果需要，不要犹豫添加一个参数；你不必遵循伪代码。
- en: We want to minimize our efforts in implementing the Minmax algorithm. For this
    reason, we will evaluate existing implementations of the algorithm, and we will
    also simplify the duality of the description of the algorithm in the rest of this
    topic.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望最小化实现MinMax算法的努力。因此，我们将评估现有的算法实现，并且我们还将简化本主题中算法描述的对偶性。
- en: The suggested utility function is quite accurate compared to utility functions
    that we could be using in this algorithm. In general, the deeper we go, the less
    accurate our utility function has to be. For instance, if we could go nine steps
    deep into the Tic-Tac-Toe game, all we would need to do is award 1 point for a
    win, zero for a draw, and -1 point for a loss. Given that, in nine steps, the
    board is complete, and we have all of the necessary information to make the evaluation.
    If we could only look four steps deep, this utility function would be completely
    useless at the start of the game, because we need at least five steps to win the
    game.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们在这个算法中可能使用的效用函数相比，建议的效用函数相当准确。一般来说，我们走得越深，我们的效用函数就越不需要准确。例如，如果我们能在井字棋游戏中深入九步，我们只需要为胜利奖励
    1 分，平局 0 分，失败 -1 分。考虑到在九步中，棋盘是完整的，我们拥有所有必要的信息来进行评估。如果我们只能看四步深，这个效用函数在游戏开始时将完全无用，因为我们至少需要五步才能赢得游戏。
- en: The Minmax algorithm could be optimized further by pruning the tree. Pruning
    is an act where we get rid of branches that don't contribute to the end result.
    By eliminating unnecessary computations, we save precious resources that could
    be used to go deeper into the tree.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过剪枝树，Minmax 算法可以进一步优化。剪枝是一种去除对最终结果没有贡献的分支的行为。通过消除不必要的计算，我们节省了宝贵的资源，这些资源可以用来深入树中。
- en: Optimizing the Minmax Algorithm with Alpha-Beta Pruning
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Alpha-Beta 剪枝优化 Minmax 算法
- en: The last consideration in the previous thought process primed us to explore
    possible optimizations on reducing the search space by focusing our attention
    on nodes that matter.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的思考过程中，最后一个考虑因素促使我们探索通过关注重要的节点来减少搜索空间的可能的优化。
- en: There are a few constellations of nodes in the tree, where we can be sure that
    the evaluation of a subtree does not contribute to the end result. We will find,
    examine, and generalize these constellations to optimize the Minmax algorithm.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在树中存在一些节点组合，我们可以确信子树的评估不会对最终结果产生影响。我们将找到、检查并概括这些组合以优化 Minmax 算法。
- en: 'Let''s examine pruning through the previous example of nodes:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过之前的节点示例来检查剪枝：
- en: '![Figure 2.12 Search tree demonstrating pruning nodes](img/Image00018.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 展示剪枝节点的搜索树](img/Image00018.jpg)'
- en: 'Figure 2.13: Search tree demonstrating pruning nodes'
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.13：展示剪枝节点的搜索树
- en: After computing the nodes with values 101, 23, and 110, we can conclude that
    two levels above, the value 101 will be chosen. Why?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了具有值 101、23 和 110 的节点后，我们可以得出结论，在两步之上，将选择值 101。为什么？
- en: Suppose X <= 110\. Then the maximum of 110 and X will be chosen, which is 110,
    and X will be omitted.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 X <= 110。那么 110 和 X 的最大值将被选择，即 110，X 将被省略。
- en: Suppose X > 110\. Then the maximum of 110 and X is X. One level above, the algorithm
    will choose the lowest value out of the two. The minimum of 101 and X will always
    be 101, because X > 110\. Therefore, X will be omitted a level above.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 X > 110。那么 110 和 X 中的最大值是 X。在更高一级，算法将选择两个中的最小值。因为 X > 110，所以 101 和 X 的最小值始终是
    101。因此，X 将在更高一级被省略。
- en: This is how we prune the tree.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们剪枝树的方法。
- en: On the right-hand side, suppose we computed branches 10 and 21\. Their maximum
    is 21\. The implication of computing these values is that we can omit the computation
    of nodes Y1, Y2, and Y3, and we will know that the value of Y4 is less than or
    equal to 21\. Why?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，假设我们计算了分支 10 和 21。它们的最大值是 21。计算这些值的含义是我们可以省略节点 Y1、Y2 和 Y3 的计算，并且我们将知道 Y4
    的值小于或等于 21。为什么？
- en: The minimum of 21 and Y3 is never greater than 21\. Therefore, Y4 will never
    be greater than 21.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 21 和 Y3 的最小值永远不会大于 21。因此，Y4 永远不会大于 21。
- en: We can now choose between a node with utility 101, and another node with a maximal
    utility of 21\. It is obvious that we have to choose the node with utility 101.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在具有效用 101 的节点和具有最大效用 21 的另一个节点之间进行选择。很明显，我们必须选择具有效用 101 的节点。
- en: '![Figure 2.13 Example of pruning a tree](img/Image00019.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 剪枝树示例](img/Image00019.jpg)'
- en: 'Figure 2.14: Example of pruning a tree'
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.14：剪枝树示例
- en: This is the idea behind alpha-beta pruning. We prune subtrees that we know are
    not going to be needed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 alpha-beta 剪枝背后的想法。我们剪枝那些我们知道不需要的子树。
- en: Let's see how we can implement alpha-beta pruning in the Minmax algorithm.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在 Minmax 算法中实现 alpha-beta 剪枝。
- en: 'First, we will add an alpha and a beta argument to the argument list of Minmax:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向 Minmax 的参数列表中添加一个 alpha 和一个 beta 参数：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the `isMaximizing` branch, we calculate the new alpha score, and break
    out of the loop whenever `beta <= alpha` :'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`isMaximizing`分支，我们计算新的alpha分数，并在`beta <= alpha`时跳出循环：
- en: '[PRE43]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We need to do the dual for the minimizing branch:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对最小化分支做双重处理：
- en: '[PRE44]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are done with the implementation. It is recommended that you mentally execute
    the algorithm on our example tree step-by-step to get a feel for the implementation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了实现。建议你逐步在示例树中执行算法，以获得对实现的感受。
- en: 'One important piece is missing that''s preventing us from doing the execution
    properly: the initial values for alpha and beta. Any number that''s outside the
    possible range of utility values will do. We will use positive and negative infinity
    as initial values to call the Minmax algorithm:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少一个重要部分，阻止我们正确执行：alpha和beta的初始值。任何在效用值可能范围之外的数字都可以。我们将使用正负无穷大作为初始值来调用Minmax算法：
- en: '[PRE46]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: DRYing up the Minmax Algorithm – The NegaMax Algorithm
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minmax算法的DRY化 – NegaMax算法
- en: The Minmax algorithm works great, especially with alpha-beta pruning. The only
    problem is that we have an if and an else branch in the algorithm that essentially
    negate each other.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Minmax算法工作得很好，特别是与alpha-beta剪枝结合使用时。唯一的问题是算法中有两个分支，一个if和一个else，它们本质上相互否定。
- en: As we know, in computer science, there is DRY code and WET code. DRY stands
    for Don't Repeat Yourself. Wet stands for We Enjoy Typing. When we write the same
    code twice, we double our chance of making a mistake while writing it. We also
    double our chances of each maintenance effort being executed in the future. Hence,
    it's better to reuse our code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，在计算机科学中，有DRY代码和WET代码。DRY代表不要重复自己。WET代表我们喜欢打字。当我们写相同的代码两次时，我们增加了一半在编写时犯错的几率。我们也增加了未来每次维护工作被执行的几率。因此，重用我们的代码会更好。
- en: When implementing the Minmax algorithm, we always compute the utility of a node
    from the perspective of the AI player. This is why we have to have a utility-maximizing
    branch and a utility-minimizing branch in the implementations that are dual in
    nature. As we prefer clean code that describes the problem only once, we could
    get rid of this duality by changing the point of view of the evaluation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现Minmax算法时，我们总是从AI玩家的视角计算节点的效用。这就是为什么在本质上是双重的实现中，我们必须有一个效用最大化分支和一个效用最小化分支。由于我们更喜欢只描述问题的干净代码，我们可以通过改变评估的视角来消除这种双重性。
- en: Whenever the AI player's turn comes, nothing changes in the algorithm.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当AI玩家的回合到来时，算法中没有任何变化。
- en: Whenever the opponent's turn comes, we negate the perspective. Minimizing the
    AI player's utility is equivalent to maximizing the opponent's utility.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 每当对手的回合到来时，我们否定视角。最小化AI玩家的效用等同于最大化对手的效用。
- en: 'This simplifies the Minmax algorithm:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了Minmax算法：
- en: '[PRE47]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There are necessary conditions for using the Negamax algorithm: the evaluation
    of the board state has to be symmetric. If a game state is worth +20 from the
    first player''s perspective, it is worth -20 from the second player''s perspective.
    Therefore, we often normalize the scores around zero.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Negamax算法有一些必要条件：棋盘状态的评估必须是对称的。如果一个游戏状态从第一个玩家的视角来看是+20，那么从第二个玩家的视角来看就是-20。因此，我们通常将分数标准化在零周围。
- en: Using the EasyAI Library
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用EasyAI库
- en: We have seen the `simpleai` library that helped us execute searches on pathfinding
    problems. We will now use the EasyAI library, which can easily handle AI search
    on two player games, reducing the implementation of the Tic-Tac-Toe problem to
    writing a few functions on scoring the utility of a board and determining when
    the game ends.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`simpleai`库，它帮助我们执行路径查找问题的搜索。现在我们将使用EasyAI库，它可以轻松处理两人游戏的AI搜索，将井字棋问题的实现简化为编写几个评估棋盘效用和确定游戏何时结束的函数。
- en: You can read the documentation of the library on GitHub at [https://github.com/Zulko/easyAI](https://github.com/Zulko/easyAI)
    .
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上阅读库的文档：[https://github.com/Zulko/easyAI](https://github.com/Zulko/easyAI)。
- en: 'To install the EasyAI library, run the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装EasyAI库，请运行以下命令：
- en: '[PRE48]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: As always, if you are using Anaconda, you must execute this command in the Anaconda
    prompt, and not in the Jupyter QtConsole.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，如果你使用Anaconda，你必须在这个Anaconda提示符中执行此命令，而不是在Jupyter QtConsole中。
- en: 'Once EasyAI is available, it makes sense to follow the structure of the documentation
    to describe the Tic-Tac-Toe problem.This implementation was taken from [https://zulko.github.io/easyAI/examples/games.html](https://zulko.github.io/easyAI/examples/games.html)
    , where the Tic-Tac-Toe problem is described in a compact and elegant way:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦EasyAI可用，按照文档的结构描述井字棋问题是有意义的。这个实现是从[https://zulko.github.io/easyAI/examples/games.html](https://zulko.github.io/easyAI/examples/games.html)中取的，在那里井字棋问题被简洁而优雅地描述：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this implementation, the computer player never loses thanks to the Negamax
    algorithm exploring the search criterion in a depth of 6.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，电脑玩家永远不会输，因为Negamax算法在深度6中探索搜索标准。
- en: Notice the simplicity of the scoring function. Wins or losses can guide the
    AI player to reach the goal of never losing a game.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意评分函数的简单性。胜利或失败可以引导AI玩家达到永不输掉游戏的目标。
- en: 'Activity 4: Connect Four'
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动4：四子棋
- en: In this section, we will practice using the **EasyAI** library and develop a
    heuristic. We will be using the game Connect 4 for this. The game board is seven
    cells wide and seven cells high. When you make a move, you can only select the
    column in which you drop your token. Then, gravity pulls the token down to the
    lowest possible empty cell. Your objective is to connect four of your own tokens
    horizontally, vertically, or diagonally, before your opponent does, or you run
    out of empty spaces. The rules of the game can be found at [https://en.wikipedia.org/wiki/Connect_Four](https://en.wikipedia.org/wiki/Connect_Four)
    .
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将练习使用**EasyAI**库并开发一种启发式方法。我们将使用四子棋来进行这个练习。游戏棋盘宽度为7个单元格，高度为7个单元格。当你移动时，你只能选择放置你的标记的列。然后，重力将标记拉到最低的空单元格。你的目标是先于对手水平、垂直或对角线连接四个自己的标记，或者你用完所有空位。游戏规则可以在[https://en.wikipedia.org/wiki/Connect_Four](https://en.wikipedia.org/wiki/Connect_Four)找到。
- en: 'We can leave a few functions from the definition intact. We have to implement
    the following methods:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保留一些函数的定义不变。我们必须实现以下方法：
- en: '`__init__`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`'
- en: '`possible_moves`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`possible_moves`'
- en: '`make_move`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_move`'
- en: '`unmake_move (optional)`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unmake_move (可选)`'
- en: '`lose`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lose`'
- en: '`show`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`'
- en: We will reuse the basic scoring function from Tic-Tac-Toe. Once you test out
    the game, you will see that the game is not unbeatable, but plays surprisingly
    well, even though we are only using basic heuristics.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重用井字棋的基本评分函数。一旦你测试了游戏，你就会看到游戏并非不可战胜，尽管我们只使用了基本的启发式方法，但它的表现却出人意料地好。
- en: Then, let's write the `init` method. We will define the board as a one-dimensional
    list, like the Tic-Tac-Toe example. We could use a two-dimensional list too, but
    modeling will not get much easier or harder. We will generate all of the possible
    winning combinations in the game and save them for future use.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们编写`init`方法。我们将定义棋盘为一个一维列表，就像井字棋的例子。我们也可以使用二维列表，但建模并不会变得更容易或更难。我们将生成游戏中所有可能的获胜组合，并保存它们以供将来使用。
- en: Let's handle the moves. The possible moves function is a simple enumeration.
    Notice that we are using column indices from 1 to 7 in the move names, because
    it is more convenient to start column indexing with 1 in the human player interface
    than with zero. For each column, we check whether there is an unoccupied field.
    If there is one, we will make the column a possible move.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们处理移动。可能的移动函数是一个简单的枚举。注意，我们在移动名称中使用从1到7的列索引，因为在人类玩家界面中从1开始列索引比从0开始更方便。对于每一列，我们检查是否有未占用的区域。如果有，我们将该列设为可能的移动。
- en: 'Making a move is similar to the possible moves function. We check the column
    of the move and find the first empty cell, starting from the bottom. Once we find
    it, we occupy it. You can also read the implementation of the dual of the `make_move`
    function: `unmake_move` . In the `unmake_move` function, we check the column from
    top to bottom, and we remove the move at the first non-empty cell. Notice that
    we rely on the internal representation of `easyAi` so that it does not undo moves
    that it has not made. If we didn''t, this function would remove one of the other
    player''s tokens without checking whose token was removed.'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动与可能的移动函数类似。我们检查移动的列，并从底部开始找到第一个空单元格。一旦找到，我们就占据它。你还可以阅读`make_move`函数的对应函数`unmake_move`的实现。在`unmake_move`函数中，我们从顶部到底部检查列，并在第一个非空单元格处移除移动。注意，我们依赖于`easyAi`的内部表示，这样它就不会撤销它没有做出的移动。如果我们不这样做，这个函数就会在没有检查移除的是哪个玩家的标记的情况下移除另一个玩家的标记。
- en: As we already have the tuples that we have to check, we can mostly reuse the
    lose function from the Tic-Tac-Toe example.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经有了必须检查的元组，我们可以主要重用井字棋示例中的lose函数。
- en: Our last task is to implement the show method that prints the board. We will
    reuse the Tic-Tac-Toe implementation and just change the variables.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后一个任务是实现一个打印棋盘的显示方法。我们将重用井字棋的实现，只需更改变量。
- en: Now that all of the functions are complete, you can try out the example. Feel
    free to play a round or two against the opponent. You can see that the opponent
    is not perfect, but it plays reasonably well. If you have a strong computer, you
    can increase the parameter of the Negamax algorithm. I encourage you to come up
    with a better heuristic.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有函数都已完成，你可以尝试运行示例。你可以随意与对手玩几轮。你可以看到对手并不完美，但它的表现相当合理。如果你有一台强大的计算机，你可以增加Negamax算法的参数。我鼓励你提出一个更好的启发式函数。
- en: Note
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 265.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第265页找到。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to apply search techniques to play games.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将搜索技术应用于游戏。
- en: First, we created a static approach that played the Tic-Tac-Toe game based on
    predefined rules without looking ahead. Then, we quantified these rules into a
    number we called heuristics. In the next topic, we learned how to use heuristics
    in the A* search algorithm to find an optimal solution to a problem.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个静态方法，该方法基于预定义的规则玩井字棋游戏，而不进行前瞻。然后，我们将这些规则量化为一个我们称之为启发式函数的数字。在下一个主题中，我们学习了如何在A*搜索算法中使用启发式函数来找到一个问题的最优解。
- en: Finally, we got to know the Minmax and the NegaMax algorithms so that the AI
    could win two-player games.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了Minmax和NegaMax算法，这样人工智能就能赢得两人游戏。
- en: 'Now that you know the fundamentals of writing game AI, it is time to learn
    about a different field within artificial intelligence: machine learning. In the
    next chapter, you will learn about regression.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了编写游戏人工智能的基础知识，那么是时候学习人工智能领域内的另一个不同领域：机器学习了。在下一章中，你将学习关于回归的内容。
