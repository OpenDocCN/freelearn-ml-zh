- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Controlling Growth Modes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制增长模式
- en: 'So far in this book, every forecast we’ve built has followed only one growth
    mode: **linear**. The trend sometimes had some small bends where the slope either
    increased or decreased, but fundamentally, the trend consisted of linear segments.
    However, Prophet features two additional growth modes: **logistic** and **flat**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们构建的每一个预测都只遵循一种增长模式：**线性**。趋势有时会有一些小的弯曲，斜率要么增加要么减少，但本质上，趋势由线性段组成。然而，Prophet有另外两种增长模式：**逻辑**和**平坦**。
- en: 'Modeling your time series with a growth mode that is not optimal can often
    fit the actual data very well. But, as you’ll see in this chapter, even if the
    fit is realistic, the future forecast can become wildly unrealistic. Sometimes,
    the shape of the data will inform which growth mode to choose, and sometimes you’ll
    need domain knowledge and a bit of common sense. This chapter will help guide
    you to an appropriate selection. Furthermore, you will learn when and how to apply
    these different growth modes. Specifically, this chapter will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非最佳增长模式对时间序列进行建模通常可以很好地拟合实际数据。但，正如你将在本章中看到的，即使拟合是现实的，未来的预测也可能变得非常不现实。有时，数据的形状会告诉我们选择哪种增长模式，有时你需要领域知识和一点常识。本章将帮助你做出适当的选择。此外，你将学习何时以及如何应用这些不同的增长模式。具体来说，本章将涵盖以下内容：
- en: Applying linear growth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用线性增长
- en: Understanding the logistic function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解逻辑函数
- en: Saturating forecasts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足预测
- en: Applying flat growth
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用平坦增长
- en: Creating a custom trend
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义趋势
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The data files and code for the examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中示例的数据文件和代码可以在[https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition)找到。
- en: Applying linear growth
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用线性增长
- en: All the models we built in the previous chapters had the default growth mode,
    linear. This means that the trend consists of a straight, sloped line, or potentially,
    a few straight, sloped lines connected at changepoints – a case we will explore
    in [*Chapter 8*](B19630_08.xhtml#_idTextAnchor537), *Influencing Trend Changepoints*.
    For now, though, let’s load up our Divvy data again and focus on the growth.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中构建的所有模型都默认使用线性增长模式。这意味着趋势由一条直线或几条直线组成，这些直线在变化点处相连——我们将在[*第八章*](B19630_08.xhtml#_idTextAnchor537)，*影响趋势变化点*中探讨这种情况。然而，现在，让我们再次加载我们的Divvy数据并专注于增长。
- en: 'We’re going to import `pandas`, `matplotlib`, and `Prophet` again, but this
    time, we’ll also import a new function from Prophet’s `plot` package, `add_changepoints_to_plot`,
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次导入`pandas`、`matplotlib`和`Prophet`，但这次，我们还将从Prophet的`plot`包中导入一个新函数，`add_changepoints_to_plot`，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This new function will allow us to easily plot our trend line directly on our
    forecast plot.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新功能将使我们能够轻松地将我们的趋势线直接绘制在我们的预测图中。
- en: 'As we’ve done previously, let’s open the Divvy data and load it into our training
    DataFrame:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，让我们打开Divvy数据并将其加载到我们的训练DataFrame中：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We learned already in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254), *Working
    with Seasonality*, that this dataset should be modeled with multiplicative seasonality
    and that the yearly seasonality should be constrained a bit by setting the Fourier
    order to `4`. We’ll set these values when instantiating our model. We’ll also
    explicitly set `growth=''linear''`. This is the default, and previously, we just
    implicitly accepted it, but for clarity’s sake, we’ll include it here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第五章*](B19630_05.xhtml#_idTextAnchor254)，*处理季节性*中了解到，这个数据集应该用乘法季节性来建模，并且通过将傅里叶阶数设置为`4`来稍微约束年度季节性。我们将在实例化我们的模型时设置这些值。我们还将明确设置`growth='linear'`。这是默认值，之前我们只是隐式地接受它，但为了清晰起见，我们在这里包括它：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just as we did when we modeled the daily Divvy data in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254),
    *Working with Seasonality*, next, we will fit the model, build a `future` DataFrame
    with one year to forecast, predict future values, and plot the forecast. This
    time, however, we will use the `add_changepoints_to_plot` function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第五章*](B19630_05.xhtml#_idTextAnchor254)，*处理季节性*中建模每日Divvy数据时所做的，接下来，我们将拟合模型，构建一个包含一年预测的`future`
    DataFrame，预测未来值，并绘制预测图。然而，这次我们将使用`add_changepoints_to_plot`函数。
- en: 'The function requires that we specify which plot axes to use, identify the
    model we created, and identify the forecast DataFrame output from the `predict`
    method. For the axes, we use the Matplotlib `gca` method, to *get current axes*,
    and call it on the figure created when plotting the forecast. You can see the
    syntax in the following code. We are only using the plot changepoints function
    here to plot the trend so we will remove the changepoint markers, for now, using
    `cp_linestyle=''''`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数要求我们指定要使用哪个绘图坐标轴，识别我们创建的模型，以及识别从`predict`方法输出的预测DataFrame。对于坐标轴，我们使用Matplotlib的`gca`方法，即获取当前坐标轴，并在绘制预测时创建的图上调用它。你可以在以下代码中看到语法。我们在这里只使用绘图变化点函数来绘制趋势，所以我们现在将使用`cp_linestyle=''`移除变化点标记：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As output, you should now see a similar forecast to that in *Figure 5**.8*,
    but this time, the trend line will be overlaid upon the plot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，你现在应该看到与*图5**.8*中类似的预测，但这次，趋势线将叠加在图上：
- en: '![Figure 7.1 – Divvy forecast with the trend](img/Fig_7.1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 带趋势的Divvy预测](img/Fig_7.1.jpg)'
- en: Figure 7.1 – Divvy forecast with the trend
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 带趋势的Divvy预测
- en: Remember, Prophet is an additive regression model. So, the trend is the most
    fundamental building block of our forecast. We add detail and variation to it
    by adding seasonalities, holidays, and additional regressors. The trend you see
    in the preceding figure (the solid line cutting through the midpoints of each
    sine period) is the Divvy plot with seasonality removed (we never added holidays
    in this example).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Prophet是一个加性回归模型。因此，趋势是我们预测的最基本构建块。我们通过添加季节性、假日和额外的回归因子来增加其细节和变化。前面图中（穿过每个正弦周期中点的实线）的趋势是去除季节性的Divvy图（在这个例子中我们从未添加过假日）。
- en: As you can see, the trend is a straight segment from **2014** until late **2015**,
    then a slight bend and another straight segment, with a shallower slope, from
    **2016** onward. Despite that bend, it is fundamentally linear.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，趋势是从**2014**年到晚**2015**年的直线段，然后是轻微的弯曲和另一个斜率较浅的直线段，从**2016**年开始。尽管有这个弯曲，它本质上还是线性的。
- en: Let’s now look at the next growth mode, logistic. To understand this growth
    mode, you first need to understand the logistic function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看下一个增长模式，逻辑增长。要理解这种增长模式，你首先需要了解逻辑函数。
- en: Understanding the logistic function
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解逻辑函数
- en: 'The **logistic function** generates an S-shaped curve; the equation takes the
    following form:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑函数**生成一个S形曲线；方程具有以下形式：'
- en: '![](img/B19630_07_F01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![img/B19630_07_F01.jpg](img/B19630_07_F01.jpg)'
- en: Here, ![](img/B19630_07_F02.png) is the maximum value of the curve, ![](img/B19630_07_F03.png)
    is the logistic growth rate, or steepness, of the curve, and ![](img/B19630_07_F04.png)
    is the *x* value of the curve’s midpoint.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![img/B19630_07_F02.png](img/B19630_07_F02.png)是曲线的最大值，![img/B19630_07_F03.png](img/B19630_07_F03.png)是曲线的逻辑增长率或陡度，而![img/B19630_07_F04.png](img/B19630_07_F04.png)是曲线中点的*x*值。
- en: 'Taking ![](img/B19630_07_F05.png), ![](img/B19630_07_F06.png), and ![](img/B19630_07_F07.png),
    the logistic function produces the **standard logistic function**, ![](img/B19630_07_F08.png),
    as seen in the following plot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以![img/B19630_07_F05.png](img/B19630_07_F05.png)，![img/B19630_07_F06.png](img/B19630_07_F06.png)，和![img/B19630_07_F07.png](img/B19630_07_F07.png)为例，逻辑函数产生了**标准逻辑函数**![img/B19630_07_F08.png](img/B19630_07_F08.png)，如下面的图中所示：
- en: "![Figure 7.\uFEFF2 – The standard logistic function](img/Fig_7.2.jpg)"
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 标准逻辑函数](img/Fig_7.2.jpg)'
- en: Figure 7.2 – The standard logistic function
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 标准逻辑函数
- en: If you have studied logistic regression or neural networks, you may recognize
    this as the **sigmoid function**. Any input value for *x*, from -∞ to ∞, will
    be squished into an output value, *y*, between 0 and 1\. This equation is what
    allows a logistic regression model to accept any input value and output a probability
    between 0 and 1.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究过逻辑回归或神经网络，你可能认出这实际上是**S形函数**。任何从-∞到∞的输入值*x*，都会被压缩到0到1之间的输出值*y*。这个方程使得逻辑回归模型能够接受任何输入值并输出0到1之间的概率。
- en: The equation was developed by Pierre François Verhulst, a Belgian mathematician,
    in a series of three papers published between 1838 and 1847\. Verhulst was working
    to model the population growth of Belgium.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程由比利时数学家皮埃尔·弗朗索瓦·弗赫尔斯特（Pierre François Verhulst）在1838年至1847年间发表的三篇论文中开发。弗赫尔斯特正在努力模拟比利时的种群增长。
- en: Population growth approximately follows an initial exponential growth rate,
    then a linear (also known as arithmetic) growth rate, until the population hits
    a saturation point, where growth slows to zero. This is the shape you see in the
    preceding plot, starting at the curve’s midpoint and moving right. Verhulst invented
    the term *logistic* to be analogous to *arithmetic* and *geometric* but derived
    from *logarithmic*. Don’t get the word confused with *logistics*, which refers
    to the handling of details. They have completely different origins.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 种群增长大致遵循一个初始的指数增长速率，然后是一个线性（也称为算术）增长速率，直到种群达到饱和点，此时增长速度减慢至零。这就是你在前面的图表中看到的形状，从曲线的中点开始向右移动。Verhulst发明了“逻辑”这个词，与“算术”和“几何”类似，但源自“对数”。不要将这个词与“后勤”混淆，它指的是处理细节。它们有完全不同的起源。
- en: Prophet’s logistic growth mode follows this general curve. The curve’s **saturation**
    levels are the upper and lower bounds, which the curve asymptotically approaches.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 预言者的逻辑增长模式遵循这条一般曲线。曲线的**饱和**水平是曲线渐近接近的上限和下限。
- en: Besides applications in statistics and machine learning where the logistic curve
    is used in logistic regression and neural networks, the logistic function is also
    often used to model population growth, either of humans (as in Verhulst’s Belgium)
    or of animals, as we will do in this chapter. It is often used in medicine to
    model the growth of tumors, bacterial or viral loads in an infected person, or
    infection rates of people during a pandemic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在统计学和机器学习中的应用，其中逻辑曲线用于逻辑回归和神经网络，逻辑函数也常用于模拟人口增长，无论是人类（如Verhulst的比利时）还是动物，正如我们在本章中所做的那样。它常用于医学中模拟肿瘤的生长、感染者的细菌或病毒载量，或在流行病期间人们的感染率。
- en: In economics and sociology, the curve is used to describe the adoption rate
    of new innovations. Linguists use it to model language changes. It can even be
    used to model the spread of a rumor or new idea throughout a population.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在经济学和社会学中，该曲线用于描述新创新的采用率。语言学家用它来模拟语言变化。它甚至可以用来模拟谣言或新观点在整个群体中的传播。
- en: Let’s see how to apply this in Prophet.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Prophet中应用这一点。
- en: Saturating forecasts
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 满足预测
- en: In the early 1800s, westward expansion in the United States brought many settlers
    and their livestock into contact with the native wolf population. These wolves
    began to prey on domestic stock, which resulted in the settlers hunting and killing
    the wolves in order to protect their own animals. The gray wolf was still present
    on the land (which became Yellowstone National Park when it was established in
    1872), but over the next few decades, they were hunted nearly to extinction in
    the region and throughout the lower 48 states.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在19世纪初，美国向西扩张使许多定居者和他们的牲畜与本土狼群接触。这些狼开始捕食家畜，这导致定居者为了保护自己的动物而猎杀和杀死狼。灰狼仍然存在于这片土地上（当它在1872年建立时成为黄石国家公园），但在接下来的几十年里，它们在该地区以及下48个州几乎被猎杀至灭绝。
- en: In the 1960s, the public began to understand the idea of ecosystems and the
    interconnectedness of species, and in 1975, the decision to restore wolf populations
    to Yellowstone was taken, with 31 gray wolves finally being relocated to the park
    from Canada in 1995\. This provided an almost perfect experiment of natural population
    growth inside the park.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代，公众开始理解生态系统和物种之间相互联系的概念，1975年，决定将狼群恢复到黄石公园，1995年最终有31只灰狼从加拿大迁移到公园，这为公园内自然种群增长提供了一个几乎完美的实验。
- en: We’ll look at this population in the next few examples. However, we’ll be using
    simulated data because the true data is spotty throughout the historical record.
    As wolves tend to avoid human contact, counting their number can never be exact
    and so accurate data is lacking. Furthermore, there are numerous compounding factors
    (such as weather, for example) that we will not model (and are generally unpredictable,
    as well).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几个例子中查看这个种群。然而，我们将使用模拟数据，因为真实数据在历史记录中分布不均。由于狼倾向于避免与人类接触，它们的数量计数永远无法精确，因此缺乏准确的数据。此外，还有许多复合因素（例如天气）我们不会建模（而且通常是不可预测的）。
- en: 'To understand these compounding factors, consider the example of Isle Royale,
    an island on Michigan’s Lake Superior that has had a moose and wolf population
    under continuous study since 1959\. This is, in fact, the longest continuous study
    of any predator-prey population system in the world. As can be seen in the following
    plot, it has not been a predictable system, to say the least:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些复合因素，考虑一下密歇根湖苏必利尔湖上的伊莎贝拉皇家岛上的例子，自1959年以来，该岛上的驼鹿和狼种群一直处于持续研究之中。这实际上是世界上任何捕食者-猎物种群系统的最长连续研究。如下面的图表所示，这至少不是一个可预测的系统：
- en: "![Figure 7.3\uFEFF – Population numbers of wolves and moose on Isle Royale](img/Fig_7.3.jpg)"
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 伊莎贝拉皇家岛上的狼和驼鹿的种群数量](img/Fig_7.3.jpg)'
- en: Figure 7.3 – Population numbers of wolves and moose on Isle Royale
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 伊莎贝拉皇家岛上的狼和驼鹿的种群数量
- en: In the 1960s and 1970s, rising moose populations provided food, which allowed
    wolf populations to double. But in 1980, humans inadvertently introduced canine-parvovirus,
    a disease that caused the wolf population to collapse. The moose population in
    turn rose again with the decline of its only predator, only to collapse itself
    in 1996 with the double stresses of the most severe winter on record and an unpredictable
    outbreak of moose ticks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代和70年代，不断增长的驼鹿种群提供了食物，这允许狼群数量翻倍。但在1980年，人类意外引入了犬细小病毒，这种疾病导致狼群数量崩溃。随着其唯一捕食者的数量下降，驼鹿种群再次增加，但于1996年在创纪录的最严重冬季和不可预测的驼鹿蜱虫爆发双重压力下崩溃。
- en: Throughout the 1990s, the wolf population was too low for healthy breeding,
    leading to intense levels of inbreeding, which held their population down, only
    rebounding when a single wolf reached the island by crossing winter ice from Canada
    in the late 1990s. Following this, the wolf population increased throughout the
    early twenty-first century, despite declining moose numbers. All this is to say
    that small, isolated populations represent a very dynamic system that cannot be
    accurately predicted when not in isolation from natural external events.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代，狼群数量过低，无法进行健康繁殖，导致近亲繁殖水平极高，这抑制了它们的种群数量，直到1990年代末一只狼通过穿越来自加拿大的冬季冰层到达岛屿时，种群数量才有所回升。此后，尽管驼鹿数量下降，狼群数量在整个21世纪初仍然在增加。所有这些都说明，小型、孤立种群代表一个非常动态的系统，当它们不与自然外部事件隔离时，无法准确预测。
- en: Increasing logistic growth
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加逻辑增长
- en: To synthesize a somewhat realistic population of wolves in Yellowstone, let’s
    suppose that 100 wolves were introduced in 1995\. Park ecologists surveyed the
    area and determined that the land could support a total population of 500 wolves.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在黄石公园合成一个相对现实的狼群种群，让我们假设1995年引入了100只狼。公园生态学家对该地区进行了调查，并确定这片土地可以支持总共500只狼的种群。
- en: 'In the linear growth example, we imported `pandas`, `matplotlib`, `Prophet`,
    and the `add_changepoints_to_plot` function, so to continue, we only need to import
    the `numpy` and `random` libraries in order to create our dataset. Be sure to
    set the random seed so that every time we run the code, we get the same pseudo-random
    results:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性增长示例中，我们导入了`pandas`、`matplotlib`、`Prophet`和`add_changepoints_to_plot`函数，因此为了继续，我们只需要导入`numpy`和`random`库来创建我们的数据集。务必设置随机种子，以确保每次运行代码时我们都得到相同的伪随机结果：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will simulate the wolf population by first creating a series of monthly
    dates, from 1995 until 2004\. At every date, we’ll calculate the output from our
    logistic equation. Then, we’ll add some sinusoidal variation to account for yearly
    seasonality, and finally, some random noise. Then, we just need to scale our curve
    up:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过首先创建一系列从1995年到2004年的月度日期来模拟狼群数量。在每一个日期，我们将从我们的逻辑方程中计算出输出。然后，我们将添加一些正弦变化来考虑年度季节性，最后，一些随机噪声。然后，我们只需要将我们的曲线放大：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s plot the curve to make sure everything worked out as expected:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制曲线以确保一切如预期进行：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If everything went correctly, you should see this plot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到这个图表：
- en: "![Figure 7\uFEFF.4 – Simulated wolf population in Yellowstone](img/Fig_7.4.jpg)"
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 黄石公园模拟的狼群数量](img/Fig_7.4.jpg)'
- en: Figure 7.4 – Simulated wolf population in Yellowstone
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 黄石公园模拟的狼群数量
- en: Let’s begin our analysis of this data by fitting a Prophet model with linear
    growth. This example will demonstrate what can go wrong when choosing an inappropriate
    growth mode.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从拟合一个具有线性增长的Prophet模型开始分析这些数据。这个例子将演示在选择不适当增长模式时可能会出现什么问题。
- en: Modeling with linear growth
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用线性增长建模
- en: 'As we did earlier, we start by organizing our data into a DataFrame for Prophet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们首先将我们的数据组织到一个DataFrame中，用于Prophet：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In addition to linear growth, let’s set the Fourier order of the yearly seasonality
    to `3` and the seasonality mode to `multiplicative`. Then, we fit our DataFrame
    and create the `future` DataFrame. We simulated this data at a monthly frequency,
    so we’ll forecast out `10` years and set `freq=''M''`. After predicting on the
    future, we’ll plot the forecast and use the `add_changepoints_to_plot` function
    to overlay the trend:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了线性增长外，让我们将年季节性的傅里叶阶数设置为`3`，并将季节性模式设置为`乘法`。然后，我们拟合我们的DataFrame并创建`future` DataFrame。我们以月度频率模拟了这些数据，所以我们将预测`10`年并将`freq='M'`。在预测未来之后，我们将绘制预测图，并使用`add_changepoints_to_plot`函数来叠加趋势：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Immediately, you should see what will go wrong with using a linear trend in
    a situation where the forecast will naturally saturate at some level. The predicted
    values will keep rising toward infinity with longer and longer forecast time periods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，你应该看到在预测将自然饱和在某个水平的情况下使用线性趋势会出现什么问题。预测值将随着预测时间周期的延长而不断上升，趋向于无穷大：
- en: "![Figu\uFEFFre 7.5 – Wolf population forecast with linear growth](img/Fig_7.5.jpg)"
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 使用线性增长的狼群数量预测](img/Fig_7.5.jpg)'
- en: Figure 7.5 – Wolf population forecast with linear growth
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 使用线性增长的狼群数量预测
- en: Obviously, this cannot be realistic. There is only so much food for the wolves
    to eat; at a certain point, there won’t be enough food, and the wolves will begin
    to starve. Let’s now model this with logistic growth and see what happens.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是不现实的。狼能吃的食物是有限的；在某个点上，食物将不足，狼将开始饿死。现在让我们用逻辑增长来模拟这种情况，看看会发生什么。
- en: Modeling with logistic growth
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用逻辑增长建模
- en: With `cap` and also mimic it in our `future` DataFrame.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cap`并在我们的`future` DataFrame中模拟它。
- en: 'In general, determining a cap may pose some difficulties. If your curve is
    near the saturation level already, you can see better what value it is approaching
    and choose it. If not, however, then a little domain knowledge will really be
    your best solution. Before you can model logistic growth rates, you must have
    some idea of where the saturation level will eventually be. Usually, this cap
    is set using data or with special expertise about market size. For our example,
    we’ll set the cap to `500`, as that was the value estimated by the ecologists:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，确定上限可能会带来一些困难。如果你的曲线已经接近饱和水平，你可以更好地看到它接近的值并选择它。然而，如果没有，那么一点领域知识将真正是你的最佳解决方案。在你可以建模逻辑增长率之前，你必须对饱和水平最终在哪里有一些想法。通常，这个上限是使用数据或对市场规模有特殊专业知识来设置的。在我们的例子中，我们将上限设置为`500`，因为这是生态学家估计的值：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we continue just as we did in the previous example, but this time, let’s
    set the growth mode to `logistic`, before fitting and creating the `future` DataFrame:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续像上一个例子中那样做，但这次，在拟合和创建`future` DataFrame之前，让我们将增长模式设置为`logistic`：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to add the cap to our `future` DataFrame as well:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将上限添加到我们的`future` DataFrame中：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, when we predict and plot the forecast, you’ll see quite a differently
    shaped curve:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们预测并绘制预测图时，你会看到一个非常不同形状的曲线：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, Prophet displays the cap (and floor if present) as horizontal dashed
    lines in your plot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Prophet将上限（如果有，则还包括下限）显示为你的图表中的水平虚线：
- en: '![Figure 7.6 – Wolf population forecast with logistic growth](img/Fig_7.6.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 使用逻辑增长的狼群数量预测](img/Fig_7.6.jpg)'
- en: Figure 7.6 – Wolf population forecast with logistic growth
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 使用逻辑增长的狼群数量预测
- en: With logistic growth, the wolf population is allowed to grow at roughly the
    same rate for several years. The growth rate slows as it approaches its saturation
    point, the greatest population that the natural resources available can support.
    After this point, the growth rate stays flat with just a bit of seasonal variation
    as old wolves die in the winter and spring pups arrive.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑增长的情况下，狼群的数量被允许以大致相同的速率增长数年。当它接近饱和点，即自然资源能够支持的最大人口时，增长率会放缓。在此之后，增长率保持平稳，仅略有季节性变化，因为老狼在冬春季节死亡，而春季幼狼出生。
- en: Non-constant cap
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非常数上限
- en: It is important to note that the cap does not necessarily need to be constant.
    If you are forecasting sales, for example, your saturation limit will be the market
    size. But this market size may be growing as various factors cause more consumers
    to consider purchasing your product. Let’s look at a quick example of how to model
    this. We assumed that the wolf population in Yellowstone was constrained by the
    size of the park. Let’s now create a hypothetical situation where the park size
    is gradually increased starting in 2007, creating conditions that allow for two
    additional wolves per month.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，上限值不一定需要是恒定的。例如，如果你在预测销售额，你的饱和极限将是市场大小。但这个市场大小可能会随着各种因素导致更多消费者考虑购买你的产品而增长。让我们快速看一下如何建模这个例子。我们假设黄石公园的狼群数量受到公园大小的限制。现在，让我们创建一个假设情况，从2007年开始，公园大小逐渐增加，创造条件允许每月增加两只狼。
- en: 'Let’s create a function to set the cap. For dates prior to 2007, we will keep
    the park’s saturation limit of `500`. For all dates starting in 2007, though,
    we will increase the cap by two per month:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数来设置上限。对于2007年之前的日期，我们将保持公园的饱和极限为`500`。然而，对于所有从2007年开始的日期，我们将每月增加上限两只：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s set the cap for our training DataFrame, `df`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的训练DataFrame，`df`，设置上限：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The cap should remain `500` throughout, as our training data ends in 2004\.
    Now, let’s create our model the same as before, but set our `future` DataFrame
    using the `set_cap` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上限应该在整个过程中保持为`500`，因为我们的训练数据在2004年结束。现在，让我们像以前一样创建我们的模型，但使用`set_cap`函数设置我们的`future`
    DataFrame：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you can see that the wolf population is asymptotically approaching our
    increasing cap:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到狼群数量正在趋向于我们不断增加的上限：
- en: '![Figure 7.7 – Wolf population forecast with non-constant cap](img/Fig_7.7.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 非恒定上限下的狼群数量预测](img/Fig_7.7.jpg)'
- en: Figure 7.7 – Wolf population forecast with non-constant cap
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 非恒定上限下的狼群数量预测
- en: The cap is simply a value set for each row in the DataFrame; for every date,
    you can set whichever value makes sense. The cap may be constant, as in our first
    example, it may vary linearly, as we have just done here, or it may follow any
    arbitrary curve of your choosing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上限是针对DataFrame中的每一行设置的值；对于每个日期，你可以设置任何有意义的值。上限可能是恒定的，就像我们的第一个例子一样，它可能线性变化，就像我们在这里所做的那样，或者它可能遵循你选择的任何任意曲线。
- en: Now, let’s look at the reverse situation, a hypothetical situation where the
    wolf population is sadly declining and approaching extinction.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看相反的情况，一个假设的情况，狼群数量正在悲哀地下降，并接近灭绝。
- en: Decreasing logistic growth
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下降的指数增长
- en: 'The only difference in this example is that we must also state a `floor` value
    in addition to a `cap` value. Let’s build another pseudo-random dataset but with
    negative growth:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，唯一的区别是我们必须除了`cap`值外，还要声明一个`floor`值。让我们构建另一个伪随机数据集，但具有负增长：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The growth curve should look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 增长曲线应该看起来像这样：
- en: '![Figure 7.8 – Simulated declining wolf population in Yellowstone](img/Fig_7.8.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 黄石公园模拟的狼群数量下降](img/Fig_7.8.jpg)'
- en: Figure 7.8 – Simulated declining wolf population in Yellowstone
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 黄石公园模拟的狼群数量下降
- en: 'For our forecast in this case, we’ll cut off the data at `2006` and attempt
    to predict when there will be no more wolves in the population. When creating
    our DataFrame, we specify both a `cap` value, as we did previously, and a `floor`
    value:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例的预测中，我们将数据截断到`2006`年，并尝试预测狼群数量何时会降至零。在创建我们的DataFrame时，我们指定了与之前相同的`cap`值，以及一个`floor`值：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We’ll complete the model all in one step. Everything is the same as the previous
    examples, except this time, we also set `floor` in the `future` DataFrame:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一步完成模型。一切与之前的例子相同，只是这次我们在`future` DataFrame中也设置了`floor`：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It should come as no surprise that Prophet handles this case with ease:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，Prophet可以轻松处理这种情况：
- en: '![Figure 7.9 – Wolf population forecast with decreasing logistic growth](img/Fig_7.9.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 下降的指数增长下的狼群数量预测](img/Fig_7.9.jpg)'
- en: Figure 7.9 – Wolf population forecast with decreasing logistic growth
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 下降的指数增长下的狼群数量预测
- en: Prophet will predict precise decimal values and, of course, wolves exist in
    integer values, but this plot shows that somewhere between 2010 and 2014, the
    wolf population will die off. In a real scenario, it also matters greatly whether
    the last few remaining wolves are part of a breeding pair, and we have ignored
    that factor here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet将预测精确的小数值，当然，狼的数量是整数，但这个图表显示，在2010年和2014年之间，狼群将灭绝。在现实场景中，最后几只剩余的狼是否是繁殖对的一部分也非常重要，但我们在这里忽略了这个因素。
- en: Notice that because we have specified both a cap and a floor, Prophet has plotted
    both as horizontal dashed lines. When logistic growth is declining, even if there
    is no relevant cap, as is the case here, one must be included in your model. You
    may choose one that is arbitrarily high with no effect on your model, although
    be aware that it will be included in your plot and may make it appear as if Prophet’s
    forecast is very low.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为我们已经指定了上限和下限，Prophet将它们都绘制为水平虚线。当逻辑增长下降时，即使没有相关的上限，就像这里的情况一样，你也必须在你的模型中包含它。你可以选择一个任意高的上限，这对你的模型没有影响，但请注意，它将被包含在你的图表中，可能会使Prophet的预测看起来非常低。
- en: 'You can, however, exclude it from your plots by including the `plot_cap` argument
    as done here: `fig = model.plot(forecast, plot_cap=False)`, which modifies both
    the cap and the floor. Prophet does not currently support the exclusion of only
    one of these from your plot.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过包括`plot_cap`参数来将其排除在图表之外，就像这里所做的那样：`fig = model.plot(forecast, plot_cap=False)`，这会修改上限和下限。Prophet目前不支持从你的图表中排除其中一个。
- en: 'Prophet currently supports one more growth mode: **no growth (or flat)**. However,
    the Prophet team is at work on some other modes at the time of writing, and those
    may become available soon, so keep an eye on the documentation. Let’s take a look
    at this final growth mode.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet目前支持一种更多增长模式：**无增长（或平稳）**。然而，Prophet团队在撰写本文时正在努力开发其他模式，这些模式可能很快就会可用，所以请密切关注文档。让我们看看这种最终的增长模式。
- en: Applying flat growth
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用平稳增长
- en: '**Flat growth** is when the trend line is perfectly constant throughout the
    data. The data’s values only differ due to seasonality, holidays, extra regressors,
    or noise. To see how to model flat growth, let’s continue on with our wolf population
    but this time, consider far into the future when the population has fully stabilized.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**平稳增长**是指趋势线在整个数据中完全恒定。数据值的不同仅由于季节性、假日、额外回归因子或噪声。要了解如何建模平稳增长，让我们继续使用我们的狼群数据，但这次，考虑远期未来，当人口已经完全稳定时。'
- en: 'Let’s begin by creating a new dataset – essentially, the same as our logistic
    growth dataset but with a much longer timeframe:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的数据集——本质上与我们的逻辑增长数据集相同，但时间跨度更长：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are now looking forward a century from when the wolves were re-introduced
    into the park:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在展望从狼群被重新引入公园的一个世纪之后：
- en: '![Figure 7.10 – Simulated wolf population over a century](img/Fig_7.10.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – 一个世纪内的模拟狼群人口](img/Fig_7.10.jpg)'
- en: Figure 7.10 – Simulated wolf population over a century
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 一个世纪内的模拟狼群人口
- en: 'After this length of time, the wolf population has reached the saturation point
    and is fully stabilized. We will now create our training DataFrame, but then only
    limit our data to the last decade of the range, where the overall trend is already
    well saturated:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这么长时间，狼群已经达到饱和点并完全稳定。我们现在将创建我们的训练数据框，但然后只限制我们的数据到范围的最后十年，那里的整体趋势已经很好地饱和：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Plotting that data should show no overall growth, just very noisy seasonality:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制这些数据应显示没有整体增长，只是非常嘈杂的季节性：
- en: '![Figure 7.11 – Simulated stable wolf population](img/Fig_7.11.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 模拟的稳定狼群人口](img/Fig_7.11.jpg)'
- en: Figure 7.11 – Simulated stable wolf population
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 模拟的稳定狼群人口
- en: 'Let’s first use the default linear growth to see what could go wrong:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用默认的线性增长来看看可能会出错：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Due to random noise in the data, Prophet will find brief areas where there
    seems to be a trend, either positive or negative. If one of these periods occurs
    at the end of the training data, then that curve will continue for the entire
    output of forecasted future data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据中的随机噪声，Prophet会在看似存在趋势的短暂区域找到趋势，无论是正的还是负的。如果这些时期发生在训练数据的末尾，那么这条曲线将延续到整个预测的未来数据的输出：
- en: '![Figure 7.12 – Stable wolf population forecast with linear growth](img/Fig_7.12.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – 使用线性增长的稳定狼群人口预测](img/Fig_7.12.jpg)'
- en: Figure 7.12 – Stable wolf population forecast with linear growth
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 使用线性增长的稳定狼群人口预测
- en: As you can see, Prophet predicts that the wolf population is decreasing, even
    though it is quite stable. Furthermore, the uncertainty intervals are growing;
    Prophet is smart enough to know this isn’t quite right. Now let’s model this correctly—with
    flat growth. Because the trend will be constant, setting a seasonality mode is
    irrelevant. It will still be calculated as either additive or multiplicative,
    but the end result will be the same in either case. We will ignore it here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Prophet预测狼群数量正在减少，尽管它相当稳定。此外，不确定性区间正在扩大；Prophet足够聪明，知道这并不完全正确。现在让我们用平稳增长来正确地建模。由于趋势将是恒定的，设置季节性模式是不相关的。它仍然会被计算为加法或乘法，但无论哪种情况，最终结果都将相同。我们在这里将忽略它。
- en: 'Creating a model with flat growth is as simple as setting `growth=''flat''`
    during model instantiation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型实例化期间设置`growth='flat'`即可创建具有平稳增长的模型：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, Prophet’s trend line is perfectly flat:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Prophet的趋势线是完全平坦的：
- en: '![Figure 7.13 – Stable wolf population forecast with flat growth](img/Fig_7.13.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13 – 使用平稳增长的稳定狼群人口预测](img/Fig_7.13.jpg)'
- en: Figure 7.13 – Stable wolf population forecast with flat growth
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 稳定的狼群人口预测，增长平稳
- en: No matter how far out we forecast, the trend will be stable. The only variation
    in Prophet’s model in this example comes from the yearly seasonality, as we added
    no holidays and neither daily nor weekly seasonalities were included.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们预测得多远，趋势都将保持稳定。在这个例子中，Prophet模型的唯一变化来自年度季节性，因为我们没有添加假日，也没有包括每日或每周的季节性。
- en: These three growth modes—linear, logistic, and flat—are by far the most commonly
    used in the industry and can cover nearly every forecasting task that most analysts
    will see. However, cases do sometimes arise where the analyst needs a custom growth
    mode. Although it is not the simplest task, Prophet does have the capability to
    accept any growth mode you can mathematically define.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种增长模式——线性、逻辑和平坦——在行业中是最常用的，几乎可以覆盖大多数分析师将看到的几乎所有预测任务。然而，有时分析师需要自定义增长模式。尽管这不是最简单的任务，但Prophet确实具有接受任何你可以数学定义的增长模式的能力。
- en: Creating a custom trend
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义趋势
- en: 'A key advantage of open source software is that any user can download the source
    code and make their own modifications to better suit the software to their own
    use case. Although nearly all common time series can be appropriately modeled
    with the three trend modes implemented in Prophet (piecewise linear, piecewise
    logistic, and flat), there may be cases when you need a different trend model
    than provided; as Prophet is open source, it is relatively easy to create whatever
    you need. A quick caveat though: it is *relatively easy* only conceptually. Mathematically,
    it can be quite complex, and you must have solid software engineering skills to
    understand how to modify the code successfully.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件的一个关键优势是任何用户都可以下载源代码，并根据他们的使用案例对软件进行自己的修改以更好地适应。尽管几乎所有常见的时间序列都可以用Prophet（分段线性、分段逻辑和平坦）中实现的三个趋势模式进行适当建模，但可能存在需要不同于提供的趋势模型的情况；由于Prophet是开源的，因此相对容易创建你需要的任何内容。但有一个快速警告：这只是在概念上相对容易。从数学上讲，它可能相当复杂，你必须具备扎实的软件工程技能才能成功修改代码。
- en: 'Let’s look at an example of what is possible. Consider a small clothing retailer,
    which updates its collection for each season:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个可能的例子。考虑一家小型服装零售商，它为每个季节更新其收藏品：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Daily sales are highly dependent upon the popularity of the collection currently
    available, so the trend is mostly flat but sees dramatic step changes every three
    months when a new collection is released:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每日销售额高度依赖于当前可用的收藏品的热度，因此趋势大多是平稳的，但每三个月当新收藏品发布时，会看到戏剧性的阶梯式变化：
- en: '![Figure 7.14 – Daily sales (in thousands) at a clothing retailer](img/Fig_7.14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14 – 服装零售商的每日销售额（以千为单位）](img/Fig_7.14.jpg)'
- en: Figure 7.14 – Daily sales (in thousands) at a clothing retailer
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – 服装零售商的每日销售额（以千为单位）
- en: 'We have two weeks of data for the new season, and we want to forecast sales
    for the rest of this season. None of Prophet’s available trend models would capture
    this very well. Our best option would be to use the default growth model, linear.
    Let’s see what happens though when we try this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有新季节两周的数据，我们想要预测本季节剩余的销售情况。Prophet可用的趋势模型都无法很好地捕捉这一点。我们最好的选择是使用默认的增长模型，线性。不过，让我们看看当我们尝试这样做会发生什么：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The resulting forecast has too many dramatic changepoints:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果预测有太多的戏剧性变化点：
- en: '![Figure 7.15 – Unsuitable linear forecast](img/Fig_7.15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15 – 不合适的线性预测](img/Fig_7.15.jpg)'
- en: Figure 7.15 – Unsuitable linear forecast
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – 不合适的线性预测
- en: The confidence interval explodes in the forecast period because the model is
    expecting more potential changepoints; and it also ignores the fact that the data
    has been flat for the previous three months, predicting an absurd ongoing hockey-stick
    growth rate. A flat growth model would be better, but as implemented in Prophet,
    it cannot handle changepoints.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 预测期间的置信区间爆炸，因为模型预计有更多的潜在变化点；它还忽略了数据在前三个月已经平稳的事实，预测了一个荒谬的持续曲棍球棒增长速率。一个平稳增长模型会更好，但在Prophet中实现时，它无法处理变化点。
- en: 'This is where the process becomes complex and very heavy on software engineering
    skills. We need to create a custom trend model. In a nutshell, the necessary code
    needs to copy the Prophet class from Prophet’s source code in the `forecaster.py`
    file at [https://github.com/facebook/prophet/blob/main/python/prophet/forecaster.py](https://github.com/facebook/prophet/blob/main/python/prophet/forecaster.py),
    and make some modifications. In particular, this new class (in the example in
    our GitHub repository at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition),
    we’re calling it `ProphetStepWise`) inherits all methods and properties from the
    base `Prophet` class and modifies it in a few ways:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的过程变得复杂，并且非常依赖软件工程技能。我们需要创建一个自定义趋势模型。简而言之，必要的代码需要从Prophet的源代码中复制Prophet类，该类位于`forecaster.py`文件中，在[https://github.com/facebook/prophet/blob/main/python/prophet/forecaster.py](https://github.com/facebook/prophet/blob/main/python/prophet/forecaster.py)。然后进行一些修改。特别是，这个新类（在我们GitHub仓库的示例中，我们称之为`ProphetStepWise`）继承了基类`Prophet`的所有方法和属性，并在几个方面进行了修改：
- en: It modifies the original `Prophet` class’s `fit` function to initialize the
    new stepwise growth mode.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它修改了原始`Prophet`类的`fit`函数，以初始化新的步进增长模式。
- en: It creates a new function, `stepwise_growth_init`, similar to the current `flat_growth_init`
    function, which initializes the trend with flat growth. The current `flat_growth_init`
    function sets an offset parameter equal to the mean of historic values, but this
    new `stepwise_growth_init` function considers changepoint locations and applies
    varying offset parameters between each changepoint.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个新的函数，`stepwise_growth_init`，类似于当前的`flat_growth_init`函数，它使用平稳增长初始化趋势。当前的`flat_growth_init`函数将偏移参数设置为历史值的平均值，但这个新的`stepwise_growth_init`函数考虑变化点的位置，并在每个变化点之间应用不同的偏移参数。
- en: It creates a new function, `stepwise_trend`, analogous to the existing `flat_trend`
    function, which evaluates the new stepwise trend.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个新的函数，`stepwise_trend`，类似于现有的`flat_trend`函数，它评估新的步进趋势。
- en: It modifies the existing `sample_predictive_trend` function to redefine the
    `'flat'` growth mode to use the new `stepwise_trend` function.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它修改了现有的`sample_predictive_trend`函数，将`'flat'`增长模式重新定义为使用新的`stepwise_trend`函数。
- en: And lastly, it modifies the existing `predict_trend` function to use `stepwise_trend`
    instead of the existing `flat_trend` function when the `'flat'` growth is set.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它修改了现有的`predict_trend`函数，当设置`'flat'`增长时，使用`stepwise_trend`而不是现有的`flat_trend`函数。
- en: The full code for all of these steps is too long and bespoke to reproduce fully
    here, but all code is in the `Chapter07` folder located in our GitHub repo linked
    to previously.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤的完整代码太长且定制化，无法在此完全重现，但所有代码都位于我们之前链接的GitHub仓库中的`Chapter07`文件夹内。
- en: 'Once this new `ProphetStepWise` class is created, we can use it just like the
    standard `Prophet` class to make forecasts. Here, we will declare the growth as
    `''flat''` and manually provide the location of each changepoint (the changepoints
    all coincide with the first date of each new clothing season—but don’t concern
    yourself with these details for now; changepoints will be discussed in the next
    chapter!):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新的`ProphetStepWise`类，我们就可以像使用标准的`Prophet`类一样使用它来做出预测。在这里，我们将增长声明为`'flat'`，并手动提供每个变化点的位置（变化点都与每个新服装季节的第一天相吻合——但现在不必担心这些细节；变化点将在下一章中讨论！）：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The resulting forecast looks much more reasonable!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 结果预测看起来更加合理！
- en: '![Figure 7.16 – Our new stepwise trend](img/Fig_7.16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16 – 我们的新步进趋势](img/Fig_7.16.jpg)'
- en: Figure 7.16 – Our new stepwise trend
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – 我们的新步进趋势
- en: 'You’ll note, however, that although the forecast for the rest of the season
    is pretty much spot-on, the confidence intervals are unfortunately extremely wide.
    In order to fix this issue, you’ll need to also modify the `prophet.stan` file.
    As this book is only working with Python code, these changes in the Stan model
    are out of scope. However, for those interested, there is an excellent example
    of this stepwise trend model with the correctly implemented Stan changes available
    as a pull request in the official Prophet GitHub repo: [https://github.com/facebook/prophet/pull/1466/files](https://github.com/facebook/prophet/pull/1466/files).
    In fact, much of the code in this section came from that example.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会注意到，尽管对整个季节的预测相当准确，但置信区间却非常宽泛。为了解决这个问题，你还需要修改`prophet.stan`文件。由于本书只使用Python代码，因此Stan模型中的这些更改不在此讨论范围之内。然而，对于那些感兴趣的人来说，官方Prophet
    GitHub仓库中有一个很好的逐步趋势模型示例，其中包含了正确实现的Stan更改，你可以通过以下链接查看：[https://github.com/facebook/prophet/pull/1466/files](https://github.com/facebook/prophet/pull/1466/files)。实际上，本节中的大部分代码都来自那个示例。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that the models we built in the first few chapters
    of this book all featured linear growth. You learned that the logistic function
    was developed to model population growth and then learned how to implement this
    in Prophet by modeling the growth of the wolf population in Yellowstone after
    their reintroduction in 1995.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到本书前几章构建的模型都具备线性增长的特点。你学习了逻辑函数是如何被开发出来以模拟人口增长的，然后学习了如何在Prophet中通过模拟1995年狼群重新引入黄石公园后的增长来实施这一功能。
- en: Logistic growth in Prophet can be modeled as either increasing up to a saturation
    limit called the *cap* or decreasing to a saturation limit called the *floor*.
    Finally, you learned how to model flat (or no growth) trends, where the trend
    is fixed to one value for the entire data period but seasonality is still allowed
    to vary. Throughout this chapter, you used the `add_changepoints_to_plot` function
    in order to overlay the trend line on your forecast plots.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Prophet中，逻辑增长可以模拟为增加到饱和极限，称为*上限*，或者减少到饱和极限，称为*下限*。最后，你学习了如何模拟平坦（或无增长）趋势，其中趋势在整个数据期间固定为一个值，但季节性仍然允许变化。在本章中，你使用了`add_changepoints_to_plot`函数来在你的预测图上叠加趋势线。
- en: Choosing the correct growth mode is important, particularly so when forecasting
    further into the future. We looked at a couple of examples in this chapter where
    the incorrect growth mode fitted the actual data well, but the future forecasts
    became quite unrealistic. Finally, we saw an example of creating a custom trend
    model. This process is the most advanced technique covered in this book but is
    also the most powerful, as it demonstrates how to take advantage of Prophet’s
    open source code to fully customize the package for your specific needs. In the
    next chapter, you’ll learn all about changepoints and how to use them to gain
    even more control over your trend lines.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的发展模式很重要，尤其是在进行未来预测时。在本章中，我们查看了一些例子，其中错误的发展模式很好地拟合了实际数据，但未来的预测却变得非常不切实际。最后，我们看到了创建自定义趋势模型的例子。这个过程是本书中介绍的最先进的技术，但也是最强大的，因为它展示了如何利用Prophet的开源代码来完全定制该包以满足你的特定需求。在下一章中，你将了解所有关于变化点的内容以及如何使用它们来获得对趋势线更多的控制。
