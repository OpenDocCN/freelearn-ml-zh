- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling Growth Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this book, every forecast we’ve built has followed only one growth
    mode: **linear**. The trend sometimes had some small bends where the slope either
    increased or decreased, but fundamentally, the trend consisted of linear segments.
    However, Prophet features two additional growth modes: **logistic** and **flat**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modeling your time series with a growth mode that is not optimal can often
    fit the actual data very well. But, as you’ll see in this chapter, even if the
    fit is realistic, the future forecast can become wildly unrealistic. Sometimes,
    the shape of the data will inform which growth mode to choose, and sometimes you’ll
    need domain knowledge and a bit of common sense. This chapter will help guide
    you to an appropriate selection. Furthermore, you will learn when and how to apply
    these different growth modes. Specifically, this chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying linear growth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the logistic function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saturating forecasts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying flat growth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom trend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data files and code for the examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Applying linear growth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the models we built in the previous chapters had the default growth mode,
    linear. This means that the trend consists of a straight, sloped line, or potentially,
    a few straight, sloped lines connected at changepoints – a case we will explore
    in [*Chapter 8*](B19630_08.xhtml#_idTextAnchor537), *Influencing Trend Changepoints*.
    For now, though, let’s load up our Divvy data again and focus on the growth.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to import `pandas`, `matplotlib`, and `Prophet` again, but this
    time, we’ll also import a new function from Prophet’s `plot` package, `add_changepoints_to_plot`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This new function will allow us to easily plot our trend line directly on our
    forecast plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve done previously, let’s open the Divvy data and load it into our training
    DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We learned already in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254), *Working
    with Seasonality*, that this dataset should be modeled with multiplicative seasonality
    and that the yearly seasonality should be constrained a bit by setting the Fourier
    order to `4`. We’ll set these values when instantiating our model. We’ll also
    explicitly set `growth=''linear''`. This is the default, and previously, we just
    implicitly accepted it, but for clarity’s sake, we’ll include it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did when we modeled the daily Divvy data in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254),
    *Working with Seasonality*, next, we will fit the model, build a `future` DataFrame
    with one year to forecast, predict future values, and plot the forecast. This
    time, however, we will use the `add_changepoints_to_plot` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function requires that we specify which plot axes to use, identify the
    model we created, and identify the forecast DataFrame output from the `predict`
    method. For the axes, we use the Matplotlib `gca` method, to *get current axes*,
    and call it on the figure created when plotting the forecast. You can see the
    syntax in the following code. We are only using the plot changepoints function
    here to plot the trend so we will remove the changepoint markers, for now, using
    `cp_linestyle=''''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As output, you should now see a similar forecast to that in *Figure 5**.8*,
    but this time, the trend line will be overlaid upon the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Divvy forecast with the trend](img/Fig_7.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Divvy forecast with the trend
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Prophet is an additive regression model. So, the trend is the most
    fundamental building block of our forecast. We add detail and variation to it
    by adding seasonalities, holidays, and additional regressors. The trend you see
    in the preceding figure (the solid line cutting through the midpoints of each
    sine period) is the Divvy plot with seasonality removed (we never added holidays
    in this example).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the trend is a straight segment from **2014** until late **2015**,
    then a slight bend and another straight segment, with a shallower slope, from
    **2016** onward. Despite that bend, it is fundamentally linear.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at the next growth mode, logistic. To understand this growth
    mode, you first need to understand the logistic function.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the logistic function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **logistic function** generates an S-shaped curve; the equation takes the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19630_07_F01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![](img/B19630_07_F02.png) is the maximum value of the curve, ![](img/B19630_07_F03.png)
    is the logistic growth rate, or steepness, of the curve, and ![](img/B19630_07_F04.png)
    is the *x* value of the curve’s midpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking ![](img/B19630_07_F05.png), ![](img/B19630_07_F06.png), and ![](img/B19630_07_F07.png),
    the logistic function produces the **standard logistic function**, ![](img/B19630_07_F08.png),
    as seen in the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.\uFEFF2 – The standard logistic function](img/Fig_7.2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The standard logistic function
  prefs: []
  type: TYPE_NORMAL
- en: If you have studied logistic regression or neural networks, you may recognize
    this as the **sigmoid function**. Any input value for *x*, from -∞ to ∞, will
    be squished into an output value, *y*, between 0 and 1\. This equation is what
    allows a logistic regression model to accept any input value and output a probability
    between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: The equation was developed by Pierre François Verhulst, a Belgian mathematician,
    in a series of three papers published between 1838 and 1847\. Verhulst was working
    to model the population growth of Belgium.
  prefs: []
  type: TYPE_NORMAL
- en: Population growth approximately follows an initial exponential growth rate,
    then a linear (also known as arithmetic) growth rate, until the population hits
    a saturation point, where growth slows to zero. This is the shape you see in the
    preceding plot, starting at the curve’s midpoint and moving right. Verhulst invented
    the term *logistic* to be analogous to *arithmetic* and *geometric* but derived
    from *logarithmic*. Don’t get the word confused with *logistics*, which refers
    to the handling of details. They have completely different origins.
  prefs: []
  type: TYPE_NORMAL
- en: Prophet’s logistic growth mode follows this general curve. The curve’s **saturation**
    levels are the upper and lower bounds, which the curve asymptotically approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Besides applications in statistics and machine learning where the logistic curve
    is used in logistic regression and neural networks, the logistic function is also
    often used to model population growth, either of humans (as in Verhulst’s Belgium)
    or of animals, as we will do in this chapter. It is often used in medicine to
    model the growth of tumors, bacterial or viral loads in an infected person, or
    infection rates of people during a pandemic.
  prefs: []
  type: TYPE_NORMAL
- en: In economics and sociology, the curve is used to describe the adoption rate
    of new innovations. Linguists use it to model language changes. It can even be
    used to model the spread of a rumor or new idea throughout a population.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to apply this in Prophet.
  prefs: []
  type: TYPE_NORMAL
- en: Saturating forecasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early 1800s, westward expansion in the United States brought many settlers
    and their livestock into contact with the native wolf population. These wolves
    began to prey on domestic stock, which resulted in the settlers hunting and killing
    the wolves in order to protect their own animals. The gray wolf was still present
    on the land (which became Yellowstone National Park when it was established in
    1872), but over the next few decades, they were hunted nearly to extinction in
    the region and throughout the lower 48 states.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1960s, the public began to understand the idea of ecosystems and the
    interconnectedness of species, and in 1975, the decision to restore wolf populations
    to Yellowstone was taken, with 31 gray wolves finally being relocated to the park
    from Canada in 1995\. This provided an almost perfect experiment of natural population
    growth inside the park.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at this population in the next few examples. However, we’ll be using
    simulated data because the true data is spotty throughout the historical record.
    As wolves tend to avoid human contact, counting their number can never be exact
    and so accurate data is lacking. Furthermore, there are numerous compounding factors
    (such as weather, for example) that we will not model (and are generally unpredictable,
    as well).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand these compounding factors, consider the example of Isle Royale,
    an island on Michigan’s Lake Superior that has had a moose and wolf population
    under continuous study since 1959\. This is, in fact, the longest continuous study
    of any predator-prey population system in the world. As can be seen in the following
    plot, it has not been a predictable system, to say the least:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.3\uFEFF – Population numbers of wolves and moose on Isle Royale](img/Fig_7.3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Population numbers of wolves and moose on Isle Royale
  prefs: []
  type: TYPE_NORMAL
- en: In the 1960s and 1970s, rising moose populations provided food, which allowed
    wolf populations to double. But in 1980, humans inadvertently introduced canine-parvovirus,
    a disease that caused the wolf population to collapse. The moose population in
    turn rose again with the decline of its only predator, only to collapse itself
    in 1996 with the double stresses of the most severe winter on record and an unpredictable
    outbreak of moose ticks.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the 1990s, the wolf population was too low for healthy breeding,
    leading to intense levels of inbreeding, which held their population down, only
    rebounding when a single wolf reached the island by crossing winter ice from Canada
    in the late 1990s. Following this, the wolf population increased throughout the
    early twenty-first century, despite declining moose numbers. All this is to say
    that small, isolated populations represent a very dynamic system that cannot be
    accurately predicted when not in isolation from natural external events.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing logistic growth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To synthesize a somewhat realistic population of wolves in Yellowstone, let’s
    suppose that 100 wolves were introduced in 1995\. Park ecologists surveyed the
    area and determined that the land could support a total population of 500 wolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the linear growth example, we imported `pandas`, `matplotlib`, `Prophet`,
    and the `add_changepoints_to_plot` function, so to continue, we only need to import
    the `numpy` and `random` libraries in order to create our dataset. Be sure to
    set the random seed so that every time we run the code, we get the same pseudo-random
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will simulate the wolf population by first creating a series of monthly
    dates, from 1995 until 2004\. At every date, we’ll calculate the output from our
    logistic equation. Then, we’ll add some sinusoidal variation to account for yearly
    seasonality, and finally, some random noise. Then, we just need to scale our curve
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s plot the curve to make sure everything worked out as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went correctly, you should see this plot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7\uFEFF.4 – Simulated wolf population in Yellowstone](img/Fig_7.4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Simulated wolf population in Yellowstone
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin our analysis of this data by fitting a Prophet model with linear
    growth. This example will demonstrate what can go wrong when choosing an inappropriate
    growth mode.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling with linear growth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we did earlier, we start by organizing our data into a DataFrame for Prophet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to linear growth, let’s set the Fourier order of the yearly seasonality
    to `3` and the seasonality mode to `multiplicative`. Then, we fit our DataFrame
    and create the `future` DataFrame. We simulated this data at a monthly frequency,
    so we’ll forecast out `10` years and set `freq=''M''`. After predicting on the
    future, we’ll plot the forecast and use the `add_changepoints_to_plot` function
    to overlay the trend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately, you should see what will go wrong with using a linear trend in
    a situation where the forecast will naturally saturate at some level. The predicted
    values will keep rising toward infinity with longer and longer forecast time periods:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figu\uFEFFre 7.5 – Wolf population forecast with linear growth](img/Fig_7.5.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Wolf population forecast with linear growth
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this cannot be realistic. There is only so much food for the wolves
    to eat; at a certain point, there won’t be enough food, and the wolves will begin
    to starve. Let’s now model this with logistic growth and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling with logistic growth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With `cap` and also mimic it in our `future` DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, determining a cap may pose some difficulties. If your curve is
    near the saturation level already, you can see better what value it is approaching
    and choose it. If not, however, then a little domain knowledge will really be
    your best solution. Before you can model logistic growth rates, you must have
    some idea of where the saturation level will eventually be. Usually, this cap
    is set using data or with special expertise about market size. For our example,
    we’ll set the cap to `500`, as that was the value estimated by the ecologists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we continue just as we did in the previous example, but this time, let’s
    set the growth mode to `logistic`, before fitting and creating the `future` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the cap to our `future` DataFrame as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we predict and plot the forecast, you’ll see quite a differently
    shaped curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Prophet displays the cap (and floor if present) as horizontal dashed
    lines in your plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Wolf population forecast with logistic growth](img/Fig_7.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Wolf population forecast with logistic growth
  prefs: []
  type: TYPE_NORMAL
- en: With logistic growth, the wolf population is allowed to grow at roughly the
    same rate for several years. The growth rate slows as it approaches its saturation
    point, the greatest population that the natural resources available can support.
    After this point, the growth rate stays flat with just a bit of seasonal variation
    as old wolves die in the winter and spring pups arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Non-constant cap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the cap does not necessarily need to be constant.
    If you are forecasting sales, for example, your saturation limit will be the market
    size. But this market size may be growing as various factors cause more consumers
    to consider purchasing your product. Let’s look at a quick example of how to model
    this. We assumed that the wolf population in Yellowstone was constrained by the
    size of the park. Let’s now create a hypothetical situation where the park size
    is gradually increased starting in 2007, creating conditions that allow for two
    additional wolves per month.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a function to set the cap. For dates prior to 2007, we will keep
    the park’s saturation limit of `500`. For all dates starting in 2007, though,
    we will increase the cap by two per month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s set the cap for our training DataFrame, `df`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The cap should remain `500` throughout, as our training data ends in 2004\.
    Now, let’s create our model the same as before, but set our `future` DataFrame
    using the `set_cap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can see that the wolf population is asymptotically approaching our
    increasing cap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Wolf population forecast with non-constant cap](img/Fig_7.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Wolf population forecast with non-constant cap
  prefs: []
  type: TYPE_NORMAL
- en: The cap is simply a value set for each row in the DataFrame; for every date,
    you can set whichever value makes sense. The cap may be constant, as in our first
    example, it may vary linearly, as we have just done here, or it may follow any
    arbitrary curve of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the reverse situation, a hypothetical situation where the
    wolf population is sadly declining and approaching extinction.
  prefs: []
  type: TYPE_NORMAL
- en: Decreasing logistic growth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only difference in this example is that we must also state a `floor` value
    in addition to a `cap` value. Let’s build another pseudo-random dataset but with
    negative growth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The growth curve should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Simulated declining wolf population in Yellowstone](img/Fig_7.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Simulated declining wolf population in Yellowstone
  prefs: []
  type: TYPE_NORMAL
- en: 'For our forecast in this case, we’ll cut off the data at `2006` and attempt
    to predict when there will be no more wolves in the population. When creating
    our DataFrame, we specify both a `cap` value, as we did previously, and a `floor`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll complete the model all in one step. Everything is the same as the previous
    examples, except this time, we also set `floor` in the `future` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It should come as no surprise that Prophet handles this case with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Wolf population forecast with decreasing logistic growth](img/Fig_7.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Wolf population forecast with decreasing logistic growth
  prefs: []
  type: TYPE_NORMAL
- en: Prophet will predict precise decimal values and, of course, wolves exist in
    integer values, but this plot shows that somewhere between 2010 and 2014, the
    wolf population will die off. In a real scenario, it also matters greatly whether
    the last few remaining wolves are part of a breeding pair, and we have ignored
    that factor here.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that because we have specified both a cap and a floor, Prophet has plotted
    both as horizontal dashed lines. When logistic growth is declining, even if there
    is no relevant cap, as is the case here, one must be included in your model. You
    may choose one that is arbitrarily high with no effect on your model, although
    be aware that it will be included in your plot and may make it appear as if Prophet’s
    forecast is very low.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, exclude it from your plots by including the `plot_cap` argument
    as done here: `fig = model.plot(forecast, plot_cap=False)`, which modifies both
    the cap and the floor. Prophet does not currently support the exclusion of only
    one of these from your plot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prophet currently supports one more growth mode: **no growth (or flat)**. However,
    the Prophet team is at work on some other modes at the time of writing, and those
    may become available soon, so keep an eye on the documentation. Let’s take a look
    at this final growth mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying flat growth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Flat growth** is when the trend line is perfectly constant throughout the
    data. The data’s values only differ due to seasonality, holidays, extra regressors,
    or noise. To see how to model flat growth, let’s continue on with our wolf population
    but this time, consider far into the future when the population has fully stabilized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating a new dataset – essentially, the same as our logistic
    growth dataset but with a much longer timeframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now looking forward a century from when the wolves were re-introduced
    into the park:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Simulated wolf population over a century](img/Fig_7.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Simulated wolf population over a century
  prefs: []
  type: TYPE_NORMAL
- en: 'After this length of time, the wolf population has reached the saturation point
    and is fully stabilized. We will now create our training DataFrame, but then only
    limit our data to the last decade of the range, where the overall trend is already
    well saturated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting that data should show no overall growth, just very noisy seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Simulated stable wolf population](img/Fig_7.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Simulated stable wolf population
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first use the default linear growth to see what could go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to random noise in the data, Prophet will find brief areas where there
    seems to be a trend, either positive or negative. If one of these periods occurs
    at the end of the training data, then that curve will continue for the entire
    output of forecasted future data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Stable wolf population forecast with linear growth](img/Fig_7.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Stable wolf population forecast with linear growth
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Prophet predicts that the wolf population is decreasing, even
    though it is quite stable. Furthermore, the uncertainty intervals are growing;
    Prophet is smart enough to know this isn’t quite right. Now let’s model this correctly—with
    flat growth. Because the trend will be constant, setting a seasonality mode is
    irrelevant. It will still be calculated as either additive or multiplicative,
    but the end result will be the same in either case. We will ignore it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a model with flat growth is as simple as setting `growth=''flat''`
    during model instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Prophet’s trend line is perfectly flat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Stable wolf population forecast with flat growth](img/Fig_7.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Stable wolf population forecast with flat growth
  prefs: []
  type: TYPE_NORMAL
- en: No matter how far out we forecast, the trend will be stable. The only variation
    in Prophet’s model in this example comes from the yearly seasonality, as we added
    no holidays and neither daily nor weekly seasonalities were included.
  prefs: []
  type: TYPE_NORMAL
- en: These three growth modes—linear, logistic, and flat—are by far the most commonly
    used in the industry and can cover nearly every forecasting task that most analysts
    will see. However, cases do sometimes arise where the analyst needs a custom growth
    mode. Although it is not the simplest task, Prophet does have the capability to
    accept any growth mode you can mathematically define.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom trend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A key advantage of open source software is that any user can download the source
    code and make their own modifications to better suit the software to their own
    use case. Although nearly all common time series can be appropriately modeled
    with the three trend modes implemented in Prophet (piecewise linear, piecewise
    logistic, and flat), there may be cases when you need a different trend model
    than provided; as Prophet is open source, it is relatively easy to create whatever
    you need. A quick caveat though: it is *relatively easy* only conceptually. Mathematically,
    it can be quite complex, and you must have solid software engineering skills to
    understand how to modify the code successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of what is possible. Consider a small clothing retailer,
    which updates its collection for each season:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Daily sales are highly dependent upon the popularity of the collection currently
    available, so the trend is mostly flat but sees dramatic step changes every three
    months when a new collection is released:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Daily sales (in thousands) at a clothing retailer](img/Fig_7.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Daily sales (in thousands) at a clothing retailer
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two weeks of data for the new season, and we want to forecast sales
    for the rest of this season. None of Prophet’s available trend models would capture
    this very well. Our best option would be to use the default growth model, linear.
    Let’s see what happens though when we try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting forecast has too many dramatic changepoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Unsuitable linear forecast](img/Fig_7.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Unsuitable linear forecast
  prefs: []
  type: TYPE_NORMAL
- en: The confidence interval explodes in the forecast period because the model is
    expecting more potential changepoints; and it also ignores the fact that the data
    has been flat for the previous three months, predicting an absurd ongoing hockey-stick
    growth rate. A flat growth model would be better, but as implemented in Prophet,
    it cannot handle changepoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the process becomes complex and very heavy on software engineering
    skills. We need to create a custom trend model. In a nutshell, the necessary code
    needs to copy the Prophet class from Prophet’s source code in the `forecaster.py`
    file at [https://github.com/facebook/prophet/blob/main/python/prophet/forecaster.py](https://github.com/facebook/prophet/blob/main/python/prophet/forecaster.py),
    and make some modifications. In particular, this new class (in the example in
    our GitHub repository at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition),
    we’re calling it `ProphetStepWise`) inherits all methods and properties from the
    base `Prophet` class and modifies it in a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It modifies the original `Prophet` class’s `fit` function to initialize the
    new stepwise growth mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates a new function, `stepwise_growth_init`, similar to the current `flat_growth_init`
    function, which initializes the trend with flat growth. The current `flat_growth_init`
    function sets an offset parameter equal to the mean of historic values, but this
    new `stepwise_growth_init` function considers changepoint locations and applies
    varying offset parameters between each changepoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates a new function, `stepwise_trend`, analogous to the existing `flat_trend`
    function, which evaluates the new stepwise trend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It modifies the existing `sample_predictive_trend` function to redefine the
    `'flat'` growth mode to use the new `stepwise_trend` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And lastly, it modifies the existing `predict_trend` function to use `stepwise_trend`
    instead of the existing `flat_trend` function when the `'flat'` growth is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The full code for all of these steps is too long and bespoke to reproduce fully
    here, but all code is in the `Chapter07` folder located in our GitHub repo linked
    to previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this new `ProphetStepWise` class is created, we can use it just like the
    standard `Prophet` class to make forecasts. Here, we will declare the growth as
    `''flat''` and manually provide the location of each changepoint (the changepoints
    all coincide with the first date of each new clothing season—but don’t concern
    yourself with these details for now; changepoints will be discussed in the next
    chapter!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The resulting forecast looks much more reasonable!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Our new stepwise trend](img/Fig_7.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Our new stepwise trend
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll note, however, that although the forecast for the rest of the season
    is pretty much spot-on, the confidence intervals are unfortunately extremely wide.
    In order to fix this issue, you’ll need to also modify the `prophet.stan` file.
    As this book is only working with Python code, these changes in the Stan model
    are out of scope. However, for those interested, there is an excellent example
    of this stepwise trend model with the correctly implemented Stan changes available
    as a pull request in the official Prophet GitHub repo: [https://github.com/facebook/prophet/pull/1466/files](https://github.com/facebook/prophet/pull/1466/files).
    In fact, much of the code in this section came from that example.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that the models we built in the first few chapters
    of this book all featured linear growth. You learned that the logistic function
    was developed to model population growth and then learned how to implement this
    in Prophet by modeling the growth of the wolf population in Yellowstone after
    their reintroduction in 1995.
  prefs: []
  type: TYPE_NORMAL
- en: Logistic growth in Prophet can be modeled as either increasing up to a saturation
    limit called the *cap* or decreasing to a saturation limit called the *floor*.
    Finally, you learned how to model flat (or no growth) trends, where the trend
    is fixed to one value for the entire data period but seasonality is still allowed
    to vary. Throughout this chapter, you used the `add_changepoints_to_plot` function
    in order to overlay the trend line on your forecast plots.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the correct growth mode is important, particularly so when forecasting
    further into the future. We looked at a couple of examples in this chapter where
    the incorrect growth mode fitted the actual data well, but the future forecasts
    became quite unrealistic. Finally, we saw an example of creating a custom trend
    model. This process is the most advanced technique covered in this book but is
    also the most powerful, as it demonstrates how to take advantage of Prophet’s
    open source code to fully customize the package for your specific needs. In the
    next chapter, you’ll learn all about changepoints and how to use them to gain
    even more control over your trend lines.
  prefs: []
  type: TYPE_NORMAL
