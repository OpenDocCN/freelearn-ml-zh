# 12

# 执行交叉验证

在机器学习和统计学中，保持训练数据和测试数据分离的概念是神圣不可侵犯的。你不应该在同一数据上训练模型并测试其性能。虽然为测试目的设置数据有缺点：这些数据包含你希望包含在训练中的有价值信息。**交叉验证**是一种用来规避这个问题的技术。

你可能熟悉**k折交叉验证**，但如果你不熟悉，我们将在本章中简要介绍它。然而，k折交叉验证不适用于时间序列数据。它要求数据是独立的，这是一个时间序列数据不成立的假设。理解k折交叉验证将帮助你学习正向链交叉验证是如何工作的，以及为什么它是时间序列数据所必需的。

在学习如何在Prophet中执行交叉验证之后，你将学习如何通过Prophet并行化多个过程的能力来加速交叉验证的计算。总的来说，本章将涵盖以下主题：

+   执行k折交叉验证

+   执行正向链交叉验证

+   创建Prophet交叉验证DataFrame

+   并行化交叉验证

# 技术要求

本章中示例的数据文件和代码可以在[https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition)找到。

.

# 执行k折交叉验证

在本章中，我们将使用一个新的数据集——英国在线零售商的销售额。这些数据已被匿名化，但它代表了三年来的每日销售额，如下所示图表所示：

![Figure 12.1 – 匿名在线零售商的每日销售额](img/Fig_12.1.jpg)

Figure 12.1 – 匿名在线零售商的每日销售额

该零售商在过去三年的数据中并未看到显著增长，但在每年的年底都看到了销售额的巨大提升。该零售商的主要客户是批发商，他们通常在工作日进行采购。这就是为什么当我们绘制Prophet预测的组成部分时，你会看到周六和周日的销售额最低。我们将使用这些数据在Prophet中执行交叉验证。

在我们进行建模之前，让我们首先回顾一下用于调整模型超参数和报告性能的传统验证技术。最基本的方法是将你的完整数据集分成三个子集：一个**训练集**、一个**验证集**和一个**测试集**，在随机打乱后。这有时被称为**保留**验证。通常，训练集是最大的，验证集和测试集较小。例如，60/20/20的分割看起来是这样的：

![Figure 12.2 – 传统训练/验证/测试数据集](img/Fig_12.2.jpg)

图12.2 – 传统的训练/验证/测试集

在完整数据被分割后，你的模型在训练集上训练，并在验证集上评估性能。为给定的算法选择一组新的超参数，并在训练集上重新训练模型，并在验证集上重新评估。这个过程会重复进行，直到尝试多少种超参数组合。

在验证集上性能最高的超参数集被选为模型；训练和验证集合并以训练最终模型，并在测试集上评估这个最终模型。这个评估结果随后报告为模型的性能。

然而，使用这种技术，你只有60%的完整数据可用于调整模型。使用更多数据进行调整可能会有所帮助，但使用较小的验证和测试集可能会引入模型偏差。

为了解决这个问题，开发了k折交叉验证。在k折交叉验证中，数据仍然随机洗牌，并分割出一个测试集，可能是20%的数据。剩余的80%数据全部用于训练。这80%的数据被分成*k*个部分，每个部分称为一个*折*。以下是五个折的过程：

![图12.3 – 五折交叉验证](img/Fig_12.3.jpg)

图12.3 – 五折交叉验证

对于你想要评估的每一组超参数，你将模型训练五次。第一次，你预留第一个折，并在剩余的四个折上训练。你在第一个折上进行评估。你重复这个过程，对每个折进行操作，并取五个折的性能指标的平均值。然后，你继续到下一组超参数，并重复。

由于每个折的训练，调整超参数的过程在这种情况下会花费更长的时间。然而，优势在于你可以在不引入模型偏差的情况下使用更多数据进行训练。

正如你所知，时间序列数据是顺序和相关的。你不能对其进行洗牌。你不能在未来的数据上训练以预测以前的数据。这就是为什么刚刚展示的两种方法都不适用的原因。我们需要一种方法来保持我们数据的顺序，同时仍然留出一部分用于测试和验证。这就是为什么开发了正向链。

# 执行正向链交叉验证

**正向链交叉验证**，也称为**滚动起点交叉验证**，与k折交叉验证类似，但更适合序列数据，如时间序列。一开始没有对数据进行随机洗牌，但可以预留一个测试集。测试集必须是数据的最后部分，所以如果每个折将占你数据的10%（就像在10折交叉验证中那样），那么你的测试集将是数据范围的最后10%。

在剩余的数据中，你选择一个初始数据量用于训练，例如，在这个例子中是五个折，然后你在第六个折上评估并保存那个性能指标。现在你在前六个折上重新训练，并在第七个折上评估。你重复此过程，直到所有折都耗尽，然后再次取性能指标的平均值。使用这种技术的方法将如下所示：

![图12.4 – 前向链式交叉验证的五折](img/Fig_12.4.jpg)

图12.4 – 前向链式交叉验证的五折

以这种方式，你能够在序列数据点上训练你的数据，并评估未见过的数据，同时也能够通过在多种样本上训练和测试来最小化偏差。

Prophet有一个内置的诊断工具用于执行前向链式交叉验证。现在让我们看看如何使用我们的零售销售数据集来使用它。

# 创建Prophet交叉验证DataFrame

在Prophet中执行交叉验证之前，首先你需要一个拟合好的模型。因此，我们将从本书中完成过的相同程序开始。这个数据集非常合作，因此我们将能够使用Prophet的大量默认参数。我们将绘制变化点，所以请确保在加载数据之前将此功能与其他导入项一起包含：

[PRE0]

此数据集的季节性并不复杂，因此在我们实例化模型时，我们将降低年季节性的傅里叶阶数，但保持其他所有设置默认，在拟合、预测和绘图之前。我们将使用1年的未来预测：

[PRE1]

如预期的那样，此图显示了与*图12.1*中引入数据相同的相同数据。没有识别出显著的趋势变化点，并且有一个非常平缓的上升趋势。夏季似乎有轻微的销售增长，但在冬季假日季节有显著增长，如以下图所示：

![图12.5 – 在线零售销售额预测](img/Fig_12.5.jpg)

图12.5 – 在线零售销售额预测

让我们绘制组成部分，以更好地理解我们的季节性：

[PRE2]

`trend`、`weekly`季节性和`yearly`季节性显示出明显的模式：

![图12.6 – 在线零售销售额组成部分图](img/Fig_12.6.jpg)

图12.6 – 在线零售销售额组成部分图

正如我们所预测的，`yearly`季节性反映了冬季的峰值。正如我在介绍此数据时提到的，零售商主要服务于批发商，而不是消费者。因此，他们的购买行为在商业周中远多于周末。与一周中的其他日子相比，`周五`的销售甚至有所下降。

现在，让我们执行实际的交叉验证。为此，我们首先需要从Prophet的`diagnostics`包中导入函数：

[PRE3]

在我们了解如何使用该函数之前，有一些术语我们需要讨论：

+   `initial` 是第一个训练周期。在 *图12*.5 中，它将是第一个折叠中的前五个数据块。这是开始训练所需的最小数据量。

+   `horizon` 是你想要评估预测的时间长度。比如说，这个零售店正在构建一个模型，以便它可以预测下一个月的销售。将预测范围设置为30天在这里是有意义的，这样他们就可以在希望使用的相同参数设置上评估他们的模型。

+   `period` 是每个折叠之间的时间量。它可以大于或小于预测范围，甚至等于它。

+   `cutoffs` 是每个 `horizon` 开始的日期。

这个词汇表在这里得到了说明：

![图12.7 – 交叉验证术语](img/Fig_12.7.jpg)

图12.7 – 交叉验证术语

对于每个 `cutoff`，模型将在截止日期之前的所有数据上进行训练，然后对 `horizon` 期间进行预测。这个预测将与已知值进行比较和评估。然后，模型将在截止日期之前的所有数据上进行重新训练，这个过程将重复进行。最终的性能评估将是每个截止点的性能的平均值。

让我们想象这个零售店希望有一个能够预测下一个月每日销售的模型，并且他们计划在每个季度的开始运行这个模型。他们有3年的数据，并且希望（正如Prophet所推荐的那样）至少有2个完整的季节周期，由于他们正在模拟年度季节性，这将需要2年。

他们将初始训练数据设置为2年。他们想要预测下一个月的销售，因此将 `horizon` 设置为30天。他们计划每个业务季度运行模型，因此将周期设置为90天。这就是之前在 *图12*.7 中所示的内容。现在，让我们将此应用于Prophet。

`cross_validation` 函数接受两个必需的参数，即拟合的模型和 `horizon`。`period` 和 `initial` 也可以指定，但不是必需的。如果保留为默认值，`period` 是 `horizon` 的一半，而 `initial` 将是 `horizon` 的三倍。该函数的输出是交叉验证的DataFrame。让我们创建这个DataFrame，并将其命名为 `df_cv`：

[PRE4]

每个 `horizon`、`period` 和 `initial` 参数都接受一个与pandas的 `Timedelta` 格式兼容的字符串，例如，`'5 days'`、`'3 hours'` 或 `'10 seconds'`。在这个例子中，我们将 `horizon` 和 `period` 的值从 *图12*.7 中所示的内容切换过来。零售店希望预测3个月的每日销售，并且每月更新他们的预测（这可能是对预测的更现实的使用；这些参数在图像中仅被反转，以避免重叠预测范围，使图像更清晰）。

我们从2年的初始周期开始训练，即`'730 days'`。我们将`horizon='90 days'`设置为评估90天的预测间隔。最后，我们设置`period='30 days'`，这样我们每30天重新训练和重新评估我们的模型。这导致总共10个预测与最终一年的数据进行比较。

你也可以指定`cutoff`值，但这通常是不必要的。然而，我们将在[*第13章*](B19630_13.xhtml#_idTextAnchor839)中介绍一个特定实例，*评估性能指标*，在那里你将需要自己设置它们。Prophet的默认行为是从时间序列的末尾自动设置它们。

现在，让我们通过显示前五行来查看这个DataFrame：

[PRE5]

如果你在一个Jupyter笔记本中运行这段代码，你会看到以下格式化的输出（由于优化算法中的随机性，你的`yhat_lower`和`yhat_upper`的值可能略有不同）：

![图12.8 – 交叉验证DataFrame](img/Fig_12.8.jpg)

图12.8 – 交叉验证DataFrame

对于DataFrame中的每个唯一的`cutoff`，你将在`ds`列中找到90天，对应于90天的预测范围。`ds`中的每个日期都有一个真实值`y`，这是你的训练数据`df['y']`中的相同值，以及在该折叠中对该日期在`yhat`列中预测的值。

注意，这与`forecast` DataFrame中的`yhat`不同，因为那些值是用完整的数据集计算的，而不是用交叉验证的折叠计算的。交叉验证DataFrame还包含这些预测的不确定性区间，在`yhat_upper`和`yhat_lower`中。

这个DataFrame允许你比较你的数据中日期时间值范围内的预测值与实际值。在`forecast` DataFrame中，对于未来的日期，显然没有真正的`y`值进行比较。对于过去的日期，有一个对应的`df['y']`值来比较你的`forecast['yhat']`值，但预测是针对这个值训练的。`forecast['yhat']`值是有偏的，而`df_cv['yhat']`值是无偏的，因此将提供更准确的关于你期望模型在新、未见数据上预测的表示。

# 并行化交叉验证

在交叉验证过程中有很多迭代，这些是可以并行化以加快速度的任务。要利用这一点，你只需要使用`parallel`关键字。你可以选择以下四个选项之一：`None`，`'processes'`，`'threads'`或`'dask'`：

[PRE6]

设置`parallel='processes'`使用Python的`concurrent.futures.ProcessPoolExecutor`类，而`parallel='threads'`使用`concurrent.futures.ThreadPoolExecutor`。如果你不确定使用哪一个，选择`'processes'`。它将在单台机器上提供最佳性能。

`None`将不会执行并行处理，如果你计划在Prophet计算时在机器上做其他工作，且不希望Prophet占用你机器的所有资源，这可能是好的。如果你使用`'dask'`，你需要单独安装Dask并使用`dask.distributed`中的`Client`来连接到集群（如果Dask没有单独安装和设置，以下代码将导致错误）：

[PRE7]

虽然你可以在你的笔记本电脑上使用Dask，但它的威力真正体现在使用多台机器上的多个计算集群时。如果你无法访问这种类型的计算能力，`parallel='processes'`通常会是更快的选项。

# 摘要

我们本章开始时讨论了为什么k折交叉验证在传统的机器学习应用中被开发出来，然后我们学习了为什么它不适用于时间序列。然后你学习了前向链，也称为滚动起点交叉验证，用于时间序列数据。

你学习了`initial`、`horizon`、`period`和`cutoff`这些关键字，它们用于定义你的交叉验证参数，并且你学习了如何在Prophet中实现它们。最后，你学习了Prophet在并行化方面提供的不同选项，以便加快模型评估。

这些技术为你提供了一种统计上稳健的方式来评估和比较模型。通过隔离用于训练和测试的数据，你消除了过程中的任何偏差，并且可以更有信心地认为你的模型在做出新预测时将表现良好。

在下一章中，你将应用在这里学到的知识来衡量你模型的性能，并对其进行调整以获得最佳结果。
