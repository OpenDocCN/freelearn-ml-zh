<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer095">
<h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-91">Packaging Up</h1>
<p class="normal">In previous chapters, we introduced a lot of the tools and techniques you will need to use to successfully build working <strong class="keyWord">machine learning</strong> (<strong class="keyWord">ML</strong>) products. We also introduced a lot of example pieces of code that helped us to understand how to implement these tools and techniques. So far, this has all been about <em class="italic">what</em> we need to program, but this chapter will focus on <em class="italic">how</em> to program. In particular, we will introduce and work with a lot of the techniques, methodologies, and standards that are prevalent in the wider Python software development community and apply them to ML use cases. The conversation will be centered around the concept of developing <em class="italic">user-defined libraries and packages</em>, reusable pieces of code that you can use to deploy your ML solutions or develop new ones. It is important to note that everything we discuss here can be applied to all of your Python development activities across your ML project development life cycle. If you are working on some exploratory data analysis in a notebook or some modeling scripts for the research portion of your project, your work will still benefit immensely from the concepts we are about to introduce.</p>
<p class="normal">In this chapter, we will recap some of the basic points of programming in Python, before discussing the concept of coding standards and some pointers for writing high-quality Python code. We will also touch upon the difference between <strong class="keyWord">object-oriented</strong> and <strong class="keyWord">functional</strong> programming in Python, and where this has strengths and points of synergy with other tools that you may want to use in your solution. We will discuss some good use cases for writing your own ML packages and go through the options for packaging up. Next will be a discussion on testing, logging, and error handling in your code, which are important concepts for building code that can be trusted not just to work but also to be diagnosable when it doesn’t. This will be followed by a deep dive into the logical flow of our package. Finally, we will perform an exploration of how we ensure we do not reinvent the wheel and use functionality that already exists elsewhere.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Writing good Python</li>
<li class="bulletList">Choosing a style</li>
<li class="bulletList">Packaging your code</li>
<li class="bulletList">Building your package</li>
<li class="bulletList">Testing, logging, and error handling</li>
<li class="bulletList">Not reinventing the wheel</li>
</ul>
<div class="note">
<p class="normal">IMPORTANT NOTE</p>
<p class="normal">There isn’t a clearly defined difference between a package and a library in Python. The general<a id="_idIndexMarker418"/> consensus seems to be that <em class="italic">library</em> often refers to any collection of code<a id="_idIndexMarker419"/> you want to reuse in other projects, whereas <em class="italic">package</em> refers to a collection of Python modules (covered in this chapter). We will often use the two interchangeably here with the understanding that when we say library, we are usually referring to a bunch of code that is cleanly put together and contains at least one package. This means that we won’t count single scripts with some code you reuse later as a library for our purposes here.</p>
</div>
<p class="normal">Who doesn’t want to write more robust, clean, readable, testable, and performant code that can be used by our colleagues, the ML community, or even our customers? Let’s get started!</p>
<h1 class="heading-1" id="_idParaDest-92">Technical requirements</h1>
<p class="normal">As with the other chapters, the dependencies required to run the examples in this chapter can be installed by navigating to the <code class="inlineCode">Chapter 04</code> folder of the book repository and creating a new Conda environment:</p>
<pre class="programlisting con"><code class="hljs-con">conda env create –f mlewp-chapter04.yml
</code></pre>
<p class="normal">You should note that this chapter mainly focuses on Python fundamentals around packaging, so the requirements are a bit lighter than usual!</p>
<h1 class="heading-1" id="_idParaDest-93">Writing good Python</h1>
<p class="normal">As discussed throughout this book, Python<a id="_idIndexMarker420"/> is an extremely popular and very versatile programming language. Some of the most widely used software products in the world, and some of the most widely used ML engineering solutions in the world, use Python as a core language. </p>
<p class="normal">Given this scope and scale, it is clear that if we are to write similarly amazing pieces of ML-driven software, we should once again follow the best practices and standards already adopted by these solutions. In the following sections, we will explore what packaging up means in practice, and start to really level up our ML code in terms of quality and consistency.</p>
<h2 class="heading-2" id="_idParaDest-94">Recapping the basics</h2>
<p class="normal">Before we get stuck into some more advanced concepts, let’s make sure we are all on the same page and go over some of the basic terminology of the Python world. If you feel quite confident in the fundamentals of Python, then you can skip this section and carry on with the rest of the chapter. However, going over these fundamentals if you are a bit newer to Python or have not revised them in a while will ensure that you apply the right thought processes to the right things and that you can feel confident when writing your code.</p>
<p class="normal">In Python, we have the following objects:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Variable</strong>: An object that stores data<a id="_idIndexMarker421"/> of one of a variety of types. In Python, variables<a id="_idIndexMarker422"/> can be created through <strong class="keyWord">assignment</strong> without specifying the type, for example:
        <pre class="programlisting code"><code class="hljs-code">numerical_variable = <span class="hljs-number">10</span>
string_variable = <span class="hljs-string">'string goes here'</span>
</code></pre>
</li>
<li class="bulletList"><strong class="keyWord">Function</strong>: A unit of code that is self-contained<a id="_idIndexMarker423"/> and performs logical steps<a id="_idIndexMarker424"/> on variables (or another object). Defined by the <code class="inlineCode">def</code> keyword in Python and can return any Python object. Functions are <em class="italic">first-class citizens</em> in Python, which means you can reference them using their object name (and re-reference them), and that functions can pass and return functions. So, for example, if we create a function that calculates some simple statistics from a pandas DataFrame, we can do the following. First, define it:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_statistics</span>(<span class="hljs-params">df</span>):
    <span class="hljs-keyword">return</span> df.describe()
</code></pre>
<p class="normal">Then run it using the original name and a DataFrame called <code class="inlineCode">X_train</code>:</p>
<pre class="programlisting code"><code class="hljs-code">calculate_statistics(X_train)
</code></pre>
<p class="normal">Then you can re-assign the function using a new name and similarly call it:</p>
<pre class="programlisting code"><code class="hljs-code">new_statistics_calculator = calculate_statistics
new_statistics_calculator(X_train)
</code></pre>
<p class="normal">You can then pass the function around even more. For example, if you pass the function into a new function that takes the result and returns a JSON object, then you can call that!</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">make_func_result_json</span>(<span class="hljs-params">func ,df</span>):
    <span class="hljs-keyword">return</span> func(df).to_json
make_func_result_json(calculate_statistics, X_train)
</code></pre>
<p class="normal">This can help build<a id="_idIndexMarker425"/> up some simple<a id="_idIndexMarker426"/> pieces of code into something relatively complex quite quickly.</p></li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord">Module</strong>: This is a file containing definitions<a id="_idIndexMarker427"/> and statements<a id="_idIndexMarker428"/> of functions, variables, and other objects where the contents can be imported into other Python code. For example, if we put the functions defined in the previous example into a file called <code class="inlineCode">module.py</code>, we can then type the following in another Python program (or the Python interpreter) in order to use the functionality contained within it:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> module
module.calculate_statistics(df)
module.make_func_result_json(module.calcualate_statistics, df)
</code></pre>
</li>
<li class="bulletList"><strong class="keyWord">Class</strong>: We will discuss classes<a id="_idIndexMarker429"/> in detail in the <em class="italic">Object-oriented programming</em> section, but for now, just know<a id="_idIndexMarker430"/> that these are the basic units of object-oriented programming, and act as a nice way of containing logically related functionality.</li>
<li class="bulletList"><strong class="keyWord">Package</strong>: This is a collection of modules<a id="_idIndexMarker431"/> that are coupled together via their directory<a id="_idIndexMarker432"/> structure and is built such that modules in the package are accessed through the <code class="inlineCode">dot</code> syntax. For example, if we have a package called <code class="inlineCode">feature</code> that contains modules to help us to do feature engineering, it could be organized as follows:
        <pre class="programlisting code"><code class="hljs-code">feature/
|-- numerical/
    |-- analyze.py
    |-- aggregate.py
    |-- transform.py
|-- categorical/
   |-- analyze.py
   |-- aggregate.py
   |-- transform.py
</code></pre>
<p class="normal">Then, if we wanted to use the functionality contained<a id="_idIndexMarker433"/> within the <code class="inlineCode">numerical</code> or <code class="inlineCode">categorical</code> sub-modules, we would<a id="_idIndexMarker434"/> use the <code class="inlineCode">dot</code> syntax like so:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> feature.categorical.analyze
<span class="hljs-keyword">import</span> feature.numerical.transform
</code></pre></li>
</ul>
<p class="normal">Now let’s move on to discuss some general Python tips and tricks.</p>
<h2 class="heading-2" id="_idParaDest-95">Tips and tricks</h2>
<p class="normal">Let’s now discuss some tips and tricks<a id="_idIndexMarker435"/> for using Python that can often be overlooked, even by those quite familiar with the language. The following concepts can help you write more compact and performant code, so it’s good to have them to hand. Note that this list is definitely not exhaustive:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Generators</strong>: These are convenience functions<a id="_idIndexMarker436"/> for helping us create a syntax that iterates in some sense. They save us from writing a lot of boilerplate code, are memory efficient, and have very useful properties, such as the ability to pause execution and save the internal state automatically. Then you can resume iterating with it later in your program. Generators are created in Python whenever we define a function that uses the <code class="inlineCode">yield</code> statement. For example, here we can define a generator that will filter a given list of values based on a predicate called <code class="inlineCode">condition</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">filter_data</span>(<span class="hljs-params">data, condition</span>):
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data:
        <span class="hljs-keyword">if</span> condition(x):
            <span class="hljs-keyword">yield</span> x
</code></pre>
<p class="normal">In action, we could apply this to a simple list of the integers from zero to ninety-nine called <code class="inlineCode">data_vals</code> and filter out values below a certain threshold:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> filter_data(data_vals, <span class="hljs-keyword">lambda</span> x: x &gt; <span class="hljs-number">50</span>):
    <span class="hljs-built_in">print</span>(x)
</code></pre>
<p class="normal">This will return the integers from fifty to ninety-nine.</p>
<p class="normal">The other way to define a generator expression is by using an iterative statement in round brackets. For example, here we can define a generator that iterates over the squares from zero to nine:</p>
<pre class="programlisting code"><code class="hljs-code">gen1 = (x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen1:
    <span class="hljs-built_in">print</span>(i)
</code></pre>
<p class="normal">Note that you can only execute<a id="_idIndexMarker437"/> your generators once; after that, they are <em class="italic">empty</em>. This is because they only store what they need in memory for each step of the iteration, so once it is complete, nothing is stored!</p>
<p class="normal">Generators<a id="_idIndexMarker438"/> are really powerful ways of creating data manipulation steps that are memory efficient and can be used to define custom pipelines in frameworks such as Apache Beam. We will not cover this here, but it is definitely<a id="_idIndexMarker439"/> worth checking out. As an example, take a look at the article at <a href="https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e"><span class="url">https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e</span></a>.</p>
</li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord">List comprehension</strong>: This is a syntax that allows<a id="_idIndexMarker440"/> us to take any iterable we have to hand (a <code class="inlineCode">dict</code>, a <code class="inlineCode">list</code>, a <code class="inlineCode">tuple</code>, and a <code class="inlineCode">str</code> are all examples) and build a list from it in an extremely compact way. This can save you from writing long, clunky loops and can help create some more elegant code. List comprehensions create the entire list in memory, so they are not as efficient as generators. So use them wisely, and only create small lists if you can. You perform list comprehension by writing your iteration logic in square brackets, as opposed to the round brackets of generators. As an example, we can create the data used in the first generator example:
        <pre class="programlisting code"><code class="hljs-code">data_vals = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]
</code></pre>
</li>
<li class="bulletList"><strong class="keyWord">Containers and collections</strong>: Python has a useful set of built-in types that are known as <strong class="keyWord">containers</strong>, these being <code class="inlineCode">dict</code>, <code class="inlineCode">set</code>, <code class="inlineCode">list</code>, and <code class="inlineCode">tuple</code>. Beginners<a id="_idIndexMarker441"/> in Python learn how to use these from their first time playing with the language, but what we can often<a id="_idIndexMarker442"/> forget is their augmented counterparts: <strong class="keyWord">collections</strong>. These allow for additional behavior on top of the standard containers, which can be useful. The table shown in <em class="italic">Figure 4.1</em> summarizes some useful containers mentioned in the Python 3 documentation on <em class="italic">python.org</em> at <a href="https://docs.python.org/3/library/collections.xhtml"><span class="url">https://docs.python.org/3/library/collections.xhtml</span></a>. 
    <p class="bulletList">These are useful to have to hand when you are working<a id="_idIndexMarker443"/> through some data manipulations and can often save you a couple of lines of code:</p>
<table class="table-container" id="table001-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Container</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">deque</p>
</td>
<td class="table-cell">
<p class="normal">This is a double-ended queue and allows you to add and remove elements to either end of the object in a scalable way. It’s useful if you want to add to the beginning or end of large data lists or if you want to search for the last occurrences of X in your data.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Counter</p>
</td>
<td class="table-cell">
<p class="normal">Counters take in iterables such as dicts or lists and return the count of each of the elements. They’re really useful to get quick summaries of the content of these objects.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">OrderedDict</p>
</td>
<td class="table-cell">
<p class="normal">The standard dict object does not maintain order, so OrderedDict introduces this functionality. This can be really useful if you need to loop back over a dictionary you have created in the same order as it was created for new processing.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 4.1: Some useful types in the collections module in Python 3.</p></li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord">*args</strong> and <strong class="keyWord">**kwargs</strong>: When we want to call a function<a id="_idIndexMarker444"/> in Python, we often<a id="_idIndexMarker445"/> supply it with arguments. We have seen plenty of examples<a id="_idIndexMarker446"/> of this in this book already. But what happens if you define a function for which you would like to apply to a varying number of arguments? This is where the <strong class="keyWord">*args</strong> and <strong class="keyWord">**kwargs</strong> patterns come in. For example, imagine we want to initialize a class called <code class="inlineCode">Address</code> that uses information gathered from an online web form to create a single string giving an address. 
    <p class="bulletList">We may not know how many elements are going to be in each text box used by the user for the address ahead of time. We could then use the <strong class="keyWord">*args</strong> pattern (you don’t have to call it <strong class="keyWord">args</strong>, so here we’ve called it <code class="inlineCode">address</code>). Here’s the class:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>(<span class="hljs-title">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, *address</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> address:
            self.address = <span class="hljs-literal">None</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'No address given'</span>)
        <span class="hljs-keyword">else</span>:
          self.address = <span class="hljs-string">' '</span>.join(<span class="hljs-built_in">str</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> address)
</code></pre>
<p class="normal">Then your code will work absolutely fine in both of these cases, even though there are a variable number of arguments to the constructor:</p>
<pre class="programlisting code"><code class="hljs-code">address1 = Address(<span class="hljs-string">'62'</span>, <span class="hljs-string">'Lochview'</span>, <span class="hljs-string">'Crescent'</span>)
address2 = Address(<span class="hljs-string">'The Palm'</span>, <span class="hljs-string">'1283'</span>, <span class="hljs-string">'Royston'</span>, <span class="hljs-string">'Road'</span>)
</code></pre>
<p class="normal">Then <code class="inlineCode">address1.address</code> will be given by <code class="inlineCode">'62 Lochview Crescent'</code> and <code class="inlineCode">address2.address</code> will be given by <code class="inlineCode">'The Palm 1283 Royston Road'</code>.</p>
<p class="normal"><strong class="keyWord">**kwargs</strong> extends this idea to allow a variable<a id="_idIndexMarker447"/> number of keyword arguments. This is particularly useful if you have functions where you may want to define a variable number of parameters, but you need names attached to those parameters. For example, we may want to define a class for containing ML model hyperparameter values, the number and names of which will vary by algorithm. We can therefore do something like the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelHyperparameters</span>(<span class="hljs-title">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, **hyperparams</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hyperparams:
            self.hyperparams = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">else</span>:
            self.hyperparams = hyperparams
</code></pre>
<p class="normal">Then the code will allow us to define instances such as the following:</p>
<pre class="programlisting code"><code class="hljs-code">hyp1 = ModelHyperparameters(eps=<span class="hljs-number">3</span>, distance=<span class="hljs-string">'euclidean'</span>)
hyp2 = ModelHyperparameters(n_clusters=<span class="hljs-number">4</span>, max_iter=<span class="hljs-number">100</span>)
</code></pre>
<p class="normal">And then <code class="inlineCode">hyp1.hyperparams</code> will be given by <code class="inlineCode">{'eps': 3, 'distance': 'euclidean'}</code> and <code class="inlineCode">hyp2.hyperparams</code> by <code class="inlineCode">{'n_clusters': 4, 'max_iter': 100}</code>.</p>
<p class="normal">There are many more concepts that are important to understand for a detailed understanding of how Python works. For now, these pointers will be enough for us to build<a id="_idIndexMarker448"/> upon throughout the chapter.</p></li>
</ul>
<p class="normal">Now we will consider how to define and organize these elements in a way that makes your code readable and consistent.</p>
<h2 class="heading-2" id="_idParaDest-96">Adhering to standards</h2>
<p class="normal">When you say something<a id="_idIndexMarker449"/> like <em class="italic">adhering to standards</em>, in most contexts, you would be forgiven for half-expecting a sigh and a gigantic eye roll from whoever you were talking to. Standards sound boring and tedious, but they are in fact an extremely important part of making sure that your work is consistent and high quality.</p>
<p class="normal">In Python, the <em class="italic">de facto</em> standard for coding style is <strong class="keyWord">Python Enhancement Proposal 8</strong> (<strong class="keyWord">PEP-8</strong>), written by Guido Van<a id="_idIndexMarker450"/> Rossum (the creator of Python), Barry Warsaw, and Nick Coghlan (<a href="https://www.python.org/dev/peps/pep-0008/"><span class="url">https://www.python.org/dev/peps/pep-0008/</span></a>). It is essentially a collection of guidelines, tips, tricks, and suggestions for making code<a id="_idIndexMarker451"/> that is consistent and readable. Some of the benefits of adhering to the PEP-8 style guide in your Python projects are as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Greater consistency</strong>: This will help you write code<a id="_idIndexMarker452"/> that is less likely to break once you have deployed it, as it is much easier to follow the flow of your programs and identify errors and bugs. Consistency also helps simplify the design of extensions and interfaces to your code.</li>
<li class="bulletList"><strong class="keyWord">Improved readability</strong>: This begets efficiency, as colleagues and even users of your solutions can understand what is being done and how to use it more effectively.</li>
</ul>
<p class="normal">So, what is in the PEP-8 style guide? And how should you think about applying it to your ML project? For the full details, I recommend you read the PEP-8 documentation given earlier. But in the next few paragraphs, we will go into some of the details that will give you the greatest improvement to your code for the least effort.</p>
<p class="normal">First, let’s cover <strong class="keyWord">naming conventions</strong>. When you write a piece<a id="_idIndexMarker453"/> of code, you will have to create several variables, files, and other objects, such as classes, and these all have to have a name. Making sure that these names are readable and consistent is the first part of making your code of a very high standard.</p>
<p class="normal">Some of the key pointers from PEP-8 are as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Variables and function names</strong>: It is recommended that these<a id="_idIndexMarker454"/> consist<a id="_idIndexMarker455"/> of all lowercase words, separated by underscores. They should also help us understand what they are for. As an example, if you are building a regression model and you want to put some of your feature engineering steps inside a function to simplify reuse and readability elsewhere in the code, you may call it something like <code class="inlineCode">Makemydata()</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">Makemydata</span>():
    <span class="hljs-comment"># steps go here …</span>
    <span class="hljs-keyword">return</span> result
</code></pre>
<p class="normal">Calling your function <code class="inlineCode">Makemydata()</code> is not a great idea, whereas naming it something like <code class="inlineCode">transform_features</code> is better:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">transform_features</span>()
    <span class="hljs-comment"># steps go here …</span>
    <span class="hljs-keyword">return</span> result
</code></pre>
<p class="normal">This function<a id="_idIndexMarker456"/> name is compliant<a id="_idIndexMarker457"/> with PEP-8.</p></li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord">Modules and packages</strong>: The recommendation is that these have all short<a id="_idIndexMarker458"/> lowercase names. Some great examples<a id="_idIndexMarker459"/> are ones you are familiar with, such as <code class="inlineCode">pandas</code>, <code class="inlineCode">numpy</code>, and <code class="inlineCode">scipy</code>. <strong class="keyWord">Scikit-learn</strong> may seem like it breaks this rule, but it actually doesn’t as the package name is <code class="inlineCode">sklearn</code>. The style guide mentions that modules can have underscores to improve readability, but packages should not. If we had a module in a package called <code class="inlineCode">transform_helpers</code>, then this is acceptable, but an entire package called <code class="inlineCode">marketing_outlier_detection</code> would be terrible!</li>
<li class="bulletList"><strong class="keyWord">Classes</strong>: Classes should have names<a id="_idIndexMarker460"/> such as <code class="inlineCode">OutlierDetector</code>, <code class="inlineCode">Transformer</code>, or <code class="inlineCode">PipelineGenerator</code>, which clearly specify what they do and also follow the upper CamelCase or PascalCase (both mean the same thing) style.</li>
</ul>
<p class="normal">These are some of the most commonly used naming conventions you should be aware of. The PEP-8 document also covers a lot of good points on whitespace and the formatting of lines that we will not go into here. We will finish this section with a discussion on some of the author’s favorite suggestions from the <em class="italic">programming recommendations</em> of PEP-8. These are often overlooked and, if forgotten, can make for some code that is both horrible to read and likely to break, so take heed!</p>
<p class="normal">A good point to remember in all of this talk about style is that at the top of the PEP-8 document, which states that <em class="italic">Foolish Consistency is the Hobgoblin of Little Minds</em> and that there are good reasons to ignore these style suggestions in certain circumstances. Again, read the PEP-8 document<a id="_idIndexMarker461"/> for the full works, but if you follow these points, then in general, you will write clean and readable code.</p>
<p class="normal">Next, we will cover how some of these rules do not really apply when we are using the Python API for Apache Spark.</p>
<h2 class="heading-2" id="_idParaDest-97">Writing good PySpark</h2>
<p class="normal">In this section, we draw attention<a id="_idIndexMarker462"/> to one particular flavor of Python that is very important in the world of data science and ML. PySpark code has already been used in examples throughout this book since it is the go-to tool for distributing your data workloads, including your ML models. In <em class="chapterRef">Chapter 6</em>, <em class="italic">Scaling Up</em>, we will learn more about PySpark, but here we will just briefly mention some points on coding style.</p>
<p class="normal">As mentioned in the section on <em class="italic">Spark ML pipelines</em> in <em class="chapterRef">Chapter 3</em>, <em class="italic">From Model to Model Factory</em>, since Spark is written in Scala, the syntax of PySpark (which is just the Python API for Spark) has inherited a lot of the syntactical style from that underlying language. This means in practice that many of the methods you use will be written in CamelCase, meaning that it also makes sense to define your variables using CamelCase rather than the standard Python PEP-8 naming convention of words separated by underscores. This is behavior that we should encourage as it helps people reading our code to clearly see which sections are PySpark code and which are (more) vanilla Python. To emphasize this, when we used the <code class="inlineCode">StringIndexer</code> object from the <code class="inlineCode">pyspark.ml</code> package before, we used <code class="inlineCode">StringIndexer</code> instead of the more idiomatic Python, <code class="inlineCode">string_indexer</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> pyspark.ml.feature <span class="hljs-keyword">import</span> StringIndexer
stringIndexer = StringIndexer(inputCol=categoricalCol,
                              outputCol=categoricalCol)
</code></pre>
<p class="normal">Another important point<a id="_idIndexMarker463"/> about PySpark code is that because Spark is written in a functional paradigm, it also makes sense that your code also follows this style. We will understand a bit more about what this means in the next section.</p>
<h1 class="heading-1" id="_idParaDest-98">Choosing a style</h1>
<p class="normal">This section will provide a summary<a id="_idIndexMarker464"/> of two coding styles or paradigms, which make use of different organizational principles and capabilities of Python. Whether you write your code in an object-oriented or functional style could just be an aesthetic choice. </p>
<p class="normal">This choice, however, can also provide other benefits, such as code that is more aligned with the logical elements of your problem, code that is easier to understand, or even more performant code.</p>
<p class="normal">In the following sections, we will outline the main principles of each paradigm and allow you to choose for yourself based on your use case.</p>
<h2 class="heading-2" id="_idParaDest-99">Object-oriented programming</h2>
<p class="normal"><strong class="keyWord">Object-oriented programming</strong> (<strong class="keyWord">OOP</strong>) is a style where the code is organized<a id="_idIndexMarker465"/> around, you guessed it, abstract<a id="_idIndexMarker466"/> objects with relevant attributes and data instead of around the logical flow of your solution. The subject of OOP is worth a book (or several books!) in itself, so we will focus on the key points that are relevant to our ML engineering journey.</p>
<p class="normal">First, in OOP, you have to define your <code class="inlineCode">objects</code>. This is done in Python through the core OOP principle of classes, which are definitions of structures in your program that keep together related data and logical elements. A class is a template for defining the objects in OOP. As an example, consider a very simple class that groups together some methods for calculating numerical outliers on a dataset. For example, if we consider the pipelines that we looked into in <em class="chapterRef">Chapter 3</em>, <em class="italic">From Model to Model Factory</em>, we may want to have something that makes this even easier to apply in a production setting. We may therefore want to wrap up some of the functionality provided by tools such as Scikit-Learn into a class of its own that could have bespoke steps specific to our problem. In the simplest case, if we wanted a class to wrap the standardization of our data and then apply a generic outlier detection model, it could look something like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">OutlierDetector</span>(<span class="hljs-title">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, model=</span><span class="hljs-literal">None</span>):
        <span class="hljs-keyword">if</span> model <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.model = model
        self.pipeline = make_pipeline(StandardScaler(), self.model)
    <span class="hljs-keyword">def</span> <span class="hljs-title">detect</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">return</span> self.pipeline.fit(data).predict(data)
</code></pre>
<p class="normal">All this example does is allow a user to skip writing out some of the steps that they may have to otherwise write to get the job done. The code doesn’t disappear; it just gets placed inside a handy object with a clear logical definition. In this case, the pipeline shown is extremely simple, but we can imagine extending this to something very complex and containing logic that’s specific to our use case. </p>
<p class="normal">Therefore, if we have already defined an outlier detection model (or retrieved it from a model store, such as MLflow, as discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">From Model to Model Factory</em>), we can then feed this into this class and run quite complex pipelines just with a single line of code, no matter the complexity contained within the class:</p>
<pre class="programlisting code"><code class="hljs-code">model = IsolationForest(contamination=outliers_fraction,
                        random_state=<span class="hljs-number">42</span>)
detector = OutlierDetector(model=model)
result = detector.detect(data)
</code></pre>
<p class="normal">As you can see from the example, this pattern of implementation seems familiar, and it should! <strong class="keyWord">Scikit-learn</strong> has a lot of OOP in it, and you use this paradigm every time you create a model. The act of creating a model is a case of you instantiating a class object, and the process of you calling <code class="inlineCode">fit</code> or <code class="inlineCode">predict</code> on your data are examples of calling class methods. So, the reason the preceding code may not seem alien is that it shouldn’t! We’ve already been using OOP when working with ML with Scikit-Learn.</p>
<p class="normal">Despite what we have just said, using objects and understanding how to build them are obviously two different challenges. So, let’s go through the core concepts of building your own classes. This will set us up later for building more classes of relevance for our own ML solutions.</p>
<p class="normal">First, you see from the preceding<a id="_idIndexMarker467"/> code snippet that a class<a id="_idIndexMarker468"/> is defined with the <code class="inlineCode">class</code> keyword and that the PEP-8 convention<a id="_idIndexMarker469"/> is to use upper CamelCase for the class name. It is also good practice to make your class names clear definitions of <em class="italic">things that do stuff</em>. For example, <code class="inlineCode">OutlierDetector</code>, <code class="inlineCode">ModelWrapper</code>, and <code class="inlineCode">DataTransformer</code> are good class names, but <code class="inlineCode">Outliers</code> and <code class="inlineCode">Calculation</code> are not. You will also notice that we have something in brackets after the name of the class. This tells the class which objects to inherit functionality from. In the preceding<a id="_idIndexMarker470"/> example, we can see that this class inherits from something called <code class="inlineCode">object</code>. This is actually the built-in base class in Python from which <em class="italic">all other objects inherit</em>. Therefore, since the class we defined does not inherit from anything more complex than <code class="inlineCode">object</code>, you can think of this as essentially saying <em class="italic">the class we are about to build will have all of the functionality it needs defined within it; we do not need to use more complex functionality already defined in other objects for this class</em>. The syntax showing the inheritance from <code class="inlineCode">object</code> is actually superfluous as you can just omit the brackets and write <code class="inlineCode">OutlierDetector</code>, but it can be good practice to make the inheritance explicit.</p>
<p class="normal">Next, you can see that the functionality we want to group together is defined inside the class. Functions that live inside a class are called methods. You can see that <code class="inlineCode">OutlierDetector</code> has only one method, called <code class="inlineCode">detect</code>, but you are not limited in how many methods your class can have. </p>
<p class="normal">Methods contain your class’s abilities to interact with data and other objects, so their definition is where most of the work of building up your class goes.</p>
<p class="normal">You might think we have missed a method, the one called <code class="inlineCode">__init__()</code>. This is in fact not a method (or you can think of it as a very special method) and is called the <em class="italic">constructor</em>. The constructor<a id="_idIndexMarker471"/> does what it says—it constructs! Its job is to perform all of the relevant setup tasks (some of which occur in the background, such as memory allocation) for your class when it gets initialized as an object. When the example defines <code class="inlineCode">detector</code>, the constructor is called. As you can see, you can pass variables and then these variables can be used within the class. Classes in Python can be created without defining an explicit constructor, but one will be created in the background. The final point we will make on constructors is that they are not allowed to return anything other than <code class="inlineCode">None</code>, so it’s common to leave the <code class="inlineCode">return</code> statement unwritten.</p>
<p class="normal">You will also have seen in the example that there are variables inside the class and there is a somewhat mysterious <code class="inlineCode">self</code> keyword. This allows methods and operations inside the class to refer to the particular instance of the class. So, if you define two or a hundred instances of the <code class="inlineCode">OutlierDetector</code> object, it is possible for them all to have different values for their internal attributes but still have the same functionality.</p>
<p class="normal">We will create some more involved OOP styles<a id="_idIndexMarker472"/> for your ML solution<a id="_idIndexMarker473"/> later, but for now, let’s discuss the other programming paradigm that we may want to use – functional programming.</p>
<h2 class="heading-2" id="_idParaDest-100">Functional programming</h2>
<p class="normal"><strong class="keyWord">Functional programming</strong> is based on the concept <a id="_idIndexMarker474"/>of, you guessed<a id="_idIndexMarker475"/> it, functions. At its core, this programming paradigm is about trying to write pieces of code that only take in data and output data, doing so without creating any internal state that can be changed. One of the goals of functional programming is to write code that has no unintended side effects due to mismanagement of state. It also has the benefit of making sure that the data flow in your programs can be understood completely by looking at the <code class="inlineCode">return</code> statements of the functions you have written.</p>
<p class="normal">It uses the idea of the data in your program<a id="_idIndexMarker476"/> not being allowed to change in place. This concept is known as <strong class="keyWord">immutability</strong>. If your data (or any object) is immutable, it means that there is no internal state to modify, and if you want to do something with the data, you actually have to create new data. For example, in the section on <em class="italic">Object-oriented programming</em>, we again revisited the concept of standardizing data. In a functional program, standardized data cannot overwrite unstandardized data; you would need to store this new data somewhere, for example, in a new column in the same data structure.</p>
<p class="normal">Some programming languages<a id="_idIndexMarker477"/> are designed with functional principles at their core, such<a id="_idIndexMarker478"/> as F# and Haskell, but Python is a general-purpose language that can accommodate both paradigms quite nicely.</p>
<p class="normal">You will likely have seen some other functional programming concepts in other Python code. For example, if you have ever used a lambda function, then this can be a powerful aspect of a functionally programmed piece of code as it is how you define <em class="italic">anonymous functions</em> (those without a specified name). So, you may have seen code that looks something like this:</p>
<pre class="programlisting code"><code class="hljs-code">df[<span class="hljs-string">'data_squared'</span>] = df[<span class="hljs-string">'data'</span>].apply(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>)
</code></pre>
<p class="normal">In the preceding code block, <code class="inlineCode">df</code> is a pandas DataFrame and <code class="inlineCode">data</code> is just a column of numbers. This is one of the tools that help make functional programming in Python easier. Other such tools are the built-in functions <code class="inlineCode">map()</code>, <code class="inlineCode">reduce()</code>, and <code class="inlineCode">filter()</code>.</p>
<p class="normal">As an example, imagine that we have some address data similar to that in the <em class="italic">Recapping the basics</em> section, where we discussed the concepts of <strong class="keyWord">args</strong> and <strong class="keyWord">**kwargs</strong>:</p>
<pre class="programlisting code"><code class="hljs-code">data = [
    [<span class="hljs-string">'The'</span>, <span class="hljs-string">'Business'</span>, <span class="hljs-string">'Centre'</span>, <span class="hljs-string">'15'</span>, <span class="hljs-string">'Stevenson'</span>, <span class="hljs-string">'Lane'</span>],
    [<span class="hljs-string">'6'</span>, <span class="hljs-string">'Mossvale'</span>, <span class="hljs-string">'Road'</span>],
    [<span class="hljs-string">'Studio'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'Tottenham'</span>, <span class="hljs-string">'Court'</span>, <span class="hljs-string">'Road'</span>]
    ]
</code></pre>
<p class="normal">Now, we might want to write some code that returns a list of lists with the same shape as this data, but every entry now contains the number of characters in each string. This could be a stage in a data preparation step in one of our ML pipelines. If we wanted to write some code to do this functionally, we could define a function that takes a list and returns a new list with the string lengths for the entries like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">len_strings_in_list</span>(<span class="hljs-params">data_list</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x), data_list))
</code></pre>
<p class="normal">This embodies functional programming because the data is immutable (there is no change of internal state) and the function is pure (it only uses data within the scope of the function). We can then use another concept<a id="_idIndexMarker479"/> from functional programming called higher-order functions, where you supply functions as the arguments of other functions. For example, we may want to define a function that can apply any list-based function but to a list of lists:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">list_of_list_func_results</span>(<span class="hljs-params">list_func, list_of_lists</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: list_func(x), list_of_lists))
</code></pre>
<p class="normal">Note that this is completely generic; as long as the <code class="inlineCode">list_func()</code> can be applied to a list, this will work on a list of lists. We can therefore get the original result we wanted by calling the following:</p>
<pre class="programlisting code"><code class="hljs-code">list_of_list_func_results(len_strings_in_list, data)
</code></pre>
<p class="normal">This returns the desired result:</p>
<pre class="programlisting con"><code class="hljs-con">[[3, 8, 6, 2, 9, 4], [1, 8, 4], [6, 1, 9, 5, 4]]
</code></pre>
<p class="normal">Spark, a tool that’s already<a id="_idIndexMarker480"/> been used multiple times in this book, is written in the Scala<a id="_idIndexMarker481"/> language, which is also general-purpose and can accommodate both object-oriented and functional programming. Spark is predominantly written in a functional style; its aim of distributing computation is more easily accommodated if principles such as immutability are respected. This means that when we have been typing PySpark code through this book, we have subtly been picking up some functional programming practices (did you notice?).</p>
<p class="normal">In fact, in <em class="chapterRef">Chapter 3</em>, <em class="italic">From Model to Model Factory</em>, the example PySpark pipeline we built had code like this:</p>
<pre class="programlisting code"><code class="hljs-code">data = data.withColumn(<span class="hljs-string">'label'</span>, f.when((f.col(<span class="hljs-string">"y"</span>) == <span class="hljs-string">"yes"</span>),
                        <span class="hljs-number">1</span>).otherwise(<span class="hljs-number">0</span>))
</code></pre>
<p class="normal">This is functional since the <code class="inlineCode">data</code> object we create is actually a new DataFrame with the new column added—we can’t just add a column in place. There was also code that formed part of our pipelines from the Spark ML library:</p>
<pre class="programlisting code"><code class="hljs-code">scaler = StandardScaler(inputCol=<span class="hljs-string">'numerical_cols_imputed'</span>,
                        outputCol=<span class="hljs-string">"numerical_cols_imputed_scaled"</span>)
</code></pre>
<p class="normal">This is defining how to take a series of columns in a DataFrame and perform a scaling transformation on them. Note how you define input columns and output columns, and <em class="italic">these cannot be the same</em>. That’s immutability in action—you have to create new data rather than transform it in place.</p>
<p class="normal">Hopefully, this gives you a taste of functional programming in Python. This is not the main paradigm we will use in this book, but it will be used for some pieces of code, and, in particular, remember that when we use PySpark, we are often implicitly<a id="_idIndexMarker482"/> using functional<a id="_idIndexMarker483"/> programming.</p>
<p class="normal">We will now discuss ways of packaging the code that you have written.</p>
<h1 class="heading-1" id="_idParaDest-101">Packaging your code</h1>
<p class="normal">In some ways, it is interesting that Python<a id="_idIndexMarker484"/> has taken the world by storm. It is dynamically typed and non-compiled, so it can be quite different to work with compared to Java or C++. This particularly comes to the fore when we think about packaging our Python solutions. For a compiled language, the main target is to produce a compiled artifact that can run on the chosen environment – a Java <code class="inlineCode">jar</code>, for example. Python requires that the environment you run in has an appropriate Python interpreter and the ability to install the libraries and packages you need. There is also no single compiled artifact created, so you often need to deploy your whole code base as is.</p>
<p class="normal">Despite this, Python has indeed taken the world by storm, especially for ML. As we are ML engineers thinking about taking models to production, we would be remiss to not understand how to package and share Python code in a way that helps others to avoid repetition, trust in the solution, and be able to easily integrate it with other projects.</p>
<p class="normal">In the following sections, we are first<a id="_idIndexMarker485"/> going to discuss what we mean by a user-defined library and some of the advantages of packaging your code this way. We are then going to define the main ways you can do this so that you can run your ML code in production.</p>
<h2 class="heading-2" id="_idParaDest-102">Why package?</h2>
<p class="normal">Before we discuss in detail exactly<a id="_idIndexMarker486"/> what a package or library is in Python, we can articulate the advantages by using a working definition of <em class="italic">a collection of Python code that can be run without detailed knowledge of its implementation</em>.</p>
<p class="normal">You will have already picked up from this definition<a id="_idIndexMarker487"/> the nature of the first reason to do this: <strong class="keyWord">abstraction</strong>.</p>
<p class="normal">Bringing together your code into a library or package that can be reused by other developers and data scientists in your team, organization, or the wider community allows these user groups to solve problems more quickly. Since the details of the work are abstracted away, anyone using your code can focus on implementing the capabilities of your solution, rather than trying to understand and dissect every line. This will lead to reduced development and deployment time in projects, as well as encourage the usage of your code in the first place!</p>
<p class="normal">The second advantage is that, by consolidating the functionality you need into a library or package, you bring all of the implementation details to one place and therefore <em class="italic">improvements scale</em>. What we mean by this is if 40 projects are using your library and someone discovers a minor bug, you only need to patch it <em class="italic">once</em> and then redeploy or update the package in those 40 implementations. </p>
<p class="normal">This is way more scalable than explaining the issue to the relevant teams and getting 40 different fixes at the implementation end. This consolidation also means that once you have thoroughly tested all the components, you can more confidently assume that this solution will be running smoothly in those 40 different projects, without knowing anything about the details under the hood.</p>
<p class="normal"><em class="italic">Figure 4.1</em> helps to show how packages helpfully allow a <em class="italic">write once, use many</em> philosophy for your code, which is incredibly important if you want to engineer ML solutions that can solve multiple problems in a scalable fashion:</p>
<figure class="mediaobject"><img alt="Figure 4.2 – Developing packages for your ML solutions allows you to write the code once but use it many times in different environments " height="402" src="../Images/B19525_04_01.png" width="672"/></figure>
<p class="packt_figref">Figure 4.1: Developing packages for your ML solutions allows you to write the code once but use it many times in different environments.</p>
<p class="normal">The next section<a id="_idIndexMarker488"/> will build on these main ideas about packaging to discuss specified use cases in which packaging our code can be beneficial.</p>
<h2 class="heading-2" id="_idParaDest-103">Selecting use cases for packaging</h2>
<p class="normal">First things first, not all of your solutions<a id="_idIndexMarker489"/> should be libraries. If you have an extremely<a id="_idIndexMarker490"/> simple use case, you may only need one simple script to run on a schedule for the core of your ML solution. You can still write a well-engineered system and performant code in this case, but it’s not a library. Similarly, if your problem is best solved by a web app, then although there will be lots of components, it will not naturally be a library.</p>
<p class="normal">Some good reasons you may want to write up your solution as a library or package are as follows:</p>
<ul>
<li class="bulletList">The problem your code solves is a common one that may come up in multiple projects or environments.</li>
<li class="bulletList">You want to abstract away implementation details so that execution and development are decoupled, making it easier for others to use your code.</li>
<li class="bulletList">To minimize the number of places and the number of times you need to change code to implement bug fixes.</li>
<li class="bulletList">To make testing simpler.</li>
<li class="bulletList">To simplify your <strong class="keyWord">continuous integration/continuous deployment</strong> (<strong class="keyWord">CI/CD</strong>) pipeline.</li>
</ul>
<p class="normal">We will now dive into how we might go about designing our packages.</p>
<h2 class="heading-2" id="_idParaDest-104">Designing your package</h2>
<p class="normal">The layout of your code base<a id="_idIndexMarker491"/> is far more than just a stylistic consideration. It is something that will determine how your code is used in every instance of the project – no pressure!</p>
<p class="normal">This means that it is important to put some thought into how you want to lay out your code and how this influences usage patterns. You need to ensure that all of the main components you need have a presence in the code base and are easy to find.</p>
<p class="normal">Let’s work this through with an example based on the outlier detection case we worked through in the previous sections.</p>
<p class="normal">First, we need to decide what kind of solution we want to create. Are we building something that will run a web application or a standalone executable with lots of functionality, or are we building a library for others to use in their ML projects? In fact, we can choose to do more than one thing! For this case, let’s build a package that can be imported for use in other projects but can also run in a standalone execution mode.</p>
<p class="normal">To set the context for the development of our package, imagine we have been asked to start building a solution that can run a set of selected unsupervised outlier detection models. The data scientists have found that, for the problem at hand, <code class="inlineCode">Isolation</code> <code class="inlineCode">Forest</code> models are the most performant, but they must be retrained on every run and the users of the package should be able to edit the configuration of the models through a config file. Only <code class="inlineCode">sklearn</code> models have been studied so far, but the business and users of the package would like this functionality to be extensible to other modeling tools if needed. The technical requirements for this project mean we cannot use MLflow. </p>
<p class="normal">Don’t worry; in later chapters when we build more examples, we will relax this constraint to show how it all fits together:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">The package<a id="_idIndexMarker492"/> we are going to build is all about outliers, so let’s call it <code class="inlineCode">outliers</code> (I know, inventive, right?). Just to make it clear how everything hangs together, we will start to build the <code class="inlineCode">outliers</code> package in a folder called <code class="inlineCode">outlier_package</code>:
        <pre class="programlisting code"><code class="hljs-code">outlier_package/
├── outliers/
</code></pre>
</li>
<li class="numberedList">Our package design will be based on the functionality we want the solution to have; in this case, we want something that detects outliers, so let’s create a sub-package called <code class="inlineCode">detectors</code>:
        <pre class="programlisting code"><code class="hljs-code">outlier_package/
├── outliers/
           ├── detectors
</code></pre>
</li>
<li class="numberedList">Within this, we will put some code that wraps (more on this later) around some basic models from external libraries. We will also want some code that gets data for us to analyze, so we will add a sub-package for that too:
        <pre class="programlisting code"><code class="hljs-code">outlier_package/
├── outliers/
           ├── detectors
           ├── data
</code></pre>
</li>
<li class="numberedList">We can already see our package taking shape. Finally, we will want to have somewhere to store configuration information and somewhere to store helper functions that may be used across the package, so let’s add a directory and sub-package for those too:
        <pre class="programlisting code"><code class="hljs-code">outlier_package/
├── outliers/
           ├── detectors
           ├── data
           ├── configs
           ├── utils
</code></pre>
<p class="normal">Now, this layout<a id="_idIndexMarker493"/> is not sacrosanct or dictated in any way. We can create the layout however we want and do whatever we think makes sense. </p>
<p class="normal">It is important when doing this, though, to always remember the principles of <strong class="keyWord">Don’t Repeat Yourself </strong>(<strong class="keyWord">DRY</strong>), <strong class="keyWord">Keep It Simple, Stupid</strong> (<strong class="keyWord">KISS</strong>), and the Python mantra of <em class="italic">there should preferably be only one way to do something</em>. If you stick to these<a id="_idIndexMarker494"/> principles, you <a id="_idIndexMarker495"/>will be fine. For more information<a id="_idIndexMarker496"/> on these<a id="_idIndexMarker497"/> principles, see <a href="https://code.tutsplus.com/tutorials/3-key-software-principles-you-must-understand--net-25161"><span class="url">https://code.tutsplus.com/tutorials/3-key-software-principles-you-must-understand--net-25161</span></a> and <a href="https://www.python.org/dev/peps/pep-0020/"><span class="url">https://www.python.org/dev/peps/pep-0020/</span></a>.</p>
<p class="normal">So, what actually goes in each of these sub-packages? Well, the underlying code of course!</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">In this case, we will want something to provide an interface between our detector implementations and the syntax for creating a pipeline and calling them, so we will build a simple class and keep it in <code class="inlineCode">pipelines.py</code>. The <code class="inlineCode">pipelines.py</code> file contains the following code:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler
<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> make_pipeline

<span class="hljs-keyword">class</span> <span class="hljs-title">OutlierDetector</span>(<span class="hljs-title">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, model=</span><span class="hljs-literal">None</span>):
        <span class="hljs-keyword">if</span> model <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.model = model
        self.pipeline = make_pipeline(StandardScaler(), self.model)
    <span class="hljs-keyword">def</span> <span class="hljs-title">detect</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">return</span> self.pipeline.fit(data).predict(data)
</code></pre>
</li>
<li class="numberedList">We then also need something<a id="_idIndexMarker498"/> to define the models we want to interface with. In this case, we will create code that uses information stored in a configuration file to decide which of a select few models to instantiate. We put all this functionality in a class called <code class="inlineCode">DetectionModels</code>. For brevity, we omit the details of each of the functions in the class in this first instance:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> IsolationForest

<span class="hljs-keyword">class</span> <span class="hljs-title">DetectionModels</span>(<span class="hljs-title">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, model_config_path=</span><span class="hljs-literal">None</span>):
....
    <span class="hljs-keyword">def</span> <span class="hljs-title">create_model</span>(<span class="hljs-params">self, model_name=</span><span class="hljs-literal">None</span><span class="hljs-params">, params=</span><span class="hljs-literal">None</span>):
....
    <span class="hljs-keyword">def</span> <span class="hljs-title">get_models</span>(<span class="hljs-params">self</span>):
....
</code></pre>
</li>
<li class="numberedList">The initialization method is expanded here. Notice that we wrote this code so that we could define a series of models in the <code class="inlineCode">config</code> file:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">DetectionModels</span>(<span class="hljs-title">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, model_config_path=</span><span class="hljs-literal">None</span>):
        <span class="hljs-keyword">if</span> model_config_path <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(model_config_path) <span class="hljs-keyword">as</span> w:
                self.model_def = json.load(w)
</code></pre>
</li>
<li class="numberedList">Then the <code class="inlineCode">create_model</code> method is able to instantiate the model based on parameter and model name information. We have also built this so that we can actually pull in configuration information for models from different libraries if we wanted to; we would just need to add the appropriate implementation logic in this <code class="inlineCode">create_model</code> function, checking that <code class="inlineCode">sklearn</code> or another model was defined and running the appropriate syntax in each case. We would also have to make sure the pipeline generated in <code class="inlineCode">OutlierDetector</code> was appropriate in each case as well:
        <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span> <span class="hljs-title">create_model</span>(<span class="hljs-params">self, model_name=</span><span class="hljs-literal">None</span><span class="hljs-params">, params=</span><span class="hljs-literal">None</span>):
        <span class="hljs-keyword">if</span> model_name <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> params <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">if</span> model_name == <span class="hljs-string">'IsolationForest'</span> <span class="hljs-keyword">and</span> params <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> IsolationForest(**params)
</code></pre>
</li>
<li class="numberedList">Finally, we bring the preceding<a id="_idIndexMarker499"/> methods together through the <code class="inlineCode">get_models</code> method, which returns a list of all models defined in the appropriate config file, instantiated as a <code class="inlineCode">sklearn</code> object via the <code class="inlineCode">create_model</code> method:
        <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span> <span class="hljs-title">get_models</span>(<span class="hljs-params">self</span>):
        models = []
        <span class="hljs-keyword">for</span> model_definition <span class="hljs-keyword">in</span> self.model_def:
            defined_model = self.create_model(
                model_name=model_definition[<span class="hljs-string">'model'</span>],
                params=model_definition[<span class="hljs-string">'params'</span>]
            )
            models.append(defined_model)
        <span class="hljs-keyword">return</span> models
</code></pre>
<p class="normal">You may be thinking <em class="italic">why not just read in the appropriate model and apply it, no matter what it is?</em> That could be a viable solution, but what we have done here means that only model types and algorithms that have been approved by the team working on the project can make it through to production, as well as permitting the use of heterogeneous model implementations.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="10">To see how this could all work<a id="_idIndexMarker500"/> in practice, let’s define a script called <code class="inlineCode">__main__.py</code> at the uppermost level of the package, which can act as the main entry point for the execution of modeling runs:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> utils.data <span class="hljs-keyword">import</span> create_data
<span class="hljs-keyword">from</span> detectors.detection_models <span class="hljs-keyword">import</span> DetectionModels
<span class="hljs-keyword">import</span> detectors.pipelines
<span class="hljs-keyword">from</span> definitions <span class="hljs-keyword">import</span> MODEL_CONFIG_PATH

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    data = create_data()
    models = DetectionModels(MODEL_CONFIG_PATH).get_models()
    <span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> models:
        detector = detectors.pipelines.OutlierDetector(model=model)
        result = detector.detect(data)
        <span class="hljs-built_in">print</span>(result)
</code></pre>
</li>
<li class="numberedList">The <code class="inlineCode">model_config.json</code> file referred to here is given by the following code:
        <pre class="programlisting code"><code class="hljs-code">[
  {
    <span class="hljs-string">"model"</span>: <span class="hljs-string">"IsolationForest"</span>,
    <span class="hljs-string">"params"</span>: {
      <span class="hljs-string">"contamination"</span>: <span class="hljs-number">0.15</span>,
      <span class="hljs-string">"random_state"</span>: <span class="hljs-number">42</span>
    }
  }
]
</code></pre>
</li>
<li class="numberedList">The <code class="inlineCode">definitions.py</code> file is a file <a id="_idIndexMarker501"/>that holds relevant paths and other variables that we want to make globally accessible in the package without polluting the namespace:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> os

ROOT_DIR = os.path.dirname(__file__)
MODEL_CONFIG_PATH = os.path.join(ROOT_DIR, <span class="hljs-string">"</span><span class="hljs-string">configs/model_config.</span>
<span class="hljs-string">                                 json"</span>)
</code></pre>
<p class="normal">We can see that we don’t really do anything with the results; we just print them to show that output is produced. But in reality, you will either push these results elsewhere or calculate statistics on them.</p>
<p class="normal">This script can be run by typing this in your terminal:</p>
<pre class="programlisting con"><code class="hljs-con">python __main__.py
</code></pre>
<p class="normal">Alternatively, you could type the following:</p>
<pre class="programlisting con"><code class="hljs-con">python -m outliers
</code></pre>
<p class="normal">And that is how you can package functionality into classes, modules, and packages. The example given was relatively constrained, but it does give us an awareness of how the different pieces can be brought together and executed.</p></li>
</ol>
<div class="note">
<p class="normal">IMPORTANT NOTE</p>
<p class="normal">The example given here has been built up to show you how to hang your code together by using some of the techniques discussed in this chapter. It is not necessarily the only way to bring all of these bits together, but it does act as a good illustration of how to create your own package. So, just remember that if you see a way to improve this implementation<a id="_idIndexMarker502"/> or adapt it to your own purposes, then brilliant!</p>
</div>
<p class="normal">In the next section, we will explore how to build distributions of this code and how to allow ourselves and users to install the <code class="inlineCode">outliers</code> package as a normal Python package that we can use in other projects.</p>
<h1 class="heading-1" id="_idParaDest-105">Building your package</h1>
<p class="normal">In our example, we can package<a id="_idIndexMarker503"/> up our solution using the <code class="inlineCode">setuptools</code> library. In order to do this, you must create a file called <code class="inlineCode">setup.py</code> that contains the important metadata for your solution, including the location of the relevant packages it requires. An example of <code class="inlineCode">setup.py</code> is shown in the following code block. This shows how to do this for a simple package that wraps some of the outlier detection functionality we have been mentioning in this chapter:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup

setup(name=<span class="hljs-string">'outliers'</span>,
      version=<span class="hljs-string">'0.1'</span>,
      description=<span class="hljs-string">'A simple package to wrap some outlier detection</span>
<span class="hljs-string">                   functionality'</span>,
      author=<span class="hljs-string">'Andrew McMahon'</span>,
      license=<span class="hljs-string">'MIT'</span>,
      packages=[<span class="hljs-string">'outliers'</span>],
      zip_safe=<span class="hljs-literal">False</span>)
</code></pre>
<p class="normal">We can see that <code class="inlineCode">setuptools</code> allows you to supply metadata<a id="_idIndexMarker504"/> such as the name of the package, the version number, and the software license. Once you have this file in the root directory of your project, you can then do a few things:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">First, you can install the package locally as an executable. This will mean you can import your library like any other Python library in the code you want to run:
        <pre class="programlisting con"><code class="hljs-con">pip install .
</code></pre>
</li>
<li class="numberedList">You can create a source distribution of the package so that all of the code is bundled together efficiently. For example, if you run the following command at the root of your project, a <code class="inlineCode">gzipped tarball</code> is created in a folder called <code class="inlineCode">dist</code>:
        <pre class="programlisting con"><code class="hljs-con">python setup.py sdist
</code></pre>
</li>
<li class="numberedList">You can create a built distribution of the package, which is an object that can be unpacked and used immediately by the user without them having to run the <code class="inlineCode">setup.py</code> script as in a source distribution. The most appropriate built distribution is what is known as a Python <code class="inlineCode">wheel</code>. Running the following command in the root directory of your project creates the <code class="inlineCode">wheel</code> and puts it in the <code class="inlineCode">dist</code> folder:
        <pre class="programlisting con"><code class="hljs-con">python setup.py bdist_wheel
</code></pre>
</li>
<li class="numberedList">If you are going to distribute your code using pip, then it makes sense to package both a <code class="inlineCode">source</code> distribution and a <code class="inlineCode">wheel</code> and let the user decide what to do. So, you can build both and then use a package called <code class="inlineCode">twine</code> to upload both distributions to PyPI. If you want to do this, then you need to register for a PyPI account at <a href="https://pypi.org/account/register/"><span class="url">https://pypi.org/account/register/</span></a>. Just run the previous two commands together in the root directory of your project and use the <code class="inlineCode">twine upload</code> command:
        <pre class="programlisting con"><code class="hljs-con">python setup.py sdist bdist_wheel
twine upload dist/*
</code></pre>
</li>
</ol>
<p class="normal">For a lot more information<a id="_idIndexMarker505"/> on packaging, you can read through<a id="_idIndexMarker506"/> the information<a id="_idIndexMarker507"/> and tutorials at <a href="https://www.pypa.io/en/latest/"><span class="url">https://www.pypa.io/en/latest/</span></a>, provided by the <strong class="keyWord">Python Packaging Authority</strong> (<strong class="keyWord">PyPA</strong>).</p>
<p class="normal">The next section touches briefly on how we can automate a few of the steps around building and testing our packages using Makefiles.</p>
<h2 class="heading-2" id="_idParaDest-106">Managing your environment with Makefiles</h2>
<p class="normal">If we are on a UNIX system<a id="_idIndexMarker508"/> and we have the <code class="inlineCode">make</code> utility installed, then we can further automate a lot of the steps we want to run for our solution in different scenarios using Makefiles. For example, in the following code block, we have a Makefile that allows us to run our module’s main entry point, run our test suite, or clean up any artifacts using the <code class="inlineCode">run</code>, <code class="inlineCode">test</code>, and <code class="inlineCode">clean</code> targets:</p>
<pre class="programlisting code"><code class="hljs-code">MODULE := outliers
run:
    @python -m <span class="hljs-variable">$(MODULE)</span>
test:
    @pytest
.PHONY: clean test
clean:
    rm -rf .pytest_cache .coverage .pytest_cache coverage.xml
</code></pre>
<p class="normal">This is a very simple Makefile, but we can make it as complex as needed by layering more and more commands. If we want to <code class="inlineCode">run</code> a specific target set of commands, we simply call <code class="inlineCode">make</code>, then the target name:</p>
<pre class="programlisting con"><code class="hljs-con">make test
make run
</code></pre>
<p class="normal">This is a powerful way to abstract out a lot of terminal commands you would otherwise have to manually enter in each case. It also acts as documentation for other users of the solution!</p>
<p class="normal">The example we have just gone<a id="_idIndexMarker509"/> through is quite simple; let’s now make things more sophisticated. We can actually use Makefiles to manage our environments and help streamline our development process so that it does not require lots of cognitive effort just to keep track of the state of our environment.</p>
<p class="normal">The following examples leverage a lot of great work by Kjell Wooding, or <em class="italic">hackalog </em>on GitHub, specifically his repository <a href="https://github.com/hackalog/make_better_defaults"><span class="url">https://github.com/hackalog/make_better_defaults</span></a>. </p>
<p class="normal">This repository formed the basis of his talk at the 2021 PyData Global conference titled “Makefiles: One Great Trick for Making Your Conda Environments More Manageable.”</p>
<p class="normal">First, the inclusion of a <code class="inlineCode">Makefile.help</code> file allows for customizable help prompts when using the <code class="inlineCode">make</code> command. If we run <code class="inlineCode">make</code> in the terminal, assuming we are still in the main project directory, you will see the output in <em class="italic">Figure 4.2</em>.</p>
<figure class="mediaobject"><img alt="" height="141" role="presentation" src="../Images/B19525_04_02.png" width="510"/></figure>
<p class="packt_figref">Figure 4.2: The help presented from the Makefile example.</p>
<p class="normal">This help message has been customized by using the <code class="inlineCode">PROJECT_NAME</code> variable in the main Makefile, which has been set as <code class="inlineCode">mlewp-ed2-ch4-outliers</code>. In fact, the top of the Makefile has several variables set for this project:</p>
<pre class="programlisting code"><code class="hljs-code">MODULE := outliers
PROJECT_NAME := mlewp-ed2-ch4-outliers
PYTHON_INTERPRETER := python3
ARCH := <span class="hljs-variable">$(shell $(PYTHON_INTERPRETER)</span> <span class="hljs-variable">-c</span> <span class="hljs-string">"import platform;</span>
<span class="hljs-string">print(platform.platform())"</span>)
VIRTUALENV := conda
CONDA_EXE ?= ~/anaconda3/bin/conda
EASYDATA_LOCKFILE := environment.<span class="hljs-variable">$(ARCH)</span>.lock.yml
</code></pre>
<p class="normal">The <code class="inlineCode">MODULE</code> variable is referring to the name<a id="_idIndexMarker510"/> of the package as before. <code class="inlineCode">PYTHON_INTERPRETER</code>, <code class="inlineCode">CONDA_EXE</code>, and <code class="inlineCode">VIRTUALENV</code> are hopefully self-explanatory. <code class="inlineCode">ARCH</code> is grabbing architecture information from the local system. <code class="inlineCode">EASYDATA_LOCKFILE</code> refers to a file that will be created as we work that helps us track the full list of dependencies in our project.</p>
<p class="normal">You can see that the help message clearly refers to different targets for the Makefile, so let’s explore each of these in turn. First, in order to standardize the creation of a new Conda environment for the project, if one is required, there are a few steps that can be brought together:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">$(EASYDATA_LOCKFILE)</span>: environment.yml
<span class="hljs-keyword">ifeq</span> (<span class="hljs-built_in">conda</span>, <span class="hljs-variable">$(VIRTUALENV)</span>)
    <span class="hljs-variable">$(CONDA_EXE)</span> env update <span class="hljs-variable">-n</span> <span class="hljs-variable">$(PROJECT_NAME)</span> <span class="hljs-variable">-f</span> $&lt;
    <span class="hljs-variable">$(CONDA_EXE)</span> env export <span class="hljs-variable">-n</span> <span class="hljs-variable">$(PROJECT_NAME)</span> <span class="hljs-variable">-f</span> $@
    <span class="hljs-meta"># pip install -e .  # uncomment for conda &lt;= 4.3</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-variable">$</span>(error Unsupported Environment `<span class="hljs-variable">$(VIRTUALENV)</span>`. Use conda)
<span class="hljs-keyword">endif</span>
.PHONY: create_environment
<span class="hljs-meta"># Set up virtual (conda) environment for this project</span>
create_environment: <span class="hljs-variable">$(EASYDATA_LOCKFILE)</span>
<span class="hljs-keyword">ifeq</span> (conda,$(VIRTUALENV))
    @rm -f $(EASYDATA_LOCKFILE)
    @echo
    @echo <span class="hljs-string">"New conda env created. Activate with:"</span>
    @echo <span class="hljs-string">"&gt;&gt;&gt; conda activate $(PROJECT_NAME)"</span>
    @echo <span class="hljs-string">"&gt;&gt;&gt; make update_environment"</span>
        <span class="hljs-keyword">ifneq</span> (<span class="hljs-string">"X$(wildcard .post-create-environment.txt)"</span>,<span class="hljs-string">"X"</span>)
            @cat .post-create-environment.txt
        <span class="hljs-keyword">endif</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-variable">$</span>(error Unsupported Environment `<span class="hljs-variable">$(VIRTUALENV)</span>`. Use conda)
<span class="hljs-keyword">endif</span>
</code></pre>
<p class="normal">Walking through this step by step, this code states that if <code class="inlineCode">conda</code> is the virtual environment, then proceed<a id="_idIndexMarker511"/> to create or update a Conda environment with the project name and then export the environment into the <code class="inlineCode">environment.yml</code> file; then after that, export the environment configuration into the lock file. It works this way because <code class="inlineCode">$&lt;</code> refers to the first prerequisite (in this case, the <code class="inlineCode">environment.yml</code> file), and <code class="inlineCode">$@</code> refers to the name of the target (in this case, the <code class="inlineCode">EASYDATA_LOCKFILE</code> variable). After this is triggered, the second block is checking if <code class="inlineCode">conda</code> is the virtual env manager before removing the lock file and then providing some guides to the user in the terminal. Note that <code class="inlineCode">@</code> here is referring to terminal commands.</p>
<p class="normal">The next important block in the Makefile is the one that handles updating the environment for you if required, which will often be the case during the “Develop” phase of your project:</p>
<pre class="programlisting code"><code class="hljs-code">.PHONY: update_environment
<span class="hljs-comment">## Install or update Python Dependencies in the virtual (conda) environment</span>
update_environment: environment_enabled<span class="hljs-section"> </span><span class="hljs-variable">$(EASYDATA_LOCKFILE)</span>
    <span class="hljs-keyword">ifneq</span> (<span class="hljs-string">"X$(wildcard .post-update-environment.txt)"</span>,<span class="hljs-string">"X"</span>)
        @cat .post-update-environment.txt
    <span class="hljs-keyword">endif</span>
</code></pre>
<p class="normal">This block ensures that if you run the following command in your terminal:</p>
<pre class="programlisting con"><code class="hljs-con">make update_environment
</code></pre>
<p class="normal">Then you will create a new <code class="inlineCode">lockfile.yml</code> with all of the details of the latest version of the environment. There is also a <code class="inlineCode">delete_environment</code> target that will clear out the lockfiles and remove the Conda environment, as well as some other helper targets that need not concern us here, but that you can explore in the book repository.</p>
<p class="normal">Bringing this all together, the workflow<a id="_idIndexMarker512"/> using this Makefile-based approach would be:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a starter <code class="inlineCode">environment.yml</code> file for the project. This could be very simple; as an example, for the <code class="inlineCode">outliers</code> package that we are building in the chapter, I started with an <code class="inlineCode">environment.yml</code> file that looked something like this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">name:</span> <span class="hljs-string">mlewp-ed2-ch4-outliers</span>
<span class="hljs-attr">channels:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">conda-forge</span>
<span class="hljs-attr">dependencies:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">python=3.10.8</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">scikit-learn</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pandas</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">numpy</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pytest</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pytest-cov</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pip</span>
</code></pre>
</li>
<li class="numberedList">Create the environment with:
        <pre class="programlisting con"><code class="hljs-con">make create_environment
</code></pre>
</li>
<li class="numberedList">Update the environment, which will create the first lockfile:
        <pre class="programlisting con"><code class="hljs-con">make update_environment
</code></pre>
</li>
<li class="numberedList">As you develop your<a id="_idIndexMarker513"/> solution, if you need a new package, go into the <code class="inlineCode">environment.yml</code> file and add the dependency you require before running <code class="inlineCode">make update_environment</code>. The idea here is that by not installing the packages manually but by mandating them in the <code class="inlineCode">environment.yml</code> file, you are creating a more repeatable and robust workflow. 
    <p class="numberedList">It becomes impossible for you to forget what you installed and what you haven’t! For example, if I wanted to add the <code class="inlineCode">bandit</code> package to this environment, I would go into the <code class="inlineCode">environment.yml</code> file using my text editor or IDE and would simply add that dependency in either the <code class="inlineCode">conda</code> or <code class="inlineCode">pip</code> dependency:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">name:</span> <span class="hljs-string">mlewp-ed2-ch4-outliers</span>
<span class="hljs-attr">channels:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">conda-forge</span>
<span class="hljs-attr">dependencies:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">python=3.10.8</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">scikit-learn</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pandas</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">numpy</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pytest</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pytest-cov</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">bandit</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">pip</span>
</code></pre></li>
</ol>
<p class="normal">And that’s it! This is how you can use Makefiles to manage your Conda environments in a far more repeatable way. As mentioned above, if you wanted to start again, you can delete the environment by running:</p>
<pre class="programlisting con"><code class="hljs-con">make delete_environment
</code></pre>
<p class="normal">That covers this particular method<a id="_idIndexMarker514"/> for managing your Python development environment when developing your packages. We will now move on to discuss one of the most popular tools for Python dependency management and packaging in use today, <strong class="keyWord">Poetry</strong>.</p>
<h2 class="heading-2" id="_idParaDest-107">Getting all poetic with Poetry</h2>
<p class="normal">Python package management<a id="_idIndexMarker515"/> is one of the things about the language that definitely does not have people screaming praise from the rooftops. It has been widely admitted by even the most ardent supporters of the language (myself included) that Python’s package management is, to put it bluntly, a bit of a mess. The examples we have walked through using <code class="inlineCode">setup.py</code> and the production of wheels are some of the most accepted ways and, as mentioned, recommended by the PyPA. But they are still not the simplest or most intuitive approaches you would expect from a language that otherwise holds these as key design principles.</p>
<p class="normal">Thankfully, over the past few years, there have been a few major developments, one of which we will cover in detail here. This is the creation of the Python packaging and dependency management tool, Poetry. Poetry’s benefits include its ease of use and its drastic simplification of the packaging up and dependency management of your solution. Most visibly, it does this by requiring only one configuration file, the <code class="inlineCode">pyproject.toml</code> file, rather than a potential setup including <code class="inlineCode">setup.py</code>, <code class="inlineCode">setup.cfg</code>, <code class="inlineCode">MANIFEST.in</code>, or <code class="inlineCode">Pipfile</code> configuration files. There is also a big advantage in the fact that the dependency file is locked so that auto-updates do not occur, which means the admin (you) has to explicitly call out changes in dependencies. This helps to make the project more stable.</p>
<p class="normal">So, this sounds great, but how<a id="_idIndexMarker516"/> do we get started? Well, no surprise, we first install the tool using <code class="inlineCode">pip</code>:</p>
<pre class="programlisting con"><code class="hljs-con">pip install poetry
</code></pre>
<p class="normal">Then, if you wanted to start a new project that leveraged Poetry, you would go into the appropriate directory where you want your package to be and run the command:</p>
<pre class="programlisting con"><code class="hljs-con">poetry new my-ml-package
</code></pre>
<p class="normal">This would then create a sub-directory structure like:</p>
<pre class="programlisting code"><code class="hljs-code">├── README.md
├── my_ml_package
│   └── __init__.py
├── poetry.lock
├── pyproject.toml
└── tests
    └── __init__.py
</code></pre>
<p class="normal">The <code class="inlineCode">tests</code> folder will be where<a id="_idIndexMarker517"/> we place our unit tests, as covered in the <em class="italic">Testing</em> section of this chapter. <code class="inlineCode">pyproject.toml</code> is the most important file in the directory. It specifies the main metadata concerning the project and is organized into blocks covering package dependencies for production and for development and testing. </p>
<p class="normal">The file generated when I ran the previous commands was the one shown in <em class="italic">Figure 4.3</em>:</p>
<figure class="mediaobject"><img alt="" height="462" role="presentation" src="../Images/B19525_04_03.png" width="632"/></figure>
<p class="packt_figref">Figure 4.3: The pyproject.toml file created by Poetry when we create a new project.</p>
<p class="normal">In the first case, this is given in a block<a id="_idIndexMarker518"/> under <code class="inlineCode">[tool.poetry]</code>, which covers high-level information about the package. Then there is <code class="inlineCode">[tool.poetry.dependencies]</code>, which currently only contains Python version 3.10 and nothing else, as I have not used it to install anything else yet. The <code class="inlineCode">[build-system]</code> section contains details of the build-time dependencies, here only listing <code class="inlineCode">poetry-core</code>.</p>
<p class="normal">If we then want to add a new dependency, such as <code class="inlineCode">pytest</code>, we can run a command like:</p>
<pre class="programlisting con"><code class="hljs-con">poetry add pytest
</code></pre>
<p class="normal">This will output in the terminal something like that shown in <em class="italic">Figure 4.4</em>.</p>
<figure class="mediaobject"><img alt="" height="214" role="presentation" src="../Images/B19525_04_04.png" width="828"/></figure>
<p class="packt_figref">Figure 4.4: Output from adding a new package to a Poetry-managed project.</p>
<p class="normal">This will also update<a id="_idIndexMarker519"/> the <code class="inlineCode">pyproject.toml</code> file with the new dependency, as shown in <em class="italic">Figure 4.5</em>.</p>
<figure class="mediaobject"><img alt="" height="475" role="presentation" src="../Images/B19525_04_05.png" width="601"/></figure>
<p class="packt_figref">Figure 4.5: Updated pyproject.toml file after adding a new dependency.</p>
<p class="normal">Now, the <code class="inlineCode">[tool.poetry.dependencies]</code> section is the place where you should define all of the packages you need to be installed at runtime for your package, so you do not necessarily want to bloat this with lots of testing packages. </p>
<p class="normal">Instead, Poetry allows you to define a block that lists your development dependencies<a id="_idIndexMarker520"/> by specifying a <code class="inlineCode">[tool.poetry.group.dev.dependencies]</code> block, like that shown in <em class="italic">Figure 4.6</em>.</p>
<figure class="mediaobject"><img alt="" height="525" role="presentation" src="../Images/B19525_04_06.png" width="547"/></figure>
<p class="packt_figref">Figure 4.6: The pyproject.toml file with a set of development dependencies.</p>
<p class="normal">When you install Poetry, it creates<a id="_idIndexMarker521"/> its own virtual environment in order to create appropriate isolation from the rest of your system. You can activate this environment if you are on a Linux system by running:</p>
<pre class="programlisting con"><code class="hljs-con">source /path/to/venv/bin/activate
</code></pre>
<p class="normal">Or you can also run:</p>
<pre class="programlisting con"><code class="hljs-con">poetry shell
</code></pre>
<p class="normal">If you already have a Python virtual environment<a id="_idIndexMarker522"/> running through Conda, <code class="inlineCode">venv</code>, or some other tool, then Poetry is actually aware of this and works within it. This can be very helpful as you can use Poetry to manage that virtual environment, rather than starting completely from scratch. In this case, you may get some output in the terminal like that shown in <em class="italic">Figure 4.7</em>.</p>
<figure class="mediaobject"><img alt="" height="26" role="presentation" src="../Images/B19525_04_07.png" width="824"/></figure>
<p class="packt_figref">Figure 4.7: Output from poetry shell command if you are already working in a Python virtual environment.</p>
<p class="normal">To close down this environment but not the shell you are running, you can use the command:</p>
<pre class="programlisting con"><code class="hljs-con">deactivate
</code></pre>
<p class="normal">If you want to close the environment and the shell (be warned, this will likely close your terminal), you can type the command:</p>
<pre class="programlisting con"><code class="hljs-con">exit
</code></pre>
<p class="normal">To install the dependencies you have been adding in the <code class="inlineCode">pyproject.toml</code> file, you can run:</p>
<pre class="programlisting con"><code class="hljs-con">poetry install
</code></pre>
<p class="normal">This will either download and install all the dependencies listed in your <code class="inlineCode">pyproject.toml</code> file, grabbing the latest versions from <code class="inlineCode">pip</code>, or it will grab and install the versions of these packages as they are listed in the <code class="inlineCode">.lock</code> file. This is to ensure that even if multiple people have been working in the environment and running <code class="inlineCode">poetry install</code> commands, the environment is kept stable with consistent package versions. This is exactly the same reason for using a <code class="inlineCode">.lock</code> file in the section on Makefiles earlier in this chapter. When the <code class="inlineCode">install</code> command was run for this <code class="inlineCode">my-ml-package</code> project, for example, the output was that shown in <em class="italic">Figure 4.8</em>.</p>
<figure class="mediaobject"><img alt="" height="151" role="presentation" src="../Images/B19525_04_08.png" width="554"/></figure>
<p class="packt_figref">Figure 4.8: Poetry installing packages from the .lock file in order to maintain environment stability.</p>
<p class="normal">All of the preceding commands<a id="_idIndexMarker523"/> are around the basic management of the environment, but what about when we want to do something with this environment? Well, if you have a script called <code class="inlineCode">main.py</code>, you can run this using the Poetry-configured environment via the command:</p>
<pre class="programlisting con"><code class="hljs-con">poetry run python main.py
</code></pre>
<p class="normal">We do not have anything like this in the <code class="inlineCode">my-ml-package</code>. Instead, since we are building a library, we can package and deploy the package by running:</p>
<pre class="programlisting con"><code class="hljs-con">poetry build
</code></pre>
<p class="normal">This gives the output shown in <em class="italic">Figure 4.9</em>.</p>
<figure class="mediaobject"><img alt="" height="122" role="presentation" src="../Images/B19525_04_09.png" width="540"/></figure>
<p class="packt_figref">Figure 4.9: The output when Poetry builds our simple package.</p>
<p class="normal">If you want to publish to PyPI, which only works if you are a registered user with the correct credentials configured, you can just run the command <code class="inlineCode">poetry publish</code>. If you want to publish to some other private repository, you can run:</p>
<pre class="programlisting con"><code class="hljs-con">poetry publish –r private-repository-location
</code></pre>
<p class="normal">After all of this, you can probably see how Poetry can make things a lot clearer when it comes to package development. We have been able to manage stable development and production (like Python environments that can be worked on by multiple developers without fear of corruption), build and publish<a id="_idIndexMarker524"/> our package, as well as run any scripts and processes we want to – all in a few commands!</p>
<p class="normal">Next, let’s cover some of the steps we can take to ensure that our packages are robust and can be trusted to work or fail gracefully and be diagnosable if there is an issue.</p>
<h1 class="heading-1" id="_idParaDest-108">Testing, logging, securing, and error handling</h1>
<p class="normal">Building code that performs an ML task may seem like the end goal, but it is only one piece of the puzzle. We also want to be confident that this code will work, and if it doesn’t, we will be able to fix it. This is where the concepts of testing, logging, and error handling come in, which the next few sections cover at a high level.</p>
<h2 class="heading-2" id="_idParaDest-109">Testing</h2>
<p class="normal">One of the most important features<a id="_idIndexMarker525"/> that sets your ML-engineered code apart from typical research scripts is the presence of robust testing. It is critical that any system you are designing for deployment can be trusted not to fall down all the time and that you can catch issues during the development process.</p>
<p class="normal">Luckily, since Python is a general-purpose programming<a id="_idIndexMarker526"/> language, it is replete with tools for performing tests on your software. In this chapter, we will use <strong class="keyWord">pytest</strong>, which is one of the most popular, powerful, and easy-to-use testing toolsets for Python code available. pytest is particularly useful if you are new to testing because it focuses on building tests as standalone Python functions that are quite readable, whereas other packages can sometimes lead to the creation of clunky testing classes and complex <code class="inlineCode">assert</code> statements. Let’s dive into an example.</p>
<p class="normal">First, let’s start by writing tests for some pieces of code defined in the rest of this chapter from our <code class="inlineCode">outliers</code> package. We can define a simple test to ensure that our data helper function actually creates some numerical data that can be used for modeling. To run this sort of test in pytest, we first create a file with <code class="inlineCode">test_</code> or <code class="inlineCode">_test</code> in the name somewhere in our test’s directory—pytest will automatically find files that have this in their name. So, for example, we may write a test script called <code class="inlineCode">test_create_data.py</code> that contains the logic we need to test all of the functions that refer to creating data within our solution. Let’s make this explicit with an example:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Import the relevant modules we will need from the package and anything else we need for testing. Here, we import <code class="inlineCode">pytest</code> because we will use some functionality from it in later steps but, in general, you don’t need to import this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy
<span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">import</span> outliers.utils.data
</code></pre>
</li>
<li class="numberedList">Then, since we want to test <a id="_idIndexMarker527"/>the function for creating data, it would be good to only generate the data once, then test its attributes in a variety of ways. To do this, we employ the <code class="inlineCode">fixture</code> decorator from pytest, which allows us to define an object that can be read into several of our tests. Here, we use this so that we can apply our tests using <code class="inlineCode">dummy_data</code>, which is just the output of the <code class="inlineCode">create_data</code> function:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@pytest.fixture()</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">dummy_data</span>():
    data = outliers.utils.data.create_data()
    <span class="hljs-keyword">return</span> data
</code></pre>
</li>
<li class="numberedList">Finally, we can actually write the tests. Here are two examples that test if the dataset created by the function is a <code class="inlineCode">numpy</code> array and if it has more than <code class="inlineCode">100</code> rows of data:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">test_data_is_numpy</span>(<span class="hljs-params">dummy_data</span>):
    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(dummy_data, numpy.ndarray)
<span class="hljs-keyword">def</span> <span class="hljs-title">test_data_is_large</span>(<span class="hljs-params">dummy_data</span>):
    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(dummy_data)&gt;<span class="hljs-number">100</span>
</code></pre>
<p class="normal">We can write as many of these tests and as many of these types of test modules as we like. This allows us to create a high degree of <strong class="keyWord">test coverage</strong> across our package.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">You can then enter the following command in the terminal at the top level of your project in order to run all the tests in the package:
        <pre class="programlisting con"><code class="hljs-con">$ pytest
</code></pre>
</li>
<li class="numberedList">Then you will see a message like this, telling us what tests have run and which have passed and failed:
    <figure class="mediaobject"><img alt="Figure 4.3 – The output of a successful unit test in PyTest " height="128" src="../Images/B19525_04_10.png" width="758"/></figure>
<p class="packt_figref">Figure 4.10: The output of a successful unit test in pytest.</p>
<p class="normal">The previous example showed how to write and execute some basic tests on our data utilities. We can now expand on this by testing some of the more sophisticated functionality in the package – namely, the model creation process.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">Similarly to the previous case, we create<a id="_idIndexMarker528"/> a script for holding our tests in <code class="inlineCode">tests/test_detectors.py</code>. Since we are testing more complex functionality, we will have to import more pieces of the package into the script:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">from</span> outliers.detectors.detection_models <span class="hljs-keyword">import</span> DetectionModels
<span class="hljs-keyword">from</span> outliers.detectors.pipelines <span class="hljs-keyword">import</span> OutlierDetector
<span class="hljs-keyword">from</span> outliers.definitions <span class="hljs-keyword">import</span> MODEL_CONFIG_PATH
<span class="hljs-keyword">import</span> outliers.utils.data
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
</code></pre>
</li>
<li class="numberedList">We will have the same fixture for dummy data created as in <em class="italic">Step 2</em>, but now we also have a fixture for creating some example models to use in tests:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@pytest.fixture()</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">example_models</span>():
    models = DetectionModels(MODEL_CONFIG_PATH)
    <span class="hljs-keyword">return</span> models
</code></pre>
</li>
<li class="numberedList">Our final fixture creates an example detector instance for us to use, based on the previous model’s fixture:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@pytest.fixture()</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">example_detector</span>(<span class="hljs-params">example_models</span>):
    model = example_models.get_models()[<span class="hljs-number">0</span>]
    detector = OutlierDetector(model=model)
    <span class="hljs-keyword">return</span> detector
</code></pre>
</li>
<li class="numberedList">And now we are ready to test some of the model creation functionality. First, we can test that the models we created are not empty <code class="inlineCode">objects</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">test_model_creation</span>(<span class="hljs-params">example_models</span>):
    <span class="hljs-keyword">assert</span> example_models <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
</code></pre>
</li>
<li class="numberedList">We can then test that we can successfully retrieve models using the instance of <code class="inlineCode">DetectionModels</code> created in <em class="italic">Step 6</em>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">test_model_get_models</span>(<span class="hljs-params">example_models</span>):
    example_models.get_models() <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
</code></pre>
</li>
<li class="numberedList">Finally, we can test that the results found by applying the model pass some simple tests. This shows that the main pieces of our package are working for an end-to-end application:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">test_model_evaluation</span>(<span class="hljs-params">dummy_data, example_detector</span>):
    result = example_detector.detect(dummy_data)
    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(result[result == -<span class="hljs-number">1</span>]) == <span class="hljs-number">39</span> <span class="hljs-comment">#number of anomalies to detect</span>
    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(result) == <span class="hljs-built_in">len</span>(dummy_data) <span class="hljs-comment">#same numbers of results</span>
    <span class="hljs-keyword">assert</span> np.unique(result)[<span class="hljs-number">0</span>] == -<span class="hljs-number">1</span>
    <span class="hljs-keyword">assert</span> np.unique(result)[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>  
</code></pre>
</li>
<li class="numberedList">As in <em class="italic">Step 4</em>, we can run the full test<a id="_idIndexMarker529"/> suite from the command line. We add a verbosity flag to return more information and show the individual tests that pass. This helps confirm that both our data utility and our model tests are being triggered:
        <pre class="programlisting con"><code class="hljs-con">pytest –-verbose
</code></pre>
</li>
<li class="numberedList">The output is shown in the following screenshot:
    <figure class="mediaobject"><img alt="Figure 4.4 – Output of successful tests on both data and model functionality " height="141" src="../Images/B19525_04_11.png" width="760"/></figure>
<p class="packt_figref">Figure 4.11: Output of successful tests on both data and model functionality.</p></li>
</ol>
<p class="normal">The running of these tests can be automated either via the inclusion of <code class="inlineCode">githooks</code> in our repository or through the use of other tools, such as the <code class="inlineCode">Makefile</code> used for the project.</p>
<p class="normal">We’ll now move on to consider<a id="_idIndexMarker530"/> how we can log information about our code as it runs, which can help with debugging and general monitoring of your solution.</p>
<h2 class="heading-2" id="_idParaDest-110">Securing your solutions</h2>
<p class="normal">As software engineers of any kind, we should<a id="_idIndexMarker531"/> always be very cognizant of the fact that there is a flip-side to the joy of building products that people use. This flip-side is that it is then your job to make sure the solution is secure and safe for those users. In the words of Uncle Ben, “<em class="italic">With great power comes great responsibility</em>.”</p>
<p class="normal">Now, cybersecurity is a huge discipline in its own right, so we cannot do it justice here. The following sections will simply aim to introduce some useful tools and explain the basics of using them in order to make your solutions more secure and trustworthy.</p>
<p class="normal">First, we need to understand the different ways we can create secure solutions:</p>
<ul>
<li class="bulletList">Testing the application and code itself for internal bugs.</li>
<li class="bulletList">Screening packages and scanning other code used for security vulnerabilities.</li>
<li class="bulletList">Testing for data leaks and data exposure.</li>
<li class="bulletList">Developing robust monitoring techniques, specifically with respect to the above points and less so about the monitoring of your ML models, which has been covered elsewhere in this book.</li>
</ul>
<p class="normal">In the first case, this refers mostly to things like our unit-testing approaches, which, again, we have covered elsewhere, but in brief, this refers to the act of testing the functionality of the code you write in order to ensure it works as expected. In the section on model monitoring, it was mentioned that performing standard tests for the expected performance of a machine learning model can be difficult and so requires specific techniques. </p>
<p class="normal">Here, we are focused more on the general application code and the solution wrapping the main model.</p>
<p class="normal">In the case of screening packages and code, this is a very pertinent and, thankfully, easy-to-implement challenge. The reader may recall that in 2022, there was a wave of activity across the world as organizations and software engineers tried to deal with the discovery of a bug in the Java-based Log4j library. Bugs and security flaws will always happen and not always be detected, but this point is all about having some system in place to automatically scan the code and packages you are using in your solution to find these proactively, saving major headaches (and far worse) for the users of your code.</p>
<p class="normal">Data leakage is an incredibly important topic now. Regulations like the <strong class="keyWord">General Data Protection Regulation</strong> (<strong class="keyWord">GDPR</strong>) in the European Union have placed<a id="_idIndexMarker532"/> a massive emphasis on the management and curation of customers’ data. Since machine learning systems are fundamentally data-driven applications, this means that concerns around privacy, usage, storage, and many other points become extremely important to consider in designs and implementations. It is important to note that what we are discussing here goes far beyond the “garbage in, garbage out” question of data quality, and really is about how securely you are holding<a id="_idIndexMarker533"/> and transferring the data required to make your machine learning system work.</p>
<h2 class="heading-2" id="_idParaDest-111">Analyzing your own code for security issues</h2>
<p class="normal">As you will have noticed<a id="_idIndexMarker534"/> throughout this book, the Python open-source community<a id="_idIndexMarker535"/> has almost every challenge you can think of covered in at least some way, and when it comes to security, this is no different. To perform static analysis of your own code and check for vulnerabilities<a id="_idIndexMarker536"/> that may have been introduced during development, you can use the open-source Bandit package, <a href="https://bandit.readthedocs.io/en/latest/"><span class="url">https://bandit.readthedocs.io/en/latest/</span></a>. This is a linter that is focused on finding security issues in source code, and it is extremely easy to run.</p>
<p class="normal">First, as always, we need to install Bandit. We can now do this using the Makefile magic we learned about in the earlier section on <em class="italic">Building your package</em>, so we add the Bandit package to the <code class="inlineCode">pip</code> dependencies in the <code class="inlineCode">environment.yml</code> file and run the command:</p>
<pre class="programlisting con"><code class="hljs-con">make update_environment
</code></pre>
<p class="normal">Then, to run Bandit on your source code, you simply run:</p>
<pre class="programlisting con"><code class="hljs-con">bandit -r outliers
</code></pre>
<p class="normal">As we mentioned in <em class="chapterRef">Chapter 2</em>, <em class="italic">The Machine Learning Development Process</em>, it is always useful to automate any development steps that you will want to run again and again. We can do this with Bandit by adding the following to our <code class="inlineCode">.pre-commit-config.yaml</code> in our Git directory:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">repos:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/PyCQA/bandit</span>
  <span class="hljs-attr">rev:</span> <span class="hljs-string">''</span> <span class="hljs-comment"># Update me!</span>
  <span class="hljs-attr">hooks:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">bandit</span>
</code></pre>
<p class="normal">This means that after every<a id="_idIndexMarker537"/> commit, we will run the <code class="inlineCode">bandit</code> command<a id="_idIndexMarker538"/> as outlined in the previous two steps.</p>
<p class="normal">The output from running Bandit on some example code is given by a series of blocks like the following in <em class="italic">Figure 4.12</em>.</p>
<figure class="mediaobject"><img alt="" height="268" role="presentation" src="../Images/B19525_04_12.png" width="825"/></figure>
<p class="packt_figref">Figure 4.12: Bandit output on a typical piece of code.</p>
<p class="normal">This is followed by a small summary report at the end of the output, shown in <em class="italic">Figure 4.13.</em></p>
<figure class="mediaobject"><img alt="" height="261" role="presentation" src="../Images/B19525_04_13.png" width="396"/></figure>
<p class="packt_figref">Figure 4.13: The Bandit tool provides a high-level summary at the end of its output for diagnosing the state of your code base.</p>
<p class="normal">There are many more features <a id="_idIndexMarker539"/>of Bandit but this shows how easy it is to get started<a id="_idIndexMarker540"/> and start analyzing the potential issues in your Python code base.</p>
<h2 class="heading-2" id="_idParaDest-112">Analyzing dependencies for security issues</h2>
<p class="normal">As we have outlined, we don’t just want<a id="_idIndexMarker541"/> to scan the code we have written for security vulnerabilities; it is also important that we try and find any issues in the packages that we are using in our solution. This can be done using<a id="_idIndexMarker542"/> something like the Python <code class="inlineCode">safety</code> tool, <a href="https://pypi.org/project/safety/"><span class="url">https://pypi.org/project/safety/</span></a>. Safety uses a standardized database containing known Python security issues and then compares any packages found in your solution against this database. Please note that, as the documentation for safety calls out:</p>
<blockquote class="packt_quote">
<p class="quote">By default it uses the open Python vulnerability database Safety DB, which is licensed for non-commercial use only.</p>
<p class="quote">For all commercial projects, Safety must be upgraded to use a PyUp API using the key option.</p>
</blockquote>
<p class="normal">Below is an example of using<a id="_idIndexMarker543"/> this on the same source code tree as in the example for using Bandit:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">If you do not have safety installed, install it:
        <pre class="programlisting con"><code class="hljs-con">pip install safety
</code></pre>
</li>
<li class="numberedList">You then need to change into the top folder of your source code tree before running:
        <pre class="programlisting con"><code class="hljs-con">safety check
</code></pre>
</li>
</ol>
<p class="normal">When I ran this on the folder containing the <code class="inlineCode">outlier_package</code> we have been building, I got the terminal output shown in <em class="italic">Figure 4.14</em>:</p>
<figure class="mediaobject"><img alt="" height="962" role="presentation" src="../Images/B19525_04_14.png" width="628"/></figure>
<p class="packt_figref">Figure 4.14: The output of safety on the outliers package.</p>
<p class="normal">As you can see from <em class="italic">Figure 4.15</em>, we are being warned that the current version cannot be used for scanning commercial software and that if this was needed, you should get an API key. For the project here, this is fine. One vulnerability has been found by the tool relating to the version of the <code class="inlineCode">wheel</code> package. Upon inspection of the <code class="inlineCode">environment.yml</code> file in the project, we see that we can update this to version 0.38.1 as the advisory note suggests. This is shown in <em class="italic">Figure 4.15</em>.</p>
<figure class="mediaobject"><img alt="" height="185" role="presentation" src="../Images/B19525_04_15.png" width="334"/></figure>
<p class="packt_figref">Figure 4.15: Updating the environment.yml file in order to avoid the error produced by the safety tool.</p>
<p class="normal">Note that the Conda channels<a id="_idIndexMarker544"/> used in this <code class="inlineCode">environment.yml</code> file did not have the <code class="inlineCode">wheel</code> package in version 0.38.1 or greater so this was added to the <code class="inlineCode">pip</code> dependencies instead, as shown in <em class="italic">Figure 4.16</em>.</p>
<figure class="mediaobject"><img alt="" height="163" role="presentation" src="../Images/B19525_04_16.png" width="219"/></figure>
<p class="packt_figref">Figure 4.16: Updating the pip dependencies of the environment.yml file in the outliers package.</p>
<p class="normal">After doing this and re-running the command: </p>
<pre class="programlisting con"><code class="hljs-con">safety check
</code></pre>
<p class="normal">The solution is given a clean bill of health, as shown in the report in <em class="italic">Figure 4.17</em>.</p>
<figure class="mediaobject"><img alt="" height="758" role="presentation" src="../Images/B19525_04_17.png" width="820"/></figure>
<p class="packt_figref">Figure 4.17: The safety tool returns zero security vulnerabilities after updating the identified package.</p>
<p class="normal">Although safety does require a commercial license<a id="_idIndexMarker545"/> in order to get the full set of features, it can still be extremely helpful for sniffing out issues in your dependencies.</p>
<h2 class="heading-2" id="_idParaDest-113">Logging</h2>
<p class="normal">Next, it is important<a id="_idIndexMarker546"/> to ensure that as your code is running, the status of the different operations is reported, as well as any errors that occur. This helps make your code more maintainable and helps you debug when there is an issue. For this, you can use the Python <code class="inlineCode">logging</code> library.</p>
<p class="normal">Loggers can be instantiated in your code via logic like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging
logging.basicConfig(filename=<span class="hljs-string">'outliers.log'</span>,
                    level=logging.DEBUG,
                    <span class="hljs-built_in">format</span>=<span class="hljs-string">'%(asctime)s | %(name)s | %(levelname)s |</span>
                            <span class="hljs-string">%(message)s'</span>)
</code></pre>
<p class="normal">This code defines our format for the logging messages and specifies that logging messages of level <code class="inlineCode">DEBUG</code> or higher will go to the <code class="inlineCode">outliers.log</code> file. We can then log output and information relevant to our code’s running status using the very easy-to-use syntax that comes with the <code class="inlineCode">logging</code> library:</p>
<pre class="programlisting con"><code class="hljs-con">logging.debug('Message to help debug ...')
logging.info('General info about a process that is running ...')
logging.warning('Warn, but no need to error ...')
With the settings shown in the first logging snippet, this will result in the following logging messages being written to outliers.log:
2021-08-02 19:58:53,501 | root | DEBUG | Message to help debug ...
2021-08-02 19:58:53,501 | root | INFO | General info about a process that is running ...
2021-08-02 19:58:53,501 | root | WARNING | Warn, but no need to error ...
</code></pre>
<p class="normal">What we have shown so far is really the basics of logging and it so far assumes that, although things may not be going perfectly, nothing has errored. This is obviously not always the case! So, what if we want to log an exception or error to our logging file?</p>
<p class="normal">Well, this is typically done with the <code class="inlineCode">logging.error</code> syntax but with an important point we must consider, which is that it is often not enough to just log the fact we’ve raised an error; we would also like to log the details of the error. So, as discussed in the <em class="italic">Error handling</em> section, we know that we can execute a <code class="inlineCode">try</code> <code class="inlineCode">except</code> clause on some code and then raise an exception. What we want to do in this case is log the details of that exception to our logging target. To do this we need to know that the <code class="inlineCode">logging.error</code> method (and the <code class="inlineCode">logging.debug</code> method) have some important keyword arguments we can use. For more on keyword arguments, see the section on <em class="italic">Tips and tricks</em> in this chapter. According to the logging<a id="_idIndexMarker547"/> documentation, <a href="https://docs.python.org/3/library/logging.xhtml#logging.debug"><span class="url">https://docs.python.org/3/library/logging.xhtml#logging.debug</span></a>, the keyword arguments <code class="inlineCode">exc_info</code> and <code class="inlineCode">stack_info</code> are given as Booleans, and <code class="inlineCode">extra</code> is a dictionary. The keyword argument <code class="inlineCode">exc_info = True</code> specifies that we wish to return exception information in the logging call, <code class="inlineCode">stack_info = True</code> will return far more detailed stack trace information for the exception (including the logger call), and <code class="inlineCode">extra</code> can be set equal to a dictionary with extra information that the developer has defined. </p>
<p class="normal">The extra information in this case is then provided with the initial part of the record, as part of the identifier of the event. This is a good way to provide some bespoke information to your logging calls.</p>
<p class="normal">As an example, let us consider a bespoke feature transformation function, which, in this case, will actually not do anything useful, just return the original DataFrame like so:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">feature_transform</span>(<span class="hljs-params">df: pd.DataFrame</span>) -&gt; pd.DataFrame:
    <span class="hljs-string">"""Transform a dataframe by not doing anything. Just for demo.</span>
<span class="hljs-string">    :param df: a dataframe.</span>
<span class="hljs-string">    :return: df.mean(), the same dataframe with the averages of eachcolumn.</span>
<span class="hljs-string">    """</span>
    <span class="hljs-keyword">return</span> df.mean()
</code></pre>
<p class="normal">If we want to raise an exception<a id="_idIndexMarker548"/> when this function failed and log details about the error, we could write something like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span>:
    df_transformed = feature_transform(df)
    logging.info(<span class="hljs-string">"df successfully transformed"</span>)
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:
    logging.error(<span class="hljs-string">"Unexpected error"</span>, exc_info=<span class="hljs-literal">True</span>)
</code></pre>
<p class="normal">If we run this code on a simple dummy pandas DataFrame like the one below, the code will execute without issue:</p>
<pre class="programlisting code"><code class="hljs-code">df = pd.DataFrame(data={<span class="hljs-string">'col1'</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-string">'col2'</span>: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]})
</code></pre>
<p class="normal">If, however, we do the same, but this time, we run the code on something that does not have the pandas DataFrame <code class="inlineCode">mean()</code> syntax, like a list:</p>
<pre class="programlisting code"><code class="hljs-code">list_of_nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]
<span class="hljs-keyword">try</span>:
    df_transformed = feature_transform(list_of_nums)
    logging.info(<span class="hljs-string">"df successfully transformed"</span>)
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:
    logging.error(<span class="hljs-string">"Unexpected error"</span>, exc_info=<span class="hljs-literal">True</span>)
</code></pre>
<p class="normal">We will activate the error and log the details to the logging file. Note that in the below code snippet, the file path was shortened<a id="_idIndexMarker549"/> for the screenshot, shown in <em class="italic">Figure 4.18</em>.</p>
<figure class="mediaobject"><img alt="" height="180" role="presentation" src="../Images/B19525_04_18.png" width="825"/></figure>
<p class="packt_figref">Figure 4.18: The output to the log file when we use the exc_info = True flag.</p>
<h2 class="heading-2" id="_idParaDest-114">Error handling</h2>
<p class="normal">The last piece of <em class="italic">housekeeping</em> to cover in this section<a id="_idIndexMarker550"/> is error handling. It is important to remember that when you are an ML engineer, your aim is to build products and services that work, but an important part of this is recognizing that things do not always work! It is therefore important that you build in patterns that allow for the escalation of (inevitable) errors during runtime. In Python, this is typically done via the concept of <em class="italic">exceptions</em>. Exceptions can be raised by the core Python functions and methods you are using. For example, imagine you ran the following code without defining the variable <code class="inlineCode">x</code>:</p>
<pre class="programlisting code"><code class="hljs-code">y = <span class="hljs-number">10</span>*x
</code></pre>
<p class="normal">The following exception would be raised:</p>
<pre class="programlisting code"><code class="hljs-code">NamError: name <span class="hljs-string">'x'</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined
</code></pre>
<p class="normal">The important point for us as engineers is that we should build solutions in which we can confidently control the flow of errors. We may not always want our code to break when an error occurs, or we may want to ensure that very specific messages and logging occur upon certain expected edge cases. The simplest technique for doing this is via <code class="inlineCode">try except</code> blocks, as seen in the following code block:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span>:
    do_something()
<span class="hljs-keyword">except</span>:
    do_something_else()
</code></pre>
<p class="normal">In this case, <code class="inlineCode">do_something_else()</code> is executed if <code class="inlineCode">do_something()</code> runs into an error.</p>
<p class="normal">We will now finish with a comment on how to be efficient when building your solutions.</p>
<p class="normal">Error handling in Python is often built around the idea of “exceptions,” which are just events that disrupt the expected functioning of the program.</p>
<p class="normal">The full list of exceptions in Python<a id="_idIndexMarker551"/> contains around 50 different types. Below is an excerpt taken from the Python documentation, with ellipses highlighting where I have not shown the full details:</p>
<pre class="programlisting code"><code class="hljs-code">BaseException
+-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
…
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
…
</code></pre>
<p class="normal">You can see from the exception list that these are organized in a hierarchy. This means that raising an exception at a lower level is simply a more specific instance of an exception at a higher level, so you can actually raise it at a higher level of the hierarchy and everything still works correctly. As a quick example, we can see from the <code class="inlineCode">ArithmeticError</code> sub-hierarchy that there are three exceptions at a lower level in the hierarchy:</p>
<pre class="programlisting code"><code class="hljs-code">      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
</code></pre>
<p class="normal">This then means that if we were to raise an exception for a piece of code we think may divide a number by zero, we can legally use <code class="inlineCode">ZeroDivisionError</code> or <code class="inlineCode">ArithmeticError</code>:</p>
<pre class="programlisting code"><code class="hljs-code">n = <span class="hljs-number">4.0</span>
<span class="hljs-keyword">try</span>:
    result = n/<span class="hljs-number">0.0</span>
<span class="hljs-keyword">except</span> ZeroDivisionError:
    <span class="hljs-built_in">print</span>("Division by zero <span class="hljs-keyword">not</span> allowed!")
n = <span class="hljs-number">4.0</span>
<span class="hljs-keyword">try</span>:
    result = n/<span class="hljs-number">0.0</span>	
<span class="hljs-keyword">except</span> ArithmeticError:
    <span class="hljs-built_in">print</span>("Division by zero <span class="hljs-keyword">not</span> allowed!")
</code></pre>
<p class="normal">In general, when you catch<a id="_idIndexMarker552"/> an exception, there are a few different routes you can go down to handle it. First, you could handle the exception and continue the program flow. You should do this when it is clear what will be causing the error and it can be handled within the logic of the code. Second, you could raise the exception again. You may want to do this for a few reasons:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">You want to log the error but still allow the exception to propagate up the call stack. This can be useful for debugging purposes, as it allows you to log the error message and other details about the exception, while still allowing the calling code to handle the exception as appropriate. An example may look something like this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging

<span class="hljs-keyword">def</span> <span class="hljs-title">process_data</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># Do some processing on the data</span>
        result = process(data)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-comment"># Log the exception</span>
        logging.exception(<span class="hljs-string">"</span><span class="hljs-string">Exception occurred while processing</span>
                           <span class="hljs-string">data"</span>)
        <span class="hljs-comment"># Re-raise the exception</span>
        <span class="hljs-keyword">raise</span>
    <span class="hljs-keyword">return</span> result
</code></pre>
<p class="normal">In this example, the <code class="inlineCode">process_data</code> function tries to process some data and returns the result. If an exception occurs while processing the data, the exception is logged using the <code class="inlineCode">logging.exception</code> function, which logs the exception along with a stack trace. The exception is then re-raised using the <code class="inlineCode">raise</code> statement, which allows the calling code to handle the exception as appropriate.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="2">You want to add additional context to the exception. For example, you might want to add information about the state of your application when the exception occurred, or about the input that led to the exception being raised. Adapting the previous example, we may then have something like:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">process_data</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># Do some processing on the data</span>
        result = process(data)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-comment"># Add additional context to the exception message</span>
        message = <span class="hljs-string">f"Exception occurred while processing data:</span>
                    <span class="hljs-subst">{data}</span><span class="hljs-string">"</span>
        <span class="hljs-comment"># Create a new exception with the modified message</span>
        <span class="hljs-keyword">raise</span> Exception(message) <span class="hljs-keyword">from</span> e
    <span class="hljs-keyword">return</span> result
</code></pre>
<p class="normal">In this example, if an exception occurs while processing the data, the exception message is modified to include the data that was being processed. A new exception is then raised using the modified message and the original exception as the cause (using the <code class="inlineCode">from e</code> syntax).</p> </li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">You want to handle an exception<a id="_idIndexMarker553"/> in a higher level of your code but still allow lower-level code to handle the exception if it is not appropriate to handle it at the higher level. This is a bit more complex, so we will try and walk through another adapted example step by step. First, this time, when we raise the exception, we call a function that handles the exception in a bespoke way, called <code class="inlineCode">handle_exception</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">process_data</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># Do some processing on the data</span>
        result = process(data)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-comment"># Handle the exception</span>
        handle_exception(e)
        <span class="hljs-comment"># Re-raise the exception</span>
        <span class="hljs-keyword">raise</span>
    <span class="hljs-keyword">return</span> result
</code></pre>
<p class="normal">The code for <code class="inlineCode">handle_exception</code> would look something like the following, where we have to determine if we want to handle the exception at this level of abstraction or pass it up the call stack, using another function called <code class="inlineCode">should_handle</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_exception</span>(<span class="hljs-params">e</span>):
    <span class="hljs-comment"># Log the exception</span>
    logging.exception(<span class="hljs-string">"Exception occurred"</span>)
    <span class="hljs-comment"># Check if the exception should be handled at this level</span>
    <span class="hljs-keyword">if</span> should_handle(e):
        <span class="hljs-comment"># Handle the exception</span>
        ...
    else:
        <span class="hljs-comment"># Allow the exception to propagate up the call stack</span>
        <span class="hljs-keyword">raise</span>
</code></pre>
<p class="normal">The <code class="inlineCode">should_handle</code> function<a id="_idIndexMarker554"/> would then be where we define our bespoke logic for deciding if we handle the exception at the current level or use the raise syntax to escalate up the call stack. For example, if we want to handle an <code class="inlineCode">ArithmeticError</code> at this level and otherwise we want to raise up the call stack, the logic would look like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">should_handle</span>(<span class="hljs-params">e</span>):
    <span class="hljs-comment"># Check the type of the exception</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(e, ArithmeticError):
        <span class="hljs-comment"># Handle the exception</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># Allow the exception to propagate</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Finally, you may raise a different exception, perhaps because you need to bring together a few different exceptions and deal with them together at a higher level of abstraction. Once again, adapting the previous examples, this may mean that you write some code that looks like this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">process_data</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># Do some processing on the data</span>
        result = process(data)
    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:
        <span class="hljs-comment"># Raise a different exception with the same message</span>
        <span class="hljs-keyword">raise</span> MyCustomException(<span class="hljs-built_in">str</span>(e))
    <span class="hljs-keyword">except</span> MyCustomException <span class="hljs-keyword">as</span> e:
        <span class="hljs-comment"># Raise a different exception with a modified message</span>
        message = <span class="hljs-string">f"Exception occurred while processing data:</span>
<span class="hljs-string">                    </span><span class="hljs-subst">{data}</span><span class="hljs-string">"</span>
        <span class="hljs-keyword">raise</span> MyCustomException(message)
    <span class="hljs-keyword">return</span> result
</code></pre>
<p class="normal">In this example, if a <code class="inlineCode">ValueError</code> exception occurs while processing the data, it is caught and a new <code class="inlineCode">MyCustomException</code> is raised with the same message. If a <code class="inlineCode">MyCustomException</code> exception occurs, it is caught and a new <code class="inlineCode">MyCustomException</code> is raised with a modified message that includes the <code class="inlineCode">data</code> that was being processed. This allows you to deal with different types of exceptions together at a higher level of abstraction, by raising a single, custom exception type that can be handled in a consistent way.</p> </li>
</ol>
<p class="normal">A third program flow<a id="_idIndexMarker555"/> that we can use is that we can raise a new exception from within the original exception. This can be helpful because we can provide more detailed information about the type of error that has occurred, and we can give more contextual information that will help us debug any issues down the line. To make this clearer, let’s define an example function to stand in for the function we’ve been using in the previous examples:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span>(<span class="hljs-params">data_to_be_processed</span>):
    <span class="hljs-string">'''Dummy example that returns original data plus 1'''</span>
    <span class="hljs-keyword">return</span> data_to_be_processed + <span class="hljs-number">1</span>
</code></pre>
<p class="normal">We will call this in the same function as we had in the first example of the list above but now we will add a new piece of syntax to raise an exception from the original exception:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">process_data</span>(<span class="hljs-params">data</span>): 
    <span class="hljs-keyword">try</span>: 
        <span class="hljs-comment"># Do some processing on the data </span>
        result = process(data) 
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e: 
        <span class="hljs-comment"># Log the exception </span>
        logging.exception(<span class="hljs-string">"Exception occurred while processing data"</span>) 
        <span class="hljs-comment"># Raise a new exception from the overall exception</span>
        new_exception = ValueError(<span class="hljs-string">"Error processing data"</span>) 
        <span class="hljs-keyword">raise</span> new_exception <span class="hljs-keyword">from</span> e
    <span class="hljs-keyword">return</span> result
</code></pre>
<p class="normal">The raising from the original exception<a id="_idIndexMarker556"/> now ensures that we have logged the fact that this was specifically a <code class="inlineCode">ValueError</code> related to the input data, and it allows us to log a higher-level message that can give additional context in the stack trace. For example, if you use the above functions and run this function call:</p>
<pre class="programlisting code"><code class="hljs-code">process_data('<span class="hljs-number">3</span>')
</code></pre>
<p class="normal">We get an error, as expected, since we are supplying a string and then trying to add an integer to it. A snippet from the stack trace I got when I ran this is given below:</p>
<pre class="programlisting con"><code class="hljs-con">ERROR:root:Exception occurred while processing data
  File "exception_handling_examples.py", line 5, in process
    return data_to_be_processed + 1
TypeError: can only concatenate str (not "int") to str
</code></pre>
<p class="normal">The above exception was the direct cause of the following exception:</p>
<pre class="programlisting con"><code class="hljs-con">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "exception_handling_examples.py", line 18, in process_data
    raise new_exception from e
ValueError: Error processing data
</code></pre>
<p class="normal">You can see how the exception we raised from the original exception calls out where in the <code class="inlineCode">process_data</code> function the error has occurred, and it has also given us the information that this issue relates to the processing of the data. Both pieces of information help provide context and can help us debug. The more technical original exception, the <code class="inlineCode">TypeError</code> referring to the operand types, is still useful but could be hard to digest and fully debug on its own.</p>
<p class="normal">This only scratches the surface of what is possible<a id="_idIndexMarker557"/> when it comes to logging, but this will allow you to get started.</p>
<p class="normal">Now, we move on to what we need to do in our code to handle scenarios where things go wrong!</p>
<h1 class="heading-1" id="_idParaDest-115">Not reinventing the wheel</h1>
<p class="normal">You will already have noticed<a id="_idIndexMarker558"/> through this chapter (or I hope you have!) that a lot of the functionality that you need for your ML and Python project has already been built. One of the most important things you can learn as an ML engineer is that you are not supposed to build everything from scratch. You can ensure you do not do this in a variety of ways, the most obvious of which is to use other packages in your own solution and then build a functionality that enriches what is already there. As an example, you do not need to build basic regression modeling capabilities since they exist in a variety of packages, but you might have to add a new type of regressor or use some specific domain knowledge or trick you have developed. In this case, you would be justified in writing your own code on top of the existing solution. You can also use a variety of concepts from Python, such as wrapper classes or decorators. The key message is that although there is a lot of work for you to do when building your ML solutions, it is important that you do not feel the need to build everything from scratch. It is far more efficient to focus on where you can create added value and build on what has gone before!</p>
<h1 class="heading-1" id="_idParaDest-116">Summary</h1>
<p class="normal">This chapter has been all about best practices for when you write your own Python packages for your ML solutions. We went over some of the basic concepts of Python programming as a refresher before covering some tips and tricks and good techniques to bear in mind. We covered the importance of coding standards in Python and PySpark. We then performed a comparison between object-oriented and functional programming paradigms for writing your code. We moved on to the details of taking the high-quality code you have written and packaging it up into something you can distribute across multiple platforms and use cases. To do this, we looked into different tools, designs, and setups you could use to make this a reality, including the use of Makefiles and Poetry. We continued with a summary of some housekeeping tips for your code, including how to test, log, and monitor your solution. This also included some detailed examples of exception handling and how you can develop more sophisticated control flows in your programs and packages. We finished with a brief <em class="italic">philosophical</em> point on the importance of not reinventing the wheel.</p>
<p class="normal">In the next chapter, we will take a deep dive into the world of deployment. This will be all about how you take scripts, packages, libraries, and apps that you have written and run them on appropriate infrastructure and tools.</p>
<h1 class="heading-1" id="_idParaDest-117">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussion with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/mle"><span class="url">https://packt.link/mle</span></a></p>
<p class="normal"><img alt="" height="177" role="presentation" src="../Images/QR_Code102810325355484.png" width="177"/></p>
</div>
</div></body></html>