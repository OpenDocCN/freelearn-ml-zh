["```py\n// OpenCV command line parser functions \n// Keys accepted by command line parser \nconst char* keys = \n{ \n  \"{help h usage ? | | print this message}\" \n   \"{@image || Image to process}\" \n   \"{@lightPattern || Image light pattern to apply to image input}\" \n   \"{lightMethod | 1 | Method to remove background light, 0 difference, 1 div }\" \n   \"{segMethod | 1 | Method to segment: 1 connected Components, 2 connected components with stats, 3 find Contours }\" \n}; \n```", "```py\nint main(int argc, const char** argv) \n{ \n  CommandLineParser parser(argc, argv, keys); \n  parser.about(\"Chapter 5\\. PhotoTool v1.0.0\"); \n  //If requires help show \n  if (parser.has(\"help\")) \n  { \n      parser.printMessage(); \n      return 0; \n  } \n\n  String img_file= parser.get<String>(0); \n  String light_pattern_file= parser.get<String>(1); \n  auto method_light= parser.get<int>(\"lightMethod\"); \n  auto method_seg= parser.get<int>(\"segMethod\"); \n\n  // Check if params are correctly parsed in his variables \n  if (!parser.check()) \n  { \n      parser.printErrors(); \n      return 0; \n  } \n```", "```py\n// Load image to process \n  Mat img= imread(img_file, 0); \n  if(img.data==NULL){ \n    cout << \"Error loading image \"<< img_file << endl; \n    return 0; \n  } \n```", "```py\n  Mat img_noise; \n  medianBlur(img, img_noise, 3); \n```", "```py\nR= L-I \n```", "```py\nR= 255*(1-(I/L)) \n```", "```py\nMat removeLight(Mat img, Mat pattern, int method) \n{ \n  Mat aux; \n  // if method is normalization \n  if(method==1) \n  { \n    // Require change our image to 32 float for division \n    Mat img32, pattern32; \n    img.convertTo(img32, CV_32F); \n    pattern.convertTo(pattern32, CV_32F); \n    // Divide the image by the pattern \n    aux= 1-(img32/pattern32); \n    // Convert 8 bits format and scale\n    aux.convertTo(aux, CV_8U, 255); \n  }else{ \n    aux= pattern-img; \n  } \n  return aux; \n} \n```", "```py\n// Required to change our image to 32 float for division \nMat img32, pattern32; \nimg.convertTo(img32, CV_32F); \npattern.convertTo(pattern32, CV_32F); \n```", "```py\n// Divide the image by the pattern \naux= 1-(img32/pattern32); \n```", "```py\n// Convert 8 bits format \naux.convertTo(aux, CV_8U, 255); \n```", "```py\naux= pattern-img; \n```", "```py\nMat calculateLightPattern(Mat img) \n{ \n  Mat pattern; \n  // Basic and effective way to calculate the light pattern from one image \n  blur(img, pattern, Size(img.cols/3,img.cols/3)); \n  return pattern; \n} \n```", "```py\n  // Binarize image for segment \n  Mat img_thr; \n  if(method_light!=2){ \n   threshold(img_no_light, img_thr, 30, 255, THRESH_BINARY); \n  }else{ \n   threshold(img_no_light, img_thr, 140, 255, THRESH_BINARY_INV); \n  } \n```", "```py\nvoid ConnectedComponents(Mat img) \n{ \n  // Use connected components to divide our image in multiple connected component objects\n     Mat labels; \n     auto num_objects= connectedComponents(img, labels); \n  // Check the number of objects detected \n     if(num_objects < 2 ){ \n        cout << \"No objects detected\" << endl; \n        return; \n      }else{ \n       cout << \"Number of objects detected: \" << num_objects - 1 << endl; \n      } \n  // Create output image coloring the objects \n     Mat output= Mat::zeros(img.rows,img.cols, CV_8UC3); \n     RNG rng(0xFFFFFFFF); \n     for(auto i=1; i<num_objects; i++){ \n        Mat mask= labels==i; \n        output.setTo(randomColor(rng), mask); \n      } \n     imshow(\"Result\", output); \n} \n```", "```py\n  Mat labels; \n  auto num_objects= connectedComponents(img, labels); \n  // Check the number of objects detected \n  if(num_objects < 2){ \n    cout << \"No objects detected\" << endl; \n    return; \n  }else{ \n    cout << \"Number of objects detected: \" << num_objects - 1 << endl;\n```", "```py\nMat output= Mat::zeros(img.rows,img.cols, CV_8UC3); \n```", "```py\nfor(int i=1; i<num_objects; i++){ \n```", "```py\n    Mat mask= labels==i; \n```", "```py\n    output.setTo(randomColor(rng), mask); \n  } \n```", "```py\nimshow(\"Result\", output); \n```", "```py\nvoid ConnectedComponentsStats(Mat img) \n{ \n  // Use connected components with stats \n  Mat labels, stats, centroids; \n  auto num_objects= connectedComponentsWithStats(img, labels, stats, centroids); \n  // Check the number of objects detected \n  if(num_objects < 2 ){ \n    cout << \"No objects detected\" << endl; \n    return; \n  }else{ \n    cout << \"Number of objects detected: \" << num_objects - 1 << endl; \n  } \n  // Create output image coloring the objects and show area \n  Mat output= Mat::zeros(img.rows,img.cols, CV_8UC3); \n  RNG rng( 0xFFFFFFFF ); \n  for(auto i=1; i<num_objects; i++){ \n    cout << \"Object \"<< i << \" with pos: \" << centroids.at<Point2d>(i) << \" with area \" << stats.at<int>(i, CC_STAT_AREA) << endl; \n    Mat mask= labels==i; \n    output.setTo(randomColor(rng), mask); \n    // draw text with area \n    stringstream ss; \n    ss << \"area: \" << stats.at<int>(i, CC_STAT_AREA); \n\n    putText(output,  \n      ss.str(),  \n      centroids.at<Point2d>(i),  \n      FONT_HERSHEY_SIMPLEX,  \n      0.4,  \n      Scalar(255,255,255)); \n  } \n  imshow(\"Result\", output); \n} \n```", "```py\nMat labels, stats, centroids; \n  auto num_objects= connectedComponentsWithStats(img, labels, stats, centroids); \n  // Check the number of objects detected \n  if(num_objects < 2){ \n    cout << \"No objects detected\" << endl; \n    return; \n  }else{ \n    cout << \"Number of objects detected: \" << num_objects - 1 << endl; \n  }\n```", "```py\nfor(auto i=1; i<num_objects; i++){ \n    cout << \"Object \"<< i << \" with pos: \" << centroids.at<Point2d>(i) << \" with area \" << stats.at<int>(i, CC_STAT_AREA) << endl; \n```", "```py\nMat mask= labels==i; \noutput.setTo(randomColor(rng), mask); \n```", "```py\n// draw text with area \nstringstream ss; \nss << \"area: \" << stats.at<int>(i, CC_STAT_AREA); \n```", "```py\nputText(output,  \n  ss.str(),  \n  centroids.at<Point2d>(i),  \n  FONT_HERSHEY_SIMPLEX,  \n  0.4,  \n  Scalar(255,255,255)); \n```", "```py\nvoid findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset=Point()) \n```", "```py\nvoid FindContoursBasic(Mat img) \n{ \n  vector<vector<Point> > contours; \n  findContours(img, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE); \n  Mat output= Mat::zeros(img.rows,img.cols, CV_8UC3); \n  // Check the number of objects detected \n  if(contours.size() == 0 ){ \n    cout << \"No objects detected\" << endl; \n    return; \n  }else{ \n    cout << \"Number of objects detected: \" << contours.size() << endl; \n  } \n  RNG rng(0xFFFFFFFF); \n  for(auto i=0; i<contours.size(); i++){ \n    drawContours(output, contours, i, randomColor(rng)); \n    imshow(\"Result\", output); \n  }\n} \n\n```", "```py\nvector<vector<Point> > contours; \nvector<Vec4i> hierarchy; \nfindContours(img, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE); \n```", "```py\n// Check the number of objects detected \n  if(contours.size() == 0){ \n    cout << \"No objects detected\" << endl; \n    return; \n  }else{ \n    cout << \"Number of objects detected: \" << contours.size() << endl; \n  }\n```", "```py\nfor(auto i=0; i<contours.size(); i++) \n    drawContours(output, contours, i, randomColor(rng)); \n  imshow(\"Result\", output); \n} \n```"]