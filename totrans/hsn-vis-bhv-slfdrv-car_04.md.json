["```py\nimg_threshold = np.zeros_like(channel)\nimg_threshold [(channel >= 180)] = 255\n```", "```py\nimg_threshold[(channel >= 20) & (channel <= 120)] = 255\n```", "```py\nperspective_correction = cv2.getPerspectiveTransform(src, dst)\nperspective_correction_inv = cv2.getPerspectiveTransform(dst, src)\n```", "```py\ncv2.warpPerspective(img, perspective_correction, warp_size, flags=cv2.INTER_LANCZOS4)\n```", "```py\nimg_hls = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HLS).astype(np.float)\n```", "```py\nedge_x = cv2.Scharr(channel, cv2.CV_64F, 1, 0)\n```", "```py\nedge_x = np.absolute(edge_x)\n```", "```py\nedge_x = np.uint8(255 * edge_x / np.max(edge_x))\n```", "```py\nbinary = np.zeros_like(img_edge)\nbinary[img_edge >= 20] = 255\n```", "```py\nbinary[img_edge >= 50] = 255\n```", "```py\nthreshold_up = 15 threshold_down = 60 threshold_delta = threshold_down-threshold_up for y in range(height):  binary_line = binary[y,:]  edge_line = channel_edge[y,:]  threshold_line = threshold_up + threshold_delta * y/height   binary_line[edge_line >= threshold_line] = 255\n```", "```py\npartial_img = img[img.shape[0] // 2:, :]  # Select the bottom part\nhist = np.sum(partial_img, axis=0)  # axis 0: columns direction\n```", "```py\nimport matplotlib.pyplot as plt\n plt.plot(hist)plt.savefig(filename)plt.clf()\n```", "```py\nsize = len(histogram)\nmax_index_left = np.argmax(histogram[0:size//2])\nmax_index_right = np.argmax(histogram[size//2:]) + size//2\n```", "```py\nnon_zero = binary_warped.nonzero()\nnon_zero_y = np.array(non_zero[0])\nnon_zero_x = np.array(non_zero[1])\n```", "```py\nmargin = 80 min_pixels = 50 \n```", "```py\nwin_x_left_min = left_x - margin\nwin_x_left_max = left_x + margin\n```", "```py\nwin_y_top = img_height - idx_window * window_height win_y_bottom = win_y_top + window_height\n```", "```py\nnon_zero_y >= win_y_bottom\n```", "```py\n(non_zero_y >= win_y_bottom) & (non_zero_y < win_y_top)\n```", "```py\nnon_zero_left = ((non_zero_y >= win_y_bottom) &                 (non_zero_y < win_y_top) &                  (non_zero_x >= win_x_left_min) & \n                 (non_zero_x < win_x_left_max)).nonzero()[0]\n```", "```py\nleft_lane_indexes.append(non_zero_left)\n```", "```py\nif len(non_zero_left) > min_pixels:\n    left_x = np.int(np.mean(non_zero_x[non_zero_left]))\n```", "```py\nx_coords = non_zero_x[left_lane_indexes]\ny_coords = non_zero_y[left_lane_indexes]\nleft_fit = np.polynomial.polynomial.polyfit(y_coords, x_coords, 2)\n```", "```py\nploty = np.array([float(x) for x in range(binary_warped.shape[0])])\n```", "```py\nLeft_fitx = left_fit[2] * ploty ** 2 + left_fit[1] * ploty + left_fit[0]\n```", "```py\nmoving_average = beta * prev_average + (1-beta)*new_value\n```", "```py\n1 / (1 - beta)\n```"]