<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Handling Matrices, Files, Cameras, and GUIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Handling Matrices, Files, Cameras, and GUIs</h1></div></div></div><p>This chapter will enable you to perform basic operations required in computer vision, such as dealing with matrices, opening files, capturing videos from a camera, playing videos, and creating GUIs for prototype applications.</p><p>In this chapter, the following topics will be covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic matrix manipulation</li><li class="listitem" style="list-style-type: disc">Pixel manipulation</li><li class="listitem" style="list-style-type: disc">How to load and display images from files</li><li class="listitem" style="list-style-type: disc">How to capture a video from a camera</li><li class="listitem" style="list-style-type: disc">Video playback</li><li class="listitem" style="list-style-type: disc">Swing GUI's integration with OpenCV</li></ul></div><p>By the end of this chapter, you should be able to get this computer vision application started by loading images and creating nice GUIs to manipulate them.</p><div class="section" title="Basic matrix manipulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Basic matrix manipulation</h1></div></div></div><p>From a computer <a id="id65" class="indexterm"/>vision background, we can see an image as a matrix of numerical values, which represents its pixels. For a gray-level image, we usually assign values ranging from 0 (black) to 255 (white) and the numbers in between show a mixture of both. These are generally 8-bit images. So, each element of the matrix refers to each pixel on the gray-level image, the number of columns refers to the image width, as well as the number of rows refers to the image's height. In order to represent a color image, we usually adopt each pixel as a combination of three basic colors: red, green, and blue. So, each pixel in the matrix is represented by a triplet of colors.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>It is important to observe that with 8 bits, we get 2 to the power of eight (<span class="emphasis"><em>2</em></span><span class="emphasis"><em><sup>8</sup></em></span>), which is 256. So, we can represent the range from 0 to 255, which includes, respectively the values used for black and white levels in 8-bit grayscale images. Besides this, we can also represent these levels as floating points and use 0.0 for black and 1.0 for white.</p></div></div><p>OpenCV has a variety of ways to represent images, so you are able to customize the intensity level through the number of bits considering whether one wants signed, unsigned, or floating point data types, as well as the number of channels. OpenCV's convention is seen through the following expression:</p><div class="informalexample"><pre class="programlisting">CV_&lt;bit_depth&gt;{U|S|F}C(&lt;number_of_channels&gt;)</pre></div><p>Here, <code class="literal">U</code> stands for unsigned, <span class="emphasis"><em>S</em></span> for signed, and <span class="emphasis"><em>F</em></span> stands for floating point. For instance, if an 8-bit unsigned single-channel image is required, the data type representation would be <code class="literal">CV_8UC1</code>, while a colored <a id="id66" class="indexterm"/>image represented by 32-bit floating point numbers would have the data type defined as <code class="literal">CV_32FC3</code>. If the number of channels is omitted, it evaluates to 1. We can see the ranges according to each bit depth and data type in the following list:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CV_8U</code>: These are the 8-bit unsigned integers that range from 0 to 255</li><li class="listitem" style="list-style-type: disc"><code class="literal">CV_8S</code>: These are the 8-bit signed integers that range from -128 to 127</li><li class="listitem" style="list-style-type: disc"><code class="literal">CV_16U</code>: These are the 16-bit unsigned integers that range from 0 to 65,535</li><li class="listitem" style="list-style-type: disc"><code class="literal">CV_16S</code>: These are the 16-bit signed integers that range from -32,768 to 32,767</li><li class="listitem" style="list-style-type: disc"><code class="literal">CV_32S</code>: These are the 32-bit signed integers that range from -2,147,483,648 to 2,147,483,647</li><li class="listitem" style="list-style-type: disc"><code class="literal">CV_32F</code>: These are the 32-bit floating-point numbers that range from <code class="literal">-FLT_MAX</code> to <code class="literal">FLT_MAX</code> and include <code class="literal">INF</code> and <code class="literal">NAN</code> values</li><li class="listitem" style="list-style-type: disc"><code class="literal">CV_64F</code>: These are the 64-bit floating-point numbers that range from <code class="literal">-DBL_MAX</code> to <code class="literal">DBL_MAX</code> and include <code class="literal">INF</code> and <code class="literal">NAN</code> values</li></ul></div><p>You will generally start the project from loading an image, but it is important to know how to deal with these values. Make sure you import <code class="literal">org.opencv.core.CvType</code> and <code class="literal">org.opencv.core.Mat</code>. Several constructors are available for matrices as well, for instance:</p><div class="informalexample"><pre class="programlisting">Mat image2 = new Mat(480,640,CvType.CV_8UC3);
Mat image3 = new Mat(new Size(640,480), CvType.CV_8UC3);</pre></div><p>Both of the preceding constructors will construct a matrix suitable to fit an image with 640 pixels of width and 480 pixels of height. Note that width is to columns as height is to rows. Also pay attention to the constructor with the <code class="literal">Size</code> parameter, which expects the width and height order. In case you want to check some of the matrix properties, the methods <code class="literal">rows()</code>, <code class="literal">cols()</code>, and <code class="literal">elemSize()</code> are available:</p><div class="informalexample"><pre class="programlisting">System.out.println(image2 + "rows " + image2.rows() + " cols " + image2.cols() + " elementsize " + image2.elemSize());</pre></div><p>The output of the preceding line is:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Mat [ 480*640*CV_8UC3, isCont=true, isSubmat=false, nativeObj=0xceeec70, dataAddr=0xeb50090 ]rows 480 cols 640 elementsize 3</strong></span>
</pre></div><p>The <code class="literal">isCont</code> property tells us whether this matrix uses extra padding when representing the image, so that it can be hardware-accelerated in some platforms; however, we won't cover it in detail right <a id="id67" class="indexterm"/>now. The <code class="literal">isSubmat</code> property refers to fact whether this matrix was created from another matrix and also whether it refers to the data from another matrix. The <code class="literal">nativeObj</code> object refers to the native object address, which is <a id="id68" class="indexterm"/>a <span class="strong"><strong>Java Native Interface</strong></span> (<span class="strong"><strong>JNI</strong></span>) detail, while <code class="literal">dataAddr</code> points to an internal data address. The element size is measured in the number of bytes.</p><p>Another matrix constructor is the one that passes a scalar to be filled as one of its elements. The syntax for this looks like the following:</p><div class="informalexample"><pre class="programlisting">Mat image = new Mat(new Size(3,3), CvType.CV_8UC3, new Scalar(new double[]{128,3,4}));</pre></div><p>This constructor will initialize each element of the matrix with the triple <code class="literal">{128, 3, 4}</code>. A very useful way to print a matrix's contents is using the auxiliary method <code class="literal">dump()</code> from <code class="literal">Mat</code>. Its output will look similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[128, 3, 4, 128, 3, 4, 128, 3, 4;</strong></span>
<span class="strong"><strong>  128, 3, 4, 128, 3, 4, 128, 3, 4;</strong></span>
<span class="strong"><strong>  128, 3, 4, 128, 3, 4, 128, 3, 4]</strong></span>
</pre></div><p>It is important to note that while creating the matrix with a specified size and type, it will also immediately allocate memory for its contents.</p></div></div>
<div class="section" title="Pixel manipulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Pixel manipulation</h1></div></div></div><p>Pixel manipulation is <a id="id69" class="indexterm"/>often required for one to access pixels in an image. There are several ways to do this and each one has its advantages and disadvantages. A straightforward method to do this is the <code class="literal">put(row, col, value)</code> method. For instance, in order to fill our preceding matrix with <code class="literal">values {1, 2, 3}</code>, we will use the following code:</p><div class="informalexample"><pre class="programlisting">for(int i=0;i&lt;<span class="strong"><strong>image.rows()</strong></span>;i++){
  for(int j=0;j&lt;<span class="strong"><strong>image.cols()</strong></span>;j++){ 
    <span class="strong"><strong>image.put(i, j, new byte[]{1,2,3});</strong></span>
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Note that in the array of bytes <code class="literal">{1, 2, 3}</code>, for our matrix, <code class="literal">1</code> stands for the blue channel, <code class="literal">2</code> for the green, and <code class="literal">3</code> for the red channel, as OpenCV stores its matrix internally in the <a id="id70" class="indexterm"/>
<span class="strong"><strong>BGR</strong></span> (<span class="strong"><strong>blue, green, and red</strong></span>) format.</p></div></div><p>It is okay to access pixels this way for small matrices. The only problem is the overhead of JNI calls for big images. Remember that even a small 640 x 480 pixel image has 307,200 pixels and if we think about a colored image, it has 921,600 values in a matrix. Imagine that it might take around 50ms to make an overloaded call for each of the 307,200 pixels. On the <a id="id71" class="indexterm"/>other hand, if we manipulate the whole matrix on the Java side and then copy it to the native side in a single call, it will take around 13ms.</p><p>If you want to manipulate the pixels on the Java side, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Allocate memory with the same size as the matrix in a byte array.</li><li class="listitem">Put the image contents into that array (optional).</li><li class="listitem">Manipulate the byte array contents.</li><li class="listitem">Make a single <code class="literal">put</code> call, copying the whole byte array to the matrix.</li></ol></div><p>A simple example that will iterate all image pixels and set the blue channel to zero, which means that we will set to zero every element whose modulo is 3 equals zero, that is {0, 3, 6, 9, …}, as shown in the following piece of code:</p><div class="informalexample"><pre class="programlisting">public void filter(Mat image){
  int <span class="strong"><strong>totalBytes</strong></span> = (int)(image.total() * image.elemSize());
  byte buffer[] = new byte[totalBytes];
  <span class="strong"><strong>image.get</strong></span>(0, 0,buffer);
  for(int i=0;i&lt;totalBytes;i++){
    if(i%3==0) <span class="strong"><strong>buffer[i]=0;</strong></span>
  }
  <span class="strong"><strong>image.put</strong></span>(0, 0, buffer);
}</pre></div><p>First, we find out the number of bytes in the image by multiplying the total number of pixels (<code class="literal">image.total</code>) with the element size in bytes (<code class="literal">image.elemenSize</code>). Then, we build a byte array with that size. We use the <code class="literal">get(row, col, byte[])</code>method to copy the matrix contents in our recently created byte array. Then, we iterate all bytes and check the condition that refers to the blue channel (<code class="literal">i%3==0</code>). Remember that OpenCV stores colors internally as {Blue, Green, Red}. We finally make another JNI call to <code class="literal">image.put</code>, which copies the whole byte array to OpenCV's native storage. An example of this filter can be <a id="id72" class="indexterm"/>seen in the following image, which was uploaded by Mromanchenko, licensed under CC BY-SA 3.0:</p><div class="mediaobject"><img src="graphics/3972OS_02_01.jpg" alt="Pixel manipulation"/></div><p>Be aware that Java does not have any unsigned byte data type, so be careful when working with it. The safe procedure is to cast it to an integer and use the And operator (<code class="literal">&amp;</code>) with <code class="literal">0xff</code>. A simple example of this would be <code class="literal">int unsignedValue = myUnsignedByte &amp; 0xff;</code>. Now, <code class="literal">unsignedValue</code> can be checked in the range of 0 to 255.</p></div>
<div class="section" title="Loading and displaying images from files"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Loading and displaying images from files</h1></div></div></div><p>Most <a id="id73" class="indexterm"/>computer vision applications need to retrieve images <a id="id74" class="indexterm"/>from some where. In case you need to get them from <a id="id75" class="indexterm"/>files, OpenCV <a id="id76" class="indexterm"/>comes with several image file loaders. Unfortunately, some loaders depend on codecs that sometimes aren't shipped with the operating system, which might cause them not to load. From the documentation, we see that the following files are supported with some caveats:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Windows bitmaps</strong></span>: <code class="literal">*.bmp</code>, <code class="literal">*.dib</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JPEG files</strong></span>: <code class="literal">*.jpeg</code>, <code class="literal">*.jpg</code>, <code class="literal">*.jpe</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JPEG 2000 files</strong></span>: <code class="literal">*.jp2</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Portable Network Graphics</strong></span>: <code class="literal">*.png</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Portable image format</strong></span>: <code class="literal">*.pbm</code>, <code class="literal">*.pgm</code>, <code class="literal">*.ppm</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sun rasters</strong></span>: <code class="literal">*.sr</code>, <code class="literal">*.ras</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>TIFF files</strong></span>: <code class="literal">*.tiff</code>, <code class="literal">*.tif</code></li></ul></div><p>Note that <a id="id77" class="indexterm"/>Windows bitmaps, the portable image format, and <a id="id78" class="indexterm"/>sun raster formats are supported by all platforms, but the <a id="id79" class="indexterm"/>other formats depend on a few details. In Microsoft Windows and Mac OS X, OpenCV can always read the <span class="emphasis"><em>jpeg</em></span>, <span class="emphasis"><em>png</em></span>, and <span class="emphasis"><em>tiff</em></span> formats. In Linux, OpenCV will look for codecs supplied with the OS, as stated by the documentation, so remember to <span class="emphasis"><em>install the relevant packages (do not forget the development files, for example, "libjpeg-dev" in Debian* and Ubuntu*) to get the codec support or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake</em></span>, as pointed out in imread's official documentation.</p><p>The <code class="literal">imread</code> method is supplied to get access to images through files. Use <code class="literal">Imgcodecs.imread</code> (name of the file) and check whether <code class="literal">dataAddr()</code> from the read image is different from zero to make sure the image has been loaded correctly, that is, the filename has been typed correctly and its format is supported.</p><p>A simple method to open a file could look like the one shown in the following code. Make sure you import <code class="literal">org.opencv.imgcodecs.Imgcodecs</code> and <code class="literal">org.opencv.core.Mat</code>:</p><div class="informalexample"><pre class="programlisting">public Mat openFile(String fileName) throws Exception{
  Mat newImage <span class="strong"><strong>= Imgcodecs.imre</strong></span>ad(fileName);
    if(<span class="strong"><strong>newImage.dataAddr()</strong></span>==0){
      throw new Exception ("Couldn't open file "+fileName);
    }
  return newImage;
}</pre></div></div>
<div class="section" title="Displaying an image with Swing"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Displaying an image with Swing</h1></div></div></div><p>OpenCV <a id="id80" class="indexterm"/>developers are used to a simple cross-platform GUI by OpenCV, which was called as HighGUI, and a handy method called <code class="literal">imshow</code>. It constructs a window easily and displays an image within it, which is nice to create quick prototypes. As Java comes with a popular GUI API called <span class="strong"><strong>Swing</strong></span>, we had better use it. Besides, no <code class="literal">imshow</code> method was available for Java until its 2.4.7.0 version was released. On the other hand, it is pretty simple to create such functionality. Refer to the reference code in <code class="literal">chapter2/swing-imageshow</code>.</p><p>Let's break <a id="id81" class="indexterm"/>down the work in to two classes: <code class="literal">App</code> and <code class="literal">ImageViewer</code>. The <code class="literal">App</code> class will be responsible for loading the file, while <code class="literal">ImageViewer</code> will display it. The application's work is simple and will only need to use Imgcodecs's <code class="literal">imread</code> method, which is shown as follows:</p><div class="informalexample"><pre class="programlisting">package org.javaopencvbook;

import java.io.File;
…
import org.opencv.imgcodecs.Imgcodecs;

public class App
{
  static{ System.loadLibrary(Core.NATIVE_LIBRARY_NAME); }

public static void main(String[] args) throws Exception {
  String filePath = "src/main/resources/images/cathedral.jpg";
  Mat newImage = <span class="strong"><strong>Imgcodecs.imread(filePath)</strong></span>;
  if(newImage.dataAddr()==0){
    System.out.println("Couldn't open file " + filePath);
  } else{
    <span class="strong"><strong>ImageViewer imageViewer = new ImageViewer();</strong></span>
    <span class="strong"><strong>imageViewer.show(newImage, "Loaded image");</strong></span>
  }
  }
}</pre></div><p>Note that the <code class="literal">App</code> class will only read an example image file in the <code class="literal">Mat</code> object and it will call the <code class="literal">ImageViewer</code> method to display it. Now, let's see how the <code class="literal">ImageViewer's show</code> method works:</p><div class="informalexample"><pre class="programlisting">package org.javaopencvbook.util;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.image.BufferedImage;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.WindowConstants;

import org.opencv.core.Mat;
import org.opencv.imgproc.Imgproc;

public class ImageViewer {
  private JLabel imageView;
  
  public void show(Mat image){
    show(image, "");
  }

  <span class="strong"><strong>public void show(Mat image,String windowName){</strong></span>
    <span class="strong"><strong>setSystemLookAndFeel();</strong></span>
    
    <span class="strong"><strong>JFrame frame = createJFrame(windowName);</strong></span>
        
        <span class="strong"><strong>Image loadedImage = toBufferedImage(image);</strong></span>
        <span class="strong"><strong>imageView.setIcon(new ImageIcon(loadedImage));</strong></span>
        
        <span class="strong"><strong>frame.pack();</strong></span>
        <span class="strong"><strong>frame.setLocationRelativeTo(null);</strong></span>
        <span class="strong"><strong>frame.setVisible(true);</strong></span>
    
  <span class="strong"><strong>}</strong></span>

  private JFrame createJFrame(String windowName) {
    JFrame frame = new JFrame(windowName);
    imageView = new JLabel();
    final JScrollPane imageScrollPane = new JScrollPane(imageView);
        imageScrollPane.setPreferredSize(new Dimension(640, 480));
        frame.add(imageScrollPane, BorderLayout.CENTER);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    return frame;
  }

  private void setSystemLookAndFeel() {
    try {
      UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName());
    } catch (ClassNotFoundException e) {
      e.printStackTrace();
    } catch (InstantiationException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (UnsupportedLookAndFeelException e) {
      e.printStackTrace();
    }
  }

  <span class="strong"><strong>public Image toBufferedImage(Mat matrix){</strong></span>
    <span class="strong"><strong>int type = BufferedImage.TYPE_BYTE_GRAY;</strong></span>
    <span class="strong"><strong>if ( matrix.channels() &gt; 1 ) {</strong></span>
      <span class="strong"><strong>type = BufferedImage.TYPE_3BYTE_BGR;</strong></span>
    <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>int bufferSize = matrix.channels()*matrix.cols()*matrix.rows();</strong></span>
    <span class="strong"><strong>byte [] buffer = new byte[bufferSize];</strong></span>
    <span class="strong"><strong>matrix.get(0,0,buffer); // get all the pixels</strong></span>
    <span class="strong"><strong>BufferedImage image = new BufferedImage(matrix.cols(),matrix.rows(), type);</strong></span>
    <span class="strong"><strong>final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();</strong></span>
    <span class="strong"><strong>System.arraycopy(buffer, 0, targetPixels, 0, buffer.length);</strong></span>
    <span class="strong"><strong>return image;</strong></span>
  <span class="strong"><strong>}</strong></span>

}</pre></div><p>Pay attention to the <code class="literal">show</code> and <code class="literal">toBufferedImage</code> methods. <code class="literal">Show</code> will try to set Swing's look and feel to the default native look, which is cosmetic. Then, it will create <code class="literal">JFrame</code> with <code class="literal">JScrollPane</code> and <code class="literal">JLabel</code> inside it. It will then call <code class="literal">toBufferedImage</code>, which will convert an <a id="id82" class="indexterm"/>OpenCV Mat object to a <code class="literal">BufferedImage</code> <a id="id83" class="indexterm"/>AWT. This conversion is made through the creation of a byte array that will store matrix contents. The appropriate size is allocated through the multiplication of the number of channels by the number of columns and rows. The <code class="literal">matrix.get</code> method puts all the elements into the byte array. Finally, the image's raster data buffer is accessed through the <code class="literal">getDataBuffer()</code> and <code class="literal">getData()</code> methods. It is then filled with a fast system call to the <code class="literal">System.arraycopy</code> method. The resulting image is then assigned to <code class="literal">JLabel</code> and then it is easily displayed. Note that this method expects a matrix that is either stored as one channel's unsigned 8-bit or three channel's unsigned 8-bit. In case your image is stored as a floating point, you should convert it using the following code before calling this method, supposing that the image you need to convert is a <code class="literal">Mat</code> object called <code class="literal">originalImage</code>:</p><div class="informalexample"><pre class="programlisting">Mat byteImage = new Mat();
originalImage.convertTo(byteImage, CvType.CV_8UC3);</pre></div><p>This way, you can call <code class="literal">toBufferedImage</code> from your converted <code class="literal">byteImage</code> property.</p><p>The image viewer can be easily installed in any Java OpenCV project and it will help you to show your <a id="id84" class="indexterm"/>images for debugging purposes. The <a id="id85" class="indexterm"/>output of this program can be seen in the next screenshot:</p><div class="mediaobject"><img src="graphics/3972OS_02_02.jpg" alt="Displaying an image with Swing"/></div></div>
<div class="section" title="Capturing a video from a camera"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Capturing a video from a camera</h1></div></div></div><p>The process of capturing frames from a webcam is very complex and it involves hardware <a id="id86" class="indexterm"/>details as well as heavy decoding or decompression <a id="id87" class="indexterm"/>algorithms. Fortunately, OpenCV has wrapped it all in a simple, yet powerful class called <code class="literal">VideoCapture</code>. This class not only grabs an image from a webcam, but also reads video files. In case more advanced access to a camera is required, you may want to use its specialized drivers.</p><p>You can think of a video stream as a series of pictures and you can retrieve each image in <code class="literal">Mat</code> and process it as you like. In order to use the <code class="literal">VideoCapture</code> class to capture a webcam stream, you need to instantiate it using the <code class="literal">VideoCapture(int device)</code> constructor. Note that the constructor parameter refers to the <code class="literal">camera</code> index in case you have several cameras. So, if you have one built-in camera and one USB camera and you create a <code class="literal">videocapture</code> object, such as <code class="literal">new</code> <code class="literal">VideoCapture(1)</code>, then this object will refer to your built-in camera, while <code class="literal">new VideoCapture(0)</code> will refer to your just-plugged-in USB camera or the other way around. Make sure the cameras work in a manufacturer test application and check whether the camera's drivers are also installed before you try to capture images in OpenCV.</p><p>After instantiating your <code class="literal">VideoCapture</code> class, check whether it is instantiated with the <code class="literal">isOpened()</code> method. This will be <code class="literal">false</code> in case something went wrong while accessing your camera. Unfortunately, there won't be much more info, so double-check your drivers. Now that everything is working, call the <code class="literal">read()</code> method to retrieve each captured frame in a loop. Note that this method combines the <code class="literal">VideoCapture grab()</code> and <code class="literal">retrieve()</code> methods. The <code class="literal">grab()</code> method only captures the next frame, which is fast, while the <code class="literal">retrieve()</code> method decodes and returns the captured frame. These methods make more sense when synchronization is important or when you use several cameras, as it will be easier to capture frames that are as close as possible, firstly by calling <code class="literal">grab()</code> for all cameras and then calling <code class="literal">retrieve()</code>. In case things go wrong while using the <code class="literal">read()</code> method, that is, the camera gets disconnected, then the method returns <code class="literal">false</code>.</p><p>Another important point that you need to remember when using the <code class="literal">VideoCapture</code> class is setting the desired camera resolution. This is possible through the <code class="literal">set()</code> property setting method, which requires the <code class="literal">Videoio.CAP_PROP_FRAME_WIDTH</code> and <code class="literal">Videoio.CAP_PROP_FRAME_WIDTH</code> parameters. In case you want a 640 x 480 resolution, you would have to make two calls, as follows:</p><div class="informalexample"><pre class="programlisting">VideoCapture capture = new VideoCapture(0);
capture.set(Videoio.CAP_PROP_FRAME_WIDTH,640);
capture.set(Videoio.CAP_PROP_FRAME_HEIGHT,480);</pre></div><p>Before attempting to set the new resolutions, check your device's capabilities. If you set a resolution the camera can't handle, this might hang the camera or fallback to a resolution where it can capture an image.</p><p>The <code class="literal">videocapture</code> project available in this chapter's sample code shows how to retrieve a webcam stream and display it in the screen pretty much like what happens in the previous <code class="literal">swing-imageshow</code> example. In this project, the <code class="literal">toBufferedImage</code> method has been refactored to <a id="id88" class="indexterm"/>an <code class="literal">ImageProcessor</code> class, which deals only <a id="id89" class="indexterm"/>with the conversion from <code class="literal">Mat</code>—retrieved from the <code class="literal">VideoCapture</code> class—to <code class="literal">BufferedImage</code>, which is required to display the image in Swing. The <code class="literal">main</code> class is also very simple; it only builds a window, instantiates a <code class="literal">VideoCapture</code> class, sets its properties, and goes to a main loop. This will grab a frame from the camera, convert it to <code class="literal">BufferedImage</code> and display it in <code class="literal">JLabel</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package org.javaopencvbook;

import java.awt.Image;
import java.io.File;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

import org.javaopencvbook.utils.ImageProcessor;
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.videoio.Videoio;
import org.opencv.videoio.VideoCapture;

public class App
{
  static{ System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
  }
  
  private JFrame frame;
  private JLabel imageLabel;
  
  public static void main(String[] args) {
   <span class="strong"><strong> App app = new App();</strong></span>
<span class="strong"><strong>    app.initGUI();</strong></span>
<span class="strong"><strong>    app.runMainLoop(args);</strong></span>
  }
  
  private void initGUI() {
    frame = new JFrame("Camera Input Example");  
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
    frame.setSize(400,400);  
    imageLabel = new JLabel();
    frame.add(imageLabel);
    frame.setVisible(true);       
  }

  private void runMainLoop(String[] args) {
    ImageProcessor imageProcessor = new ImageProcessor();
    <span class="strong"><strong>Mat webcamMatImage = new Mat();  </strong></span>
<span class="strong"><strong>    Image tempImage;  </strong></span>
    <span class="strong"><strong>VideoCapture capture = new VideoCapture(0);</strong></span>
<span class="strong"><strong>    capture.set(Videoio.CAP_PROP_FRAME_WIDTH,320);</strong></span>
<span class="strong"><strong>    capture.set(Videoio.CAP_PROP_FRAME_HEIGHT,240);</strong></span>

    if( <span class="strong"><strong>capture.isOpened()</strong></span>){  
    while (true){  
    <span class="strong"><strong>capture.read(webcamMatImage);</strong></span>
    if( !webcamMatImage.empty() ){
  tempImage= imageProcessor.toBufferedImage(webcamMatImage);
  ImageIcon imageIcon = new ImageIcon(tempImage, "Captured video");
  <span class="strong"><strong>imageLabel.setIcon(imageIcon)</strong></span>;
  <span class="strong"><strong>frame.pack();</strong></span>  //this will resize the window to fit the image
      }  
    else{
      System.out.println(" -- Frame not captured -- Break!");
      break;  
    }
  }
  }
  else{
    System.out.println("Couldn't open capture.");
  }
  }
}</pre></div><p>Note that calling <a id="id90" class="indexterm"/>
<code class="literal">frame.pack()</code> will realize the captured frame <a id="id91" class="indexterm"/>size and fit the window according to it. The following screenshot shows a successful execution of the preceding code:</p><div class="mediaobject"><img src="graphics/3972OS_02_03.jpg" alt="Capturing a video from a camera"/></div><p>Be aware that when you open a <code class="literal">VideoCapture</code> device, it might not release the process gracefully, so your <a id="id92" class="indexterm"/>Java application might still be running when you close it. You might need to kill your process (according to your platform) as a last <a id="id93" class="indexterm"/>resort. In Windows, this is as easy as opening the Task Manager, which you can open by pressing <span class="emphasis"><em>CTRL </em></span>+ <span class="emphasis"><em>ALT</em></span> + <span class="emphasis"><em>DEL</em></span> and locating your Java process. To do this, OS X users need to press <span class="emphasis"><em>CMD</em></span> + <span class="emphasis"><em>ALT</em></span> + <span class="emphasis"><em>ESC</em></span>, while Linux users can just issue a <code class="literal">kill</code> command. For troubleshooting, if you are having problems starting your capture device after using it for a while, reconnecting your USB plug can make it work.</p></div>
<div class="section" title="Video playback"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Video playback</h1></div></div></div><p>Another <a id="id94" class="indexterm"/>important I/O task in computer vision is being able to open and process a video file. Fortunately, OpenCV can easily deal with videos through the <code class="literal">VideoCapture</code> class. Instead of constructing it with a device number, as was done previously, we need to create it with the file path. We can also use the empty constructor and make the <code class="literal">open(String filename)</code> method responsible for pointing to the file.</p><p>The <code class="literal">videoplayback</code> project available in the chapter's source code has the same structure as the <code class="literal">swing-imageshow</code> project, explained previously. It only differs when you initialize the <code class="literal">VideoCapture</code> instance:</p><div class="informalexample"><pre class="programlisting">VideoCapture capture = new VideoCapture("src/main/resources/videos/tree.avi");</pre></div><p>We have also put a 50ms delay between each frame so that the whole video doesn't play too fast. There is also code that you can use to manipulate <code class="literal">InterruptedException</code>. Note that the video files won't play with the same velocity as seen in a video player device. This is because the <code class="literal">capture.read(webcamMatImage);</code> method is called as quickly as possible. You can also add delays to the code so that it plays slower than the usual pace. Although it is not covered in this section, the <code class="literal">get</code> method from the <code class="literal">VideoCapture</code> class when called with the <code class="literal">CV_CAP_PROP_FPS</code> parameter should return the video frames per second, so that you can play it in the original frame rate.</p><p>In case your video is not loaded, it might be an uninstalled codec issue. Try installing it or looking for other codecs so that this bug is finished. Another option to do this is to use tools to convert your video to supported codecs. It might also be the case where the <code class="literal">opencv_ffmpeg300</code> dynamic link library goes missing from your path environmental variable. Try copying it to your project home folder or adding it to your path variable. That should work. Make sure you point your java.library.path to the folder that contains this library, in the same way you configured your projects to find native OpenCV libraries, as described in <a class="link" href="ch01.html" title="Chapter 1. Setting Up OpenCV for Java">Chapter 1</a>, <span class="emphasis"><em>Setting Up OpenCV for Java</em></span>.</p></div>
<div class="section" title="Swing GUI's integration with OpenCV"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Swing GUI's integration with OpenCV</h1></div></div></div><p>It is important to <a id="id95" class="indexterm"/>have rich graphical user interfaces while <a id="id96" class="indexterm"/>debugging or experimenting with computer vision projects, since some tasks might require a lot of tuning. This way, dealing with sliders, buttons, labels, and mouse events should be in the backpack of any computer vision researcher. Thankfully, you can work with all of these components in a relatively easy way in Swing. In this section, we will cover the most important parts of creating an application that loads an image and blurs it at several levels through a slider. This application also makes use of mouse events to highlight details in the image as well as a nice button to click and clear everything. The next screenshot gives us a good idea of how the application works. The code can be found in the <code class="literal">opencv-gui</code> project within the code bundle for this book.</p><div class="mediaobject"><img src="graphics/3972OS_02_04.jpg" alt="Swing GUI's integration with OpenCV"/></div><p>The code to <a id="id97" class="indexterm"/>load an image is not new to us and can be <a id="id98" class="indexterm"/>found in the <span class="emphasis"><em>Displaying an image with Swing</em></span> section. We will pay closer attention to the <code class="literal">setupSlider()</code>, <code class="literal">setupImage()</code>, and <code class="literal">setupButton()</code> methods. Read the <code class="literal">setupSlider</code> method and we will then cover it in detail later:</p><div class="informalexample"><pre class="programlisting">private void setupSlider(JFrame frame) {
JLabel sliderLabel = new JLabel("Blur level", JLabel.CENTER);
sliderLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

int minimum = 0;
int maximum = 10;
int initial =0;
JSlider levelSlider = new JSlider(JSlider.HORIZONTAL, minimum, maximum, initial);

levelSlider.setMajorTickSpacing(2);
levelSlider.setMinorTickSpacing(1);
levelSlider.setPaintTicks(true);
levelSlider.setPaintLabels(true);
levelSlider.addChangeListener(new ChangeListener() {

  public void stateChanged(ChangeEvent e) {
    <span class="strong"><strong>JSlider source = (JSlider)e.getSource();</strong></span>
    <span class="strong"><strong>int level = (int)source.getValue();</strong></span>
    <span class="strong"><strong>Mat output = imageProcessor.blur(image, level);</strong></span>
    updateView(output);
    }
  });
frame.add(sliderLabel);
frame.add(levelSlider);
}</pre></div><p>Note that a <a id="id99" class="indexterm"/>slider is simply a <code class="literal">Jslider</code> class and we need <a id="id100" class="indexterm"/>to set its minimum, maximum, and initial values through the constructor. We also set whether it's a vertical or horizontal slider. Some cosmetic details, such as the major and minor tick spacing and whether to paint or not labels and ticks are also set. A key method in the slider is its <code class="literal">stateChanged</code> listener provided by the anonymous class, which implements the <code class="literal">ChangeListener</code> interface. This is basically what happens when the user changes the slider. In our case, we will blur the image the number of times set by the slider. This is done through our implemented <code class="literal">ImageProcessor</code> class, which basically calls the <code class="literal">Imgproc blur</code> method, a very simple filter that only calculates the mean of a number of neighbor pixels. The value addressed by the slider is obtained through a call to <code class="literal">source.getValue()</code>.</p><p>Another important task is being responsive to the mouse click events. This is achieved by adding <code class="literal">MouseListener</code> to our <code class="literal">JLabel</code> image view. The following is the <code class="literal">setupImage</code> method:</p><div class="informalexample"><pre class="programlisting">private void setupImage(JFrame frame) {
  JLabel mouseWarning = new JLabel("Try clicking on the image!", JLabel.CENTER);
  mouseWarning .setAlignmentX(Component.CENTER_ALIGNMENT);
  mouseWarning.setFont(new Font("Serif", Font.PLAIN, 18));
  frame.add(mouseWarning);

  imageView = new JLabel();

  final JScrollPane imageScrollPane = new JScrollPane(imageView);
  imageScrollPane.setPreferredSize(new Dimension(640, 480));

  imageView.addMouseListener(new MouseAdapter()
  {
   <span class="strong"><strong> public void mousePressed(MouseEvent e)</strong></span>
    <span class="strong"><strong>{</strong></span>
      <span class="strong"><strong>Imgproc.circle(image,new Point(e.getX(),e.getY()),20, new Scalar(0,0,255), 4);</strong></span>
      <span class="strong"><strong>updateView(image);</strong></span>
    <span class="strong"><strong>}</strong></span>
  });

frame.add(imageScrollPane);
}</pre></div><p>The <code class="literal">mousePressed()</code>method implemented in the preceding code is responsible for answering all the <a id="id101" class="indexterm"/>mousedown events. We can get local <a id="id102" class="indexterm"/>coordinates through the <code class="literal">getX()</code> and <code class="literal">getY()</code> event methods. Note that we call <code class="literal">Imgproc.circle</code>, which is an OpenCV function that will draw a circle in the desired matrix, in the desired position, and we can define its radius, color, and thickness.</p><p>The last GUI component explored in this example is a button that is created through the <code class="literal">JButton</code> component, which implements the <code class="literal">actionPerformed</code> interface. As we have previously stored the original image, it's easy to clear the image by just copying the original one back:</p><div class="informalexample"><pre class="programlisting">private void setupButton(JFrame frame) {
  JButton clearButton = new JButton("Clear");
  clearButton.addActionListener(new ActionListener() {

  <span class="strong"><strong>public void actionPerformed(ActionEvent event) {</strong></span>
    <span class="strong"><strong>image = originalImage.clone();</strong></span>
    <span class="strong"><strong>updateView(originalImage);</strong></span>
  <span class="strong"><strong>}</strong></span>
});
clearButton.setAlignmentX(Component.CENTER_ALIGNMENT);
frame.add(clearButton);
}</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>Wow! A lot of details have been covered in this chapter, but we have finally grasped the development of a complete application for computer vision. We touched on the topic of core structure from OpenCV, which is the <code class="literal">Mat</code> class for basic pixel manipulation, and its close relation to Swing's <code class="literal">BufferedImage</code> class. Besides this, we covered important tasks such as opening image files and displaying them in a Swing application. The important area of live video streaming has been covered with the <code class="literal">VideoCapture</code> class, which shows you how to obtain frames from a webcam as well as from video files. Finally, we created a rich graphical user interface application with sliders, labels, buttons and by handling mouse events in Java.</p><p>The foundations of working with a Java OpenCV API have been set and we are ready to go on to the next chapter, which will deal with core operators in image processing, such as smoothing filters to remove noise, using morphological operators to isolate elements, using bucket fill for segmentation, image pyramids, and the essential task of thresholding. Be sure to check them out.</p></div></body></html>