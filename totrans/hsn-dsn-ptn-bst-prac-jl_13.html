<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Anti-Patterns</h1>
                </header>
            
            <article>
                
<p class="mce-root">Over the last five chapters, we have looked in great detail at reusability, performance, maintainability, safety, and some miscellaneous design patterns. These patterns are extremely useful and can be applied to various situations for different types of applications. While it is important to know what the best practices are, it is also beneficial to understand what pitfalls to avoid. To do this, we are going to cover several <strong>anti-patterns</strong> in this chapter.</p>
<p>Anti-patterns are bad practices that programmers may do unintentionally. Sometimes, these problems are not severe enough to cause trouble; however, it is possible that an application may become unstable or have degraded performance due to improper design. In this chapter, we will cover the following topics:</p>
<ul>
<li>Piracy anti-pattern</li>
<li>Narrow argument types anti-pattern</li>
<li>Nonconcrete field types anti-pattern</li>
</ul>
<p>By the end of this chapter, you will have learned how to avoid developing pirate functions. You will also be more conscious and smart about the level of abstraction when specifying the type of function arguments. Finally, you will be able to leverage more parametric types in your design for your own composite types for high-performance applications.</p>
<p>Let's start with the most interesting topic—piracy!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10</a><a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10"><span>.</span></a></p>
<p>The code is tested in a Julia 1.3.0 environment.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Piracy anti-pattern</h1>
                </header>
            
            <article>
                
<p>In <a href="48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml">Chapter 2</a>, <em>Modules, Packages and Data Type Concepts</em>, we learned how to create new namespaces using modules. As you may recall, modules are used to define functions so that they are logically separated. It is possible, then, that we can define two different functions—one in module X and another in module Y, with both having exactly the same name. In fact, these functions do not even need to mean the same thing. For example, in a mathematics package, we can define a <kbd>trace</kbd> function for matrices. In a computer graphics package, we can define a <kbd>trace</kbd> function for doing ray tracing work. These two <kbd>trace</kbd> functions perform different things, and they do not interfere with each other. </p>
<p>On the other hand, a function can also be designed to be extended from another package. For example, in the <kbd>Base</kbd> package, the <kbd>AbstractArray</kbd> interface is designed to be extended. Here's an example:</p>
<pre># My own array-like type for tracking scores<br/>struct Scores &lt;: AbstractVector{Float64}<br/>    values::Vector{Float64}<br/>end<br/><br/># implement AbstractArray interface<br/>Base.size(s::Scores) = (length(s.values),)<br/>Base.getindex(s::Scores, i::Int) = s.values[i]</pre>
<p>Here, we have extended the <kbd>size</kbd> and <kbd>getindex</kbd> functions from the <kbd>Base</kbd> package so that they can work with our own data types. This is a perfectly good usage of the Julia language; however, it can be problematic when we do not extend functions from other packages correctly. In particular,<em> piracy</em> refers to the situation in which a third-party function is replaced or extended in a bad way. This is an anti-pattern because it may cause system behavior to become nondeterministic. For convenience, we can define three different kinds of piracy:</p>
<ul>
<li><strong>Type I piracy</strong>: Function is redefined </li>
<li><strong>Type II piracy</strong>:<span> Function is extended without using your own types in any of the arguments </span></li>
<li><strong>Type III piracy</strong>: Function is extended but used for a different purpose</li>
</ul>
<p>We will now drill down into each one in more detail.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type I – Redefining a function</h1>
                </header>
            
            <article>
                
<p>Type I piracy refers to the situation where a programmer redefines a third-party function from their own module. Perhaps you did not like the original implementation in the third-party module and replaced the function with your own implementation.</p>
<p>The worst form of Type I piracy is when you replace the function without conforming to the original function's interface. Let's do an experiment and see what could happen. We will use the <kbd>+</kbd> function from <kbd>Base</kbd> as an example. As you know, when the <kbd>+</kbd> function is passed with two <kbd>Int</kbd> arguments, it should return an <kbd>Int</kbd> value as a result. What would happen if we replace the function so that it returns a string? Let's open up a REPL and give it a try:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f79f8cb7-b6c1-403c-a428-9b1d907a190c.png" style="width:53.75em;height:18.00em;"/></p>
<p><span><em>Boom! </em>Th</span><span>e Julia REPL crashed immediately as soon as the function was defined. </span>That is because the return value of this <kbd>+</kbd> function is expected to be an integer. When we return a string, it violates the contract of this function and all functionalities that rely on the <kbd>+</kbd> function are negatively impacted. Given that <kbd>+</kbd> is a commonly used function, it crashes the system immediately.</p>
<p>Why does Julia even allow us to do that? For some situations, the ability to do this can be useful. Say that <span>you found a bug for a specific function in a third-party package—you can inject a fix immediately without having to wait for the bug fix upstream. Likewise, you can replace a slow function with a more performant version. Ideally, these changes should be sent upstream, but you have the flexibility to implement the change immediately.</span></p>
<p>The only requirement is that the function being replaced should adhere to the same contract that was originally intended. Therefore, it requires an intimate understanding about how the third-party package is designed. In reality, it is even better if you can contact the original author and discuss the change before applying piracy.</p>
<p><em><span>With great power comes great responsibility. </span></em><span>Great care must be taken if we ever want to make use of Type I piracy. </span></p>
<p><span>Next, we will look into Type II piracy, which is more common across packages in the Julia ecosystem.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type II piracy – Extending without your own types</h1>
                </header>
            
            <article>
                
<p>Type II piracy is commonly known as <em>type piracy</em> by the Julia developer community. It refers to the situation where a third-party function is extended without using the programmer's own types in any of the function arguments. It usually happens when you want to extend the third-party package by injecting your own code. Let's go through a hypothetical example.</p>
<p>Suppose that you want to mimic the same behavior in JavaScript of adding a string and a number together, where the values concatenate as if they are both strings:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/181d749d-f102-4928-ba25-6006356a6a51.png" style="width:44.33em;height:7.58em;"/></p>
<p>To make it happen in Julia, we would be tempted to do the following in <kbd>MyModule</kbd>:</p>
<pre>module MyModule<br/>    import Base.+<br/>    (+)(s::AbstractString, n::Number) = "$s$n"<br/>end</pre>
<p>We can paste the preceding code in the REPL and do a quick test:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a13e987f-88e4-4c69-8b2b-38b551f95014.png" style="width:13.75em;height:5.67em;"/></p>
<p>This seems to be working great! But there are some hidden issues with this approach. Let's look at why it is still a bad idea.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conflicting with another pirate</h1>
                </header>
            
            <article>
                
<p>Now that we are using the enhanced version of the <kbd>+</kbd> function, can we rely on the fact that the function will always do exactly what we have made it do? Perhaps surprisingly, the answer is no.</p>
<p>Let's say we have found an open source package called <kbd>AnotherModule</kbd>, and we want to use it in our <kbd>MyModule</kbd> module. The <kbd>AnotherModule</kbd> module happens to do the same kind of type II piracy; however, the author decided to do the <em>right</em> thing—instead of concatenating the arguments as if they are strings, the string argument is parsed into a number and then the two numbers are added together. The code is as follows:</p>
<pre>module AnotherModule<br/>    import Base: +, -, *, /<br/>    (+)(s::AbstractString, n::T) where T &lt;: Number = parse(T, s) + n<br/>    (-)(s::AbstractString, n::T) where T &lt;: Number = parse(T, s) - n<br/>    (*)(s::AbstractString, n::T) where T &lt;: Number = parse(T, s) * n<br/>    (/)(s::AbstractString, n::T) where T &lt;: Number = parse(T, s) / n<br/>end</pre>
<p>If we go back to the REPL and define this module, then we get the new definition:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5dbbd88c-0b23-4057-9025-d16729e75e80.png" style="width:17.00em;height:5.92em;"/></p>
<p>We now have two implementations of the same function with exactly the same signature, and they return different results. <span>Who is going to win? </span>Is it the one defined in <kbd>MyModule</kbd> or the one in <kbd>AnotherModule</kbd>? Only one of them can be in effect. That means that either <kbd>AnotherModule</kbd> or <kbd>MyModule</kbd> is going to break. This problem can lead to a disastrous situation and hard-to-find bugs.</p>
<p>Another reason to avoid type II piracy is the future-proofing problem. We will discuss this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Future-proofing your code</h1>
                </header>
            
            <article>
                
<p>Say that we have extended the <kbd>+</kbd> function in <kbd>Base</kbd> as follows:</p>
<pre>module MyModule<br/>    import Base.+<br/>    (+)(s::AbstractString, n::Number) = "$s$n"<br/>end</pre>
<p>It may seem to be a great addition today; however, there is no guarantee that the same function will not be implemented in a future version of Julia. It is conceivable (which is not to say that it's likely or unlikely) that the <kbd>+</kbd> function will be enhanced to work with strings in the future. </p>
<p>In addition, these kinds of changes would be considered nonbreaking, meaning that the Julia dev team can add this feature with just a minor release. Unfortunately, your application now breaks for a nonbreaking Julia upgrade. That's not something that we normally expect.</p>
<p><em>If you want to future-proof your code, then do not be a pirate!</em> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding type piracy</h1>
                </header>
            
            <article>
                
<p>Type II piracy can be mitigated by creating your own types and using them in the function argument. In this case, perhaps we should consider creating a wrapper type to hold the string and using this new type for dispatch:</p>
<pre>module MyModule<br/>    export @str_str<br/>    import Base: +, show<br/><br/>    struct MyString<br/>        value::AbstractString<br/>    end <br/><br/>    macro str_str(s::AbstractString) <br/>        MyString(s)<br/>    end<br/><br/>    show(io::IO, s::MyString) = print(io, s.value)<br/>    (+)(s::MyString, n::Number) = MyString(s.value * string(n))<br/>    (+)(n::Number, s::MyString) = MyString(string(n) * s.value)<br/>    (+)(s::MyString, t::MyString) = MyString(s.value * t.value)<br/>end</pre>
<p>Here, we have redefined the module with a new <kbd>MyString</kbd> type that holds a string. Then, we can still extend the <kbd>+</kbd> function to concatenate <kbd>MyString</kbd> with any number. For completeness, we have defined three variations of the <kbd>+</kbd> function for accepting <kbd>MyString</kbd> and <kbd>Number</kbd> arguments in any order and another one that accepts two <kbd>MyString</kbd> arguments. We have also defined a <kbd>str_str</kbd> macro for convenience. The new module works properly as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/55f649ff-8e46-490a-b929-0f53af5fbd9e.png" style="width:25.50em;height:6.00em;"/></p>
<p>By using your own type in the function argument, we can avoid any conflict with other dependent packages, as well as future-proofing our code for Julia upgrades.</p>
<p>The last kind of piracy is somewhat less severe but still worth a look. Let's take a look at that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type III piracy – Extending with your own type, but for a different purpose</h1>
                </header>
            
            <article>
                
<p>Type III piracy refers to the situation where a function is extended, but is used for a different purpose. It is the right procedure of extending code, but done in a bad way. This kind of piracy is also called a <em>pun </em>by the Julia developers. To understand what it is, let's consider a fun example here.</p>
<p>Suppose that we are developing a simple party registration application. The type definition and constructor are shown here:</p>
<pre># A Party just contains a title and guest names<br/>struct Party<br/>    title::String<br/>    guests::Vector{String}<br/>end<br/><br/># constructor<br/>Party(title) = Party(title, String[])</pre>
<p>The <kbd>Party</kbd> type contains just a title and an array of guest names. The constructor just takes the title and initializes the guest array as an empty array. Now, just to be cute, we can define a function for joining a party as follows:</p>
<pre>Base.join(name::String, party::Party) = push!(party.guests, name)</pre>
<p>This is an extension to the <kbd>join</kbd> method from <kbd>Base</kbd>. Why would we want to do that? Well, if we create the <kbd>join</kbd> function in our own namespace, then we can get into a naming conflict with the standard <kbd>join</kbd> function. To avoid handling that conflict, maybe it is easier to just extend the function from <kbd>Base</kbd>.</p>
<p>At first glance, it would work as expected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe6cd83a-ab76-44ad-9b78-a29c23dcc77b.png" style="width:23.92em;height:15.33em;"/></p>
<p>However, there is a hidden trap. If we were to let multiple people join the party at the same time, then we could get into trouble easily:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/880ac20d-0858-48d9-abad-23375c8ded03.png" style="width:34.83em;height:3.42em;"/></p>
<p>What happened? Let's take a look at the original meaning of the <kbd>join</kbd> function, as shown in the <kbd>help</kbd> screen:</p>
<pre>help?&gt; join<br/><br/>  join([io::IO,] strings, delim, [last])</pre>
<p>The purpose of the <kbd>join</kbd> function is to take multiple strings and put them together separated by some kind of delimiter. So the call to the <kbd>join</kbd> function in the preceding code ended up using the <kbd>Party</kbd> object as a delimiter. </p>
<p>Let's think a little bit about how we got into trouble. When we defined the function using our own type (<kbd>Party</kbd>), we did not expect our function to be used by any other code except our own. However, that is not true here. Our function was clearly utilized by the string concatenation logic from the <kbd>Base</kbd> package. </p>
<p>It turns out that we are an unfortunate victim of <em>duck typing</em>. If you look into the source code of Julia, you will find that some <kbd>join</kbd> functions are defined without specifying any type in the arguments. So, when we pass a <kbd>Party</kbd> object to the <kbd>join</kbd> function, it leaks into the original <kbd>join</kbd> logic. Worse yet, no error was thrown because everything just <em>worked</em>.</p>
<p>It is best to avoid type III piracy altogether. In the preceding example, we could have defined the <kbd>join</kbd> function in our own module rather than extending the one from <kbd>Base</kbd>. If we are bothered by the name conflict issue, we can also choose a different function name—for example, <kbd>register</kbd>. We have to realize that the meaning of joining a party is not the same as joining strings together.</p>
<p>All three types of piracy are bad, and they can cause bugs that are surprisingly difficult to find or debug. We should avoid them as much as possible.</p>
<p>Next, we will go over another anti-pattern related to specifying argument types in function definitions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Narrow argument types anti-pattern</h1>
                </header>
            
            <article>
                
<p>When designing functions in Julia, we have many options about whether and how to provide the type of arguments. The narrow argument types anti-pattern refers to the situation in which the types of the arguments are too narrowly specified, causing the function to be less useful unnecessarily.</p>
<p>Let's consider a simple example function that is used for computing the sum of the products of two vectors:</p>
<pre>function sumprod(A::Vector{Float64}, B::Vector{Float64})<br/>    return sum(A .* B)<br/>end</pre>
<p>There is nothing wrong with this design, except that the function can only be used when the arguments are vectors of <kbd>Float64</kbd> values. What are the other possible options? Let's take a look at that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Considering various options for argument types</h1>
                </header>
            
            <article>
                
<p>Julia's dispatch mechanism can select the right function to call as long as the type of the arguments being passed matches the signature of the function. Based upon the type hierarchy, we can possibly specify abstract types and the function still gets selected properly.</p>
<p>Such flexibility gives us many options. We can consider any of the following:</p>
<ul>
<li><kbd>sumprod(A::Vector{Float64}, B::Vector{Float64})</kbd></li>
<li><kbd>sumprod(A::Vector{Number}, B::Vector{Number})</kbd></li>
<li><kbd>sumprod(A::Vector{T}, B::Vector{T}) where T &lt;: Number</kbd></li>
<li><kbd>sumprod(A::Vector{S}, B::Vector{T}) where {S &lt;: Number, T &lt;: Number}</kbd></li>
<li><kbd>sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S &lt;: Number, T &lt;: Number}</kbd></li>
<li><kbd>sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N, S &lt;: Number, T &lt;: Number}</kbd></li>
<li><kbd><span>sumprod(A, B)</span></kbd></li>
</ul>
<p>Which one is the most appropriate option for our function? We're not sure yet, but we can always revisit our requirements and perform some testing before drawing a conclusion.</p>
<p>Let's first define what scenarios we plan to support. As we expect, this is just a numeric calculation: we would like to support any numeric container that supports broadcasting. Broadcasting is required because we use dot notation when calculating the product of A and B in the preceding code.</p>
<p>Our test scenarios involve the following combinations of arguments:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign"><strong>Scenario</strong></td>
<td class="CDPAlignLeft CDPAlign"><strong>Argument 1</strong></td>
<td class="CDPAlignLeft CDPAlign"><strong>Argument 2</strong></td>
</tr>
<tr>
<td>1</td>
<td><kbd>Array{Float64, 1}</kbd></td>
<td><kbd>Array{Float64, 1}</kbd></td>
</tr>
<tr>
<td>2</td>
<td><kbd>Array{Int64, 1}</kbd></td>
<td><kbd><span>Array{Int64, 1}</span></kbd></td>
</tr>
<tr>
<td>3</td>
<td><kbd>Array{Int, 1}</kbd></td>
<td><kbd><span>Array{Float64, 1}</span></kbd></td>
</tr>
<tr>
<td>4</td>
<td><kbd>Array{Float64, 2}</kbd></td>
<td><kbd><span>Array{Float64, 2}</span></kbd></td>
</tr>
<tr>
<td>5</td>
<td><kbd>Array{Number,1}</kbd></td>
<td><kbd><span>Array{Number,1}</span></kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>To test these scenarios for various function signature options, we can build a test harness function, as follows:</p>
<pre>function test_harness(f, scenario, args...)<br/>    try <br/>        f(args...)<br/>        println(f, " #$(scenario) success")<br/>    catch ex<br/>        if ex isa MethodError<br/>            println(f, " #$(scenario) failure (method not selected)")<br/>        else<br/>            println(f, " #$(scenario) failure (unknown error $ex)")<br/>        end<br/>    end<br/>end</pre>
<p>The test harness applies function <kbd>f</kbd> with the provided arguments <kbd>args</kbd> for a specific <kbd>scenario</kbd>. If the function is dispatched, it displays a success message in the console; otherwise, it displays a failure message. As we want to test the preceding listed scenarios, we can define just one more function so that we can execute our tests easily:</p>
<pre>function test_sumprod(f)<br/>    test_harness(f, 1, [1.0,2.0], [3.0, 4.0]);<br/>    test_harness(f, 2, [1,2], [3,4]);<br/>    test_harness(f, 3, [1,2], [3.0,4.0]);<br/>    test_harness(f, 4, rand(2,2), rand(2,2));<br/>    test_harness(f, 5, Number[1,2.0], Number[3.0, 4]);<br/>end</pre>
<p>The <kbd>test_sumprod</kbd> function takes a function and executes the five preceding test cases.</p>
<p>Now we are all set. Let's dissect each option and see how well they work for us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Option 1 – Vectors of Float64 values</h1>
                </header>
            
            <article>
                
<p>The first option is what we started with at the beginning of this section. It has the most specific types of arguments. The drawback is that it can only work with a vector of <kbd>Float64</kbd> values.</p>
<p>Let's define our function as follows so that we can pass it to the testing function:</p>
<pre>sumprod_1(A::Vector{Float64}, B::Vector{Float64}) = sum(A .* B)</pre>
<p class="mce-root">We can try our test harness now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/722c66c6-4c47-4dd5-bfb4-69630ca827e8.png" style="width:27.92em;height:9.25em;"/></p>
<p>As expected, this function can work with the first scenario when both arguments are vectors of <kbd>Float64</kbd> values. So it does not satisfy all of our requirements. Let's try the next option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Option 2 – Vectors of instances of Number</h1>
                </header>
            
            <article>
                
<p>The second option is a little more interesting. We have switched the type parameter from <kbd>Float64</kbd> to <kbd>Number</kbd>, which is the topmost abstract type in the numeric type hierarchy:</p>
<pre>sumprod_2(A::Vector{Number}, B::Vector{Number}) = sum(A .* B)</pre>
<p>Let's test it now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/be78eef1-fd52-43b2-98e9-7f799d0439f2.png" style="width:27.42em;height:9.08em;"/></p>
<p>At first glance, it may appear that using <kbd>Number</kbd> as a type parameter would make it more generic. It turns that out that it can only accept an array of <kbd>Number</kbd> types, which means that it has to be a heterogenous array where each element can be a different type as long as all element types are subtypes of <kbd>Number</kbd>. For that reason, a vector of <kbd>Float64</kbd> values is not a subtype of a vector of <kbd>Number</kbd> values. Check the following code snippet:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2da93bb-6858-4bd4-9ad8-b4db15d9ff03.png" style="width:26.17em;height:3.42em;"/></p>
<p>For that reason, none of the scenarios was successful except the last one, which takes vectors of <kbd>Number</kbd> exactly as arguments. So this option is not a great one either. Let's move on!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Option 3 – Vectors of type T where T is a subtype of Number</h1>
                </header>
            
            <article>
                
<p>The third option is to take vectors of type <kbd>T</kbd>, where <kbd>T</kbd> is just a subtype of <kbd>Number</kbd>.</p>
<p>The function can be defined as follows:</p>
<pre>sumprod_3(A::Vector{T}, B::Vector{T}) where T &lt;: Number = sum(A .* B)</pre>
<p>Let's try it first:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/da1489bb-1a10-4dbb-85c2-bc4258a76abb.png" style="width:27.33em;height:9.08em;"/></p>
<p>As the type parameter <kbd>T</kbd> can be any subtype of <kbd>Number</kbd>, this function comfortably handles vectors of <kbd>Float64</kbd>, <kbd>Int64</kbd>, and even <kbd>Number</kbd> types. Unfortunately, it cannot handle arguments of different types, but we should be able to improve it further. Let's try the next option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Option 4 – Vectors of type S and T where S and T are subtypes of Number</h1>
                </header>
            
            <article>
                
<p>This option differs from option 3 only in the way that the types of arguments are separately specified. Thus, the function can accept different types for the first and second arguments. The function is defined as follows:</p>
<pre>sumprod_4(A::Vector{S}, B::Vector{T}) where {S &lt;: Number, T &lt;: Number} = sum(A .* B)</pre>
<p>We can try it now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/54817012-bf9b-4a6e-9382-4435067dc8aa.png" style="width:26.67em;height:8.67em;"/></p>
<p>We have definitely addressed the issue with mixed argument types by now. We're getting close to the final destination. Scenario 4 is the case where the arguments are matrices rather than vectors. For sure we know how to fix this, so let's do that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Option 5 – Arrays of type S and type T where S and T are subtypes of Number</h1>
                </header>
            
            <article>
                
<p>Since Julia arrays support broadcasting, we can generalize the function arguments from a <kbd>Vector{T}</kbd> to an <kbd>Array{T,N}</kbd> signature in order to support multidimensional arrays. Let's now define the function as follows:</p>
<pre>sumprod_5(A::Array{S,N}, B::Array{T,N}) where {N, S &lt;: Number, T &lt;: Number} = <br/>    sum(A .* B)</pre>
<p>We have pretty good confidence that this would work. Let's test it now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c8503b9-bb20-493c-9990-442b3e64bb31.png" style="width:19.17em;height:8.75em;"/></p>
<p><em>Fabulous!</em> We have finally satisfied all the requirements as listed in the test scenarios. Are we done? Maybe not. For the sake of argument, we may want to support other types of containers that are not necessarily a dense array. What if the input is sparse matrices? Let's improve the function once again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Option 6 – Abstract arrays</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>AbstractArray</kbd> is the abstract type for all Julia array containers. Many Julia packages implement the array interface and are made to be subtypes of <kbd>AbstractArray</kbd>. It would be a shame if we go so far to make the <kbd>sumprod</kbd> function versatile enough, and yet we cannot support sparse matrices or other types of array-type containers. To make it more general, let's turn our function definition from <kbd>Array</kbd> to <kbd>AbstractArray</kbd> as follows:</p>
<pre>sumprod_6(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where <br/>    {N, S &lt;: Number, T &lt;: Number} = sum(A .* B)</pre>
<p>The signature is the same as the previous option, except that the function can be dispatched with any <kbd>AbstractArray</kbd> container types. Let's make sure that the function works as expected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5635c61d-1a34-464e-a158-c11fd39e2365.png" style="width:17.75em;height:8.25em;"/></p>
<p>The function is working properly for our existing cases. Let's just try it once again using the sparse matrix type:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/159e5aa8-4b96-44ac-8563-39a8cfb6f1b1.png" style="width:34.58em;height:20.67em;"/></p>
<p><em>Bravo!</em> It is working great now, even with a non-dense array type. We are almost done. Let's look at our last option—duck typing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Option 7 – Duck typing</h1>
                </header>
            
            <article>
                
<p>Our last option basically skips the types in the function arguments. This is also called duck typing, as the function will be dispatched as long as two arguments are provided. Julia will specialize and compile a new version for different variations of the argument types. The function is simply defined as follows:</p>
<pre>sumprod_7(A, B) = sum(A .* B)</pre>
<p>For completeness, we will run the test again:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/102bb95c-6403-4519-9065-5a400edd9561.png" style="width:18.92em;height:8.67em;"/></p>
<p>The benefit of this option is that the function is free of type information in the signature, so it looks very clean. However, the drawback is that the function can be dispatched for any type—not even an array or for numeric values. When garbage is passed into the function, garbage comes out, or the function just throws an error when the objects being passed do not have the <kbd>*</kbd> operator function defined.</p>
<p>Now that we have considered all the options and performed the respective tests, let's summarize what we have done so far and what we would want to do next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summarizing all options</h1>
                </header>
            
            <article>
                
<p>Let's now summarize all the options that we have considered so far:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<thead>
<tr>
<td class="CDPAlignLeft CDPAlign"><strong>Option</strong></td>
<td class="CDPAlignLeft CDPAlign"><strong>Signature</strong></td>
<td class="CDPAlignLeft CDPAlign"><strong>Passed all tests?</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign">1</td>
<td><kbd>sumprod(A::Vector{Float64}, B::Vector{Float64})</kbd></td>
<td class="CDPAlignCenter CDPAlign">No</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">2</td>
<td><kbd>sumprod(A::Vector{Number}, B::Vector{Number})</kbd></td>
<td class="CDPAlignCenter CDPAlign">No</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">3</td>
<td><kbd>sumprod(A::Vector{T}, B::Vector{T}) where T &lt;: Number</kbd></td>
<td class="CDPAlignCenter CDPAlign">No</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">4</td>
<td><kbd>sumprod(A::Vector{S}, B::Vector{T}) where {S &lt;: Number, T &lt;: Number}</kbd></td>
<td class="CDPAlignCenter CDPAlign">No</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">5</td>
<td><kbd>sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S &lt;: Number, T &lt;: Number}</kbd></td>
<td class="CDPAlignCenter CDPAlign">Yes</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">6</td>
<td><kbd>sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N, S &lt;: Number, T &lt;: Number}</kbd></td>
<td class="CDPAlignCenter CDPAlign">Yes</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">7</td>
<td><kbd>sumprod(A, B)</kbd></td>
<td class="CDPAlignCenter CDPAlign">Yes</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Technically speaking, options 5, 6, or 7 could work for all array types. Options 6 and 7 support other array containers, such as sparse matrix. Option 7 works with non-<kbd>AbstractArray</kbd> types, as long as the type is broadcasting multiplication as well as summation.</p>
<p>Before we draw our conclusion, let's do one last test from a performance perspective. Do you wonder whether making the function accept more general types would sacrifice performance? The only way to know this is to prove it with real experiments. Let's do that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating performance</h1>
                </header>
            
            <article>
                
<p><span>Do we sacrifice performance w</span>hen we make the functions accept more general types in their arguments? Let's do some benchmarking tests and see how they perform.</p>
<p>Here, we will benchmark the functions for options 1, 5, 6, and 7 using exactly the same input: two <kbd>Float64</kbd> vectors with 10,000 elements:</p>
<pre>using BenchmarkTools <br/><br/>A = rand(10_000);<br/>B = rand(10_000);<br/><br/>@btime sumprod_1($A, $B);<br/>@btime sumprod_5($A, $B);<br/>@btime sumprod_6($A, $B);<br/>@btime sumprod_7($A, $B);</pre>
<p>Here are the test results:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a1901151-46ea-4338-810e-3f66c7fb9b88.png" style="width:24.92em;height:16.08em;"/></p>
<p>As you can see, there is no material difference between these options. How the argument types are specified does not affect the runtime performance of the function.</p>
<p>In summary, what we have learned about this anti-pattern is that the function argument should not be made too narrow unnecessarily. A function can be much more useful when the <em>net</em> is cast wide. A function that can accept and support more input types is automatically more reusable.</p>
<p>Our next anti-pattern relates to how field types should be chosen when designing data types. This is an extremely important topic as it can dramatically affect system performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nonconcrete field types anti-pattern</h1>
                </header>
            
            <article>
                
<p>The nonconcrete field types anti-pattern is an anti-pattern in which a struct field is not concrete. The main problem with nonconcrete types for fields is that they can cause major performance problems. To understand why, let's take a look at the memory layout for composite types that have nonconcrete versus concrete types, then design and compare the two.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the memory layout of composite data types</h1>
                </header>
            
            <article>
                
<p>Let's first take a look at a simple example for a composite type for tracking the coordinates of a point:</p>
<pre>struct Point<br/>    x<br/>    y<br/>end</pre>
<p>When the field type is not specified, it is implicitly interpreted as <kbd>Any</kbd>, the super type of all types, hence the preceding code is syntactically equivalent to the following (except that we have renamed the type name as <kbd>Point2</kbd> to avoid confusion):</p>
<pre>struct Point2<br/>    x::Any<br/>    y::Any<br/>end</pre>
<p>The fields <kbd>x</kbd> and <kbd>y</kbd> have the <kbd>Any</kbd> <span>type</span><span>, meaning that they can be anything:</span> <kbd>Int64</kbd><span>,</span> <kbd>Float64</kbd><span>, or any other data type. To compare the memory layout and utilization, it is worth creating a new point type that uses a small concrete type, such as</span> <kbd>UInt8</kbd><span>:</span></p>
<pre>struct Point3<br/>    x::UInt8<br/>    y::UInt8<br/>end</pre>
<p>As we know, <kbd>UInt8</kbd> should occupy a single byte of storage. Having both <kbd>x</kbd> and <kbd>y</kbd> fields should consume only two bytes of storage. Perhaps we should just prove it to ourselves. Check the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d8c30dcb-bb09-4f8f-946b-a82ad0479b39.png" style="width:21.83em;height:3.08em;"/></p>
<p>Clearly, a single <kbd>Point3</kbd> object only occupies two bytes. Let's do the same with the original <kbd>Point</kbd> object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1fdf8554-09ac-4a38-be2a-a858b3e6dea0.png" style="width:22.83em;height:3.42em;"/></p>
<p>The <kbd>Point</kbd> object takes 16 bytes, even though we want to store <span>just </span>two bytes. As we know, the <kbd>Point</kbd> object can take any data type in the <kbd>x</kbd> and <kbd>y</kbd> fields. Now, let's do the same exercise with a larger data type, such as <kbd>Int128</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5f3561d8-0ee6-42d1-a404-e3cf5fdda73a.png" style="width:24.50em;height:2.75em;"/></p>
<p>An <kbd>Int128</kbd> is a 128-bit integer, which occupies 16 bytes in memory. Interestingly, even though we are carrying two <kbd>Int128</kbd> fields in <kbd>Point</kbd>, the size of the object remains as 16 bytes.</p>
<p>Why? It is because <kbd>Point</kbd> actually stores two 64-bit pointers, each occupying eight bytes of storage. We can visualize the memory of a <kbd>Point</kbd> object as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c98b9c7-d7ba-4406-90fd-90b099bfa974.png" style="width:21.92em;height:11.25em;"/></p>
<p>When the field types are concrete, the Julia compiler knows exactly what the memory layout looks like. With two <kbd>UInt8</kbd> fields, it is compactly represented with two bytes. With two <kbd>Int128</kbd> fields, it will occupy 32 bytes. Let's try that in REPL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9a3be4a1-1026-4805-bdc6-3a5e034f7b5d.png" style="width:23.33em;height:2.58em;"/></p>
<p>The memory layout of <kbd>Point4</kbd> is compact, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/91ca4f89-99a9-4356-90da-2bb55bc4967f.png" style="width:8.25em;height:10.25em;"/></p>
<p>Now that we know the difference in memory layout, we can immediately see the benefits of using concrete types. Every time we need to access the <kbd>x</kbd> or <kbd>y</kbd> field, if it is a concrete type, then the data is right there. If the fields are just pointers, then we have to dereference the pointer to find the data. Furthermore, the physical memory locations of <kbd>x</kbd> and <kbd>y</kbd> may not even be adjacent to each other, which may cause hardware cache misses, further hurting performance.</p>
<p>So, do we just follow the rule of using concrete types directly in the field definitions? Not necessarily. There are other options that we can consider, which we will do in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing composite types with concrete types in mind</h1>
                </header>
            
            <article>
                
<p>Perhaps the reason why we use abstract types in the fields in the first place is to support different types of data in the field. Taking the <kbd>Point</kbd> type in the previous section, we can see that the type can be useful in the context of computer games, where the coordinates are identified by integer pixel positions on the screen. On the other hand, we also think that the same type may be useful for storing coordinates of shapes in architectural diagrams, in which case, we would want floating-point values.</p>
<p>If we want to be flexible, we would want to support <kbd>Point</kbd> fields with any subtype of the <kbd>Real</kbd> type. Conceptually, we want something like this:</p>
<pre>struct Point<br/>    x::Real<br/>    y::Real<br/>end</pre>
<p>However, since <kbd>Real</kbd> is an abstract type, we would expect poor performance, just like we would with <kbd>Any</kbd>. In order to utilize concrete types without sacrificing the flexibility of supporting other numeric types, we can turn <kbd>Point</kbd> into a parametric type. Let's restart the REPL and define the new <kbd>Point</kbd> type, as follows:</p>
<pre>struct Point{T &lt;: Real}<br/>    x::T<br/>    y::T<br/>end</pre>
<p>Making it a parametric type has the benefit of being concrete. We can check this out easily from the REPL. The following is a basic syntax implementation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3d52d8d-c736-41ba-a950-3be3e02c793c.png" style="width:18.17em;height:7.42em;"/></p>
<p>The following code shows another example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/26adba53-dedf-4318-88fb-81544d3e20f0.png" style="width:24.08em;height:7.33em;"/></p>
<p>So far, we have been assuming that concrete types would outperform nonconcrete types in <kbd>struct</kbd> fields. It would be nice to get an idea of how much difference it makes. Let's try that now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comparing performance between concrete versus nonconcrete field types</h1>
                </header>
            
            <article>
                
<p>We can run a performance test with these two different types, depicted here:</p>
<p class="CDPAlignCenter CDPAlign"/>
<p>Our benchmark test function will compute the center of all points from an array, as follows:</p>
<pre>using Statistics: mean<br/><br/>function center(points::AbstractVector{T}) where T<br/>    return T(<br/>        mean(p.x for p in points), <br/>        mean(p.y for p in points))<br/>end</pre>
<p>In addition, we will also define a function that can be used to make an array of points for whatever type we want:</p>
<pre>make_points(T::Type, n) = [T(rand(), rand()) for _ in 1:n]</pre>
<p>Let's start with a <kbd>PointAny</kbd> type.</p>
<p>We will generate 100,000 points and use <kbd>BenchmarkTools</kbd> to measure the time:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae24af37-f0f9-436e-844b-32fb0928c388.png" style="width:29.83em;height:7.33em;"/></p>
<p>Next, we will run the performance test for the <kbd>Point</kbd> type:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ad4d592-b2c5-4588-8518-b2b09f27476e.png" style="width:28.58em;height:6.25em;"/></p>
<p>As we can see, there is a huge difference between the two. Using the parametric <kbd>Point</kbd> type is approximately 25 times faster than the one that uses <kbd>Any</kbd> as a field type.</p>
<p>What we have learned from this anti-pattern is that we should use concrete types for fields defined in composite types. It is quite easy to <em>factor out</em> the abstract type we want into a type parameter. Doing this allows us to gain performance benefits from concrete types without sacrificing the ability to support other data types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about several anti-patterns in Julia programming. When we went over details for each anti-pattern, we also figured out how to apply alternative design solutions.</p>
<p>We began with the piracy anti-pattern, which refers to bad practices as related to extending functions from a third-party module. For convenience, we classified piracy anti-patterns into three different types—type I, II, and III. Each type poses a different problem in causing the system to become unstable or potentially invite problems in the future.</p>
<p>Next, we looked into the narrow argument types anti-pattern. When function arguments are too narrowly specified, they become less reusable. Because Julia can specialize the function for various argument types, it is more beneficial to make argument types as general as possible, utilizing abstract types. We went through several design options in <span>great detail,</span> <span>and concluded that the most general types can be used without sacrificing performance.</span></p>
<p> </p>
<p>Finally, we reviewed the nonconcrete field types anti-pattern. We proved that having nonconcrete types poses a performance problem because of the resulting inefficient memory layout structure. We figured that the problem can be solved <span>easily </span>by using parametric types, specifying concrete types as part of the type parameters.</p>
<p>In the next chapter, we will turn our attention to traditional object-oriented design patterns and see how they can be applied in Julia programming. <em>Fasten your seat belt: if you used to be an OOP programmer, your ride may be a little bumpy! </em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the risks and potential benefits of type I piracy?</li>
<li>What kind of problems can arise from type II piracy?</li>
<li>How does type III piracy cause trouble?</li>
<li>What should we watch out for when specifying function arguments?</li>
<li>How is system performance affected by using abstract function arguments?</li>
<li>How is system performance affected by using abstract field types for composite types?</li>
</ol>


            </article>

            
        </section>
    </body></html>