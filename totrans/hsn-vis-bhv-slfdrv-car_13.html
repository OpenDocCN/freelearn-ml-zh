<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer224">
			<h1 id="_idParaDest-213"><a id="_idTextAnchor221"/><em class="italic">Chapter 10</em>: Steering, Throttle, and Brake Control</h1>
			<p>In this chapter, you will learn about more methods for controlling the steering, throttle, and brake using techniques from the field of control systems. If you recall <a href="B16322_08_Final_NM_ePUB.xhtml#_idTextAnchor182"><em class="italic">Chapter 8</em></a>, <em class="italic">Behavioral Cloning</em>, you learned how to steer a car using a neural network and camera images. While this most closely mimics how a human drives a car, it can be resource-intensive due to the computational needs of neural networks.</p>
			<p>There are more traditional and less resource-intensive methods for controlling a vehicle. The most widely used of these is the <strong class="bold">PID</strong> (short for <strong class="bold">Proportional, Integral, Derivative</strong>) controller, which you will implement in CARLA to drive your car around the simulated town.</p>
			<p>There is also another method that is widely used in self-driving cars, called the <strong class="bold">MPC</strong> (short for <strong class="bold">Model Predictive Controller</strong>). The MPC focuses on simulating trajectories, calculating the cost of each trajectory, and selecting the trajectory with the minimum cost. We will walk through some example code that you could implement in place of the PID you will learn.</p>
			<p>In this chapter, you will learn the following topics:</p>
			<ul>
				<li>Why do you need controls?</li>
				<li>Types of controllers</li>
				<li>Implementing a PID in CARLA</li>
				<li>An example MPC in C++</li>
			</ul>
			<p>By the end of the chapter, you will have gained knowledge of why we need controls, and the skills to select a controller for a given application. You will also know how to implement a PID controller in Python and get exposure to an MPC controller example written in C++.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor222"/>Technical requirements</h1>
			<p>In this chapter, we will require the following software and libraries:</p>
			<ul>
				<li>Python 3.7, available at <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</li>
				<li>CARLA Simulator 0.9.9, available at <a href="https://carla.readthedocs.io/en/latest/start_quickstart/#carla-installation">https://carla.readthedocs.io/en/latest/start_quickstart/#carla-installation</a>.</li>
				<li>The NumPy module, which can be installed with the <strong class="source-inline">pip3 install numpy</strong> command.</li>
				<li>A GPU is highly recommended.</li>
			</ul>
			<p>The code for the chapter can be found here:</p>
			<p><a href="https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter10">https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter10</a></p>
			<p>The Code in Action videos for this chapter can be found here:</p>
			<p><a href="https://bit.ly/2T7WnKo">https://bit.ly/2T7WnKo</a></p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor223"/>Why do you need controls?</h1>
			<p>This may <a id="_idIndexMarker644"/>seem completely obvious since you are trying to build a self-driving car, but let's cover it quickly.</p>
			<p>When you build a self-driving car, what are you trying to achieve? The ultimate goal is to get the vehicle to move from a start position to a destination by commanding actuators such as the steering, throttle, and brakes. Historically, the commands to these actuators have been provided by you, the human driver, via the steering wheel, and the throttle and brake pedals. Now you are trying to remove yourself as the thing responsible for primary driving tasks. So, what do you put in place of yourself? A controller!</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor224"/>What is a controller?</h2>
			<p>A controller is <a id="_idIndexMarker645"/>simply an algorithm that takes some type of error signal and transforms it into an actuation signal to achieve a desired setpoint for a given process. Let's define some of these terms as follows:</p>
			<ul>
				<li>The <strong class="bold">Control Variable</strong> (<strong class="bold">CV</strong>) or process <a id="_idIndexMarker646"/>variable is the variable that you would like to control.</li>
				<li>The <strong class="bold">setpoint</strong> is the <a id="_idIndexMarker647"/>desired value of the CV.</li>
				<li>The <strong class="bold">error</strong> is the <a id="_idIndexMarker648"/>difference between the current state of the CV and the <strong class="bold">setpoint</strong>.</li>
				<li>The <strong class="bold">actuation</strong> is the signal <a id="_idIndexMarker649"/>sent to the process to influence the reduction of the error.</li>
				<li>The <strong class="bold">process</strong> is the <a id="_idIndexMarker650"/>system being controlled.</li>
				<li> You may see the <strong class="bold">process</strong> sometimes called the <em class="italic">plant</em> or the <em class="italic">transfer function</em>.</li>
			</ul>
			<p>For example, let's say that you are trying to maintain your self-driving car within the bounds of the lane it is driving in. The center of the lane would be the <strong class="bold">setpoint</strong>. You first need to know the <strong class="bold">error</strong>, or how far <a id="_idIndexMarker651"/>you are away from the lane center – let's call this your <strong class="bold">Cross-Track Error</strong> (<strong class="bold">CTE</strong>). You then need to determine what <strong class="bold">actuation</strong> command you need to safely return the car (aka the <strong class="bold">process</strong>) to the center of the lane, thereby minimizing the car's CTE. Ultimately, think of the controller as a function that is continually trying to minimize the car's <strong class="bold">error</strong> for a given CV relative to the <strong class="bold">setpoint</strong> of that variable.</p>
			<p>So to achieve this, let's review the types of controllers available.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor225"/>Types of controllers</h1>
			<p>There is a <a id="_idIndexMarker652"/>vast multitude of controllers that have been invented and implemented in control systems. The following is a sample of the different types of controllers:</p>
			<ul>
				<li>The PID controller and its offshoots</li>
				<li>Optimal control</li>
				<li>Robust control</li>
				<li>State-space control</li>
				<li>Vector control </li>
				<li>The MPC</li>
				<li>Linear-quadratic control</li>
			</ul>
			<p>Controllers <a id="_idIndexMarker653"/>can also be categorized by the types of systems they are used in, such as the following examples:</p>
			<ul>
				<li>Linear versus nonlinear</li>
				<li>Analog (continuous) versus digital (discrete)</li>
				<li><strong class="bold">Single Input, Single Output</strong> (<strong class="bold">SISO</strong>) versus <strong class="bold">Multiple Input, Multiple Output</strong> (<strong class="bold">MIMO</strong>)</li>
			</ul>
			<p>By far <a id="_idIndexMarker654"/>the most common and widely used controllers in self-driving cars <a id="_idIndexMarker655"/>are the PID and MPC. PID controllers are used in SISO systems, while MPCs can be used in MIMO systems. This will be useful to remember when you consider which type of controller to select for your self-driving car. For example, if you only want <a id="_idIndexMarker656"/>to control the speed of the vehicle by implementing cruise control, you may want to select a SISO controller such as the PID. Conversely, if you want to control multiple outputs, such as the steering angle and speed in a single controller, you may choose to implement a MIMO controller such as the MPC.</p>
			<p>In the following section, you will be introduced to the basics of PIDs in preparation to understand the code you will learn.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor226"/>PID</h2>
			<p>The PID <a id="_idIndexMarker657"/>controller is the most ubiquitous <a id="_idIndexMarker658"/>form of control system, and has more than a century of research and implementation behind it. It has many flavors and subtle tweaks that can be made for specific applications. Here you will focus on learning the basics and implementing a simple controller for both the lateral and longitudinal control of your self-driving car. You will need both longitudinal and lateral PID controllers since PID is a SISO controller. Refer to the following figure which shows a typical PID block diagram:</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="Images/Figure_10.1_B16322.jpg" alt="Figure 10.1 – PID block diagram" width="1058" height="295"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – PID block diagram</p>
			<p>Let's look at a simple example of controlling the temperature in your home using <em class="italic">Figure 10.1</em>. Your home likely has a thermostat that allows you to set the temperature you would like. We will call the temperature you have chosen the <strong class="bold">setpoint</strong> or <em class="italic">r(t)</em>. The instantaneous temperature in your home is the <strong class="bold">CV</strong> or <em class="italic">y(t)</em>. Now your thermostat's job is to use the heater/cooler in your home to drive the temperature (the CV) in your home to the <strong class="bold">setpoint</strong>. The CV, <em class="italic">y(t)</em>, is fed back to a subtraction block to determine the <strong class="bold">error</strong>, <em class="italic">e(t) = r(t) - y(t)</em>, between the temperature you want in the home and the current temperature. The <strong class="bold">error</strong> is then passed to the P, I, and D control terms, which will each be multiplied by a <strong class="bold">gain</strong> value (usually represented by <em class="italic">K</em>), which are in turn summed together to produce the control input into your heater/cooler. Your heater/cooler has a certain <a id="_idIndexMarker659"/>power capacity, and your home has a certain volume of air. The combination of the heater/cooler capacity and the volume of your home <a id="_idIndexMarker660"/>determines how quickly your home will heat up or cool down when a new <strong class="bold">setpoint </strong>is chosen. This is known as the <strong class="bold">process</strong>, plant, or <em class="italic">transfer function</em> of your home. The process represents how a system's CV will respond to a change in <strong class="bold">setpoint</strong>, also known as the <em class="italic">step response</em>.</p>
			<p>The following graph shows an example step response for a system. At time <em class="italic">t=0</em>, the <strong class="bold">setpoint </strong>(shown by the dotted line) is stepped from 0 to 0.95. The response of the system is illustrated in the following figure:</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="Images/Figure_10.2_B16322.jpg" alt="Figure 10.2 – Step response example" width="647" height="397"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Step response example</p>
			<p>We can see that this system and controller combined have created a response that will overshoot the setpoint and oscillate around it unil the response eventually settles on the setpoint value.</p>
			<p>Another <a id="_idIndexMarker661"/>example of a control <a id="_idIndexMarker662"/>system that is more relevant to this book would be the cruise control system in a self-driving car. In this case, the car's current speed is the CV, the desired speed is the setpoint, and the physical dynamics of the car and motor are the process. You will see later how to implement a cruise controller as well as a steering controller.</p>
			<p>For now, let's understand what the proportional, integral, and derivative control terms of PID mean.</p>
			<p class="callout-heading">Pedal to the metal!</p>
			<p class="callout">Have you ever thought about how you decide how much to press the throttle pedal when you are driving? </p>
			<p class="callout">What factors determine how much you mash the pedal? </p>
			<p class="callout">–Is it how fast you are going versus how much faster you want to go?</p>
			<p class="callout">–Does it have to do with how quickly you are approaching your target speed?</p>
			<p class="callout">–Do you continually check your speed to make sure you haven't drifted from your target speed?</p>
			<p class="callout">Think about all of these as we race through the next few sections. </p>
			<p>Before we <a id="_idIndexMarker663"/>start discussing the P, I, and D control terms, we <a id="_idIndexMarker664"/>need to define what the <strong class="bold">gain</strong> is.</p>
			<p>The <strong class="bold">gain</strong> is a scaling <a id="_idIndexMarker665"/>factor used to weight a control term more or less heavily in the total control input to the <strong class="bold">process</strong>.</p>
			<h3>Understanding what proportional means</h3>
			<p>In the cruise <a id="_idIndexMarker666"/>control example, you are trying to match your car's speed to a setpoint speed. The difference between the setpoint speed and your car's current speed is called the <strong class="bold">error</strong>. When the car's speed is below the setpoint, the error is positive, and when it is above the setpoint, the<a id="_idTextAnchor227"/> error is negativ<a id="_idTextAnchor228"/>e:</p>
			<p><img src="Images/Formula_10_001.png" alt="" width="362" height="23"/></p>
			<p>The proportional control term simply takes <img src="Images/Formula_10_002.png" alt="" width="84" height="17"/> and multiplies it by a scaling factor known as the proportional <strong class="bold">gain</strong>:<a id="_idTextAnchor229"/></p>
			<p><img src="Images/Formula_10_003.png" alt="" width="130" height="22"/></p>
			<p>What this means is that the larger the <strong class="bold">error</strong>, the larger the control input to the process, or in the case of cruise control, the larger the throttle input. This makes sense, right?</p>
			<p>Let's check this with some actual numbers. First, let's define the throttle as going from 0 to 100%. Next, let's map that to the acceleration of a car, say, that of the Tesla Model X, at 37 m/s2. <em class="italic">Ludicrous Mode</em>! So, 100% of the throttle gives an acceleration of 37 m/ s2.</p>
			<p>If your setpoint speed is 100 km/h and you start from 0 km/h, then your current error is 100 km/h. Then, if you want maximum acceleration with an error of 100 km/h, you could set your proportiona<a id="_idTextAnchor230"/>l gain to be 1:</p>
			<p><img src="Images/Formula_10_004.png" alt="" width="402" height="24"/></p>
			<p>As your error in speed decreases, the throttle would also decrease until you reach a throttle input of zero at the point when the error is zero.</p>
			<p>Wait! Zero <a id="_idIndexMarker667"/>throttle means we are coasting. This would work great if there was no friction, air resistance, and so on, but we all know that isn't the case. This means that you would never really stay at the target speed and would rather oscillate just below our target speed, leaving us with a steady-state bias:</p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="Images/Figure_10.3_B16322.jpg" alt="Figure 10.3 – Steady-state bias in a proportional controller" width="1538" height="299"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Steady-state bias in a proportional controller</p>
			<p>Oh no – how do we maintain our target speed? No fear, we have the mighty integrator that can help bring us up to speed.</p>
			<h3>Understanding the integral term</h3>
			<p>Introducing <a id="_idIndexMarker668"/>the mighty integrator! The integrator term in PID seeks to address any steady-state bias in the system. It does this by integrating all the past errors in the system. Really, this just means that it is summing up all the errors we have seen at <a id="_idTextAnchor231"/>each time step:</p>
			<p><img src="Images/Formula_10_005.png" alt="" width="547" height="32"/></p>
			<p>We then take the total error and scale it with a gain, <em class="italic">K</em><span class="subscript">I</span>, like we did with the proportional term. Then, we use this result as a control input to the syst<a id="_idTextAnchor232"/>em as follows:</p>
			<p><img src="Images/Formula_10_006.png" alt="" width="244" height="32"/></p>
			<p>In your cruise control example, the Model X's speed only briefly achieved the setpoint speed and then quickly dipped back down below as the proportional input became zero and the air resistance slowed it down. This means that if you summed up all the errors over time you would find that they are always positive and continue to grow.</p>
			<p>So, the further we go in time, the larger the integrator term, <strong class="source-inline">total_error</strong><span class="subscript">speed</span>, becomes. This means that if you choose <strong class="source-inline">K</strong><span class="subscript">I</span> appropriately, the throttle commanded will be greater than zero even when the instantaneous error is zero. Remember, we sum all the control terms to get the total throttle input. So far, we have the P and I terms, which give us t<a id="_idTextAnchor233"/>he following:</p>
			<p><img src="Images/Formula_10_007.png" alt="" width="455" height="31"/></p>
			<p>Nice! Now you are oscillating around the setpoint instead of being biased below it. But you may ask, <em class="italic">how can we prevent the constant overshooting and undershooting of the speed setpoint, and instead stabilize at a nice smooth throttle application?</em> I thought you would never ask!</p>
			<p>Derivative control to the rescue!</p>
			<h3>Derivative term</h3>
			<p>The last trouble <a id="_idIndexMarker669"/>you must overcome is adjusting your throttle as you approach the setpoint without overshooting it. The derivative term helps with this by adjusting the throttle based on how quickly you are approaching the setpoint. In terms of the error, this means the rate of change of the error<a id="_idTextAnchor234"/>, as follows:</p>
			<p><img src="Images/Formula_10_008.png" alt="" width="683" height="26"/></p>
			<p>When the preceding formula is simplified, we get the following, where <strong class="source-inline">d</strong> den<a id="_idTextAnchor235"/>otes change:</p>
			<p><img src="Images/Formula_10_009.png" alt="" width="209" height="25"/></p>
			<p>If the error is decreasing – meaning you are approaching the setpoint – the derivative term will be negative. This means that the derivative term will aim to reduce your total throttle since the throttle is now given by the sum of all the P, I, and D control terms. The following equation<a id="_idTextAnchor236"/> shows this:</p>
			<p><img src="Images/Formula_10_010.png" alt="" width="681" height="33"/></p>
			<p>Okay, you now know what each part of PID means in real terms. The real trick is tuning your <strong class="source-inline">K</strong><span class="subscript">P</span>, <strong class="source-inline">K</strong><span class="subscript">I</span>, and <strong class="source-inline">K</strong><span class="subscript">D</span> gains to make the car's speed and acceleration act as you want them to. That is beyond the scope of this book, but there are some great references at the end of the chapter for learning more about this.</p>
			<p>Next, you will <a id="_idIndexMarker670"/>learn about a more modern form of controller that is very popular in self-driving cars today – the MPC.</p>
			<p class="callout-heading">Pump the brakes!</p>
			<p class="callout">What would you call a negative throttle?</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor237"/>MPC</h2>
			<p>The <strong class="bold">MPC</strong> is a <a id="_idIndexMarker671"/>modern and very versatile controller that is used in MIMO systems. This is perfect for your self-driving car, since you have multiple inputs such as the throttle, brake, and steering torque. You also have multiple outputs such as the lateral position <a id="_idIndexMarker672"/>relative to the lane and the car's speed. As you learned previously, PID would require two separate controllers (lateral and longitudinal) to control the car. With MPC you can do this all in one beautiful controller.</p>
			<p>MPC has become popular in recent years due to the increase in computing speed, which allows for the <em class="italic">online</em> optimization that is required to perform real-time driving tasks. </p>
			<p>Before you can learn what the MPC does, let's first contemplate what your magical brain does when you drive a car:</p>
			<ol>
				<li value="1">You select a destination.</li>
				<li>You plan your route (waypoints).</li>
				<li>You execute your route within the bounds of the traffic laws, your car's dynamics and performance (<em class="italic">Ludicrous Mode, engage!</em>), your time constraints (<em class="italic">I'm late for a life-changing interview!</em>), and the traffic around you.</li>
			</ol>
			<h3>MPC works like you</h3>
			<p>If you <a id="_idIndexMarker673"/>really think about how you drive, you are continually assessing the state of the cars around you, your car, the time until your destination, your position in the lane, your distance from the car in front of yours, the traffic signs and signals, your speed, your throttle position, your steering torque, your brake position, and so much more! At the same time, you are continually simulating various maneuvers you can execute based on the current state of traffic – for instance, <em class="italic">there is a car in the lane to my left so I can't go there</em>, <em class="italic">the car in front of me is going really slow</em>, <em class="italic">there isn't a car in the lane to my right but one is approaching quickly</em>, and <em class="italic">I need to get to this interview and I am running late</em>.</p>
			<p>You are also constantly weighing the cost of each maneuver if executed, based on the following cost considerations:</p>
			<ul>
				<li>The cost of being late to the interview: high!</li>
				<li>The cost of breaking the law: high!</li>
				<li>The cost of causing an accident: unfathomable!</li>
				<li>The cost of using Ludicrous Mode: medium!</li>
				<li>The cost of damaging your car: <em class="italic">is there something higher than infinity? Let's pick that!</em></li>
			</ul>
			<p>You then quickly estimate the cost of any of your possible maneuvers:</p>
			<ul>
				<li><em class="italic">Passing in the left lane means I could crash into the car next to me and potentially cause an accident or damage my car, and still probably miss my interview.</em> The cost: astronomical!</li>
				<li><em class="italic">I could continue in my lane behind this sloth of a car. This will make me late</em>. The cost: high!</li>
				<li><em class="italic">Passing in the right lane will require Ludicrous Mode acceleration to make sure the approaching car doesn't hit me</em>. The cost: medium!</li>
			</ul>
			<p>You choose the last of the preceding options, since it has the lowest cost of the simulated maneuvers based on the costs you have ascribed to each consideration.</p>
			<p>Great, you have chosen a maneuver! Now you need to execute it. </p>
			<p>You smash <a id="_idIndexMarker674"/>the Ludicrous Mode button for 5 seconds while you cinch your seatbelt until it feels like a boa constrictor and you chop your blinker on as if you were the <em class="italic">Karate Kid</em>! You grip the steering wheel with white-knuckle fury and then put the pedal to the metal as you visualize the power and majesty of the extra 35 horses that thrust you back into your seat. You simultaneously crank the steering wheel to rail you into the right lane and fly by the sloth with adrenaline and a smug grin plastered on your face as you watch the previously approaching car fading into oblivion behind you! </p>
			<p>Now that you are blissfully satisfied with your maneuver, you start the entire process over for <a id="_idIndexMarker675"/>the next maneuver and repeat until you arrive safely and on time for your interview! You did it!</p>
			<h3>MPC pipeline</h3>
			<p>MPC takes <a id="_idIndexMarker676"/>a similar approach to dynamic driving tasks that humans do. MPC simply formalizes the driving tasks into mathematics and physics (with less thrill and excitement). The steps are very similar.</p>
			<p>Establish constraints such as the following:</p>
			<ol>
				<li value="1">The vehicle's dynamic model for estimating its state in the next time step:<ul><li>The minimum turn radius</li><li>The maximum steering angle</li><li>The maximum throttle</li><li>The maximum brake</li><li>The maximum lateral jerk (a derivative of acceleration)</li><li>The maximum longitudinal acceleration</li></ul></li>
				<li>Establish the cost functions, including the following:<ul><li>The cost of not being at the desired state</li><li>The cost of using actuators</li><li>The cost of sequential actuations</li><li>The cost of using the throttle with steering</li><li>The cost of crossing lane lines</li><li>The cost of collisions</li></ul></li>
				<li>Next, simulate possible trajectories and the associated control inputs that obey the mathematical cost and constraints for the next <em class="italic">N</em> time steps.</li>
				<li>Use an optimization algorithm to select the simulated trajectory with the lowest cost.</li>
				<li>Execute the control inputs for one time step.</li>
				<li>Measure the state of the system at the new time step.</li>
				<li>Repeat <em class="italic">steps 3–6</em>.</li>
			</ol>
			<p>There is <a id="_idIndexMarker677"/>a lot more detail in each of these steps and you are encouraged to learn more by following the links in the <em class="italic">Further reading</em> section at the end of the chapter. For now, here are some quick guidelines to think about.</p>
			<p><strong class="bold">Sample time, TS</strong>:</p>
			<ul>
				<li>This is the discrete time step at which you repeat <em class="italic">steps</em> <em class="italic">3–7</em> of the MPC pipeline.</li>
				<li>Usually, TS is selected so that there are at least 10 time steps in the open-loop rise time.</li>
			</ul>
			<p><strong class="bold">Prediction horizon, N</strong>:</p>
			<ul>
				<li>This is the number of time steps into the future for which you will simulate the car state and control inputs.</li>
				<li>Usually, 20 time steps are used to cover the open-loop response of the car.</li>
			</ul>
			<p>You can also examine the following figure, which illustrates many of the concepts and parameters you've learned that constitute the MPC problem:</p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="Images/Figure_10.4_B16322.jpg" alt="Figure 10.4 – Concepts and parameters that constitute the MPC problem" width="1521" height="620"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Concepts and parameters that constitute the MPC problem</p>
			<p>Here is a quick description of each of the parameters shown in the preceding graph:</p>
			<ul>
				<li>The <strong class="bold">Reference Trajectory</strong> is the desired trajectory of the controlled variable; for example, the lateral position of the vehicle in the lane.</li>
				<li>The <strong class="bold">Predicted Output</strong> is the prediction of the controlled variable state after the predicted control input has been applied. It is informed by the dynamic model of the system, the constraints, and the previously measured output.</li>
				<li>The <strong class="bold">Measured Output</strong> is the measured past state of the controlled variable.</li>
				<li>The <strong class="bold">Predicted Control Input</strong> is the system's prediction of the control actuations that must be performed to achieve the predicted output.</li>
				<li>The <strong class="bold">Past Control Input</strong> is the actual control actuations that were performed in the past, leading up to the current state.</li>
			</ul>
			<p>MPC is a powerful though resource-intensive control algorithm that can sometimes simplify your architecture by allowing MIMO to fit into a single module.</p>
			<p>This is a lot to take in at once, but if you have made it this far, you are in luck! In the next section, we will dive into the real code that you can use to control your self-driving car in CARLA using PID!</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor238"/>Implementing PID in CARLA</h1>
			<p>Congratulations on making it to the truly fun and hands-on portion of this chapter. You have learned a lot so far about PIDs and MPCs. Now it is time to put that knowledge to use!</p>
			<p>In this section, we will walk through all the relevant code that is available on GitHub for this chapter:</p>
			<p><a href="https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars">https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars</a></p>
			<p>You will learn how to apply the equations and concepts of PID in Python and then interface with CARLA.</p>
			<p>First, you will need to install CARLA.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor239"/>Installing CARLA</h2>
			<p>The CARLA project has a Linux and Windows Quick Start guide available at <a href="https://carla.readthedocs.io/en/latest/start_quickstart/">https://carla.readthedocs.io/en/latest/start_quickstart/</a>.</p>
			<p>For Linux, the CARLA files will be located here:</p>
			<p class="source-code">/opt/carla-simulator/</p>
			<p>Inside this folder you will find a <strong class="source-inline">/bin/</strong> folder that contains the executable simulator script, which you can run with the following command:</p>
			<p class="source-code">$  /opt/carla-simulator/bin/CarlaUE4.sh -opengl</p>
			<p>The <strong class="source-inline">–opengl</strong> tag runs the simulator using OpenGL instead of Vulkan. Depending on your system setup and GPU, you may drop <strong class="source-inline">–opengl</strong>. You should see a simulator environment window pop up that looks like this:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="Images/Figure_10.5_B16322.jpg" alt="Figure 10.5 – CARLA simulator environment opening" width="1650" height="983"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – CARLA simulator environment opening</p>
			<p>For this chapter, you will be primarily working from the <strong class="source-inline">examples</strong> folders located at the following destinations:</p>
			<ul>
				<li>Linux: <strong class="source-inline">/opt/carla-simulator/PythonAPI/examples</strong></li>
				<li>Windows: <strong class="source-inline">WindowsNoEditor\PythonAPI\examples</strong></li>
			</ul>
			<p>This folder contains all the example CARLA scripts that teach you the basics of the CARLA API. In this folder, you will find a script called <strong class="source-inline">automatic_control.py</strong>, which is the basis of the script you will be working with throughout the rest of this chapter.</p>
			<p>Now that you have installed and successfully run the simulator, you will clone the <strong class="source-inline">Packt-Town04-PID.py</strong> script that contains the PID controller.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor240"/>Cloning Packt-Town04-PID.py</h2>
			<p>You can find the repository for this chapter under <strong class="source-inline">Chapter10</strong> at <a href="https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars">https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars</a>.</p>
			<p>You can clone the entire repo to any location on your machine. </p>
			<p>You will then need to link the <strong class="source-inline">Packt-Town04-PID.py</strong> script into the <strong class="source-inline">examples</strong> folder previously discussed. You can use this command in Linux:</p>
			<p class="source-code">$  ln -s /full/path/to/Packt-Town04-PID.py /opt/carla-simulator/PythonAPI/examples/</p>
			<p>Now that you have the script and have linked it to the correct location within CARLA, let's walk through the code and what it does.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor241"/>Walking through your Packt-Town04-PID.py control script</h2>
			<p>Your <strong class="source-inline">Packt-Town04-PID.py</strong> code is based on the <strong class="source-inline">automatic_control.py</strong> example script and is pieced together from the relevant snippets of code located in the <strong class="source-inline">/opt/carla-simulator/PythonAPI/carla/agents</strong> subfolders, namely, the following scripts:</p>
			<ul>
				<li><strong class="source-inline">behavior_agent.py</strong></li>
				<li><strong class="source-inline">local_planner.py</strong></li>
				<li><strong class="source-inline">controller.py</strong></li>
				<li><strong class="source-inline">agent.py</strong></li>
			</ul>
			<p>This is a very good way to learn how to interact with the CARLA simulator and learn the API without having to write everything from scratch. </p>
			<h3>Finding the CARLA module</h3>
			<p>If you now look at <strong class="source-inline">Packt-Town04-PID.py</strong>, the first thing that you might notice after the usual imports is this block of code:</p>
			<p class="source-code">try:</p>
			<p class="source-code">    sys.path.append(glob.glob('../carla/dist/carla-*%d.%d-%s.egg' % (</p>
			<p class="source-code">        sys.version_info.major,</p>
			<p class="source-code">        sys.version_info.minor,</p>
			<p class="source-code">        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])</p>
			<p class="source-code">except IndexError:</p>
			<p class="source-code">    pass</p>
			<p>This block loads an egg file containing the code for CARLA, which is in the <strong class="source-inline">/opt/carla-simulator/PythonAPI/carla/dist/</strong> folder.</p>
			<h3>Classes of interest</h3>
			<p>After this, you will probably notice that the code is organized into the following classes:</p>
			<ul>
				<li><strong class="source-inline">World</strong>: The virtual world where our vehicle moves, including the map and all the actors (such as vehicles, pedestrians, and sensors).</li>
				<li><strong class="source-inline">KeyboardControl</strong>: This reacts to the keys pressed by the user and has some logic to convert the binary on/off keys for steering, braking, and accelerating to a wider range of values, based on how much time they are pressed, making the car much easier to control.</li>
				<li><strong class="source-inline">HUD</strong>: This renders all the information related to the simulation including the speed, steering, and throttle. It manages the notifications that can show some information to the user for a few seconds.</li>
				<li><strong class="source-inline">FadingText</strong>: This class is used by the <strong class="source-inline">HUD</strong> class to show notifications that disappear after a few seconds.</li>
				<li><strong class="source-inline">HelpText</strong>: This class displays some text using <strong class="source-inline">pygame</strong>, a gaming library used by CARLA.</li>
				<li><strong class="source-inline">CollisionSensor</strong>: This is a sensor that can detect collisions.</li>
				<li><strong class="source-inline">LaneInvasionSensor</strong>: This is a sensor that can detect that you crossed a lane line.</li>
				<li><strong class="source-inline">GnssSensor</strong>: This is a GPS/GNSS sensor that provides the GNSS position inside the OpenDRIVE map.</li>
				<li><strong class="source-inline">CameraManager</strong>: This is a class that manages the camera and prints it.</li>
				<li><strong class="source-inline">Agent</strong>: This is the base class to define an agent in the game.</li>
				<li><strong class="source-inline">AgentState</strong>: This is a class to represent the possible states of the agent.</li>
				<li><strong class="source-inline">BehaviorAgent</strong>: This class implements an agent that navigates the world to reach a destination by computing the shortest possible path to it.</li>
				<li><strong class="source-inline">LocalPlanner</strong>: This class implements a trajectory to follow by generating waypoints on the fly. It also calls the <strong class="source-inline">VehiclePIDController</strong> class with the appropriate gains. This is where the magic happens for this chapter.</li>
				<li><strong class="source-inline">VehiclePIDController</strong>: This class calls the lateral and longitudinal controllers.</li>
				<li><strong class="source-inline">PIDLongitudinalController</strong>: This class holds the PID math that you have been learning about for cruise control.</li>
				<li><strong class="source-inline">PIDLateralController</strong>: This class holds the PID math for steering control to keep your car following the waypoints generated by the <strong class="source-inline">LocalPlanner</strong> class.</li>
			</ul>
			<p>There are also a couple of other notable methods:</p>
			<ul>
				<li><strong class="source-inline">main()</strong>: This is mostly dedicated to parsing the arguments received by the OS.</li>
				<li><strong class="source-inline">game_loop()</strong>: This mostly initializes <strong class="source-inline">pygame</strong>, the CARLA client, and all the related objects. It also implements the game loop where, 60 times per second, the keys are analyzed and the most updated image is shown on the screen.</li>
			</ul>
			<h3>Setting the world</h3>
			<p>Inside the <strong class="source-inline">game_loop()</strong> method you will find where to set the world map. It is currently set to <strong class="source-inline">Town04</strong>:</p>
			<p class="source-code">selected_world = client.load_world("Town04")</p>
			<h3>Car personalization</h3>
			<p>If you are a car enthusiast who would like to choose your car model and color, you can do so with this code inside the <strong class="source-inline">World()</strong> class:</p>
			<p class="source-code">blueprint=self.world.get_blueprint_library().filter('vehicle.lincoln.mkz2017')[0] </p>
			<p class="source-code">        blueprint.set_attribute('role_name', 'hero')</p>
			<p class="source-code">        if blueprint.has_attribute('color'):</p>
			<p class="source-code">            color = '236,102,17'</p>
			<p class="source-code">            blueprint.set_attribute('color', color)</p>
			<h3>Spawn point</h3>
			<p>The next thing you may want to change is the spawn point of the vehicle in the map. You can do this by picking a different index for <strong class="source-inline">spawn_points[0]</strong>:</p>
			<p class="source-code">spawn_point = spawn_points[0] if spawn_points else carla.Transform()</p>
			<p>Now that you have gone through your customization and understand the layout of the classes and what they do, we will now dive into the meat of this chapter's code – the PID controllers!</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor242"/>PIDLongitudinalController</h2>
			<p>This is your cruise control and is responsible for actuating the throttle and brake. Do you remember earlier when we tickled your brain and asked what a negative throttle would be called? Well, the answer here is the brake. So any time the controller calculates a negative throttle input, it will actuate the brake with the control value.</p>
			<h3>Gains</h3>
			<p>This gains class is initialized with the PID gains that have been tuned by the CARLA team:</p>
			<p class="source-code">        self._k_p = K_P</p>
			<p class="source-code">        self._k_d = K_D</p>
			<p class="source-code">        self._k_i = K_I</p>
			<p>The values are set back in the <strong class="source-inline">LocalPlanner</strong> class in the following code:</p>
			<p class="source-code">        self.args_long_hw_dict = {</p>
			<p class="source-code">            'K_P': 0.37,</p>
			<p class="source-code">            'K_D': 0.024,</p>
			<p class="source-code">            'K_I': 0.032,</p>
			<p class="source-code">            'dt': 1.0 / self.FPS}</p>
			<p class="source-code">        self.args_long_city_dict = {</p>
			<p class="source-code">            'K_P': 0.15,</p>
			<p class="source-code">            'K_D': 0.05,</p>
			<p class="source-code">            'K_I': 0.07,</p>
			<p class="source-code">            'dt': 1.0 / self.FPS}</p>
			<h3>Gain scheduling</h3>
			<p>Notice that there are different gains based on highway versus city driving. The gains are scheduled in <strong class="source-inline">LocalPlanner</strong> based on the current speed of the car:</p>
			<p class="source-code">   if target_speed &gt; 50:</p>
			<p class="source-code">            args_lat = self.args_lat_hw_dict</p>
			<p class="source-code">            args_long = self.args_long_hw_dict</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            args_lat = self.args_lat_city_dict</p>
			<p class="source-code">            args_long = self.args_long_city_dict</p>
			<h3>PID math</h3>
			<p>And now for the PID implementation math you have been waiting for! The <strong class="source-inline">_pid_control()</strong> method contains the heart of the PID controller and the calculations that you learned in the <em class="italic">PID</em> subsection of the <em class="italic">Types of controllers</em> section:</p>
			<ol>
				<li value="1">First, we calculate the error in the speed:<p class="source-code">        error = target_speed – current_speed</p></li>
				<li>Next, we add the current error to the error buffer so we can use it later to calculate the integral and derivative terms:<p class="source-code">        self._error_buffer.append(error)</p></li>
				<li>Then, if the error buffer has at least two values in it, we calculate the integral and derivative terms:<p class="source-code">        if len(self._error_buffer) &gt;= 2:</p></li>
				<li>Next, we calculate the derivative term by subtracting the previous error value from the current error value and divide that by the <strong class="bold">sampling time</strong>:<p class="source-code">            _de = (self._error_buffer[-1] - self._error_buffer[-2]) / self._dt</p></li>
				<li>Next, we calculate the integral term by summing all the errors we have seen and multiplying by the <strong class="bold">sampling time</strong>:<p class="source-code">            _ie = sum(self._error_buffer) * self._dt</p><p>If we don't have enough in the buffer, we simply set our integral and derivative terms to zero:</p><p class="source-code">        else:</p><p class="source-code">            _de = 0.0</p><p class="source-code">            _ie = 0.0</p></li>
				<li>Finally, we calculate the control input by summing all the gain-weighted PID terms and returning the value clipped to ±1.0. Recall the math for this is as follows:</li>
			</ol>
			<p><img src="Images/Formula_10_011.png" alt="" width="821" height="28"/></p>
			<p>The throttle is commanded if the value is positive, otherwise, the brake is commanded:</p>
			<p class="source-code">        return np.clip((self._k_p * error) + (self._k_d * _de) + (self._k_i * _ie), -1.0, 1.0)</p>
			<p>Now that you know the basic math for a PID, you will now see how to implement this in the lateral PID controller.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor243"/>PIDLateralController</h2>
			<p>This is your steering control and is responsible for actuating the steering angle.</p>
			<h3>Gains</h3>
			<p>This class is initialized with the PID gains that have been tuned by the CARLA team:</p>
			<p class="source-code">        self._k_p = K_P</p>
			<p class="source-code">        self._k_d = K_D</p>
			<p class="source-code">        self._k_i = K_I</p>
			<p>The values set back in the <strong class="source-inline">LocalPlanner</strong> class are in the following code:</p>
			<p class="source-code">        self.args_lat_hw_dict = {</p>
			<p class="source-code">            'K_P': 0.75,</p>
			<p class="source-code">            'K_D': 0.02,</p>
			<p class="source-code">            'K_I': 0.4,</p>
			<p class="source-code">            'dt': 1.0 / self.FPS}</p>
			<p class="source-code">        self.args_lat_city_dict = {</p>
			<p class="source-code">            'K_P': 0.58,</p>
			<p class="source-code">            'K_D': 0.02,</p>
			<p class="source-code">            'K_I': 0.5,</p>
			<p class="source-code">            'dt': 1.0 / self.FPS}</p>
			<h3>Gain scheduling</h3>
			<p>Notice that there are different gains based on highway versus city driving just as there were for the longitudinal control. The gains are scheduled in <strong class="source-inline">LocalPlanner</strong> based on the current speed of the car:</p>
			<p class="source-code">   if target_speed &gt; 50:</p>
			<p class="source-code">            args_lat = self.args_lat_hw_dict</p>
			<p class="source-code">            args_long = self.args_long_hw_dict</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            args_lat = self.args_lat_city_dict</p>
			<p class="source-code">            args_long = self.args_long_city_dict</p>
			<h3>PID math</h3>
			<p>The math for the lateral control is a little different but has the same basic principle. Again, the math is in the <strong class="source-inline">_pid_control()</strong> method. Let's see how to go about it:</p>
			<ol>
				<li value="1">First, we find the starting point of our vehicle vector in global coordinates:<p class="source-code">        v_begin = vehicle_transform.location</p></li>
				<li>Next, we find the end of our vehicle vector in global coordinates using the yaw angle of the vehicle:<p class="source-code">        v_end = v_begin + carla.Location(x=math.cos(math.radians(vehicle_transform.rotation.yaw)),</p><p class="source-code">                                         y=math.sin(math.radians(vehicle_transform.rotation.yaw)))</p></li>
				<li>Next, we create the vehicle vector, which is the direction our vehicle is pointing in global coordinates:<p class="source-code">        v_vec = np.array([v_end.x - v_begin.x, v_end.y - v_begin.y, 0.0])</p></li>
				<li>Next, we calculate the vector from the vehicle's position to the next waypoint:<p class="source-code">        w_vec = np.array([waypoint.transform.location.x -</p><p class="source-code">                          v_begin.x, waypoint.transform.location.y -</p><p class="source-code">                          v_begin.y, 0.0])</p></li>
				<li>Next, we find the angle between the vehicle vector and the vector pointing from the vehicle location to the waypoint. This is essentially our steering error:<p class="source-code">        _dot = math.acos(np.clip(np.dot(w_vec, v_vec) /</p><p class="source-code">                                 (np.linalg.norm(w_vec) * np.linalg.norm(v_vec)), -1.0, 1.0))</p></li>
				<li>Next, we find the cross product of the two vectors to determine which side of the waypoint we are on:<p class="source-code">        _cross = np.cross(v_vec, w_vec)</p></li>
				<li>Next, we adjust the angle <strong class="source-inline">_dot</strong> value to be negative if the cross product was negative:<p class="source-code">        if _cross[2] &lt; 0:</p><p class="source-code">            _dot *= -1.0</p></li>
				<li>Next, we append the current steering error to our error buffer:<p class="source-code">        self._e_buffer.append(_dot)</p></li>
				<li>Next, if the error buffer has at least two values in it, we calculate the integral and derivative terms:<p class="source-code">        if len(self._e_buffer) &gt;= 2:</p></li>
				<li>Next, we calculate the derivative term by subtracting the previous error value from the current error value and divide by the <strong class="bold">sampling time</strong>:<p class="source-code">            _de = (self._e_buffer[-1] - self._e_buffer[-2]) / self._dt</p></li>
				<li>Next, we calculate the integral term by summing all the errors we have seen and multiplying by the sampling time:<p class="source-code">            _ie = sum(self._e_buffer) * self._dt</p><p>If we don't have enough in the buffer, we simply set our integral and derivative terms to zero:</p><p class="source-code">        else:</p><p class="source-code">            _de = 0.0</p><p class="source-code">            _ie = 0.0</p></li>
				<li>Finally, we calculate the control input by summing all the gain-weighted PID terms and returning the value clipped to ±1.0. We haven't seen this yet for steering, but it works the same as for speed:</li>
			</ol>
			<p><img src="Images/Formula_10_012.png" alt="" width="728" height="51"/></p>
			<p>A negative steering angle simply means <em class="italic">turn left </em>while positive means <em class="italic">turn right</em>: </p>
			<p class="source-code">        return np.clip((self._k_p * _dot) + (self._k_d * _de) + (self._k_i * _ie), -1.0, 1.0)</p>
			<p>Now that you have learned how to implement the PID control in Python, it is time to see it working!</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor244"/>Running the script</h2>
			<p>You should first ensure that you have started the CARLA simulator by running the following code:</p>
			<p class="source-code">$  /opt/carla-simulator/bin/CarlaUE4.sh -opengl</p>
			<p>Then in a new Terminal window, you can run the <strong class="source-inline">Packt-Town04-PID.py</strong> script and watch the magic unfold. The command to run the script is as follows:</p>
			<p class="source-code">$  python3 /opt/carla-simulator/PythonAPI/examples/Packt-Town04-PID.py</p>
			<p>You should see a new window pop up that looks like the following screenshot:</p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="Images/Figure_10.6_B16322.jpg" alt="Figure 10.6 – Packt-Town04-PID.py runtime window" width="1024" height="600"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – Packt-Town04-PID.py runtime window</p>
			<p>Congratulations! You <a id="_idIndexMarker678"/>made a car steer and accelerate itself using nothing but a keyboard and your newfound knowledge! In the next section, you will learn how to apply an MPC controller using C++.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor245"/>An example MPC in C++</h1>
			<p>A full <a id="_idIndexMarker679"/>implementation of MPC is beyond the scope of this chapter but you can review this example implementation written in C++ at <a href="https://github.com/Krishtof-Korda/CarND-MPC-Project-Submission/blob/master/src/MPC.cpp">https://github.com/Krishtof-Korda/CarND-MPC-Project-Submission/blob/master/src/MPC.cpp</a>.</p>
			<p>The following <a id="_idIndexMarker680"/>example will walk you through the implementation of an MPC module that you can use in place of a PID controller for both lateral and longitudinal control. Recall that MPC is a MIMO system, meaning you can control multiple outputs<a id="_idTextAnchor246"/>.</p>
			<p>The following example shows all the basic components and code you'll need to build an MPC controller:</p>
			<ol>
				<li value="1">First, use the following code to fit a polynomial to your <strong class="bold">prediction horizon</strong> waypoints:<p class="source-code">Main.cpp --&gt; polyfit()</p><p>Use the following code to calculate cross-tracking errors:</p><p class="source-code">Main.cpp --&gt; polyeval()</p><p class="source-code">double cte = polyeval(coeffs, px) - py;</p><p>Use the following code to calculate orientation errors:</p><p class="source-code">double epsi = psi - atan(coeffs[1] + 2*coeffs[2]*px + 3*coeffs[3]*px*px) ;</p></li>
				<li>Now, we use <strong class="source-inline">MPC.cpp</strong> to structure the vector so that it can be passed to an optimizer. The optimizer takes all the state and actuator variables in a single vector. So, here, you will establish the start index of each variable in the vector:<p class="source-code">size_t x_start = 0;</p><p class="source-code">size_t y_start = x_start + N;</p><p class="source-code">size_t psi_start = y_start + N;</p><p class="source-code">size_t v_start = psi_start + N;</p><p class="source-code">size_t cte_start = v_start + N;</p><p class="source-code">size_t epsi_start = cte_start + N;</p><p class="source-code">size_t delta_start = epsi_start + N;</p><p class="source-code">size_t a_start = delta_start + N - 1;</p></li>
				<li>Next, assign <a id="_idIndexMarker681"/>all the adjustable <a id="_idIndexMarker682"/>weights for your costs:<p class="source-code">const double w_cte = 1;</p><p class="source-code">const double w_epsi = 100;</p><p class="source-code">const double w_v = 1;</p><p class="source-code">const double w_delta = 10000;</p><p class="source-code">const double w_a = 7;</p><p class="source-code">const double w_delta_smooth = 1000;</p><p class="source-code">const double w_a_smooth = 1;</p><p class="source-code">const double w_throttle_steer = 10;</p></li>
				<li>After that, you can establish your cost functions based on those weights.<p>For this, you must add a cost, if you are at the relative state compared to the reference state. In other words, add a cost for not being on the desired path, heading, or velocity, as follows:</p><p class="source-code">for (int t = 0; t &lt; N; t++) {</p><p class="source-code">    fg[0] += w_cte * CppAD::pow(vars[cte_start + t], 2);</p><p class="source-code">    fg[0] += w_epsi * CppAD::pow(vars[epsi_start + t], 2);</p><p class="source-code">    fg[0] += w_v * CppAD::pow(vars[v_start + t] - ref_v, 2);</p><p class="source-code">    }</p><p class="source-code"> </p><p>Then, you need to add a cost for the use of actuators. This helps minimize the actuations if they are not needed. Think of this as the car likes to be lazy and will only command an actuation if the cost is low enough:</p><p class="source-code">for (int t = 0; t &lt; N - 1; t++) {</p><p class="source-code">    fg[0] += w_delta * CppAD::pow(vars[delta_start + t], 2);</p><p class="source-code">    fg[0] += w_a * CppAD::pow(vars[a_start + t], 2);</p><p class="source-code">    }</p></li>
				<li>Next, you <a id="_idIndexMarker683"/>need to add a cost for sequential use of the actuators. This will <a id="_idIndexMarker684"/>help minimize oscillatory use of the actuators, such as when a new driver jumps between the throttle and the brake clumsily:<p class="source-code">for (int t = 0; t &lt; N - 2; t++) {</p><p class="source-code">    fg[0] += w_delta_smooth * CppAD::pow(vars[delta_start + t                                    + 1] - vars[delta_start + t], 2);</p><p class="source-code">    fg[0] += w_a_smooth * CppAD::pow(vars[a_start + t + 1]                                               - vars[a_start + t], 2);</p><p class="source-code">    }</p><p class="source-code">   </p></li>
				<li>Next, it's a good idea to add a cost for using the throttle while at high steering angles. You don't want to mash the throttle in the middle of a turn and spin out of control:<p class="source-code">for (int t = 0; t &lt; N - 1; t++) {</p><p class="source-code">    fg[0] += w_throttle_steer * CppAD::pow(vars[delta_start                                          + t] / vars[a_start + t], 2);</p><p class="source-code">  </p><p class="source-code">    }</p></li>
				<li>Now, establish <a id="_idIndexMarker685"/>the initial constraints:<p class="source-code">fg[1 + x_start] = vars[x_start];</p><p class="source-code">fg[1 + y_start] = vars[y_start];</p><p class="source-code">fg[1 + psi_start] = vars[psi_start];</p><p class="source-code">fg[1 + v_start] = vars[v_start];</p><p class="source-code">fg[1 + cte_start] = vars[cte_start];</p><p class="source-code">fg[1 + epsi_start] = vars[epsi_start];</p></li>
				<li>Now that <a id="_idIndexMarker686"/>we've done this, we can establish the vehicle model constraints based on the state variable and the <strong class="bold">prediction horizon</strong> waypoints.<p>For this, create variables for the state at time <strong class="source-inline">t+1</strong>; that is, the current time step:</p><p class="source-code">for (int t = 1; t &lt; N; t++) {</p><p class="source-code">      AD&lt;double&gt; x1 = vars[x_start + t];</p><p class="source-code">      AD&lt;double&gt; y1 = vars[y_start + t];</p><p class="source-code">      AD&lt;double&gt; psi1 = vars[psi_start + t];</p><p class="source-code">      AD&lt;double&gt; v1 = vars[v_start + t];</p><p class="source-code">      AD&lt;double&gt; cte1 = vars[cte_start + t];</p><p class="source-code">      AD&lt;double&gt; epsi1 = vars[epsi_start + t];</p></li>
				<li>Then, create the variables for the state at time <strong class="source-inline">t</strong>; that is, the previous time step:<p class="source-code">      AD&lt;double&gt; x0 = vars[x_start + t - 1];</p><p class="source-code">      AD&lt;double&gt; y0 = vars[y_start + t - 1];</p><p class="source-code">      AD&lt;double&gt; psi0 = vars[psi_start + t - 1];</p><p class="source-code">      AD&lt;double&gt; v0 = vars[v_start + t - 1];</p><p class="source-code">      AD&lt;double&gt; cte0 = vars[cte_start + t - 1];</p><p class="source-code">      AD&lt;double&gt; epsi0 = vars[epsi_start + t - 1];</p></li>
				<li>Now, you <a id="_idIndexMarker687"/>need to ensure you only consider <a id="_idIndexMarker688"/>the actuation at time <strong class="source-inline">t</strong>. So, here, we only consider the steering (<strong class="source-inline">delta0</strong>) and the acceleration (<strong class="source-inline">a0</strong>) at time <strong class="source-inline">t</strong>:<p class="source-code">      AD&lt;double&gt; delta0 = vars[delta_start + t - 1];</p><p class="source-code">      AD&lt;double&gt; a0 = vars[a_start + t - 1];</p></li>
				<li>Next, you need the constraint of the waypoint line you are trying to follow. This is done by creating a polynomial that's fitted to the waypoints. This is dependent on the number of coefficients. For example, a second-order polynomial will have three coefficients:<p class="source-code">AD&lt;double&gt; f0 = 0.0;</p><p class="source-code">for (int i=0; i&lt;coeffs.size(); i++){</p><p class="source-code">f0 += coeffs[i] * CppAD::pow(x0, i);</p><p class="source-code">}</p><p>Using the same coefficients, you can establish the constraint for the desired heading of the car:</p><p class="source-code">      AD&lt;double&gt; psides0 = 0.0;</p><p class="source-code">      for (int i=1; i&lt;coeffs.size(); i++){</p><p class="source-code">psides0 += i * coeffs[i] * pow(x0, i-1);</p><p class="source-code">      }</p><p class="source-code">      psides0 = CppAD::atan(psides0);</p></li>
				<li>Finally, you need to create constraints for the vehicle model. In this case, a simplified vehicle model known as the bicycle model can be used:<p class="source-code">      fg[1 + x_start + t] = x1 - (x0 + v0 * CppAD::cos(psi0) * dt);</p><p class="source-code">      fg[1 + y_start + t] = y1 - (y0 + v0 * CppAD::sin(psi0) * dt);</p><p class="source-code">      fg[1 + psi_start + t] = psi1 - (psi0 + v0 * delta0 * dt / Lf);</p><p class="source-code">      fg[1 + v_start + t] = v1 - (v0 + a0 * dt);</p><p class="source-code">      fg[1 + cte_start + t] = cte1 - ((f0 - y0) + (v0 * CppAD::sin(epsi0) * dt));</p><p class="source-code">      fg[1 + epsi_start + t] = epsi1 - ((psi0 - psides0) + v0 * delta0 / Lf * dt);</p><p class="source-code">    </p><p class="source-code">}</p></li>
			</ol>
			<p>Great! You now <a id="_idIndexMarker689"/>have at least an example of how to code an MPC in C++. You <a id="_idIndexMarker690"/>can take this basic example and translate it to any language that you need for your control application. You have another weapon in your arsenal of control knowledge!</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor247"/>Summary</h1>
			<p>Congratulations! You now have a lateral and longitudinal controller for a self-driving car! You should be proud of what you have learned and applied in this chapter.</p>
			<p>You have learned about the two most ubiquitous controllers, namely, the PID and MPC. You learned that PIDs are well suited for SISO systems and are very efficient, but require several controllers to control multiple outputs. Meanwhile, you also learned that MPCs are suited for MIMO systems with enough resources to continually optimize in real time at each time step.</p>
			<p>With this, you have trudged through the minutia of the mathematics and models and emerged with your very own PID controller implemented in CARLA and Python.</p>
			<p>In the next chapter, you are going to learn how to build maps and localize your self-driving car so you always know where you are in the world!</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor248"/>Questions</h1>
			<p>Having read this chapter, you should be able to answer the following questions:</p>
			<ol>
				<li value="1">What controller type is best suited for a vehicle with lower computing resources?</li>
				<li>What does the integral term of a PID controller correct for?</li>
				<li>What does the derivative term of a PID controller correct for?</li>
				<li>What is the difference between a cost and a constraint in an MPC?</li>
			</ol>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor249"/>Further reading</h1>
			<ul>
				<li>Control theory: <a href="https://en.wikipedia.org/wiki/Control_theory#Main_control_strategies">https://en.wikipedia.org/wiki/Control_theory#Main_control_strategies</a></li>
				<li><em class="italic">Self-Tuning PID Controller for Autonomous Car Tracking in Urban Traffic</em>: <a href="http://oa.upm.es/30015/1/INVE_MEM_2013_165545.pdf">http://oa.upm.es/30015/1/INVE_MEM_2013_165545.pdf</a></li>
				<li>The Twiddle algorithm for tuning PID controllers: <a href="https://martin-thoma.com/twiddle/">https://martin-thoma.com/twiddle/</a></li>
				<li> <em class="italic">Lateral Tracking Control for the Intelligent Vehicle Based on Adaptive PID Neural Network</em>: <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492364/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492364/</a></li>
				<li><em class="italic">MPC-Based Approach to Active Steering for Autonomous Vehicle Systems</em>: <a href="https://borrelli.me.berkeley.edu/pdfpub/pub-6.pdf">https://borrelli.me.berkeley.edu/pdfpub/pub-6.pdf</a></li>
				<li><em class="italic">Kinematic and Dynamic Vehicle Models for Autonomous Driving Control Design</em>: <a href="https://borrelli.me.berkeley.edu/pdfpub/IV_KinematicMPC_jason.pdf">https://borrelli.me.berkeley.edu/pdfpub/IV_KinematicMPC_jason.pdf</a></li>
			</ul>
		</div>
	</div>



  </body></html>