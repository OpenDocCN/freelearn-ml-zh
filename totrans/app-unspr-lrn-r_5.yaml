- en: '*Chapter 5*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*'
- en: Data Comparison Methods
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据比较方法
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Create hashes of data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据哈希
- en: Create image signatures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像签名
- en: Compare image datasets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较图像数据集
- en: Perform factor analysis to isolate latent variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行因子分析以隔离潜在变量
- en: Compare surveys and other datasets using factor analysis
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用因子分析比较调查和其他数据集
- en: In this chapter, we will have a look at different data comparison methods.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的数据比较方法。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Unsupervised learning is concerned with analyzing the structure of data to draw
    useful conclusions. In this chapter, we will examine methods that enable us to
    use the structure of data to compare datasets. The major methods we will look
    at are hash functions, analytic signatures, and latent variable models.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无监督学习关注于分析数据的结构以得出有用的结论。在本章中，我们将探讨使我们能够利用数据结构来比较数据集的方法。我们将重点研究的方法包括哈希函数、分析签名和潜在变量模型。
- en: Hash Functions
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希函数
- en: Imagine that you want to send an R script to your friend. However, you and your
    friend have been having technical problems with your files – maybe your computers
    have been infected by malware, or maybe a hacker is tampering with your files.
    So, you need a way to ensure that your script is sent intact to your friend, without
    being corrupted or changed. One way to check that files are intact is to use **hash
    functions**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想把一个R脚本发送给你的朋友。然而，你和你的朋友在文件上遇到了技术问题——也许你们的电脑被恶意软件感染了，或者也许有黑客正在篡改你的文件。所以，你需要一种方法来确保你的脚本在发送给朋友时是完整的，没有被损坏或更改。检查文件是否完整的一种方法就是使用**哈希函数**。
- en: A hash function can create something like a **fingerprint** for data. What we
    mean by a fingerprint is something that is small and easy to check that enables
    us to verify whether the data has the identity we think it should have. So, after
    you create the script you want to send, you apply your hash function to the script
    and get its fingerprint. Then, your friend can use the same hash function on the
    file after it is received and check to make sure the fingerprints match. If the
    fingerprint of the file that was sent matches the fingerprint of the file that
    was received, then the two files should be the same, meaning that the file was
    sent intact. The following exercise shows how to create and use a simple hash
    function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数可以为数据创建类似指纹的东西。我们所说的指纹是指一种小而易于检查的东西，使我们能够验证数据是否具有我们认为是其身份的东西。因此，在你创建想要发送的脚本之后，你将对脚本应用哈希函数并获取其指纹。然后，你的朋友可以在收到文件后使用相同的哈希函数对文件进行处理，并确保指纹匹配。如果发送的文件指纹与接收到的文件指纹匹配，那么这两个文件应该是相同的，这意味着文件是完整发送的。以下练习展示了如何创建和使用一个简单的哈希函数。
- en: 'Exercise 29: Creating and Using a Hash Function'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习29：创建和使用哈希函数
- en: 'In this exercise, we will create and use a hash function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建和使用一个哈希函数：
- en: 'Specify the data on which you need to use the hash function. We have been exploring
    the scenario of an R script that you want to send. Here is an example of a simple
    R script:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定需要使用哈希函数的数据。我们一直在探讨你想发送的R脚本场景。以下是一个简单的R脚本示例：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have a script that prints the string `Take the cake`. We have saved
    it as a variable called `string_to_hash`.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有一个打印字符串`Take the cake`的脚本。我们将其保存为名为`string_to_hash`的变量。
- en: 'Specify the total number of possible hash values. Our goal is to create a fingerprint
    for our script. We need to specify the total number of possible fingerprints that
    we will allow to exist. We want to specify a number that is low enough to work
    with easily, but high enough that there is not much likelihood of different scripts
    having the same fingerprint by coincidence. Here, we will use 10,000:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定可能的哈希值总数。我们的目标是为我们脚本创建一个指纹。我们需要指定我们将允许存在的指纹总数。我们希望指定一个足够低以便于操作，但又足够高以至于不同脚本偶然具有相同指纹的可能性不大的数字。在这里，我们将使用10,000：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Convert the script (currently a string) to numeric values. Hash functions are
    usually arithmetic, so we will need to be working with numbers instead of strings.
    Luckily, R has a built-in function that can accomplish this for us:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本（目前是一个字符串）转换为数值。哈希函数通常是算术性的，因此我们需要用数字而不是字符串来工作。幸运的是，R有一个内置函数可以为我们完成这项工作：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This has converted each of the characters in our script to an integer, based
    on each character''s encoding in the UTF-8 encoding scheme. We can see the result
    by printing to the console:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这已经将我们的脚本中的每个字符转换为整数，基于每个字符在UTF-8编码方案中的编码。我们可以通过打印到控制台来查看结果：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Apply our hashing function. We will use the following function to generate
    our final hash, or in other words, the fingerprint of the script:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用我们的散列函数。我们将使用以下函数来生成我们的最终散列，或者说，脚本的指纹：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After running this line in R, we find that the final value of `hash` is 2702\.
    Since we have used the modulo operator (`%%` in R), the value of `hash` will always
    be between 0 and 10,000\.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在R中运行这一行后，我们发现`hash`的最终值是2702。由于我们使用了模运算符（在R中为`%%`），`hash`的值将始终在0到10,000之间。
- en: The simple function we used to convert a numeric vector to a final hash value
    is not the only possible hash function. Experts have designed many such functions
    with varying levels of sophistication. There is a long list of properties that
    good hash functions are supposed to have. One of the most important of these properties
    is **collision resistance**, which means that it is difficult to find two datasets
    that yield the same hash.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来将数值向量转换为最终散列值的简单函数并不是唯一的散列函数。专家们设计了许多具有不同复杂程度的此类函数。好的散列函数应该具有许多属性，其中之一是最重要的属性是**抗碰撞性**，这意味着很难找到两个产生相同散列值的数据集。
- en: 'Exercise 30: Verifying Our Hash Function'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习30：验证我们的散列函数
- en: 'In this exercise, we will verify that our hash function enables us to effectively
    compare different data by checking that different messages produce different hashes.
    The outcome of this exercise will be hash functions of different messages that
    we will compare to verify that different messages produce different hashes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将验证我们的散列函数是否使我们能够有效地比较不同的数据，通过检查不同的信息产生不同的散列值。这个练习的结果将是不同信息的散列函数，我们将比较以验证不同的信息产生不同的散列值：
- en: 'Create a function that performs hashing for us. We will put the code that we
    introduced in the preceding exercise together into one function:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个执行散列的函数。我们将把前面练习中引入的代码组合到一个函数中：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function takes the string we want to hash and the total number of possible
    hashes, then applies the same hashing calculation we used in the previous exercise
    to calculate a hash, and then returns that hash value.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数接收我们想要散列的字符串和可能的散列总数，然后应用我们在上一个练习中使用的相同的散列计算来计算散列值，并返回该散列值。
- en: 'Compare hashes of different inputs. We can compare the hashes that are returned
    from different inputs as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较不同输入的散列值。我们可以如下比较来自不同输入的散列值：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have four different strings, expressing different messages. We can
    see the value of their hashes as follows:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有四个不同的字符串，表达不同的信息。我们可以看到它们的散列值如下：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first script returns the hash 2702, as we found in the preceding exercise.
    The second script, even though it is only differs from the first script by one
    character, returns the hash 9853, and the third script, also differing by only
    one character from the first script, returns the hash 9587\. The final script
    returns the hash 5920\. Though these four scripts have substantial similarities,
    they have different fingerprints that we can use to compare them and distinguish
    them.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个脚本返回散列值2702，正如我们在前面的练习中找到的那样。第二个脚本，尽管它只与第一个脚本有一个字符不同，返回的散列值是9853，第三个脚本，也只与第一个脚本有一个字符不同，返回的散列值是9587。最后一个脚本返回的散列值是5920。尽管这四个脚本有相当大的相似性，但它们有不同的指纹，我们可以使用这些指纹来比较和区分它们。
- en: These hashes are useful for you and the recipient of your message to verify
    that your script was sent intact without tampering. When you send the script,
    you can tell your friend to make sure that the hash of the script is 2702\. If
    the hash of the script your friend receives is not 2702, then your friend can
    conclude that the script was tampered with between being sent and being received.
    If your friend can reliably detect whether a file was corrupted, then you can
    avoid spreading malware or arguing with your friend over miscommunication.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些散列对于您和您的消息接收者来说很有用，可以用来验证您的脚本在发送过程中未被篡改。当您发送脚本时，您可以告诉您的朋友确保脚本的散列值是2702。如果您的朋友收到的脚本散列值不是2702，那么您的朋友可以得出结论，脚本在发送和接收过程中被篡改了。如果您的朋友能够可靠地检测文件是否损坏，那么您可以避免传播恶意软件或与您的朋友因误解而争吵。
- en: 'Software that is distributed online is sometimes distributed with a hash value
    that users can use to check for file corruption. For this purpose, professionals
    use hash functions that are more advanced than the simple function presented in
    the preceding exercises. One of the hash functions that professionals use is called
    MD5, which can be applied very easily in R using the `digest` package:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在线分发的软件有时会附带一个用户可以用来检查文件损坏的哈希值。为此，专业人士使用比前面练习中简单函数更高级的哈希函数。专业人士使用的其中一个哈希函数称为MD5，在R中使用`digest`包可以非常容易地应用它：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we can see the MD5 hash of our simple R script. You can feel free to try
    out MD5 hashes of other data as well to compare the results.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们简单R脚本的MD5哈希值。您可以自由尝试其他数据的MD5哈希值，以比较结果。
- en: Analytic Signatures
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析签名
- en: In *Chapter 4*, *Dimension Reduction,* we discussed dimension reduction – methods
    that enable us to express data succinctly in ways that give us insights into the
    data. A hash function, discussed previously, is yet another way to accomplish
    dimension reduction. Hash functions are effective for many purposes, including
    the file verification use case we discussed. In that scenario, we were interested
    in determining whether two scripts were exactly the same or not. Even a slight
    difference in data, such as changing the word "take" to "make," had the potential
    to completely corrupt the intended message, so exactness was required.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*降维*中，我们讨论了降维——这些方法使我们能够以给我们数据洞察力的方式简洁地表达数据。之前讨论的哈希函数是另一种实现降维的方法。哈希函数在许多用途中都很有用，包括我们讨论的文件验证用例。在那个场景中，我们感兴趣的是确定两个脚本是否完全相同。即使数据有细微的差异，例如将“take”一词改为“make”，也可能完全破坏预期的信息，因此需要精确性。
- en: In other cases, we may want to make meaningful comparisons between different
    datasets without requiring the exact identity of the two datasets being compared.
    Consider the case of detecting copyright violations. Suppose that a website hosts
    images from its users. It wants to ensure that users are not submitting images
    that are protected by copyright. So, every time it receives an upload, it wants
    to check whether that upload is the same as any of the images in a large database
    of copyrighted images.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们可能希望在不需要比较的两个数据集具有完全相同性的情况下，进行有意义的比较。考虑检测版权侵犯的情况。假设一个网站托管了来自其用户的图像。它想要确保用户没有提交受版权保护的图像。因此，每次它收到上传时，它都希望检查该上传是否与大型版权图像数据库中的任何图像相同。
- en: It is not sufficient to check whether images are exactly the same, since unscrupulous
    uploaders may make slight alterations and attempt to upload anyway. For example,
    they might change the color of one pixel, or crop the image very slightly, or
    compress it to be larger or smaller than the original. Even with these slight
    alterations, the images would still violate copyright laws. A hash function that
    checked for exact identity would fail to recognize these copyright violations.
    So, the image hosting site will want to check whether there is any underlying
    structure in the data representing the two pictures that is substantially similar.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 仅检查图像是否完全相同是不够的，因为一些不择手段的上传者可能会进行细微的修改并仍然尝试上传。例如，他们可能会改变一个像素的颜色，或者非常轻微地裁剪图像，或者将其压缩到比原始图像大或小。即使有这些细微的修改，图像仍然会违反版权法。一个检查完全相同性的哈希函数将无法识别这些版权侵犯。因此，图像托管网站将想要检查代表两张图片的数据中是否存在任何实质上相似的底层结构。
- en: We mentioned that hash functions created something that's like a fingerprint
    for data. Fingerprints should be exactly the same each time they are observed,
    and even if two fingerprints are similar in most ways, we will not regard them
    as matching each other unless they match completely.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，哈希函数创建了一种类似于数据指纹的东西。指纹应该在每次观察时都完全相同，即使两个指纹在大多数方面相似，除非它们完全匹配，否则我们不会认为它们彼此匹配。
- en: Instead of a fingerprint, in this case we need something more like a signature.
    Each time you sign your name, your signature should look more or less the same.
    But, there will be small differences in each signature, even when signed by the
    same person and even when attempting to match previous signatures. In order to
    verify whether a signature matches, we need to check for substantial similarity
    but not perfect identity. The code we present here will show how to encode any
    image of any size in a small and robust encoding that enables quick and accurate
    approximate comparisons between datasets. This method for encoding image data
    can be referred to as creating an **analytic signature**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要的更像是一个签名，而不是指纹。每次您签名时，您的签名应该看起来或多或少相同。但是，即使是同一个人在尝试匹配之前的签名时，每个签名之间也会有细微的差异。为了验证签名是否匹配，我们需要检查实质性的相似性，而不是完美的身份。我们在这里提供的代码将展示如何将任何大小图像编码为一个小巧且健壮的编码，这允许在数据集之间进行快速且准确的近似比较。这种编码图像数据的方法可以被称为创建**分析签名**。
- en: Our method for creating a signature for an image will proceed as follows. First,
    we will divide our image into a 10x10 grid. We will then measure the brightness
    of each section of this grid. After that, we will compare the brightness of each
    section to the brightness of its neighbors. The final signature will consist of
    a vector of comparisons between each grid section and each of its neighbors. This
    signature method was invented by Wong, Bern, and Goldberg, who published it in
    a paper called *An Image Signature for Any Kind of Image*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建图像签名的步骤如下。首先，我们将图像分成一个10x10的网格。然后，我们将测量网格每个部分的亮度。之后，我们将比较每个部分的亮度与其相邻部分的亮度。最终的签名将包含一个向量，该向量包含每个网格部分与其每个相邻部分的比较。这种方法是由Wong、Bern和Goldberg发明的，并在一篇名为《任何类型图像的图像签名》的论文中发表。
- en: Before we create an analytic signature, we will need to do some data preparation,
    as outlined in the next exercise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建分析签名之前，我们需要进行一些数据准备，如下一练习所述。
- en: 'Exercise 31: Perform the Data Preparation for Creating an Analytic Signature
    for an Image'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习31：为创建图像分析签名进行数据准备
- en: In this exercise, we will perform the data preparation for creating an analytic
    signature for a photo of the Alamo.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为阿拉莫的照片创建分析签名进行数据准备。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For all the exercises and activities where we are importing external CSV files
    or images, go to **RStudio**-> **Session**-> **Set Working Directory**-> **To
    Source File Location**. You can see in the console that the path is set automatically.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有需要导入外部CSV文件或图像的练习和活动，请转到**RStudio**-> **会话**-> **设置工作目录**-> **到源文件位置**。您可以在控制台中看到路径已自动设置。
- en: First, we will need to configure R to be able to read in and work with our image
    data. We will need to install the `imager` package. You can install this package
    by executing `install.packages('imager')` in the R console, and then you can load
    it by running `library('imager')` in the console.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要配置R以能够读取并处理我们的图像数据。我们需要安装`imager`包。您可以在R控制台中执行`install.packages('imager')`来安装此包，然后您可以通过在控制台中运行`library('imager')`来加载它。
- en: Next, we will need to read in the data. We will be working with this photo of
    the Alamo in our example:![](img/C12628_05_01.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要读取数据。在我们的例子中，我们将使用这张阿拉莫的照片：![](img/C12628_05_01.jpg)
- en: 'Figure 5.1: Alamo image'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.1：阿拉莫图像
- en: 'First, download this to your computer from [https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/](https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/blob/master/Lesson05/alamo.jpg)Lesson05/Exercise31/alamo.jpg
    and save it as `alamo.jpg`. Make sure that it is saved in R''s working directory.
    If it is not in R''s working directory, then change R''s working directory using
    the `setwd()` function. Then, you can load this image into a variable called `im`
    (short for image) as follows:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，从[https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/](https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/blob/master/Lesson05/Exercise31/alamo.jpg)Lesson05/Exercise31/alamo.jpg下载到您的计算机上，并将其保存为`alamo.jpg`。确保它保存在R的工作目录中。如果它不在R的工作目录中，那么请使用`setwd()`函数更改R的工作目录。然后，您可以将此图像加载到名为`im`（代表图像）的变量中，如下所示：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The rest of the code we will explore will use this image called `im`. Here,
    we have loaded a photo of the Alamo into `im`. However, you can run the rest of
    the code on any image, simply by saving the image to your working directory and
    specifying its path in the `filepath` variable.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将要探索的其余代码将使用这个名为`im`的图像。在这里，我们已经将阿拉莫的照片加载到`im`中。然而，你可以通过将图像保存到你的工作目录并在`filepath`变量中指定其路径来运行其余的代码。
- en: 'The signature we are developing is meant to be used for grayscale images. So,
    we will convert this image to grayscale by using functions in the `imager` package:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在开发的签名是为了用于灰度图像。因此，我们将使用`imager`包中的函数将此图像转换为灰度：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second line of this code is the conversion to grayscale. The last line performs
    a split of the image into 10 equal sections.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码的第二行是将图像转换为灰度。最后一行将图像分割成10等份。
- en: 'The following code creates an empty matrix that we will fill with information
    about each section of our 10x10 grid:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码创建了一个空矩阵，我们将用有关我们10x10网格每个部分的详细信息来填充它：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will run the following loop. The first line of this loop uses the
    `imsplit` command. This command was also used earlier to split the x-axis into
    10 equal parts. This time, for each of the 10 x-axis splits, we will do a split
    along the yaxis, also splitting it into 10 equal parts:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将运行以下循环。这个循环的第一行使用了`imsplit`命令。这个命令之前也被用来将x轴分成10等份。这次，对于x轴的每个10等份，我们将在y轴上进行分割，也将它分成10等份：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After splitting along the y axis, the matrix is updated with `mean(is[[j]])`.
    This is a measure of the mean brightness of the selected section.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在沿y轴分割后，矩阵通过`mean(is[[j]])`更新。这是所选部分的平均亮度的度量。
- en: The result of this code is a 10x10 matrix, where the `i-j` element contains
    the average brightness of the `i`-`j` section of the original photo.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码的结果是一个10x10的矩阵，其中`i-j`元素包含原始照片`i-j`部分的平均亮度。
- en: 'If you print this matrix, you can see the brightness numbers for each section
    of the photo:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你打印这个矩阵，你可以看到照片每个部分的亮度数字：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output should look like the following:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像以下这样：
- en: '![Figure 5.2: Screenshot of the output matrix'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.2: Screenshot of the output matrix'
- en: '](img/C12628_05_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C12628_05_02.jpg](img/C12628_05_02.jpg)'
- en: 'Figure 5.2: Screenshot of the output matrix'
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.2：输出矩阵的截图
- en: You can compare these brightness numbers to the appearance of the original photo.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些亮度数字与原始照片的外观进行比较。
- en: We could stop here, since we have generated a compressed encoding of a complex
    dataset. However, we can take some further steps to make this encoding more useful.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里停止，因为我们已经生成了一个复杂数据集的压缩编码。然而，我们可以采取一些进一步的步骤来使这个编码更有用。
- en: One thing we can do is create a `brightnesscomparison` function. The purpose
    of this function is to compare the relative brightness of two different sections
    of an image. Eventually, we will compare all of the different sections of each
    image we analyze. Our final fingerprint will consist of many such brightness comparisons.
    The purpose of this exercise is to create the brightness comparison function that
    will eventually enable us to create the final fingerprint.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的事情之一是创建一个`brightnesscomparison`函数。这个函数的目的是比较图像中两个不同部分的相对亮度。最终，我们将比较我们分析的每张图像的所有不同部分。我们的最终指纹将包含许多这样的亮度比较。这个练习的目的是创建一个亮度比较函数，这将最终使我们能够创建最终的指纹。
- en: Please note, this exercise is built on top of the previous exercise, meaning
    that you should run all of the code in the previous exercise before you run the
    code in this exercise.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个练习是在上一个练习的基础上构建的，这意味着你应该在运行这个练习的代码之前运行上一个练习中的所有代码。
- en: 'Exercise 32: Creating a Brightness Comparison Function'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习32：创建亮度比较函数
- en: 'In this function, we pass two arguments, `x` and `y`: each argument represents
    the brightness of a particular section of the picture. If `x` and `y` are quite
    similar (less than 10% different), then we say that they are essentially the same
    and we return 0, indicating approximately 0 difference in brightness. If `x` is
    more than 10% greater than `y`, we return 1, indicating that `x` is brighter than
    `y`, and if `x` is more than 10% smaller than `y`, we return -1, indicating that
    `x` is less bright than `y`.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们传递两个参数，`x`和`y`：每个参数代表图片中特定部分的亮度。如果`x`和`y`相当相似（小于10%的差异），那么我们可以说它们基本上是相同的，我们返回0，表示亮度差异大约为0。如果`x`比`y`大10%以上，我们返回1，表示`x`比`y`亮，如果`x`比`y`小10%以上，我们返回-1，表示`x`比`y`暗。
- en: 'Create the brightness comparison function. The code for the `brightnesscomparison`
    function is as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建亮度比较函数。`brightnesscomparison` 函数的代码如下：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use this function to compare two sections of the 10x10 grid we formed
    for our picture. For example, to find the brightness comparison of a section with
    the section that is directly to its left, we can execute the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数来比较我们为图片形成的 10x10 网格的两个部分。例如，为了找到与直接左侧部分的亮度比较，我们可以执行以下代码：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we looked at the 5th row and 5th column of our matrix. We compared this
    section to the section directly to the left of it – the 5th row and 4th column,
    which we accessed by specifying `j-1`.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们查看矩阵的第 5 行和第 5 列。我们将这个部分与它左侧直接的部分进行比较——第 5 行和第 4 列，我们通过指定 `j-1` 来访问这个部分。
- en: 'Use the brightness comparison function to compare an image section to its neighbor
    above it. We could do an analogous operation to compare this section to the section
    above it:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用亮度比较函数来比较图像部分与其上面的邻居。我们可以进行类似的操作来比较这个部分与其上面的部分：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `top` is a comparison of the brightness of section 5, 5 with the section
    immediately above it, which we accessed by specifying `i-1`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`top` 是第 5 节与它上面紧邻的节点的亮度比较，我们通过指定 `i-1` 来访问这个节点。
- en: The important outputs of this exercise are the values of `top` and `left`, which
    are both comparisons of an image section to other, neighboring sections. In this
    case, left is equal to zero, meaning that the image section we selected has about
    the same brightness as the image section to its left. Also, `top` is equal to
    1, meaning that the section directly above the section we selected is brighter
    than the section we selected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的重要输出是 `top` 和 `left` 的值，它们都是图像部分与其他相邻部分的比较。在这种情况下，`left` 等于零，意味着我们选择的图像部分的亮度与左侧的图像部分大致相同。同样，`top`
    等于 1，意味着我们选择的节点的直接上方部分比我们选择的节点亮度更高。
- en: In the next exercise, we will create a `neighborcomparison` function. This function
    takes every section of our 10x10 grid and compares the brightness of that section
    to its neighbors. These neighbors include the left neighbor, whose brightness
    we compared a moment ago, and also the top neighbor. Altogether, there are eight
    neighbors for each section of our picture (top, bottom, left, right, top-left,
    top-right, bottom-left, and bottom-right). The reason we will want this neighbor
    comparison function is because it will make it very easy for us to get our final
    analytic signature.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将创建一个 `neighborcomparison` 函数。这个函数将比较我们 10x10 网格中的每个节点的亮度，与它的邻居进行比较。这些邻居包括我们刚才比较过的左侧邻居，以及上面的邻居。总的来说，我们图片的每个部分（顶部、底部、左侧、右侧、左上、右上、左下和右下）都有八个邻居。我们想要这个邻居比较函数的原因是，它将使我们很容易得到最终的解析特征。
- en: Please note that this exercise builds on the previous exercises, and you should
    run all of the previous code before running this code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个练习建立在之前的练习之上，你应该在运行这段代码之前运行所有之前的代码。
- en: 'Exercise 33: Creating a Function to Compare Image Sections to All of the Neighboring
    Sections'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 33：创建一个函数来比较图像部分与所有相邻部分
- en: 'In this exercise, we will create a `neighborcomparison` function to compare
    image sections to all other neighboring sections. To do this, perform the following
    steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个 `neighborcomparison` 函数来比较图像部分与其他所有相邻部分。为此，执行以下步骤：
- en: 'Create a function that compares an image section to its neighbor on the left.
    We did this in the previous exercise. For any image section, we can compare its
    brightness to the brightness of its neighbor on the left as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，比较图像部分与其左侧的邻居。我们在之前的练习中做过这个操作。对于任何图像部分，我们可以比较其亮度与其左侧邻居的亮度，如下所示：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a function that compares an image section to its neighbor on top. We
    did this in the previous exercise. For any image section, we can compare its brightness
    to the brightness of its neighbor above it as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，比较图像部分与其上面的邻居。我们在之前的练习中做过这个操作。对于任何图像部分，我们可以比较其亮度与其上方邻居的亮度，如下所示：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you look at S*tep 1* and S*tep 2*, you can start to notice the pattern in
    these neighbor comparisons. To compare an image section to the section on its
    left, we need to access the part of the matrix at index `j-1`. To compare an image
    section to the section on its right, we need to access the part of the matrix
    at index `j+1`. To compare an image section to the section above it, we need to
    access the part of the matrix at index `i-1`. To compare an image section to the
    section below it, we need to access the part of the matrix at index `i+1`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你查看S*tep 1*和S*tep 2*，你可以开始注意到这些邻居比较中的模式。要比较图像部分与其左侧的部分，我们需要访问矩阵的`j-1`索引部分。要比较图像部分与其右侧的部分，我们需要访问矩阵的`j+1`索引部分。要比较图像部分与其上方的部分，我们需要访问矩阵的`i-1`索引部分。要比较图像部分与其下方的部分，我们需要访问矩阵的`i+1`索引部分。
- en: 'So, we will have comparisons of each image section to each of its neighbors,
    above, below, left, and right. The following code shows the comparisons we will
    make in addition to the top and left comparisons made in S*tep 1* and S*tep 2*:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们将有每个图像部分与其上方、下方、左侧和右侧的每个邻居的比较。以下代码显示了我们将进行的比较，除了在S*tep 1*和S*tep 2*中进行的顶部和左侧比较：
- en: '[PRE21]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Initialize a vector that will contain the final comparison of a section to
    each of its neighbors:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个向量，该向量将包含部分与其每个邻居的最终比较：
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will use this `comparison` vector to store all of the neighbor comparisons
    that we eventually generate. It will consist of comparisons of an image section
    to each of its neighbors.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用这个`comparison`向量来存储我们最终生成的所有邻居比较。它将包含图像部分与其每个邻居的比较。
- en: 'In steps 1-4, we have shown the individual parts of the neighbor comparison
    function. In this step, we will combine them. The neighbor comparison function
    that you can see takes an image matrix as an argument, and also `i` and `j` values,
    specifying which part of the image matrix we are focusing on. The function uses
    the code we wrote for the `top` and `left` comparisons, and also adds other comparisons
    for other neighbors, such as `top_left`, which compares an image brightness level
    with the image brightness of the section above and to the left. Altogether, each
    image section should have eight neighbors: top-left, top, top-right, left, right,
    bottom-left, bottom, and bottom-right. In this step, we will do each of these
    eight comparisons and store them in the `comparison` vector. Finally, there is
    a `return` statement that returns all of the comparisons together.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤1-4中，我们展示了邻居比较函数的各个部分。在这个步骤中，我们将它们组合起来。你可以看到的邻居比较函数接受一个图像矩阵作为参数，并且还有`i`和`j`值，指定我们正在关注的图像矩阵的部分。该函数使用我们为`top`和`left`比较编写的代码，并为其他邻居添加了其他比较，例如`top_left`，它比较图像亮度级别与上方左侧部分的图像亮度。总的来说，每个图像部分应该有八个邻居：左上、上、右上、左、右、左下、下和右下。在这个步骤中，我们将进行这八个比较并将它们存储在`comparison`向量中。最后，有一个`return`语句，它返回所有比较。
- en: 'Here is the function we can use to get all of the neighbor comparisons:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是我们可以使用来获取所有邻居比较的函数：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function returns a vector with eight elements: one for each of the neighbors
    of a particular section of our grid. You may have noticed that some sections of
    the 10x10 grid do not appear to have eight neighbors. For example, the 1-1 element
    of the 10x10 grid has a neighbor below it, but does not have a neighbor above
    it. For grid locations that do not have particular neighbors, we say that their
    brightness comparison is 0 for that neighbor. This decreases the level of complexity
    in creating and interpreting the brightness comparisons.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个包含八个元素的向量：每个元素对应于我们网格中特定部分的邻居。你可能已经注意到，10x10网格的一些部分似乎没有八个邻居。例如，10x10网格的1-1元素下面有一个邻居，但没有上面的邻居。对于没有特定邻居的网格位置，我们说它们对该邻居的亮度比较为0。这降低了创建和解释亮度比较的复杂性水平。
- en: The final output is a vector called `comparison`, which contains comparisons
    of brightness levels between an image section and each of its eight neighbors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出是一个名为`comparison`的向量，它包含图像部分与其八个邻居之间的亮度级别比较。
- en: In the next exercise, we will finish creating our analytic signature. The analytic
    signature for each image will consist of comparisons of each image section with
    each of its eight neighbors. We will use two nested `for` loops to iterate through
    every section of our 10x10 grid. The expected output of this exercise will be
    a function that generates an analytic signature for an image.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将完成创建我们的分析签名。每个图像的分析签名将包括每个图像部分与其八个邻居的比较。我们将使用两个嵌套的 `for` 循环来遍历我们
    10x10 网格的每个部分。本练习的预期输出将是一个生成图像分析签名的函数。
- en: 'Exercise 34: Creating a Function that Generates an Analytic Signature for an
    Image'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 34：创建一个生成图像分析签名的函数
- en: 'In this exercise, we will create a function that generates an analytic signature
    for an image. To do this, perform the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，用于为图像生成一个分析签名。为此，请执行以下步骤：
- en: 'We begin by creating a `signature` variable and initializing it with a `NULL`
    value:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `signature` 的变量，并用 `NULL` 值初始化它：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This `signature` variable will store the complete signature when we have finished.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们完成时，这个 `signature` 变量将存储完整的签名。
- en: 'Now we can loop through our grid. For each section of the grid, we add eight
    new elements to the signature. The elements we add are the outputs of the `neighborcomparison`
    function we introduced earlier:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以遍历我们的网格。对于网格的每个部分，我们向签名中添加八个新元素。我们添加的元素是我们之前介绍的 `neighborcomparison`
    函数的输出：
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see what our fingerprint looks like by running `print(signature)` in
    the console. It is a vector of 800 values, all of which are equal to either 0
    (indicating similar brightness or no neighbor), 1 (indicating that a section is
    more bright than its neighbor), or -1 (indicating that a section is less bright
    than its neighbor).
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过在控制台中运行 `print(signature)` 来查看我们的指纹是什么样的。它是一个包含 800 个值的向量，所有这些值都等于 0（表示相似的亮度或没有邻居）、1（表示某个区域比其邻居更亮）或
    -1（表示某个区域比其邻居更暗）。
- en: 'Put S*tep 1* and S*tep 2* together in a function that can generate a signature
    for any image matrix:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 S*tep 1* 和 S*tep 2* 结合在一个函数中，该函数可以生成任何图像矩阵的签名：
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code defines a function called `get_signature`, and it uses the code from
    S*tep 1* and S*tep 2* to get that signature. We can call this function using the
    image matrix we created earlier.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码定义了一个名为 `get_signature` 的函数，它使用来自 S*tep 1* 和 S*tep 2* 的代码来获取该签名。我们可以使用之前创建的图像矩阵来调用此函数。
- en: 'Since we are going to create more signatures later, we will save this signature
    to a variable that refers to what it is a signature of. In this case, we will
    call it `building_signature` since it is a signature of an image of a building.
    We can do this as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们稍后还将创建更多签名，我们将把这个签名保存到一个变量中，该变量指明了它代表的是什么。在这种情况下，我们将称之为 `building_signature`，因为它是一个建筑图像的签名。我们可以这样做：
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure: 5.3: Matrix of building_signature'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图：5.3：building_signature 矩阵'
- en: '](img/C12628_05_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12628_05_03.jpg)'
- en: 'Figure: 5.3: Matrix of building_signature'
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图：5.3：building_signature 矩阵
- en: The vector stored in `building_signature` is the final output of this exercise,
    and it is the image signature we have been trying to develop throughout this chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `building_signature` 中的向量是这个练习的最终输出，也是我们在本章中一直试图开发的图像签名。
- en: 'This signature is meant to be like a human''s handwritten signature: small
    and apparently similar to other signatures, but sufficiently unique to enable
    us to distinguish it from millions of other existing signatures.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名旨在类似于人类的亲笔签名：小巧且表面上与其他签名相似，但足够独特，使我们能够将其与数百万其他现有签名区分开来。
- en: We can check the robustness of the signature solution we have found by reading
    in a completely different image and comparing the resulting signatures. This is
    the scenario for the following activity.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过读取一个完全不同的图像并比较生成的签名来检查我们找到的签名解决方案的鲁棒性。这就是以下活动的场景。
- en: 'Activity 11: Creating an Image Signature for a Photograph of a Person'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 11：为人物照片创建图像签名
- en: Let's try to create an image fingerprint for this image, a photograph of the
    great Jorge Luis Borges.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试为这张图像创建一个图像指纹，这是一张伟大的豪尔赫·路易斯·博尔赫斯的照片。
- en: 'To accomplish this activity, you can follow all of the steps we have followed
    so far in this chapter. The following steps will outline this process for you.
    Remember that in our previous image signature exercise, we used a 10x10 matrix
    of brightness measurements. However, a 10x10 matrix may be inappropriate for some
    situations, for example, if the image we are working with is particularly small,
    or if we have data storage constraints, or if we expect higher accuracy with a
    different matrix size. So, in the following activity, we will also calculate a
    signature using a 9x9 matrix:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个活动，您可以遵循本章中我们已经遵循的所有步骤。以下步骤将为您概述这个过程。请记住，在我们之前进行的图像签名练习中，我们使用了一个 10x10
    的亮度测量矩阵。然而，10x10 的矩阵可能不适合某些情况，例如，如果我们处理的图像特别小，或者我们有数据存储限制，或者我们期望使用不同的矩阵大小可以获得更高的精度。因此，在以下活动中，我们也将使用
    9x9 矩阵计算一个签名：
- en: Note
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This can be performed on any given matrix size. It could be a 5x5 matrix for
    data storage purposes or a 20x20 matrix for accurate signatures.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在任何给定的矩阵大小上执行。它可能是一个 5x5 的矩阵用于数据存储，或者是一个 20x20 的矩阵用于精确的签名。
- en: '![Figure 5.4: Jorge Luis Borges image'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：豪尔赫·路易斯·博尔赫斯图像'
- en: '](img/C12628_05_04.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12628_05_04.jpg)'
- en: 'Figure 5.4: Jorge Luis Borges image'
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.4：豪尔赫·路易斯·博尔赫斯图像
- en: 'These steps will help us complete the activity:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助我们完成活动：
- en: Load the image into your R working directory. Save it to a variable called `im`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像加载到您的 R 工作目录中。将其保存到名为 `im` 的变量中。
- en: Convert your image to grayscale and split it into 100 sections.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的图像转换为灰度并分成 100 个部分。
- en: Create a matrix of brightness values.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个亮度值矩阵。
- en: Create a signature using the `get_signature` function we created earlier. Save
    the signature of the Borges image as `borges_signature`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前创建的 `get_signature` 函数创建一个签名。将 Borges 图像的签名保存为 `borges_signature`。
- en: Note
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 227.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第 227 页找到。
- en: 'The final output of this activity is the `borges_signature` variable, which
    is the analytic signature of the Borges photo. Additionally, we have created the
    `borges_signature_ninebynine` variable, which is also an analytic signature, but
    based on a 9x9 rather than a 10x10 matrix. We can use either of them in our analysis,
    but we will use the `borges_signature` variable. If you have completed all of
    the exercises and activities so far, then you should have two analytic signatures:
    one called `building_signature`, and one called `borges_signature`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的最终输出是 `borges_signature` 变量，它是 Borges 照片的分析签名。此外，我们还创建了 `borges_signature_ninebynine`
    变量，它也是一个分析签名，但基于 9x9 而不是 10x10 的矩阵。我们可以在分析中使用它们中的任何一个，但我们将使用 `borges_signature`
    变量。如果您已经完成了迄今为止的所有练习和活动，那么您应该有两个分析签名：一个名为 `building_signature`，另一个名为 `borges_signature`。
- en: Comparison of Signatures
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名比较
- en: Next, we can compare these two signatures, to see whether they have mapped our
    different images to different signature values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以比较这两个签名，看看它们是否将我们的不同图像映射到不同的签名值。
- en: 'You can compare the signatures with one simple line of R code as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下一行 R 代码比较签名：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This comparison takes the absolute value of the difference between each element
    of the two signatures, and then calculates the mean of those values. If two signatures
    are identical, then this difference will be 0\. The larger the value of `comparison`,
    the more different the two images are.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较计算了两个签名中每个元素之间的差的绝对值，然后计算这些值的平均值。如果两个签名完全相同，那么这个差值将为 0。`comparison` 的值越大，两个图像的差异就越大。
- en: In this case, the value of `comparison` is 0.644, indicating that on average,
    the corresponding signature entries are about 0.644 apart. This difference is
    substantial for a dataset where the values only range between 1 and -1\. So we
    see that our method for creating signatures has created very different signatures
    for very different images, as we would expect.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`comparison` 的值为 0.644，这表明平均而言，相应的签名条目之间大约相差 0.644。对于值仅在 1 和 -1 之间变化的数据库来说，这种差异是显著的。因此，我们看到我们的签名创建方法为非常不同的图像创建了非常不同的签名，正如我们所期望的那样。
- en: 'Now, we can calculate a signature for an image that is very similar to our
    original image, but not identical:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算一个与我们的原始图像非常相似但又不完全相同的图像的签名：
- en: '![Figure 5.5: Alamo_marked image'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5：标记的阿拉莫图像'
- en: '](img/C12628_05_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12628_05_05.jpg)'
- en: 'Figure 5.5: Alamo_marked image'
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.5：标记的阿拉莫图像
- en: To obtain this image, I started with the original Alamo image, and I added the
    word **watermark** in four places, simulating what someone might do to alter an
    image. Naive copyright detection software might be fooled by this watermark, since
    the image is now different from the original. Our analytic signature method should
    not be so naive. We will accomplish this in the following activity.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这张图像，我从一个原始的阿拉莫图像开始，并在四个地方添加了单词**水印**，模拟了有人可能对图像进行的修改。由于图像现在与原始图像不同，简单的版权检测软件可能会被这个水印欺骗。我们的分析签名方法不应该如此天真。我们将在以下活动中完成这项任务。
- en: 'Activity 12: Creating an Image Signature for the Watermarked Image'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十二：为水印图像创建图像签名
- en: 'In this activity, we will create an image signature for the watermarked image:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将为水印图像创建一个图像签名：
- en: Load the image into your R working directory. Save it to a variable called `im`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像加载到您的R工作目录中。将其保存到名为`im`的变量中。
- en: Convert your image to grayscale and split it into 100 sections.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的图像转换为灰度并分成100个部分。
- en: Create a matrix of brightness values.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个亮度值矩阵。
- en: Create a signature using the `get_signature` function we created earlier. Save
    the signature of the Alamo image as `watermarked_signature`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前创建的`get_signature`函数创建一个签名。将阿拉莫图像的签名保存为`watermarked_signature`。
- en: Compare the signature of the watermarked image to the signature of the original
    image to determine whether the signature method can tell the images apart.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将水印图像的签名与原始图像的签名进行比较，以确定签名方法是否能够区分图像。
- en: 'The output will be as follows:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.6: Expected signature of watermarked image'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：预期水印图像的签名'
- en: '](img/C12628_05_06.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C12628_05_06.jpg](img/C12628_05_06.jpg)'
- en: 'Figure 5.6: Expected signature of watermarked image'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.6：预期水印图像的签名
- en: Note
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 230.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第230页找到。
- en: In order to detect copyright violations, we can calculate signatures for every
    copyrighted image in a database. Then, for every newly uploaded image, we compare
    the signature of the newly uploaded image to the signatures in the database. If
    any of the copyrighted images have a signature that is identical to or substantially
    close to the signature of the new upload, we flag them as potential matches that
    need further investigation. Comparing signatures can be much faster than comparing
    original images, and it has the advantage of being robust to small changes such
    as watermarking.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测版权侵权，我们可以计算数据库中每个受版权保护图像的签名。然后，对于每个新上传的图像，我们将新上传图像的签名与数据库中的签名进行比较。如果任何受版权保护的图像的签名与新上传的图像的签名相同或非常接近，我们将它们标记为潜在的匹配项，需要进一步调查。比较签名可能比比较原始图像快得多，并且它具有对水印等小变化具有鲁棒性的优点。
- en: 'The signature method we just performed is a way to encode data to enable comparisons
    between different datasets. There are many other encoding methods, including some
    that use neural networks. Each encoding method will have some of its own unique
    characteristics, but they will all share some common features: they will all try
    to return compressed data that enables easy and accurate comparison between datasets.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才执行签名方法是一种将数据编码以实现不同数据集之间比较的方法。有许多其他编码方法，包括一些使用神经网络的方法。每种编码方法都将具有其独特的特征，但它们都将共享一些共同特征：它们都将尝试返回压缩数据，以便于在不同数据集之间进行简单和准确的比较。
- en: Applying Other Unsupervised Learning Methods to Analytic Signatures
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将其他无监督学习方法应用于分析签名
- en: 'So far, we have only used hashes and analytic signatures to compare two images
    or four short strings. However, there is no limit to the unsupervised learning
    methods that can be applied to hashes or analytic signatures. Creating analytic
    signatures for a set of images can be the first step of an in-depth analysis rather
    than the last step. After creating analytic signatures for a set of images, we
    can attempt the following unsupervised learning approaches:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了哈希和分析签名来比较两张图像或四个简短字符串。然而，可以应用于哈希或分析签名的无监督学习方法没有限制。为一系列图像创建分析签名可能是深入分析的第一步，而不是最后一步。在为一系列图像创建分析签名之后，我们可以尝试以下无监督学习方法：
- en: '**Clustering**: We can apply any of the clustering methods discussed in the
    first two chapters to datasets consisting of analytic signatures. This could enable
    us to find groups of images that all tend to resemble each other, perhaps because
    they are photographs of the same type of object. Please see the first two chapters
    for more information about clustering methods.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚类**：我们可以将第一、二章节中讨论的任何聚类方法应用于由分析特征组成的数据库。这可能使我们能够找到所有倾向于彼此相似的一组图像，可能是因为它们是同一类型物体的照片。有关聚类方法的更多信息，请参阅第一、二章节。'
- en: '**Anomaly detection**: We can apply the anomaly detection methods described
    in *Chapter 6*, *Anomaly Detection,* to datasets that consist of analytic signatures.
    This will enable us to find images that are very different from the rest of the
    images in the dataset.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常检测**：我们可以将*第6章*中描述的异常检测方法应用于由分析特征组成的数据库。这将使我们能够找到与数据集中其他图像非常不同的图像。'
- en: Latent Variable Models – Factor Analysis
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 潜在变量模型 – 因子分析
- en: This section will cover latent variable models. Latent variable models attempt
    to express data in terms of a small number of variables that are hidden or latent.
    By finding the latent variables that correspond to a dataset, we can better understand
    the data and potentially even understand where it came from or how it was generated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍潜在变量模型。潜在变量模型试图用少量隐藏或潜在的变量来表示数据。通过找到与数据集相对应的潜在变量，我们可以更好地理解数据，甚至可能理解数据来源或生成方式。
- en: 'Consider students receiving grades in a wide variety of classes, from math
    to music to foreign languages to chemistry. Psychologists or educators may be
    interested in using this data to better understand human intelligence. There are
    several different theories of intelligence that researchers might want to test
    in the data, for example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到学生在各种不同课程中获得的分数，从数学到音乐、外语到化学。心理学家或教育工作者可能对使用这些数据更好地理解人类智力感兴趣。研究人员可能想要在数据中测试几种不同的智力理论，例如：
- en: '**Theory 1**: There are two different types of intelligence, and people who
    possess one type will excel in one set of classes, while people who possess the
    other type will excel in other classes.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理论1**：有两种不同类型的智力，拥有一种类型的人将在一组课程中表现出色，而拥有另一种类型的人将在其他课程中表现出色。'
- en: '**Theory 2**: There is only one type of intelligence, and people who possess
    it will excel at all types of classes, and people who do not possess it will not.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理论2**：只有一种类型的智力，拥有它的人将在所有类型的课程中表现出色，而没有它的人则不会。'
- en: '**Theory 3**: People may be highly intelligent when judged by the standards
    of one or a few of the classes they are taking, but not intelligent when judged
    by other standards, and every person will have a different set of classes at which
    they excel.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理论3**：一个人可能在一个或几个他们所学的课程标准下非常聪明，但在其他标准下并不聪明，每个人都会有一套不同的课程，他们在这些课程中表现出色。'
- en: Each of these theories is expressing a notion of latent variables. The data
    only contains student grades, which could be a manifestation of intelligence but
    are not a direct measure of intelligence itself. The theories express ways that
    different kinds of intelligence affect grades in a latent way. Even though we
    do not know which theory is true, we can use tools of unsupervised learning to
    understand the structure of the data and which theory fits the data best.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些理论中的每一个都表达了一个潜在变量的概念。数据只包含学生成绩，这可能是智力的表现，但不是智力本身的直接衡量标准。这些理论表达了不同类型的智力如何以潜在的方式影响成绩。即使我们不知道哪个理论是正确的，我们也可以使用无监督学习工具来理解数据的结构以及哪个理论最适合数据。
- en: Anyone who remembers being a student is probably fed up with people evaluating
    their intelligence. So, we will use a slightly different example. Instead of evaluating
    intelligence, we will evaluate personality. Instead of looking for a right brain
    and a left brain, we will look for different features of people's personalities.
    But we will take the same approach – using latent variables to identify whether
    complex data can be explained by some small number of factors.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 任何记得自己曾是学生的人可能都厌倦了别人评价他们的智力。因此，我们将使用一个稍微不同的例子。我们不会评价智力，而是评价个性。我们不会寻找左右脑，而是寻找人们个性的不同特征。但我们将采取相同的方法——使用潜在变量来识别复杂数据是否可以由少数几个因素解释。
- en: In order to prepare for our analysis, we will need to install and load the right
    packages. The next exercise will cover how to load the packages that will be necessary
    for factor analysis.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的分析做准备，我们需要安装和加载正确的包。下一个练习将涵盖如何加载因子分析所需的包。
- en: 'Exercise 35: Preparing for Factor Analysis'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 35：准备因子分析
- en: 'In this exercise, we will prepare the data for factor analysis:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为因子分析准备数据：
- en: 'Install the necessary packages:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的包：
- en: '[PRE29]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, you can run the following lines to load them into your R workspace:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以运行以下行将它们加载到你的 R 工作空间中：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, load the data. The data we will use is a record of 500 responses to a
    personality test called the "Revised NEO Personality Inventory". The dataset is
    included in the R package called `qgraph`. To begin, read the data into your R
    workspace. This code will allow you to access it as a variable called `big5`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，加载数据。我们将使用的数据是 500 份对名为“修订版 NEO 人格问卷”的人格测试的记录。该数据集包含在名为 `qgraph` 的 R 包中。首先，将数据读入你的
    R 工作空间。以下代码将允许你将其作为名为 `big5` 的变量访问：
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can see the top section of the data by running the following line in the
    R console:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在 R 控制台中运行以下行来查看数据的顶部部分：
- en: '[PRE32]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.7: Top section of the data'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.7：数据顶部部分]'
- en: '](img/C12628_05_07.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.7：数据顶部部分](img/C12628_05_07.jpg)'
- en: 'Figure 5.7: Top section of the data'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.7：数据顶部部分
- en: 'You can see the number of rows and columns of your data as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下方式查看你的数据行和列的数量：
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To check the columns, execute the following:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检查列，执行以下操作：
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This data contains 500 rows and 240 columns. Each row is the complete record
    related to one survey respondent. Each column records answers to one question.
    So, there are 500 survey respondents who have each answered 240 questions. Each
    of the answers are numerical, and you can see the range of responses as follows:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这份数据包含 500 行和 240 列。每一行是与一个调查受访者相关的完整记录。每一列记录了一个问题的答案。因此，有 500 名调查受访者每人回答了 240
    个问题。每个答案都是数值型的，你可以看到以下回答的范围：
- en: '[PRE37]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The answers range from 1 to 5\.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案的范围是 1 到 5。
- en: The expected output of this exercise is an R workspace that has the `big5` data
    loaded. You can be sure that the data is loaded because when you run `print(range(big5))`
    in the console, you get `1 5` as output.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本练习的预期输出是一个已加载 `big5` 数据的 R 工作空间。你可以确信数据已加载，因为当你控制台中运行 `print(range(big5))`
    时，你会得到 `1 5` 作为输出。
- en: 'The questions are asked in this survey by showing survey respondents a question
    and asking them the degree to which they agree with the answer, where 5 represents
    strong agreement and 1 represents strong disagreement. The statements are statements
    about a person''s particular characteristics, for example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调查中，问题是通过向调查受访者展示一个问题并询问他们同意该答案的程度来提出的，其中 5 代表强烈同意，1 代表强烈不同意。这些陈述是关于一个人特定特征的说法，例如：
- en: '"I enjoy meeting new people."'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: “我喜欢结识新朋友。”
- en: '"I sometimes make mistakes."'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: “我有时会犯错误。”
- en: '"I enjoy repairing things."'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: “我喜欢修理东西。”
- en: You can imagine that some of these questions will be measuring the same underlying
    "latent" personality trait. For example, we often describe people as curious,
    in the sense that they like to learn and try new things. Someone who strongly
    agrees with the statement "I enjoy meeting new people" might be likely to also
    agree with the statement "I enjoy repairing things" if both of those statements
    are measuring latent curiosity. Or, it could be that some people possess the personality
    trait of being interested in people, and others possess the personality trait
    of being interested in things. If so, people who agree with "I enjoy meeting new
    people" would not be expected to also agree with "I enjoy repairing things." The
    point of factor analysis here is to discover which of these questions correspond
    to one underlying idea, and to get an idea of what those underlying ideas are.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，其中一些问题可能会测量相同的潜在“潜在”人格特质。例如，我们经常描述人们为好奇，从他们喜欢学习和尝试新事物的意义上来说。那些强烈同意“我喜欢结识新朋友”这一说法的人，如果这两个说法都在测量潜在的好奇心，那么他们很可能也会同意“我喜欢修理东西”这一说法。或者，可能是有些人具有对人们感兴趣的人格特质，而其他人则具有对事物感兴趣的人格特质。如果是这样，那些同意“我喜欢结识新朋友”的人就不太可能也同意“我喜欢修理东西”。在这里，因子分析的目的在于发现哪些问题对应于一个潜在的想法，并了解这些潜在想法是什么。
- en: You can see that most of the columns begin with a letter of the alphabet as
    well as a number. For now, you can ignore these labels and just keep in mind that
    each question is slightly different, but many of them are similar to each other.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，大多数列都以字母表中的一个字母以及一个数字开头。目前，你可以忽略这些标签，只需记住每个问题都有细微的差别，但其中许多是相似的。
- en: We are ready to begin our latent variable model. In this case, we will be performing
    factor analysis. Factor analysis is a powerful and very common method that can
    perform the type of latent variable analysis we discussed earlier. Factor analysis
    assumes that there are certain latent factors that govern a dataset, then shows
    us what those factors are and how they relate to our data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好开始我们的潜在变量模型。在这种情况下，我们将执行因子分析。因子分析是一种强大且非常常见的方法，可以执行我们之前讨论过的潜在变量分析。因子分析假设存在某些潜在因子控制数据集，然后向我们展示这些因子是什么以及它们如何与我们的数据相关。
- en: To begin our factor analysis, we will need to specify how many factors we are
    looking for. There are several methods for deciding the number of factors we should
    seek. For now, we will start by looking at five factors since this data is called
    Big 5, and then we will check later whether another number of factors is better.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的因子分析，我们需要指定我们要找多少个因子。有几种方法可以决定我们应该寻找多少个因子。目前，我们将从查看五个因子开始，因为这项数据被称为大五因子，然后我们稍后会检查是否其他数量的因子更好。
- en: 'We will need to create a correlation matrix for our new data. A correlation
    matrix is a matrix where the `i-j` entry is the correlation between the variable
    stored in column `i` and the variable stored in column `j`. It is similar to the
    covariance matrices we discussed in *Chapter 4*, *Dimension Reduction*. You can
    create a correlation matrix for this data as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们新的数据创建一个相关矩阵。相关矩阵是一个矩阵，其中`i-j`项是存储在列`i`中的变量和存储在列`j`中的变量之间的相关系数。这与我们在*第4章*，*降维*中讨论的协方差矩阵类似。你可以按照以下方式创建这个数据的相关矩阵：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, the factor analysis itself is quite simple. We can perform it by using
    the `fa` command, which is part of the `psych` R package:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因子分析本身相当简单。我们可以通过使用`fa`命令来完成它，这是`psych` R包的一部分：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will notice several arguments in this command. First, we specify `r=big_cor`.
    In this case, the authors of R's `psych` package decided to use a lowercase `r`
    to refer to the covariance matrix used for the factor analysis. The next argument
    is `nfactors=5`. This specifies the number of factors we will seek in our factor
    analysis. We have chosen five factors this time, but we will look at using more
    or fewer later.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个命令中有几个参数。首先，我们指定`r=big_cor`。在这种情况下，R的`psych`包的作者决定使用小写`r`来指代因子分析中使用的协方差矩阵。下一个参数是`nfactors=5`。这指定了我们在因子分析中要寻找的因子数量。这次我们选择了五个因子，但稍后我们会看看使用更多或更少的因子。
- en: The final two arguments are less important to our purposes here. The first says
    `rotate="oblimin"`. Factor analysis is doing what is called a rotation of our
    data behind the scenes before presenting its result to us. There are many techniques
    that can be used to accomplish this behind-the-scenes rotation, and `oblimin`
    is the default that has been chosen by the authors of the `fa` function. Feel
    free to experiment with other rotation methods, but they usually deliver substantially
    similar results. The last argument, just like the rotation argument, specifies
    a method that is used behind the scenes. Here, `fm` stands for factoring method
    and `pa` stands for principal. You can experiment with other factoring methods
    as well, but once again, they should deliver substantially similar results.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个参数对我们这里的目的是不太重要的。第一个参数说`rotate="oblimin"`。因子分析在向我们展示结果之前，在幕后对我们的数据进行旋转，这就是所谓的旋转。有许多技术可以用来完成这种幕后旋转，而`oblimin`是`fa`函数的作者选择作为默认的旋转方法。你可以自由地尝试其他旋转方法，但它们通常会产生实质上相似的结果。最后一个参数，就像旋转参数一样，指定了一个在幕后使用的方法。在这里，`fm`代表因子分解方法，`pa`代表主成分。你也可以尝试其他因子分解方法，但再次强调，它们应该会产生实质上相似的结果。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can use the `?` command in R to look up the documentation related to any
    other command. In this case, if you are curious about the `fa` command that we
    have just used, you can run `?fa` to load the documentation from your R console.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用R中的`?`命令查找与任何其他命令相关的文档。在这种情况下，如果你对我们刚刚使用的`fa`命令感到好奇，你可以运行`?fa`来从你的R控制台加载文档。
- en: 'Now, we can look at the output of our factor analysis:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看我们的因子分析输出：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.8: Section of the output'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8：输出的一部分'
- en: '](img/C12628_05_08.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C12628_05_08.jpg)'
- en: 'Figure 5.8: Section of the output'
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.8：输出的一部分
- en: When we do this, the majority of the output is a DataFrame with 240 rows labeled
    `Standardized loadings`. Each of the rows of this data frame corresponds to a
    column of our original data frame, such as `N1`. Remember that these are the questions
    on the personality profile test that is the source of our data. The first five
    columns of this data frame are labeled `PA1` through `PA5`. These correspond to
    each of the five factors we are looking for. The number for a particular personality
    question and a particular factor is called a loading. So, for example, we have
    the entry 0.54 in our data frame, corresponding to personality question `N1`,
    and factor `PA1`. We say that question `N1` has loading 0.54 on factor `PA1`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，大部分输出是一个包含240行，标签为`Standardized loadings`的DataFrame。这个数据框的每一行对应于我们原始数据框中的一列，例如`N1`。请记住，这些是我们数据来源的个性测试问题。这个数据框的前五行标签为`PA1`至`PA5`。这些对应于我们要找的五个因素。特定个性问题和特定因素的数量称为负载。例如，我们在数据框中有0.54的条目，对应于个性问题`N1`和因素`PA1`。我们说问题`N1`在因素`PA1`上的负载为0.54。
- en: '`We can interpret loadings as contributors to an overall score. To get the
    final score, you can multiply each particular loading by the survey respondent''s
    answers to each question, and sum up the results. In equation form, we can write
    this as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将负载解释为对总分有贡献的因素。为了得到最终分数，你可以将每个特定负载乘以调查受访者对每个问题的回答，并将结果相加。用方程式表示，我们可以写成以下形式：
- en: Respondent 1's Factor 1 score =
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 受访者1的因素1得分 =
- en: (Factor 1 loading on Question 1) * (Respondent 1's answer to question 1) +
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: （问题1上的因素1负载）*（受访者1对问题1的回答）+
- en: (Factor 1 loading on Question 2) * (Respondent 1's answer to question 2) +
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: （问题2上的因素1负载）*（受访者1对问题2的回答）+
- en: '....'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: (Factor 1 loading on Question 240) * (Respondent 1's answer to question 240)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: （问题240上的因素1负载）*（受访者1对问题240的回答）
- en: So, if a factor 1 loading for a particular question is high, then the respondent's
    answer to that question will have a large contribution to the total factor 1 score.
    If a loading is low, then the answer to that question doesn't contribute as much
    to the factor 1 score, or in other words it doesn't matter as much for factor
    1\. This means that each loading is a measurement of how much each particular
    question matters in the measurement of a factor.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个特定问题的因素1负载很高，那么受访者对该问题的回答将对总因素1得分有较大的贡献。如果负载较低，那么该问题的回答对因素1得分的贡献就不那么大，换句话说，它对因素1的影响就不那么重要。这意味着每个负载都是衡量每个特定问题在因素测量中的重要程度的度量。
- en: Each factor has 240 total loadings – one for each question in the personality
    survey. If you look at the loading matrix, you can see that many questions have
    a large loading on one factor, and small loadings (close to zero) on all other
    factors. Researchers frequently attempt to hypothesize an interpretation for each
    factor based on which questions have the highest loadings for each factor.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个因素都有240个总负载——对应于个性调查中的每个问题。如果你查看负载矩阵，你可以看到许多问题在一个因素上有很大的负载，而在所有其他因素上的负载都很小（接近零）。研究人员经常试图根据每个因素的最高负载问题来假设每个因素的解释。
- en: In our case, we can see that the first factor, called `PA1`, has a high loading
    (0.54) for the first question (labeled `N1`). It also has a relatively high loading
    (0.45) for the sixth question (`N6`), and a high loading (0.62) for the eleventh
    question (`N11`). It is easy to see a pattern here – the questions labeled `N`
    tend to have a high loading for this first factor. It turns out that these `N`
    questions on the original test were all meant to measure something psychologists
    call "neuroticism." Neuroticism is a fundamental personality trait that leads
    people to have strong negative reactions to difficulties, among other things.
    The `N` questions in the survey are all different, but each is intended to measure
    this personality trait. What we have found in our factor analysis is that this
    first factor tends to have high loadings for these neuroticism questions – so
    we would be justified in calling this factor a "neuroticism factor."
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们可以看到第一个因子，称为`PA1`，对第一个问题（标记为`N1`）有较高的负荷（0.54）。它还对第六个问题（`N6`）有相对较高的负荷（0.45），以及第十一题（`N11`）有较高的负荷（0.62）。在这里很容易看出一个模式——标记为`N`的问题往往对这个第一个因子有较高的负荷。结果证明，原始测试上的这些`N`问题都是为了衡量心理学家所说的“神经质”。神经质是一种基本的人格特质，使人们在面对困难时产生强烈的负面反应。调查中的`N`问题各不相同，但每个问题都是旨在衡量这种人格特质。我们在因子分析中发现，这个第一个因子往往对神经质问题有较高的负荷——因此我们可以称这个因子为“神经质因子”。
- en: 'We can see similar patterns in the other loadings:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在其他负荷中看到类似的模式：
- en: Factor 2 seems to have high loadings for "A" questions, which measure agreeableness.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因素2似乎对“A”问题有较高的负荷，这些问题是用来衡量宜人性的。
- en: Factor 3 seems to have high loadings for "E" questions, which measure extroversion.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因素3似乎对“E”问题有较高的负荷，这些问题是用来衡量外向性的。
- en: Factor 4 seems to have high loadings for "C" questions, which measure conscientiousness.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因素4似乎对“C”问题有较高的负荷，这些问题是用来衡量尽责性的。
- en: Factor 5 seems to have high loadings for "O" questions, which measure openness.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因素5似乎对“O”问题有较高的负荷，这些问题是用来衡量开放性的。
- en: These labels correspond to the "Big 5" theory of personality, which states that
    these five personality traits are the most important and most fundamental aspects
    of a person's personality. In this case, our five-factor analysis has yielded
    patterns of factor loadings that match the pre-existing labels in our dataset.
    However, we do not need labeled questions in order to learn from factor analysis.
    If we had obtained data with unlabeled questions, we could still run factor analysis,
    and still find patterns in the loadings of particular questions with particular
    factors. After finding those patterns, we would have to look closely at the questions
    that had high loadings on the same factors, and try to find what those questions
    have in common.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签对应于“大五”人格理论，该理论认为这五种人格特质是人格最重要的最基本方面。在这种情况下，我们的五因素分析产生了与数据集中预先存在的标签相匹配的因子负荷模式。然而，我们不需要标记的问题来从因子分析中学习。如果我们获得了未标记的问题数据，我们仍然可以运行因子分析，并仍然可以在特定问题的特定因子负荷中找到模式。在找到这些模式后，我们必须仔细查看在相同因子上有高负荷的问题，并试图找出这些问题的共同之处。
- en: Linear Algebra behind Factor Analysis
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 因子分析背后的线性代数
- en: Factor analysis is a powerful and flexible method that can be used in a variety
    of ways. In the following exercise, we will change some of the details of the
    factor analysis commands we have used in order to get a better sense of how factor
    analysis works.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因子分析是一种强大且灵活的方法，可以用多种方式使用。在以下练习中，我们将更改我们使用的因子分析命令的一些细节，以便更好地了解因子分析是如何工作的。
- en: 'Please note: the following exercise builds on the previous factor analysis
    code. You will have to run the previously highlighted code, especially `big_cor
    <- cor(big5)`, in order to successfully run the code in the following exercise.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：以下练习基于之前的因子分析代码。您必须运行之前突出显示的代码，特别是`big_cor <- cor(big5)`，才能成功运行以下练习中的代码。
- en: 'Exercise 36: More Exploration with Factor Analysis'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习36：使用因子分析的进一步探索
- en: 'In this exercise, we will explore factor analysis in detail:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将详细探讨因子分析：
- en: 'We can change several of the arguments in our `fa` function to obtain a different
    result. Remember that last time we ran the following code to create our solution:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以改变`fa`函数中的几个参数以获得不同的结果。记住上次我们运行以下代码来创建我们的解决方案：
- en: '[PRE42]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This time, we can change some of the parameters of the `fa` function, as follows:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们可以更改`fa`函数的一些参数，如下所示：
- en: '[PRE43]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this case, we have changed the rotation method to `varimax` and the factoring
    method to `minres`. These are changes to the behind-the-scenes methods used by
    the function. Most importantly for us, we have changed the number of factors (`nfactors`)
    to 3 rather than 5\. Examine the factor loadings in this model:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.9: Section of the output](img/C12628_05_10.jpg)'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.9: Section of the output'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You can try to find patterns in these loadings as well. If you find that there
    is a striking pattern of loadings for three or four or some other number of loadings,
    you may even have a new theory of personality psychology on your hands.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Determine the number of factors to use in factor analysis. A natural question
    to ask at this point is: how should we go about choosing the number of factors
    we look for? The simplest answer is that we can use another command in R''s `psych`
    package, called `fa.parallel`. We can run this command with our data as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Again, we have made choices about the behind-the-scenes behavior of the function.
    You can experiment with different choices for the `fm` and `fa` arguments, but
    you should see substantially similar results each time.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'One of the outputs of the `fa.parallel` command is the following scree plot:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.10: Parallel analysis scree plot'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C12628_05_11.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Parallel analysis scree plot'
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We discussed scree plots in *Chapter 4*, *Dimension Reduction*. The y axis,
    labeled **eigen values of principal factors**, shows a measurement of how important
    each factor is in explaining the variance of our model. In most factor analyses,
    the first several factors have relatively high eigenvalues, and then there is
    a sharp drop off in eigenvalues and a long plateau. The sharp drop off and long
    plateau together from an image that looks like an elbow. Common practice in factor
    analysis is to choose a number of factors that are close to the elbow created
    by this pattern. Psychologists have collectively chosen five as the number of
    factors that is commonly used for personality inventories. You can examine this
    scree plot to see whether you agree that that is the right number to use, and
    feel free to try factor analysis with different numbers of factors.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The final important outcome of the exercise we have just performed is the scree
    plot.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that factor analysis seems to have some things in common
    with principal component analysis. In particular, both rely on scree plots that
    plot eigenvalues as a way to measure the importance of different vectors.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'A full comparison between factor analysis and principal component analysis
    is beyond the scope of this book. Suffice it to say that they have similar linear
    algebraic foundations: both are designed to create approximations of covariance
    matrices, but each accomplishes this in a slightly different way. The factors
    we have found in factor analysis are analogous to the principal components that
    we found in principal component analysis. You are encouraged to try both factor
    analysis and principal component analysis on the same dataset, and to compare
    the results. The results are usually substantially similar, though not identical.
    In most real-world applications, either approach can be used – the specific method
    you use will depend on your own preference and your judgment of which approach
    best fits the problem at hand.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中对因子分析和主成分分析之间的全面比较超出了本书的范围。只需说明的是，它们具有相似的线性代数基础：两者都是为了创建协方差矩阵的近似，但每种方法实现这一点的途径略有不同。我们在因子分析中找到的因子与我们在主成分分析中找到的主成分类似。我们鼓励您尝试在相同的数据集上使用因子分析和主成分分析，并比较结果。结果通常非常相似，但并非完全相同。在大多数实际应用中，可以使用任何一种方法——您使用的具体方法将取决于您自己的偏好以及您对哪种方法最适合当前问题的判断。
- en: 'Activity 13: Performing Factor Analysis'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 13：执行因子分析
- en: In this activity, we will use factor analysis on a new dataset. You can find
    the dataset at [https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson05/Activity13](https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson05/Activity13).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用因子分析对新的数据集进行分析。您可以在[https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson05/Activity13](https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson05/Activity13)找到数据集。
- en: Note
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This dataset is taken from the UCI Machine Learning Repository. You can find
    the dataset at [http://archive.ics.uci.edu/ml/machine-learning-databases/00484/tripadvisor_review.csv](http://archive.ics.uci.edu/ml/machine-learning-databases/00484/tripadvisor_review.csv).
    We have downloaded the file and saved it at [https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson05/Activity13/factor.csv](https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson05/Activity13/factor.csv).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集来自 UCI 机器学习仓库。您可以在[http://archive.ics.uci.edu/ml/machine-learning-databases/00484/tripadvisor_review.csv](http://archive.ics.uci.edu/ml/machine-learning-databases/00484/tripadvisor_review.csv)找到数据集。我们已经下载了文件并将其保存到[https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson05/Activity13/factor.csv](https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson05/Activity13/factor.csv)。
- en: This dataset was compiled by Renjith, Sreekumar, and Jathavedan and is available
    on the UCI Machine Learning Repository. This dataset contains information about
    reviews that individuals wrote of tourist destinations. Each row corresponds to
    a particular unique user, for a total of 980 users. The columns correspond to
    categories of tourist sites. For example, the second column records each user's
    average rating of art galleries, and the third column records each user's average
    rating of dance clubs. There are 10 total categories of tourist sites. You can
    find the documentation of what each column records at [http://archive.ics.uci.edu/ml/datasets/Travel+Reviews](http://archive.ics.uci.edu/ml/datasets/Travel+Reviews).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集由 Renjith、Sreekumar 和 Jathavedan 编制，可在 UCI 机器学习仓库中找到。此数据集包含有关个人对旅游目的地所写评论的信息。每一行对应一个特定的唯一用户，总共有
    980 个用户。列对应旅游景点的类别。例如，第二列记录每个用户的艺术画廊平均评分，第三列记录每个用户的舞厅平均评分。共有 10 个旅游景点类别。您可以在[http://archive.ics.uci.edu/ml/datasets/Travel+Reviews](http://archive.ics.uci.edu/ml/datasets/Travel+Reviews)找到关于每列记录的文档。
- en: 'Through factor analysis, we will seek to determine the relationships between
    the user ratings of different categories. For example, it could be that user ratings
    of juice bars (column 4) and restaurants (column 5) are similar because both are
    determined by the same latent factor – the user''s interest in food. Factor analysis
    will attempt to find these latent factors that govern the users'' ratings. We
    can follow these steps to conduct our factor analysis:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过因子分析，我们将寻求确定不同类别用户评分之间的关系。例如，果汁吧（第 4 列）和餐厅（第 5 列）的用户评分可能相似，因为它们都由相同的潜在因素决定——用户对食物的兴趣。因子分析将尝试找到这些控制用户评分的潜在因素。我们可以遵循以下步骤进行因子分析：
- en: Download the data and read it into R.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载数据并将其读入 R。
- en: Load the `psych` package.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 `psych` 包。
- en: Select the subset of the columns that record the user ratings.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择记录用户评分的列子集。
- en: Create a correlation matrix for the data.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为数据创建一个相关矩阵。
- en: Determine the number of factors that should be used.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定应使用的因子数量。
- en: Perform factor analysis using the `fa` command.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fa`命令进行因子分析。
- en: Examine and interpret the results of the factor analysis.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查并解释因子分析的结果。
- en: 'The output should be similar to the following:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '![Figure 5.11: Expected outcome of factor analysis'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.11：因子分析预期结果'
- en: '](img/C12628_05_12.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C12628_05_12.jpg]'
- en: 'Figure 5.11: Expected outcome of factor analysis'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.11：因子分析预期结果
- en: Note
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 231.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第231页找到。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered topics related to data comparisons. We started by
    discussing the idea of a data fingerprint. In order to illustrate a data fingerprint,
    we introduced a hash function that can take any string and convert it to a number
    in a fixed range. This kind of hash function is useful because it enables us to
    ensure that data has the right identity – just like a fingerprint in real life.
    After introducing hash functions, we talked about the need for data signatures.
    A data signature or analytic signature is useful because it enables us to see
    whether two datasets are approximate matches – fingerprints require exact matches.
    We illustrated the use of analytic signatures with image data. We concluded the
    chapter by covering latent variable models. The latent variable model we discussed
    was factor analysis. We discussed an application of factor analysis that uses
    psychological survey data to determine differences between people's personalities.
    In the next chapter, we will discuss anomaly detection, which will enable us to
    find observations that do not fit with the rest of a dataset.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与数据比较相关的话题。我们首先讨论了数据指纹的概念。为了说明数据指纹，我们引入了一个可以将任何字符串转换为固定范围内数字的哈希函数。这种哈希函数很有用，因为它使我们能够确保数据具有正确的身份——就像现实生活中的指纹一样。在介绍哈希函数之后，我们讨论了数据签名的重要性。数据签名或分析签名很有用，因为它使我们能够看到两个数据集是否是近似匹配的——指纹需要精确匹配。我们通过图像数据说明了分析签名的作用。我们通过介绍潜在变量模型来结束本章。我们讨论的潜在变量模型是因子分析。我们讨论了因子分析的一个应用，该应用使用心理调查数据来确定人们性格之间的差异。在下一章中，我们将讨论异常检测，这将使我们能够找到与数据集其他部分不匹配的观测值。
