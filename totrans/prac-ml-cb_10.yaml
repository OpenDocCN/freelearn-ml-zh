- en: Chapter 10. Neural Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling S&P 500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring the unemployment rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Neural networks**: A neural network is a sorted triple ![Introduction](img/image_10_001.jpg)
    where ![Introduction](img/image_10_002.jpg) is the set of a neuron, and ![Introduction](img/image_10_003.jpg)
    is a set ![Introduction](img/image_10_004.jpg) whose elements are called connections
    between neuron ![Introduction](img/image_10_005.jpg) and neuron ![Introduction](img/image_10_006.jpg)The
    function ![Introduction](img/image_10_007.jpg) defines the weights, where ![Introduction](img/image_10_008.jpg)
    is the weight of the connection between neuron ![Introduction](img/image_10_009.jpg)
    and neuron ![Introduction](img/image_10_010.jpg). Data is transferred between
    neurons via connections, with the connecting weight being either excitatory or
    inhibitory.'
  prefs: []
  type: TYPE_NORMAL
- en: Modelling SP 500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The value of the stocks of the 500 largest corporations by market capitalization
    listed on the New York Stock Exchange or Nasdaq Composite is measured by the S&P
    500\. Standard & Poor's provides a quick look at the movement of the stock market
    and economy on the basis of stock prices. The S&P 500 index is the most popular
    measure used by the financial media and professionals. The S&P 500 index is calculated
    by taking the sum of the adjusted market capitalization of all S&P 500 stocks
    and then dividing it with an index divisor developed by Standard & Poor's. The
    divisor is adjusted when there are stock splits, special dividends, or spinoffs
    that could affect the value of the index. The divisor ensures that these non-economic
    factors do not affect the index.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to model the S&P 500 index using neural networks, we shall be using
    a dataset collected from the `GSPC` dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dataset to be used is the `GSPC` daily closing stock value between January
    1, 2009 and January 1, 2014\. This dataset is freely available on [https://www.yahoo.com/](https://www.yahoo.com/),
    from which we shall be downloading the data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, the following packages need to be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's download the data. We will begin by marking the start and the end dates
    for the desired time period.
  prefs: []
  type: TYPE_NORMAL
- en: The `as.Date()` function is used to convert the character representation and
    objects of the `Date` class, which represents calendar dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start date for the dataset is stored in `startDate`, which represents a character
    vector representation of the calendar date. The format for this representation
    is YYYY-MM-DD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The end date for the dataset is stored in `endDate`, which represents the character
    vector representation of the calendar date. The format for this representation
    is YYYY-MM-DD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading the data using the `getSymbols()` function: The function loads data
    from multiple sources, either local or remote. `GSPC` is the character vector
    that specifies the name of the symbol to be loaded. `src = yahoo` specifies the
    sourcing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Step 2 - exploring data](img/image_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - calculating the indicators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calculating the relative strength index: This is a ratio between the recent
    upward price movements and the absolute price movement. The `RSI()` function is
    used to calculate the **Relative Strength Index**. The `GSPC` data frame is used
    as a price series. `n = 3` represents the number of periods for moving averages.
    The result is then stored in the `relativeStrengthIndex3` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of the change in prices: The `summary()` function is
    used for this. The function provides a range of descriptive statistics to produce
    result summaries of the `relativeStrengthIndex3` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `EMA()` function uses the `GSPC` symbol as a price series. `n = 5` represents
    the time period to average over. The result is then stored in the `exponentialMovingAverage5`
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `exponentialMovingAverage5` data frame: The `head()` function
    returns the first part of the `exponentialMovingAverage5` data frame. The `exponentialMovingAverage5`
    data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exploring the summary of the change in prices. For this, the `summary()` function
    is used. This function provides a range of descriptive statistics to produce result
    summaries of the `exponentialMovingAverage5` data frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the difference between the exponential opening price for `GSPC`
    and `exponentialMovingAverage5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s print the `exponentialMovingAverageDiff` data frame. The `head()`
    function returns the first part of the `exponentialMovingAverageDiff` data frame.
    The `exponentialMovingAverageDiff` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of the change in prices: For this, the `summary()` function
    is used. This function provides a range of descriptive statistics to produce result
    summaries of the `exponentialMovingAverageDiff` data frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now compare the fast-moving average of a `GSPC` series with a slow-moving
    average for the `GSPC` series. To do this, `GSPC` is passed as the price matrix.
    `fast = 12` represents periods for the fast-moving average, `slow = 26` represents
    periods for the slow-moving average, and `signal = 9` represents the signal for
    the moving average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `MACD` data frame: The `tail()` function returns the last part
    of the `MACD` data frame. The `MACD` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of the change in prices with the `summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will grab the signal line to use as an indicator. The result is stored
    in the `MACDsignal` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the **Bollinger Bands**: Theyare range-bound indicators that calculate
    the standard deviation from the moving average. Bollinger Bands operate under
    the logic that a currency pair''s price is most likely to gravitate towards its
    average; thus when it strays too far, say two standard deviations away, it will
    fall back to its moving average. The `BBands()` function is used to calculate
    Bollinger Bands. `GSPC` is passed as an object and `n=20` indicates the number
    of periods for the moving average. `sd=2` indicates two standard deviations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s print the `BollingerBands` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of the change in prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s grab the signal line from `BollingerBands` to use as an indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `PercentageChngpctB` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of this change in `PercentageChngpctB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding the difference between the closing and opening prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `price` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Combining the `relativeStrengthIndex3`, `expMvAvg5Cross`, `MACDsignal`, and
    `PercentageChngpctB`, `Price` data frames: the result is then stored in the `DataSet` data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the internal structure of the `DataSet` data frame: The `str()` function
    displays the internal structure of the data frame. The `DataSet` is passed as
    an R object to the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculating the indicators, creating the dataset, and removing the points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `DataSet` data frame: The `dim()` function
    returns the dimension of the `DataSet` frame. The `DataSet` data frame is passed
    as an input parameter. The result clearly states that there are 1,176 rows of
    data and 5 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Naming the columns: The `c()` function is used to combine the arguments into
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimensions of the `DataSet` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - calculating the indicators](img/image_10_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - preparing data for model building
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normalizing the dataset to be bound between 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the function to normalize the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `NormalizedData` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing data for model building](img/image_10_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Building the training dataset: Data elements from `1:816` in the `NormalizedData`
    data frame will be used as the training dataset. The training dataset shall be
    stored in `TrainingSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimension of the `TrainingSet` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing data for model building](img/image_10_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of the change in `TrainingSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing data for model building](img/image_10_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Building the testing dataset: Data elements from `817:1225` in the `NormalizedData`
    data frame will be used as the training dataset. This testing dataset shall be
    stored in `TestSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the dimension of the `TrainingSet` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing data for model building](img/image_10_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exploring the summary of the change in `TestSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - preparing data for model building](img/image_10_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - building the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building the neural network: The `neuralnet()` function trains neural networks
    using a back-propagation algorithm without weight backtrackings. `Price~RSI3+EMAcross+MACDsignal+BollingerB`
    is a description of the model to be fitted. `data=TrainingSet` is the data frame
    containing the variables specified in the formula. `hidden=c(3,3)` specifies the
    number of hidden neurons (vertices) in each layer. `learningrate=.001` signifies
    the learning rate used by the back-propagation algorithm. `algorithm="backprop"`
    refers to the back propagation algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the neural network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model](img/image_10_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Measuring the unemployment rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unemployment rate is defined as the percentage of the total labor force
    that is unemployed, but actively seeking employment and willing to work. As defined
    by the **International Labor Organization **(**ILO**), an unemployed person is
    someone who is actively looking for work but does not have a job. The unemployment
    rate is a measure of the number of people who are both jobless *and *looking for
    a job.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to perform a measurement of the unemployment rate using neural networks,
    we shall be using a dataset collected on the unemployment rate in Wisconsin.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this, we will be using a CSV dataset titled `FRED-WIUR.csv`. There are
    448 rows of data. There are two numeric variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This dataset shows the unemployment rate in Wisconsin between January 1, 1976
    and April 1, 2013.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, the following packages need to be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the data and understand the relationships among the variables.
    We''ll begin by importing the CSV data file named `FRED-WIUR.csv`. We will be
    saving the data to the `ud` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `ud` data frame: The `tail()` function returns the last part of
    the `ud` data frame. The `ud` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_10_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Naming the columns: The `c()` function is used to combine the arguments into
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `as.Date()` function is used to convert the character representation and
    objects of the `Date` class, which represents calendar dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of unemployment data: For this, the `summary()` function
    is used. The function provides a range of descriptive statistics to produce result
    summaries of the `ud` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_10_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s create base data from rows 1 to 436:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of the base unemployment data. For this, the `summary()`
    function is used. The function provides a range of descriptive statistics to produce
    result summaries of the `ud.b` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_10_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s create the test data from rows 437 to 448:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the summary of the test unemployment data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_10_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the base time series data from 1976: `ts()` as a function creates
    time series objects. `ud.b$rate` represents the vector of observed time series
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of the `ud.ts` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_10_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating the test time series data: The `ts()` function creates time series
    objects. `ud.b$rate` represents the vector of observed time series values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the value of the `ud.ts` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_10_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the base time series data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_10_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the test time series data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 - exploring data](img/image_10_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - preparing and verifying the models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calculating the mean of the base time series dataset. The `meanf()` function
    returns forecasts and prediction intervals for an **i.i.d** model applied on the
    `ud.ts` dataset. `12` indicates the period for forecasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Forecasting and predicting the intervals for a random walk with a drift base
    time series. The `rwf()` function forecasts and returns for a random walk performed
    on the time series `ud.ts`. The parameter `12` indicates the period for forecasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Forecasting and predicting intervals for a random walk from an ARIMA(0,0,0)(0,1,0)m
    base time series: The `snaive()` function forecasts and returns results for an
    ARIMA(0,0,0)(0,1,0)m performed on the time series `ud.ts`. The parameter `12`
    indicates the period for forecasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Forecasting and predicting the drift for the base time series. The `rwf()`
    function forecasts and returns for a random walk performed on the time series
    `ud.ts`. The parameter `12` indicates the period for forecasting. `drift=T` is
    a logical flag that fits a random walk with the drift model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will prepare linear fit models for the base time series data for trend.
    The `tslm()` function fits linear models to the `ud.ts` time series. `ud.ts~trend`
    is the formula that indicates that the trend components have to be taken into
    consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Preparing the linear fit models for the base time series data for trend and
    seasonality: The `tslm()` function fits linear models to `ud.ts` time series.
    `ud.ts~trend+season` is the formula that indicates that the trend and seasonality
    components have to be taken into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`residuals()` is a generic function that extracts model residuals from object
    `m1` after returned after fitting models for the base time series data for trend.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the residual model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s look at how to estimate the `autocovariance` function. `residual_1`
    is the univariate numeric time series object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`residuals()` is a generic function that extracts model residuals from object
    `m2` after returned after fitting models for base time series data for trend.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Ploting the residual model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Durbin-Watson test is performed to find out if the residuals from a linear
    regression or multiple regressions are independent. The hypotheses usually considered
    in the Durbin-Watson test are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_045.jpg)![Step
    3 - preparing and verifying the models](img/image_10_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The test statistics are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, ![Step 3 - preparing and verifying the models](img/image_10_048.jpg), ![Step
    3 - preparing and verifying the models](img/image_10_049.jpg)is the observed value
    of for individual ![Step 3 - preparing and verifying the models](img/image_10_050.jpg),
    and ![Step 3 - preparing and verifying the models](img/image_10_051.jpg) is the
    predicted value of for individual ![Step 3 - preparing and verifying the models](img/image_10_052.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of ![Step 3 - preparing and verifying the models](img/image_10_053.jpg)
    decreases as the serial correlations increase. The upper and lower critical values,
    ![Step 3 - preparing and verifying the models](img/image_10_054.jpg) and ![Step
    3 - preparing and verifying the models](img/image_10_055.jpg), have been tabulated
    for different values of ![Step 3 - preparing and verifying the models](img/image_10_056.jpg)--the
    number of explanatory variables and ![Step 3 - preparing and verifying the models](img/image_10_057.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: If ![Step 3 - preparing and verifying the models](img/image_10_058.jpg) reject
    ![Step 3 - preparing and verifying the models](img/image_10_059.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: If ![Step 3 - preparing and verifying the models](img/image_10_060.jpg) do not
    reject ![Step 3 - preparing and verifying the models](img/image_10_061.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: If ![Step 3 - preparing and verifying the models](img/image_10_062.jpg) the
    test is inconclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing the Durbin-Watson test on linear fit models for the base time series
    data for trend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Performing the Durbin-Watson test on linear fit models for the base time series
    data for trend and seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Decomposing the base data time series into period, seasonal, trend, and irregular
    components using LOESS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the decomposed base data time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Performing the exponential smoothing state space model for the base data time
    series. The `ets()` function returns the `ets` model on the `ud.ts` time series.
    `ZZZ - "Z"` signifies an automatic selection. The first letter denotes the error
    type, the second letter denotes the trend type, and the third letter denotes the
    season type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the exponential smoothing state space model for the base data time
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Returning the order of a univariate ARIMA for the base data time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Ploting the univariate ARIMA for the base data time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Building the feed-forward neural network model: The `nnetar()` function builds
    the feed-forward neural network with a single hidden layer and lagged inputs for
    forecasting the base data univariate time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the values of the feed-forward neural network model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the feed-forward neural network model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - preparing and verifying the models](img/image_10_069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - forecasting and testing the accuracy of the models built
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Testing the accuracy of the mean value of the base data time series with the
    test data time series. The `accuracy()` function returns the range of summary
    measures of the forecast accuracy. `ud.p.ts` is the test data time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the forecasted and predicted base data time series
    with a drift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the forecasted and predicted base data time series
    with an ARIMA(0,0,0)(0,1,0)m:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the drift of the base data time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining the results in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - forecasting and testing the accuracy of the models built](img/image_10_070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Forecasting the linear fit models for the base time series data for trend.
    `h=12` indicates the period of forecasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Forecasting the linear fit models for the base time series data for trend and
    seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Forecasting the decomposed base data time series into period, seasonal, trend,
    and irregular components using LOESS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Forecasting the exponential smoothing state space model for the base data time
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Forecasting the ordered univariate ARIMA for the base data time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Forecasting the feed-forward neural network model with a single hidden layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the forecasted linear fit models for the base time
    series data for trend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the forecasted linear fit models for the base time
    series data for trend and seasonality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the forecasted decomposed base data time series into
    period, seasonal, trend, and irregular components using LOESS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the forecasted exponential smoothing state space model
    for the base data time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the forecasted ordered univariate ARIMA for the base
    data time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the accuracy of the forecasted feed-forward neural network model with
    a single hidden layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining the results in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - forecasting and testing the accuracy of the models built](img/image_10_071.jpg)'
  prefs: []
  type: TYPE_IMG
