- en: Chapter 4. Panoramic Image Stitching Application Using Android Studio and NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Panorama is an interesting subject in application development. In OpenCV, the
    stitching module can easily create a panorama image from a sequence of images.
    One benefit of the stitching module is that the sequence of images don't have
    to be in order and can be in any direction. However, in the OpenCV Android SDK,
    the stitching module does not exist. Therefore, we must use the stitching module
    in the C++ interface. Luckily, Android provides the **Native Development Kit**
    (**NDK**) to support native development in C/C++. In this chapter, we will guide
    you through the steps to capture camera frames from Java and process the data
    in OpenCV C++ with the NDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to make a complete panorama stitching application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Java Native Interface (JNI) to use OpenCV C++ in Android Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the stitching module to create a panorama image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the concept of panorama
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A panorama image gives the viewer a much broader field of view than a normal
    image and allows them to fully experience a scene. By extending the range of panorama
    to 360 degrees, viewers can simulate turning their head around. A panorama image
    can be created by stitching a sequence of overlapping images.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows a demonstration of a panorama image captured with
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the concept of panorama](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A panorama image captured in an horizontal direction
  prefs: []
  type: TYPE_NORMAL
- en: In order to capture a panorama image, you must capture many images of the scene
    at different angles, as in the following figure. For example, you take your first
    picture at the left side of the room. Then, you move the phone straight to a new
    angle to start capturing. All the images will be stitched together to create a
    panorama image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the concept of panorama](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Illustration showing how you pan the phone to create a panorama image
  prefs: []
  type: TYPE_NORMAL
- en: Normally, a panorama application only supports capturing images in horizontal.
    With the stitching module in OpenCV, we can extend the height of an image by capturing
    more images in both directions. The following figure shows an image that can be
    captured by changing the camera view in a horizontal and vertical direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the concept of panorama](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A panorama image captured in both directions
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will implement a panorama application in Android using
    OpenCV 3.0.0\. The chapter contains two main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android section**: We will implement the user interface in Android Studio.
    In this chapter, we only implement the panorama capture activity with two buttons,
    **Capture** and **Save**. When the panorama is captured, we will save it to the
    phone''s internal storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenCV section**: We will show the process to integrate OpenCV to Android
    Studio with NDK/JNI and implement the code to create a panorama image from a sequence
    of images captured in the Android section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will show the process to create a user interface
    in Android Studio. If you want to review the OpenCV code, you can go to the *Integrating
    OpenCV into the Android Studio* section and come back to this later.
  prefs: []
  type: TYPE_NORMAL
- en: The Android section – an application user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you a basic user interface to capture and save
    the panorama to the internal storage. Basically, the user will see a fullscreen
    of the camera preview image. When the user presses the **Capture** button, the
    application will capture the current scene and put the captured image on an overlay
    layer above the current view. Therefore, the user knows what they have just captured
    and can change the phone position to capture the next image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the application when the user opens it and
    after the user captures an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Android section – an application user interface](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example of the user interface before and after a user captures an image
  prefs: []
  type: TYPE_NORMAL
- en: The setup activity layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create a new Android project with a blank activity in Android
    Studio. Then, we will edit the layout xml for MainActivity in `app/src/main/res/layout/activity_main.xml`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this layout xml file, we have two SurfaceViews—one for the camera preview
    and one for the overlay layer. We also have two buttons—one for capturing the
    image and one for saving the panorama image to the internal storage.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the camera frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will implement the process to capture camera frames and
    view it on a SurfaceView with the ID `surfaceView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the begin of the `MainActivity` class, we will create some objects to work
    with the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created two buttons and two `SurfaceViews` to interact
    with the user interface. We also create a Camera object, `mCam`, to open the camera.
    In our implementation, we will open the camera and get the video frame in the
    Android approach. OpenCV also provides some other approaches to open the camera.
    However, we found that they may not work well on all Android devices, so we prefer
    using the camera with Android approach. In this chapter, we only need the Camera
    object from the Android API. The advantage of this approach is that you can expect
    it to work on almost any Android device. The disadvantage is that you have to
    do some conversion from camera byte array to Android Bitmap to display on the
    UI and to OpenCV Mat to do the image processing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to experience OpenCV classes to interact with the camera, you may
    want to check [Chapter 7](part0058_split_000.html#1NA0K1-940925703e144daa867f510896bffb69
    "Chapter 7. Gyroscopic Video Stabilization"), *Gyroscopic Video Stabilization*,
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onCreate` function, we set up these objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we initialize `isPreview` to false and assign `mSurfaceView` to `SurfaceView`
    in the layout. Then, we get the holder of `mSurfaceView` and add a callback to
    it. The variable `mSurfaceCallback` is an instance of `SurfaceHolder.Callback`
    that we will create later. We also assign `mSurfaceViewOnTop` to the other SurfaceView
    in the layout, since we want this SurfaceView to be an overlay layer on the camera
    view. We need to set the Z order to be true and set the holder format to `TRANSPARENT`.
    Finally, we set up the capture and save buttons, and set the corresponding `OnClickListener`.
    In the next part, we will work on displaying the camera frame on the `SurfaceView`.
    So we will just create a basic `OnClickListener` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the Camera API to get the camera frame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we said before, we will use the Android API to get the camera frame in Android.
    Currently, there are two versions of Camera API, `android.hardware.Camera` and
    `android.hardware.camera2`. We will use `android.hardware.Camera` because it supports
    most of the Android devices up to Android 4.4\. In Android 5.0 and later, this
    API is deprecated and replaced by camera2\. We can still use `android.hardware.Camera`
    on Android 5.0\. If you want to target Android 5.0, we recommend you to try camera2
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the camera, we need to add the following lines to `AndroidManifest.xml`
    to gain the permissions to the camera. Besides, we also request the permission
    to write to storage as we will save the panorama image to internal storage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to set the `mSurfaceView` to display the camera frame, so we will set
    up the camera parameters in the callback of `mSurfaceView`. We need to create
    the variable `mSurfaceCallback` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we call the `setPreviewDisplay` method in the `surfaceCreated`
    function to tell the camera to display the camera frame on `mSurfaceView`. After
    this, in the `surfaceChanged` function, we set the camera parameters, change the
    display orientation to 90 degrees and start the preview process. The function
    `getBestPreviewSize` is a function to get the preview size that has the biggest
    number of pixels. The `getBestPreviewSize` is simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add some code to open the camera in `onResume` and release
    the camera in `onPause`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, we can install and run the application on a real device. The
    following figure shows a screenshot of our application on a Nexus 5 running Android
    5.1.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Camera API to get the camera frame](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the application in Camera Preview mode on Nexus 5 running Android
    5.1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we don''t want the layout to rotate so we set the activity
    orientation to portrait mode. It''s optional. If you want to do this, you can
    simply change your activity in `AndroidManifest.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the Capture button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will show you how to implement the `OnClickListener` of
    the **Capture** button. When the user clicks on the **Capture** button, we want
    the application to take a picture of the current scene. With the Camera API, we
    can use the `takePicture` function to capture a picture. The benefit of this function
    is that the resolution of the output image is very high. For example, when our
    application runs on Nexus 5, even though the previewing size is 1920x1080, the
    resolution of the captured image is 3264x2448\. We change `captureOnClickListener`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `onClick` function, we check whether the camera is initialized and the
    flag `safeToTakePicture` is `true`. Then, we set the flag to `false` so that we
    don't take two pictures at the same time. The `takePicture` function of the Camera
    instance requires three parameters. The first and second parameters are shutter
    call back and raw data call back respectively. These functions may be called differently
    on different devices so we don't want to use them and set them to null. The last
    parameter is the callback that is called when the camera saves the picture in
    the JPEG format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, `onPictureTaken` provides a byte array of the captured image, so we would
    want to decode it to an instance of Bitmap. Because the camera sensor captured
    the image in landscape mode, we would want to apply a rotation matrix to obtain
    the image in the portrait mode. Then, we would want to save this image to pass
    a sequence of images to the OpenCV stitching module. Since this code needs the
    OpenCV library, we will implement this part later. After this, we will obtain
    the canvas of the overlay `SurfaceView` and try to draw the image on the screen.
    The following is a demonstration of the overlay layer on top of the previewing
    layer. Finally, we will start the preview process again and also set the `safeToTakePicture`
    flag to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the Capture button](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the application after the user captured an image on a Nexus
    5 running Android 5.1.1
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Save button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the **Save** button is fairly simple. We will assume that when the
    user clicks on the **Save** button, we will start a new thread to perform the
    image processing task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In `imageProcessingRunnable`, we would want to show a processing dialog at
    the start of the process and close the dialog when everything is completed. In
    order to accomplish this, we will first create an instance of `ProgressDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `imageProcessingRunnable` is implemented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will simply call `showProcessingDialog` to show the progressing dialog and
    call `closeProcessingDialog` to close the dialog. The steps in between are quite
    complex and requires lots of OpenCV functions, so we keep this part for a later
    section. The functions to show and close the progress dialog are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In `showProcessingDialog`, we will stop the camera preview to reduce unnecessary
    computation cost on the device, whereas in `closeProcessingDialog`, we start the
    camera preview again to allow the user to capture more panorama images. We must
    put these codes in `runOnUiThread` since these codes interact with the UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will show you how to implement the remaining parts
    of our application with OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating OpenCV into the Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you the steps to integrate OpenCV in the Android
    Studio with the Native Development Kit and use the OpenCV stitching module in
    C++ to create the final panorama image. We will also do some computations with
    OpenCV Android SDK Java to show how the interaction goes about between Java and
    C++ interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling OpenCV Android SDK to the Android Studio project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Officially, the OpenCV Android SDK is an Eclipse project, which means we can't
    simply use it in our Android Studio project. We need to convert the OpenCV Android
    SDK to an Android Studio project and import it as a module to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We assume that you have downloaded the latest OpenCV for Android from [http://opencv.org/downloads.html](http://opencv.org/downloads.html).
    At the time of writing, we now have OpenCV for Android 3.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: Let's extract the downloaded file to your favorite path, for example, `/Volumes/Data/OpenCV/OpenCV-android-sdk`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to open a new Android Studio window and select **Import project**
    (Eclipse ADT, Gradle, and so on). In the popup window, you should select the `java`
    folder at `OpenCV-android-sdk/sdk/java` and click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling OpenCV Android SDK to the Android Studio project](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Import project visualization
  prefs: []
  type: TYPE_NORMAL
- en: In the next window, we will choose a path to store the new OpenCV SDK project.
    In our case, we choose `/Volumes/Data/OpenCV/opencv-java` and click on **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling OpenCV Android SDK to the Android Studio project](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Select import destination visualization
  prefs: []
  type: TYPE_NORMAL
- en: In the last window, we will simply click on **Finish** and wait until Android
    Studio completes the Gradle build process. Basically, Gradle is the default build
    system of Android Studio. At this step, we want to make sure that the OpenCV SDK
    can be compiled successfully. One of the common errors is that you haven't downloaded
    the required Android SDK. The error message is very straightforward. You can follow
    the message to solve the problem. In our case, there is no problem as in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling OpenCV Android SDK to the Android Studio project](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Build competition visualization
  prefs: []
  type: TYPE_NORMAL
- en: At this time, we can close this project and open our Panorama project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Android Studio to work with OpenCV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use OpenCV in our project, we need to import the OpenCV Android
    SDK to our project. With this SDK, we can use the OpenCV Java API and perform
    image processing tasks easily. Moreover, we must make a further step to tell Android
    Studio to compile OpenCV C++ code to use OpenCV in the Native Development Kit
    (NDK). We will split this section into three subsections: Importing the Android
    SDK, Creating a Java-C++ interaction, and Compiling OpenCV C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing the OpenCV Android SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We assume that you have opened the Panorama project. We need to import the
    converted OpenCV Android SDK in the previous section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File** | **New** | **Import Module**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **New Module** window, we will select the source directory to the converted
    project. In our case, we will choose `/Volumes/Data/OpenCV/opencv-java`. Then,
    we''ll check the import checkbox, change the module name to `:opencv-java`, as
    shown in the following screenshot and click **Finish**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing the OpenCV Android SDK](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A new module window
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to modify `build.gradle` in the `app` folder to add one line
    to the `dependencies` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we must sync the project with the button **Sync Project with Gradle
    Files**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you only need the OpenCV Java Interface and don''t want to use OpenCV C++,
    you must copy the `libs` folder at `OpenCV-android-sdk/sdk/native/libs` to your
    `app/src/main` folder. Then, you must add the following `loadLibrary` code to
    your class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Java and C++ interaction with Java Native Interface (JNI)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start the compile process, we will create a class file named `NativePanorama.java`
    and add a method to the `NativePanorama` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `processPanorama` method will receive an array of long addresses of each
    image and a long address of an output image.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must rebuild the project in order to follow the ensuing steps. The detailed
    explanation is in the next paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `javah` command line to create a C++ header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `.cpp` file for the newly created header in the `jni` folder to implement
    the function in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may notice the keyword `native` before the `processPanorama` method. This
    means that we will use this method to interact between Java and C++ in our application.
    Therefore, we need to create some headers and source files to implement our C++
    code. We must follow **Java Native Interface** (**JNI**) to use C++ code, so the
    process may be a bit complex and out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the following parts, we will show you the steps to use OpenCV C++.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to understand JNI, you may want to take a look at the JNI documentation
    found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/7/docs/technotes/guides/jni/](http://docs.oracle.com/javase/7/docs/technotes/guides/jni/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, have a look at the JNI tips from API guides found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/training/articles/perf-jni.html](http://developer.android.com/training/articles/perf-jni.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will use the `javah` command in the terminal to create the corresponding
    C++ header for the `processPanorama` method. In order to do this, you need to
    open the terminal on your machine, then change the directory to the folder `app/src/main`
    in your Android application and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You only need to verify the package name and the name of the class file, `NativePanorama`.
    The command will not display anything on the terminal, as shown in the following
    figure. You may want to rebuild the project if you encounter the following error:
    **Error: Could not find class file for ''com.example.panorama.NativePanorama''**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Java and C++ interaction with Java Native Interface (JNI)](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The terminal after using the javah command
  prefs: []
  type: TYPE_NORMAL
- en: As the result of the `javah` command, we now have a folder named `jni` in our
    `app/src/main` folder with a file `com_example_panorama_NativePanorama.h`. This
    header contains a function to work with Java Interface. When `processPanorama`
    is called, this function will run in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a source file named `com_example_panorama_NativePanorama.cpp`
    in the `jni` folder. We recommend that you should copy the function declaration
    from the header file to the source file and add the parameter names as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The only thing left is that we need to compile OpenCV C++ SDK to use it in the
    preceding source file.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling OpenCV C++ with NDK/JNI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to use OpenCV in C++ code, we need to compile OpenCV C++ and use an
    `Android.mk` file as the make file to build and link our C++ file with OpenCV
    library. However, Android Studio doesn't support `Android.mk` out of the box.
    We need to do lots of things to make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will open the `local.properties` file and set `ndk.dir` to be your
    path to the Android NDK folder. In our case, the `local.properties` will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can get the Android NDK at: [https://developer.android.com/ndk/index.html](https://developer.android.com/ndk/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we open the `build.gradle` file in our app folder and add this line
    at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then, we need to add the following code between the `defaultConfig` tag and
    `buildType` tag to create a new Gradle task to build C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You may want to look at the following figure for a screenshot of our `build.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling OpenCV C++ with NDK/JNI](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of our build.gradle
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a file named `Application.mk` in the `jni` folder and put the
    following lines in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a file named `Android.mk` in the `jni` folder and set up
    this file as below to use OpenCV in our C++ code. You may need to change the `OPENCVROOT`
    variable to the location of OpenCV-android-sdk in your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding `Android.mk`, Android Studio will build OpenCV into `libopencv_java3.so`
    and build our C++ code into `libMyLib.so` in the folder `app/src/main/jniLibs`.
    We have to open our `MainActivity.java` and load this library to use in our application
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use OpenCV Android SDK Version 2.*, you should load `opencv_java` instead
    of `opencv_java3`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the OpenCV Java code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will show you OpenCV in Java side to prepare the data for
    the stitching module in the OpenCV C++ side.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a list to store all of the captured images when the user
    presses the **Capture** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `onPictureTaken` method of the `jpegCallback` variable, we want
    to convert the captured Bitmap into an OpenCV Mat and store in this `listImage`
    list. You need to add these lines before the drawing parts with Canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, when the user clicks the **Save** button, we would want to send the
    address of the images in `listImage` to the OpenCV C++ code to perform the stitching
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `imageProcessingRunnable`, we will add these codes after the `showProcessingDialog`
    function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we will create a long array to store all the native addresses
    of each Mat image. Then, we will pass this long array and the native address of
    a `Mat result`, to store the panorama image. The OpenCV C++ code will run to perform
    stitching with the stitching module. After this, we save the result into the external
    storage and make a simple toast to indicate to the user that the panorama is saved.
    Finally, we clear the `listImage` list to start a new section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the OpenCV C++ code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this moment, we want to implement the `processPanorama` in OpenCV C++. The
    implementation is really simple; we will only edit the `com_example_panorama_NativePanorama.cpp`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we converted the long array of image addresses into images
    and pushed into a vector called `imgVec`. We also resized the image for fast computation.
    The stitching module is really easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create an instance of `Stitcher`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Then, we use this stitcher to stitch our vector image of Mat. The panorama image
    will be saved into a resultant Mat.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of a panorama image processed with
    the default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the OpenCV C++ code](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A sample image captured in the corridor
  prefs: []
  type: TYPE_NORMAL
- en: Application showcase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we show some panorama images captured with our application.
    You can see that the application is capable of processing panorama images in both
    horizontal and vertical directions.
  prefs: []
  type: TYPE_NORMAL
- en: First, this is an image captured from the fifth floor of a building. We took
    this picture through a window glass so the light was dim. However, the panorama
    is good because there are many details so the feature matcher can do a great job.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application showcase](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A sample image captured by the application
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot is an image captured in the evening on a balcony. The
    region on the top-left corner of the panorama is bad since this only contains
    a blank wall and the sky. Therefore, there were too little features to compare
    between images. Hence, the final panorama is not perfect in this region.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application showcase](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A sample image captured by the application in the evening
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot was captured through a window. The lower half of the
    image is good. However, the sky still has some problems due to the lack of features,
    as in the previous image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application showcase](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Another sample image captured by the application in the evening
  prefs: []
  type: TYPE_NORMAL
- en: The following image was shot in a courtyard in front of the building in the
    afternoon. The lighting was good and there were many details, so the final panorama
    is perfect.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application showcase](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A sample image captured by the application in the afternoon
  prefs: []
  type: TYPE_NORMAL
- en: This image was taken at the same period with the previous image. However, this
    image was captured with a wide range of angles and the light was different at
    each shot. Therefore, the lighting in the final panorama is not consistent.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application showcase](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Another sample image captured by the application in the afternoon
  prefs: []
  type: TYPE_NORMAL
- en: Further improvement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show some improvements that you can consider while
    creating a fully featured panorama application.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can make a better user interface for the user to capture a panorama
    image. The current user interface doesn't show that the application can capture
    images in both directions. A suggestion is to use the motion sensors (accelerometer
    and gyroscope) in the Android API to obtain the rotation of the device and adjust
    the position of the overlay image.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Motion Sensors API documentation is available at [http://developer.android.com/guide/topics/sensors/sensors_motion.html](http://developer.android.com/guide/topics/sensors/sensors_motion.html).
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the current application resizes the captured image to decrease computation
    time. You may want to change some parameters of the Stitcher to have better performance.
    We suggest that you look at the documentation of the stitching module for more
    details. In our implementation, we will use the Stitcher class for simplification.
    However, there is a detailed sample in the OpenCV repository at `samples/cpp/stitching_detailed.cpp`,
    where they show many options to improve the stability and quality of the final
    panorama.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The detailed sample of using the stitching module is available at [https://github.com/Itseez/opencv/blob/master/samples/cpp/stitching_detailed.cpp](https://github.com/Itseez/opencv/blob/master/samples/cpp/stitching_detailed.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: Thirdly, you can change the logic of our application to perform real-time stitching.
    That means we make a stitching image whenever there are two captured images. Then,
    we show the result with the help of a 360-degree user interface so that the user
    can know which is the missing region, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed a complete panorama application in Android Studio where
    OpenCV 3 is used in both the Java interface and the C++ interface with the support
    of the Native Development Kit (NDK). The chapter also introduced us to how to
    use the Android Camera API with the OpenCV library. Also, the chapter illustrated
    some basic implementation with the OpenCV 3 stitching module to perform image
    stitching.
  prefs: []
  type: TYPE_NORMAL
