- en: Chapter 4. Panoramic Image Stitching Application Using Android Studio and NDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用Android Studio和NDK实现全景图像拼接应用程序
- en: Panorama is an interesting subject in application development. In OpenCV, the
    stitching module can easily create a panorama image from a sequence of images.
    One benefit of the stitching module is that the sequence of images don't have
    to be in order and can be in any direction. However, in the OpenCV Android SDK,
    the stitching module does not exist. Therefore, we must use the stitching module
    in the C++ interface. Luckily, Android provides the **Native Development Kit**
    (**NDK**) to support native development in C/C++. In this chapter, we will guide
    you through the steps to capture camera frames from Java and process the data
    in OpenCV C++ with the NDK.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 全景是应用开发中的一个有趣的主题。在OpenCV中，拼接模块可以轻松地从一系列图像中创建全景图像。拼接模块的一个好处是图像序列不必按顺序排列，可以是任何方向。然而，在OpenCV
    Android SDK中，拼接模块不存在。因此，我们必须在C++接口中使用拼接模块。幸运的是，Android提供了**原生开发工具包**（**NDK**）来支持C/C++的本地开发。在本章中，我们将指导您通过从Java捕获相机帧并在OpenCV
    C++中使用NDK处理数据的步骤。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: How to make a complete panorama stitching application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何制作一个完整的全景拼接应用程序
- en: How to use Java Native Interface (JNI) to use OpenCV C++ in Android Studio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Java本地接口（JNI）在Android Studio中使用OpenCV C++
- en: How to use the stitching module to create a panorama image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用拼接模块创建全景图像
- en: Introducing the concept of panorama
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍全景的概念
- en: A panorama image gives the viewer a much broader field of view than a normal
    image and allows them to fully experience a scene. By extending the range of panorama
    to 360 degrees, viewers can simulate turning their head around. A panorama image
    can be created by stitching a sequence of overlapping images.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 全景图像比普通图像提供了更广阔的视野，并允许他们完全体验场景。通过将全景范围扩展到360度，观众可以模拟转动他们的头部。全景图像可以通过拼接一系列重叠的图像来创建。
- en: The following figure shows a demonstration of a panorama image captured with
    our application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了使用我们的应用程序捕捉的全景图像的演示。
- en: '![Introducing the concept of panorama](img/00053.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![介绍全景的概念](img/00053.jpeg)'
- en: A panorama image captured in an horizontal direction
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在水平方向上捕捉的全景图像
- en: In order to capture a panorama image, you must capture many images of the scene
    at different angles, as in the following figure. For example, you take your first
    picture at the left side of the room. Then, you move the phone straight to a new
    angle to start capturing. All the images will be stitched together to create a
    panorama image.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕捉全景图像，您必须在场景的不同角度捕捉许多图像，如下面的图所示。例如，您在房间的左侧拍摄第一张照片。然后，您将手机直接移动到新的角度开始捕捉。所有图像将被拼接在一起以创建全景图像。
- en: '![Introducing the concept of panorama](img/00054.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![介绍全景的概念](img/00054.jpeg)'
- en: Illustration showing how you pan the phone to create a panorama image
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何平移手机以创建全景图像的插图
- en: Normally, a panorama application only supports capturing images in horizontal.
    With the stitching module in OpenCV, we can extend the height of an image by capturing
    more images in both directions. The following figure shows an image that can be
    captured by changing the camera view in a horizontal and vertical direction.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，全景应用程序仅支持水平方向上的图像捕捉。使用OpenCV的拼接模块，我们可以通过在两个方向上捕捉更多图像来扩展图像的高度。以下图显示了可以通过在水平和垂直方向上改变相机视图来捕捉的图像。
- en: '![Introducing the concept of panorama](img/00055.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![介绍全景的概念](img/00055.jpeg)'
- en: A panorama image captured in both directions
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个方向上捕捉的全景图像
- en: 'In this chapter, we will implement a panorama application in Android using
    OpenCV 3.0.0\. The chapter contains two main sections:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用OpenCV 3.0.0在Android中实现全景应用程序。本章包含两个主要部分：
- en: '**Android section**: We will implement the user interface in Android Studio.
    In this chapter, we only implement the panorama capture activity with two buttons,
    **Capture** and **Save**. When the panorama is captured, we will save it to the
    phone''s internal storage.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android部分**：我们将使用Android Studio实现用户界面。在本章中，我们只实现了带有两个按钮（**捕获**和**保存**）的全景捕获活动。当捕捉到全景时，我们将将其保存到手机的内部存储中。'
- en: '**OpenCV section**: We will show the process to integrate OpenCV to Android
    Studio with NDK/JNI and implement the code to create a panorama image from a sequence
    of images captured in the Android section.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenCV部分**：我们将展示如何将OpenCV集成到Android Studio中，使用NDK/JNI，并实现从Android部分捕获的一系列图像创建全景图像的代码。'
- en: In the following sections, we will show the process to create a user interface
    in Android Studio. If you want to review the OpenCV code, you can go to the *Integrating
    OpenCV into the Android Studio* section and come back to this later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将展示在Android Studio中创建用户界面的过程。如果您想回顾OpenCV代码，您可以前往*将OpenCV集成到Android
    Studio*部分，稍后再回来。
- en: The Android section – an application user interface
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓部分 - 应用程序用户界面
- en: In this section, we will show you a basic user interface to capture and save
    the panorama to the internal storage. Basically, the user will see a fullscreen
    of the camera preview image. When the user presses the **Capture** button, the
    application will capture the current scene and put the captured image on an overlay
    layer above the current view. Therefore, the user knows what they have just captured
    and can change the phone position to capture the next image.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示一个基本用户界面，用于捕获并将全景保存到内部存储。基本上，用户将看到相机预览图像的全屏。当用户按下**捕获**按钮时，应用程序将捕获当前场景并将捕获的图像放置在当前视图之上的叠加层上。因此，用户知道他们刚刚捕获了什么，并且可以改变手机位置以捕获下一张图像。
- en: 'The following is a screenshot of the application when the user opens it and
    after the user captures an image:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在用户打开应用程序后以及用户捕获图像时的应用程序截图：
- en: '![The Android section – an application user interface](img/00056.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![安卓部分 - 应用程序用户界面](img/00056.jpeg)'
- en: An example of the user interface before and after a user captures an image
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用户捕获图像前后的用户界面示例
- en: The setup activity layout
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置活动布局
- en: 'First, we will create a new Android project with a blank activity in Android
    Studio. Then, we will edit the layout xml for MainActivity in `app/src/main/res/layout/activity_main.xml`
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用Android Studio创建一个新的Android项目，其中包含一个空白活动。然后，我们将编辑`app/src/main/res/layout/activity_main.xml`中的MainActivity布局xml，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this layout xml file, we have two SurfaceViews—one for the camera preview
    and one for the overlay layer. We also have two buttons—one for capturing the
    image and one for saving the panorama image to the internal storage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此布局xml文件中，我们有两个SurfaceView——一个用于相机预览，一个用于叠加层。我们还有一个按钮用于捕获图像，另一个按钮用于将全景图像保存到内部存储。
- en: Capturing the camera frame
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获相机帧
- en: In this section, we will implement the process to capture camera frames and
    view it on a SurfaceView with the ID `surfaceView`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现捕获相机帧并在ID为`surfaceView`的SurfaceView上查看的过程。
- en: 'At the begin of the `MainActivity` class, we will create some objects to work
    with the layout:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的开头，我们将创建一些对象以与布局一起使用：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we created two buttons and two `SurfaceViews` to interact
    with the user interface. We also create a Camera object, `mCam`, to open the camera.
    In our implementation, we will open the camera and get the video frame in the
    Android approach. OpenCV also provides some other approaches to open the camera.
    However, we found that they may not work well on all Android devices, so we prefer
    using the camera with Android approach. In this chapter, we only need the Camera
    object from the Android API. The advantage of this approach is that you can expect
    it to work on almost any Android device. The disadvantage is that you have to
    do some conversion from camera byte array to Android Bitmap to display on the
    UI and to OpenCV Mat to do the image processing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了两个按钮和两个`SurfaceViews`以与用户界面交互。我们还创建了一个Camera对象`mCam`以打开相机。在我们的实现中，我们将使用Android方法打开相机并获取视频帧。OpenCV还提供了一些其他打开相机的方法。然而，我们发现它们可能不会在所有Android设备上很好地工作，所以我们更喜欢使用Android方法中的相机。在本章中，我们只需要Android
    API中的Camera对象。这种方法的优势是您可以预期它在几乎任何Android设备上都能工作。缺点是您必须进行一些从相机字节数组到Android Bitmap的转换，以在UI上显示，并将OpenCV
    Mat用于图像处理。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to experience OpenCV classes to interact with the camera, you may
    want to check [Chapter 7](part0058_split_000.html#1NA0K1-940925703e144daa867f510896bffb69
    "Chapter 7. Gyroscopic Video Stabilization"), *Gyroscopic Video Stabilization*,
    of this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想体验OpenCV类与相机交互，您可能想查看本书的第七章[7.陀螺仪视频稳定](part0058_split_000.html#1NA0K1-940925703e144daa867f510896bffb69
    "第七章.陀螺仪视频稳定")，*陀螺仪视频稳定*。
- en: 'In the `onCreate` function, we set up these objects as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中，我们按以下方式设置这些对象：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, we initialize `isPreview` to false and assign `mSurfaceView` to `SurfaceView`
    in the layout. Then, we get the holder of `mSurfaceView` and add a callback to
    it. The variable `mSurfaceCallback` is an instance of `SurfaceHolder.Callback`
    that we will create later. We also assign `mSurfaceViewOnTop` to the other SurfaceView
    in the layout, since we want this SurfaceView to be an overlay layer on the camera
    view. We need to set the Z order to be true and set the holder format to `TRANSPARENT`.
    Finally, we set up the capture and save buttons, and set the corresponding `OnClickListener`.
    In the next part, we will work on displaying the camera frame on the `SurfaceView`.
    So we will just create a basic `OnClickListener` as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`isPreview`初始化为false，并将布局中的`mSurfaceView`分配给`SurfaceView`。然后，我们获取`mSurfaceView`的持有者并向其添加一个回调。变量`mSurfaceCallback`是我们稍后将要创建的`SurfaceHolder.Callback`实例。我们还把`mSurfaceViewOnTop`分配给布局中的另一个`SurfaceView`，因为我们希望这个`SurfaceView`成为相机视图的叠加层。我们需要设置Z顺序为true，并将持有者格式设置为`TRANSPARENT`。最后，我们设置捕获和保存按钮，并设置相应的`OnClickListener`。在下一部分，我们将专注于在`SurfaceView`上显示相机帧。因此，我们将创建一个基本的`OnClickListener`，如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the Camera API to get the camera frame
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Camera API获取相机帧
- en: As we said before, we will use the Android API to get the camera frame in Android.
    Currently, there are two versions of Camera API, `android.hardware.Camera` and
    `android.hardware.camera2`. We will use `android.hardware.Camera` because it supports
    most of the Android devices up to Android 4.4\. In Android 5.0 and later, this
    API is deprecated and replaced by camera2\. We can still use `android.hardware.Camera`
    on Android 5.0\. If you want to target Android 5.0, we recommend you to try camera2
    in your application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，我们将使用Android API在Android中获取相机帧。目前，有两个版本的Camera API，即`android.hardware.Camera`和`android.hardware.camera2`。我们将使用`android.hardware.Camera`，因为它支持大多数Android
    4.4及以下版本的设备。在Android 5.0及以后的版本中，此API已被弃用，并由camera2替代。我们仍然可以在Android 5.0中使用`android.hardware.Camera`。如果您想针对Android
    5.0，我们建议您在您的应用程序中尝试使用camera2。
- en: In order to use the camera, we need to add the following lines to `AndroidManifest.xml`
    to gain the permissions to the camera. Besides, we also request the permission
    to write to storage as we will save the panorama image to internal storage.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用相机，我们需要在`AndroidManifest.xml`中添加以下行以获取对相机的权限。此外，我们还请求写入存储的权限，因为我们将会将全景图像保存到内部存储。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We want to set the `mSurfaceView` to display the camera frame, so we will set
    up the camera parameters in the callback of `mSurfaceView`. We need to create
    the variable `mSurfaceCallback` as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将`mSurfaceView`设置为显示相机帧，因此我们将在`mSurfaceView`的回调中设置相机参数。我们需要创建变量`mSurfaceCallback`，如下所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code, we call the `setPreviewDisplay` method in the `surfaceCreated`
    function to tell the camera to display the camera frame on `mSurfaceView`. After
    this, in the `surfaceChanged` function, we set the camera parameters, change the
    display orientation to 90 degrees and start the preview process. The function
    `getBestPreviewSize` is a function to get the preview size that has the biggest
    number of pixels. The `getBestPreviewSize` is simple, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们在`surfaceCreated`函数中调用`setPreviewDisplay`方法，告诉相机在`mSurfaceView`上显示相机帧。之后，在`surfaceChanged`函数中，我们设置相机参数，将显示方向更改为90度并开始预览过程。`getBestPreviewSize`函数是一个获取具有最大像素数的预览尺寸的函数。`getBestPreviewSize`很简单，如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we need to add some code to open the camera in `onResume` and release
    the camera in `onPause`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`onResume`中添加一些代码来打开相机，并在`onPause`中释放相机：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At this moment, we can install and run the application on a real device. The
    following figure shows a screenshot of our application on a Nexus 5 running Android
    5.1.1:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们可以在真实设备上安装并运行应用程序。以下图显示了在运行Android 5.1.1的Nexus 5上我们的应用程序的截图：
- en: '![Using the Camera API to get the camera frame](img/00057.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用Camera API获取相机帧](img/00057.jpeg)'
- en: A screenshot of the application in Camera Preview mode on Nexus 5 running Android
    5.1.1
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus 5在Android 5.1.1上运行Camera预览模式的截图
- en: 'In our application, we don''t want the layout to rotate so we set the activity
    orientation to portrait mode. It''s optional. If you want to do this, you can
    simply change your activity in `AndroidManifest.xml` as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们不希望布局旋转，因此我们将活动方向设置为纵向模式。这是可选的。如果您想这样做，您只需在`AndroidManifest.xml`中更改您的活动，如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implementing the Capture button
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现捕获按钮
- en: 'In this section, we will show you how to implement the `OnClickListener` of
    the **Capture** button. When the user clicks on the **Capture** button, we want
    the application to take a picture of the current scene. With the Camera API, we
    can use the `takePicture` function to capture a picture. The benefit of this function
    is that the resolution of the output image is very high. For example, when our
    application runs on Nexus 5, even though the previewing size is 1920x1080, the
    resolution of the captured image is 3264x2448\. We change `captureOnClickListener`
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `onClick` function, we check whether the camera is initialized and the
    flag `safeToTakePicture` is `true`. Then, we set the flag to `false` so that we
    don't take two pictures at the same time. The `takePicture` function of the Camera
    instance requires three parameters. The first and second parameters are shutter
    call back and raw data call back respectively. These functions may be called differently
    on different devices so we don't want to use them and set them to null. The last
    parameter is the callback that is called when the camera saves the picture in
    the JPEG format.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, `onPictureTaken` provides a byte array of the captured image, so we would
    want to decode it to an instance of Bitmap. Because the camera sensor captured
    the image in landscape mode, we would want to apply a rotation matrix to obtain
    the image in the portrait mode. Then, we would want to save this image to pass
    a sequence of images to the OpenCV stitching module. Since this code needs the
    OpenCV library, we will implement this part later. After this, we will obtain
    the canvas of the overlay `SurfaceView` and try to draw the image on the screen.
    The following is a demonstration of the overlay layer on top of the previewing
    layer. Finally, we will start the preview process again and also set the `safeToTakePicture`
    flag to `true`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the Capture button](img/00058.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the application after the user captured an image on a Nexus
    5 running Android 5.1.1
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Save button
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the **Save** button is fairly simple. We will assume that when the
    user clicks on the **Save** button, we will start a new thread to perform the
    image processing task:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `imageProcessingRunnable`, we would want to show a processing dialog at
    the start of the process and close the dialog when everything is completed. In
    order to accomplish this, we will first create an instance of `ProgressDialog`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, `imageProcessingRunnable` is implemented as:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will simply call `showProcessingDialog` to show the progressing dialog and
    call `closeProcessingDialog` to close the dialog. The steps in between are quite
    complex and requires lots of OpenCV functions, so we keep this part for a later
    section. The functions to show and close the progress dialog are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In `showProcessingDialog`, we will stop the camera preview to reduce unnecessary
    computation cost on the device, whereas in `closeProcessingDialog`, we start the
    camera preview again to allow the user to capture more panorama images. We must
    put these codes in `runOnUiThread` since these codes interact with the UI elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `showProcessingDialog` 中，我们将停止相机预览以减少设备上的不必要的计算成本，而在 `closeProcessingDialog`
    中，我们将再次启动相机预览，以便用户可以捕获更多的全景图像。我们必须将这些代码放在 `runOnUiThread` 中，因为这些代码与 UI 元素交互。
- en: In the following section, we will show you how to implement the remaining parts
    of our application with OpenCV.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示如何使用 OpenCV 实现应用程序的剩余部分。
- en: Integrating OpenCV into the Android Studio
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 OpenCV 集成到 Android Studio 中
- en: In this section, we will show you the steps to integrate OpenCV in the Android
    Studio with the Native Development Kit and use the OpenCV stitching module in
    C++ to create the final panorama image. We will also do some computations with
    OpenCV Android SDK Java to show how the interaction goes about between Java and
    C++ interfaces.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何使用原生开发套件将 OpenCV 集成到 Android Studio 中，并使用 C++ 中的 OpenCV 粘合模块创建最终的全景图像。我们还将使用
    OpenCV Android SDK Java 进行一些计算，以展示 Java 和 C++ 接口之间的交互过程。
- en: Compiling OpenCV Android SDK to the Android Studio project
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 OpenCV Android SDK 编译到 Android Studio 项目
- en: Officially, the OpenCV Android SDK is an Eclipse project, which means we can't
    simply use it in our Android Studio project. We need to convert the OpenCV Android
    SDK to an Android Studio project and import it as a module to our application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，OpenCV Android SDK 是一个 Eclipse 项目，这意味着我们无法简单地将其用于我们的 Android Studio 项目。我们需要将
    OpenCV Android SDK 转换为 Android Studio 项目，并将其作为模块导入到我们的应用程序中。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We assume that you have downloaded the latest OpenCV for Android from [http://opencv.org/downloads.html](http://opencv.org/downloads.html).
    At the time of writing, we now have OpenCV for Android 3.0.0.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已从 [http://opencv.org/downloads.html](http://opencv.org/downloads.html)
    下载了最新的 OpenCV for Android。在撰写本文时，我们现在有 OpenCV for Android 3.0.0。
- en: Let's extract the downloaded file to your favorite path, for example, `/Volumes/Data/OpenCV/OpenCV-android-sdk`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将下载的文件解压到您喜欢的路径，例如，`/Volumes/Data/OpenCV/OpenCV-android-sdk`。
- en: Then, we need to open a new Android Studio window and select **Import project**
    (Eclipse ADT, Gradle, and so on). In the popup window, you should select the `java`
    folder at `OpenCV-android-sdk/sdk/java` and click on **OK**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要打开一个新的 Android Studio 窗口并选择**导入项目**（Eclipse ADT、Gradle 等等）。在弹出的窗口中，你应该选择
    `java` 文件夹在 `OpenCV-android-sdk/sdk/java`，然后点击**确定**。
- en: '![Compiling OpenCV Android SDK to the Android Studio project](img/00059.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![编译 OpenCV Android SDK 到 Android Studio 项目](img/00059.jpeg)'
- en: Import project visualization
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 导入项目可视化
- en: In the next window, we will choose a path to store the new OpenCV SDK project.
    In our case, we choose `/Volumes/Data/OpenCV/opencv-java` and click on **Next**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个窗口中，我们将选择一个路径来存储新的 OpenCV SDK 项目。在我们的例子中，我们选择 `/Volumes/Data/OpenCV/opencv-java`
    并点击**下一步**。
- en: '![Compiling OpenCV Android SDK to the Android Studio project](img/00060.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![编译 OpenCV Android SDK 到 Android Studio 项目](img/00060.jpeg)'
- en: Select import destination visualization
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 选择导入目标可视化
- en: In the last window, we will simply click on **Finish** and wait until Android
    Studio completes the Gradle build process. Basically, Gradle is the default build
    system of Android Studio. At this step, we want to make sure that the OpenCV SDK
    can be compiled successfully. One of the common errors is that you haven't downloaded
    the required Android SDK. The error message is very straightforward. You can follow
    the message to solve the problem. In our case, there is no problem as in the following
    screenshot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个窗口中，我们只需点击**完成**并等待 Android Studio 完成Gradle 构建过程。基本上，Gradle 是 Android Studio
    的默认构建系统。在这一步，我们想确保 OpenCV SDK 可以成功编译。一个常见错误是您尚未下载所需的 Android SDK。错误信息非常直接。您可以按照消息解决问题。在我们的例子中，正如以下截图所示，没有问题。
- en: '![Compiling OpenCV Android SDK to the Android Studio project](img/00061.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![编译 OpenCV Android SDK 到 Android Studio 项目](img/00061.jpeg)'
- en: Build competition visualization
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 构建竞争可视化
- en: At this time, we can close this project and open our Panorama project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以关闭此项目并打开我们的全景项目。
- en: Setting up the Android Studio to work with OpenCV
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Android Studio 以与 OpenCV 一起工作
- en: 'In order to use OpenCV in our project, we need to import the OpenCV Android
    SDK to our project. With this SDK, we can use the OpenCV Java API and perform
    image processing tasks easily. Moreover, we must make a further step to tell Android
    Studio to compile OpenCV C++ code to use OpenCV in the Native Development Kit
    (NDK). We will split this section into three subsections: Importing the Android
    SDK, Creating a Java-C++ interaction, and Compiling OpenCV C++.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Importing the OpenCV Android SDK
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We assume that you have opened the Panorama project. We need to import the
    converted OpenCV Android SDK in the previous section as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**File** | **New** | **Import Module**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **New Module** window, we will select the source directory to the converted
    project. In our case, we will choose `/Volumes/Data/OpenCV/opencv-java`. Then,
    we''ll check the import checkbox, change the module name to `:opencv-java`, as
    shown in the following screenshot and click **Finish**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing the OpenCV Android SDK](img/00062.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: A new module window
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to modify `build.gradle` in the `app` folder to add one line
    to the `dependencies` section:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, we must sync the project with the button **Sync Project with Gradle
    Files**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you only need the OpenCV Java Interface and don''t want to use OpenCV C++,
    you must copy the `libs` folder at `OpenCV-android-sdk/sdk/native/libs` to your
    `app/src/main` folder. Then, you must add the following `loadLibrary` code to
    your class file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating a Java and C++ interaction with Java Native Interface (JNI)
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start the compile process, we will create a class file named `NativePanorama.java`
    and add a method to the `NativePanorama` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `processPanorama` method will receive an array of long addresses of each
    image and a long address of an output image.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'You must rebuild the project in order to follow the ensuing steps. The detailed
    explanation is in the next paragraph:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Use the `javah` command line to create a C++ header
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `.cpp` file for the newly created header in the `jni` folder to implement
    the function in C++
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may notice the keyword `native` before the `processPanorama` method. This
    means that we will use this method to interact between Java and C++ in our application.
    Therefore, we need to create some headers and source files to implement our C++
    code. We must follow **Java Native Interface** (**JNI**) to use C++ code, so the
    process may be a bit complex and out of the scope of this book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In the following parts, we will show you the steps to use OpenCV C++.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to understand JNI, you may want to take a look at the JNI documentation
    found at:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/7/docs/technotes/guides/jni/](http://docs.oracle.com/javase/7/docs/technotes/guides/jni/)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, have a look at the JNI tips from API guides found at:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/training/articles/perf-jni.html](http://developer.android.com/training/articles/perf-jni.html)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will use the `javah` command in the terminal to create the corresponding
    C++ header for the `processPanorama` method. In order to do this, you need to
    open the terminal on your machine, then change the directory to the folder `app/src/main`
    in your Android application and run the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用终端中的 `javah` 命令为 `processPanorama` 方法创建相应的 C++ 头文件。为了做到这一点，您需要打开您的机器上的终端，然后切换到
    Android 应用程序中的 `app/src/main` 文件夹，并运行以下命令：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You only need to verify the package name and the name of the class file, `NativePanorama`.
    The command will not display anything on the terminal, as shown in the following
    figure. You may want to rebuild the project if you encounter the following error:
    **Error: Could not find class file for ''com.example.panorama.NativePanorama''**.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要验证包名和类文件名 `NativePanorama`。命令在终端上不会显示任何内容，如图所示。如果您遇到以下错误：**错误：找不到类文件 'com.example.panorama.NativePanorama'**，您可能需要重新构建项目。
- en: '![Creating a Java and C++ interaction with Java Native Interface (JNI)](img/00063.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Java Native Interface (JNI) 创建 Java 和 C++ 交互](img/00063.jpeg)'
- en: The terminal after using the javah command
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 javah 命令后的终端
- en: As the result of the `javah` command, we now have a folder named `jni` in our
    `app/src/main` folder with a file `com_example_panorama_NativePanorama.h`. This
    header contains a function to work with Java Interface. When `processPanorama`
    is called, this function will run in C++.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`javah` 命令的结果是，我们现在在 `app/src/main` 文件夹中有一个名为 `jni` 的文件夹，其中包含一个名为 `com_example_panorama_NativePanorama.h`
    的文件。这个头文件包含一个用于与 Java 接口工作的函数。当调用 `processPanorama` 时，这个函数将在 C++ 中运行。'
- en: 'Next, we will create a source file named `com_example_panorama_NativePanorama.cpp`
    in the `jni` folder. We recommend that you should copy the function declaration
    from the header file to the source file and add the parameter names as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `jni` 文件夹中创建一个名为 `com_example_panorama_NativePanorama.cpp` 的源文件。我们建议您将头文件中的函数声明复制到源文件中，并添加以下参数名称：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only thing left is that we need to compile OpenCV C++ SDK to use it in the
    preceding source file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是我们需要编译 OpenCV C++ SDK，以便在先前的源文件中使用它。
- en: Compiling OpenCV C++ with NDK/JNI
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NDK/JNI 编译 OpenCV C++
- en: In order to use OpenCV in C++ code, we need to compile OpenCV C++ and use an
    `Android.mk` file as the make file to build and link our C++ file with OpenCV
    library. However, Android Studio doesn't support `Android.mk` out of the box.
    We need to do lots of things to make this happen.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 C++ 代码中使用 OpenCV，我们需要编译 OpenCV C++，并使用 `Android.mk` 文件作为构建文件来构建和链接我们的 C++
    文件与 OpenCV 库。然而，Android Studio 默认不支持 `Android.mk`。我们需要做很多事情才能实现这一点。
- en: 'First, we will open the `local.properties` file and set `ndk.dir` to be your
    path to the Android NDK folder. In our case, the `local.properties` will look
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将打开 `local.properties` 文件，并将 `ndk.dir` 设置为 Android NDK 文件夹的路径。在我们的例子中，`local.properties`
    将如下所示：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can get the Android NDK at: [https://developer.android.com/ndk/index.html](https://developer.android.com/ndk/index.html)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置获取 Android NDK：[https://developer.android.com/ndk/index.html](https://developer.android.com/ndk/index.html)
- en: 'Secondly, we open the `build.gradle` file in our app folder and add this line
    at the top:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们打开应用程序文件夹中的 `build.gradle` 文件，并在顶部添加以下行：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, we need to add the following code between the `defaultConfig` tag and
    `buildType` tag to create a new Gradle task to build C++ code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在 `defaultConfig` 标签和 `buildType` 标签之间添加以下代码，以创建一个新的 Gradle 任务来构建 C++
    代码。
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You may want to look at the following figure for a screenshot of our `build.gradle`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想查看以下图中的我们的 `build.gradle` 的截图。
- en: '![Compiling OpenCV C++ with NDK/JNI](img/00064.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![使用 NDK/JNI 编译 OpenCV C++](img/00064.jpeg)'
- en: A screenshot of our build.gradle
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 build.gradle 截图
- en: 'Next, we create a file named `Application.mk` in the `jni` folder and put the
    following lines in it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `jni` 文件夹中创建一个名为 `Application.mk` 的文件，并将以下行放入其中：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we create a file named `Android.mk` in the `jni` folder and set up
    this file as below to use OpenCV in our C++ code. You may need to change the `OPENCVROOT`
    variable to the location of OpenCV-android-sdk in your machine:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `jni` 文件夹中创建一个名为 `Android.mk` 的文件，并按照以下设置来使用 OpenCV 在我们的 C++ 代码中。您可能需要将
    `OPENCVROOT` 变量更改为您机器上 OpenCV-android-sdk 的位置：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the preceding `Android.mk`, Android Studio will build OpenCV into `libopencv_java3.so`
    and build our C++ code into `libMyLib.so` in the folder `app/src/main/jniLibs`.
    We have to open our `MainActivity.java` and load this library to use in our application
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的`Android.mk`，Android Studio会将OpenCV构建到`libopencv_java3.so`中，并将我们的C++代码构建到`app/src/main/jniLibs`文件夹中的`libMyLib.so`中。我们必须打开我们的`MainActivity.java`并加载这个库，以便在我们的应用程序中使用，如下所示：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you use OpenCV Android SDK Version 2.*, you should load `opencv_java` instead
    of `opencv_java3`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用OpenCV Android SDK版本2.*，您应该加载`opencv_java`而不是`opencv_java3`。
- en: Implementing the OpenCV Java code
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现OpenCV Java代码
- en: In this section, we will show you OpenCV in Java side to prepare the data for
    the stitching module in the OpenCV C++ side.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示OpenCV在Java端，为OpenCV C++端的拼接模块准备数据。
- en: 'First, we will create a list to store all of the captured images when the user
    presses the **Capture** button:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当用户按下**捕获**按钮时，我们将创建一个列表来存储所有捕获的图像：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, in the `onPictureTaken` method of the `jpegCallback` variable, we want
    to convert the captured Bitmap into an OpenCV Mat and store in this `listImage`
    list. You need to add these lines before the drawing parts with Canvas:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`jpegCallback`变量的`onPictureTaken`方法中，我们想要将捕获的Bitmap转换为OpenCV Mat并存储在这个`listImage`列表中。您需要在Canvas绘制部分之前添加这些行：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, when the user clicks the **Save** button, we would want to send the
    address of the images in `listImage` to the OpenCV C++ code to perform the stitching
    process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户点击**保存**按钮时，我们希望将`listImage`中图像的地址发送到OpenCV C++代码以执行拼接过程。
- en: 'In `imageProcessingRunnable`, we will add these codes after the `showProcessingDialog`
    function call:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`imageProcessingRunnable`中，我们将在调用`showProcessingDialog`函数之后添加以下代码：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we will create a long array to store all the native addresses
    of each Mat image. Then, we will pass this long array and the native address of
    a `Mat result`, to store the panorama image. The OpenCV C++ code will run to perform
    stitching with the stitching module. After this, we save the result into the external
    storage and make a simple toast to indicate to the user that the panorama is saved.
    Finally, we clear the `listImage` list to start a new section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将创建一个长数组来存储每个Mat图像的本地地址。然后，我们将传递这个长数组和一个`Mat result`的本地地址，以存储全景图像。OpenCV
    C++代码将运行以执行拼接模块的拼接。之后，我们将结果保存到外部存储，并做一个简单的toast提示用户全景已保存。最后，我们清除`listImage`列表以开始新的部分。
- en: Implementing the OpenCV C++ code
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现OpenCV C++代码
- en: 'At this moment, we want to implement the `processPanorama` in OpenCV C++. The
    implementation is really simple; we will only edit the `com_example_panorama_NativePanorama.cpp`
    file as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，我们想要在OpenCV C++中实现`processPanorama`。实现非常简单；我们只需编辑`com_example_panorama_NativePanorama.cpp`文件，如下所示：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we converted the long array of image addresses into images
    and pushed into a vector called `imgVec`. We also resized the image for fast computation.
    The stitching module is really easy to use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将图像地址的长数组转换为图像并推入一个名为`imgVec`的向量中。我们还调整了图像大小以加快计算速度。拼接模块非常容易使用。
- en: First, we will create an instance of `Stitcher`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`Stitcher`实例。
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, we use this stitcher to stitch our vector image of Mat. The panorama image
    will be saved into a resultant Mat.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这个拼接器来拼接我们的Mat向量图像。全景图像将被保存到一个结果Mat中。
- en: 'The following screenshot shows an example of a panorama image processed with
    the default configuration:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了使用默认配置处理的全景图像示例：
- en: '![Implementing the OpenCV C++ code](img/00065.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![实现OpenCV C++代码](img/00065.jpeg)'
- en: A sample image captured in the corridor
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在走廊中捕获的示例图像
- en: Application showcase
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序展示
- en: In this section, we show some panorama images captured with our application.
    You can see that the application is capable of processing panorama images in both
    horizontal and vertical directions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了使用我们的应用程序捕获的一些全景图像。您可以看到，该应用程序能够处理水平和垂直方向的全景图像。
- en: First, this is an image captured from the fifth floor of a building. We took
    this picture through a window glass so the light was dim. However, the panorama
    is good because there are many details so the feature matcher can do a great job.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是从建筑物的五楼捕获的图像。我们通过窗户玻璃拍照，所以光线很暗。然而，全景效果很好，因为有很多细节，所以特征匹配器可以做得很好。
- en: '![Application showcase](img/00066.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序展示](img/00066.jpeg)'
- en: A sample image captured by the application
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序捕获的示例图像
- en: The following screenshot is an image captured in the evening on a balcony. The
    region on the top-left corner of the panorama is bad since this only contains
    a blank wall and the sky. Therefore, there were too little features to compare
    between images. Hence, the final panorama is not perfect in this region.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是在傍晚时分从阳台拍摄的。全景图的左上角区域不好，因为这个区域只包含一面空墙和天空。因此，图像之间可比较的特征太少。因此，最终全景图在这个区域并不完美。
- en: '![Application showcase](img/00067.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![应用展示](img/00067.jpeg)'
- en: A sample image captured by the application in the evening
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在傍晚捕获的样本图像
- en: The following screenshot was captured through a window. The lower half of the
    image is good. However, the sky still has some problems due to the lack of features,
    as in the previous image.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是通过窗户拍摄的。图像的下半部分很好。然而，由于缺乏特征，天空仍然存在一些问题，就像之前的图像一样。
- en: '![Application showcase](img/00068.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![应用展示](img/00068.jpeg)'
- en: Another sample image captured by the application in the evening
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在傍晚时分捕获的另一张样本图像
- en: The following image was shot in a courtyard in front of the building in the
    afternoon. The lighting was good and there were many details, so the final panorama
    is perfect.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是在下午拍摄的建筑前庭院中的。光线很好，有很多细节，所以最终全景图完美无瑕。
- en: '![Application showcase](img/00069.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![应用展示](img/00069.jpeg)'
- en: A sample image captured by the application in the afternoon
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在下午捕获的样本图像
- en: This image was taken at the same period with the previous image. However, this
    image was captured with a wide range of angles and the light was different at
    each shot. Therefore, the lighting in the final panorama is not consistent.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片与上一张图片拍摄于同一时期。然而，这张图片以广泛的视角捕捉，每个拍摄角度的光线都不同。因此，最终全景图的照明并不一致。
- en: '![Application showcase](img/00070.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![应用展示](img/00070.jpeg)'
- en: Another sample image captured by the application in the afternoon
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在下午捕获的另一张样本图像
- en: Further improvement
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进
- en: In this section, we will show some improvements that you can consider while
    creating a fully featured panorama application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示一些在创建功能齐全的全景应用时可以考虑的改进。
- en: First, you can make a better user interface for the user to capture a panorama
    image. The current user interface doesn't show that the application can capture
    images in both directions. A suggestion is to use the motion sensors (accelerometer
    and gyroscope) in the Android API to obtain the rotation of the device and adjust
    the position of the overlay image.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以为用户创建一个更好的用户界面来捕捉全景图像。当前的用户界面没有显示应用程序可以双向捕捉图像。建议使用Android API中的运动传感器（加速度计和陀螺仪）来获取设备的旋转并调整叠加图像的位置。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Motion Sensors API documentation is available at [http://developer.android.com/guide/topics/sensors/sensors_motion.html](http://developer.android.com/guide/topics/sensors/sensors_motion.html).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运动传感器API文档可在[http://developer.android.com/guide/topics/sensors/sensors_motion.html](http://developer.android.com/guide/topics/sensors/sensors_motion.html)找到。
- en: Secondly, the current application resizes the captured image to decrease computation
    time. You may want to change some parameters of the Stitcher to have better performance.
    We suggest that you look at the documentation of the stitching module for more
    details. In our implementation, we will use the Stitcher class for simplification.
    However, there is a detailed sample in the OpenCV repository at `samples/cpp/stitching_detailed.cpp`,
    where they show many options to improve the stability and quality of the final
    panorama.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当前应用程序调整捕获的图像大小以减少计算时间。你可能想更改Stitcher的一些参数以获得更好的性能。我们建议你查看拼接模块的文档以获取更多详细信息。在我们的实现中，我们将使用Stitcher类进行简化。然而，OpenCV仓库中有一个详细的示例在`samples/cpp/stitching_detailed.cpp`，其中展示了许多选项来提高最终全景图的稳定性和质量。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The detailed sample of using the stitching module is available at [https://github.com/Itseez/opencv/blob/master/samples/cpp/stitching_detailed.cpp](https://github.com/Itseez/opencv/blob/master/samples/cpp/stitching_detailed.cpp).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拼接模块的详细示例可在[https://github.com/Itseez/opencv/blob/master/samples/cpp/stitching_detailed.cpp](https://github.com/Itseez/opencv/blob/master/samples/cpp/stitching_detailed.cpp)找到。
- en: Thirdly, you can change the logic of our application to perform real-time stitching.
    That means we make a stitching image whenever there are two captured images. Then,
    we show the result with the help of a 360-degree user interface so that the user
    can know which is the missing region, if any.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，您可以更改我们应用程序的逻辑以执行实时拼接。这意味着每当捕获到两张图像时，我们就制作一张拼接图像。然后，我们借助360度用户界面展示结果，以便用户知道如果有的话，哪个是缺失的区域。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showed a complete panorama application in Android Studio where
    OpenCV 3 is used in both the Java interface and the C++ interface with the support
    of the Native Development Kit (NDK). The chapter also introduced us to how to
    use the Android Camera API with the OpenCV library. Also, the chapter illustrated
    some basic implementation with the OpenCV 3 stitching module to perform image
    stitching.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了在Android Studio中使用的完整全景应用程序，其中OpenCV 3在Java接口和C++接口中均得到使用，并得到了原生开发工具包（NDK）的支持。本章还介绍了如何使用OpenCV库与Android
    Camera API结合。此外，本章还展示了使用OpenCV 3拼接模块的一些基本实现，以执行图像拼接。
