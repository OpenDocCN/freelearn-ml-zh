- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Achieving the GCP ML Certification
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获得GCP ML认证
- en: Congratulations! You have gone through all the chapters thus far and built a
    strong knowledge base and skillset for **Machine Learning** (**ML**) in Google
    Cloud. Now, it is time to integrate what you have learned so far and take the
    GCP ML certification exam – the last part of our learning roadmap.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经走过了所有这些章节，并在 Google Cloud 的机器学习（ML）方面建立了强大的知识库和技能集。现在，是时候整合您所学到的知识，参加
    GCP ML 认证考试——我们学习路线图的最后一部分。
- en: The Google Professional Machine Learning Engineer certification exam is a very
    important part of your journey to becoming a Google Cloud Certified Machine Learning
    Engineer. To prepare for and pass the exam, you must review all the contents in
    this book and integrate them to deeply understand them and connect all the dots.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Google 专业机器学习工程师认证考试是您成为 Google Cloud 认证机器学习工程师旅程中非常重要的一部分。为了准备和通过考试，您必须复习本书中的所有内容，并深入理解它们，将所有知识点串联起来。
- en: 'We recommend that you take the following steps to prepare for and achieve the
    Google Professional ML Engineer certification:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您采取以下步骤来准备和获得 Google 专业机器学习工程师认证：
- en: Read the official Google ML certification exam guide.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读官方 Google 机器学习认证考试指南。
- en: Read all the chapters in this book.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读本书的所有章节。
- en: Complete all the hands-on labs in this book.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成本书中的所有动手实验室。
- en: Practice and review all the practice questions in this chapter.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习并复习本章中的所有练习题。
- en: To get you prepared, we have provided some practice questions for the ML certification
    exam, along with the analysis of the questions in this chapter. Make sure you
    fully understand each question and all the answers to the questions, and why the
    right answer is right and the wrong answers are wrong. Keep in mind that the questions
    set here are just examples and we aim to provide a pilot sample for you to follow.
    You will need to do more research on the internet to reach a comprehensive level
    for the exam.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您做好准备，我们提供了一些 ML 认证考试的练习题，以及本章中问题的分析。确保您充分理解每个问题以及所有问题的答案，以及为什么正确答案是正确的，错误答案为什么是错误的。请记住，这里设置的问题只是示例，我们的目标是为您提供一份参考样本。您还需要在互联网上进行更多研究，以达到考试的全面水平。
- en: GCP ML exam practice questions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCP ML 考试练习题
- en: 'Please read each question carefully and thoroughly, and fully understand it.
    Please also review all the docs that are related to the question at the reference
    links provided:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细、全面地阅读每个问题，并充分理解它。请同时查阅提供的参考链接中的所有相关文档：
- en: '**Question 1**: Space Y is launching its hundredth satellite to build its StarSphere
    network. They have designed an accurate orbit (launching speed/time/and so on)
    for it based on the existing 99 satellite orbits to cover the Earth’s scope. What’s
    the best solution to forecast the position of the 100 satellites after the hundredth
    launch?'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 1**：Space Y 正在发射其第一百颗卫星以构建其 StarSphere 网络。他们已经根据现有的 99 颗卫星轨道设计了精确的轨道（发射速度/时间等），以覆盖地球的范围。在第一百次发射后预测
    100 颗卫星位置的最好解决方案是什么？'
- en: Use ML algorithms and train ML models to forecast
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用机器学习算法和训练机器学习模型进行预测
- en: Use neural networks to train the model to forecast
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用神经网络训练模型进行预测
- en: Use physical laws and actual environmental data to model and forecast
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用物理定律和实际环境数据建模和预测
- en: Use a linear regression model to forecast
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用线性回归模型进行预测
- en: '**Analysis**: This is an ML problem framing question. To decide whether ML
    is the best method for a problem, we need to see whether traditional science modeling
    would be very difficult or impossible to solve the problem and whether plenty
    of data exists. When we start, science modeling will be our first choice since
    it builds the most accurate model based on science and natural laws. For example,
    given the initial position and speed of an object, as well as its mass and the
    forces acting on it, we can precisely predict its position at any time. For this
    case, the mathematical model works much better than any ML model!'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：这是一个机器学习问题框架问题。为了决定机器学习是否是解决问题的最佳方法，我们需要看传统科学建模是否非常困难或不可能解决问题，以及是否存在大量数据。当我们开始时，科学建模将是我们的首选，因为它基于科学和自然法则建立最精确的模型。例如，给定物体的初始位置和速度，以及它的质量和作用在其上的力，我们可以精确预测其在任何时间的位置。对于这个案例，数学模型比任何机器学习模型都要好得多！'
- en: To forecast the hundredth satellite’s orbit, answer C is the best choice here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测第一百颗卫星的轨道，在这里答案 C 是最佳选择。
- en: '**Reference**: Section *Is ML the best solution?* in [*Chapter 3*](B18333_03.xhtml#_idTextAnchor072),
    *Preparing for ML Development*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考**：在[*第3章*](B18333_03.xhtml#_idTextAnchor072)的*“机器学习是否是最好的解决方案？”*部分，*准备机器学习开发*'
- en: '**Question 2**: A financial company is building an ML model to detect credit
    card fraud based on their historical dataset, which contains 20 positives and
    4,990 negatives.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题2**：一家金融公司正在构建一个机器学习模型，基于他们的历史数据集检测信用卡欺诈，该数据集包含20个正面样本和4,990个负面样本。'
- en: Due to the imbalanced classes, the model training is not working as desired.
    What’s the best way to resolve this issue?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类别不平衡，模型训练没有按预期进行。最好的解决方法是什么？
- en: Data augmentation
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据增强
- en: Early stopping
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提前停止
- en: Downsampling and upweighting
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下采样和上权重
- en: Regularization
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则化
- en: '**Analysis**: This question is about class imbalance when preparing data for
    classification problems. When the data is imbalanced, it will be very difficult
    to train the ML model and get good forecasts. We need to use *downsampling and
    upweighting* to balance the classes, so the answer is C.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：这个问题是关于在准备分类问题时数据不平衡的问题。当数据不平衡时，将非常难以训练机器学习模型并获得良好的预测。我们需要使用*下采样和上权重*来平衡类别，所以答案是C。'
- en: '**Reference**: Section *Data sampling and balancing* in [*Chapter 3*](B18333_03.xhtml#_idTextAnchor072),
    *Preparing for ML Development*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考**：在[*第3章*](B18333_03.xhtml#_idTextAnchor072)的*“数据采样和平衡”*部分，*准备机器学习开发*'
- en: '**Question 3**: A chemical manufacturer is using a GCP ML pipeline to detect
    real-time sensor anomalies by queuing the inputs and analyzing and visualizing
    the data. Which one will you choose for the pipeline?'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题3**：一家化学制造商正在使用GCP机器学习管道通过排队输入、分析和可视化数据来检测实时传感器异常。你会选择哪个管道？'
- en: Dataproc | AI Platform | BQ
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dataproc | 人工智能平台 | BQ
- en: Dataflow | AutoML | Cloud SQL
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dataflow | AutoML | Cloud SQL
- en: Dataflow | AI Platform | BQ
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据流 | 人工智能平台 | BQ
- en: Dataproc | AutoML | Bigtable
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dataproc | AutoML | Bigtable
- en: '**Analysis**: This is an ML pipeline question. We need to understand the difference
    between Dataflow and Dataproc, AI Platform and AutoML, as well as the various
    GCP databases: Cloud SQL, Bigtable, and BQ.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：这是一个机器学习管道问题。我们需要了解Dataflow和Dataproc、人工智能平台和AutoML之间的区别，以及各种GCP数据库：Cloud
    SQL、Bigtable和BQ。'
- en: Dataproc and Dataflow are GCP data processing services, and both can process
    batch or streaming data. However, Dataproc is designed to run on clusters for
    jobs that are compatible with MapReduce (Apache Hadoop, Hive, and Spark). Dataflow
    is based on parallel data processing and works better if your data has no implementation
    with Spark or Hadoop.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Dataproc和Dataflow是GCP数据处理服务，两者都可以处理批量或流数据。然而，Dataproc是为与MapReduce（Apache Hadoop、Hive和Spark）兼容的工作而设计的，可以在集群上运行。Dataflow基于并行数据处理，如果你的数据没有与Spark或Hadoop的实现，它将运行得更好。
- en: AI Platform involves “human-performed” ML training – using your own data and
    model. AutoML is “automated” ML training with Google’s model and your own data,
    with no coding.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能平台涉及“人工执行”的机器学习训练——使用你自己的数据和模型。AutoML是“自动化”的机器学习训练，使用Google的模型和你的数据，无需编码。
- en: Out of the GCP database/warehouse products, Cloud SQL is for relational data
    online transaction processing, Bigtable is more for NoSQL transaction processing,
    and BQ is great for analyzing and visualizing data (integrating with Data Studio).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCP数据库/仓库产品中，Cloud SQL适用于在线事务处理的关系数据，Bigtable更多用于NoSQL事务处理，而BQ非常适合分析和可视化数据（与Data
    Studio集成）。
- en: Based on this, we will choose C as the answer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们将选择C作为答案。
- en: '**Question 4**: A real estate company, Zeellow, does great business buying
    and selling properties in the United States. Over the past few years, they have
    accumulated a big amount of historical data for US houses.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题4**：一家房地产公司，Zeellow，在美国买卖房产业务做得很好。在过去的几年里，他们积累了大量美国房屋的历史数据。'
- en: Zeellow is using ML training to predict housing prices, and they retrain the
    models every month by integrating new data. The company does not want to write
    any code in the ML process. What method best suits their needs?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Zeellow正在使用机器学习训练来预测房价，并且他们通过整合新数据每月重新训练模型。公司不希望在机器学习过程中编写任何代码。哪种方法最适合他们的需求？
- en: AutoML tables
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AutoML表格
- en: BigQuery ML
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BigQuery ML
- en: AI Platform
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人工智能平台
- en: AutoML classification
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AutoML分类
- en: '**Analysis**: This question is also about the difference between AutoML and
    AI Platform, as well as between regression and classification. Since AutoML serves
    the purpose of no coding during the ML process, and this is a structured data
    ML problem, the correct answer is A.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：这个问题也是关于自动机器学习（AutoML）和AI平台，以及回归和分类之间的区别。由于自动机器学习（AutoML）在机器学习过程中无需编码，并且这是一个结构化数据机器学习问题，因此正确答案是A。'
- en: '**Question 5**: The data scientist team is building a deep learning model for
    a customer support center of a big **Enterprise Resource Planning** (**ERP**)
    company, which has many ERP products and modules. The DL model will input customers’
    chat texts and categorize them into products before routing them to the corresponding
    team. The company wants to minimize the model development time and data preprocessing
    time. What strategy/platform should they choose?'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题5**：数据科学家团队正在为一家大型**企业资源规划（ERP**）公司的客户服务中心构建一个深度学习模型，该公司拥有许多ERP产品和模块。该深度学习模型将输入客户的聊天文本，并在将它们路由到相应的团队之前将它们分类到产品中。公司希望最小化模型开发时间和数据预处理时间。他们应该选择什么策略/平台？'
- en: AI Platform
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AI平台
- en: Auto ML
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动机器学习（Auto ML）
- en: NLP API
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: NLP API
- en: Vertex AI Custom notebooks
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vertex AI自定义笔记本
- en: '**Analysis**: The key point here is that *the company wants to minimize the
    model development time and data preprocessing time.* AutoML is the best choice,
    so the correct answer is B.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：这里的关键点是*公司希望最小化模型开发时间和数据预处理时间*。自动机器学习（AutoML）是最佳选择，因此正确答案是B。'
- en: '**Question 6**: A real estate company, Zeellow, does great business buying
    and selling properties in the United States. Over the past few years, they have
    accumulated a big amount of historical data for US houses.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题6**：一家房地产公司，Zeellow，在美国买卖房产业务做得很好。在过去的几年里，他们积累了大量关于美国房屋的历史数据。'
- en: Zeellow wants to use ML to forecast future sales by leveraging their historical
    sales data. The historical data is stored in cloud storage. You want to rapidly
    experiment with all the available data. How should you build and train your model?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Zeellow希望利用他们的历史销售数据通过机器学习预测未来的销售。历史数据存储在云存储中。你想要快速实验所有可用数据。你应该如何构建和训练你的模型？
- en: Load data into BigQuery and use BigQuery ML
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据加载到BigQuery中并使用BigQuery ML
- en: Convert the data into CSV and use AutoML Tables
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据转换为CSV格式并使用AutoML Tables
- en: Convert the data into TFRecords and use TensorFlow
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据转换为TFRecords并使用TensorFlow
- en: Convert and refactor the data into CSV format and use the built-in XGBoost library
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据和重构转换为CSV格式并使用内置的XGBoost库
- en: '**Analysis**: The key point here is that we need to experiment quickly with
    all the structured datasets stored in cloud storage. BQ and BQML are the best
    options here since all the others will take a long time to build and train the
    model. Thus, the correct answer is A.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：这里的关键点是，我们需要快速实验存储在云存储中的所有结构化数据集。BQ和BQML是最佳选择，因为其他所有选项都需要很长时间来构建和训练模型。因此，正确答案是A。'
- en: '**Question 7**: A real estate company, Zeellow, uses ML to forecast future
    sales by leveraging their historical data. New data is coming in every week, and
    Zeellow needs to make sure the model is continually retrained to reflect the marketing
    trend. What should they do with the historical data and new data?'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题7**：一家房地产公司，Zeellow，利用他们的历史数据通过机器学习预测未来的销售。每周都有新数据进来，Zeellow需要确保模型持续重新训练以反映市场趋势。他们应该如何处理历史数据和新的数据？'
- en: Only use the new data for retraining
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只使用新数据进行重新训练
- en: Update the datasets weekly with new data
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每周用新数据更新数据集
- en: Update the datasets with new data when model evaluation metrics do not meet
    the required criteria
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当模型评估指标不符合所需标准时，用新数据更新数据集
- en: Update the datasets monthly with new data
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每月用新数据更新数据集
- en: '**Analysis**: Model retraining is the key term here. Since data changes over
    time and causes trained models to become obsolete, model retraining is the norm
    in the ML process. In this case, when do we need to retrain the model? The answer
    is when the performance metrics do not meet the requirements. How do we retrain
    the model? The answer is to use the integrated datasets, including existing and
    new data. Therefore, the correct answer is C.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：模型重新训练是这里的关键术语。由于数据随时间变化，导致训练好的模型变得过时，因此模型重新训练是机器学习过程中的常态。在这种情况下，我们何时需要重新训练模型？答案是当性能指标不符合要求时。我们如何重新训练模型？答案是使用集成数据集，包括现有和新数据。因此，正确答案是C。'
- en: '**Question 8**: A real estate company, Zeellow, uses ML to forecast future
    sales by leveraging their historical data. Their data science team trained and
    deployed a DL model in production half a year ago. Recently, the model is suffering
    from performance issues due to data distribution changes.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 8**：房地产公司 Zeellow 通过利用其历史数据来预测未来的销售。他们的数据科学团队在半年前在生产环境中训练并部署了一个深度学习模型。最近，由于数据分布的变化，该模型出现了性能问题。'
- en: The team is working on a strategy for model retraining. What is your suggestion?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 团队正在制定模型重新训练的策略。您有什么建议？
- en: Monitor data skew and retrain the model
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控数据偏差并重新训练模型
- en: Retrain the model with fewer model features
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用较少的模型特征重新训练模型
- en: Retrain the model to fix overfitting
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新训练模型以修复过拟合
- en: Retrain the model with new data coming in every month
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用每月新来的数据进行模型重新训练
- en: '**Analysis**: Model retraining is based on data value skews, which are significant
    changes in the statistical properties of data. When data skew is detected, this
    means that data patterns are changing, and we need to retrain the model to capture
    these changes. The question did not mention any overfitting issues, nor did it
    mention feature reduction. The retraining strategy will be monitoring data skew
    and retraining the model with the new inputs. Thus, the correct answer is A.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：模型重新训练基于数据值偏差，即数据统计属性的重大变化。当检测到数据偏差时，这意味着数据模式正在变化，我们需要重新训练模型以捕捉这些变化。问题没有提到任何过拟合问题，也没有提到特征减少。重新训练策略将是监控数据偏差，并使用新的输入重新训练模型。因此，正确答案是
    A。'
- en: '**Reference**: [https://developers.google.com/machine-learning/guides/rules-of-ml/#rule_37_measure_trainingserving_skew](https://developers.google.com/machine-learning/guides/rules-of-ml/#rule_37_measure_trainingserving_skew).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考**：[https://developers.google.com/machine-learning/guides/rules-of-ml/#rule_37_measure_trainingserving_skew](https://developers.google.com/machine-learning/guides/rules-of-ml/#rule_37_measure_trainingserving_skew)。'
- en: '**Question 9**: Recent research has indicated that when a certain kind of cancer,
    *X*, is developed in a human liver, there are usually other symptoms that can
    be identified as objects *Y* and *Z* from CT scan images. A hospital is using
    this research to train ML models with a label map of (*X*, *Y*, *Z*) on CT images.
    What cost functions should be used in this case?'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 9**：最近的研究表明，当某种癌症 *X* 在人类肝脏中发展时，通常会有其他可以识别为 CT 扫描图像中的对象 *Y* 和 *Z* 的症状。一家医院正在利用这项研究在
    CT 图像上使用 (*X*, *Y*, *Z*) 标签图的机器学习模型进行训练。在这种情况下应使用哪些成本函数？'
- en: Binary cross-entropy
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制交叉熵
- en: Categorical cross-entropy
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类别交叉熵
- en: Sparse categorical cross-entropy
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稀疏类别交叉熵
- en: Dense categorical cross-entropy
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稠密类别交叉熵
- en: '**Analysis**: The correct answer is B.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是 B。'
- en: In [*Chapter 5*](B18333_05.xhtml#_idTextAnchor116), *Understanding Neural Networks
    and Deep Learning*, *in The cost function* section, we discussed the use cases
    for different cost functions. Binary cross-entropy is used for binary classification
    problems. Categorical entropy is better to use when you want to prevent the model
    from giving more importance to a certain class – the same as the one-hot encoding
    idea. Sparse categorical entropy is more optimal when your classes are mutually
    exclusive (for example, when each sample belongs exactly to one class).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B18333_05.xhtml#_idTextAnchor116)，*理解神经网络和深度学习*，*成本函数*部分，我们讨论了不同成本函数的使用案例。二进制交叉熵用于二分类问题。当您想防止模型对某个特定类别给予更多重视时，最好使用类别熵——这与
    one-hot 编码的想法相同。当您的类别互斥时（例如，当每个样本恰好属于一个类别时），稀疏类别熵更为优化。
- en: '**Question 10**: The data science team in your company has built a DNN model
    to forecast the sales value for an automobile company, based on historical data.
    As a Google ML Engineer, you need to verify that the features selected are good
    enough for the ML model.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 10**：贵公司的数据科学团队基于历史数据构建了一个深度神经网络模型，用于预测汽车公司的销售价值。作为一名谷歌机器学习工程师，您需要验证所选特征是否足够好，以供机器学习模型使用。'
- en: Train the model with L1 regularization and verify that the loss is constant
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 L1 正则化训练模型并验证损失保持不变
- en: Train the model with no regularization and verify that the loss is constant
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无正则化的模型进行训练并验证损失保持不变
- en: Train the model with L2 regularization and verify that the loss is decreasing
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 L2 正则化训练模型并验证损失在下降
- en: Train the model with no regularization and verify that the loss is close to
    zero
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无正则化的模型进行训练，并验证损失接近零
- en: '**Analysis**: The correct answer is D.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是 D。'
- en: The loss function is the measurement for model prediction accuracy and is used
    as an index for the ML training process. To verify that the model that’s been
    built has enough features, we need to make sure that the loss function is close
    to zero when no regularizations are used.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 损失函数是模型预测准确度的衡量标准，并用作机器学习训练过程的指标。为了验证构建的模型具有足够的特征，我们需要确保在未使用正则化时，损失函数接近零。
- en: '**Reference**: Section *Regularization* in [*Chapter 4*](B18333_04.xhtml#_idTextAnchor094),
    *Developing and Deploying ML Models*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考**：[第4章](B18333_04.xhtml#_idTextAnchor094)中的*正则化*部分，*开发和部署机器学习模型*。'
- en: '**Question 11**: The data science team in your company has built a DNN model
    to forecast the sales value for a real estate company, based on historical data.
    As a Google ML Engineer, you find that the model has over 300 features and that
    you wish to remove some features that are not contributing to the target. What
    will you do?'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题11**：你公司的数据科学团队基于历史数据构建了一个深度神经网络模型来预测房地产公司的销售额。作为一名谷歌机器学习工程师，你发现该模型有超过300个特征，并且你希望删除一些对目标没有贡献的特征。你会怎么做？'
- en: Use Explainable AI to understand the feature contributions and reduce the non-contributing
    ones.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用可解释人工智能来理解特征贡献并减少非贡献的特征。
- en: Use L1 regularization to reduce features.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用L1正则化来减少特征。
- en: Use L2 regularization to reduce features.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用L2正则化来减少特征。
- en: Drop a feature at a time, train the model, and verify that it does not degrade
    the model. Remove these features.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一次删除一个特征，训练模型，并验证它不会降低模型性能。删除这些特征。
- en: '**Analysis**: The correct answer is A. This question is discussing feature
    selection, and Explainable AI is one of the ways to understand which features
    are contributing and which ones are not. It is important to understand that L1
    and L2 are methods for resolving model overfitting issues and not feature selection
    in data engineering.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是A。这个问题在讨论特征选择，可解释人工智能是理解哪些特征有贡献以及哪些没有贡献的一种方式。重要的是要理解L1和L2是解决模型过拟合问题的方法，而不是数据工程中的特征选择。'
- en: '**Question 12**: The data science team in your company has built a DNN model
    to forecast the sales value for a real estate company, based on historical data.
    They found that the model fits the training dataset well, but not the validation
    dataset. What would you do to improve the model?'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题12**：你公司的数据科学团队基于历史数据构建了一个深度神经网络模型来预测房地产公司的销售额。他们发现模型很好地拟合了训练数据集，但没有拟合验证数据集。你会怎么做来改进模型？'
- en: Apply a dropout parameter of 0.3 and decrease the learning rate by a factor
    of 10
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用0.3的dropout参数，并将学习率降低10倍。
- en: Apply an L2 regularization parameter of 0.3 and decrease the learning rate by
    a factor of 10
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用0.3的L2正则化参数，并将学习率降低10倍。
- en: Apply an L1 regularization parameter of 0.3 and increase the learning rate by
    a factor of 10
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用0.3的L1正则化参数，并将学习率提高10倍。
- en: Tune the hyperparameters to optimize the L2 regularization and dropout parameters
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整超参数以优化L2正则化和dropout参数。
- en: '**Analysis**: The correct answer is D.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是D。'
- en: This question is discussing techniques to avoid model overfitting. While L1/L2
    regularization, dropout parameters, and learning rate are all ways to help, we
    must tune the hyperparameters and find the optimized values. A hint here is that
    the correct answer would be fitting to the general case and thus will not have
    concrete numbers such as 0.3, 10, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在讨论避免模型过拟合的技术。虽然L1/L2正则化、dropout参数和学习率都是帮助的方法，但我们必须调整超参数并找到优化的值。这里的提示是，正确答案将适合一般情况，因此不会包含像0.3、10等具体的数字。
- en: '**Question 13**: You are building a DL model for a customer service center.
    The model will input customers’ chat text and analyze their sentiments. What algorithm
    should be used for the model?'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题13**：你正在为客服中心构建一个深度学习模型。该模型将输入客户的聊天文本并分析他们的情绪。应该使用什么算法来构建这个模型？'
- en: MLP
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MLP
- en: Regression
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回归
- en: CNN
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CNN
- en: RNN
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: RNN
- en: '**Analysis**: The correct answer is D.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是D。'
- en: This question tests the different algorithms used for ML/DL. Since text processing
    for sentiment analysis needs to process sequential data (time series), the best
    option is **Recurrent Neural Networks** (**RNNs**).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题测试了机器学习/深度学习中使用的不同算法。由于文本处理进行情感分析需要处理序列数据（时间序列），最佳选项是**循环神经网络**（**RNN**）。
- en: '**Question 14**: A health insurance company scans customers'' hand-filled claim
    forms and stores them in Google Cloud Storage buckets in real time. They use ML
    models to recognize the handwritten texts. Since the claims may contain **Personally
    Identifiable Information** (**PII**), company policies require only authorized
    persons to access the information. What’s the best way to store and process this
    streaming data?'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题14**：一家健康保险公司实时扫描客户的填写索赔表格，并将它们存储在谷歌云存储桶中。他们使用机器学习模型来识别手写文本。由于索赔可能包含**个人身份信息**（**PII**），公司政策要求只有授权人员才能访问信息。存储和处理这种流数据的最佳方式是什么？'
- en: Create two buckets and label them as sensitive and non-sensitive. Store data
    in the non-sensitive bucket first. Periodically scan it using the DLP API and
    move the sensitive data to the sensitive bucket.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个桶，并分别标记为敏感和非敏感。首先将数据存储在非敏感桶中。定期使用DLP API扫描它，并将敏感数据移动到敏感桶中。
- en: Create one bucket to store the data. Only allow the ML service account access
    to it.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个桶来存储数据。仅允许机器学习服务账户访问它。
- en: Create three buckets – quarantine, sensitive, and non-sensitive. Store all the
    data in the quarantine bucket first. Then, periodically scan it using the DLP
    API and move the data to either the sensitive or non-sensitive bucket.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个桶——隔离区、敏感和非敏感。首先将所有数据存储在隔离区桶中。然后，定期使用DLP API扫描它，并将数据移动到敏感或非敏感桶中。
- en: Create three buckets – quarantine, sensitive, and non-sensitive. Store all the
    data in the quarantine bucket first. Then, once the file has been uploaded, trigger
    the DLP API to scan it, and move the data to either the sensitive or non-sensitive
    bucket.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个桶——隔离区、敏感和非敏感。首先将所有数据存储在隔离区桶中。然后，一旦文件已上传，触发DLP API进行扫描，并将数据移动到敏感或非敏感桶中。
- en: '**Analysis**: The correct answer is D.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是D。'
- en: This is a business use case for PII/private data storage and processing, and
    a typical solution is to create three buckets and utilize DLP to scan and then
    move the raw data into different buckets and control their access.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个PII/私人数据存储和处理的业务用例，一个典型的解决方案是创建三个桶，并利用DLP进行扫描，然后将原始数据移动到不同的桶中，并控制它们的访问。
- en: '**Question 15**: A real estate company, Zeellow, uses ML to forecast future
    sales by leveraging their historical data. The recent model training was able
    to achieve the desired forecast accuracy objective, but it took the data science
    team a long time. They want to decrease the training time without affecting the
    achieved model accuracy. What hyperparameter should the team adjust?'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题15**：房地产公司Zeellow利用机器学习通过利用其历史数据来预测未来的销售。最近的模型训练能够达到预期的预测准确度目标，但数据科学团队花费了很长时间。他们希望在不影响达到的模型准确度的情况下减少训练时间。团队应该调整哪个超参数？'
- en: Learning rate
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习率
- en: Epochs
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代次数
- en: Scale tier
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩放层
- en: Batch size
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批处理大小
- en: '**Analysis**: The correct answer is C since changing the other three parameters
    will change the model’s prediction accuracy.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是C，因为改变其他三个参数将改变模型的预测准确度。'
- en: '**Question 16**: The data science team has built a DNN model to monitor and
    detect defective products using the images from the assembly line of an automobile
    manufacturing company. As a Google ML Engineer, you need to measure the performance
    of the ML model for the test dataset/images. Which of the following would you
    choose?'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题16**：数据科学团队使用来自汽车制造公司装配线图像构建了一个深度神经网络（DNN）模型来监控和检测缺陷产品。作为谷歌机器学习工程师，你需要测量测试数据集/图像的机器学习模型的性能。以下哪个选项你会选择？'
- en: The AUC value
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AUC值
- en: The recall value
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 召回值
- en: The precision value
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精确度值
- en: The TP value
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真阳性（TP）值
- en: '**Analysis**: The correct answer is A because it measures how well the predictions
    are ranked rather than their absolute values. It is a classification threshold
    invariant and thus is the best way to measure the model’s performance.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是A，因为它衡量的是预测的排名有多好，而不是它们的绝对值。它是一个分类阈值不变的指标，因此是衡量模型性能的最佳方式。'
- en: '**Question 17**: The data science team has built a DL model to monitor and
    detect defective products using the images from the assembly line of an automobile
    manufacturing company. Over time, the team has built multiple model versions in
    AI Platform. As a Google ML Engineer, how will you compare the model versions?'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题17**：数据科学团队使用来自汽车制造公司装配线图像构建了一个深度学习（DL）模型来监控和检测缺陷产品。随着时间的推移，团队在AI平台中构建了多个模型版本。作为谷歌机器学习工程师，你将如何比较这些模型版本？'
- en: Compare the mean average precision for the model versions
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较模型版本的平均平均精度
- en: Compare the model loss functions on the training dataset
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在训练数据集上比较模型损失函数
- en: Compare the model loss functions on the validation dataset
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证数据集上比较模型损失函数
- en: Compare the model loss functions on the testing dataset
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试数据集上比较模型损失函数
- en: '**Analysis**: The correct answer is A because it measures how well the different
    model versions perform over time: deploy your model as a model version and then
    create an evaluation job for that version. By comparing the mean average precision
    across the model versions, you can find the best performer.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：正确答案是 A，因为它衡量了不同模型版本随时间推移的表现：将你的模型作为模型版本部署，然后为该版本创建一个评估作业。通过比较模型版本之间的平均平均精度，你可以找到表现最好的版本。'
- en: '**References**: [https://cloud.google.com/ai-platform/prediction/docs/continuous-evaluation/view-metrics#compare_mean_average_precision_across_models](https://cloud.google.com/ai-platform/prediction/docs/continuous-evaluation/view-metrics#compare_mean_average_precision_across_models).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考资料**：[https://cloud.google.com/ai-platform/prediction/docs/continuous-evaluation/view-metrics#compare_mean_average_precision_across_models](https://cloud.google.com/ai-platform/prediction/docs/continuous-evaluation/view-metrics#compare_mean_average_precision_across_models)。'
- en: '**Question 18**: The data science team is building a recommendation engine
    for an e-commerce website using ML models to increase its business revenue, based
    on users’ similarities. What model would you choose?'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 18**：数据科学团队正在使用机器学习模型为电子商务网站构建一个推荐引擎，以提高其业务收入，基于用户的相似性。你会选择哪种模型？'
- en: Collaborative filtering
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协同过滤
- en: Regression
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回归
- en: Classification
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分类
- en: Content-based filtering
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: '**Analysis**: For this recommendation engine question, the correct answer is
    A.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：对于这个推荐引擎问题，正确答案是 A。'
- en: Content-based filtering uses the similarity between items to recommend items
    that are similar to what the user likes. Collaborative filtering uses similarities
    between users to provide recommendations. The question specifies “based on users’
    similarities.”
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的过滤通过使用项目之间的相似性来推荐与用户喜好相似的项目。协同过滤通过用户之间的相似性来提供推荐。问题中指定了“基于用户的相似性”。
- en: '**References**: [https://developers.google.com/machine-learning/recommendation/overview/candidate-generation](https://developers.google.com/machine-learning/recommendation/overview/candidate-generation).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考资料**：[https://developers.google.com/machine-learning/recommendation/overview/candidate-generation](https://developers.google.com/machine-learning/recommendation/overview/candidate-generation)。'
- en: '**Question 19**: The data science team is building a fraud-detection model
    for a credit card company, whose objective is to detect as much fraud as possible
    and avoid as many false alarms as possible. What confusion matrix index would
    you maximize for this model performance evaluation?'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 19**：数据科学团队正在为一家信用卡公司构建一个欺诈检测模型，其目标是尽可能多地检测欺诈，同时尽可能少地产生误报。你将最大化哪个混淆矩阵指标来评估此模型的表现？'
- en: Precision
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精确度
- en: Recall
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 召回率
- en: The area under the PR curve
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PR 曲线下方的面积
- en: The area under the ROC curve
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROC 曲线下方的面积
- en: '**Analysis**: In this fraud-detection problem, it asks you to focus on detecting
    fraudulent transactions - maximize True Positive rate and minimize False Negative
    - maximize recall (*Recall = TruePositives / (TruePositives + FalseNegatives)*).
    It also asks you to minimize false alarms (false positives) - maximize precision
    (*Precision = TruePositives / (TruePositives + FalsePositives)*).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：在这个欺诈检测问题中，它要求你专注于检测欺诈交易——最大化真正阳性率并最小化假阴性——最大化召回率（召回率 = 真阳性 / (真阳性 +
    假阴性)）。它还要求你最小化误报（假阳性）——最大化精确度（精确度 = 真阳性 / (真阳性 + 假阳性)）。'
- en: So, since you want to maximize both precision and recall, the correct answer
    is C (maximize the area under the PR curve).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然你想同时最大化精确度和召回率，正确答案是 C（最大化 PR 曲线下方的面积）。
- en: '**References**: [https://machinelearningmastery.com/roc-curves-and-precision-recall-curves-for-imbalanced-classification/](https://machinelearningmastery.com/roc-curves-and-precision-recall-curves-for-imbalanced-classification/).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考资料**：[https://machinelearningmastery.com/roc-curves-and-precision-recall-curves-for-imbalanced-classification/](https://machinelearningmastery.com/roc-curves-and-precision-recall-curves-for-imbalanced-classification/)。'
- en: '**Question 20**: The data science team is building a data pipeline for an auto
    manufacturing company, whose objective is to integrate all the data sources that
    exist in their on-premise facilities, via a codeless data ETL interface. What
    GCP service will you use?'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 20**：数据科学团队正在为一家汽车制造公司构建数据管道，其目标是通过无代码数据 ETL 界面集成其本地设施中存在的所有数据源。您将使用哪个
    GCP 服务？'
- en: Dataproc
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dataproc
- en: Dataflow
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dataflow
- en: Dataprep
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据准备
- en: Data Fusion
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据融合
- en: '**Analysis**: Since the question asks for data integration with a codeless
    interface, Data Fusion is the best choice here. Thus, the correct answer is D.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：由于问题要求使用无代码界面进行数据集成，因此在这里 Data Fusion 是最佳选择。因此，正确答案是 D。'
- en: '**References**: [https://cloud.google.com/data-fusion/docs/concepts/overview#using_the_code-free_web_ui](https://cloud.google.com/data-fusion/docs/concepts/overview#using_the_code-free_web_ui).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**: [https://cloud.google.com/data-fusion/docs/concepts/overview#using_the_code-free_web_ui](https://cloud.google.com/data-fusion/docs/concepts/overview#using_the_code-free_web_ui).'
- en: '**Question 21**: The data science team has built a TensorFlow model in BigQuery
    for a real estate company, whose objective is to integrate all their data models
    into the new Google Vertex AI platform. What’s the best strategy?'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 21**：数据科学团队在 BigQuery 中为一家房地产公司构建了一个 TensorFlow 模型，其目标是将其所有数据模型集成到新的 Google
    Vertex AI 平台。最佳策略是什么？'
- en: Export the model from BigQuery ML
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 BigQuery ML 导出模型
- en: Register the BQML model to Vertex AI
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 BQML 模型注册到 Vertex AI
- en: Import the model into Vertex AI
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型导入到 Vertex AI
- en: Use AI Platform as the middle stage
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 AI 平台作为中间阶段
- en: '**Analysis**: Since the question asks for model integration with Vertex AI,
    which allows you to register a BQML model in it, the correct answer is B.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：由于问题要求使用 Vertex AI 进行模型集成，该平台允许您在其中注册 BQML 模型，因此正确答案是 B。'
- en: '**References**: https://cloud.google.com/bigquery-ml/docs/managing-models-vertex.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**: https://cloud.google.com/bigquery-ml/docs/managing-models-vertex.'
- en: '**Question 22**: A real estate company, Zeellow, uses ML to forecast future
    house sale prices by leveraging their historical data. The data science team needs
    to build a model to predict US house sale prices based on the house location (US
    city-specific) and house type. What strategy is the best for feature engineering
    in this case?'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 22**：房地产公司 Zeellow 使用机器学习通过利用其历史数据来预测未来的房屋销售价格。数据科学团队需要构建一个模型来根据房屋位置（美国特定城市）和房屋类型预测美国房屋销售价格。在这种情况下，特征工程的最佳策略是什么？'
- en: 'One feature cross: [latitude X longitude X housetype]'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个特征交叉：[纬度 X 经度 X 房屋类型]
- en: 'Two feature crosses: [binned latitude X binned housetype] and [binned longitude
    X binned housetype]'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个特征交叉：[分箱纬度 X 分箱房屋类型] 和 [分箱经度 X 分箱房屋类型]
- en: 'Three separate binned features: [binned latitude], [binned longitude], [binned
    housetype]'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个独立的分箱特征：[分箱纬度]、[分箱经度]、[分箱房屋类型]
- en: 'One feature cross: [binned latitude X binned longitude X binned housetype]'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个特征交叉：[分箱纬度 X 分箱经度 X 分箱房屋类型]
- en: '**Analysis**: Crossing binned latitude with binned longitude enables the model
    to learn city-specific effects on house types. It prevents a change in latitude
    from producing the same result as a change in longitude. Depending on the granularity
    of the bins, this feature cross could learn city-specific housing effects. So,
    the correct answer is D.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：将分箱纬度与分箱经度交叉可以使得模型学习到特定城市对房屋类型的影响。它防止纬度的变化产生与经度变化相同的结果。根据分箱的粒度，这个特征交叉可以学习到特定城市的住房影响。因此，正确答案是
    D。'
- en: '**References**: [https://developers.google.com/machine-learning/crash-course/feature-crosses/check-your-understanding](https://developers.google.com/machine-learning/crash-course/feature-crosses/check-your-understanding).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**: [https://developers.google.com/machine-learning/crash-course/feature-crosses/check-your-understanding](https://developers.google.com/machine-learning/crash-course/feature-crosses/check-your-understanding).'
- en: '**Question 23**: A health insurance company scans customer’s hand-filled claim
    forms and stores them in Google Cloud Storage buckets in real time. The data scientist
    team has developed an AI documentation model to digitize the images. By the end
    of each day, the submitted forms need to be processed automatically. The model
    is ready for deployment. What strategy should the team use to process the forms?'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 23**：一家健康保险公司实时扫描客户的填写索赔表格，并将它们存储在 Google Cloud Storage 存储桶中。数据科学家团队开发了一个
    AI 文档模型来数字化图像。每天结束时，提交的表格需要自动处理。模型已准备好部署。团队应使用什么策略来处理表格？'
- en: Vertex AI batch prediction
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vertex AI 批量预测
- en: Vertex AI online prediction
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vertex AI 在线预测
- en: Vertex AI ML pipeline prediction
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vertex AI ML 流程预测
- en: Cloud Run to trigger prediction
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cloud Run 触发预测
- en: '**Analysis**: As specified in the question, we need to run the process at the
    end of each day, which implies batch processing using AI Platform or Vertex AI.
    The correct answer is A.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：如问题所述，我们需要在每天结束时运行该过程，这意味着使用AI平台或Vertex AI进行批处理。正确答案是A。'
- en: '**Question 24**: A real estate company, Zeellow, uses GCP ML to forecast future
    house sale prices by leveraging their historical data. Their data science team
    has about 30 members and each member has developed multiple versions of models
    using Vertex AI customer notebooks. What’s the best strategy to manage these different
    models and different versions developed by the team members?'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题24**：房地产公司Zeellow使用GCP机器学习来利用其历史数据预测未来的房屋销售价格。他们的数据科学团队大约有30名成员，每个成员都使用Vertex
    AI客户笔记本开发了多个模型版本。管理团队成员开发的这些不同模型和不同版本的最佳策略是什么？'
- en: Set up IAM permissions to allow each member access to their notebooks, models,
    and versions
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置IAM权限，允许每个成员访问他们的笔记本、模型和版本
- en: Create a GCP project for each member for clean management
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个成员创建一个GCP项目以实现整洁的管理
- en: Create a map from each member to their GCP resources using BQ
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用BQ为每个成员创建一个到其GCP资源的映射
- en: Apply label/tags to the resources when they’re created for scalable inventory/cost/access
    management
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建资源时应用标签/标记，以实现可扩展的库存/成本/访问管理
- en: '**Analysis**: Resource tagging/labeling is the best way to manage ML resources
    for medium/big data science teams. The best answer is D.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：资源标记/标签是管理中等/大数据科学团队机器学习资源的最佳方式。最佳答案是D。'
- en: '**Resource**: https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源**：https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing.'
- en: '**Question 25**: Starbucks is an international coffee shop selling multiple
    products A, B, C… at different stores (1, 2, 3… using one-hot encoding and location
    binning). They are building stores and want to leverage ML models to predict product
    sales based on historical data (A1 is the data for product A sales at store 1).
    Following the best practices of splitting data into a training subset, validation
    subset, and testing subset, how should the data be distributed into these subsets?'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题25**：星巴克是一家国际咖啡店，在多个店铺（1, 2, 3…）销售多种产品A, B, C…，使用独热编码和位置分箱。他们正在开设新店，并希望利用机器学习模型根据历史数据（A1是店铺1产品A的销售数据）预测产品销售。遵循将数据分为训练子集、验证子集和测试子集的最佳实践，数据应如何分配到这些子集中？'
- en: 'Distribute data randomly across the subsets:'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据随机分配到子集中：
- en: 'Training set: [A1, B2, F1, E2, ...]'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练集：[A1, B2, F1, E2, ...]
- en: 'Testing set: [A2, C3, D2, F4, ...]'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试集：[A2, C3, D2, F4, ...]
- en: 'Validation set: [B1, C1, D9, C2...]'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证集：[B1, C1, D9, C2...]
- en: 'Distribute products randomly across the subsets:'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将产品随机分配到子集中：
- en: 'Training set: [A1, A2, A3, E1, E2, ...]'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练集：[A1, A2, A3, E1, E2, ...]
- en: 'Testing set: [B1, B2, C1, C2, C3, ...]'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试集：[B1, B2, C1, C2, C3, ...]
- en: 'Validation set: [D1, D2, F1, F2, F3, ...]'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证集：[D1, D2, F1, F2, F3, ...]
- en: 'Distribute stores randomly across subsets:'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将店铺随机分配到子集中：
- en: 'Training set: [A1, B1, C1, ...]'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练集：[A1, B1, C1, ...]
- en: 'Testing set: [A2, C2, F2, ...]'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试集：[A2, C2, F2, ...]
- en: 'Validation set: [D3, A3, C3, ...]'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证集：[D3, A3, C3, ...]
- en: Aggregate the data groups by the cities where the stores are allocated and distribute
    cities randomly across subsets
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照分配店铺的城市对数据组进行聚合，并将城市随机分配到子集中
- en: '**Analysis**: This question is about dataset splitting to avoid data leakage.
    If we distribute the data randomly into the training, validation, and test sets,
    the model will be able to learn specific qualities about the products. If we divided
    things up at the product level so that the given products were only in the training
    subset, the validation subset, or the testing subset, the model would find it
    more difficult to get high accuracy on the validation since it would need to focus
    on the product characteristics/qualities. Therefore, the correct answer is B.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：此问题涉及数据集分割以避免数据泄露。如果我们随机将数据分配到训练集、验证集和测试集，模型将能够学习关于产品的特定特性。如果我们按产品级别划分，使得给定的产品只存在于训练子集、验证子集或测试子集中，那么模型在验证集上获得高准确率将更加困难，因为它需要关注产品特性/质量。因此，正确答案是B。'
- en: '**Reference**: https://developers.google.com/machine-learning/crash-course/18th-century-literature.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考**：https://developers.google.com/machine-learning/crash-course/18th-century-literature.'
- en: '**Question 26**: You are building a DL model with Keras that looks as follows:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题26**：您正在使用Keras构建一个深度学习模型，其结构如下：'
- en: '[PRE0]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How many trainable weights does this model have?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型有多少个可训练权重？
- en: 200x128+128x4+4x2
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 200x128+128x4+4x2
- en: 200x128+128x4+2
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 200x128+128x4+2
- en: 200x128+129x4+5x2
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 200x128+129x4+5x2
- en: 200x128x0.25+128x4x0.25+4x2
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 200x128x0.25+128x4x0.25+4x2
- en: '**Analysis**: This question is testing the concept of trainable weights in
    a Keras model. As you can see, the correct answer is D.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：这个问题正在测试Keras模型中可训练权重的概念。如你所见，正确答案是D。'
- en: '**Question 27**: The data science team is building a DL model for a customer
    support center of a big ERP company, which has many ERP products and modules.
    The company receives over a million customer service calls every day and stores
    them in GCS. The call data must not leave the region in which the call originated
    and no PII can be stored/analyzed. The model will analyze calls for customer sentiments.
    How should you design a data pipeline for call processing, analyzing, and visualizing?'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 27**：数据科学团队正在为一家大型ERP公司的客户服务中心构建一个深度学习模型，该公司拥有许多ERP产品和模块。公司每天接收超过一百万个客户服务电话，并将它们存储在GCS中。通话数据不得离开通话起源地区域，并且不能存储/分析PII。该模型将分析通话以了解客户情绪。你应该如何设计通话处理、分析和可视化的数据管道？'
- en: GCS -> Speech2Text -> DLP -> BigQuery
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: GCS -> 语音转文本 -> DLP -> BigQuery
- en: GCS -> Pub/Sub -> Speech2Text -> DLP -> Datastore
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: GCS -> Pub/Sub -> 语音转文本 -> DLP -> 数据存储
- en: GCS -> Speech2Text -> DLP -> BigTable
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: GCS -> 语音转文本 -> DLP -> BigTable
- en: GCS -> Speech2Text -> DLP -> Cloud SQL
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: GCS -> 语音转文本 -> DLP -> 云SQL
- en: '**Analysis**: Since the question asks for a data pipeline to process, analyze,
    and visualize, the best answer is A. BigQuery is the best tool here to analyze
    and visualize.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：由于问题要求一个数据处理、分析和可视化的数据管道，最佳答案是A。BigQuery是这里分析和可视化的最佳工具。'
- en: '**Question 28**: The data science team is building an ML model to monitor and
    detect defective products using the images from the assembly line of an automobile
    manufacturing company, which does not have reliable Wi-Fi near the assembly line.
    As a Google ML Engineer, you need to reduce the amount of time spent by quality
    control inspectors utilizing the model’s fast defect detection. Your company wants
    to implement the new ML model as soon as possible. Which model should you use?'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 28**：数据科学团队正在构建一个机器学习模型，用于监控和检测汽车制造公司装配线上的图像中的缺陷产品，该公司装配线附近没有可靠的Wi-Fi。作为一名谷歌机器学习工程师，你需要减少质量检查员使用模型快速缺陷检测所花费的时间。贵公司希望尽快实施新的机器学习模型。你应该使用哪个模型？'
- en: AutoML Vision
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AutoML Vision
- en: AutoML Vision Edge mobile-versatile-1
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AutoML Vision Edge 移动多用途-1
- en: AutoML Vision Edge mobile-low-latency-1
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AutoML Vision Edge 移动低延迟-1
- en: AutoML Vision Edge mobile-high-accuracy-1
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AutoML Vision Edge 移动高精度-1
- en: '**Analysis:** Since the question asks for a quick inspection time and prioritizes
    latency reduction, the correct answer is C.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：由于问题要求快速检查时间和优先考虑延迟降低，正确答案是C。'
- en: '**Reference**: [https://cloud.google.com/vision/automl/docs/train-edge](https://cloud.google.com/vision/automl/docs/train-edge).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考**：[https://cloud.google.com/vision/automl/docs/train-edge](https://cloud.google.com/vision/automl/docs/train-edge)。'
- en: '**Question 29**: A national hospital is leveraging Google Cloud and a cell
    phone app to build an ML model to forecast heart attacks based on age, gender,
    exercise, heart rate, blood pressure, and more. Since the health data is highly
    sensitive personal information and cannot be stored in cloud databases, how should
    you train and deploy the ML model?'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 29**：一家国家医院正在利用谷歌云和手机应用构建一个机器学习模型，根据年龄、性别、运动、心率、血压等预测心脏病发作。由于健康数据是高度敏感的个人信息，不能存储在云数据库中，你应该如何训练和部署机器学习模型？'
- en: IoT with data encryption
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带数据加密的物联网
- en: Federated learning
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联邦学习
- en: Encrypted BQML
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密BQML
- en: DLP API
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: DLP API
- en: '**Analysis**: Federated learning is the best choice here due to the restrictions.
    With federated learning, all the data is collected, and the model is trained with
    algorithms across multiple decentralized edge devices such as cell phones or websites,
    without exchanging them. Therefore, the best answer is B.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：由于限制，联邦学习是这里最佳选择。使用联邦学习，所有数据都被收集，模型通过跨多个去中心化边缘设备（如手机或网站）的算法进行训练，而不需要交换它们。因此，最佳答案是B。'
- en: '**Question 30**: You are an ML engineer at a media company. You need to build
    an ML model to analyze video content frame by frame, identify objects, and alert
    users if there is inappropriate content. Which Google Cloud products should you
    use to build this project?'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 30**：你是一家媒体公司的机器学习工程师。你需要构建一个机器学习模型，逐帧分析视频内容，识别对象，并在存在不适当内容时提醒用户。你应该使用哪些谷歌云产品来构建这个项目？'
- en: Pub/Sub, Cloud Functions, and Cloud Vision API
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pub/Sub、云函数和云视觉API
- en: Pub/Sub, Cloud IoT, Dataflow, Cloud Vision API, and Cloud Logging
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pub/Sub、Cloud IoT、Dataflow、Cloud Vision API和Cloud Logging
- en: Pub/Sub, Cloud Functions, Video Intelligence API, and Cloud Logging
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pub/Sub、Cloud Functions、视频智能API和Cloud Logging
- en: Pub/Sub, Cloud Functions, AutoML Video Intelligence, and Cloud Logging
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pub/Sub、Cloud Functions、AutoML视频智能和Cloud Logging
- en: '**Analysis**: Since this question involves video analysis, this will eliminate
    A and B. AutoML video intelligence is for cases where you wish to customize models
    with Google’s model and your data. Therefore, C is the correct answer since the
    Video Intelligence API can be used to meet the requirements.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**：由于这个问题涉及视频分析，这将排除A和B。AutoML视频智能适用于您希望使用Google的模型和您的数据进行模型定制的情况。因此，C是正确答案，因为视频智能API可以用来满足这些要求。'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed the Google Cloud Professional Machine Learning
    Engineer certification exam and some practice questions. Since GCP ML is a changing
    domain, many new services have been developed and released by Google while this
    book was being written. By no means does this book cover all the exam topics in
    this domain. You will need to refer to the Google certification page for the certification
    exam guides and updates.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Google Cloud专业机器学习工程师认证考试和一些练习题。由于GCP ML是一个不断变化的领域，在本书编写期间，Google已经开发并发布了许多新服务。本书绝对没有涵盖该领域所有考试主题。您需要参考Google认证页面以获取认证考试指南和更新。
- en: This chapter concludes part four of this book. In part five of this book, in
    the appendices, we will provide some labs and demos for practicing your hands-on
    skills. It is recommended that you go through each appendix and practice the labs
    step-by-step.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了本书的第四部分。在本书的第五部分中，在附录中，我们将提供一些实验室和演示，以练习您的动手技能。建议您逐个查看每个附录并逐步进行实验室练习。
- en: 'Part 5: Appendices'
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分：附录
- en: In this part, we provide hands-on practices for ML in Google Cloud, including
    the basic GCP services, the Python data science libraries, the scikit-learn library,
    the GCP Vertex AI suite, and the Google Cloud ML APIs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们提供了在Google Cloud中进行机器学习的实践操作，包括基本GCP服务、Python数据科学库、scikit-learn库、GCP
    Vertex AI套件和Google Cloud ML API。
- en: 'This part comprises the following chapters:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Appendix 1*](B18333_11.xhtml#_idTextAnchor184), Practicing with Basic GCP
    Services'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*附录1*](B18333_11.xhtml#_idTextAnchor184)，使用基本GCP服务进行实践'
- en: '[*Appendix 2*](B18333_12.xhtml#_idTextAnchor195), Practicing with the Python
    Data Library'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*附录2*](B18333_12.xhtml#_idTextAnchor195)，使用Python数据库进行实践'
- en: '[*Appendix 3*](B18333_13.xhtml#_idTextAnchor209), Practicing with Scikit-Learn'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*附录3*](B18333_13.xhtml#_idTextAnchor209)，使用Scikit-Learn进行实践'
- en: '[*Appendix 4*](B18333_14.xhtml#_idTextAnchor218), Practicing with Google Vertex
    AI'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*附录4*](B18333_14.xhtml#_idTextAnchor218)，使用Google Vertex AI进行实践'
- en: '[*Appendix 5*](B18333_15.xhtml#_idTextAnchor233), Practicing with Google Cloud
    ML API'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*附录5*](B18333_15.xhtml#_idTextAnchor233)，使用Google Cloud ML API进行实践'
- en: Appendix 1
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录1
- en: Practicing with Basic GCP Services
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本GCP服务进行实践
- en: 'In this appendix, we will show some GCP resource provisioning examples, using
    the Google Cloud console and Cloud Shell. We will use the following architecture
    to practice using the Google Cloud console, as shown in *Figure 11.1*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将展示一些使用Google Cloud控制台和Cloud Shell的GCP资源配置示例。我们将使用以下架构来练习使用Google Cloud控制台，如图*图11.1*所示：
- en: 'A VPC network, VPC1, and two subnets in it: a public `subnet1` and a private
    `subnet2`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个VPC网络，VPC1，以及其中的两个子网：一个公共`subnet1`和一个私有`subnet2`
- en: A `subnet1` that has an external IP address and can be accessed from the internet
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有外部IP地址的`subnet1`，可以从互联网访问
- en: A VM in the private `subnet2` that does not have an external IP address and
    thus can only be accessed from the console browser, or from VMs within the same
    VPC
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在私有`subnet2`中的虚拟机（VM），它没有外部IP地址，因此只能通过控制台浏览器或同一VPC内的虚拟机访问
- en: 'Another VPC network, VPC2, and one subnet within VPC2: a private `subnet8`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个VPC网络，VPC2，以及VPC2中的一个子网：一个私有的`subnet8`
- en: A VM in the private `subnet8`
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有子网`subnet8`中的虚拟机（VM）
- en: Peering between VPC1 and VPC2
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VPC1和VPC2之间的对等连接
- en: '![](img/B18333_11_1.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_11_1.jpg)'
- en: Figure 11.1 – A sample architecture for GCP console practice
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – GCP控制台练习的示例架构
- en: In the GCP practice diagram in *Figure 11.1*, `public subnet1` is accessible
    from the internet. There is a Google Cloud Storage bucket called `B1`. If we want
    to have VM1, VM2, and VM8 access `B1`, what do we need to do? This is a great
    question to think about before reading further.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCP 实践图 *图 11.1* 中，`public subnet1` 可以从互联网访问。有一个名为 `B1` 的 Google Cloud Storage
    存储桶。如果我们想让 VM1、VM2 和 VM8 访问 `B1`，我们需要做什么？这是一个在继续阅读之前值得思考的好问题。
- en: Practicing using GCP services with the Cloud console
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云控制台中练习使用 GCP 服务
- en: 'In GCP, a project is the basic unit for resource provision. You can use the
    following steps to begin a project:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCP 中，项目是资源分配的基本单元。您可以使用以下步骤开始一个项目：
- en: 'After you log into the GCP console ([https://console.cloud.google.com](https://console.cloud.google.com))
    from your browser, you will see the following starting page:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中从 GCP 控制台 ([https://console.cloud.google.com](https://console.cloud.google.com))
    登录后，您将看到以下起始页面：
- en: '![](img/B18333_11_2.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_2.jpg)'
- en: You can always create a new project by clicking the drop-down button next to
    **My First Project**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您始终可以通过点击 **我的第一个项目** 旁边的下拉按钮来创建一个新的项目。
- en: '![](img/B18333_11_3.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_3.jpg)'
- en: Within the **My First Project** project, we will now create the network VPCs,
    subnets, and VMs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **我的第一个项目** 项目中，我们现在将创建网络 VPC、子网和虚拟机。
- en: Creating network VPCs using the GCP console
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GCP 控制台创建网络 VPC
- en: 'Use the following steps to create a VPC in the GCP console:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤在 GCP 控制台中创建 VPC：
- en: On the upper-left side of the window, there is the navigation drop-down menu
    that you will be able to use to choose the GCP services.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的右上角，有一个导航下拉菜单，您可以使用它来选择 GCP 服务。
- en: '![](img/B18333_11_4.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_4.jpg)'
- en: From the navigation menu on the left side, go to **VPC network** and select
    **VPC networks** from the dropdown. It will prompt you to enable **Compute Engine
    API**. Go ahead and enable it.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的导航菜单中，转到 **VPC 网络** 并从下拉菜单中选择 **VPC 网络**。它将提示您启用 **计算引擎 API**。继续并启用它。
- en: You will be brought to the **VPC network** page, where you can create a VPC
    network.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被带到 **VPC 网络** 页面，在那里您可以创建 VPC 网络。
- en: Click **CREATE VPC NETWORK**.![](img/B18333_11_5.jpg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建 VPC 网络**。![图片](img/B18333_11_5.jpg)
- en: 'Then, fill in the network details and create VPC1:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，填写网络详细信息并创建 VPC1：
- en: '`subnet1`'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subnet1`'
- en: '`10.10.1.0/24`'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.10.1.0/24`'
- en: '`us-east1`'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us-east1`'
- en: '`subnet2`'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subnet2`'
- en: '`10.10.2.0/24`'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.10.2.0/24`'
- en: '`asia-east1`'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asia-east1`'
- en: 'Then, `vpc1` is created with two subnets:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`vpc1` 创建了两个子网：
- en: '![](img/B18333_11_6.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_6.jpg)'
- en: 'Repeat *Steps 3* and *4* to create `vpc2`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 3* 和 *步骤 4* 来创建 `vpc2`：
- en: '`subnet8`'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subnet8`'
- en: '`192.168.1.0/24`'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.1.0/24`'
- en: '`europe-central2`'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`europe-central2`'
- en: '![](img/B18333_11_7.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_7.jpg)'
- en: 'You now have two VPCs created: `vpc1` with two subnets and `vpc2` with one
    subnet.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在创建了两个 VPC：`vpc1` 包含两个子网，`vpc2` 包含一个子网。
- en: Creating a public VM, vm1, within vpc1/subnet1 using the GCP console
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 vpc1/subnet1 中使用 GCP 控制台创建公共虚拟机 vm1
- en: 'Use the following steps to create a VM in the GCP console:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤在 GCP 控制台中创建虚拟机：
- en: From the navigation menu on the left side, go to **Compute Engine** and then
    **VM instances**. Click the **CREATE INSTANCE** button.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的导航菜单中，转到 **计算引擎** 然后是 **虚拟机实例**。点击 **创建实例** 按钮。
- en: '![](img/B18333_11_8.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_8.jpg)'
- en: 'Then, fill in the VM instance details:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，填写虚拟机实例的详细信息：
- en: '`vm1`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vm1`'
- en: '`us-east1`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us-east1`'
- en: '`us-east1-b`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us-east1-b`'
- en: '**Machine configuration**: **GENERAL-PURPOSE**, **N1** series'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器配置**：**通用型**，**N1** 系列'
- en: '`f1-micro`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f1-micro`'
- en: '`subnet1`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subnet1`'
- en: 'This is shown in the following screenshot:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下屏幕截图中显示：
- en: '![](img/B18333_11_9.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_9.jpg)'
- en: Select the defaults for the other options, and then click on **NETWORKING, DISKS,
    SECURITY, MANAGEMENT, SOLE-TENANCY**.![](img/B18333_11_10.jpg)
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其他选项选择默认设置，然后点击 **网络、磁盘、安全、管理、独占租户**。![图片](img/B18333_11_10.jpg)
- en: Expand the **Networking** option, then go to **Network interfaces**.![](img/B18333_11_11.jpg)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开网络选项，然后转到 **网络接口**。![图片](img/B18333_11_11.jpg)
- en: In the `vpc1` for `subnet1 Ipv4 (10.10.1.0/24)` for **Subnetwork**, and leave
    everything else as the default.![](img/B18333_11_12.jpg)
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `vpc1` 的 `subnet1 Ipv4 (10.10.1.0/24)` 对于 **子网**，并将其他所有内容保留为默认设置。![图片](img/B18333_11_12.jpg)
- en: Click **DONE** and then **CREATE**.![](img/B18333_11_13.jpg)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **完成** 然后点击 **创建**。![图片](img/B18333_11_13.jpg)
- en: At this time, VM1 is created in `vpc1` and `subnet1` (`10.10.1.0/24`), with
    the internal IP address of `10.10.1.2` and the external IP address of `34.148.1.115`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，VM1 已在 `vpc1` 和 `subnet1` (`10.10.1.0/24`) 中创建，内部 IP 地址为 `10.10.1.2`，外部 IP
    地址为 `34.148.1.115`。
- en: '![](img/B18333_11_14.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_14.jpg)'
- en: To allow **Secure Shell** (**SSH**) into this Linux VM, you need to create a
    firewall rule to allow inbound SSH traffic.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许将 **安全外壳协议**（**SSH**）连接到这个Linux虚拟机，你需要创建一个防火墙规则以允许传入的SSH流量。
- en: Select **View network details** from the three dots drop-down menu.![](img/B18333_11_15.jpg)
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从三个点的下拉菜单中选择 **查看网络详情**。![图片](img/B18333_11_15.jpg)
- en: Select **Firewall** and then **CREATE FIREWALL RULE**.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **防火墙**，然后选择 **创建防火墙规则**。
- en: '![](img/B18333_11_16.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_16.jpg)'
- en: 'Fill in the firewall rule details:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写防火墙规则详细信息：
- en: '`vpc1-firewall-rule2`'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vpc1-firewall-rule2`'
- en: '`vpc1`'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vpc1`'
- en: '![](img/B18333_11_17.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_17.jpg)'
- en: Select `0.0.0.0/0` for `22` as the port number (SSH uses port `22`). Then, click
    **CREATE**.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `22` 作为端口号选择 `0.0.0.0/0`（SSH使用端口号 `22`）。然后，点击 **创建**。
- en: '![](img/B18333_11_18.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_18.jpg)'
- en: After the firewall rule is created successfully, go back to the **VM instances**
    page. Select **Open in browser window** from the **SSH** drop-down menu (make
    sure you allow pop-up windows from the browser).![](img/B18333_11_19.jpg)
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在防火墙规则创建成功后，返回 **虚拟机实例** 页面。从 **SSH** 下拉菜单中选择 **在浏览器窗口中打开**（确保你允许浏览器弹出窗口）。![图片](img/B18333_11_19.jpg)
- en: Now you are able to SSH into the VM instance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你能够SSH进入虚拟机实例。
- en: '![](img/B18333_11_20.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_20.jpg)'
- en: You now have a GCP VM, called `vm1`, created in `subnet1` of `vpc1`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经在 `vpc1` 的 `subnet1` 中创建了一个名为 `vm1` 的GCP虚拟机。
- en: Creating a private VM, vm2, within vpc1/subnet2 using the GCP console
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GCP控制台在vpc1/subnet2内创建私有虚拟机vm2
- en: 'Repeat the steps in *the previous section* to create a VM in `vpc1/subnet2`.
    The only changes are as follows:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *上一节* 中的步骤来在 `vpc1/subnet2` 中创建一个VM。唯一的变化如下：
- en: Choose `asia-east1` as the region where `subnet2` sits.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 `asia-east1` 作为 `subnet2` 所在的区域。
- en: Choose `subnet2` as the subnetwork.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 `subnet2` 作为子网。
- en: Choose **None** for **External IPv4 address** since this is a private VM and
    no external IP address is assigned.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **外部IPv4地址** 选择 **无**，因为这是一个私有虚拟机，没有分配外部IP地址。
- en: '![](img/B18333_11_21.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_21.jpg)'
- en: Now, `vm2` is provisioned in `vpc1/subnet2` with the IP address of `10.10.2.2`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`vm2` 已经在 `vpc1/subnet2` 中配置，IP地址为 `10.10.2.2`。
- en: '![](img/B18333_11_22.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_22.jpg)'
- en: Repeat the steps in *Creating a public virtual machine vm1 within the vpc1/subnet1
    using GCP console* to create a firewall rule to allow `ping` within `vpc1` (`10.10.0.0/16`)
    so `vm1` and `vm2` can ping each other since they are in the same VPC.![](img/B18333_11_23.jpg)
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *在vpc1/subnet1内使用GCP控制台创建公共虚拟机vm1* 中的步骤来创建一个防火墙规则，允许 `vpc1`（`10.10.0.0/16`）内的ping，这样
    `vm1` 和 `vm2` 就可以在同一个VPC内ping对方。![图片](img/B18333_11_23.jpg)
- en: Ping `vm2` (`10.10.1.2`) from `vm1`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `vm1` ping `vm2`（`10.10.1.2`）。
- en: '![](img/B18333_11_24.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_24.jpg)'
- en: At this time, you have a GCP VM, `vm2`, created in `subnet2` of `vpc1`, and
    `vm1` can ping `vm2`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，你已经在 `vpc1` 的 `subnet2` 中创建了一个名为 `vm2` 的GCP虚拟机，并且 `vm1` 可以ping `vm2`。
- en: Creating a private VM, vm8, within vpc2/subnet8 using the GCP console
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GCP控制台在vpc2/subnet8内创建私有虚拟机vm8
- en: 'Repeat the steps in *Creating a private virtual machine vm2 within the vpc1/subnet2
    using GCP console* to create a VM in `vpc2/subnet8` (`192.168.1.0/24`), with no
    public IP addresses. The only changes are as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 重复 *在vpc1/subnet2内使用GCP控制台创建私有虚拟机vm2* 中的步骤来在 `vpc2/subnet8`（`192.168.1.0/24`）中创建一个VM，没有公共IP地址。唯一的变化如下：
- en: Choose `europe-central2` as the region where `subnet3` sits.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 `europe-central2` 作为 `subnet3` 所在的区域。
- en: Choose `subnet8` as the subnetwork.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 `subnet8` 作为子网。
- en: Notice that `vm1/vm2` cannot ping `vm8` even if you create firewall rules allowing
    pinging from `vpc1` to `vpc2`, since there are no routes between `vpc1` and `vpc2`.
    That’s why we need to create peering between `vpc1` and `vpc2`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使你创建了允许从 `vpc1` 到 `vpc2` 进行ping的防火墙规则，`vm1/vm2` 也不能ping `vm8`，因为 `vpc1`
    和 `vpc2` 之间没有路由。这就是为什么我们需要在 `vpc1` 和 `vpc2` 之间创建对等连接的原因。
- en: Creating peering between vpc1 and vpc2 using the GCP console
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GCP控制台在vpc1和vpc2之间创建对等连接
- en: 'Use the following steps to create VPC network peering between `vpc1` and `vpc2`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤在 `vpc1` 和 `vpc2` 之间创建VPC网络对等连接：
- en: From the navigation menu, go to **VPC network** and then **VPC network peering**.![](img/B18333_11_25.jpg)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从导航菜单中，转到 **VPC网络**，然后转到 **VPC网络对等连接**。![图片](img/B18333_11_25.jpg)
- en: Create `vpc12-peering` from `vpc1` to `vpc2`.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `vpc1` 到 `vpc2` 创建 `vpc12-peering`。
- en: '![](img/B18333_11_26.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_26.jpg)'
- en: Do the same for `vpc2` to `vpc1` peering, so both peerings will now be active.![](img/B18333_11_27.jpg)
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `vpc2` 到 `vpc1` 的对等连接也做同样的操作，这样现在两个对等连接都将处于活动状态。![图片](img/B18333_11_27.jpg)
- en: Ping `vm8` (`192.168.1.2`) from `vm1`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `vm1` ping `vm8`（`192.168.1.2`）。
- en: '![](img/B18333_11_28.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_11_28.jpg)'
- en: You now have a GCP VM, `vm8`, created in `subnet8` of `vpc2`, and `vm1` can
    ping `vm8`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个在 `vpc2` 的 `subnet8` 中创建的 GCP 虚拟机 `vm8`，`vm1` 可以 ping 通 `vm8`。
- en: Creating a GCS bucket from the GCP console
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 GCP 控制台创建 GCS 存储桶
- en: 'Use the following steps to create a GCS bucket:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤创建 GCS 存储桶：
- en: From the navigation menu, go to **Cloud Storage** and then **Buckets**.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从导航菜单中，转到 **云存储** 然后是 **存储桶**。
- en: '![](img/B18333_11_29.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_11_29.jpg)'
- en: From the new window, click **CREATE BUCKET**.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，点击 **创建存储桶**。
- en: '![](img/B18333_11_30.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_11_30.jpg)'
- en: Choose a globally unique name for the GCP bucket. Here, we use `bucket-08282022`.
    Select **Region** under **Choose where to store your data**, and select **us-east1**
    as the storage bucket region. Click the **CREATE** button.![](img/B18333_11_31.jpg)
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 GCP 存储桶选择一个全局唯一的名称。这里，我们使用 `bucket-08282022`。在 **选择数据存储位置** 下选择 **区域**，并将存储桶区域选择为
    **us-east1**。点击 **创建** 按钮.![](img/B18333_11_31.jpg)
- en: It will bring you to the bucket page, where you can create a subfolder, upload
    files, or upload a folder under the previously created bucket.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您到存储桶页面，您可以在之前创建的存储桶下创建子文件夹，上传文件或上传文件夹。
- en: '![](img/B18333_11_32.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_11_32.jpg)'
- en: So far, we have provisioned GCP resources (VPCs/subnets, VPC peering, VMs, and
    storage) from the console. All of this provisioning can be done using Cloud Shell.
    In the next section, we will provide the Cloud Shell commands/scripts for GCP
    resource provisioning.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从控制台配置了 GCP 资源（VPCs/子网、VPC 对等连接、虚拟机和存储）。所有这些配置都可以使用 Cloud Shell 完成。在下一节中，我们将提供
    Cloud Shell 的 GCP 资源配置命令/脚本。
- en: Provisioning GCP resources using Google Cloud Shell
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Cloud Shell 配置 GCP 资源
- en: Instead of using the GCP console, we can use Google Cloud Shell to provision
    all the resources. In the following example, the GCP architecture is shown in
    *Figure 11.2*, and we use the Cloud Shell commands to provision GCP resources,
    including network VPCs/subnets, VMs, and VPC peering. Please practice using them
    in Cloud Shell, and make sure you understand each step.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 GCP 控制台，我们还可以使用 Google Cloud Shell 来配置所有资源。在以下示例中，GCP 架构显示在 *图 11.2* 中，我们使用
    Cloud Shell 命令来配置 GCP 资源，包括网络 VPCs/子网、虚拟机和 VPC 对等连接。请在 Cloud Shell 中练习使用它们，并确保您理解每一步。
- en: '![](img/B18333_11_33.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_11_33.jpg)'
- en: Figure 11.2 – A sample architecture for GCP Cloud Shell practice
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – GCP Cloud Shell 实践的示例架构
- en: 'Create a project,VPC, and subnet:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目、VPC 和子网：
- en: '[PRE1]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create VMs:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟机：
- en: '[PRE2]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'List all the VMs and write down their IP addresses:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有虚拟机并记下它们的 IP 地址：
- en: '[PRE3]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the firewall for `VPC1`:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `VPC1` 的防火墙：
- en: '[PRE4]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: SSH from the console to `myvm11`, and you should be able to ping `vm12` from
    `vm11`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制台使用 SSH 连接到 `myvm11`，你应该能够从 `vm11` ping 通 `vm12`。
- en: 'But how can we ping from `myvm11` to `myvm2`? You need to create VPC peering
    between `VPC1` and `VPC2` (they are in the same project):'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但如何从 `myvm11` ping 通 `myvm2` 呢？你需要创建 `VPC1` 和 `VPC2` 之间的 VPC 对等连接（它们在同一个项目中）：
- en: '[PRE5]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open a firewall for `vpc2`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `vpc2` 的防火墙：
- en: '[PRE6]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you shall be able to ping `vm2` from `vm11`. But how can we ping from `myvm11`
    to `myvm3`? You need to create VPC peering between `vpc1` and `vpc3` (they are
    in different projects):'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该能够从 `vm11` ping 通 `vm2`。但如何从 `myvm11` ping 通 `myvm3` 呢？你需要创建 `vpc1` 和
    `vpc3` 之间的 VPC 对等连接（它们在不同的项目中）：
- en: '[PRE7]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open a firewall for `vpc3`:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `vpc3` 的防火墙：
- en: '[PRE8]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you shall be able to ping `vm3` from `vm11`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够从 `vm11` ping 通 `vm3`。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, we have provided practice examples to provision GCP services/resources
    from the GCP console. We have also shown how to create these basic resources using
    Google Cloud Shell.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们提供了从 GCP 控制台配置 GCP 服务/资源的实践示例。我们还展示了如何使用 Google Cloud Shell 创建这些基本资源。
- en: Appendix 2
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 2
- en: Practicing Using the Python Data Libraries
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习使用 Python 数据库
- en: In [*Chapter 2*](B18333_02.xhtml#_idTextAnchor054), *Mastering Python Programming*,
    we covered the Python data libraries, including NumPy, Pandas, Matpotlib, and
    Seaborn. In this appendix, we will continue learning these libraries by practicing
    using them on the Google Colab platform ([colab.research.google.com](http://colab.research.google.com)).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18333_02.xhtml#_idTextAnchor054) *精通 Python 编程* 中，我们介绍了 Python
    数据库，包括 NumPy、Pandas、Matplotlib 和 Seaborn。在本附录中，我们将通过在 Google Colab 平台上使用这些库进行实践来继续学习这些库（[colab.research.google.com](http://colab.research.google.com)）。
- en: With a step-by-step approach, we will show how to use these libraries to manage
    and visualize data. For the NumPy library, we will discuss how to generate and
    operate NumPy arrays. For the Pandas library, we cover features including Series,
    DataFrames, missing data handling, GroupBy, and operations. For the Matpotlib
    and Seaborn libraries, we will show their features by exploring multiple data
    visualization examples.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 采用逐步的方法，我们将展示如何使用这些库来管理和可视化数据。对于 NumPy 库，我们将讨论如何生成和操作 NumPy 数组。对于 Pandas 库，我们将涵盖包括
    Series、DataFrames、缺失数据处理、GroupBy 和操作等功能。对于 Matplotlib 和 Seaborn 库，我们将通过探索多个数据可视化示例来展示它们的功能。
- en: Follow these examples and make sure you understand each of them. Practicing
    each example on Google Colab will yield the best results.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下示例进行操作，并确保你理解每一个示例。在 Google Colab 上练习每个示例将获得最佳结果。
- en: NumPy
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy
- en: NumPy is a library for Python that adds support for large, multi-dimensional
    arrays and matrices, along with a large collection of high-level mathematical
    functions to operate on these arrays.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是一个为 Python 提供对大型、多维数组和矩阵支持以及大量高级数学函数来操作这些数组的库。
- en: 'In this section, we will go over the following topics:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下主题：
- en: Generating NumPy arrays
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 NumPy 数组
- en: Operating NumPy arrays
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作 NumPy 数组
- en: We will start with how to generate NumPy arrays.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从如何生成 NumPy 数组开始。
- en: Generating NumPy arrays
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 NumPy 数组
- en: In this section, we will demonstrate various ways to create NumPy arrays. Arrays
    might be one-dimensional or two-dimensional.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示创建 NumPy 数组的各种方法。数组可能是一维的或二维的。
- en: 'Let’s convert a list into a one-dimensional array by using the following code
    (the first line imports the NumPy library and and gives it the alias of `np`):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码将一个列表转换成一维数组（第一行导入 NumPy 库并将其别名为 `np`）：
- en: '[PRE9]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s make our list a little complicated with the following code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码使我们的列表变得稍微复杂一些：
- en: '[PRE10]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that there are two sets of brackets that represent the two-dimensional
    array.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两对括号表示二维数组。
- en: 'One of the basic functions in NumPy is `arange()`, where you can provide start
    and stop values. For example, with `0` as the start value and `10` as the stop
    value, `np.arange()` will generate a one-dimensional array with values from `0`
    to `10` (the last value provided in the function is not included):'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 中的一个基本函数是 `arange()`，你可以提供起始值和结束值。例如，以 `0` 作为起始值，`10` 作为结束值，`np.arange()`
    将生成一个从 `0` 到 `10`（函数中提供的最后一个值不包括在内）的一维数组：
- en: '[PRE11]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s use the same function with some other values/arguments. In the following
    example, we add an additional argument called **step size** to create a one-dimensional
    array, with even numbers:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用相同的函数和一些其他值/参数。在以下示例中，我们添加了一个额外的参数，称为**步长**，以创建一个包含偶数的一维数组：
- en: '[PRE12]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first argument in the `arange` function is the `start` value, the second
    is the `stop` value, and the last one is the step size.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`arange` 函数的第一个参数是起始值，第二个是结束值，最后一个参数是步长。'
- en: 'The other built-in function in NumPy is to generate an array with all zeros.
    We need to provide the argument with how many zeros we want to generate in the
    array, as shown in the following snippet:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的另一个内置函数是生成全为零的数组。我们需要提供参数，说明数组中要生成多少个零，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also provide a tuple as an argument:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提供一个元组作为参数：
- en: '[PRE14]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly, if we need to generate an array with pure ones, we can use the `ones`
    function and provide a number as an argument, as shown here:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们需要生成一个全为 `1` 的数组，我们可以使用 `ones` 函数并提供一个数字作为参数，如下所示：
- en: '[PRE15]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another useful built-in function is `linspace`, where we enter arguments as
    the first number and the last number, evenly spaced between specified intervals.
    Remember that the `arange` function returns all integers between the start and
    stop points, but `linspace` takes a third argument, the number of points we want:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的内置函数是 `linspace`，我们输入的第一个参数是第一个数字，最后一个参数是最后一个数字，它们在指定的区间内均匀分布。记住，`arange`
    函数返回起始点和结束点之间的所有整数，但 `linspace` 还有一个第三个参数，即我们想要的点的数量：
- en: '[PRE16]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous example, there is a one-dimensional array (specified with a
    single bracket), with 10 evenly spaced points between `0` and `5`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，有一个一维数组（用单个括号指定），在 `0` 和 `5` 之间有 10 个等间距的点：
- en: '[PRE17]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that, using the same example with different space points (`25`), the array
    looks like a two-dimensional array, but it is one-dimensional, proven by there
    only being one bracket in front of the array.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用相同的例子和不同的空间点（`25`），数组看起来像二维数组，但实际上是一维的，这可以通过数组前只有一个括号来证明。
- en: 'If you are dealing with linear algebra problems, it is basically a two-dimensional
    square matrix (the same number of rows and columns), where we have a diagonal
    of ones and everything else is zero. That’s why it takes a single digit as an
    argument:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理线性代数问题，它基本上是一个二维的平方矩阵（行数和列数相同），其中有一个全为1的对角线，其余都是0。这就是为什么它只需要一个数字作为参数：
- en: '[PRE18]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'One of the most used functions that will be used here generates an array with
    random numbers, such as the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里将要使用的一个最常用的函数是生成包含随机数的数组，如下所示：
- en: '[PRE19]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we need to return from the standard normal distribution, instead of `rand`,
    we can use the `randn` function:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要从标准正态分布中返回，而不是使用`rand`，我们可以使用`randn`函数：
- en: '[PRE20]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The other function is `randint`, which returns a random single integer between
    the lowest and highest integer values, provided as an argument (the lowest inclusive
    and the highest exclusive):'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数是`randint`，它返回一个介于最低和最高整数值之间的随机整数，这些值作为参数提供（最低值包含在内，最高值不包含）：
- en: '[PRE21]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we need a particular number of random integers between the provided interval,
    we need to provide a third argument:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在提供的区间内生成特定数量的随机整数，我们需要提供一个第三个参数：
- en: '[PRE22]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let’s do some conversion. In the following example, we have generated
    a one-dimensional array with 25 values, saved it in an `array` variable, and then
    reshaped it into a two-dimensional array:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行一些转换。在下面的例子中，我们生成了一个包含25个值的二维数组，将其保存在`array`变量中，然后将其重塑为二维数组：
- en: '[PRE23]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we want to get the maximum or minimum value in the randomly generated array,
    we can use the `array.max()` or `array.min()` function respectively:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取随机生成的数组中的最大值或最小值，我们可以分别使用`array.max()`或`array.min()`函数：
- en: '[PRE24]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we want to pick a single value (or a set of values) from the array provided
    in the preceding example, we can specify this with brackets, as shown here:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从前面例子中提供的数组中选取单个值（或一组值），我们可以用括号指定，如下所示：
- en: '[PRE25]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we want to replace a single value or a set of values in an array, we need
    to set those values as shown here:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在数组中替换单个值或一组值，我们需要将这些值设置如下所示：
- en: '[PRE26]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, values that are in the `0`, `1`, and `2` indexes are replaced
    with values of `100`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，索引为`0`、`1`和`2`的值被替换成了`100`。
- en: Operating NumPy arrays
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作NumPy数组
- en: 'Now, we are going a little deeper and working with a two-dimensional array.
    In the following example, we generated an array with 25 random numbers and reshaped
    it into a two-dimensional array. It then shows a value, which is located on row
    1 and column 1:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进一步深入，处理二维数组。在下面的例子中，我们生成了一个包含25个随机数的数组，并将其重塑为二维数组。然后显示了一个值，它位于第1行第1列：
- en: '[PRE27]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is a function to return a Boolean (`True` or `False`) of the
    array, based on a specific condition:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个函数，根据特定条件返回数组的布尔值（`True`或`False`）：
- en: '[PRE28]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also apply some math, such as addition, subtraction, multiplication,
    and division operations, to an array, as well as applying some functions, such
    as `sin`, `cos`, and `log`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对数组应用一些数学运算，如加法、减法、乘法和除法，以及应用一些函数，如`sin`、`cos`和`log`：
- en: '[PRE29]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have shown some examples using the NumPy library; for more information about
    the library, please refer to [https://numpy.org/](https://numpy.org/).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了使用NumPy库的一些例子；有关库的更多信息，请参阅[https://numpy.org/](https://numpy.org/)。
- en: Pandas
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pandas
- en: Pandas is an open source library that is built on top of NumPy. Pandas allows
    for quick data analysis and data preparation. It excels in performance and productivity.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas是一个基于NumPy构建的开源库。Pandas允许快速的数据分析和数据准备。它在性能和生产率方面表现卓越。
- en: 'In this section, we will discuss the following topics:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下主题：
- en: Series
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列
- en: DataFrames
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据框
- en: Missing data handling
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失数据处理
- en: GroupBy
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组
- en: Operations
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: 'Depending on the environment, you may need to install Pandas first by going
    to your command line or terminal and running the following commands:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 根据环境的不同，你可能需要先通过命令行或终端运行以下命令来安装Pandas：
- en: '[PRE30]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will start by looking at the Series data type.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看序列数据类型。
- en: Series
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列
- en: Series is the first main data type that we will be using with Pandas. Series
    is almost the same as the NumPy array. The difference is that with Series, a series
    of axis labels can be indexed by a label.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Series 是我们将首先与 Pandas 一起使用的第一个主要数据类型。Series 几乎与 NumPy 数组相同。区别在于，使用 Series，可以通过标签对轴标签进行索引。
- en: 'We are going to make four different Python objects and form a list:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建四个不同的 Python 对象并形成一个列表：
- en: '[PRE31]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By default, if we do not specify the index values, it will assign `0, 1, 2,
    ….` Therefore, we can change those labels into labels we created earlier (`labels`):'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们没有指定索引值，它将分配 `0, 1, 2, ….` 因此，我们可以将这些标签更改为我们之前创建的标签（`labels`）：
- en: '[PRE32]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you want to provide a dictionary in a Series, you do not need to provide
    an index, since the dictionary already has its keys and values:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 Series 中提供一个字典，您不需要提供索引，因为字典已经有了其键和值：
- en: '[PRE33]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A Series can hold any data types, and we can provide labels too:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Series 可以持有任何数据类型，我们也可以提供标签：
- en: '[PRE34]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: DataFrames
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DataFrames
- en: 'A DataFrame is a two-dimensional labeled data structure with columns of different
    types. In this section, we will start building our first DataFrame using Pandas.
    In the following example, we have created a random number generated by NumPy and
    built a nice view with labels (rows and columns) with Pandas:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 是一个二维带标签的数据结构，具有不同类型的列。在本节中，我们将开始使用 Pandas 构建我们的第一个 DataFrame。在以下示例中，我们使用
    NumPy 创建了一个随机数，并使用 Pandas 建立了一个带有标签（行和列）的漂亮视图：
- en: '[PRE35]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you want to display a specific row of a DataFrame, specify the name of the
    row in the brackets:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想显示 DataFrame 的特定行，请在括号中指定行的名称：
- en: '[PRE36]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that the output is a Series, which we have covered before. If you want
    to check the type of the output, use the `type` syntax, as shown here:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出是一个 Series，我们之前已经介绍过。如果您想检查输出类型，请使用 `type` 语法，如下所示：
- en: '[PRE37]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you want to display multiple columns from the DataFrame, you can specify
    them in brackets as a list:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想显示 DataFrame 的多个列，可以在括号中指定它们作为一个列表：
- en: '[PRE38]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another feature of the DataFrame is being able to add new columns to it. When
    adding a new column, we need to specify the values of the new column. In the following
    example, we are creating a new column, `new`, and we will sum all the values from
    `x` and `y` and add them to it:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 的另一个特性是能够向其中添加新列。当添加新列时，我们需要指定新列的值。在以下示例中，我们正在创建一个新列 `new`，并将 `x`
    和 `y` 的所有值相加并添加到其中：
- en: '[PRE39]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you want to delete a particular column or row, you can use the built-in
    `drop` function:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想删除特定的列或行，可以使用内置的 `drop` 函数：
- en: '[PRE40]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you need to get output from a specific row, you can use the `loc` syntax,
    which stands for `location`, and you need to specify a row name as an argument:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要从特定行获取输出，您可以使用 `loc` 语法，它代表 `location`，并且您需要指定一个行名作为参数：
- en: '[PRE41]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Conditional selection is also a feature of Pandas, where you can call data
    as a Boolean (`True` or `False`) in a DataFrame:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 条件选择也是 Pandas 的一个特性，您可以在 DataFrame 中将数据作为布尔值（`True` 或 `False`）调用：
- en: '[PRE42]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Missing data handling
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失数据处理
- en: 'In the DataFrame we created earlier, if we apply some conditions (such as greater
    than zero), data that is less than zero will be displayed as `NaN` (null data).
    If you need to display only rows and columns that do not have `null` data, use
    the `dropna` syntax, as shown here:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前创建的 DataFrame 中，如果我们应用一些条件（例如大于零），小于零的数据将显示为 `NaN`（空数据）。如果您只想显示没有 `null`
    数据的行和列，请使用 `dropna` 语法，如下所示：
- en: '[PRE43]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we are going to apply a condition and save a new DataFrame (`new_df`)
    with values that are greater than zero, as shown here:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将应用一个条件并保存一个新的 DataFrame (`new_df`)，其中包含大于零的值，如下所示：
- en: '[PRE44]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the cells that do not have any value (`NaN`), we are going to replace them
    with the mean (average) of all values in that column:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有任何值（`NaN`）的单元格，我们将用该列所有值的平均值（平均数）替换它们：
- en: '[PRE45]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that the value in the `x` column and `c` row is not null and is replaced
    with a value.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`x` 列和 `c` 行的值不是空值，并替换了值。
- en: GroupBy
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GroupBy
- en: GroupBy allows you to group together rows based on columns and perform an aggregate
    function on them.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: GroupBy 允许您根据列将行分组并对它们执行聚合函数。
- en: 'In the next example, we will create a new DataFrame using the dictionary, as
    shown here:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将使用字典创建一个新的 DataFrame，如下所示：
- en: '[PRE46]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you are working with a large DataFrame and want to print the sum of the
    sales of each country, use the `groupby` built-in function, as shown here:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理一个大的 DataFrame 并且想打印每个国家的销售额总和，请使用 `groupby` 内置函数，如下所示：
- en: '[PRE47]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Operations
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作
- en: In this section, we will show some real-life data operations. In the next examples,
    we are going to use a CSV file, `Salaries.csv` (taken from [https://www.kaggle.com/kaggle/sf-salaries?select=Salaries.csv](https://www.kaggle.com/kaggle/sf-salaries?select=Salaries.csv)).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示一些实际的数据操作。在接下来的示例中，我们将使用一个 CSV 文件，`Salaries.csv`（来自[https://www.kaggle.com/kaggle/sf-salaries?select=Salaries.csv](https://www.kaggle.com/kaggle/sf-salaries?select=Salaries.csv)）。
- en: After downloading the file to a local computer and uploading it to Google Colab,
    you can visualize the DataFrame and explore the data using the Pandas library.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地计算机上下载文件并将其上传到 Google Colab 后，您可以使用 Pandas 库可视化 DataFrame 并探索数据。
- en: 'Use the `read_csv` function to read the CSV file, as shown here:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `read_csv` 函数读取 CSV 文件，如下所示：
- en: '[PRE48]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![](img/B18333_12_1.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_12_1.jpg)'
- en: '[PRE49]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding sections, we have shown the basic features of the Pandas library.
    For more information on Pandas features, please refer to [https://pandas.pydata.org](https://pandas.pydata.org).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经展示了 Pandas 库的基本功能。有关 Pandas 功能的更多信息，请参阅[https://pandas.pydata.org](https://pandas.pydata.org)。
- en: Matplotlib
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib
- en: Matplotlib is one of the essential libraries of data visualization in Python.
    It is an excellent two-dimensional and three-dimensional graphics library for
    generating scientific figures.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是 Python 中数据可视化的重要库之一。它是一个出色的二维和三维图形库，用于生成科学图表。
- en: 'Some of the major pros of Matplotlib are as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 的一些主要优点如下：
- en: Generally easy to get started with simple plots
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，简单的图表很容易上手
- en: Support for custom labels and text
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持自定义标签和文本
- en: Great control of every element in a figure
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对图表中每个元素都有很好的控制
- en: High-quality output in many formats
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种格式的输出质量高
- en: Very customizable in general
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常非常易于定制
- en: 'We will start with simple data generated by the NumPy library:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 NumPy 库生成简单数据：
- en: '[PRE50]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have generated data using the `linspace` function in the NumPy library.
    We can also play with all our data (in our case, it is an array), such as taking
    each number in an array and squaring it:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy 库中的 `linspace` 函数生成数据。我们还可以玩转我们的所有数据（在我们的例子中，它是一个数组），例如，取数组中的每个数字并将其平方：
- en: '[PRE51]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can plot the data in a graph with a simple function in Matplotlib:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Matplotlib 中的一个简单函数在图表中绘制数据：
- en: '[PRE52]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![](img/B18333_12_2.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_12_2.jpg)'
- en: 'You can rearrange the `x` and `y` axes with `a` and `b` values, as shown here:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `a` 和 `b` 值重新排列 `x` 和 `y` 轴，如下所示：
- en: '[PRE53]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](img/B18333_12_3.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_12_3.jpg)'
- en: 'So far, we have demonstrated how to plot using the `plot` and `subplot` methods.
    Now, we are going to dive into object-oriented methods, where we will break down
    all for a more formal introduction of the `matplotlib` object-oriented API method.
    In the following example, we run a built-in `figure` function, which builds an
    imaginary blank canvas, and later on, we will add a set to this canvas so that
    it will work more flexibly:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何使用 `plot` 和 `subplot` 方法进行绘图。现在，我们将深入探讨面向对象的方法，其中我们将对所有内容进行更正式的介绍，即
    `matplotlib` 面向对象 API 方法。在下面的示例中，我们运行一个内置的 `figure` 函数，它构建一个想象中的空白画布，稍后我们将在这个画布上添加一组图形，使其更加灵活：
- en: '[PRE54]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![](img/B18333_12_4.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_12_4.jpg)'
- en: The very first step is to add axes to the canvas using the `add_axes` function.
    The numbers in the brackets represent the left, the button, the width, and the
    height of the axes.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用 `add_axes` 函数在画布上添加轴。括号中的数字表示轴的左侧、底部、宽度和高度。
- en: 'Each number should be between zero and one, representing a percentage, numbers
    representation:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数应在零和一之间，表示百分比，数字表示法：
- en: The first number (0.1) represents 10 percent from the left of the canvas.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数（0.1）表示从画布左侧的 10%。
- en: The second number (0.1) represents 10 percent from the bottom.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个数（0.1）表示从画布底部的 10%。
- en: The third number (0.8) represents the percentage of axes from the canvas (width).
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个数（0.8）表示轴从画布（宽度）的百分比。
- en: The fourth number (0.8) represents the percentage of axes from the canvas (height).
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个数（0.8）表示轴从画布（高度）的百分比。
- en: 'In the preceding example, we generated `a` and `b` values using NumPy and plotted
    them in our custom canvas/axes using object-oriented methods, which gives us more
    control. Using some other functions, we can set names for each axis and title,
    as shown here:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用 NumPy 生成 `a` 和 `b` 值，并使用面向对象的方法在我们的自定义画布/轴上绘制它们，这为我们提供了更多的控制。使用一些其他函数，我们可以为每个轴和标题设置名称，如下所示：
- en: '[PRE55]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![](img/B18333_12_5.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_12_5.jpg)'
- en: 'Now, let’s put two sets of figures on the same canvas:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一画布上放置两组图形：
- en: '[PRE56]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![](img/B18333_12_6.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_6.jpg)'
- en: 'In the next example, we have plotted two sets in the same figure and also added
    some labels, using the `label` and `legend` methods:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们在同一张图上绘制了两组数据，并添加了一些标签，使用了`label`和`legend`方法：
- en: '[PRE57]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![](img/B18333_12_7.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_7.jpg)'
- en: We have shown some examples using the Matplotlib library; for more detailed
    information, please refer to [https://matplotlib.org](https://matplotlib.org).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了使用Matplotlib库的一些示例；对于更详细的信息，请参阅[https://matplotlib.org](https://matplotlib.org)。
- en: Seaborn
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 海报恩
- en: Seaborn is a statistical library built on top of the Matplotlib library, and
    all the Matplotlib knowledge that we have learned can be applied to Seaborn.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 海报恩是一个基于Matplotlib库构建的统计库，我们所学到的所有Matplotlib知识都可以应用于海报恩。
- en: 'We will start with a simple importing library. One of the useful features of
    Seaborn is its built-in datasets. In our case, we are going to use the `tips`
    dataset:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的导入库开始。海报恩的一个有用功能是其内置的数据集。在我们的案例中，我们将使用`tips`数据集：
- en: '[PRE58]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can also check out some other details (such as the number of columns and
    rows, and data types) by using the `.info()` function, as shown here:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用`.info()`函数检查一些其他细节（例如列数、行数和数据类型），如下所示：
- en: '[PRE59]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The example here shows a very basic histogram, where we set the dataset name
    as `tips` and the `total_bill` data (one of the columns of our dataset):'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个非常基本的直方图，我们将数据集名称设置为`tips`和`total_bill`数据（我们数据集的一列）：
- en: '[PRE60]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![](img/B18333_12_8.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_8.jpg)'
- en: '[PRE61]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![](img/B18333_12_9.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_9.jpg)'
- en: The `displot` function described previously has different arguments that you
    can set to modify your graph/histogram. Note that we have entered two arguments,
    `kde` and `bins`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的`displot`函数有不同的参数可以设置以修改您的图表/直方图。请注意，我们已输入两个参数，`kde`和`bins`。
- en: 'Next, we are going to explore different types of graphs using the `jointplot`
    function. You need to provide the `x` value, the `y` value, and the data name
    as arguments, as shown here:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`jointplot`函数探索不同类型的图表。您需要提供`x`值、`y`值和数据名称作为参数，如下所示：
- en: '[PRE62]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![](img/B18333_12_10.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_10.jpg)'
- en: 'Note that the arguments we provided (`total_bill` and `tips`) are from data
    we imported, and they are the column names. It is a two-distribution plot, and
    in between, we have a scatter plot. As the bill value increases on the plot, the
    tip value also increases. `jointplot` also has other arguments that can help you
    to modify the graph (by default, it is a scatter plot, but you can also pass the
    hex argument), as shown here:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们提供的参数（`total_bill`和`tips`）来自我们导入的数据，它们是列名。这是一个双分布图，中间有一个散点图。随着账单价值的增加，小费价值也增加。`jointplot`也有其他参数可以帮助您修改图表（默认情况下是散点图，但您也可以传递hex参数），如下所示：
- en: '[PRE63]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![](img/B18333_12_11.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_11.jpg)'
- en: 'The next Seaborn features/functions we will introduce are box plots and violin
    plots. These types of plots are used to show the distribution of categorical data.
    They show the distribution of quantitative data in a way that facilitates comparison
    between variables:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要介绍的海报恩功能/函数是箱形图和小提琴图。这些类型的图表用于显示分类数据的分布。它们以便于比较变量的方式显示定量数据的分布：
- en: '[PRE64]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![](img/B18333_12_12.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_12.jpg)'
- en: 'The violin plot, unlike the box plot, allows you to actually plot all the components
    that correspond to actual data points, and it essentially shows the kernel density
    estimation of the underlying distribution:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 与箱形图不同，小提琴图允许您实际绘制与实际数据点相对应的所有组件，并且它本质上显示了潜在分布的核密度估计：
- en: '[PRE65]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![](img/B18333_12_13.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_13.jpg)'
- en: By adding more arguments to the `violinplot` function, you can add different
    features and details to the graph, as shown here.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`violinplot`函数添加更多参数，您可以向图表添加不同的功能和细节，如下所示。
- en: '[PRE66]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '![](img/B18333_12_14.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_12_14.jpg)'
- en: So far, we have shown the Seaborn library features via several examples. There
    are many different visual representations that use the Seaborn library in Python.
    Check out the Seaborn website ([https://seaborn.pydata.org/index.xhtml](https://seaborn.pydata.org/index.xhtml))
    for more details
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过几个示例展示了海报恩库的功能。Python中有很多不同的视觉表示使用海报恩库。请访问海报恩网站([https://seaborn.pydata.org/index.xhtml](https://seaborn.pydata.org/index.xhtml))获取更多详细信息。
- en: Summary
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, we practices using the Python data libraries, including NumPy,
    Pandas, Matpotlib, and Seaborn. Thoroughly understanding these examples will help
    you to understand the data libraries and master Python programming skills.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们练习使用Python数据库，包括NumPy、Pandas、Matplotlib和Seaborn。彻底理解这些示例将帮助您理解数据库并掌握Python编程技能。
- en: 'Appendix 3: Practicing with Scikit-Learn'
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录3：使用Scikit-Learn进行练习
- en: In [*Chapter 3*](B18333_03.xhtml#_idTextAnchor072), *Preparing for ML Development*,
    and [*Chapter 4*](B18333_04.xhtml#_idTextAnchor094), *Developing and Deploying
    ML Models*, we discussed the data preparation and ML model development process.
    In this appendix, we will continue learning about ML modeling skills by practicing
    using the scikit-learn package on the Google Colaboratory platform ([colab.research.google.com](http://colab.research.google.com)).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18333_03.xhtml#_idTextAnchor072)“准备ML开发”和[*第4章*](B18333_04.xhtml#_idTextAnchor094)“开发和部署ML模型”中，我们讨论了数据准备和ML模型开发过程。在本附录中，我们将通过在Google
    Colaboratory平台上使用scikit-learn包来练习ML建模技能([colab.research.google.com](http://colab.research.google.com))。
- en: 'With a step-by-step approach, we will show you how to develop ML models leveraging
    the scikit-learn library. We will cover the following practices:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 采用逐步方法，我们将向您展示如何利用scikit-learn库开发ML模型。我们将涵盖以下实践：
- en: Data preparation
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据准备
- en: Regression
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归
- en: Classification
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类
- en: It is a best practice to follow these examples and make sure you understand
    each of them. Practicing each example on Google Colab will yield the best results.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些示例并确保您理解每个示例是一个最佳实践。在Google Colab上练习每个示例将产生最佳结果。
- en: Data preparation
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据准备
- en: 'In the previous chapters, we discussed Python libraries such as NumPy, Pandas,
    Matplotlib, and Seaborn for processing and visualizing data. Let’s start with
    simply importing the libraries:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了用于处理和可视化数据的Python库，如NumPy、Pandas、Matplotlib和Seaborn。让我们从简单地导入库开始：
- en: '[PRE67]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We will use a simple dataset that has only 4 columns and 10 rows.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个只有4列和10行的简单数据集。
- en: '![](img/B18333_13_1.jpg)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_13_1.jpg)'
- en: Notice that some of the columns are categorical and others are numerical, and
    some of them have missing values that we need to fix. The dataset `.csv` file
    is uploaded to Google Colab.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到一些列是分类的，而另一些是数值的，其中一些列有缺失值，我们需要修复。数据集`.csv`文件已上传到Google Colab。
- en: '![](img/B18333_13_2.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_13_2.jpg)'
- en: 'Using the `pandas` library and the `read_csv` function, we read the data and
    save it to a variable dataset, assign the first three columns (`X`, and assign
    the last column dataset to `y`, as the prediction:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pandas`库和`read_csv`函数，我们读取数据并将其保存到变量`dataset`中，将前三个列（`X`）分配给`y`，作为预测：
- en: '[PRE68]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that it has some missing values. In the ML training process, we need to
    minimize the number of missing values, so you can either delete the rows containing
    missing data cells or replace the missing values with an input value, for example,
    the average of all values in that column. The following example is the filling
    of missing values with the mean/average of that particular column:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到它有一些缺失值。在ML训练过程中，我们需要最小化缺失值的数量，因此您可以选择删除包含缺失数据单元格的行，或者用输入值（例如，该列所有值的平均值）替换缺失值。以下示例是使用该特定列的平均值/平均值填充缺失值：
- en: '[PRE69]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The next step is to convert categorical values to numerical values. In our
    loaded dataset (`‘data.cvs’`), the name of the column is `Country` and it has
    three different values (`France`, `Spain`, and `Germany`). We are going to convert
    it to three columns with binary values using one-hot encoding:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将分类值转换为数值。在我们的加载的数据集(`‘data.cvs’`)中，列名为`Country`，有三个不同的值（`France`、`Spain`和`Germany`）。我们将使用独热编码将其转换为具有二进制值的三个列：
- en: '[PRE70]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We also need to encode the very last column of our dataset (where values are
    `Yes` or `No` only) to zeros and ones:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将数据集的最后一个列（其中值仅为`Yes`或`No`）编码为零和一：
- en: '[PRE71]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The next step is to split them into training and testing datasets:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将它们分成训练集和测试集：
- en: '[PRE72]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now we have practiced the basic data processing skills, let’s get into feature
    scaling before starting training ML models. There are two types of feature scaling:
    standardization and normalization. The goal is to have all values of the features
    in the same range. Let’s examine the train data:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经练习了基本的数据处理技能，在开始训练ML模型之前，让我们先进行特征缩放。有两种类型的特征缩放：标准化和归一化。目标是使所有特征值都在相同的范围内。让我们检查训练数据：
- en: '![](img/B18333_13_3.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_13_3.jpg)'
- en: 'We find that the very first three rows were encoded previously, so we will
    apply feature scaling for rows 4 and 5 only:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现前三个行之前已经被编码，所以我们将只对第4行和第5行应用特征缩放：
- en: '[PRE73]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that the outcome of `X_train` is between -2 and +2 (avery short range).
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`X_train`的结果介于-2和+2之间（范围非常短）。
- en: Regression
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归
- en: 'Now we have split the datasets and transformed the data, we will show you how
    to use the scikit-learn library to build up ML models. We will start with regression
    and show you the following examples:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拆分了数据集并转换了数据，我们将向您展示如何使用scikit-learn库构建机器学习模型。我们将从回归开始，并展示以下示例：
- en: Simple linear regression
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单线性回归
- en: Multiple linear regression
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多元线性回归
- en: Polynomial/non-linear regression
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式/非线性回归
- en: Simple linear regression
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单线性回归
- en: 'First things first, we need to prepare the dataset:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要准备数据集：
- en: '[PRE74]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we can start training our regression model. We need to import a class and
    feed our training data:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始训练我们的回归模型了。我们需要导入一个类并输入我们的训练数据：
- en: '[PRE75]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we are going to predict the results of the observation in the test set:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将预测测试集中观察结果：
- en: '[PRE76]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s plot our prediction and real data to see how close they are:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制我们的预测数据和实际数据，看看它们有多接近：
- en: '[PRE77]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](img/B18333_13_4.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_13_4.jpg)'
- en: '[PRE78]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '![](img/B18333_13_5.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_13_5.jpg)'
- en: As you can see, the simple linear regression model fits well with our datasets.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，简单线性回归模型与我们的数据集拟合得很好。
- en: Multiple linear regression
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多元线性回归
- en: 'In this section, we are going to use another dataset, which has multiple columns
    as data features and one for the predictor:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用另一个数据集，该数据集有多个列作为数据特征，一个作为预测变量：
- en: '![](img/B18333_13_6.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_13_6.jpg)'
- en: 'First, we perform the data preparation:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们进行数据准备：
- en: Import the necessary libraries and/or classes.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库和/或类。
- en: Split the dataset into `X` (features) and `y` (predictors).
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集拆分为`X`（特征）和`y`（预测变量）。
- en: Encode column index 3 (state names have been converted to binary values and
    saved as three additional columns).
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码列索引3（状态名称已转换为二进制值并保存为三个额外的列）。
- en: 'Split the data into training and testing:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据拆分为训练集和测试集：
- en: '[PRE79]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can start training our model now:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始训练我们的模型了：
- en: '[PRE80]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And now is the time to validate/test our model. We cannot visualize as we did
    in the simple linear regression, since we have four different features and cannot
    plot them in a 5-dimensional graph. However, we can display two vectors: vectors
    of the *real profit* in the test set, and the *predicted profit*:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是验证/测试我们模型的时候了。由于我们有四个不同的特征，无法在五维图中绘制它们，所以我们不能像在简单线性回归中那样可视化。然而，我们可以显示两个向量：测试集中的*实际利润*向量和*预测利润*向量：
- en: '[PRE81]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The left side of the output indicates the predicted profits, and the right side
    indicates the real profits.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 输出左边的部分表示预测利润，右边的部分表示实际利润。
- en: Polynomial/non-linear regression
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式/非线性回归
- en: In this section, we will show examples of non-linear regression, where the relationship
    between the target and the feature(s) is not linear, that is, it is polynomial.
    We will use a linear model and a non-linear model, and compare how they fit to
    the real datasets.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示非线性回归的示例，其中目标变量与特征之间的关系不是线性的，即它是多项式的。我们将使用线性模型和非线性模型，并比较它们如何拟合真实数据集。
- en: 'We will start with the data preparation:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从数据准备开始：
- en: '[PRE82]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we are going to train two models: linear regression and polynomial regression.
    The following example shows both regression models:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将训练两个模型：线性回归和多项式回归。以下示例展示了这两个回归模型：
- en: '[PRE83]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Next, we will visualize both regressions.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将可视化这两个回归模型。
- en: 'This is the linear regression:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是线性回归：
- en: '[PRE84]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '![](img/B18333_13_7.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_13_7.jpg)'
- en: 'Then, this is the polynomial regression:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这是多项式回归：
- en: '[PRE85]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![](img/B18333_13_8.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_13_8.jpg)'
- en: 'As we can see, polynomial regression (we used the power of `2`) yields accurate
    predictions. If we go with higher powers, we will harvest better results. In the
    following examples, we will change the power to `4` (see line 2), and the result
    will fit the dataset much better:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，多项式回归（我们使用了`2`的幂）产生了准确的预测。如果我们使用更高的幂，我们将获得更好的结果。在以下示例中，我们将幂改为`4`（见第2行），结果将更好地拟合数据集：
- en: '[PRE86]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '![](img/B18333_13_9.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_13_9.jpg)'
- en: So far, we have covered the regression modeling process by practicing simple
    linear regression, multiple linear regression, and non-linear regression. In the
    next section, we will discuss classification models.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过练习简单线性回归、多元线性回归和非线性回归来覆盖了回归建模过程。在下一节中，我们将讨论分类模型。
- en: Classification
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类
- en: Unlike regression, where you predict a continuous number, you use classification
    to predict a category. We will cover logistic regression here.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 与回归不同，在回归中您预测一个连续的数字，而分类用于预测一个类别。在这里我们将介绍逻辑回归。
- en: We will use a dataset of historical data of iPhone purchases, based on the age
    and the salary of the buyers, to predict whether a new potential buyer will purchase
    an iPhone.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基于购买者的年龄和薪水的 iPhone 购买历史数据集来预测一个新潜在购买者是否会购买 iPhone。
- en: '![](img/B18333_13_10.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_13_10.jpg)'
- en: 'Let’s do the preparation first:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先进行准备：
- en: '[PRE87]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note that all values are between -3 and +3\.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有值都在 -3 和 +3 之间。
- en: 'Next, we train the logistic regression model:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们训练逻辑回归模型：
- en: '[PRE88]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Let’s predict a new result. Before running prediction scripts, let’s take a
    look into our original dataset and pick up a random feature set (in our case,
    the age of `30` and salary of `87000`), and the result is `0`.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们预测一个新的结果。在运行预测脚本之前，让我们查看我们的原始数据集并选择一个随机特征集（在我们的案例中，是 `30` 岁和 `87000` 的薪水），结果是
    `0`。
- en: 'After running the prediction function, the result is also the same:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 运行预测函数后，结果也是相同的：
- en: '[PRE89]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The following example demonstrates the comparison of the actual and predicted
    results for the testing dataset so we can compare the accuracy/efficiency of the
    trained model:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了测试数据集的实际结果与预测结果的比较，以便我们可以比较训练模型的准确性和效率：
- en: '[PRE90]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output we have in the preceding code shows the comparison: the first column
    is the predicted value and the second column is the real value. To calculate the
    accuracy/efficiency of the model, we can divide the total of the correct number
    in the prediction by the total number of actual numbers in the testing dataset,
    and construct its confusion matrix:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的输出显示了比较：第一列是预测值，第二列是实际值。为了计算模型的准确性和效率，我们可以将预测中正确数量的总和除以测试数据集中实际数量的总和，并构建其混淆矩阵：
- en: '[PRE91]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output shows the following:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示以下内容：
- en: '[PRE92]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The accuracy/efficiency of the model is 83%.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的准确性和效率为 83%。
- en: Summary
  id: totrans-662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, we have shown examples of data preparation and model development
    (regression and classification) using the scikit-learn library. Going over these
    examples and understanding the process will help in your understanding of ML concepts
    and processes.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们展示了使用 scikit-learn 库进行数据准备和模型开发（回归和分类）的示例。通过了解这些示例和过程，将有助于您理解机器学习概念和流程。
- en: Appendix 4
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 4
- en: Practicing with Google Vertex AI
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Vertex AI 进行实践
- en: 'In [*Chapter 7*](B18333_07.xhtml#_idTextAnchor143), *Exploring Google Cloud
    Vertex AI*, we discussed Google Cloud Vertex AI. This appendix contains some hands-on
    tutorials for Google Vertex AI in the Google Cloud console, step by step. We will
    cover the following labs:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 7 章*](B18333_07.xhtml#_idTextAnchor143) “探索 Google Cloud Vertex AI” 中，我们讨论了
    Google Cloud Vertex AI。本附录包含一些 Google Cloud 控制台中 Vertex AI 的动手教程，步骤详尽。我们将涵盖以下实验室：
- en: Vertex AI – enabling its API
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 启用其 API
- en: Vertex AI – datasets
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 数据集
- en: Vertex AI – labeling tasks
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 标注任务
- en: Vertex AI – training
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 训练
- en: Vertex AI – predictions (Vertex AI Endpoint)
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 预测（Vertex AI 端点）
- en: Vertex AI – predictions (Vertex AI Batch Prediction)
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 预测（Vertex AI 批量预测）
- en: Vertex AI – Workbench
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 工作台
- en: Vertex AI – Feature Store
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 特征存储
- en: Vertex AI – pipelines and metadata
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 管道和元数据
- en: Vertex AI – model monitoring
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI – 模型监控
- en: You are expected to follow these labs to practice Vertex AI and gain implementation
    skills.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要按照这些实验室进行练习，以掌握 Vertex AI 的使用并获取实施技能。
- en: Vertex AI – enabling its API
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 启用其 API
- en: 'To start using Vertex AI in the Google Cloud console, you will need to set
    up a billing account and create a project. Once you have created a project (*Vertex
    AI – demo documentation*), you will be on the following project home dashboard:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在 Google Cloud 控制台中使用 Vertex AI，您需要设置一个计费账户并创建一个项目。一旦您创建了项目（*Vertex AI –
    demo documentation*），您将进入以下项目主页仪表板：
- en: '![](img/B18333_14_1.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_1.jpg)'
- en: 'Navigate through the top-left menu to launch Vertex AI:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 通过左上角的菜单导航以启动 Vertex AI：
- en: '![](img/B18333_14_2.jpg)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_2.jpg)'
- en: 'To launch Vertex AI for the first time, you need to enable the Vertex AI API.
    To do so, select a **Region** and click on the blue **ENABLE VERTEX AI API** button:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 要首次启动Vertex AI，您需要启用Vertex AI API。为此，选择一个**区域**并点击蓝色**启用Vertex AI API**按钮：
- en: f
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: f
- en: '![](img/B18333_14_3.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_14_3.jpg)'
- en: After enabling the Vertex AI API, by default, you will land on the Vertex AI
    API dashboard.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 启用Vertex AI API后，默认情况下，您将进入Vertex AI API仪表板。
- en: Vertex AI – datasets
  id: totrans-687
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 数据集
- en: 'The very first tool we will use in Vertex AI is **Datasets**. After clicking
    on **Datasets**, you will be taken to the respective page. Since we are working
    on a brand new project, there is no dataset to display. Click on **CREATE DATASET**
    to get started:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Vertex AI中使用的第一个工具是**数据集**。点击**数据集**后，您将被带到相应的页面。由于我们正在处理一个全新的项目，没有数据集可以显示。点击**创建数据集**开始：
- en: '![](img/B18333_14_4.jpg)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_14_4.jpg)'
- en: 'Enter the name of your dataset and select a dataset type to work with from
    the following four main categories:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您数据集的名称，并从以下四个主要类别中选择一个数据集类型来工作：
- en: '**Image**:'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**:'
- en: '**Image classification (Single-label)**'
  id: totrans-692
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像分类（单标签**）'
- en: '**Image classification (Multi-label)**'
  id: totrans-693
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像分类（多标签**）'
- en: '**Image object detection**'
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像目标检测**'
- en: '**Image segmentation**'
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像分割**'
- en: '**Tabular**:'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格**:'
- en: '**Regression/classification**'
  id: totrans-697
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归/分类**'
- en: '**Forecasting**'
  id: totrans-698
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测**'
- en: '**Text**:'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**:'
- en: '**Text classification (Single-label)**'
  id: totrans-700
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本分类（单标签**）'
- en: '**Text classification (Multi-label)**'
  id: totrans-701
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本分类（多标签**）'
- en: '**Text entity extraction**'
  id: totrans-702
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本实体提取**'
- en: '**Text sentiment analysis**'
  id: totrans-703
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本情感分析**'
- en: '**Video**:'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频**:'
- en: '**Video action recognition**'
  id: totrans-705
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频动作识别**'
- en: '**Video classification**'
  id: totrans-706
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频分类**'
- en: '**Video object tracking**'
  id: totrans-707
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频目标跟踪**'
- en: 'After selecting a dataset type, a bucket will be created in Google Cloud Storage
    as the default dataset repository. Here, you can specify the region where your
    bucket will be created:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数据集类型后，将在Google Cloud Storage中创建一个存储桶作为默认数据集存储库。在这里，您可以指定您的存储桶将在哪个区域创建：
- en: '![](img/B18333_14_5.jpg)'
  id: totrans-709
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_14_5.jpg)'
- en: 'Click on the **CREATE** button. You will be brought to the next page, where
    you need to specify the import method. There are three options for importing data:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。您将被带到下一页，在那里您需要指定导入方法。有三种导入数据的方法：
- en: '**Upload images from your computer**'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从您的计算机上传图片**'
- en: '**Upload import files from your computer**'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从您的计算机上传导入文件**'
- en: '**Select import files from Cloud Storage**'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从云存储选择导入文件**'
- en: 'To select a file(s) from your local computer, click on the **SELECT FILES**
    button:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 要从您的本地计算机选择文件，请点击**选择文件**按钮：
- en: '![](img/B18333_14_6.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_14_6.jpg)'
- en: 'On the page that appears, navigate to the folder that contains your pictures
    on your local computer and then select one or more pictures that you want to upload
    to your dataset. Note that you can upload up to 500 images per upload. The pictures
    that you upload should be in one of the following formats:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的页面上，导航到包含您本地计算机上图片的文件夹，然后选择您想要上传到数据集的一个或多个图片。请注意，您每次上传最多可以上传500张图片。您上传的图片应该是以下格式之一：
- en: JPEG
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPEG
- en: GIF
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GIF
- en: PNG
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PNG
- en: BMP
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BMP
- en: ICO
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ICO
- en: If you need to upload more pictures, you need to click on the **SELECT FILES**
    button and specify which Google Cloud bucket you want to use for your dataset.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要上传更多图片，您需要点击**选择文件**按钮并指定您想用于数据集的Google Cloud存储桶。
- en: 'Once the pictures have been uploaded, you can browse all the images in the
    dataset and check their status (they will be either **Labeled** or **Unlabeled**).
    As shown in the following screenshot, we have a total of 20 images and all of
    them are unlabeled (labeling tasks will be covered in the next section):'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图片上传完毕，您可以在数据集中浏览所有图片并检查它们的状态（它们将是**已标记**或**未标记**）。如下面的截图所示，我们总共有20张图片，它们都是未标记的（标记任务将在下一节中介绍）：
- en: '![](img/B18333_14_7.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_14_7.jpg)'
- en: 'If you wish to use the other two options for adding images to a dataset – **Upload
    import files from your computer** and **Select import files from Cloud Storage**
    – you can simply provide a link to Cloud Storage, as shown in the following screenshot:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用其他两种将图片添加到数据集的方法——**从您的计算机上传导入文件**和**从云存储选择导入文件**——您可以简单地提供一个指向云存储的链接，如下面的截图所示：
- en: '![](img/B18333_14_8.jpg)'
  id: totrans-726
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_14_8.jpg)'
- en: The other three categories (**Tabular**, **Text**, and **Video**) follow the
    same procedure in that you must create a dataset and upload files either from
    your local computer or from Google Cloud Storage. You must also enter a dataset
    name and select a region from the options provided.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个类别（**表格**、**文本**和**视频**）遵循相同的程序，您必须创建数据集并从您的本地计算机或Google Cloud Storage上传文件。您还必须输入数据集名称并从提供的选项中选择一个区域。
- en: Vertex AI – labeling tasks
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 标注任务
- en: 'In this section, you will learn how to label data in Vertex AI. There are several
    ways to label data within a created dataset. If you use a small-size dataset,
    you can label each dataset manually. By default, the dataset only shows 10 images
    per page. If you want to see all your pictures on the same page, you can select
    a number from the **Items per page** option. There are three options – **10**,
    **50**, and **100**:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在Vertex AI中标注数据。在创建的数据集中，有几种标注数据的方法。如果您使用的是小型数据集，您可以手动标注每个数据集。默认情况下，数据集每页只显示10个图像。如果您想在一页上看到所有图片，您可以从**每页项目数**选项中选择一个数字。有三个选项
    – **10**、**50**和**100**：
- en: '![](img/B18333_14_9.jpg)'
  id: totrans-730
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_9.jpg)'
- en: 'Since we haven’t created a label yet, we need to define/create a label name.
    Click on `Brain` and `Spine`:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有创建标签，我们需要定义/创建一个标签名称。点击`大脑`和`脊柱`：
- en: '![](img/B18333_14_10.jpg)'
  id: totrans-732
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_10.jpg)'
- en: 'After creating/adding new labels, you can either select every single image
    and label it or make multiple selections and label them as a group (following
    each step from *Steps 1* to *4*):'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建/添加新标签后，您可以选择每个单独的图像并对其进行标注，或者进行多次选择并将它们作为一组进行标注（按照从*步骤1*到*步骤4*的每个步骤）：
- en: '![](img/B18333_14_11.jpg)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_11.jpg)'
- en: 'After labeling all the images, you can check if any of the images have been
    left unlabeled by going to the summary page:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在标注所有图像后，您可以通过访问摘要页面来检查是否有任何图像未被标注：
- en: '![](img/B18333_14_12.jpg)'
  id: totrans-736
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_12.jpg)'
- en: If you have a very large dataset, you can create a labeling task and assign
    it to a team to label the dataset.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个非常大的数据集，您可以创建一个标注任务并将其分配给一个团队来标注数据集。
- en: Vertex AI – training
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 训练
- en: 'Now that you have a labeled dataset, it is ready for model training. Vertex
    AI provides different methods for training your model:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有一个标注好的数据集，它已准备好进行模型训练。Vertex AI提供了不同的方法来训练您的模型：
- en: AutoML
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AutoML
- en: Custom training (advanced)
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义训练（高级）
- en: 'To start AutoML training, in the Vertex AI console, click on **Training** and
    then the **CREATE** button, which is located at the top of the page (in our case,
    we are going to perform AutoML training using the dataset of MRI images that we
    created in the previous section):'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始AutoML训练，在Vertex AI控制台中，点击**训练**然后点击页面顶部的**创建**按钮（在我们的案例中，我们将使用上一节中创建的MRI图像数据集进行AutoML训练）：
- en: '![](img/B18333_14_13.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_13.jpg)'
- en: 'On the page that appears, you need to define some specifications for the model
    you are trying to train:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的页面上，您需要为要训练的模型定义一些规格：
- en: '**Select Dataset**: Here, you will be able to see all the datasets you created
    previously.'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择数据集**：在这里，您将能够看到您之前创建的所有数据集。'
- en: '**Annotation Set**: Labels are saved in collections called annotations. You
    can change annotation sets to apply a different group of labels to the same dataset.'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标注集**：标签存储在称为标注的集合中。您可以更改标注集，以将不同的标签组应用于同一数据集。'
- en: 'On the **Training method** page, select **AutoML** (this will be selected by
    default). Then, click **CONTINUE**:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在**训练方法**页面，选择**AutoML**（这将默认选中）。然后，点击**继续**：
- en: '![](img/B18333_14_14.jpg)'
  id: totrans-748
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_14.jpg)'
- en: Since we are working on training a new ML model, we need to select **Train new
    model**. But in case you already have a trained model and want to retrain *or*
    train a model as a version of an existing model, select **Train new version**.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在训练一个新的ML模型，我们需要选择**训练新模型**。但如果您已经有一个训练好的模型并想要重新训练*或*以现有模型的版本训练模型，请选择**训练新版本**。
- en: Next, enter the name of the model and provide a description (the description
    is optional).
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入模型的名称并提供描述（描述是可选的）。
- en: 'In the **Advanced options** section, you will be given two options for data
    splitting: **Randomly assigned** and **Manual (Advanced)**. In terms of **Randomly
    assigned**, your dataset will be automatically randomized and split into training,
    validation, and testing sets using the following ratios:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在**高级选项**部分，您将有两个数据拆分选项：**随机分配**和**手动（高级）**。在**随机分配**的情况下，您的数据集将自动随机拆分为训练集、验证集和测试集，使用以下比例：
- en: '`80%`'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`80%`'
- en: '`10%`'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10%`'
- en: '`10%`'
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10%`'
- en: 'You can change values as needed for your training mode. For more details, check
    out the Google documentation at [https://cloud.google.com/vertex-ai/docs/general/ml-use?_ga=2.140326960.-2030104523.1635276817&_gac=1.58794719.1650385127.CjwKCAjwu_mSBhAYEiwA5BBmf84zVxwFEpx-VaeJRusJFGq8rVNEovNnLhJ3vLYGMK3Eao6yJhRY5BoCdKgQAvD_BwE](https://cloud.google.com/vertex-ai/docs/general/ml-use?_ga=2.140326960.-2030104523.1635276817&_gac=1.58794719.1650385127.CjwKCAjwu_mSBhAYEiwA5BBmf84zVxwFEpx-VaeJRusJFGq8rVNEovNnLhJ3vLYGMK3Eao6yJhRY5BoCdKgQAvD_BwE):'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要更改训练模式中的值。有关更多详细信息，请查看 Google 文档[https://cloud.google.com/vertex-ai/docs/general/ml-use?_ga=2.140326960.-2030104523.1635276817&_gac=1.58794719.1650385127.CjwKCAjwu_mSBhAYEiwA5BBmf84zVxwFEpx-VaeJRusJFGq8rVNEovNnLhJ3vLYGMK3Eao6yJhRY5BoCdKgQAvD_BwE](https://cloud.google.com/vertex-ai/docs/general/ml-use?_ga=2.140326960.-2030104523.1635276817&_gac=1.58794719.1650385127.CjwKCAjwu_mSBhAYEiwA5BBmf84zVxwFEpx-VaeJRusJFGq8rVNEovNnLhJ3vLYGMK3Eao6yJhRY5BoCdKgQAvD_BwE)：
- en: '![](img/B18333_14_15.jpg)'
  id: totrans-756
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_15.jpg)'
- en: Click **CONTINUE**.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**继续**。
- en: 'On the next and last page, you will be prompted to enter an amount in the **Budget**
    section. Here, you need to specify the maximum amount of time that will be used
    to train a particular model. Click on the **START TRAINING** option:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页和最后一页，您将被提示在**预算**部分输入一个金额。在这里，您需要指定用于训练特定模型的最大时间量。点击**开始训练**选项：
- en: '![](img/B18333_14_16.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_16.jpg)'
- en: 'When the training is done, you will receive an email confirming this and you
    will be able to see its status. Now, you can analyze the trained model from the
    training page (the same page where we trained our model) or click on **Models**
    from the left menu and click on the model you want to analyze:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，您将收到一封确认邮件，您将能够看到其状态。现在，您可以从训练页面（我们训练模型相同的页面）分析训练好的模型，或者从左侧菜单点击**模型**并点击您想要分析的模型：
- en: '![](img/B18333_14_17.jpg)'
  id: totrans-761
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_17.jpg)'
- en: 'When you click on the model you want to analyze, you will be prompted to select
    the version of the model. Since we have trained a brand new model, we only have
    one version. The following screenshot shows a summary of the training model for
    our tabular dataset:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击您想要分析的模型时，您将被提示选择模型的版本。由于我们训练了一个全新的模型，我们只有一个版本。以下截图显示了我们的表格数据集的训练模型摘要：
- en: '![](img/B18333_14_18.jpg)'
  id: totrans-763
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_18.jpg)'
- en: From this chart, you can see the performance of the trained model, as well as
    the confusion matrix of our classification model.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图表中，您可以查看训练模型的性能，以及我们分类模型的混淆矩阵。
- en: 'After model training, it is time to deploy the model for prediction. There
    are two ways to deploy the model:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 模型训练完成后，是时候部署模型进行预测了。有两种方式可以部署模型：
- en: Vertex AI Endpoint
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI 端点
- en: Vertex AI Batch Prediction
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vertex AI 批量预测
- en: We will discuss these in more detail in the next few sections.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几节中详细讨论这些。
- en: Vertex AI – predictions (Vertex AI Endpoint)
  id: totrans-769
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 预测（Vertex AI 端点）
- en: 'In this section, we are going to deploy our model via Vertex AI Endpoint. There
    are two ways to deploy a model:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过 Vertex AI 端点部署我们的模型。部署模型有两种方式：
- en: From **Models**
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**模型**
- en: From **Endpoints**
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**端点**
- en: Let’s look at these options in detail.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些选项。
- en: Deploying the model via Models
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过模型部署模型
- en: 'Go to the **Models** section from the left menu, select the model you want
    to deploy, and select the version you want to deploy (remember, we have only one
    version since we have built/trained a brand-new model). Then, at the top of the
    page, click on **DEPLOY & TEST**:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧菜单转到**模型**部分，选择您想要部署的模型，并选择您想要部署的版本（记住，我们只有一个版本，因为我们构建/训练了一个全新的模型）。然后，在页面顶部点击**部署
    & 测试**：
- en: '![](img/B18333_14_19.jpg)'
  id: totrans-776
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_19.jpg)'
- en: 'After clicking on **DEPLOY & TEST**, you will be taken to the next page. Here,
    click on the blue **DEPLOY TO ENDPOINT** button:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**部署 & 测试**后，您将被带到下一页。在这里，点击蓝色的**部署到端点**按钮：
- en: '![](img/B18333_14_20.jpg)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_20.jpg)'
- en: Deploying the model via Endpoints
  id: totrans-779
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过端点部署模型
- en: 'Go to the **Endpoints** section from the left menu. By doing so, you will be
    navigated to a pop-up page where you need to define your endpoint:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧菜单转到**端点**部分。这样做，您将被导航到一个弹出页面，您需要定义您的端点：
- en: '![](img/B18333_14_21.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_21.jpg)'
- en: 'On the next page, you need to specify which model you want to deploy to the
    endpoint and select the version of the model:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页，您需要指定您想要部署到端点的模型以及模型的版本：
- en: '![](img/B18333_14_22.jpg)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_22.jpg)'
- en: 'Specify the number of compute nodes and leave the other settings as-is. Then,
    click **DONE** and then **CREATE**:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 指定计算节点数量，并保留其他设置不变。然后，点击**完成**然后**创建**：
- en: '![](img/B18333_14_23.jpg)'
  id: totrans-785
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_23.jpg)'
- en: 'Upon completing the deployment, you will receive an email specifying the status
    of the endpoint deployment. Now, we can start making predictions:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 完成部署后，您将收到一封电子邮件，说明端点部署的状态。现在，我们可以开始进行预测：
- en: Go to **Models**.
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**模型**。
- en: Select the model you wish to use.
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您希望使用的模型。
- en: Select the model’s version.
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模型的版本。
- en: At the top of the page, click on **DEPLOY & TEST**.
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面顶部，点击**部署 & 测试**。
- en: 'You will land on a page where you can start trying/testing your deployed model.
    Click on the blue **UPLOAD IMAGE** button:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 您将进入一个页面，您可以开始尝试/测试您部署的模型。点击蓝色**上传图片**按钮：
- en: '![](img/B18333_14_24.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_24.jpg)'
- en: 'Choose an image from your local drive. That image will be uploaded to the endpoint;
    on the right-hand side of the page, you will see the predicted result. In our
    case, we uploaded a random image (`spine MARI`) and the prediction was done with
    almost 99% accuracy:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的本地驱动器中选择一个图片。该图片将被上传到端点；在页面的右侧，您将看到预测结果。在我们的案例中，我们上传了一张随机图片（`spine MARI`），预测的准确率几乎达到了99%：
- en: '![](img/B18333_14_25.jpg)'
  id: totrans-794
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_25.jpg)'
- en: 'If you need to use your endpoint in mobile/web applications, you can request
    a sample API. From the same page, click on **Sample request**:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在移动/网络应用程序中使用您的端点，您可以请求一个示例API。从同一页面，点击**示例请求**：
- en: '![](img/B18333_14_26.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_26.jpg)'
- en: 'From the menu that appears, you can copy the script from the **REST** or **PYTHON**
    section based on your needs:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 从出现的菜单中，根据您的需求，您可以从**REST**或**PYTHON**部分复制脚本：
- en: '![](img/B18333_14_27.jpg)'
  id: totrans-798
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_27.jpg)'
- en: 'After several attempts, the system will start generating graphs based on the
    logs that have been collected from the endpoint:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次尝试后，系统将开始根据从端点收集的日志生成图表：
- en: '![](img/B18333_14_28.jpg)'
  id: totrans-800
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_28.jpg)'
- en: So far, we have deployed our model to Vertex AI Endpoint. Now, let’s learn how
    to use batch prediction.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将我们的模型部署到Vertex AI端点。现在，让我们学习如何使用批量预测。
- en: Vertex AI – predictions (Batch Prediction)
  id: totrans-802
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 预测（批量预测）
- en: 'Batch prediction is used when you don’t require an immediate response and want
    to get predictions from the accumulated data via a single request. Follow these
    steps to perform batch prediction for the models we trained earlier:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不需要立即响应，而想通过单个请求从累积的数据中获取预测时，使用批量预测。按照以下步骤为我们之前训练的模型执行批量预测：
- en: Go to **Models** from the left menu of the console.
  id: totrans-804
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制台的左侧菜单中转到**模型**。
- en: Click on the model you want to work with.
  id: totrans-805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您想要使用的模型。
- en: Click on the version of the model you want to work with.
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您想要使用的模型版本。
- en: From the top menu, click on **BATCH PREDICT**.
  id: totrans-807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部菜单中，点击**批量预测**。
- en: 'Click on the blue **CREATE BATCH PREDICTION** button:'
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色**创建批量预测**按钮：
- en: '![](img/B18333_14_29.jpg)'
  id: totrans-809
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_29.jpg)'
- en: 'After clicking on **CREATE BATCH PREDICTION**, you need to define some parameters,
    such as the batch prediction’s name, source, output, and so on. Let’s analyze
    each of them:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建批量预测**后，您需要定义一些参数，例如批量预测的名称、来源、输出等。让我们分析每个参数：
- en: '**Batch prediction name**: Enter a name for the batch prediction.'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量预测名称**：为批量预测输入一个名称。'
- en: '**Select source**: Here, you need to specify the source of the value that will
    be used in batch prediction. You can source either the BigQuery table *or* the
    file in Cloud Storage. Remember that since we are using the tabular dataset, the
    format must be CSV, JSONL, or TFRecord.'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择来源**：在此，您需要指定用于批量预测的值的来源。您可以从BigQuery表*或*云存储中的文件中选择。请记住，由于我们使用的是表格数据集，格式必须是CSV、JSONL或TFRecord。'
- en: '**Batch prediction output**: Select the format of output (BigQuery table, CSV,
    TFRecord, or JSONL) and provide the path (BigQuery *or* Cloud Storage).'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量预测输出**：选择输出格式（BigQuery表、CSV、TFRecord或JSONL）并提供路径（BigQuery*或*云存储）。'
- en: '**Explainability options**: Optionally, you may check **Enable feature attributions**
    for this model to get feature attributions as part of the output.'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可解释性选项**：可选地，您可以为该模型勾选**启用特征归因**，以便在输出中获得特征归因。'
- en: 'Using a BigQuery dataset and the table we have created, we can create a new
    batch prediction to predict the **Risk Level** column:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BigQuery数据集和我们所创建的表，我们可以创建一个新的批量预测来预测**风险等级**列：
- en: '![](img/B18333_14_30.jpg)'
  id: totrans-816
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_30.jpg)'
- en: After defining all the parameters, click on **CREATE**; the batch prediction
    will start processing. It will take some time to complete this process and you
    will receive an email upon completion.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义所有参数后，点击**创建**；批量预测将开始处理。这个过程需要一些时间来完成，完成后您将收到一封电子邮件。
- en: Vertex AI – Workbench
  id: totrans-818
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 工作台
- en: 'Vertex AI Workbench is a single development environment for the entire data
    science workflow. You can use Vertex AI Workbench’s notebook-based environment
    to query and explore data, develop and train a model, and run your code as part
    of a pipeline. Vertex AI workbench offers the following features:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: Vertex AI 工作台是整个数据科学工作流程的单个开发环境。您可以使用 Vertex AI 工作台的基于笔记本的环境来查询和探索数据，开发并训练模型，并将代码作为管道的一部分运行。Vertex
    AI 工作台提供以下功能：
- en: '**Managed notebooks** are Google-managed environments with integrations and
    features that help you set up and work in an end-to-end notebook-based production
    environment.'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管笔记本**是 Google 管理的环境，具有集成和功能，可以帮助您设置并在一个端到端基于笔记本的生产环境中工作。'
- en: '**User-managed notebooks** are deep learning VM image instances that are heavily
    customizable and are therefore ideal for users who need a lot of control over
    their environment.'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户托管笔记本**是深度学习 VM 图像实例，具有高度可定制性，因此非常适合需要对其环境有大量控制权的用户。'
- en: 'To launch Vertex AI Workbench, navigate to the Vertex AI console and click
    on **Workbench**:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Vertex AI 工作台，导航到 Vertex AI 控制台并点击**工作台**：
- en: '![](img/B18333_14_31.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_31.jpg)'
- en: 'If you are using Vertex AI Workbench for the first time, you will need to enable
    Notebook API, which you will be prompted for after you click on **Workbench**.
    Click on **ENABLE**:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是第一次使用 Vertex AI 工作台，您需要启用笔记本 API，您将在点击**工作台**后收到提示。点击**启用**：
- en: '![](img/B18333_14_32.jpg)'
  id: totrans-825
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_32.jpg)'
- en: 'In this lab, we are going to create a user-managed notebook. Vertex AI provides
    different types of Jupyter notebooks with various pre-installed libraries and
    dependencies. In this example, we will create a simple Python 3 notebook. Follow
    these steps:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，我们将创建一个用户托管笔记本。Vertex AI 提供不同类型的 Jupyter 笔记本，带有各种预安装的库和依赖项。在这个例子中，我们将创建一个简单的
    Python 3 笔记本。按照以下步骤操作：
- en: From the left menu of the console, click on **Workbench**.
  id: totrans-827
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制台的左侧菜单中，点击**工作台**。
- en: Click on **NEW NOTEBOOK** at the top of the page.
  id: totrans-828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面顶部点击**新建笔记本**。
- en: 'From the drop - down menu, click on **Python 3**:'
  id: totrans-829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中，点击**Python 3**：
- en: '![](img/B18333_14_33.jpg)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_33.jpg)'
- en: 'From the popup menu, you need to identify the notebook by providing its **Notebook
    name**, **Region**, **Zone**, and so on. Then, click on **CREATE**:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 从弹出菜单中，您需要通过提供其**笔记本名称**、**区域**、**区域**等来识别笔记本。然后，点击**创建**：
- en: '![](img/B18333_14_34.jpg)'
  id: totrans-832
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_34.jpg)'
- en: 'Now, let’s check and analyze the notebook we created earlier and what features
    are available in Vertex AI Notebook(s). Vertex AI provides a Jupyter notebook
    environment. Click on **OPEN JUPYTERLAB**, as shown in the following screenshot:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查和分析我们之前创建的笔记本以及 Vertex AI 笔记本中可用的功能。Vertex AI 提供一个 Jupyter 笔记本环境。点击**打开
    JupyterLab**，如下截图所示：
- en: '![](img/B18333_14_35.jpg)'
  id: totrans-834
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_35.jpg)'
- en: 'You will be navigated to a new tab containing the JupyterLab environment. On
    the left-hand side of the page, you will see all your folders. By default, there
    are two folders, but you can create, upload, or clone a folder from different
    sources such as GitHub. On the right-hand side of the page, you have **Notebook**,
    **Console**, and **Other**, which includes options for **Terminal**, **Text File**,
    and so on. Click on **Python 3** under Notebook. You will be taken to a blank
    notebook where you can start programming using Python:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被导航到一个包含 JupyterLab 环境的新标签页。在页面左侧，您将看到所有您的文件夹。默认情况下，有两个文件夹，但您可以从 GitHub 等不同来源创建、上传或克隆文件夹。在页面右侧，您有**笔记本**、**控制台**和**其他**，其中包含**终端**、**文本文件**等选项。在笔记本下点击**Python
    3**。您将被带到一张空白笔记本，您可以使用 Python 开始编程：
- en: '![](img/B18333_14_36.jpg)'
  id: totrans-836
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_36.jpg)'
- en: 'After clicking on `.ipynb` file (on the left) so that you can start inputting
    your scripts on the right:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击左边的 `.ipynb` 文件（以便您可以在右侧开始输入脚本）后：
- en: '![](img/B18333_14_37.jpg)'
  id: totrans-838
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_37.jpg)'
- en: With that, you have created the training platform and are ready to start running
    Jupyter notebooks.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经创建了训练平台，并准备好开始运行 Jupyter 笔记本。
- en: Vertex AI – Feature Store
  id: totrans-840
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 特征存储
- en: 'Feature Store in Vertex AI is where you can create entities and features and
    add values that can be used later as needed. In this demo, we are going to explore
    creating a Feature Store with entities and features in the Jupyter notebook by
    running some Python scripts. Before diving into the notebook, let’s create a Feature
    Store and entities via the Google Cloud console. From the left menu of the console,
    click on **Features**:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: Vertex AI中的特征存储是您可以创建实体和特征并添加可以稍后按需使用的值的地方。在本演示中，我们将通过运行一些Python脚本来探索在Jupyter笔记本中创建带有实体和特征的特征存储。在深入笔记本之前，让我们通过Google
    Cloud控制台创建一个特征存储和实体。从控制台的左侧菜单中，点击**特征**：
- en: '![](img/B18333_14_38.jpg)'
  id: totrans-842
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_38.jpg)'
- en: 'Since we haven’t created any Feature Store(s) yet, this section will be empty.
    To create a new entity, click on **CREATE ENTITY TYPE**, which is located at the
    top of the page:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未创建任何特征存储，本节将为空。要创建一个新的实体，请点击页面顶部的**创建实体类型**：
- en: '![](img/B18333_14_39.jpg)'
  id: totrans-844
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_39.jpg)'
- en: 'From the popup menu, enter all the necessary information and click the **CREATE**
    button, as shown here:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出菜单中，输入所有必要的信息并点击此处所示的**创建**按钮：
- en: '![](img/B18333_14_40.jpg)'
  id: totrans-846
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_40.jpg)'
- en: 'Next, we are going to create a new notebook and clone a repository from GitHub
    ([https://github.com/GoogleCloudPlatform/vertex-ai-samples](https://github.com/GoogleCloudPlatform/vertex-ai-samples)).
    After creating a notebook and cloning the aforementioned repository, from the
    `cloned` folder, go to `Vertex-ai-samples` | `notebooks` | `official` | `feature_store`
    and click on `gapic-feature-store.ipynb`:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的笔记本并从GitHub（[https://github.com/GoogleCloudPlatform/vertex-ai-samples](https://github.com/GoogleCloudPlatform/vertex-ai-samples)）克隆一个仓库。在创建笔记本并克隆上述仓库后，从`cloned`文件夹中，转到`Vertex-ai-samples`
    | `notebooks` | `official` | `feature_store`并点击`gapic-feature-store.ipynb`：
- en: '![](img/B18333_14_41.jpg)'
  id: totrans-848
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_41.jpg)'
- en: 'Install all additional packages and enter your project ID, as shown in the
    following screenshot:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所有附加包并输入您的项目ID，如以下截图所示：
- en: '![](img/B18333_14_42.jpg)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_42.jpg)'
- en: Run all the scripts as you go through (in this demo document, we will not go
    over every single line, but we will highlight important points related to the
    Vertex AI Feature Store).
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在您运行脚本的过程中运行所有脚本（在本演示文档中，我们不会逐行检查，但我们将突出与Vertex AI特征存储相关的重要点）。
- en: 'These scripts will do the following:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本将执行以下操作：
- en: Prepare a dataset for output. It will create a dataset in BigQuery to host the
    output.
  id: totrans-853
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备输出数据集。它将在BigQuery中创建一个数据集来托管输出。
- en: Import libraries and define constants.
  id: totrans-854
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库并定义常量。
- en: Create the feature store, as well as its entities and features.
  id: totrans-855
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建特征存储，以及其实体和特征。
- en: Import values.
  id: totrans-856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入值。
- en: 'After running all the scripts, you can check the created Feature Store (along
    with its entities and features) in the Google console. From the console, go to
    **Vertex AI** and click on **Features** from the left menu:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行所有脚本后，您可以在Google控制台中检查创建的特征存储（及其实体和特征）。从控制台，转到**Vertex AI**，然后从左侧菜单点击**特征**：
- en: '![](img/B18333_14_43.jpg)'
  id: totrans-858
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_43.jpg)'
- en: 'You will notice that we have created a Feature Store with two entities (`movies`
    and `users`). Each entity has three features. If you click on any entity provided,
    you will see some details about that particular entity (in our case, the entity
    is `movies`):'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们已经创建了一个包含两个实体（`movies`和`users`）的特征存储。每个实体有三个特征。如果您点击提供的任何实体，您将看到有关该特定实体的详细信息（在我们的情况下，实体是`movies`）：
- en: '![](img/B18333_14_44.jpg)'
  id: totrans-860
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_44.jpg)'
- en: As a fully managed solution, Vertex AI Feature Store provides a centralized
    repository for you to organize, store, and serve ML features, and for your team
    to share, discover, and reuse ML features at scale. It greatly helps in developing
    and deploying new ML applications. For more detailed information about Feature
    Store, check out [https://cloud.google.com/vertex-ai/docs/featurestore](https://cloud.google.com/vertex-ai/docs/featurestore).
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项完全托管的服务，Vertex AI特征存储为您提供了一个集中式存储库，用于组织、存储和提供机器学习特征，并允许您的团队在规模上共享、发现和重用机器学习特征。它极大地帮助开发新机器学习应用程序和部署。有关特征存储的更多详细信息，请查看[https://cloud.google.com/vertex-ai/docs/featurestore](https://cloud.google.com/vertex-ai/docs/featurestore)。
- en: Vertex AI – pipelines and metadata
  id: totrans-862
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 管道和元数据
- en: Pipelines help you automate and reproduce your ML workflow. Vertex AI integrates
    its ML offerings across Google Cloud into a seamless development experience. Previously,
    models trained with AutoML and custom models were accessible via separate services.
    Vertex AI combines both into a single API, along with other new products. In this
    demo, we will create and run ML pipelines with Vertex Pipelines.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 管道可以帮助你自动化和重现你的机器学习工作流程。Vertex AI将它的机器学习产品整合到Google Cloud中，提供无缝的开发体验。以前，使用AutoML和自定义模型训练的模型可以通过单独的服务访问。Vertex
    AI将两者结合到一个单一的API中，以及其他新产品。在这个演示中，我们将使用Vertex Pipelines创建和运行机器学习管道。
- en: 'We are going to use the Vertex AI SDK and create a Jupyter notebook. After
    creating a notebook, click on **OPEN JUPYTERLAB**, as shown in the following screenshot:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Vertex AI SDK并创建一个Jupyter笔记本。创建笔记本后，点击**OPEN JUPYTERLAB**，如图所示：
- en: '![](img/B18333_14_45.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_45.jpg)'
- en: The new notebook will open in a new tab. Clone the repository ([https://github.com/GoogleCloudPlatform/vertex-ai-samples](https://github.com/GoogleCloudPlatform/vertex-ai-samples)).
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 新的笔记本将在新标签页中打开。克隆仓库([https://github.com/GoogleCloudPlatform/vertex-ai-samples](https://github.com/GoogleCloudPlatform/vertex-ai-samples))。
- en: 'From the cloned folder, go to `Vertex-ai-samples` | `notebooks` | `official`
    | `pipelines`. After clicking on the `automl_tabular_classification_beans.ipynb`
    file, the notebook will open on the left-hand side, as shown here:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 从克隆的文件夹中，转到`Vertex-ai-samples` | `notebooks` | `official` | `pipelines`。在点击`automl_tabular_classification_beans.ipynb`文件后，笔记本将在左侧打开，如图所示：
- en: '![](img/B18333_14_46.jpg)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_46.jpg)'
- en: From the given notebook, read the overview and look at the dataset, objectives,
    and the cost of the particular demo. Run all commands as you go (we will not describe
    every single script but will focus on the main parts that are related to Vertex
    AI Pipeline).
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 从提供的笔记本中，阅读概述并查看特定演示的数据集、目标和成本。在执行过程中运行所有命令（我们不会描述每个脚本，但会关注与Vertex AI Pipeline相关的主要部分）。
- en: 'The scripts you are going to run will do the following:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要运行的脚本将执行以下操作：
- en: Set the project ID and bucket (where all the data will be stored).
  id: totrans-871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置项目ID和存储桶（所有数据都将存储在这里）。
- en: Import the necessary libraries.
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库。
- en: Define the constants and create the necessary components.
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义常量并创建必要的组件。
- en: 'Create an end-to-end ML pipeline. This process will take over 2 hours since
    it is going to perform the following tasks:'
  id: totrans-874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个端到端的机器学习管道。这个过程将超过2小时，因为它将执行以下任务：
- en: Create a dataset in Vertex AI.
  id: totrans-875
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Vertex AI中创建一个数据集。
- en: Train a tabular classification model with AutoML.
  id: totrans-876
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用AutoML训练一个表格分类模型。
- en: Get evaluation metrics on this model.
  id: totrans-877
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取此模型的评估指标。
- en: Based on the evaluation metrics, it will decide whether to deploy the model
    using conditional logic in Vertex Pipelines.
  id: totrans-878
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据评估指标，它将决定是否使用Vertex Pipelines中的条件逻辑部署模型。
- en: Deploy the model to an endpoint using Vertex prediction.
  id: totrans-879
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Vertex预测将模型部署到端点。
- en: 'After creating a pipeline, to view and analyze it, from the left menu of Vertex
    AI, click on **Pipelines**, as shown here:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 创建管道后，要查看和分析它，从Vertex AI的左侧菜单中点击**Pipelines**，如图所示：
- en: '![](img/B18333_14_47.jpg)'
  id: totrans-881
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_47.jpg)'
- en: 'After clicking on **Pipelines**, you will be taken to a page where you can
    select a pipeline you want to view. You will see the following diagram of the
    pipeline:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Pipelines**后，你将被带到可以选择要查看的管道的页面。你将看到以下管道图：
- en: '![](img/B18333_14_48.jpg)'
  id: totrans-883
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_48.jpg)'
- en: 'If you click the `dataset` artifact, you’ll see details about the Vertex AI
    dataset that was created. You can click the link specified next to **URI** to
    go to the page for that dataset:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击`dataset`工件，你会看到创建的Vertex AI数据集的详细信息。你可以点击旁边指定的**URI**链接，进入该数据集的页面：
- en: '![](img/B18333_14_49.jpg)'
  id: totrans-885
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_49.jpg)'
- en: 'To check the resulting metric visualizations from your custom evaluation component,
    click on the `metrics` artifact. On the right-hand side of your dashboard, you’ll
    be able to see the confusion matrix for this model:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查自定义评估组件生成的结果指标可视化，请点击`metrics`工件。在你的仪表板的右侧，你将能够看到此模型的混淆矩阵：
- en: '![](img/B18333_14_50.jpg)'
  id: totrans-887
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_50.jpg)'
- en: 'To check the model and endpoint that was created from this pipeline run, go
    to the `automl-beans` model. There, you should see this model deployed to an endpoint:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查从该管道运行创建的模型和端点，请转到`automl-beans`模型。在那里，你应该看到此模型已部署到端点：
- en: '![](img/B18333_14_51.jpg)'
  id: totrans-889
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_51.jpg)'
- en: 'Remember that each section in the pipeline will produce output that will be
    used as input for the next section. Later, if those outputs/inputs need to be
    modified, click on the **Metadata** button from the left menu:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，管道中的每个部分都会生成输出，这些输出将被用作下一部分的输入。稍后，如果那些输出/输入需要修改，请从左侧菜单点击**元数据**按钮：
- en: '![](img/B18333_14_52.jpg)'
  id: totrans-891
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_52.jpg)'
- en: With that, we have covered Vertex AI Pipelines and metadata. In the next section,
    we will discuss model monitoring for Vertex AI.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经涵盖了Vertex AI管道和元数据。在下一节中，我们将讨论Vertex AI的模型监控。
- en: Vertex AI – model monitoring
  id: totrans-893
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vertex AI – 模型监控
- en: 'After model deployment, we need to monitor it since the data and environment
    may change and cause the model to deteriorate over time. Two concepts of monitoring
    should be considered: **feature skew** and **drift detection**.'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 模型部署后，我们需要对其进行监控，因为数据和环境可能会发生变化，导致模型随时间恶化。应考虑两种监控概念：**特征偏差**和**漂移检测**。
- en: In our demo documentation, we are going to build a brand-new tabular dataset
    and train the model. In this example, we will be using the *Women’s International
    Football Results* ([https://www.kaggle.com/datasets/martj42/womens-international-football-results](https://www.kaggle.com/datasets/martj42/womens-international-football-results))
    dataset.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示文档中，我们将构建一个新的表格数据集并训练模型。在这个例子中，我们将使用*女子国际足球比赛结果*([https://www.kaggle.com/datasets/martj42/womens-international-football-results](https://www.kaggle.com/datasets/martj42/womens-international-football-results))数据集。
- en: 'We have created a tabular dataset where we have uploaded a CSV file that’s
    been downloaded from Kaggle. The following screenshot shows a summary of the dataset:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个表格数据集，其中我们上传了一个从Kaggle下载的CSV文件。以下截图显示了数据集的摘要：
- en: '![](img/B18333_14_53.jpg)'
  id: totrans-897
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_53.jpg)'
- en: 'We have also trained a model using the AutoML method, and as the target, we
    have used the `neutral` column, which has two values (either `False` or `True`).
    The following screenshot shows the summary of the trained model:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用AutoML方法训练了一个模型，目标列我们使用了`中性`列，该列有两个值（`False`或`True`）。以下截图显示了训练模型的摘要：
- en: '![](img/B18333_14_54.jpg)'
  id: totrans-899
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_54.jpg)'
- en: 'With Explainable AI, we can see that the `tournament` column has the most impact
    on our model:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可解释人工智能，我们可以看到`比赛`列对我们的模型影响最大：
- en: '![](img/B18333_14_55.jpg)'
  id: totrans-901
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_55.jpg)'
- en: 'Next, we need to deploy our model to Endpoint. Click on the **DEPLOY TO ENDPOINT**
    button, as shown here:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的模型部署到端点。点击此处所示的**部署到端点**按钮：
- en: '![](img/B18333_14_56.jpg)'
  id: totrans-903
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_56.jpg)'
- en: 'In the popup menu that appears (on the right-hand side), fill out all the fields:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的弹出菜单（在右侧）中，填写所有字段：
- en: '**Monitoring job display name**: The name of the monitoring job.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控作业显示名称**：监控作业的名称。'
- en: '**Monitoring windows length**: How many hours the model will be monitored for.'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控窗口长度**：模型将被监控的小时数。'
- en: '**Alert emails**: Enter at least 1 email that is going to receive an alert
    (you can enter multiple email addresses).'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报电子邮件**：输入至少1个将接收警报的电子邮件（可以输入多个电子邮件地址）。'
- en: '**Sampling rate**: The percentage of the sampling.'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采样率**：采样百分比。'
- en: 'Leave the rest of the fields as-is and click **CONTINUE**:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 保持其余字段不变，点击**继续**：
- en: '![](img/B18333_14_57.jpg)'
  id: totrans-910
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_57.jpg)'
- en: 'In the next and last section, you need to specify the monitoring objective
    (skew detection or drift detection). If you select the **Training-serving skew
    detection** option, you need to specify the training data source and target column.
    However, if you select the **Prediction drift detection** option, you need to
    specify alert thresholds. In our case, we will select **Prediction drift detection**.
    Next, click on the **DEPLOY** button:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节和最后一节中，您需要指定监控目标（偏差检测或漂移检测）。如果您选择**训练-服务偏差检测**选项，您需要指定训练数据源和目标列。然而，如果您选择**预测漂移检测**选项，您需要指定警报阈值。在我们的案例中，我们将选择**预测漂移检测**。接下来，点击**部署**按钮：
- en: '![](img/B18333_14_58.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_58.jpg)'
- en: 'It will take a while to process the deployment to the endpoint. Once the deployment
    has finished, you will receive emails about the *notification and status of the
    deployment*, and the *monitoring job being created* (in two separate emails):'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到端点的处理需要一些时间。一旦部署完成，您将收到关于*部署通知和状态*以及*正在创建的监控作业*（两封分开的电子邮件）的电子邮件：
- en: '![](img/B18333_14_59.jpg)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_14_59.jpg)'
- en: The preceding screenshot shows the model monitoring job request email notification.
    Note that the request has been submitted and is based on the incoming prediction
    request. It will be sampled and logged for analysis.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了模型监控作业请求电子邮件通知。请注意，请求已提交，并基于传入的预测请求。它将被采样并记录以进行分析。
- en: Summary
  id: totrans-916
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, we looked at examples based on the Google Cloud Vertex AI
    suite, which provides end-to-end services for data scientists. We covered Vertex
    AI datasets, labeling tasks, training, prediction, Workbench, Feature Store, pipelines,
    metadata, and model monitoring.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们查看了一些基于 Google Cloud Vertex AI 套件的示例，该套件为数据科学家提供端到端服务。我们涵盖了 Vertex AI
    数据集、标记任务、训练、预测、Workbench、特征存储、管道、元数据和模型监控。
- en: In the next appendix, we will discuss how to use various Google Cloud ML APIs,
    including the Vision API, NLP API, Speech-to-Text API, Text-to-Speech API, Translation
    API, and Dialogflow API.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个附录中，我们将讨论如何使用各种 Google Cloud ML API，包括视觉 API、NLP API、语音转文本 API、文本转语音 API、翻译
    API 和 Dialogflow API。
- en: Appendix 5
  id: totrans-919
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 5
- en: Practicing with Google Cloud ML API
  id: totrans-920
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 Google Cloud ML API
- en: 'In [*Chapter 8*](B18333_08.xhtml#_idTextAnchor159), *Discovering Google Cloud
    ML API*, we explored the Google Cloud ML API, which is the API interface provided
    by Google, based on pre-trained models. The Google Cloud ML API includes the following
    APIs, all of which will be covered as topics in this appendix:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B18333_08.xhtml#_idTextAnchor159) *探索 Google Cloud ML API* 中，我们探讨了
    Google Cloud ML API，这是基于预训练模型由 Google 提供的 API 接口。Google Cloud ML API 包括以下 API，所有这些都将在本附录中作为主题进行介绍：
- en: Google Cloud Vision API
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud 视觉 API
- en: Google Cloud NLP API
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud NLP API
- en: Google Cloud Speech-to-Text API
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud 语音转文本 API
- en: Google Cloud Text-to-Speech API
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud 文本转语音 API
- en: Google Cloud Translation API
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud 翻译 API
- en: Google Cloud Dialogflow API
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Dialogflow API
- en: In this appendix, we will provide implementation examples for each of these
    APIs. Let’s get started.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将为这些 API 提供实现示例。让我们开始吧。
- en: Google Cloud Vision API
  id: totrans-929
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud 视觉 API
- en: In this appendix, we will show you how to use the Vision API via Google Cloud
    Shell and the Python SDK.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将向您展示如何通过 Google Cloud Shell 和 Python SDK 使用视觉 API。
- en: 'Before we can start using the Vision API, we need to enable the Vision API
    from the Google console. From the left menu of the console, navigate to `Vision
    API`. After clicking on **Vision API**, you will be prompted to enable the API.
    In our case, the API is already enabled, as shown here:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用视觉 API 之前，我们需要从 Google 控制台中启用视觉 API。从控制台的左侧菜单中导航到 `视觉 API`。点击 **视觉 API**
    后，您将被提示启用 API。在我们的案例中，API 已经启用，如图所示：
- en: '![](img/B18333_15_1.jpg)'
  id: totrans-932
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_1.jpg)'
- en: 'We will start by using the Vision API via Google Cloud Shell. From the Google
    console, from the top-right corner, click on the Cloud Shell icon, as shown here:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过 Google Cloud Shell 使用视觉 API。从 Google 控制台，从右上角点击云壳图标，如图所示：
- en: '![](img/B18333_15_2.jpg)'
  id: totrans-934
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_2.jpg)'
- en: 'After clicking the Cloud Shell icon, the Shell Terminal will appear at the
    bottom of the console, as shown here:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 点击云壳图标后，Shell 终端将出现在控制台底部，如图所示：
- en: '![](img/B18333_15_3.jpg)'
  id: totrans-936
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_3.jpg)'
- en: 'Now, let’s look at some examples to show how the Vision API works in Google
    Cloud Shell:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些示例，以展示视觉 API 在 Google Cloud Shell 中的工作方式：
- en: '**Example 1** is an image of a tree:'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例 1** 是一棵树的图片：'
- en: '![](img/B18333_15_4.jpg)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_4.jpg)'
- en: 'To upload a file to Google Cloud Shell, click on the three dots icon highlighted
    in the following screenshot and click **Upload**:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件上传到 Google Cloud Shell，点击以下屏幕截图中的高亮三个点图标，然后点击 **上传**：
- en: '![](img/B18333_15_5.jpg)'
  id: totrans-941
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_5.jpg)'
- en: 'On the page that appears, you will be prompted to either upload a file or a
    folder. Navigate to your browser and select the image that you want to upload
    – in our case, `tree.jpeg`. Run the following command in Google Cloud Shell:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的页面上，您将被提示上传文件或文件夹。导航到您的浏览器并选择您想要上传的图片 – 在我们的案例中，是 `tree.jpeg`。在 Google Cloud
    Shell 中运行以下命令：
- en: '[PRE93]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '![](img/B18333_15_6.jpg)'
  id: totrans-944
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_6.jpg)'
- en: In the preceding screenshot, we can see *X* and *Y* values. These represent
    the corners of the object, and the object was detected as a flower with a 78%
    confidence level.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到 *X* 和 *Y* 值。这些代表物体的角点，并且物体被检测为花朵，置信度为 78%。
- en: '**Example 2** is an image of the Google logo:'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例 2** 是 Google 标志的图片：'
- en: '![](img/B18333_15_7.jpg)'
  id: totrans-947
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_7.jpg)'
- en: 'Now, we will try another option that’s available from the Vision API and detect
    a logo. Upload the image of the Google logo, and type the following command in
    Google Cloud Shell:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试从 Vision API 可用的另一个选项，检测标志。上传 Google 标志的图像，并在 Google Cloud Shell 中输入以下命令：
- en: '[PRE94]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '![](img/B18333_15_8.jpg)'
  id: totrans-950
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_8.jpg)'
- en: 'You can also try using other options, such as detecting text on the *same*
    image. It will display the result, such as each character and the location of
    each character on the image:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以尝试使用其他选项，例如检测同一图像上的文本。它将显示结果，例如每个字符及其在图像上的位置：
- en: '[PRE95]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '![](img/B18333_15_9.jpg)'
  id: totrans-953
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_9.jpg)'
- en: Note that the preceding screenshot only displays part of the result since the
    output is long.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的截图只显示了部分结果，因为输出很长。
- en: 'Now, let’s interact with the Python SDK and the Vision API:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们与 Python SDK 和 Vision API 进行交互：
- en: 'First, you must install Python’s Google Cloud Vision API. Use the following
    command in Google Cloud Shell:'
  id: totrans-956
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须安装 Python 的 Google Cloud Vision API。在 Google Cloud Shell 中使用以下命令：
- en: '[PRE96]'
  id: totrans-957
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next, we will need some Python code. The following is a simple Python script
    where it detects the Google logo in the image:'
  id: totrans-958
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些 Python 代码。以下是一个简单的 Python 脚本，它检测图像中的 Google 标志：
- en: '[PRE97]'
  id: totrans-959
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Here, we have imported all the necessary libraries, then defined an image name
    (the same logo image we used earlier), detected the logo using the Vision API,
    and printed the result and the score.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经导入了所有必要的库，然后定义了一个图像名称（与我们之前使用的相同标志图像），使用 Vision API 检测了标志，并打印了结果和得分。
- en: 'Now, we need to upload the Python script to Cloud Shell. After uploading the
    Python script, we can execute it, as follows:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将 Python 脚本上传到 Cloud Shell。上传 Python 脚本后，我们可以按照以下方式执行它：
- en: '[PRE98]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The result indicates that the logo is **Google** and the score is 0.98, which
    means it has a confidence level of about 98%.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，标志是 **Google**，得分为 0.98，这意味着它有大约 98% 的置信度。
- en: Google Cloud NLP API
  id: totrans-964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud NLP API
- en: The Google Cloud NLP API uses models to analyze text. There are several ways
    to use the NLP API. Here, we will show you how to use the NLP API via Google Cloud
    Shell and the Python SDK.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud NLP API 使用模型来分析文本。有几种方式可以使用 NLP API。在这里，我们将向您展示如何通过 Google Cloud
    Shell 和 Python SDK 使用 NLP API。
- en: Before you can use the NLP API, you will need to enable it. Simply navigate
    to the Natural Language API from the left menu of the console *or* type `Natural
    Language API` in the search bar at the top of the page. After landing on the NLP
    API web page, you will be asked to **Enable API** (if you have already done this,
    you can skip this).
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用 NLP API 之前，您需要启用它。只需从控制台的左侧菜单导航到自然语言 API，或者在上页顶部的搜索栏中输入 `Natural Language
    API`。在到达 NLP API 网页后，您将被要求 **启用 API**（如果您已经这样做，可以跳过此步骤）。
- en: 'Now, let’s start using the NLP API with Google Cloud Shell. Click on the Cloud
    Shell icon to activate it and type the following command:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用 Google Cloud Shell 的 NLP API。点击 Cloud Shell 图标以激活它，并输入以下命令：
- en: '[PRE99]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As output, you will see the result of the classification based on the text
    provided:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，您将看到基于提供的文本进行的分类结果：
- en: '![](img/B18333_15_10.jpg)'
  id: totrans-970
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_10.jpg)'
- en: The preceding output shows that it successfully identified the text in `People
    & Society / Social Issues & Advocacy` with 98% confidence and `Sensitive Subjects`
    with 89% confidence.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，它以 98% 的置信度成功识别了 `People & Society / Social Issues & Advocacy` 中的文本，以及以
    89% 的置信度识别了 `Sensitive Subjects`。
- en: 'Let’s try another option – that is, `analyze-sentiment`. Here, we can provide
    some text to analyze the sentiment. For this example, we will use a restaurant
    review from Google Maps:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个选项——那就是 `analyze-sentiment`。在这里，我们可以提供一些文本来分析情感。对于这个例子，我们将使用 Google
    地图的餐厅评论：
- en: '![](img/B18333_15_11.jpg)'
  id: totrans-973
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_11.jpg)'
- en: 'Enter the following command in Google Cloud Shell:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud Shell 中输入以下命令：
- en: '[PRE100]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The analysis will be displayed. The following screenshot shows part of the
    result:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 分析结果将显示。以下截图显示了部分结果：
- en: '![](img/B18333_15_12.jpg)'
  id: totrans-977
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_12.jpg)'
- en: 'You can scroll through the result to view its details. There are two main concepts
    we need to understand: magnitude (the overall strength of the emotion – that is,
    either positive or negative) and score (the overall emotional leaning of the text).'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以滚动查看其详细信息。我们需要了解两个主要概念：幅度（情绪的整体强度——即，要么是积极的，要么是消极的）和得分（文本的整体情感倾向）。
- en: 'Now, let’s investigate the NLP API with the Python SDK. There are a few other
    SDKs available as well, such as Java, PHP, Go, and others:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Python SDK 调查 NLP API。还有其他一些 SDK 可用，例如 Java、PHP、Go 等：
- en: '![](img/B18333_15_13.jpg)'
  id: totrans-980
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_13.jpg)'
- en: 'First, we need to install the SDK. Type the following command:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装SDK。输入以下命令：
- en: '[PRE101]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You need to have a credential to interact with Google Cloud. Therefore, create
    a service account, generate and upload the key, and activate it. We will skip
    this step here.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要凭证才能与Google Cloud交互。因此，创建服务帐户，生成并上传密钥，并激活它。我们在这里将跳过此步骤。
- en: 'Next, we will need some Python code. The following is a simple Python script
    that analyzes sentiment from the given text:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些Python代码。以下是一个简单的Python脚本，用于从给定文本中分析情感：
- en: '[PRE102]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Save the script on your local computer and upload it to Google Cloud Shell
    with a filename of `analyze_sentiment.py`. When all the files have been uploaded,
    you can run the `.py` file to execute the script and start the analysis process:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本保存在您的本地计算机上，并以`analyze_sentiment.py`为文件名上传到Google Cloud Shell。当所有文件都已上传后，您可以运行`.py`文件来执行脚本并开始分析过程：
- en: '[PRE103]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Using the `analyze-sentiment` method, we can retrieve the value of the sentiment
    and magnitude. We will let you execute it and get the results.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`analyze-sentiment`方法，我们可以检索情感值和幅度。我们将让您执行它并获取结果。
- en: The NLP API can also be used to integrate with other APIs, such as the **Speech-To-Text**
    (**STT**) API. By using the STT API, we can convert a sound/voice file into text
    and apply the NLP API, as well as various methods, to analyze the sentiment/entity/syntax
    of the text.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: NLP API也可以用于与其他API集成，例如**Speech-To-Text**（**STT**）API。通过使用STT API，我们可以将声音/语音文件转换为文本，并应用NLP
    API以及各种方法来分析文本的情感/实体/句法。
- en: Google Cloud Speech-to-Text API
  id: totrans-990
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Speech-to-Text API
- en: The Google Cloud Speech-to-Text API is used to convert audio into text. The
    service is based on deep learning technology and supports 120 languages and variants.
    The service can be used to transcribe audio files as well as support voice-activated
    interfaces. Cloud Speech-to-Text automatically detects the language being spoken.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Speech-to-Text API用于将音频转换为文本。该服务基于深度学习技术，支持120种语言和变体。该服务可用于转录音频文件，以及支持语音激活的界面。Cloud
    Speech-to-Text自动检测正在说的语言。
- en: First, we need to enable the Speech-to-Text API. From the left menu, scroll
    down and click on `speech to text` in the search bar at the top of the page.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启用Speech-to-Text API。从左侧菜单中，向下滚动并在页面顶部的搜索栏中点击`speech to text`。
- en: 'You will be taken to a page where you will be asked to enable the API. If you
    enabled it previously, you will see the following page:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被带到一页，您将在此页面上被要求启用API。如果您之前已启用，您将看到以下页面：
- en: '![](img/B18333_15_14.jpg)'
  id: totrans-994
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_14.jpg)'
- en: Since we are going to use `curl` to send a request to the Speech-To-Text API,
    we will need to generate an API key to pass in our request URL.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算使用`curl`向Speech-To-Text API发送请求，我们需要生成一个API密钥来传递到我们的请求URL。
- en: 'Create a request file named `request.json`:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`request.json`的请求文件：
- en: '![](img/B18333_15_15.jpg)'
  id: totrans-997
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_15.jpg)'
- en: 'Then, run the following command (note that we skipped the key creation step):'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令（注意，我们跳过了密钥创建步骤）：
- en: '[PRE104]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The preceding command calls the Speech-to-Text API, gets all the variables
    from the `request.json` file, uses the key we have generated, and sends/saves
    all the results to the `result.json` file. To view the `result.json` file, type
    the following command:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令调用Speech-to-Text API，从`request.json`文件中获取所有变量，使用我们生成的密钥，并将所有结果发送/保存到`result.json`文件中。要查看`result.json`文件，请输入以下命令：
- en: '[PRE105]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '![](img/B18333_15_16.jpg)'
  id: totrans-1002
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_16.jpg)'
- en: The preceding screenshot shows the converted text from the given audio file,
    the confidence level (which is 98%), the time processed, and the language of the
    text.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了从给定音频文件转换的文本，置信度水平（为98%），处理时间和文本的语言。
- en: Speech-to-Text supports different languages as well. Check out [https://cloud.google.com/speech-to-text/docs/languages](https://cloud.google.com/speech-to-text/docs/languages)
    for more details about supported languages.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: Speech-to-Text也支持不同的语言。有关支持的语言的更多详细信息，请查看[https://cloud.google.com/speech-to-text/docs/languages](https://cloud.google.com/speech-to-text/docs/languages)。
- en: Google Cloud Text-To-Speech API
  id: totrans-1005
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Text-To-Speech API
- en: 'The Google Cloud Text-to-Speech API maps natural language texts to human-like
    speech. The initial step is to enable the Text-to-Speech API:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Text-to-Speech API将自然语言文本映射成类似人类的语音。第一步是启用Text-to-Speech API：
- en: '![](img/B18333_15_17.jpg)'
  id: totrans-1007
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_17.jpg)'
- en: 'Go to Cloud Shell by clicking on the Shell icon. Before diving into the API,
    check the list of the supported voices and languages. You can check the available
    languages and voices via Google Cloud Shell using the following command:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 点击Shell图标进入Cloud Shell。在深入API之前，检查支持的语音和语言列表。您可以通过以下命令在Google Cloud Shell中检查可用的语言和语音：
- en: '[PRE106]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The preceding command will list *all* possible languages and voices, along
    with their corresponding code. The following screenshot shows just a small part
    of the list:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将列出所有可能的语言和语音，以及它们对应的代码。以下截图显示了列表的一小部分：
- en: '![](img/B18333_15_18.jpg)'
  id: totrans-1011
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_18.jpg)'
- en: 'Next, we need to create a JSON file named `synthesize-text.json`, where we
    will specify the language and voice codes and provide some full text that we want
    to convert into audio:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个名为`synthesize-text.json`的JSON文件，其中我们将指定语言和语音代码，并提供一些我们想要转换为音频的完整文本：
- en: '[PRE107]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Use the following code to call the Text-to-Speech API using the `curl` command:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码通过`curl`命令调用Text-to-Speech API：
- en: '[PRE108]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: After running the preceding command, the result will be saved to a file called
    `synthesize-text.txt`.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，结果将保存到名为`synthesize-text.txt`的文件中。
- en: 'Open the `synthesize-text.txt` file. You’ll notice that the Text-to-Speech
    API provides the audio output in base64-encoded text and has been assigned to
    the `audioContent` field, as shown here:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`synthesize-text.txt`文件。您会注意到Text-to-Speech API提供了以base64编码的音频输出，并将其分配给`audioContent`字段，如下所示：
- en: '[PRE109]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, create a Python file named `tts_decode.py`:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`tts_decode.py`的Python文件：
- en: '[PRE110]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Finally, run the following command from Cloud Shell:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从Cloud Shell运行以下命令：
- en: '[PRE111]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now, our MP3 file is ready.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的MP3文件已准备就绪。
- en: Google Cloud Translation API
  id: totrans-1024
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Translation API
- en: 'Google’s Cloud Translation API allows you to translate text that’s in more
    than 100 languages. There are two ways to use the Translation API. From the main
    menu of the Google Cloud console, click on `Translation API` into the search bar
    (at the top of the page):'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: Google的Cloud Translation API允许您翻译超过100种语言中的文本。使用Translation API有两种方式。从Google
    Cloud控制台的主菜单中，点击搜索栏中的`Translation API`（位于页面顶部）：
- en: '![](img/B18333_15_19.jpg)'
  id: totrans-1026
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_19.jpg)'
- en: 'After clicking on the dashboard, you will be prompted to select one of three
    options:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 点击仪表板后，您将被提示选择以下三个选项之一：
- en: '**AutoML Translation**'
  id: totrans-1028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AutoML翻译**'
- en: '**Cloud Translation API**'
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云翻译API**'
- en: '**Translation Hub**'
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**翻译中心**'
- en: Since we are going to use `curl` to send a request to the Translation API, we
    will need to generate an API key to pass in our request URL.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用`curl`向Translation API发送请求，我们需要生成一个API密钥来传递我们的请求URL。
- en: 'First, let’s define our text. Type `TEXT=` and type any sentence. Remember
    that the space between words should *not* be left blank; instead, in each space,
    type `%20`. In our example, we will type `This is a demo documentation`, as shown
    here:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的文本。输入`TEXT=`然后输入任何句子。记住，单词之间的空格不应留空；相反，在每个空格中输入`%20`。在我们的例子中，我们将输入`This
    is a demo documentation`，如下所示：
- en: '[PRE112]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now that we’ve defined our `TEXT` variable, type the following command, which
    is underlined in red:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`TEXT`变量，输入以下命令，该命令用红色下划线标出：
- en: '[PRE113]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: That is a `curl` call for the API where we specified a target language (in our
    case, it is `ru`, which stands for Russian). Check out [https://cloud.google.com/translate/docs/languages](https://cloud.google.com/translate/docs/languages)
    to view all the supported languages and ISO-639-1 codes.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个指定目标语言（在我们的例子中是`ru`，代表俄语）的API的`curl`调用。查看[https://cloud.google.com/translate/docs/languages](https://cloud.google.com/translate/docs/languages)以查看所有支持的语言和ISO-639-1代码。
- en: 'After running the command provided, you will see the following output:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的命令后，您将看到以下输出：
- en: '![](img/B18333_15_20.jpg)'
  id: totrans-1038
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_20.jpg)'
- en: The Google Cloud Translation API also has a feature that detects a language
    and translates it into *any* supported language.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Translation API还具有一个功能，可以检测语言并将其翻译成任何支持的语言。
- en: 'In this example, we will provide two different texts in different languages,
    as shown here:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将提供两种不同语言的两种不同文本，如下所示：
- en: '[PRE114]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Instead of using a space between words, we need to type `%20`.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在单词之间输入`%20`而不是空格。
- en: 'After defining `TEXT_ONE` and `TEXT_TWO`, run the following command to call
    the Translation API to detect the language(s):'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`TEXT_ONE`和`TEXT_TWO`后，运行以下命令以调用Translation API进行语言检测：
- en: '[PRE115]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This will return the language that was detected with a confidence level between
    zero and one (where zero stands for 0% and one stands for 100%):'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个置信度在零到一之间的检测到的语言（其中零代表0%，一代表100%）：
- en: '![](img/B18333_15_21.jpg)'
  id: totrans-1046
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_21.jpg)'
- en: As we can see, the language of `TEXT_ONE` is Turkish (`tr`) with a 100% confidence
    level and the language of `TEXT_TWO` is Russian (`ru`) with a 100% confidence
    level as well.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`TEXT_ONE`的语言是土耳其语（`tr`），置信度为100%，而`TEXT_TWO`的语言是俄语（`ru`），置信度同样为100%。
- en: Google Cloud Dialogflow API
  id: totrans-1048
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Dialogflow API
- en: 'The Dialogflow API is used for chatbots, **interactive voice response** (**IVR**),
    and other dialog-based interactions with human speech. First, we need to enable
    the Dialogflow API:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: Dialogflow API用于聊天机器人、**交互式语音响应**（**IVR**）以及与人类语音的基于对话的交互。首先，我们需要启用Dialogflow
    API：
- en: '![](img/B18333_15_22.jpg)'
  id: totrans-1050
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_22.jpg)'
- en: To start using the platform, open a new tab and type [https://dialogflow.cloud.google.com/#/logindialogflow.cloud.google.com](https://dialogflow.cloud.google.com/#/logindialogflow.cloud.google.com)
    into your browser. You might be asked to sign in with your Google account.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用该平台，请在新标签页中输入[https://dialogflow.cloud.google.com/#/logindialogflow.cloud.google.com](https://dialogflow.cloud.google.com/#/logindialogflow.cloud.google.com)到您的浏览器中。您可能需要使用您的Google账户登录。
- en: You will be taken to the Dialogflow platform. This is the Dialogflow ES (essential)
    version. Here, we will mainly be using its **user interface** (**UI**). There
    is a section where you can type scripts (such as Google Functions), which will
    be covered in this demo documentation.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被带到Dialogflow平台。这是Dialogflow ES（基本）版本。在这里，我们将主要使用其**用户界面**（**UI**）。有一个可以输入脚本（如Google
    Functions）的区域，这部分将在本演示文档中介绍。
- en: 'Now, let’s become familiar with the Dialogflow UI. The following screenshot
    shows the page you’ll see when you first start the Dialogflow platform:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们熟悉Dialogflow的用户界面。以下截图显示了您首次启动Dialogflow平台时将看到的页面：
- en: '![](img/B18333_15_23.jpg)'
  id: totrans-1054
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_23.jpg)'
- en: 'In Dialogflow, you can have multiple agents. If you have already created agents
    before, you can check them by clicking on the down arrow shown in the following
    screenshot:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dialogflow中，您可以拥有多个代理。如果您之前已经创建了代理，您可以通过点击以下截图所示的向下箭头来检查它们：
- en: '![](img/B18333_15_24.jpg)'
  id: totrans-1056
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_24.jpg)'
- en: 'Here, you can view a list of all created agents and/or create a new agent.
    To create a new agent, scroll down to the bottom and click on **Create new agent**,
    as shown here:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看所有创建的代理列表，或创建一个新的代理。要创建一个新的代理，请向下滚动到页面底部并点击**创建新代理**，如图所示：
- en: '![](img/B18333_15_25.jpg)'
  id: totrans-1058
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_25.jpg)'
- en: 'You will be taken to the following page:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被带到以下页面：
- en: '![](img/B18333_15_26.jpg)'
  id: totrans-1060
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_26.jpg)'
- en: 'In our case, we will name our new agent `Test-Chatbot` and leave all the other
    settings as-is. Now, click **CREATE**:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将我们的新代理命名为`Test-Chatbot`，并保留所有其他设置不变。现在，点击**创建**：
- en: '![](img/B18333_15_27.jpg)'
  id: totrans-1062
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_27.jpg)'
- en: 'Once your agent has been created, you will see **Intents** on the left:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的代理创建完成，您将在左侧看到**意图**：
- en: '![](img/B18333_15_28.jpg)'
  id: totrans-1064
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_28.jpg)'
- en: This option helps you understand the intent of the user. Then, we have **Entities**,
    which allows you to grab useful information from users. For example, when someone
    says “I want a veggie pizza,” the chatbot can understand that they want a vegetarian
    pizza instead of a normal pizza.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项有助于您理解用户的意图。然后，我们有**实体**，它允许您从用户那里获取有用的信息。例如，当有人说出“我想吃个素食披萨”时，聊天机器人可以理解他们想要的是素食披萨而不是普通披萨。
- en: At the time of writing, **Knowledge** is a beta feature. You can use this feature
    to create a knowledge base inside Dialogflow.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，**知识**功能处于测试阶段。您可以使用此功能在Dialogflow中创建知识库。
- en: '**Fulfillment** is where you can integrate Dialogflow with other systems such
    as your customer management system. The following screenshot shows an example
    script powered by Google Functions:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '**满足**是您可以集成Dialogflow与其他系统（如您的客户管理系统）的地方。以下截图显示了由Google Functions驱动的示例脚本：'
- en: '![](img/B18333_15_29.jpg)'
  id: totrans-1068
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_29.jpg)'
- en: Now, let’s learn how to use intents in Dialogflow. An intent is an action a
    user wants to perform or a question a user has. For example, let’s say that they
    want to order a pizza, book an appointment, or want more information about your
    company. In Dialogflow, we can create an agent that can understand the intent
    of the user and automatically reply to it.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在 Dialogflow 中使用意图。意图是用户想要执行的操作或用户提出的问题。例如，假设他们想要订购披萨、预约或想要了解更多关于您公司的信息。在
    Dialogflow 中，我们可以创建一个能够理解用户意图并自动回复的代理。
- en: 'When you create a new agent (as we did here), Dialogflow creates two intents
    by default:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的代理（正如我们在这里所做的那样），Dialogflow 会默认创建两个意图：
- en: '**Default Welcome Intent**'
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认欢迎意图**'
- en: '**Default Fallback Intent**'
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认回退意图**'
- en: 'These can be seen in the following screenshot:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在下面的截图中看到：
- en: '![](img/B18333_15_30.jpg)'
  id: totrans-1074
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_30.jpg)'
- en: 'Let’s see what’s inside **Default Welcome Intent**. To do so, click on **Default
    Welcome Intent**. This intent is for understanding greetings such as Hello, Hi,
    and others:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看**默认欢迎意图**中有什么内容。要做到这一点，请点击**默认欢迎意图**。这个意图用于理解问候语，如你好、嗨等：
- en: '![](img/B18333_15_31.jpg)'
  id: totrans-1076
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_31.jpg)'
- en: 'Each intent consists of two main parts:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 每个意图由两个主要部分组成：
- en: Training phases
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练阶段
- en: Response phases
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应阶段
- en: 'Training phases help Dialogflow understand the intent of the user, whereas
    the response phase involves Dialogflow understanding the greeting. If it does,
    it will respond with some text, which will be provided in the **Responses** section:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 训练阶段帮助 Dialogflow 理解用户的意图，而响应阶段涉及 Dialogflow 理解问候语。如果它做到了，它将使用**响应**部分中提供的某些文本进行响应：
- en: '![](img/B18333_15_32.jpg)'
  id: totrans-1081
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_32.jpg)'
- en: 'The other default intent provided by Dialogflow is **Default Fallback Intent**.
    Here, when Dialogflow does not understand the user, it will respond with one of
    the pieces of text provided as a text response in **Default Fallback Intent**:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: Dialogflow 提供的另一个默认意图是**默认回退意图**。在这里，当 Dialogflow 无法理解用户时，它将使用**默认回退意图**中提供的文本之一作为文本响应：
- en: '![](img/B18333_15_33.jpg)'
  id: totrans-1083
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_33.jpg)'
- en: Now, let’s dive into creating an intent (as mentioned previously, we will build
    a chatbot where the user will order a pizza).
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解如何创建意图（如前所述，我们将构建一个用户可以订购披萨的聊天机器人）。
- en: 'To create a new intent, click **CREATE INTENT**, as shown here:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的意图，请点击**创建意图**，如下所示：
- en: '![](img/B18333_15_34.jpg)'
  id: totrans-1086
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_34.jpg)'
- en: 'We will name our first intent `opening_times`, as shown here:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的第一个意图命名为`opening_times`，如下所示：
- en: '![](img/B18333_15_35.jpg)'
  id: totrans-1088
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_35.jpg)'
- en: 'Click on **ADD TRAINING PHRASES**. This is where we will provide examples of
    how users can express their intent:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加训练短语**。这是我们提供用户如何表达其意图的示例：
- en: '![](img/B18333_15_36.jpg)'
  id: totrans-1090
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_36.jpg)'
- en: 'Let’s add a couple of training phrases, as shown in the following screenshot:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些训练短语，如下面的截图所示：
- en: '![](img/B18333_15_37.jpg)'
  id: totrans-1092
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_37.jpg)'
- en: 'Next, we need to add some responses. Click on **ADD RESPONSE**, as shown here:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一些响应。点击**添加响应**，如下所示：
- en: '![](img/B18333_15_38.jpg)'
  id: totrans-1094
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_38.jpg)'
- en: 'We will add just one response here, but remember you can add multiple responses
    for a particular intent:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只添加一个响应，但请记住，您可以为特定的意图添加多个响应：
- en: '![](img/B18333_15_39.jpg)'
  id: totrans-1096
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_39.jpg)'
- en: When you’ve finished with the training phrases and responses, save them; they
    will automatically start training the agent. Dialogflow needs to train the agent
    to respond to the question. This will take a couple of seconds (or minutes if
    you have a long input); you will be notified when training has been completed.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成训练短语和响应后，保存它们；它们将自动开始训练代理。Dialogflow 需要训练代理以响应用户的问题。这可能需要几秒钟（如果您有长输入，可能需要几分钟）；训练完成后，您将收到通知。
- en: Now, let’s try our trained agent. On the right-hand side of the page, you will
    see a small section where you can try your trained agent.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试我们的训练代理。在页面右侧，您将看到一个可以尝试您的训练代理的小部分。
- en: 'Let’s type a question for our agent. Let’s ask if they are open today and see
    what response we get:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的代理输入一个问题。让我们询问他们今天是否营业，看看我们会得到什么回应：
- en: '![](img/B18333_15_40.jpg)'
  id: totrans-1100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_40.jpg)'
- en: In this agent, we can create multiple intents. Dialogflow will understand which
    intents to use and respond to the user’s question.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代理中，我们可以创建多个意图。Dialogflow 将理解使用哪些意图并响应用户的问题。
- en: 'Now, let’s create a new intent for ordering pizza. Click on **Intents** from
    the left menu and click on **CREATE INTENT**. The following screenshot shows some
    expressions you can use:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的点披萨意图。点击左侧菜单中的**意图**，然后点击**创建意图**。以下截图显示了您可以使用的某些表达式：
- en: '![](img/B18333_15_41.jpg)'
  id: totrans-1103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_41.jpg)'
- en: 'Now, provide a single response to the question (you can add more responses
    if you wish):'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，提供一个针对问题的单一响应（如果您愿意，可以添加更多响应）：
- en: '![](img/B18333_15_42.jpg)'
  id: totrans-1105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_42.jpg)'
- en: 'Upon saving your intent, your agent will be retrained. Let’s test our agent:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的意图后，您的代理将被重新训练。让我们测试我们的代理：
- en: '![](img/B18333_15_43.jpg)'
  id: totrans-1107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_43.jpg)'
- en: Note that the user’s phrase was different than it was in the training phases,
    but Dialogflow still understands the intent and gives the correct response.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用户的短语与训练阶段中的不同，但Dialogflow仍然理解意图并给出正确的响应。
- en: If the user needs to provide more details, such as different toppings for the
    pizza, then Dialogflow will need to use entities that haven’t been created yet.
    So, we will need to create an entity.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户需要提供更多细节，例如披萨的不同配料，那么Dialogflow将需要使用尚未创建的实体。因此，我们需要创建一个实体。
- en: 'From the left menu, click on **Entities** and then **CREATE ENTITY**, as shown
    here:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧菜单中，点击**实体**，然后点击**创建实体**，如下所示：
- en: '![](img/B18333_15_44.jpg)'
  id: totrans-1111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_44.jpg)'
- en: 'We will use `topping` as the entity’s name. Check the `topping`:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`topping`作为实体的名称。检查`topping`：
- en: '![](img/B18333_15_45.jpg)'
  id: totrans-1113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_45.jpg)'
- en: Click **SAVE**.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**。
- en: Let’s go back to our intent to order pizza and create a new training phrase
    with some details of ordering such as “I want to order cheese pizza.”
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的点披萨意图，并创建一个新的带有一些点披萨细节的新训练短语，例如“我想点一份芝士披萨。”
- en: 'Here are some additional expressions for ordering a pizza:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的点披萨的短语：
- en: '![](img/B18333_15_46.jpg)'
  id: totrans-1117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_46.jpg)'
- en: 'Note that when we type `two`, it automatically detects the entity:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们键入`two`时，它会自动检测实体：
- en: '![](img/B18333_15_47.jpg)'
  id: totrans-1119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_47.jpg)'
- en: '`@sys.number` is a built-in entity in Dialogflow that captures/recognizes the
    numbers in the dialog. There are also other built-in entities that can recognize
    emails, addresses, phone numbers, and other details. Check out [https://cloud.google.com/dialogflow/es/docs/reference/system-entities](https://cloud.google.com/dialogflow/es/docs/reference/system-entities)
    for more built-in entities. Here are some examples:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '`@sys.number`是Dialogflow中的一个内置实体，它可以捕获/识别对话中的数字。还有其他内置实体可以识别电子邮件、地址、电话号码和其他细节。有关更多内置实体的信息，请参阅[https://cloud.google.com/dialogflow/es/docs/reference/system-entities](https://cloud.google.com/dialogflow/es/docs/reference/system-entities)。以下是一些示例：'
- en: '![](img/B18333_15_48.jpg)'
  id: totrans-1121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_48.jpg)'
- en: 'In our case, we are building entities, so we will need to map some words to
    an entity. This will allow us to see which part of the sentence is related to
    which entity. Simply select a word or a phrase from the expression that we used
    in the **Intents** section and assign it to the entity that’s been created, as
    shown here:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们正在构建实体，因此我们需要将一些词映射到实体上。这将允许我们看到句子的哪一部分与哪个实体相关。只需从**意图**部分使用的表达式中选择一个词或短语，并将其分配给已创建的实体，如下所示：
- en: '![](img/B18333_15_49.jpg)'
  id: totrans-1123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_49.jpg)'
- en: 'After selecting the entity, you can select other words or phrases from the
    training expression and map them to that entity:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 选择实体后，您可以从训练表达式中选择其他单词或短语并将它们映射到该实体：
- en: '![](img/B18333_15_50.jpg)'
  id: totrans-1125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_50.jpg)'
- en: 'In this example, we have two different entities – `@sys.number` and `@topping`:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个不同的实体 - `@sys.number`和`@topping`：
- en: '![](img/B18333_15_51.jpg)'
  id: totrans-1127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_51.jpg)'
- en: 'We can also change or modify the response with more dynamic answers:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用更动态的答案来更改或修改响应：
- en: '![](img/B18333_15_52.jpg)'
  id: totrans-1129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_52.jpg)'
- en: 'Click the **SAVE** button to train the agent and test/try the chatbot:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**按钮来训练代理并测试/尝试聊天机器人：
- en: '![](img/B18333_15_53.jpg)'
  id: totrans-1131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_53.jpg)'
- en: 'If the user provides information about the topping for the pizza, we need to
    reinforce the extra question to gather that particular information. Click the
    checkbox next to **topping** in the **REQUIRED** section and click on **Define
    prompts**, as shown in the following screenshot:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户提供了有关披萨配料的信息，我们需要加强额外的问题来收集该特定信息。在**必需**部分点击**topping**旁边的复选框，然后点击**定义提示**，如下面的截图所示：
- en: '![](img/B18333_15_54.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_54.jpg)'
- en: 'Add a question that the user will be asked, as shown here:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 添加用户将被问及的问题，如下所示：
- en: '![](img/B18333_15_55.jpg)'
  id: totrans-1135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18333_15_55.jpg)'
- en: 'Click **Close** and save the agent. Note that you can add more prompts as well.
    Now, let’s test the agent, which doesn’t know anything about the topping:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**关闭**并保存代理。请注意，您还可以添加更多提示。现在，让我们测试一下代理，它对配料一无所知：
- en: '![](img/B18333_15_56.jpg)'
  id: totrans-1137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_56.jpg)'
- en: 'With that, we have a very simple chatbot with basic functionality. But in real
    life, we would want to keep asking the user if they have any other questions *or*
    if they would like to add some other items to their current order. In our case,
    we have a chatbot where users order a pizza. In addition to asking about the pizza
    and its toppings, we can ask them if they want another pizza *or* if they want
    to add some drinks. This feature is called a **follow-up intent**. To enable this
    feature, click on **Add follow-up intent** next to the **order_pizza** intent,
    as shown here:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就拥有了一个功能非常简单的聊天机器人。但在现实生活中，我们希望继续询问用户是否有其他问题**或者**他们是否想添加其他项目到当前订单中。在我们的案例中，我们有一个用户订购披萨的聊天机器人。除了询问披萨及其配料外，我们还可以询问他们是否想要另一份披萨**或者**是否想添加一些饮料。这个功能被称为**后续意图**。要启用此功能，点击**order_pizza**意图旁边的**添加后续意图**，如图所示：
- en: '![](img/B18333_15_57.jpg)'
  id: totrans-1139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_57.jpg)'
- en: 'So, if a user wants to continue to add another pizza, they can simply answer
    **YES**. Click **YES** to add the follow-up intent:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果用户想要继续添加另一份披萨，他们只需简单地回答**是**。点击**是**以添加后续意图：
- en: '![](img/B18333_15_58.jpg)'
  id: totrans-1141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_58.jpg)'
- en: Click on the **order_pizza - yes** section; you will be taken to a page where
    you can modify the section’s content.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**order_pizza - yes**部分；您将被带到可以修改该部分内容的页面。
- en: 'In our case, we will change the name of the intent, leave all the training
    phrases as-is (they are good enough to use in our case), and add a response that
    states `Great! What topping do you want on your pizza?`. Then, click **SAVE**:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将更改意图的名称，保留所有训练短语不变（在我们的案例中它们已经足够好使用），并添加一个声明“太好了！您想在披萨上放什么配料？”的响应。然后，点击**保存**：
- en: '![](img/B18333_15_59.jpg)'
  id: totrans-1144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_59.jpg)'
- en: 'But what happens if the user answers **NO** to this follow-up question (Do
    you want to add more pizza?)? In this case, we would like to ask if they want
    to add a drink to their order. As we did previously, from the follow-up intent,
    select **NO**, click on the sub-intent and change its title (optional), leave
    all the training phrases as-is, and type the answer, as shown in the following
    screenshot:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果用户对这个问题（您想再点一些披萨吗？）回答**不**，会发生什么？在这种情况下，我们想询问他们是否想在订单中添加饮料。像之前一样，从后续意图中选择**不**，点击子意图并更改其标题（可选），保留所有训练短语不变，并输入答案，如下面的截图所示：
- en: '![](img/B18333_15_60.jpg)'
  id: totrans-1146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18333_15_60.jpg)'
- en: After saving the agent, you can try to chat with the bot. You can keep adding
    follow-up questions or new intents based on your designed conversation architecture.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 保存代理后，您可以尝试与机器人聊天。您可以根据您设计的对话架构继续添加后续问题或新的意图。
- en: Summary
  id: totrans-1148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, we provided examples of how to use various Google Cloud ML
    APIs, including the Vision API, NLP API, Speech-To-Text API, Text-To-Speech API,
    Translation API, and Dialogflow API.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们提供了如何使用各种Google Cloud ML API的示例，包括视觉API、NLP API、语音转文本API、文本转语音API、翻译API和Dialogflow
    API。
