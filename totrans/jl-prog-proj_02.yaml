- en: Creating Our First Julia App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a working Julia installation and your IDE of choice is ready
    to run, it's time to put them to some good use. In this chapter, you'll learn
    how to apply Julia for data analysis—a domain that is central to the language,
    so expect to be impressed!
  prefs: []
  type: TYPE_NORMAL
- en: We will learn to perform exploratory data analysis with Julia. In the process,
    we'll take a look at `RDatasets`, a package that provides access to over 700 learning
    datasets. We'll load one of them, the Iris flowers dataset, and we'll manipulate
    it using standard data analysis functions. Then we'll look more closely at the
    data by employing common visualization techniques. And finally, we'll see how
    to persist and (re)load our data.
  prefs: []
  type: TYPE_NORMAL
- en: But, in order to do that, first we need to take a look at some of the language's
    most important building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables (and constants)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `Strings` of characters and `regular expressions`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers and numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first Julia data structures—`Tuple`, `Range`, and `Array`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` Exploratory data analysis using the Iris flower dataset—`RDatasets` and
    core `Statistics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick data visualization with `Gadfly`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` Saving and loading tabular data with `CSV` and `Feather`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with MongoDB databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to install a specific version of a package you need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Defining variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in the previous chapter how to use the REPL in order to execute
    computations and have the result displayed back to us. Julia even lends a helping
    hand by setting up the `ans` variable, which automatically holds the last computed
    value.
  prefs: []
  type: TYPE_NORMAL
- en: But, if we want to write anything but the most trivial programs, we need to
    learn how to define variables ourselves. In Julia, a variable is simply a name
    associated to a value. There are very few restrictions for naming variables, and
    the names themselves have no semantic meaning (the language will not treat variables
    differently based on their names, unlike say Ruby, where a name that is all caps
    is treated as a constant).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can follow along through the examples in the chapter by loading the accompanying
    Jupyter/IJulia notebook provided with this chapter's support files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables, names are case-sensitive, meaning that `ANSWER` and `answer`
    (and `Answer` and `aNsWeR`) are completely different things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Unicode names (UTF-8-encoded) are also accepted as variables names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you can type many Unicode math symbols by typing backslash (`\`)
    then the name of the symbol and then the *Tab* key. For example, \pi[*Tab*] will
    output π.
  prefs: []
  type: TYPE_NORMAL
- en: 'Emojis also work, if your terminal supports them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The only explicitly disallowed names for variables are the names of built-in
    Julia statements (`do`, `end`, `try`, `catch`, `if`, and `else`, plus a few more):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to access a variable that hasn''t been defined will result in an
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It's true that the language does not impose many restrictions, but a set of
    code style conventions is always useful—and even more so for an open source language.
    The Julia community has distilled a set of best practices for writing code. In
    regard to naming variables, the names should be lowercase and in just one word;
    word separation can be done with underscores (`_`), but only if the name would
    be difficult to read without them. For example, `myvar` versus `total_length_horizontal`.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the degree of difficulty in reading a name is a subjective thing,
    I'm a bit split about this naming style. I normally prefer the crystal-clear clarity
    of separating at word boundaries. But nevertheless, it is better to follow the
    recommendation, given that function names in the Julia API adhere to it. By adhering
    to the same conventions, your code will be consistent throughout.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Constants are variables that, once declared, can''t be changed. They are declared
    by prefixing them with the `const` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Very importantly in Julia, constants are not concerned with their value, but
    rather with their *type*. It is a bit too early to discuss types in Julia, so
    for now it suffices to say that a type represents what kind of a value we''re
    dealing with. For instance, `"abc"` (within double quotes) is of type `String`,
    `''a''` (within single quotes) is of type `Char` , and `1000` is of type `Int`
    (because it''s an integer). Thus, in Julia, unlike most other languages, we can
    change the value assigned to a constant as long as the `type` remains the same.
    For instance, we can at first decide that eggs and milk are acceptable meal choices
    and go `vegetarian`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can change our mind later on, if we decide to go `vegan`. Julia will
    let it slide with just a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, attempting to say that `mealoption = 2` will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This makes sense, right? Who's ever heard of that kind of diet?
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the nuances can be more subtle than that, most notably when working
    with numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Julia doesn''t allow it because internally `10` and `10.00`, despite having
    the same arithmetical value, are values of different types (`10` is an integer,
    while `10.00` is a `float`). We''ll take a closer look at numeric types in just
    a moment, so it will all become clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we need to pass the new value as `10.00`—a `float`, in order to obey the
    same type requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Why are constants important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's mostly about performance. Constants can be especially useful as global
    values. Because global variables are long-lived and can be modified at any time
    and from any location in your code, the compiler is having a hard time optimizing
    them. If we tell the compiler that the value is constant and thus that the type
    of the value won't change, the performance problem can be optimized away.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just because constants alleviate some critical performance problems
    brought about by global variables, it doesn't mean that we are encouraged to use
    them. Global values in Julia, like in other languages, must be avoided whenever
    possible. Besides performance issues, they can create subtle bugs that are hard
    to catch and understand. Also, keep in mind that, since Julia allows changing
    the value of a constant, accidental modification becomes possible.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Common programming wisdom says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Code is read much more often than it is written, so plan accordingly."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code comments are a powerful tool that make the programs easier to understand
    later on. In Julia, comments are marked with the # sign. Single-line comments
    are denoted by a `#` and everything that follows this, until the end of the line,
    is ignored by the compiler. Multiline comments are enclosed between `#= ... =#`.
    Everything within the opening and the closing comment tags is also ignored by
    the compiler. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, we can see both multiline and single-line comments
    in action. A single-line comment can also be placed at the beginning of the line.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A string represents a sequence of characters. We can create a string by enclosing
    the corresponding sequence of characters between double quotes, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the string also includes quotes, we can escape these by prefixing them with
    a backslash `\`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Triple-quoted strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, escaping can get messy, so there's a much better way of dealing with
    this—by using triple quotes `"""..."""`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Within triple quotes, it is no longer necessary to escape the single quotes.
    However, make sure that the single quotes and the triple quotes are separated—or
    else the compiler will get confused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The triple quotes come with some extra special powers when used with multiline
    text. First, if the opening `"""` is followed by a newline, this newline is stripped
    from the string. Also, whitespace is preserved but the string is dedented to the
    level of the least-indented line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how it looks in Jupyter/IJulia:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1eb65198-16e9-4b0e-9044-7cce9cd0bfce.png)'
  prefs: []
  type: TYPE_IMG
- en: The longer arrow stands for a *Tab* (represented by a `\t` in the output), while
    the shorter arrow is a space. Note that each line had a space as the first character—but
    it was removed. The least indented line, the last one, was shifted to the left,
    removing all its whitespace and beginning with **Here**, while the remaining whitespace
    on the other lines was preserved (now beginning with a *Tab*).
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two or more strings can be joined together (concatenated) to form a single
    string by using the star `*` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can invoke the `string` function, passing in all the words
    we want to concatenate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenation works great with variables too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, again, we need to be careful when dealing with types (types are central
    to Julia, so this will be a recurring topic). Concatenation only works for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing the concatenation by invoking the `string` function does work even
    if not all the arguments are strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, `string` has the added advantage that it automatically converts its parameters
    to strings. The following example works too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But this does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `String` method (with capital S). Remember that in Julia names
    are case-sensitive, so `string` and `String` are two different things. For most
    purposes we'll need the lowercase function, `string`. You can use Julia's help
    system to access the documentation for `String`, if you want to learn about it.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating longer, more complex strings, concatenation can be noisy and
    error-prone. For such cases, we''re better off using the `$` symbol to perform
    variable interpolation into strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'More complex expressions can be interpolated by wrapping them into `$(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here we invoke the `uppercase` function which changes all the letters of the
    string into their uppercase counterparts—and the `reverse` function which reverses
    the order of the letters in the word. Their output is then interpolated in a string.
    Between the `$(...)` boundaries, we can use any Julia code we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `string` function, interpolation takes care of converting the
    values to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings can be treated as a list of characters, so we can index into them—that
    is, access the character at a certain position in the word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first character of the string `Nice to see you` is `N`.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing in Julia is `1`-based, which means that the first element of a list
    is found at index 1\. This can be surprising if you've programmed before, given
    that most programming languages use `0`-based indexing. However, I assure you
    that `1`-based indexing makes for a very pleasant and straightforward coding experience.
  prefs: []
  type: TYPE_NORMAL
- en: Julia has support for arrays with arbitrary indices, allowing, for example,
    to start numbering at `0`. However, arbitrary indexing is a more advanced feature
    that we won't cover here. If you are curious, you can check the official documentation
    at [https://docs.julialang.org/en/v1/devdocs/offset-arrays/](https://docs.julialang.org/en/v1/devdocs/offset-arrays/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also extract a part of the string (a substring) by indexing with a `range`,
    providing the starting and the ending positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to notice that indexing via a singular value returns a `Char` ,
    while indexing via a `range` returns a `String` (remember, for Julia these are
    two completely different things):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`N` is a `String` of just one letter, as indicated by its double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`N` is a `Char`, as shown by the single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: They are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode and UTF-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Julia, string literals are encoded using UTF-8\. UTF-8 is a variable-width
    encoding, meaning that not all characters are represented using the same number
    of bytes. For example, ASCII characters are encoded using a single byte—but other
    characters can use up to four bytes. This means that not every byte index into
    a UTF-8 string is necessarily a valid index for a corresponding character. If
    you index into a string at such an invalid byte index, an error will be thrown.
    Here is what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can correctly retrieve the character at index `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And at index `2`, we successfully get the `ø` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `ø` has two bytes, so index `3` is used by `ø` as well and we cannot
    access the string at this position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The third letter, `r`, is found at position `4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus `ø` is a two-byte character that occupies the locations `2` and `3`—so
    the index `3` is invalid, matching the second byte of `ø`. The next valid index
    can be computed using `nextind(str, 2)`—but the recommended way is to use iteration
    over the characters (we''ll discuss `for` loops a bit later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of variable-length encodings, the number of characters in a string
    is not necessarily the same as the last index (as you have seen, the third letter,
    `r`, was at index `4`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For such cases, Julia provides the `end` keyword, which can be used as a shorthand
    for the last index. You can perform arithmetic and other operations with `end`,
    just like a normal value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `end` value can be computed programmatically using the `endof(str)` function.
    Attempting to index outside the bounds of a string will result in a `BoundsError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are used for powerful pattern-matching of substrings within
    strings. They can be used to search for a substring in a string, based on patterns—and
    then to extract or replace the matches. Julia provides support for Perl-compatible
    regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way to input regular expressions is by using the so-called **nonstandard
    string literals**. These look like regular double-quoted strings, but carry a
    special prefix. In the case of regular expressions, this prefix is `"r"`. The
    prefix provides for a different behavior, compared to a normal string literal.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in order to define a regular string that matches all the letters,
    we can use `r"[a-zA-Z]*".`
  prefs: []
  type: TYPE_NORMAL
- en: Julia provides quite a few nonstandard string literals—and we can even define
    our own if we want to. The most widely used are for regular expressions (`r"..."`),
    byte array literals (`b"..."`), version number literals (`v"..."`), and package
    management commands (`pkg"..."`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we build a regular expression in Julia—it matches numbers between
    0 and 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our regular expression matches the substring `1970`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm that the nonstandard string literal `reg` is in fact a `Regex`
    and not a regular `String` by checking its `type` with the `typeof` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives away the fact that there''s also a `Regex` constructor available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The two constructs are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Using the constructor can come in handy when we need to create regular expressions
    using more complex strings that might include interpolation or concatenation.
    But in general, the `r"..."` format is more used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of the regular expression can be affected by using some combination
    of the flags `i`, `m`, `s`, and `x.` These modifiers must be placed right after
    the closing double quote mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, `i` performs a case-insensitive pattern match. Without
    the `i` modifier, `match` returns `nothing`—a special value that does not print
    anything at the interactive prompt—to indicate that the regex does not match the
    given string.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the available modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i`—case-insensitive pattern matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`—treats string as multiple lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`—treats string as single line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`—tells the regular expression parser to ignore most whitespace that is neither
    backslashed nor within a character class. You can use this to break up your regular
    expression into (slightly) more readable parts. The `#` character is also treated
    as a metacharacter introducing a comment, just as in ordinary code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `occursin` function is more concise if all we need is to check if a regex
    or a substring is contained in a string—if we don''t want to extract or replace
    the matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When a regular expression does match, it returns a `RegexMatch` object. These
    objects encapsulate how the expression matches, including the substring that the
    pattern matches and any captured substrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the option to specify the index at which to start the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try something a bit more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant `RegexMatch` object `m` exposes the following properties (or
    fields, in Julia''s lingo):'
  prefs: []
  type: TYPE_NORMAL
- en: '`m.match` (`Why`, ) contains the entire substring that matched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m.captures` (an array of strings containing `Why`, `Why`, and `,` ) represents
    the captured substrings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m.offset`, the offset at which the whole match begins (in our case `1`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m.offsets`, the offsets of the captured substrings as an array of integers
    (for our example being `[1, 1, 4]`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Julia does not provide a `g` modifier, for a *greedy* or *global* match. If
    you need all the matches, you can iterate over them using `eachmatch()`, with
    a construct like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternatively, we can put all the matches in a list using `collect()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: For more info about regular expressions, check the official documentation at
    [https://docs.julialang.org/en/stable/manual/strings/#Regular-Expressions-1](https://docs.julialang.org/en/stable/manual/strings/#Regular-Expressions-1).
  prefs: []
  type: TYPE_NORMAL
- en: Raw string literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to define a string that does not perform interpolation or escaping,
    for example to represent code from another language that might contain `$` and
    `\` which can interfere with the Julia parser, you can use raw strings. They are
    constructed with `raw"..."` and create ordinary `String` objects that contain
    the enclosed characters exactly as entered, with no interpolation or escaping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting a `$` inside the string will cause Julia to perform interpolation and
    look for a variable called `will`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: But by using a raw string, the `$` symbol will be ignored (or rather, automatically
    escaped, as you can see in the output).
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia provides a broad range of primitive numeric types, together with the full
    range of arithmetic and bitwise operators and standard mathematical functions.
    We have at our disposal a rich hierarchy of numeric types, with the most generic
    being `Number`—which defines two subtypes, `Complex` and `Real`. Conversely, `Real`
    has four subtypes—`AbstractFloat`, `Integer`, `Irrational`, and `Rational`. Finally,
    `Integer` branches into four other subtypes—`BigInt`, `Bool`, `Signed`, and `Unsigned`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the most important categories of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Literal integers are represented simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The default Integer type, called `Int`, depends on the architecture of the
    system upon which the code is executed. It can be either `Int32` or `Int64`. On
    my 64-bit system, I get it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Int` type will reflect that, as it''s just an alias to either `Int32`
    or `Int64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Overflow behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The minimum and maximum values are given by the `typemin()` and `typemax()`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to use values that go beyond the boundaries defined by the minimum
    and the maximum values will not throw an error (or even a warning), resulting
    instead in a wraparound behavior (meaning that it will jump over at the other
    end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Substracting `1` from the minimum value will return the maximum value instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The reverse is also `true`—adding `1` to the maximum value will return the minimum
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For working with values outside these ranges, we''ll use the `BigInt` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: No wraparound here; the result is what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Floating-point numbers are represented by numerical values separated by a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'By default they are `Float64` values, but they can be converted to `Float32`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve readability, the underscore (`_`) separator can be used with both
    integers and floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Rational numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia also provides a Rational number type. This allows us to work with exact
    ratios, instead of having to deal with the precision loss inherent in floats.
    Rational numbers are represented as their numerator and denominator values, separated
    by two forward slashes `//`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Rational numbers can be converted to other types, if there is no data loss:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Julia also includes support for Complex numbers. We won't discuss, them but
    you can read about the topic in the official documentation at [https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-Numbers-1](https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-Numbers-1).
  prefs: []
  type: TYPE_NORMAL
- en: Numerical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia supports the full range of arithmetic operators for its numeric types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+`—(unary and binary plus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`—(unary and binary minus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`—(times)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`—(divide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\`—(inverse divide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^`—(power)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%`—(remainder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The language also supports handy update operators for each of these (`+=`,`-=`,`*=`,`/=`,`\=`,`÷=`,`%=`,and `^=`).
    Here they are in the wild:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Numerical comparisons can be performed with the following set of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`==`—(equality)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=` or `≠`—(inequality)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<`—(less than)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=` or `≤`—(less than or equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`—(greater than)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=` or `≥`—(greater than or equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Julia, the comparisons can also be chained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Vectorized dot operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia defines corresponding *dot* operations for every binary operator. These
    are designed to work element-wise with collections of values (called **vectorized**).
    That is, the operator that is *dotted* is applied for each element of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll square each element of the `first_five_fib`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `first_five_fib` was not touched and the resultant
    collection was returned, but *dotted* updating operators are also available, updating
    the values in place. They match the previously discussed update operators (with
    the added *dot*). For example, to update `first_five_fib` in place, we''d use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Vectorized code is an important part of the language due to its readability
    and conciseness, but also because it provides important performance optimizations.
    For more details, check [https://docs.julialang.org/en/stable/manual/functions/#man-vectorized-1](https://docs.julialang.org/en/stable/manual/functions/#man-vectorized-1).
  prefs: []
  type: TYPE_NORMAL
- en: There's more to it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section barely scratches the surface. For a deeper dive into Julia's numeric
    types, read the official documentation at [https://docs.julialang.org/en/stable/manual/mathematical-operations/](https://docs.julialang.org/en/stable/manual/mathematical-operations/).
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples are one of the simplest data types and data structures in Julia. They
    can have any length and can contain any kind of value—but they are immutable.
    Once created, a tuple cannot be modified. A tuple can be created using the literal
    tuple notation, by wrapping the comma-separated values within brackets `(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to define a one-element tuple, we must not forget the trailing comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'But it''s OK to leave off the parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can index into tuples to access their elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Vectorized *dot *operations also work with tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Named tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A named tuple represents a tuple with labeled items. We can access the individual
    components by label or by index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Named tuples can be very powerful as they are similar to full-blown objects,
    but with the limitation that they are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen ranges a bit earlier, when learning to index into `strings`. They
    can be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As with previous collections, we can index into ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'A range can be expanded into its corresponding values by using the splat operator,
    `"..."`. For example, we can splat it into a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also splat it into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for Tuples, which can also be splatted into lists, among other
    things: `[(1,2,3)...]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the range steps in increments of one, by default. We can change
    that by passing it an optional step parameter. Here is an example of a range between
    `0` and `20` with a step of five:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now our values go from `5` to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens the possibility to also go in descending order, by using a negative
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranges are not limited to integers—you''ve seen earlier a range of `chars`;
    and these are ranges of `floats`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `collect` function to expand the range into a list (an
    array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is a data structure (and the corresponding *type*) that represents
    an ordered collection of elements. More specifically, in Julia, an array is a
    collection of objects stored in a multi-dimensional grid.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays can have any number of dimensions and are defined by their type and number
    of dimensions—`Array{Type, Dimensions}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A one-dimensional array, also called a **vector**, can be easily defined using
    the array literal notation, the square brackets `[...]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also constrain the type of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'A two D array (also called a **matrix**) can be initialized using the same
    array literal notation, but this time without the commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add more rows using semicolons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Julia comes with a multitude of functions that can construct and initialize
    arrays with different values, such as `zeroes`, `ones`, `trues`, `falses`, `similar`,
    `rand, fill`, and more`.` Here are a few of these in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '`Array` elements can be accessed by their index, passing in a value for each
    dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass a colon (`:`) to select all indices within the entire dimension—or
    a range to define subselections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we select rows `1` to `3` and columns `3` to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The solitary colon `:` stands for all—so here we pick all the rows and columns
    `3` to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is an `Array` of Booleans to select elements at its `true` indices.
    Here we select the rows corresponding to the `true` values and the columns `3`
    to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way to indexing into an array, we can also assign values to the
    selected items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to iterate over an array is with the `for` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If you also need the index while iterating, Julia exposes the `eachindex(yourarray)`
    iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Mutating arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add more elements to the end of a collection by using the `push!` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Note the ending exclamation mark `!` for the `push!` function. This is a perfectly
    legal function name in Julia. It is a convention to warn that the function is
    *mutating—*that is, it will modify the data passed as argument to it, instead
    of returning a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove elements from the end of an `array` using `pop!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `pop!` function has removed the last element of `arr` and returned
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to remove an element other than the last, we can use the `deleteat!`
    function, indicating the index that we want to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a word of warning when mutating arrays. In Julia, the arrays are passed
    to functions by reference. This means that the original array is being sent as
    the argument to the various mutating functions, and not its copy. Beware not to
    accidentally make unwanted modifications. Similarly, when assigning an array to
    a variable, a new reference is created, but the data is not copied. So for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we `pop` an element off `arr2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `arr2` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'But our original array was modified, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning `arr` to `arr2` does not copy the values of `arr` into `arr2` , it
    only creates a new binding (a new name) that points to the original `arr` array.
    To create a separate array with the same values, we need to use the `copy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we `pop` an element off the copied array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Our original array is untouched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the copy was modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Array comprehensions provide a very powerful way to construct arrays. It is
    similar to the previously discussed array literal notation, but instead of passing
    in the actual values, we use a computation over an iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example will make it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: This can be read as—*for each element* `x` *within the range* `1` *to* `5`,
    *compute* `x+1` *and put the resultant value in the array*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with the *plain* array literals, we can constrain the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can create multi-dimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Comprehensions can be filtered using the `if` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we only kept the values where `x/2` was greater than `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But the superpower of the comprehensions is activated when they are used for
    creating generators. Generators can be iterated to produce values on demand, instead
    of allocating an array and storing all the values in advance. You'll see what
    that means in a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generators are defined just like array comprehensions, but without the square
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'They allow us to work with potentially infinite collections. Check the following
    example, where we want to print the numbers from one to one million with a cube
    less than or equal to `1_000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This computation uses significant resources because the comprehension creates
    the full array of 1 million items, despite the fact that we only iterate over
    its first nine elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that by benchmarking the code using the handy `@time` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Over 10 MB of memory and almost 60,000 allocations. Compare this with using
    a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Less than 1 MB and a quarter of the number of allocations. The difference will
    be even more dramatic if we increase from 1 million to 1 billion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Over 10 seconds and 7 GB of memory used!
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the generator runs practically in constant time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Exploratory data analysis with Julia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a good understanding of Julia's basics, we can apply this
    knowledge to our first project. We'll start by applying **exploratory data analysis** (**EDA**)
    to the Iris flower dataset.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have experience with data analysis, you might've used the Iris
    dataset before. If so, that's great! You'll be familiar with the data and the
    way things are done in your (previous) language of choice, and can now focus on
    the Julia way.
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, if this is the first time you've  heard about the Iris flower
    dataset, no need to worry. This dataset is considered the `Hello World` of data
    science—and we'll take a good look at it using Julia's powerful toolbox. Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: The Iris flower dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also called **Fisher's Iris dataset**, it was first introduced in 1936 by British
    statistician and biologist Ronald Fisher. The dataset consists of 50 samples from
    each of three species of Iris flower (Iris setosa, Iris virginica, and Iris versicolor).
    It is sometimes called **Anderson's Iris dataset** because Edgar Anderson collected
    the data. Four features were measured—the length and the width of the sepals and
    petals (in centimeters).
  prefs: []
  type: TYPE_NORMAL
- en: Using the RDatasets package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding good-quality data for learning, teaching, and statistical software development
    can be challenging. That's why the industry practically standardized the use of
    over 10,00 high-quality datasets. These were originally distributed with the statistical
    software environment R. Hence, they've been aptly named the `RDatasets`.
  prefs: []
  type: TYPE_NORMAL
- en: The Iris flower dataset is part of this collection. There are many ways to download
    it, but the most convenient is through the `RDatasets` package. This package provides
    an easy way for Julia users to experiment with most of the standard datasets available
    in R or included with R's most popular packages. Sounds great; let's add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, switch to package management mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package is added, let''s tell Julia that we want to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We can peek at the included datasets by calling `RDatasets.datasets()`. It
    returns a list of all the 700+ datasets available with `RDatasets`. It includes
    details about the data package, the name of the dataset, its title (or info),
    number of rows, and number of columns. These are the first 20 rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b2c6fea-7db3-4a7f-98a2-c1828440a299.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the datasets are part of a `Package`—we can use that to filter
    by it. The Iris flower dataset is part of the *datasets* package.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do now is load the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24730ac1-e5b6-4be2-9a2c-f942cb6efd3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The returned value is a `DataFrame` object with 150 rows and five columns—`SepalLength`,
    `SepalWidth`, `PetalLength`, `PetalWidth`, and `Species`, plus an automatically
    added id column called `Row`.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes are the *de facto* standard for working with tabular data in Julia.
    They are a key part of Julia's data analysis toolset and we'll discuss them in
    detail in the next chapters. For now, it suffices to say that, as you can see
    in the previous examples, it represents a data structure that looks very much
    like a table or a spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can programmatically retrieve the names of the columns using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the size, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The result is a tuple that matches the number of rows and columns—`(rows, cols)`.
    Yep, as already established, `150` rows over `5` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b78cf2e-e2e2-4e20-b09c-caa367d66762.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `head` function shows the top six rows. Optionally, it takes a second parameter
    to indicate the number of rows: `head(iris, 10)`. There''s also its twin, `tail()`,
    which will display the bottom rows of the `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf1d35bf-2af0-4fc5-87bb-ad0afa39d241.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In regard to the species present in the dataset, we see *setosa* in the head
    rows and *virginica* at the bottom. We should have three species, though, according
    to the description of the data. Let''s ask for a row count grouped by `Species`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e36265b-8e7d-48e5-bf48-ec8d4e03c2b3.png)'
  prefs: []
  type: TYPE_IMG
- en: The `by` function takes three parameters—the dataset, the name of the column,
    and a grouping function—in this case, `nrow`, which computes the number of rows.
    We can see that the third species is *versicolor*, and for each of the species
    we have `50` records.
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure you're wondering why, in the preceding example, the name of the column
    is prefixed by a colon "`:`". It is a `Symbol`. We'll discuss more about symbols
    when we learn about metaprogramming. For now, you can just think of symbols as
    identifiers or labels.
  prefs: []
  type: TYPE_NORMAL
- en: Using simple statistics to better understand our data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that it's clear how the data is structured and what is contained in the
    collection, we can get a better understanding by looking at some basic stats.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get us started, let''s invoke the `describe` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/053e3457-e544-496c-aaad-f5cd1f81c961.png)'
  prefs: []
  type: TYPE_IMG
- en: This function summarizes the columns of the `iris` `DataFrame`. If the columns
    contain numerical data (such as `SepalLength`), it will compute the minimum, median,
    mean, and maximum. The number of missing and unique values is also included. The
    last column reports the type of data stored in the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few other stats are available, including the 25^(th) and the 75^(th) percentile,
    and the first and the last values. We can ask for them by passing an extra `stats`
    argument, in the form of an array of symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0634a453-5f96-45eb-9df7-a0b496f89aa3.png)'
  prefs: []
  type: TYPE_IMG
- en: Any combination of stats labels is accepted. These are all the options—`:mean`,
    `:std`, `:min`, `:q25`, `:median`, `:q75`, `:max`, `:eltype`, `:nunique`, `:first`,
    `:last`, and `:nmissing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get all the stats, the special `:all` value is accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35176292-d49a-4cfa-a733-5387879f8d0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also compute these individually by using Julia''s `Statistics` package.
    For example, to calculate the mean of the `SepalLength` column, we''ll execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `iris[:SepalLength]` to select the whole column. The
    result, not at all surprisingly, is the same as that returned by the corresponding
    `describe()` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way we can compute the `median()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'And there''s (a lot) more, such as, for instance, the standard deviation `std()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use another function from the `Statistics` package, `cor(),` in
    a simple script to help us understand how the values are correlated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this snippet will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The script iterates over each column of the dataset with the exception of `Species`
    (the last column, which is not numeric), and generates a basic correlation table.
    The table shows strong positive correlations between `SepalLength` and `PetalLength`
    (87.17%), `SepalLength` and `PetalWidth` (81.79%), and `PetalLength` and `PetalWidth`
    (96.28%). There is no strong correlation between `SepalLength` and `SepalWidth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same script, but this time employ the `cov()` function to compute
    the covariance of the values in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The output illustrates that `SepalLength` is positively related to `PetalLength`
    and `PetalWidth`, while being negatively related to `SepalWidth`. `SepalWidth`
    is negatively related to all the other values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, if we want a random data sample, we can ask for it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, we can pass in the number of values to be sampled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert one of the columns to an array using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can convert the whole `DataFrame` to a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing the Iris flowers data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization is a powerful tool in exploratory data analysis, helping us to
    identify patterns that would otherwise be hard to spot just by looking at the
    numbers. Julia provides access to some excellent plotting packages that are very
    easy to set up and use.
  prefs: []
  type: TYPE_NORMAL
- en: We'll illustrate with some plots created with Gadfly.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by adding Gadfly with `pkg> add "Gadfly"`and we'll continue with `julia>
    using Gadfly`. This will bring into scope Gadfly's `plot()`method. Now, let's
    find some interesting data to visualize.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we have identified that there is a strong covariant
    relation between `SepalLength` and `PetalLength`. Let''s plot the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, Gadfly support for Julia v1 was still incomplete. If
    that is still the case, the unstable yet working version of Gadfly can be installed
    using—`pkg> add Compose#master`, `Gadfly#master`, `Hexagon`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the `plot()` function will generate the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5e56a6c-c9ce-481c-90b7-fd66be5bca88.png)'
  prefs: []
  type: TYPE_IMG
- en: Sure enough, the plot will indicate that `SepalLength` and `PetalLength` vary
    together for both Iris versicolor and Iris virginica. For Iris setosa, it's not
    that obvious, with `PetalLength` staying pretty much unchanged while the sepal
    length grows.
  prefs: []
  type: TYPE_NORMAL
- en: 'A box plot will confirm the same; the sepal length of Iris setosa has little
    variation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting our values looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71de0a21-e932-406e-9471-8b014ac3fda1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I have a feeling that a histogram would be even better for illustrating the
    distribution of the `PetalLength`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating a histogram using the `PetalLength` produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9b3d8b8-1a4c-4786-943c-b6776713a4d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we visualize the `PetalWidth` values as a histogram, we''ll notice a similar
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbea6825-f0aa-4f35-b41e-51223b2c175f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the petal width and height for the three species should now provide
    a strong indication that, for example, we can successfully classify Iris setosa
    based on the two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28ab11d2-ba23-4f48-839c-eb529e1679f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Loading and saving our data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia comes with excellent facilities for reading and storing data out of the
    box. Given its focus on data science and scientific computing, support for tabular-file
    formats (CSV, TSV) is first class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's extract some data from our initial dataset and use it to practice persistence
    and retrieval from various backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reference a section of a `DataFrame` by defining its bounds through
    the corresponding columns and rows. For example, we can define a new `DataFrame`
    composed only of the `PetalLength` and `PetalWidth` columns and the first three
    rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic indexing notation is `dataframe[rows, cols]`, where `rows` can
    be a number, a range, or an `Array` of `boolean` values where `true` indicates
    that the row should be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Armed with this knowledge, let''s take a sample from our original dataset.
    It will include some 10% of the initial data and only the `PetalLength`, `PetalWidth`,
    and `Species` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: What just happened here? The secret in this piece of code is `rand(150) .<=
    0.1`. It does a lot—first, it generates an array of random `Float` values between
    0 and 1; then, it compares the array, element-wise, against 0.1 (which represents
    10% of 1); and finally, the resultant `Boolean` array is used to filter out the
    corresponding rows from the dataset. It's really impressive how powerful and succinct
    Julia can be!
  prefs: []
  type: TYPE_NORMAL
- en: In my case, the result is a `DataFrame` with the preceding 10 rows, but your
    data will be different since we're picking random rows (and it's quite possible
    you won't have exactly 10 rows either).
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading using tabular file formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily save this data to a file in a tabular file format (one of CSV,
    TSV, and others) using the `CSV` package. We''ll have to add it first and then
    call the `write` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'And, just as easily, we can read back the data from tabular file formats, with
    the corresponding `CSV.read` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Just specifying the file extension is enough for Julia to understand how to
    handle the document (CSV, TSV), both when writing and reading.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Feather files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feather is a binary file format that was specially designed for storing data
    frames. It is fast, lightweight, and language-agnostic. The project was initially
    started in order to make it possible to exchange data frames between R and Python.
    Soon, other languages added support for it, including Julia.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for Feather files does not come out of the box, but is made available
    through the homonymous package. Let''s go ahead and add it and then bring it into
    scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, saving our `DataFrame` is just a matter of calling `Feather.write`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s try the reverse operation and load back our Feather file. We''ll
    use the counterpart `read` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, that's our sample data all right!
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide compatibility with other languages, the Feather format imposes
    some restrictions on the data types of the columns. You can read more about Feather
    in the package's official documentation at [https://juliadata.github.io/Feather.jl/latest/index.html](https://juliadata.github.io/Feather.jl/latest/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before closing this chapter, let's take a look at using a NoSQL backend for
    persisting and retrieving our data. Don't worry, we'll extensively cover interaction
    with relational databases in the upcoming chapters too.
  prefs: []
  type: TYPE_NORMAL
- en: In order to follow through this chapter, you'll need a working MongoDB installation.
    You can download and install the correct version for your operating system from
    the official website, at [https://www.mongodb.com/download-center?jmp=nav#community](https://www.mongodb.com/download-center?jmp=nav#community).
    I will use a Docker image which I installed and started up through Docker's Kitematic
    (available for download at [https://github.com/docker/kitematic/releases](https://github.com/docker/kitematic/releases)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to make sure to add the `Mongo` package. The package also has
    a dependency on `LibBSON`, which is automatically added. `LibBSON` is used for
    handling `BSON`, which stands for *Binary JSON*, a binary-encoded serialization
    of JSON-like documents. While we''re at it, let''s add the `JSON` package as well;
    we will need it. I''m sure you know how to do that by now—if not, here is a reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, Mongo.jl support for Julia v1 was still a work in progress.
    This code was tested using Julia v0.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Easy! Let''s let Julia know that we''ll be using all these packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to connect to MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Once successfully connected, we can reference a `dataframes` collection in
    the `db` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Julia''s MongoDB interface uses dictionaries (a data structure called `Dict`
    in Julia) to communicate with the server. We''ll look at `dicts` in more detail
    in the next chapter. For now, all we need to do is to convert our `DataFrame`
    to such a `Dict`. The simplest way to do it is to sequentially serialize and then
    deserialize the `DataFrame` by using the `JSON` package. It generates a nice structure
    that we can later use to rebuild our `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Thinking ahead, to make any future data retrieval simpler, let''s add an identifier
    to our dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can insert it into Mongo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to retrieve it, all we have to do is query the Mongo database using
    the "id" field we''ve previously configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a `BSONObject`, which we need to convert back to a `DataFrame`. Don''t
    worry, it''s straightforward. First, we create an empty `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we populate it using the data we retrieved from Mongo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Our data has been loaded back into a `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's intuitive syntax makes for a lean learning curve. The optional typing
    and the wealth of shorthand constructors result in readable, noise-free code,
    while the large collection of third-party packages makes accessing, manipulating,
    visualizing, plotting, and saving data a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Just by learning Julia's basic data structures and a few related functions,
    coupled with its powerful data manipulation toolset, we were able to implement
    an efficient data analysis workflow and extract valuable insight from the Iris
    flowers dataset. That was all we needed in order to perform efficient exploratory
    data analysis with Julia.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue our journey by learning how to build a web
    crawler. Web mining, the process of extracting information from the web, is an
    important part of data mining and a key component of data acquisition in general.
    Julia is a great choice when building web mining software, given not only its
    built-in performance and its rapid prototyping features, but also the availability
    of powerful libraries that cover everything, from HTTP clients, to DOM parsing,
    to text analysis.
  prefs: []
  type: TYPE_NORMAL
