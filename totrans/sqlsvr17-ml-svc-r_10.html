<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">R and SQL Server 2016/2017 Features Extended</h1>
                
            
            <article>
                
<p class="calibre2"><span>SQL Server 2016 and 2017 provide a lot of new and improved query performance capabilities, extensibility features, security features, and built-in/native capabilities that are useful for developers, DBAs, and data scientists. These new features and capabilities can be used together with machine learning services in SQL, bringing a powerful data science solution as well as making the life of the developer/data scientist much easier.</span><br class="title-page-name"/></p>
<p class="calibre2">This chapter will walk you through a few unique scenarios to show the combined power of R and other built-in capabilities in SQL Server. These scenarios include JSON built-in capabilities to show how we work with IoT data, PolyBase to illustrate beyond relational data sources, and a large amount of data with the <kbd class="calibre11">ColumnStore</kbd> index. We will dive into these scenarios and produce data visualization and predictive analysis power in R that we have learned in previous chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Built-in JSON capabilities</h1>
                
            
            <article>
                
<p class="calibre2">In this scenario, we will use the EMS incidents by month from the official city of Austin open data portal (<a href="https://data.austintexas.gov/Public-Safety/EMS-Incidents-by-Month/gjtj-jt2d" class="calibre10">https://data.austintexas.gov/Public-Safety/EMS-Incidents-by-Month/gjtj-jt2d</a>). The data essentially contains incident counts, broken down by location and priorities for the city of Austin and Travis County incidents, and the percentage of on-time compliance.</p>
<p class="calibre2">The following are the prerequisites to get started:</p>
<ol class="calibre14">
<li value="1" class="calibre8">Download the data from <a href="https://data.austintexas.gov/resource/bpws-iwvb.json" class="calibre10">https://data.austintexas.gov/resource/bpws-iwvb.json</a> to a local path, such as <kbd class="calibre11">C:\Temp\bpws-iwvb.json</kbd>.</li>
<li value="2" class="calibre8">Grant read access to the directory; for example:</li>
</ol>
<div class="packt_figure"><img class="aligncenter104" src="../images/00178.jpeg"/></div>
<div class="cdpaligncenter">Figure 10.1 Granting access to C:\Temp for MS SQL Server</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">For ease of R visualization, we will use SQL Operations Studio. You can download SQL Ops Studio from: <a href="https://docs.microsoft.com/en-us/sql/sql-operations-studio/download" target="_blank" class="calibre10">https://docs.microsoft.com/en-us/sql/sql-operations-studio/download</a>.</li>
</ol>
<p class="calibre34">The following is an excerpt of a JSON file:</p>
<div class="packt_figure"><img src="../images/00179.jpeg" class="calibre27"/></div>
<div class="cdpaligncenter">Figure 10.2: Excerpt of bpws-iwvb.json</div>
<p class="calibre34">The schema of the JSON object in this file is fairly straightforward. It's an array of the following 31 properties:</p>
<ul class="calibre7">
<li class="front-matter">
<ul class="calibre17">
<li class="calibre8"><kbd class="calibre11">count_incidents_all</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_coa</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_coa_or_tc</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_coa_p1</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_coa_p2</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_coa_p3</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_coa_p4</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_coa_p5</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_other</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_tc</kbd></li>
<li class="calibre8"><kbd class="calibre11"><kbd class="calibre84">count_incidents_tc_p1</kbd></kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_tc_p2</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_tc_p3</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_tc_p4</kbd></li>
<li class="calibre8"><kbd class="calibre11">count_incidents_tc_p5</kbd></li>
<li class="calibre8"><kbd class="calibre11">month_key</kbd></li>
<li class="calibre8"><kbd class="calibre11">month_start_date</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_all</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_coa</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_coa_p1</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_coa_p2</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_coa_p3</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_coa_p4</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_coa_p5</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_target</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_tc</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_tc_p1</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_tc_p2</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_tc_p3</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_tc_p4</kbd></li>
<li class="calibre8"><kbd class="calibre11">percent_on_time_tc_p5</kbd></li>
</ul>
</li>
</ul>
<p class="calibre34">To see a first row of the data and what the value looks like, you can use the following T-SQL code:</p>
<pre class="calibre33"><strong class="calibre1">SELECT * 
FROM OPENJSON((SELECT Doc.BulkColumn  
                FROM OPENROWSET(BULK N'C:\Temp\bpws-iwvb.json', SINGLE_CLOB) AS Doc), '$[0]')</strong> </pre>
<p class="calibre34">The following is the output of the previous command:</p>
<div class="packt_figure"><img class="aligncenter105" src="../images/00180.jpeg"/></div>
<div class="cdpaligncenter">Figure 10.3 Inspecting the first row of data in bpws-iwvb.json</div>
<p class="calibre2">The remainder of this section will show you how to use built-in JSON and R capabilities in SQL Server to parse the data and create a visualization to understand the trends of EMS incidents received by ATCEMS. The following screenshot shows the data visualization that we will build from the preceding JSON data via SQL Operations Studio:</p>
<div class="packt_figure"><img src="../images/00181.jpeg" class="calibre94"/></div>
<div class="cdpaligncenter">Figure 10.4 Using R to produce a forecast of EMS incidents</div>
<p class="calibre2">Perform the following steps to build the preceding visualization:</p>
<ol class="calibre14">
<li value="1" class="calibre8">Open SQL Operations Studio.</li>
<li value="2" class="calibre8">Using JSON,  get the <kbd class="calibre11">Date</kbd> and incident counts:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">SELECT  
    a.Date,  
    a.TotalIncidents, 
    a.AustinIncidents, 
    a.TravisIncidents 
FROM OPENJSON((SELECT Doc.BulkColumn  
                FROM OPENROWSET(BULK N'C:\Temp\bpws-iwvb.json', SINGLE_CLOB) AS Doc), '$') 
WITH (Date          DATE    '$.month_start_date', 
    TotalIncidents  INT     '$.count_incidents_all', 
    AustinIncidents INT     '$.count_incidents_coa', 
    TravisIncidents INT     '$.count_incidents_tc' 
    ) AS a 
ORDER BY a.Date ASC;</strong></pre>
<p class="calibre34">Here, we are using <kbd class="calibre11">OPENROWSET</kbd> and <kbd class="calibre11">SINGLE_CLOB</kbd> to read the file stream in clear text.</p>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">Then, we use <kbd class="calibre11">OPEN_JSON</kbd> to extract <kbd class="calibre11">month_start_date</kbd> as <kbd class="calibre11">Date</kbd>, <kbd class="calibre11">count_incidents_all</kbd> as <kbd class="calibre11">TotalIncidients</kbd>, <kbd class="calibre11">count_incidents_coa</kbd> as <kbd class="calibre11">AustinIncidents</kbd>, and <kbd class="calibre11">count_incidents_tc</kbd> as <kbd class="calibre11">TravisIncidents</kbd>.</li>
</ol>
<p class="calibre34">The output should look something like this:</p>
<div class="packt_figure"><img class="aligncenter106" src="../images/00182.jpeg"/></div>
<div class="cdpaligncenter">Figure 10.5: Output of running OPENJSON against the EMS Incident JSON file</div>
<ol start="4" class="calibre14">
<li value="4" class="calibre8">Now, let's build the <kbd class="calibre11">InputDataSet</kbd> for the R script with the <kbd class="calibre11">Date</kbd> and <kbd class="calibre11">TotalIncidents</kbd> data:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">DECLARE @input_query    NVARCHAR(MAX);  
SET @input_query = 'SELECT  
    a.Date,  
    a.TotalIncidents 
FROM OPENJSON((SELECT Doc.BulkColumn  
    FROM OPENROWSET(BULK N'C:\Temp\bpws-iwvb.json',  
         SINGLE_CLOB) AS Doc), '$') 
   WITH (Date            DATE  '$.month_start_date', 
         TotalIncidents  INT   '$.count_incidents_all' 
        ) AS a;' </strong></pre>
<ol start="5" class="calibre14">
<li value="5" class="calibre8">Let's build the R script that uses the preceding <kbd class="calibre11">InputDataSet</kbd>:</li>
</ol>
<p class="calibre34">In this script, we will use the forecast package to perform forecasting based on the existing data in January 2010 and November 2017. More information about the forecast package, including the dependent packages, is available at: <a href="https://cran.r-project.org/web/packages/forecast/index.html" class="calibre10">https://cran.r-project.org/web/packages/forecast/index.html</a>.</p>
<p class="calibre34">In this specific example, the number of incidents can be seasonal. So, we are going to use a few helping functions that help with forecasting:</p>
<ul class="calibre7">
<li class="front-matter">
<ul class="calibre17">
<li class="calibre8"><kbd class="calibre11">ts</kbd> function to convert the <kbd class="calibre11">InputDataSet</kbd> dataframe into time series</li>
<li class="calibre8"><kbd class="calibre11">stl</kbd> function to decompose a time series into seasonal, trend, and irregular components</li>
<li class="calibre8"><kbd class="calibre11">forecast</kbd> function that takes into account seasonality:</li>
</ul>
</li>
</ul>
<pre class="calibre33"><strong class="calibre1">DECLARE @RPlot          NVARCHAR(MAX); 
 
SET @RPlot = 'library(forecast); 
    image_file = tempfile();  
    jpeg(filename = image_file, width=1000, height=400);  
 
    #store as time series  
    myts &lt;- ts(InputDataSet$TotalIncidents,  
        start = c(2010, 1), end = c(2017, 11), 
         frequency = 12);  
    fit &lt;- stl(myts, s.window = "period"); 
 
    # show the plot 
    plot(forecast(fit), main = "Forecast of EMS incidents"); 
    dev.off();  
 
    # return the plot as dataframe 
    OutputDataSet &lt;-  data.frame( 
        data=readBin(file(image_file,"rb"), 
        what=raw(),n=1e6));'</strong> </pre>
<ol start="6" class="calibre14">
<li value="6" class="calibre8">Now, let's execute the following script:</li>
</ol>
<pre class="calibre95"><strong class="calibre1">EXEC sp_execute_external_script @language = N'R' 
    ,@script = @RPlot  
    ,@input_data_1 = @input_query 
    ,@input_data_1_name = N'InputDataSet' 
    ,@output_data_1_name = N'OutputDataSet'  
    WITH RESULT SETS (( [plot] VARBINARY(MAX)));</strong>     </pre>
<ol start="7" class="calibre14">
<li value="7" class="calibre8">In SQL Ops Studio, the result will be in the <kbd class="calibre11">VARBINARY</kbd> data type:</li>
</ol>
<div class="packt_figure"><img src="../images/00183.jpeg" class="calibre96"/></div>
<div class="cdpaligncenter">Figure 10.6: View as Chart function in SQL Operations Studio</div>
<ol start="8" class="calibre14">
<li value="8" class="calibre8">Click on the <span>View as Chart</span> icon on the right, then click on the <span>Chart Viewer</span> tab on the <span>Results</span> pane, and then choose <span>image</span> from <span>Chart Type</span>. The output should be similar to the following:</li>
</ol>
<div class="packt_figure"><img class="aligncenter107" src="../images/00184.jpeg"/></div>
<div class="cdpaligncenter">Figure 10.7: Displaying the chart produced by R in SQL Operations Studio</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing external data sources using PolyBase</h1>
                
            
            <article>
                
<p class="calibre2">PolyBase allows your SQL Server instance to access data outside of the server/database using T-SQL. In SQL Server 2016, you can run queries on external data in Hadoop or import data from Azure Blob Storage:</p>
<div class="packt_figure"><img class="aligncenter108" src="../images/00185.jpeg"/></div>
<div class="cdpaligncenter">Figure 10.8: PolyBase concept (source: https://docs.microsoft.com/en-us/sql/relational-databases/polybase/polybase-guide)</div>
<p class="calibre2">In this section, we'll use a similar dataset as in the previous section, represented as CSV files in Azure Blob Storage. These CSV files represent the EMS incidents, which will be exposed as an external table in SQL Server. The goal for this walk-through is to understand seasonality and the trending of EMS incidents. We will use R in the SQL Server to do this and view the chart in SQL Operations Studio.</p>
<p class="calibre2">The following are the prerequisites to get started:</p>
<ol class="calibre14">
<li value="1" class="calibre8">The SQL Server instance installed with PolyBase. This step is documented at: <a href="https://docs.microsoft.com/en-us/sql/relational-databases/polybase/get-started-with-polybase" target="_blank" class="calibre10">https://docs.microsoft.com/en-us/sql/relational-databases/polybase/get-started-with-polybase</a></li>
<li value="2" class="calibre8">Microsoft Azure Storage Explorer installed. Using Azure Storage Explorer, you can upload files, manage containers in your storage account, and get a Primary Access Key from the storage account:</li>
</ol>
<div class="packt_figure"><img src="../images/00186.jpeg" class="calibre97"/></div>
<div class="cdpaligncenter">Figure 10.9: Using Microsoft Azure Storage Explorer to connect to Azure Blob Storage</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">EMS Incident by Month downloaded from &lt;insert GitHub link&gt; and uploaded to your Azure Blob Storage.</li>
<li value="4" class="calibre8">SSMS or SQL Operations Studio installed.</li>
</ol>
<p class="calibre2">Perform the following steps to create an external table:</p>
<ol class="calibre14">
<li value="1" class="calibre8">Enable the advanced option to enable connectivity to Azure Blob Storage on the master database first.</li>
</ol>
<p class="calibre34">Having Hadoop connectivity set to 7 allows connectivity to Azure Blob Storage. For more information on others supported data sources, visit:</p>
<p class="calibre34"><a href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/polybase-connectivity-configuration-transact-sql" target="_blank" class="calibre10">https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/polybase-connectivity-configuration-transact-sql</a></p>
<pre class="calibre33"><strong class="calibre1">USE master;   
GO   
EXEC sp_configure 'show advanced option', '1';   
RECONFIGURE;  
GO 
EXEC sp_configure 'hadoop connectivity', 7;  
GO  
RECONFIGURE;  
GO</strong> </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">Create a master key in your database where you'd like to create an external table connecting to the CSV files in Azure Blob Storage:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">USE [AdventureWorks2016] 
GO 
CREATE MASTER KEY ENCRYPTION BY PASSWORD='MsSQLGirlLovesSQLServer2016&amp;2017:)';</strong> </pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">Create the database <kbd class="calibre11">MsSQLGirlAtAzureBlobStorage</kbd>:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE DATABASE SCOPED CREDENTIAL MsSQLGirlAtAzureBlobStorage   
WITH IDENTITY = 'credential', Secret = 'Es3duvq+x9G5x+EFbuUmGo0salEi6Jsd59NI20KXespbiBG9RswLA4L1fuqs/59porPBay64YkRj/tvQ7XAMLA=='; </strong></pre>
<ol start="4" class="calibre14">
<li value="4" class="calibre8">Create the external data source pointing to a container in Azure Blob Storage. In this instance, <kbd class="calibre11">open-data-sample</kbd> is the name of the container, and <kbd class="calibre11">mssqlgirl.blob.core.windows.net</kbd> is the Azure Blob Storage location:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE EXTERNAL DATA SOURCE OpenDataSample 
WITH ( 
    TYPE = HADOOP, 
    LOCATION = 'wasbs://open-data-sample@mssqlgirl.blob.core.windows.net/', 
    CREDENTIAL = MsSQLGirlAtAzureBlobStorage 
);</strong> </pre>
<ol start="5" class="calibre14">
<li value="5" class="calibre8">Create the file format of the source files in the container:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE EXTERNAL FILE FORMAT csvformat  
WITH (  
    FORMAT_TYPE = DELIMITEDTEXT,  
    FORMAT_OPTIONS (  
        FIELD_TERMINATOR = ',' 
    )  
);</strong> </pre>
<ol start="6" class="calibre14">
<li value="6" class="calibre8">Create the following source files in the container:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE EXTERNAL TABLE EMSIncident 
(  
   [Month Key]                         INT, 
   [Month-Year]                        VARCHAR(30), 
   [Total Incidents]                   INT, 
   [Austin Incidents]                  INT, 
   [Travis County Incidents]           INT, 
   [Other Area Incidents]              INT, 
   [Combined Austin &amp; Travis Incidents]      INT, 
   [Austin P1 Incidents]               INT, 
   [Austin P2 Incidents]               INT, 
   [Austin P3 Incidents]               INT, 
   [Austin P4 Incidents]               INT, 
   [Austin P5 Incidents]               INT, 
   [Travis County P1 Incidents]        INT, 
   [Travis County P2 Incidents]        INT, 
   [Travis County P3 Incidents]        INT, 
   [Travis County P4 Incidents]        INT, 
   [Travis County P5 Incidents]        INT, 
   [Overall On-Time Compliance]        VARCHAR(10), 
   [Austin On-Time Compliance]               VARCHAR(10), 
   [Travis County On-Time Compliance]        VARCHAR(10), 
   [Austin P1 On-Time Compliance]            VARCHAR(10), 
   [Austin P2 On-Time Compliance]            VARCHAR(10), 
   [Austin P3 On-Time Compliance]            VARCHAR(10), 
   [Austin P4 On-Time Compliance]            VARCHAR(10), 
   [Austin P5 On-Time Compliance]            VARCHAR(10), 
   [Travis County P1 On-Time Compliance]     VARCHAR(10), 
   [Travis County P2 On-Time Compliance]     VARCHAR(10), 
   [Travis County P3 On-Time Compliance]     VARCHAR(10), 
   [Travis County P4 On-Time Compliance]     VARCHAR(10), 
   [Travis County P5 On-Time Compliance]     VARCHAR(10), 
   [Target On-Time Compliance]               VARCHAR(10) 
)  
WITH  
(  
    LOCATION = '/EMS_-_Incidents_by_Month.csv',  
    DATA_SOURCE = OpenDataSample,  
    FILE_FORMAT = csvformat  
)</strong> </pre>
<ol start="7" class="calibre14">
<li value="7" class="calibre8">So, now we can do a <kbd class="calibre11">SELECT</kbd> statement on the external table as an input to the R script:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">DECLARE @input_query    NVARCHAR(MAX);  
DECLARE @RPlot          NVARCHAR(MAX); 
 
SET @input_query = 'SELECT  
    CAST([Month-Year] AS DATE) AS [Date], 
    [Total Incidents] AS [TotalIncidents] 
FROM EMSIncident;' 
SET @RPlot = 'library(ggplot2);  
    library(forecast); 
    image_file = tempfile();  
    jpeg(filename = image_file, width=1000, height=400);  
 
    #store as time series  
    myts &lt;- ts(InputDataSet$TotalIncidents,  
        start = c(2010, 1), end = c(2017, 11), 
         frequency = 12);  
    fit &lt;- stl(myts, s.window = "period"); 
    
    # show the plot 
    plot(fit, main = "EMS incidents"); 
    dev.off();  
 
    # return the plot as dataframe 
    OutputDataSet &lt;-  data.frame( 
        data=readBin(file(image_file,"rb"), 
        what=raw(),n=1e6));' 
 
 
EXEC sp_execute_external_script @language = N'R' 
    ,@script = @RPlot  
    ,@input_data_1 = @input_query 
    ,@input_data_1_name = N'InputDataSet' 
    ,@output_data_1_name = N'OutputDataSet'  
    WITH RESULT SETS (( [plot] VARBINARY(MAX)));     </strong></pre>
<p class="calibre2">If you are using SQL Operations Studio, you can view the graph, which should look like the following:</p>
<div class="packt_figure"><img class="aligncenter109" src="../images/00187.jpeg"/></div>
<div class="cdpaligncenter">Figure 10.10: EMS incidents time series</div>
<p class="calibre2">The preceding chart suggests that the trend is increasing from year 2010 to 2016, which then significantly decreases in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">High performance using ColumnStore and in memory OLTP</h1>
                
            
            <article>
                
<p class="calibre2">SQL Server 2016 R Services and SQL Server 2017 ML Services provide advanced analytical capabilities that can also be applied to optimized tables. In this section, we will walk you through comparisons on how to use R Services with:</p>
<ul class="calibre7">
<li class="calibre8">A table with a primary key</li>
<li class="calibre8">A table with a clustered <kbd class="calibre11">ColumnStore</kbd> index</li>
<li class="calibre8">A memory-optimized table</li>
<li class="calibre8">A memory-optimized table with a clustered <kbd class="calibre11">ColumnStore</kbd> index</li>
</ul>
<div class="packt_tip">For more optimization tips and tricks with SQL Server and machine learning, visit:<br class="calibre30"/>
<a href="https://azure.microsoft.com/en-us/blog/optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services/" target="_blank" class="calibre40">https://azure.microsoft.com/en-us/blog/optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services/</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing rxLinMod performance on a table with a primary key</h1>
                
            
            <article>
                
<p class="calibre2">The following steps will test the performance of <kbd class="calibre11">rxLinMod</kbd> over 6,096,762 bits of data stored in a table with a primary key. This Air Flights data can be downloaded from <a href="https://packages.revolutionanalytics.com/datasets/AirOnTime2012.xdf" class="calibre10">https://packages.revolutionanalytics.com/datasets/AirOnTime2012.xdf</a> and stored in <kbd class="calibre11">C:/Program Files/Microsoft SQL Server/140/R_SERVER/library/RevoScaleR/SampleData</kbd>. At the end of the steps, we will record the CPU time:</p>
<ol class="calibre14">
<li value="1" class="calibre8">Create a stored procedure that reads the <kbd class="calibre11">AirFlights</kbd> sample data in an XDF file, and return it as a data frame so that we can insert it into a new table:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE PROCEDURE [dbo].[usp_ImportXDFtoSQL] 
AS 
   DECLARE @RScript NVARCHAR(MAX) 
   SET @RScript = N'library(RevoScaleR) 
         rxOptions(sampleDataDir = "C:/Program Files/Microsoft SQL Server/140/R_SERVER/library/RevoScaleR/SampleData"); 
         outFile &lt;-  file.path(rxGetOption("sampleDataDir"), "AirOnTime2012.xdf"); 
         OutputDataSet &lt;- data.frame(rxReadXdf(file=outFile, varsToKeep=c("ArrDelay", "CRSDepTime","DayOfWeek")))' 
 
   EXECUTE sp_execute_external_script 
          @language = N'R' 
         ,@script = @RScript 
         WITH RESULT SETS (( 
               [ArrDelay]        SMALLINT, 
               [CRSDepTime]      DECIMAL(6,4), 
               [DayOfWeek]       NVARCHAR(10))); 
GO</strong></pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">Create a table where the <kbd class="calibre11">AirFlights</kbd> data will be stored. This table represents a row-stored table with a primary key:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE TABLE [dbo].[AirFlights] 
( 
    [ID]             INT NOT NULL IDENTITY(1,1)  
   ,[ArrDelay]       SMALLINT 
   ,[CRSDepTime]     DECIMAL(6,4) 
   ,[DayOfWeek]      NVARCHAR(10)  
   ,CONSTRAINT PK_AirFlights PRIMARY KEY ([ID]) 
); 
GO </strong></pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">Insert the Air Flights data into the <kbd class="calibre11">AirFlights</kbd> table. In this instance, we are using R services to load the data:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">INSERT INTO [dbo].[AirFlights] 
EXECUTE [dbo].[usp_ImportXDFtoSQL]</strong> </pre>
<ol start="4" class="calibre14">
<li value="4" class="calibre8">Create a procedure that calls an external script to calculate the coefficient from the linear model prediction of the Arrival Delay:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE PROCEDURE dbo.usp_TestPerformance (@TableName VARCHAR(50)) 
AS 
   DECLARE @RScript NVARCHAR(MAX) 
   SET @RScript = N'library(RevoScaleR) 
                           LMResults &lt;- rxLinMod(ArrDelay ~ DayOfWeek, data = InputDataSet) 
                           OutputDataSet &lt;- data.frame(LMResults$coefficients)' 
 
   DECLARE @SQLScript nvarchar(max) 
   SET @SQLScript = N'SELECT ArrDelay, DayOfWeek FROM ' + @TableName  
   SET STATISTICS TIME ON; 
   EXECUTE sp_execute_external_script 
          @language = N'R' 
         ,@script = @RScript 
         ,@input_data_1 = @SQLScript 
   WITH RESULT SETS (( 
                     Coefficient DECIMAL(10,5) 
                     )); 
 
   SET STATISTICS TIME OFF; 
GO</strong> </pre>
<ol start="5" class="calibre14">
<li value="5" class="calibre8">Execute the procedure, as follows:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">EXEC dbo.usp_TestPerformance '[dbo].[AirFlights]'</strong> </pre>
<p class="calibre34">The result should look something like this:</p>
<pre class="calibre33"><strong class="calibre1">SQL Server parse and compile time:  
   CPU time = 0 ms, elapsed time = 1 ms. 
STDOUT message(s) from external script:  
Rows Read: 6096762, Total Rows Processed: 6096762, Total Chunk Time: 0.075 seconds  
Computation time: 0.080 seconds. 
(8 rows affected) 
 SQL Server Execution Times: 
   CPU time = 2797 ms,  elapsed time = 10463 ms. 
 SQL Server Execution Times: 
   CPU time = 2797 ms,  elapsed time = 10464 ms.</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing rxLinMod performance on a table with a clustered ColumnStore index</h1>
                
            
            <article>
                
<p class="calibre2">The following steps will test the performance of <kbd class="calibre11">rxLinMod</kbd> over 6,096,762 bits of data stored in a table with a clustered <kbd class="calibre11">ColumnStore</kbd> index. At the end of the steps, we will record the CPU time:</p>
<ol class="calibre14">
<li value="1" class="calibre8">Create a table similar to <kbd class="calibre11">dbo.AirFlights</kbd> from the previous section. We also want to create a clustered <kbd class="calibre11">ColumnStore</kbd> index and insert the data from <kbd class="calibre11">dbo.AirFlights</kbd>:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE TABLE AirFlights_CS 
( 
    [ID]             INT NOT NULL IDENTITY(1,1) 
   ,[ArrDelay]       SMALLINT 
   ,[CRSDepTime]     DECIMAL(6,4) 
   ,[DayOfWeek]      NVARCHAR(10)  
); 
GO 
 
INSERT INTO [dbo].[AirFlights_CS] 
( 
    [ArrDelay]        
   ,[CRSDepTime]      
   ,[DayOfWeek]       
) 
SELECT  
    [ArrDelay]        
   ,[CRSDepTime]      
   ,[DayOfWeek]       
FROM [dbo].[AirFlights];  
GO 
 
CREATE CLUSTERED COLUMNSTORE INDEX CCI_Airflights_CS ON [dbo].[AirFlights_CS]  
GO</strong> </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">Execute the following procedure:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">EXEC dbo.usp_TestPerformance '[dbo].[AirFlights_CS]'</strong> </pre>
<p class="calibre34">The result should look something like the following:</p>
<pre class="calibre33"><strong class="calibre1">SQL Server parse and compile time:  
   CPU time = 0 ms, elapsed time = 7 ms. 
STDOUT message(s) from external script:  
Rows Read: 6096762, Total Rows Processed: 6096762, Total Chunk Time: 0.075 seconds  
Computation time: 0.080 seconds. 
(8 rows affected) 
 SQL Server Execution Times: 
   CPU time = 2235 ms,  elapsed time = 10684 ms. 
 SQL Server Execution Times: 
   CPU time = 2235 ms,  elapsed time = 10692 ms.</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing rxLinMod performance on a memory-optimized table with a primary key</h1>
                
            
            <article>
                
<p class="calibre2">The following steps will test the performance of <kbd class="calibre11">rxLinMod</kbd> over 6,096,762 bits of data stored in a memory-optimized table with a non-clustered primary key. At the end of the steps, we will record the CPU time:</p>
<ol class="calibre14">
<li value="1" class="calibre8">Create a file group for the memory-optimized table in the database:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">ALTER DATABASE PerfTuning  
   ADD FILEGROUP PerfTuningMOD CONTAINS MEMORY_OPTIMIZED_DATA; 
 
ALTER DATABASE PerfTuning  
   ADD FILE (NAME='PerfTuningMOD',  
   FILENAME = 'C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\MSSQL\DATA\PerfTuningMOD.ndf')  
   TO FILEGROUP PerfTuningMOD; 
 
ALTER DATABASE PerfTuning  
   SET MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT=ON   
GO  </strong> </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">Create a memory-optimized table version of <kbd class="calibre11">dbo.AirFlights</kbd>:</li>
</ol>
<pre class="calibre18">    <strong class="calibre1">CREATE TABLE [dbo].[AirFlights_MOD] </strong>
    <strong class="calibre1">(  </strong>
    <strong class="calibre1">       [ID] INT IDENTITY(1,1) NOT NULL PRIMARY KEY NONCLUSTERED</strong>
    <strong class="calibre1">      ,[ArrDelay] SMALLINT</strong>
    <strong class="calibre1">      ,[CRSDepTime]     DECIMAL(6,4)</strong>
    <strong class="calibre1">      ,[DayOfWeek]      NVARCHAR(10) </strong>
    <strong class="calibre1">) WITH (MEMORY_OPTIMIZED=ON, DURABILITY = SCHEMA_AND_DATA);</strong>
    
    <strong class="calibre1">GO</strong>
    
    <strong class="calibre1">INSERT INTO [dbo].[AirFlights_MOD]</strong>
    <strong class="calibre1">(</strong>
    <strong class="calibre1">       [ArrDelay]       </strong>
    <strong class="calibre1">      ,[CRSDepTime]     </strong>
    <strong class="calibre1">      ,[DayOfWeek]      </strong>
    <strong class="calibre1">)</strong>
    <strong class="calibre1">SELECT </strong>
    <strong class="calibre1">       [ArrDelay]       </strong>
    <strong class="calibre1">      ,[CRSDepTime]     </strong>
    <strong class="calibre1">      ,[DayOfWeek]      </strong>
    <strong class="calibre1">FROM [dbo].[AirFlights] </strong>
    <strong class="calibre1">go</strong> </pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">Execute the following procedure:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">EXEC dbo.usp_TestPerformance '[dbo].[AirFlights_MOD]'</strong></pre>
<p class="calibre34">The result should look something like this:</p>
<pre class="calibre33"><strong class="calibre1">SQL Server parse and compile time: </strong>
<strong class="calibre1">   CPU time = 2 ms, elapsed time = 2 ms.</strong>
<strong class="calibre1">STDOUT message(s) from external script:</strong> <br class="title-page-name"/><strong class="calibre1">Rows Read: 6096762, Total Rows Processed: 6096762, Total Chunk     <br class="title-page-name"/>Time: 0.072 seconds </strong>
<strong class="calibre1">Computation time: 0.077 seconds.</strong>
<strong class="calibre1">(8 rows affected)</strong>
<strong class="calibre1"> SQL Server Execution Times:</strong>
<strong class="calibre1">   CPU time = 2109 ms,  elapsed time = 8835 ms.</strong>
<strong class="calibre1"> SQL Server Execution Times: 2235 ms,  elapsed time = 10692 ms.</strong>
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing rxLinMod performance on a memory-optimized table with a clustered ColumnStore index</h1>
                
            
            <article>
                
<p class="calibre2">The following steps will test the performance of <kbd class="calibre11">rxLinMod</kbd> over 6,096,762 bits of data stored in a memory-optimized table with a non-clustered primary key. At the end of the steps, we will record the CPU time:</p>
<ol class="calibre14">
<li value="1" class="calibre8">Create a memory-optimized table with a clustered <kbd class="calibre11">columstore</kbd> index version of <kbd class="calibre11">dbo.AirFlights</kbd>:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE TABLE [dbo].[AirFlights_MODCS]  
(   
    [ID] INT IDENTITY(1,1) NOT NULL PRIMARY KEY NONCLUSTERED 
   ,[ArrDelay] SMALLINT 
   ,[CRSDepTime] DECIMAL(6,4) 
   ,[DayOfWeek]      VARCHAR(10)  
) WITH (MEMORY_OPTIMIZED=ON, DURABILITY = SCHEMA_AND_DATA); 
GO 
 
INSERT INTO [dbo].[AirFlights_MODCS] 
( 
    [ArrDelay]        
   ,[CRSDepTime]      
   ,[DayOfWeek]       
) 
SELECT  
    [ArrDelay]        
   ,[CRSDepTime]      
   ,[DayOfWeek]       
FROM [dbo].[AirFlights]; 
GO 
ALTER TABLE [dbo].[AirFlights_MODCS] 
ADD INDEX CCI_Airflights_MODCS CLUSTERED COLUMNSTORE 
GO <br class="title-page-name"/></strong></pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">Execute the following procedure:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">EXEC dbo.usp_TestPerformance '[dbo].[AirFlights_MODCS]'</strong> </pre>
<p class="calibre34">The result should look something like this:</p>
<pre class="calibre33"><strong class="calibre1">SQL Server parse and compile time:  
   CPU time = 3 ms, elapsed time = 3 ms. 
STDOUT message(s) from external script:  
Rows Read: 6096762, Total Rows Processed: 6096762, Total Chunk Time: 0.088 seconds  
Computation time: 0.093 seconds. 
(8 rows affected) 
 SQL Server Execution Times: 
   CPU time = 1766 ms,  elapsed time = 8659 ms. 
 SQL Server Execution Times: 
   CPU time = 1782 ms,  elapsed time = 8662 ms.</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Comparing results</h1>
                
            
            <article>
                
<p class="calibre2">As you can see from the following quick chart comparison, SQL Server R Services can take advantage of optimized tables very well:</p>
<div class="packt_figure"><img src="../images/00188.jpeg" class="calibre98"/></div>
<div class="cdpaligncenter">Figure 10.11 Comparing performance of classic primary key, Columnstore, in-memory, and in-memory + Columnstore when used in combination with R Services</div>
<p class="calibre2">For additional information on the performance comparison, you can go to <em class="calibre12">Tomaž Kaštrun's</em> article here:</p>
<p class="calibre2"><a href="https://github.com/tomaztk/Performance-differences-between-RevoScaleR-ColumnStore-Table-and-In-Memory-OLTP-Table/blob/master/RevoScaleR_vs_ColumStore_vs_InMemoryOLTP.sql" class="calibre10">https://github.com/tomaztk/Performance-differences-between-RevoScaleR-ColumnStore-Table-and-In-Memory-OLTP-Table/blob/master/RevoScaleR_vs_ColumStore_vs_InMemoryOLTP.sql</a></p>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">SQL Server 2016 and SQL Server 2017 are packed with useful features, from JSON, PolyBase, to high performance features, such as the <kbd class="calibre11">ColumnStore</kbd> index and memory-optimized tables. Most of these features are compatible and can enhance your advanced analytics experience. In this chapter, you have learned the steps for creating forecast and seasonal trends of EMS incidents in Austin and Travis County. We used both JSON data source and CSV files in Azure Blob Storage. Finally, you also have learned how to make use of <kbd class="calibre11">ColumnStore</kbd> and memory-optimized tables to improve performance of R Services.</p>


            </article>

            
        </section>
    </body></html>