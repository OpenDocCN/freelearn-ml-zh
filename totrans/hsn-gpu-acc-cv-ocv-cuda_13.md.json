["```py\ninclude <iostream>\n#include <cuda.h>\n#include <cuda_runtime.h>\n__global__ void gpuSub(int d_a, int d_b, int *d_c) \n{\n *d_c = d_a - d_b;\n}\nint main(void) \n{\n  int h_c;\n  int *d_c;\n  cudaMalloc((void**)&d_c, sizeof(int));\n gpuSub << <1, 1 >> > (4, 1, d_c);\n cudaMemcpy(&h_c, d_c, sizeof(int), cudaMemcpyDeviceToHost);\n printf(\"4-1 = %d\\n\", h_c);\n cudaFree(d_c);\n return 0;\n}\n\n```", "```py\n#include <iostream>\n#include <cuda.h>\n#include <cuda_runtime.h>\n __global__ void gpuMul(int *d_a, int *d_b, int *d_c) \n{\n *d_c = *d_a * *d_b;\n}\nint main(void) \n{\n int h_a,h_b, h_c;\n int *d_a,*d_b,*d_c;\n h_a = 1;\n h_b = 4;\n cudaMalloc((void**)&d_a, sizeof(int));\n cudaMalloc((void**)&d_b, sizeof(int));\n cudaMalloc((void**)&d_c, sizeof(int));\n cudaMemcpy(d_a, &h_a, sizeof(int), cudaMemcpyHostToDevice);\n cudaMemcpy(d_b, &h_b, sizeof(int), cudaMemcpyHostToDevice);\n gpuMul << <1, 1 >> > (d_a, d_b, d_c);\n cudaMemcpy(&h_c, d_c, sizeof(int), cudaMemcpyDeviceToHost);\n printf(\"Passing Parameter by Reference Output: %d + %d = %d\\n\", h_a, h_b, h_c);\n cudaFree(d_a);\n cudaFree(d_b);\n cudaFree(d_c);\n return 0;\n }\n```", "```py\n1\\. gpuMul << <25, 200 >> > (d_a, d_b, d_c);\n2\\. gpuMul << <50, 100 >> > (d_a, d_b, d_c);\n3\\. gpuMul << <10, 500 >> > (d_a, d_b, d_c);\n```", "```py\nint main(void) \n{ \n  int device; \n  cudaDeviceProp device_property; \n  cudaGetDevice(&device); \n  printf(\"ID of device: %d\\n\", device); \n  memset(&device_property, 0, sizeof(cudaDeviceProp)); \n  device_property.major = 5; \n  device_property.minor = 0; \n  cudaChooseDevice(&device, &device_property); \n  printf(\"ID of device which supports double precision is: %d\\n\", device);                                                                         \n  cudaSetDevice(device); \n} \n```", "```py\n#include \"stdio.h\"\n#include<iostream>\n#include <cuda.h>\n#include <cuda_runtime.h>\n#define N 50\n__global__ void gpuCube(float *d_in, float *d_out) \n{\n     //Getting thread index for current kernel\n     int tid = threadIdx.x; // handle the data at this index\n     float temp = d_in[tid];\n     d_out[tid] = temp*temp*temp;\n }\nint main(void) \n{\n     float h_in[N], h_out[N];\n     float *d_in, *d_out;\n     cudaMalloc((void**)&d_in, N * sizeof(float));\n     cudaMalloc((void**)&d_out, N * sizeof(float));\n      for (int i = 0; i < N; i++) \n    {\n         h_in[i] = i;\n     }\n   cudaMemcpy(d_in, h_in, N * sizeof(float), cudaMemcpyHostToDevice);\n   gpuSquare << <1, N >> >(d_in, d_out);\n  cudaMemcpy(h_out, d_out, N * sizeof(float), cudaMemcpyDeviceToHost);\n    printf(\"Cube of Number on GPU \\n\");\n     for (int i = 0; i < N; i++) \n     {\n         printf(\"The cube of %f is %f\\n\", h_in[i], h_out[i]);\n     }\n     cudaFree(d_in);\n     cudaFree(d_out);\n     return 0;\n }\n```", "```py\ngpuAdd << <512, 512 >> >(d_a, d_b, d_c);\n```", "```py\n#include \"stdio.h\"\n#include<iostream>\n#include <cuda.h>\n#include <cuda_runtime.h>\n#define N 50000\n__global__ void gpuCube(float *d_in, float *d_out) \n{\n      int tid = threadIdx.x + blockIdx.x * blockDim.x; \nwhile (tid < N)\n{\n    float temp = d_in[tid];\n    d_out[tid] = temp*temp*temp;\n    tid += blockDim.x * gridDim.x;\n }\n}\nint main(void) \n{\n     float h_in[N], h_out[N];\n     float *d_in, *d_out;\n     cudaMalloc((void**)&d_in, N * sizeof(float));\n     cudaMalloc((void**)&d_out, N * sizeof(float));\n      for (int i = 0; i < N; i++) \n    {\n         h_in[i] = i;\n     }\n   cudaMemcpy(d_in, h_in, N * sizeof(float), cudaMemcpyHostToDevice);\n   gpuSquare << <512, 512 >> >(d_in, d_out);\n  cudaMemcpy(h_out, d_out, N * sizeof(float), cudaMemcpyDeviceToHost);\n    printf(\"Cube of Number on GPU \\n\");\n     for (int i = 0; i < N; i++) \n     {\n         printf(\"The cube of %f is %f\\n\", h_in[i], h_out[i]);\n     }\n     cudaFree(d_in);\n     cudaFree(d_out);\n     return 0;\n }\n```", "```py\n__global__ void gpuCube(float *d_in, float *d_out) \n{\n     int tid = threadIdx.x; \nif(tid%2 == 0)\n{\n     float temp = d_in[tid];\n     d_out[tid] = temp*temp*temp;\n }\nelse\n{\n    float temp = d_in[tid];\n    d_out[tid] = temp*temp*temp;\n}\n}\n```", "```py\n Mat img3(1960,1960, CV_64FC3, Scalar(0,0,255) )\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n   VideoCapture cap(0); \n   if (cap.isOpened() == false) \n   {\n     cout << \"Cannot open Webcam\" << endl;\n     return -1;\n }\n  Size frame_size(640, 640);\n  int frames_per_second = 30;\n\n  VideoWriter v_writer(\"images/video.avi\", VideoWriter::fourcc('M', 'J', 'P', 'G'), frames_per_second, frame_size, true); \n  cout<<\"Press Q to Quit\" <<endl;\n  String win_name = \"Webcam Video\";\n  namedWindow(win_name); //create a window\n   while (true)\n   {\n     Mat frame;\n     bool flag = cap.read(frame); // read a new frame from video \n     imshow(win_name, frame);\n     v_writer.write(frame);\n  if (waitKey(1) == 'q')\n  {\n     v_writer.release(); \n     break;\n  }\n }\nreturn 0;\n}\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n   VideoCapture cap(0); \n if (cap.isOpened() == false) \n {\n    cout << \"Cannot open Webcam\" << endl;\n    return -1;\n }\n cout<<\"Press Q to Quit\" <<endl;\n String win_name = \"Webcam Video\";\n namedWindow(win_name); //create a window\n while (true)\n {\n    Mat frame;\n    bool flag = cap.read(frame); // read a new frame from video \n    cvtColor(frame, frame,cv::COLOR_BGR2GRAY);\n    imshow(win_name, frame);\n  if (waitKey(1) == 'q')\n  {\n      break;\n  }\n }\nreturn 0;\n}\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\n\nint main (int argc, char* argv[])\n{\n    //Read Two Images \n    cv::Mat h_img1 = cv::imread(\"images/cameraman.tif\");\n    cv::Mat h_img2 = cv::imread(\"images/circles.png\");\n    //Create Memory for storing Images on device\n    cv::cuda::GpuMat d_result1,d_result2,d_img1, d_img2;\n    cv::Mat h_result1,h_result2;\nint64 work_begin = getTickCount(); \n    //Upload Images to device     \n    d_img1.upload(h_img1);\n    d_img2.upload(h_img2);\n\n    cv::cuda::add(d_img1,d_img2, d_result1);\n    cv::cuda::subtract(d_img1, d_img2,d_result2);\n    //Download Result back to host\n    d_result1.download(h_result1);\n     d_result2.download(h_result2);\n    int64 delta = getTickCount() - work_begin;\n//Frequency of timer\n    double freq = getTickFrequency();\n    double work_fps = freq / delta;\n    std::cout<<\"Performance of Thresholding on CPU: \" <<std::endl;\n    std::cout <<\"Time: \" << (1/work_fps) <<std::endl;   \n    cv::waitKey();\n    return 0;\n}\n```", "```py\ninclude <iostream>\n#include \"opencv2/opencv.hpp\"\n\nint main (int argc, char* argv[])\n{\n    cv::Mat h_img1 = cv::imread(\"images/cameraman.tif\");\n    cv::Mat h_img2 = cv::imread(\"images/circles.png\");\n    cv::cuda::GpuMat d_result1,d_result2,d_img1, d_img2;\n    cv::Mat h_result1,h_result2;\n    d_img1.upload(h_img1);\n    d_img2.upload(h_img2);\n\n    cv::cuda::bitwise_and(d_img1,d_img2, d_result1);\n    cv::cuda::biwise_or(d_img1, d_img2,d_result2);\n\n    d_result1.download(h_result1);\n     d_result2.download(h_result2);\ncv::imshow(\"Image1 \", h_img1);\n    cv::imshow(\"Image2 \", h_img2);\n    cv::imshow(\"Result AND operation \", h_result1);\ncv::imshow(\"Result OR operation \", h_result2);\n    cv::waitKey();\n    return 0;\n}\n```", "```py\ncv::Mat h_img2 = cv::imread(\"images/autumn.tif\",1);\ncv::Vec3b intensity1 = h_img1.at<cv::Vec3b>(cv::Point(200, 200));\nstd::cout<<\"Pixel Intensity of color Image at (200,200) is:\" << intensity1 << std::endl;\n```", "```py\ncv::cuda::resize(d_img1,d_result1,cv::Size(300, 200), cv::INTER_LINEAR);\n```", "```py\nint width= d_img1.cols;\nint height = d_img1.size().height;\ncv::cuda::resize(d_img1,d_result2,cv::Size(2*width, 2*height), cv::INTER_AREA); \n```", "```py\ncv::Mat element = cv::getStructuringElement(cv::MORPH_RECT,cv::Size(5,5)); \n  d_img1.upload(h_img1);\n  cv::Ptr<cv::cuda::Filter> filtert,filterb;\n  filtert = cv::cuda::createMorphologyFilter(cv::MORPH_TOPHAT,CV_8UC1,element);\n  filtert->apply(d_img1, d_resulte);\n  filterb = cv::cuda::createMorphologyFilter(cv::MORPH_BLACKHAT,CV_8UC1,element);\n  filterb->apply(d_img1, d_resultd);\n```", "```py\ncuda::cvtColor(d_frame, d_frame_hsv, COLOR_BGR2HSV);\n\n//Split HSV 3 channels\ncuda::split(d_frame_hsv, d_frame_shsv);\n\n//Threshold HSV channels for Yellow color\ncuda::threshold(d_frame_shsv[0], d_thresc[0], 20, 30, THRESH_BINARY);\ncuda::threshold(d_frame_shsv[1], d_thresc[1], 100, 255, THRESH_BINARY);\ncuda::threshold(d_frame_shsv[2], d_thresc[2], 100, 255, THRESH_BINARY);\n\n//Bitwise AND the channels\ncv::cuda::bitwise_and(d_thresc[0], d_thresc[1],d_intermediate);\ncv::cuda::bitwise_and(d_intermediate, d_thresc[2], d_result);\nd_result.download(h_result);\nimshow(\"Thresholded Image\", h_result); \nimshow(\"Original\", frame);\n```", "```py\nmyfirst_kernel(block=(512,512,1),grid=(1024,1014,1))\n```", "```py\nimport pycuda.gpuarray as gpuarray\nimport numpy\nimport pycuda.driver as drv\n\nstart = drv.Event()\nend=drv.Event()\nstart.record()\nstart.synchronize()\nn=10\nh_b = numpy.random.randint(1,5,(1,n))\nd_b = gpuarray.to_gpu(h_b.astype(numpy.float32))\nh_result = (d_b + 2).get()\nend.record()\nend.synchronize()\n\nprint(\"original array:\")\nprint(h_b)\nprint(\"doubled with gpuarray:\")\nprint(h_result)\nsecs = start.time_till(end)*1e-3\nprint(\"Time of adding 2 on GPU with gpuarray\")\nprint(\"%fs\" % (secs))\n```", "```py\natomic_hist(\n        drv.Out(h_result), drv.In(h_a), numpy.uint32(SIZE),\n        block=(n_threads,1,1), grid=(NUM_BIN,1),shared= 256*4)\n```"]