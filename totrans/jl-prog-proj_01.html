<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with Julia Programming</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia is a high-level, high-performance dynamic programming language, focusing on numerical computing and general programming. It is relatively new—the four creators, Jeff Bezanson, Stefan Karpinski, Viral Shah, and Alan Edelman, set out to create it in 2009, with the first public reference to the language in 2012, when they published a blog post explaining their vision and their goals. 2012 is considered the official birth year of Julia, making it only six years old. Since its initial public release, Julia has received code contributions from hundreds of scientists, programmers, and engineers across the world. It is developed in the open, with the source code available on GitHub, and is one of the most popular repositories with almost 20,000 stars (at the time of writing, and counting). Julia v1.0, the much anticipated first stable release, came in August 2018 during the Julia conference in London, as the brilliant outcome of the collaboration between over 700 open source contributors and thousands of package creators and early users. By that time, the language had been downloaded over two million times already!</p>
<p class="calibre2">Julia came out as a fresh alternative to traditional scientific computing languages, which were either productive <em class="calibre16">or</em> fast, but not both. This is known as the <strong class="calibre4">two language problem</strong>, where the initial prototyping code is written in a dynamic, highly productive language (such as R or Python), which allows exploratory coding and quick iterations, skipping taxing build and compile times. But later on, the developers would be forced to rewrite their programs (or at least the performance critical parts of their programs), using a compiled language that would satisfy the high-performance requirements of scientific computing.</p>
<p class="calibre2">The creators of Julia thought that software development technology has evolved enough that it can support a language that combines both high productivity and high performance. This was their manifesto, underlying their goals for Julia:</p>
<div class="mce-root1">"We want a language that's open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that's homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like MATLAB. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as MATLAB, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled."<br class="title-page-name"/>
<br class="title-page-name"/>
<span>"(Did we mention it should be as fast as C?)"</span></div>
<p class="calibre2">As incredible as it may seem, Julia has managed to satisfy all these demands, making for a unique language that is easy to learn, intuitive, friendly, productive, and fast. Let's take a closer look at all these features.</p>
<p class="calibre2">The topics we will cover in this chapter are:</p>
<ul class="calibre10">
<li class="calibre11">A quick look at Julia—what is it, the main features and strengths, and why it could be the best choice for your next project</li>
<li class="calibre11">How to set up and interact with the Julia language on your local machine</li>
<li class="calibre11">The best IDEs and editors for productive Julia development</li>
<li class="calibre11">Getting starting with Julia by learning about its powerful REPL</li>
<li class="calibre11">How to use the built-in package manager, <kbd class="calibre12">Pkg</kbd>, to extend the language with third-party libraries</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="calibre2">The Julia package ecosystem is under continuous development and new package versions are released on a daily basis. Most of the times this is great news, as new releases bring new features and bug fixes. However, since many of the packages are still in beta (version 0.x), any new release can introduce breaking changes. As a result, the code presented in the book can stop working. In order to ensure that your code will produce the same results as described in the book, it is recommended to use the same package versions. Here are the external packages used in this chapter and their specific versions:</p>
<pre class="calibre17"> IJulia@v1.14.1<br class="title-page-name"/>OhMyREPL@v0.4.1<br class="title-page-name"/>Revise@v0.7.14</pre>
<p class="calibre2">In order to install a specific version of a package you need to run:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add PackageName@vX.Y.Z</strong> </pre>
<p class="calibre2">For example:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add IJulia@v1.14.1</strong></pre>
<p class="calibre2">Alternatively you can install all the used packages by downloading the <kbd class="calibre12">Project.toml</kbd> file provided with the chapter and using <kbd class="calibre12">pkg&gt;</kbd> instantiate as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; download("https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter01/Project.toml", "Project.toml")</strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; activate . </strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; instantiate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why Julia?</h1>
                </header>
            
            <article>
                
<p class="calibre2">In a nutshell, Julia truly is a new breed of programming language that successfully manages to combine the high performance of compiled languages with the agility of the dynamic ones, through a friendly syntax that feels natural and intuitive right from the start. Julia is <em class="calibre16">fast</em> (programs are compiled at runtime to efficient native code for multiple platforms), <em class="calibre16">general</em> (the standard library supports, out of the box, powerful programming tasks including asynchronous I/O, process control, parallel, and distributed computing, logging, profiling, package management, and more), <em class="calibre16">dynamic and optionally typed</em> (it is dynamically-typed with optional type declarations and comes with a powerful <strong class="calibre4">read-eval-print loop</strong> (<strong class="calibre4">REPL</strong>) for interactive and exploratory coding). It is also <em class="calibre16">technical</em> (excelling at numerical computing) and <em class="calibre16">composable</em> (thanks to its rich ecosystem of packages that are designed to work together seamlessly and with high performance).</p>
<p class="calibre2">Although initially it focused on addressing the needs of <span class="calibre5">high-performance numerical analysis and computational science, recent releases have positioned the language in the area of general computing, with many classes of specialized functions being moved out of the core into dedicated modules. As such, it is also a great fit for client and server-side programming, due to its powerful capabilities for concurrent, parallel, and distributed computing. </span></p>
<p class="calibre2">Julia implements a type system based on parametric polymorphism and multiple dispatch, it is garbage-collected, uses eager evaluation, packs a powerful regular expression engine, and can call C and Fortran functions without glue code. </p>
<p class="calibre2">Let's take a look at the most important features of the language, the parts that make Julia stand out. If you're considering Julia for your next project, you can use this as a quick checklist against your requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Good performance</h1>
                </header>
            
            <article>
                
<p class="calibre2">The key to Julia's performance is the combination between the LLVM-based <strong class="calibre4">just-in-time</strong> (<strong class="calibre4">JIT</strong>) compiler and a series of strategic design decisions that allow the compiler to generate code that approaches, and most of the times matches, the performance of C.</p>
<p class="calibre2">To give you an idea of where Julia stands in this regard, the official website provides a series of micro-benchmarks against other mainstream languages (including C, Python, R, Java, JavaScript, Fortran, Go, Rust, MATLAB, and Octave) implementing some algorithms for computing the Fibonacci sequence, the Mandelbrot set, a <kbd class="calibre12">quicksort</kbd> and a few others. They are designed to evaluate compiler performance against common code patterns such as function calls, string parsing, sorting, iterations, recursion, and more. There is a plot of the benchmarks, available at <a href="https://julialang.org/benchmarks/" class="calibre9"><span>https://julialang.org/benchmarks/</span></a>, which illustrates Julia's consistent top performance across all of the tests. The following plot depicts this:</p>
<p class="CDPAlignCenter"><img src="assets/dceb5fac-7edb-49e8-8c46-8e7a47379953.png" class="calibre18"/></p>
<div class="packttip">For more details about the testing methodology, you can visit <span><a href="https://julialang.org/benchmarks/" class="calibre19">https://julialang.org/benchmarks/</a>.</span><a href="https://julialang.org/benchmarks/" class="calibre19"><br class="title-page-name"/></a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concise, readable, and intuitive syntax</h1>
                </header>
            
            <article>
                
<p class="calibre2">The creators of Julia have carefully picked the most successful elements of syntax from other languages, with the goal of producing expressive, concise, and readable code. Julia provides powerful and expressive language constructs for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python do. It builds upon the experience brought by existing mathematical programming languages but also borrows much from popular dynamic ones, such as Lisp, Perl, Python, Lua, and Ruby.</p>
<p class="calibre2">To give you a quick taste of idiomatic Julia, here's how to open a file, read it, output it, and then have the file automatically closed by Julia:</p>
<pre class="calibre17">open(".viminfo") do io<br class="title-page-name"/>    read(io, String) |&gt; println<br class="title-page-name"/>end  </pre>
<p class="calibre2">In the preceding snippet, we open the <kbd class="calibre12">.viminfo</kbd> file for reading passing <kbd class="calibre12">io</kbd>, an <kbd class="calibre12">IOStream</kbd> instance, into the underlying code block. The stream is then read into a <kbd class="calibre12">String</kbd> that is finally displayed onto the console by piping it into the <kbd class="calibre12">println</kbd> function. The code is very readable and easy to understand if you have some coding experience, even if this is your first time looking at Julia code.</p>
<p class="calibre2">This so-called <kbd class="calibre12">do</kbd> syntax (named after the <kbd class="calibre12">do</kbd> part following the <kbd class="calibre12">open</kbd> function) is inspired by Ruby's blocks—and it is, in fact, syntactic sugar for passing anonymous functions as method arguments. It is efficiently used in the preceding example to succinctly express a powerful design pattern for safely handling files, guaranteeing that the resources are not accidentally left open.</p>
<p class="calibre2">This goes to show the amount of attention that was put by the designers of the language to make Julia safe, beginner-friendly, expressive, concise, readable, and intuitive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Powerful and productive dynamic type system</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia's type system is a key feature of the language and one that has a major impact on both its performance and productivity. The type system is dynamic and optional, meaning that the developer can, but is not required to, provide type information to the compiler. If not provided, Julia will perform type inference, which is the process of deducing the types of later values from the types of input values. This is a very powerful technique, as it frees the programmers from having to worry about types, allowing them to focus on the application logic and making for a gentler learning curve. This is especially useful for prototyping and exploratory programming, when the complete set of constraints and requirements is not known beforehand.</p>
<p class="calibre2">However, understanding and correctly using the type system offers important performance benefits. Julia allows optionally adding type information, making it possible to indicate that a certain value must be of a specific kind. This is one of the cornerstones of the language, allowing performant method dispatching and facilitating the automatic generation of efficient, specialized code for different argument types. The type system allows the definition of rich type hierarchies, with user-defined types as fast and compact as the built-in ones.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designed for parallelism and distributed computation</h1>
                </header>
            
            <article>
                
<p class="calibre2">If the languages of the 70s and 80s were designed under the strict requirements imposed by the limited CPU and RAM resources, the ones in the 90s and the 2000s had the optimistic outlook that these resources are forever expanding. However, the last decade had seen something of a stagnation in this regard, with a shift toward multi-CPU, multi-core, and distributed computing. In this regard, Julia's inception only 6 years ago gave it an edge compared to older languages, putting parallel and distributed computing at its center as one of its most important features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Efficient intercommunication with other languages</h1>
                </header>
            
            <article>
                
<p class="calibre2">One of the most serious barriers in the adoption of a new language is that it takes time for the ecosystem to catch up—and in the beginning, it cannot offer libraries of the quality and richness of the already established languages. This is less of an issue now, when Julia benefits from a large, enthusiastic and continuously growing developer community. But being able to seamlessly communicate with other languages is a very efficient way to enrich existing functionality and to effortlessly supplement any missing features.</p>
<p class="calibre2">Julia has the ability to directly call C and Fortran functions (that is, without glue code)—especially important for scientific computing, where these languages have a strong presence and a long history.</p>
<p class="calibre2">Optional packages extend this capability by adding support for calling functions written in other languages, most notably Python, via <kbd class="calibre12">PyCall</kbd>. And there are others, supporting interaction with Java, C++, MATLAB, Rust, and more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Powerful REPL and shell-like capabilities</h1>
                </header>
            
            <article>
                
<p class="calibre2">The REPL represents a language shell, an interactive computer programming environment at the command line. Julia has an excellent REPL, supporting sophisticated code inputting and evaluation. It includes powerful editing features such as searchable history, tab-completion, and syntax highlighting, to name just a few.</p>
<p class="calibre2">It also comes with three special modes—<em class="calibre16">shell</em><em class="calibre16">,</em> which allows executing commands as if at the OS Terminal; <em class="calibre16">help,</em> which provides access to documentation without leaving the REPL; and pkg, used for installing and managing application dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">And more...</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia comes with its own powerful package manager that resolves dependencies and handles the adding and removal of extra packages. Like most modern languages, Julia has full support for Unicode. And finally, it is distributed under the liberal MIT license—it is free and open source.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Julia</h1>
                </header>
            
            <article>
                
<p class="calibre2">If the previous section convinced you to use Julia for your next project, or at least made you curious to learn more, then it's time to set up your Julia development environment.</p>
<p class="calibre2">Julia has superb cross-platform support, running on all major operating systems. The install process is straightforward—the language can be set up on your local machine, in a <strong class="calibre4">virtual machine</strong> (<strong class="calibre4">VM</strong>), in a Docker container, or on a server somewhere in the cloud.</p>
<p class="calibre2">Let's start by looking at local installation options for the <em class="calibre16">big three</em> operating systems (Windows, Linux, and macOS). Feel free to skip directly to the right one for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows</h1>
                </header>
            
            <article>
                
<p class="calibre2">Windows has come a long way as a development platform and there are a few good alternatives for getting Julia up and running.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Official Windows installer</h1>
                </header>
            
            <article>
                
<p class="calibre2">The simplest option is to download the Windows installer corresponding to your platform (32 or 64-bit), from <a href="https://julialang.org/downloads/" class="calibre9"><span>https://julialang.org/downloads/</span></a>. Get the <kbd class="calibre12">.exe</kbd> and run it. Follow the standard installation procedure and in the end, you will have Julia installed as a program. Double-clicking <kbd class="calibre12">julia.exe</kbd> opens a command prompt with the Julia REPL, just like the one illustrated here:</p>
<p class="CDPAlignCenter"><img src="assets/d918e99d-a624-4fbe-932d-6d7d21effaf4.png" class="calibre20"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Chocolatey</h1>
                </header>
            
            <article>
                
<p class="calibre2">Chocolatey is a package manager for Windows, similar to <kbd class="calibre12">apt</kbd> or <kbd class="calibre12">yum</kbd> on Linux, or <kbd class="calibre12">brew</kbd> on Mac. If you don't have it, get it by following the instructions at <a href="https://chocolatey.org" class="calibre9"><span>https://chocolatey.org</span></a>.</p>
<p class="calibre2">Chocolatey has the latest version of Julia, as can be confirmed with a search, as follows:</p>
<pre class="calibre17"><strong class="calibre1">$ choco search julia 
Chocolatey v0.10.11 
Julia 1.0.0 [Approved] 
1 packages found. </strong></pre>
<p class="calibre2">Installing is as simple as this:</p>
<pre class="calibre17"><strong class="calibre1">$ choco install julia 
Chocolatey v0.10.11 
Installing the following packages: 
julia 
By installing you accept licenses for the packages. 
Progress: Downloading Julia 1.0.0... 100% </strong><br class="title-page-name"/><strong class="calibre1">Julia v1.0.0 [Approved] </strong><br class="title-page-name"/><strong class="calibre1">Chocolatey installed 1/1 packages.</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows Subsystem for Linux</h1>
                </header>
            
            <article>
                
<p class="calibre2">One of the recent additions to Windows 10 is the Subsystem for Linux. This allows setting up a Linux development environment, including most command-line tools, utilities, and applications—directly on Windows, unmodified, and without the overhead of running a VM.</p>
<p class="calibre2">In order to be able to use the Linux Subsystem your PC must be running the 64-bit version of Windows 10 Anniversary Update or later (build 1607+). It also needs to be enabled first—so open a PowerShell as an administrator and run the following:</p>
<pre class="calibre17"><strong class="calibre1">$ Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux </strong></pre>
<p class="calibre2">Once the subsystem is enabled (computer restart might be required) you can choose one of the Linux versions available, directly from the Windows Store. At the time of writing, five versions were available—Ubuntu, openSUSE , SLES, Debian, and Kali.</p>
<p class="calibre2">Ubuntu is the default option for Windows 10 and has the best user ratings in the Windows Store, so let's go with that. It can be installed from <a href="https://www.microsoft.com/en-us/store/p/ubuntu/9nblggh4msv6" class="calibre9"><span>https://www.microsoft.com/en-us/store/p/ubuntu/9nblggh4msv6</span></a>. Alternatively, you can just open a command prompt and type <kbd class="calibre12">$ bash</kbd>. This will trigger the installation of the Ubuntu Linux Subsystem.</p>
<p class="calibre2">Once you find yourself at the shell prompt of your Linux subsystem, you can proceed and issue the commands for installing Julia. For Ubuntu you need to run the following:</p>
<pre class="calibre17"><strong class="calibre1">$ sudo apt-get install julia</strong></pre>
<p class="calibre2">Make sure to confirm the required selections—then after a couple of minutes you should have Julia up and running.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">macOS</h1>
                </header>
            
            <article>
                
<p class="calibre2">Installing Julia on macOS is straightforward. There are two main options, depending on whether you prefer a visual installer or are more at home in front of the Terminal prompt.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Official image</h1>
                </header>
            
            <article>
                
<p class="calibre2">Visit <a href="https://julialang.org/downloads/" class="calibre9"><span>https://julialang.org/downloads/</span></a> and look for the macOS package (<kbd class="calibre12">.dmg</kbd>). Once it's downloaded, double-click the <kbd class="calibre12">.dmg</kbd> file and drag and drop the Julia app into the <kbd class="calibre12">/Applications</kbd> folder. Now you can simply open the Julia app—which in turn will launch a new Terminal session, loading the Julia environment, as follows:</p>
<p class="CDPAlignCenter"><img src="assets/c530fc94-ba36-4b8d-b496-ab68eb42e966.png" class="calibre21"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Homebrew</h1>
                </header>
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">Homebrew</kbd> is a well-known package manager for macOS in the line of <kbd class="calibre12">apt</kbd> and <kbd class="calibre12">yum</kbd> on Linux. It's not really necessary for installing Julia, but it's worth setting it up as it can be very useful during development since it can seamlessly install database servers, libraries, and other components for your projects.</p>
<p class="calibre2">As per the instructions at <a href="https://brew.sh" class="calibre9"><span>https://brew.sh</span></a>, it can be installed by running the following command in a Terminal window:</p>
<pre class="calibre17"><strong class="calibre1">$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</strong> </pre>
<p class="calibre2">It might take a while but once <kbd class="calibre12">Homebrew</kbd> is installed, a new command-line utility, <kbd class="calibre12">brew</kbd>, will become available.</p>
<p class="calibre2">Finally, <kbd class="calibre12">$ brew cask install julia</kbd> will download and install the latest version of Julia. In the process, it will also link the <kbd class="calibre12">julia</kbd> binary to <kbd class="calibre12">/usr/local/bin/julia</kbd> so you can interact with the language from the command line by simply typing <kbd class="calibre12">$ julia</kbd>.</p>
<p class="calibre2">As soon as you get the confirmation that the installation was successful you can run <kbd class="calibre12">$ julia</kbd> to start a new REPL session:</p>
<p class="CDPAlignCenter"><img src="assets/c22c2c3d-210b-40e7-a2c0-4e589803e081.png" class="calibre22"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linux and FreeBSD</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia is already available in the software repositories of the major Linux distributions, but unfortunately, these are not up to date. For example, at the time of writing, Ubuntu was providing v0.4.5 and Debian v0.4.7. The best approach is to use the generic Linux binaries provided on Julia's download page, at <a href="https://julialang.org/downloads/" class="calibre9">https://julialang.org/downloads/</a>. </p>
<p class="calibre2">Please follow the instructions corresponding to your Linux distribution, as indicated at <a href="https://julialang.org/downloads/platform.html#generic-binaries" class="calibre9">https://julialang.org/downloads/platform.html#generic-binaries</a>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Docker</h1>
                </header>
            
            <article>
                
<p class="calibre2">Docker is a software technology that provides an additional layer of abstraction of operating-system-level virtualization. In plain English, Docker sets up <em class="calibre16">containers</em> that behave like VMs, but without the added overhead of starting and maintaining VMs. You can run Docker on all the major operating systems. </p>
<p class="calibre2">Docker is widely used as a development and deployment strategy, so many technologies are readily available in the form of Docker images, and Julia is no exception.</p>
<p class="calibre2">Start by installing Docker for your platform. The official Julia container can be found in the Docker store at <a href="https://store.docker.com/images/julia" class="calibre9"><span>https://store.docker.com/images/julia</span></a>. Go get it.</p>
<div class="packttip">If you need help setting up Docker or installing containers, follow the instructions at <a href="https://www.docker.com" class="calibre19"><span>https://www.docker.com</span></a><span>.</span></div>
<p class="calibre2">At the command prompt, type <kbd class="calibre12">$ docker pull julia</kbd>. Once the Julia image is configured by Docker, run it with <kbd class="calibre12">$ docker exec -it --rm julia</kbd>. This will start the container and load a new Julia REPL:</p>
<p class="CDPAlignCenter"><img src="assets/b2960334-eb4f-4ad9-9f55-1abb07275e33.png" class="calibre23"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JuliaPro</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia Computing, the company behind the Julia programming language, offers a <em class="calibre16">batteries included</em> distribution. It's called <strong class="calibre4">JuliaPro</strong> and it's arguably the easiest way to get started with Julia straight away. It includes the compiler, a profiler, the Juno IDE, and over 160 top quality curated packages for plotting, data visualization, machine learning, databases, and more.</p>
<p class="calibre2">JuliaPro can be downloaded for free at <a href="https://shop.juliacomputing.com/Products/" class="calibre9"><span>https://shop.juliacomputing.com/Products/</span></a> (registration required). Once you get it, follow the install process specific to your platform. When done you'll have everything needed to begin using Julia productively.</p>
<div class="packttip">A paid enterprise version is also available, offering a few extra features, such as Excel integration and support with SLA.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JuliaBox</h1>
                </header>
            
            <article>
                
<p class="calibre2">Finally, there's also JuliaBox (<a href="https://www.juliabox.com" class="calibre9"><span>https://www.juliabox.com</span></a>), another free offering from Julia Computing. JuliaBox allows running a Julia Docker container on the fly, in their cloud. It provides access to IJulia Jupyter notebooks (<a href="https://github.com/JuliaLang/IJulia.jl" class="calibre9"><span>https://github.com/JuliaLang/IJulia.jl</span></a>), file sync with Google Drive, importing GitHub repositories, and many other features.</p>
<div class="packttip">If you are not familiar with Jupyter notebooks, you can learn more about them by visiting <a href="http://jupyter.org" class="calibre19">http://jupyter.org</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing an IDE</h1>
                </header>
            
            <article>
                
<p class="calibre2">An IDE is very important when working with a programming language. A powerful source code editor, code completion, and a good linter and debugger can significantly influence the learning curve and the productivity of using a language. You will be happy to learn that there are some very good IDE and editor options for Julia—and chances are you'll find your favorite one among these.</p>
<p class="calibre2">The IDE choices reflect the pragmatism of the language as a whole. From choosing LLVM as the compiler to providing efficient ways for calling functions from other languages, to using <kbd class="calibre12">git</kbd> and GitHub to power the package manager, the Julia core team takes a <em class="calibre16">don't reinvent the wheel</em> approach. Following the same line of thinking, the Julia community has built powerful IDEs upon existing industry established editors, such as Atom and Visual Studio Code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Juno (Atom)</h1>
                </header>
            
            <article>
                
<p class="calibre2">Juno (<a href="http://junolab.org" class="calibre9"><span>http://junolab.org</span></a>) is the most advanced Julia IDE and the de facto editor of choice for Julia professionals. It is based on the Atom editor and it can be considered the official development tool, being also distributed with the previously mentioned JuliaPro distribution.</p>
<p class="calibre2">To get it, either download and install JuliaPro from <a href="https://juliacomputing.com/products/juliapro.html" class="calibre9"><span>https://juliacomputing.com/products/juliapro.html</span></a> <span class="calibre5">or</span><a href="https://juliacomputing.com/products/juliapro.html" class="calibre9"> do a manual install of Atom and the required plugins.</a></p>
<p class="calibre2">If you choose the manual install, first you need to download Atom from <a href="https://atom.io" class="calibre9"><span>https://atom.io</span></a>. Once it's up and running, go to the <span class="calibre5">Settings</span> pane (you can use the shortcut <em class="calibre16">Ctrl</em>/<em class="calibre16">cmd</em> and <em class="calibre16">,</em>) and then go to the <span class="calibre5">Install</span> panel. Type <kbd class="calibre12">uber-juno</kbd> into the search box and press <em class="calibre16">Enter</em>. Next, click the <span class="calibre5">install</span> button on the package with the same name. Atom will pick it up from here, installing all the required Atom and Julia packages.</p>
<p class="calibre2">Once configured, the IDE options will be available in Atom's menu, under <span class="calibre5">Packages</span> &gt; <span class="calibre5">Julia</span>. Various panes can also be enabled from here, to list variables, visualize plots, or search the documentation.</p>
<p class="calibre2">For further information, check out <a href="http://junolab.org" class="calibre9"><span>http://junolab.org</span></a> and <a href="https://githubcom/JunoLab/uber-juno/blob/master/setup.md" class="calibre9"><span>https://github.com/JunoLab/uber-juno/blob/master/setup.md</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Studio Code</h1>
                </header>
            
            <article>
                
<p class="calibre2">Visual Studio Code is a cross-platform extendable editor from Microsoft. It is available for all the <em class="calibre16">big three</em> platforms at <a href="https://code.visualstudio.com" class="calibre9"><span>https://code.visualstudio.com</span></a>. Once installed, run it and from the menu click <span class="calibre5">View</span> &gt; <span class="calibre5">Extensions</span> or use the shortcut <em class="calibre16">Shift</em> and <em class="calibre16">Ctrl</em>/<em class="calibre16">cmd</em> and <em class="calibre16">X</em>. Search for <kbd class="calibre12">julia</kbd> and install the Julia extension from <em class="calibre16">julialang</em>.</p>
<p class="calibre2">The Julia support in Visual Studio Code is not (yet) as powerful as Juno, but if you prefer it, it makes for a great coding experience, providing syntax highlighting, code completion, hover help, evaluation of Julia code, linting, code navigation, and more. Visual Studio Code is also snappier and uses fewer resources than Atom, which makes it an appealing option when running on a less powerful workstation (although Atom has greatly improved in this regard with recent versions).</p>
<p class="calibre2">The extension might need a bit of help figuring out where it can find the Julia binary. If that is the case, you'll get an informative error message, asking you to set the <kbd class="calibre12">julia.executablePath</kbd> configuration option. This should point to the julia binary, and depends on your operating system and the way you installed Julia (see the previous section for details on the installation).</p>
<p class="calibre2">To set the configuration, go to <span class="calibre5">Preferences</span> &gt; <span class="calibre5">Settings</span> (<em class="calibre16">Ctrl</em>/<em class="calibre16">cmd</em> and <em class="calibre16">,</em>) and in the right pane, the one used to overwrite the defaults, add the following:</p>
<pre class="calibre17">"julia.executablePath": "/path/to/your/julia/folder/bin/julia" </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IJulia (JuliaBox)</h1>
                </header>
            
            <article>
                
<p class="calibre2">We already mentioned JuliaBox (<a href="https://www.juliabox.com" class="calibre9"><span>https://www.juliabox.com</span></a>) in the previous section—it allows creating, editing, and running IJulia Jupyter notebooks in the cloud. IJulia can also be installed on the local development machine.</p>
<p class="calibre2">IJulia is a Julia language backend for the Jupyter interactive environment (also used by IPython). It allows us to interact with the Julia language using Jupyter/IPython's powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document.</p>
<p class="calibre2">Although IJulia/Jupyter is not really an IDE, nor a classical editor, it is a powerful environment for editing and executing Julia scripts, and it's especially popular for data science and scientific computing. Let's take a few moments to set it up.</p>
<p class="calibre2">Start a new Julia REPL and execute the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Pkg</strong><br class="title-page-name"/><strong class="calibre1">julia&gt; Pkg.add("IJulia")</strong></pre>
<p class="calibre2">This will install the <kbd class="calibre12">IJulia</kbd> package, while also adding a required minimal Python and Jupyter distribution called <strong class="calibre4">Miniconda</strong>. This Python distribution is private to Julia (not in your <kbd class="calibre12">PATH</kbd>). Once finished, continue by executing the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using IJulia</strong><br class="title-page-name"/><strong class="calibre1">julia&gt; notebook()</strong></pre>
<p class="calibre2">This will open the home page of your local Jupyter install in your default browser, at <a href="http://localhost:8888/tree" class="calibre9"><span>http://localhost:8888/tree</span></a>. From the toolbar choose <kbd class="calibre12">New &gt; Julia 1.0.0</kbd> (or whatever version you are currently running) to create a new notebook. You can now create rich documents using embedded executable Julia code.</p>
<div class="packttip">There's another way of running IJulia as a desktop app, through <kbd class="calibre24">Interact</kbd>. You can download it and give it a try at <a href="https://nteract.io/desktop" class="calibre19"><span>https://nteract.io/desktop</span></a><span>.</span></div>
<p class="calibre2">If you're new to Jupyter, it's worth learning more about it. Go check it out at <a href="http://jupyter.org" class="calibre9"><span>http://jupyter.org</span></a>.</p>
<div class="packttip">You can also find IJulia notebooks for each chapter in this book in the chapter's support file repository. The notebooks will allow you to go through the code we're writing, step by step. For instance, you can find the code for this chapter at <a href="https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb" target="_blank" class="calibre19">https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb</a>. You can download it on your computer and open it with the local IJulia installation, or upload it to JuliaBox through their Google Drive integration.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other options</h1>
                </header>
            
            <article>
                
<p class="calibre2">The preceding choices are the most common IDE and editor options for Julia. But there are a few more out there.</p>
<p class="calibre2">For the <kbd class="calibre12">vim</kbd> enthusiasts, there's also <kbd class="calibre12">julia-vim</kbd> (<a href="https://github.com/JuliaEditorSupport/julia-vim" class="calibre9"><span>https://github.com/JuliaEditorSupport/julia-vim</span></a>).</p>
<p class="calibre2">If you prefer Emacs, you'll be pleased to know that Julia supports it as well <span class="calibre5"><a href="https://github.com/JuliaEditorSupport/julia-emacs" class="calibre9">https://github.com/JuliaEditorSupport/julia-emacs</a>.</span></p>
<p class="calibre2">If you'd rater go with one of the IDEs provided by JetBrains (like IntelliJ IDEA), you'll be happy to hear that a plugin is available, at <a href="https://plugins.jetbrains.com/plugin/10413-julia" class="calibre9">https://plugins.jetbrains.com/plugin/10413-julia</a></p>
<p class="calibre2">Finally, there is also support for Sublime Text, available at <a href="https://github.com/JuliaEditorSupport/Julia-sublime" class="calibre9"><span>https://github.com/JuliaEditorSupport/Julia-sublime</span></a>. The plugin provides a good Julia editing experience, supporting syntax highlighting, code completion, and jumping to definition, among other things.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with Julia</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you followed through the first part of the chapter, by now you should have a fully functional local Julia installation, the knowledge to start a Julia REPL session, and have your preferred IDE ready for coding. If that is not the case, please refer to the previous sections. From this point on we're getting down to business—it's time to write some Julia code!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Julia REPL</h1>
                </header>
            
            <article>
                
<p class="calibre2">The first thing we need to understand is how to use the powerful REPL. As a Julia developer, you'll spend a significant amount of time doing exploratory programming, interacting with the shell and the filesystem, and managing packages. The REPL will be your trusted sidekick. It's worth getting to know it well, it will save you a lot of time down the line.</p>
<p class="calibre2">The acronym REPL stands for read-eval-print loop. Simply put, it's a language-specific shell, an interactive coding environment that allows inputting expressions, evaluates them, and outputs the result.</p>
<p class="calibre2">REPLs are very useful as they provide a simple way to interact with the language, to try out ideas and prototype, facilitating exploratory programming and debugging. It is especially powerful in the context of data analysis, where one can quickly connect to a data source, load a data sample and then slice and dice, rapidly testing different hypothesis.</p>
<p class="calibre2">Julia provides an excellent REPL experience, with rich functionality that covers quick evaluation of Julia statements, searchable history, tab-completion, syntax highlighting, dedicated help and shell modes, to name just a few.</p>
<p class="calibre2">If you do not have a working Julia installation, please see the <em class="calibre16">Installing Julia</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with the REPL</h1>
                </header>
            
            <article>
                
<p class="calibre2">Depending on your OS and your preferences, the REPL can be started by simply invoking <kbd class="calibre12">$ julia</kbd> with no arguments, or by double-clicking the <kbd class="calibre12">julia</kbd> executable.</p>
<p class="calibre2">You will be greeted with a screen like this one (the Julia version might be different than mine):</p>
<p class="CDPAlignCenter"><img src="assets/3869e0f5-3197-4d08-9005-ab90794bce8e.png" class="calibre25"/></p>
<p class="calibre2">Now Julia is waiting for us to input our code, evaluating it line by line. You can confirm that by checking the Terminal prompt, which says <kbd class="calibre12">julia&gt;</kbd>. This is called the <strong class="calibre4">julian</strong> <strong class="calibre4">mode</strong>. Let's take it for a spin.</p>
<div class="packttip">You can follow through the IJulia Jupyter notebook provided with this chapter's support files. If you are not familiar with Jupyter and don't know how to run it locally, you can use Juliabox (<a href="http://juliabox.com" target="_blank" class="calibre19"><span>juliabox.com</span></a>). All you have to do is create an account, log in, and then load the notebook from <a href="https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb" target="_blank" class="calibre19">https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb</a>.</div>
<p class="calibre2">Input the following lines, pressing <em class="calibre16">Enter</em> after each one:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 2+2 
julia&gt; 2^3</strong> </pre>
<p class="calibre2">So we can use Julia like a simple calculator. Not very useful, but this is only the beginning and illustrates how powerful this rapid input and feedback cycle can be when we deal with complex computations.</p>
<p class="calibre2"><kbd class="calibre12">println</kbd> is a very useful function that prints whatever value it receives, appending a new line afterward. Type the following code:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; println("Welcome to Julia")</strong> </pre>
<p class="calibre2">Under each line, you should see the output generated by each expression. Your window should now look like this.</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 2+2 
4 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; 2^3 
8 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; println("Welcome to Julia") 
Welcome to Julia</strong> </pre>
<p class="calibre2">Let's try some more. The REPL interprets one line at a time, but everything is evaluated in a common scope. This means that we can define variables and refer to them later on, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; greeting = "Hello" 
"Hello"</strong> </pre>
<p class="calibre2">This looks great! Let's use the <kbd class="calibre12">greeting</kbd> variable with <kbd class="calibre12">println</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; println(greting) 
ERROR: UndefVarError: greting not defined</strong> </pre>
<p class="calibre2">Oops! A little typo there, and the REPL promptly returned an error. It's not <kbd class="calibre12">greting</kbd>, it's <kbd class="calibre12">greeting</kbd>. This also tells us that Julia does not allow using variables without properly initializing them. It just looked for the <kbd class="calibre12">greting</kbd> variable, unsuccessfully—and it threw an undefined variable error. Let's try that again, this time more carefully:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; println(greeting) 
Hello</strong> </pre>
<p class="calibre2">OK, that's much better! We can see the output: the <kbd class="calibre12">Hello</kbd> value we stored in the <kbd class="calibre12">greeting</kbd> variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ans variable</h1>
                </header>
            
            <article>
                
<p class="calibre2">The REPL provides a few helping features, specific to this interactive environment (they won't be available when executing a Julia script). One of these is the <kbd class="calibre12">ans</kbd> variable, automatically set up and updated by Julia.</p>
<p class="calibre2">If you type <kbd class="calibre12">julia&gt; 2^3</kbd>—unsurprisingly, you'll get <kbd class="calibre12">8</kbd>. Now input <kbd class="calibre12">julia&gt; ans</kbd>—you'll get <kbd class="calibre12">8</kbd> again! What's up with that? <kbd class="calibre12">ans</kbd> is a special variable that exists only in the REPL and that automatically stores the last returned value. It can prove very useful when working with the REPL, but more importantly, you need to be aware of its existence so that you don't accidentally declare a variable with the same name. Otherwise, you'll run into some very hard to understand bugs with your variable's value constantly overwritten.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prompt pasting</h1>
                </header>
            
            <article>
                
<p class="calibre2">The REPL comes with a very powerful feature called <strong class="calibre4">prompt pasting</strong>. This allows us to copy-paste-execute Julia code and snippets that include both the <kbd class="calibre12">julia&gt;</kbd> prompt and the output of the expression. It activates when pasting text that starts with <kbd class="calibre12">julia&gt;</kbd>. In that case, only expressions starting with <kbd class="calibre12">julia&gt;</kbd> are parsed, and all the others are ignored. This makes it possible to paste a chunk of code that has been copied from another REPL session or from the documentation, without having to scrub away prompts and outputs.</p>
<div class="packttip">Prompt pasting does not work in IJulia Jupyter notebooks.</div>
<p class="calibre2">To see this in action, copy and paste the following snippet, as is:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Dates 
 
julia&gt; Dates.now() 
2018-09-02T21:13:03.122 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; ans 
2018-09-02T21:13:03.122</strong> </pre>
<p class="calibre2">If all goes well, both expressions should output your current time, and not the one from the snippet, effectively replacing the results in the snippet with the results in your Julia session.</p>
<div class="packttip">This feature does not work with the default Windows command prompt due to its limitations.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tab completion</h1>
                </header>
            
            <article>
                
<p class="calibre2">In both the Julian, pkg, and help modes you can press the <em class="calibre16">Tab</em> key after entering the first few characters of a function to get a list of all the matches:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; pri[TAB] 
primitive type   print             print_shortest    print_with_color  println           printstyled </strong> </pre>
<p class="calibre2">It can also be used to substitute LaTeX math symbols with their Unicode equivalents. To do this, type a backslash as the first character, then the first few characters of the symbol, then <em class="calibre16">Tab</em>. This will complete the name of the symbol or will display a list of options if there's more than one matching name. Pressing <em class="calibre16">Tab</em> again on the complete name of the symbol will perform the replacement:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; \pi[TAB] <br class="title-page-name"/>julia&gt; π <br class="title-page-name"/>π = 3.1415926535897... <br class="title-page-name"/><br class="title-page-name"/>julia&gt; \om[TAB] \omega \ominus <br class="title-page-name"/>julia&gt; \ome[TAB] <br class="title-page-name"/>julia&gt; \omega[TAB] <br class="title-page-name"/>julia&gt; ω</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cleaning the REPL scope</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia does not have the concept of null so you can't really deallocate a variable from memory. If, however, you need to free an expensive resource referenced by a variable, you can replace its value with something like <kbd class="calibre12">0</kbd> and the previous value will be automatically garbage collected. You can even invoke the garbage collector yourself straight away by calling <kbd class="calibre12">gc()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional REPL modes</h1>
                </header>
            
            <article>
                
<p class="calibre2">The Julia REPL comes with four operational modes—and additional ones can be defined as needed. The currently active mode is indicated by its prompt. In the previous examples we've used the <em class="calibre16">julian</em> mode <kbd class="calibre12">julia&gt;</kbd>, which evaluates the inputted expression. The other three available modes are <em class="calibre16">help,</em> <kbd class="calibre12">help?&gt;</kbd>, <em class="calibre16">shell,</em> <kbd class="calibre12">shell&gt;</kbd>, and package management, <kbd class="calibre12">pkg&gt;</kbd>.</p>
<p class="calibre2">The active mode can be switched by typing a specific character right at the beginning of the line. The prompt will change in response, to indicate the current mode. The mode will stay active until the current line is evaluated, automatically switching back to julian (with the exception of the <kbd class="calibre12">pkg&gt;</kbd> mode which is <em class="calibre16">sticky—</em>that is, it stays active until explicitly exited by typing backspace at the beginning of the line). The alternative modes can be exited without evaluating the expression by deleting everything on the line until the prompt changes back to <kbd class="calibre12">julia&gt;</kbd>, or by pressing <em class="calibre16">Ctrl</em> + <em class="calibre16">C</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the documentation with the help mode</h1>
                </header>
            
            <article>
                
<p class="calibre2">The help mode provides access to documentation without having to get out of the REPL. To access it, simply type <kbd class="calibre12">?</kbd> at the beginning of the line. You should see the  <kbd class="calibre12">help?&gt;</kbd> prompt. Now you can input text, and Julia will search the documentation for matching entries, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ?  
help?&gt; println 
search: println printstyled print_with_color print print_shortest sprint isprint 
 
  println([io::IO], xs...) 
 
  Print (using print) xs followed by a newline. If io is not supplied, prints to stdout. 
 
  Examples 
  ≡≡≡≡≡≡≡≡≡≡ 
 
  julia&gt; println("Hello, world") 
  Hello, world 
 
  julia&gt; io = IOBuffer(); 
 
  julia&gt; println(io, "Hello, world") 
 
  julia&gt; String(take!(io)) 
  "Hello, world\n" </strong> </pre>
<div class="packttip">In IJulia, the additional modes are activated by prefixing the input with the desired mode activator. For instance, to access the help for the previous <kbd class="calibre24">println</kbd> function, we need to input <kbd class="calibre24">?println.</kbd></div>
<p class="calibre2">The output supports rich formatting, via Markdown:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Profile </strong><br class="title-page-name"/><strong class="calibre1">help?&gt; Profile.print</strong> </pre>
<p class="calibre2">Resulting a rich output as in the following screenshot:</p>
<p class="CDPAlignCenter"><img src="assets/3e082fe5-e8ed-42d6-9c9c-c8c949384950.png" class="calibre18"/></p>
<p class="calibre2">More complex expressions can be queried, including macros, types, and variables.</p>
<p class="calibre2">For example, <kbd class="calibre12">help?&gt; @time</kbd>:</p>
<p class="CDPAlignCenter"><img src="assets/f12eb3ed-e7c2-4395-a9c9-2b0df1657012.png" class="calibre26"/></p>
<p class="calibre2">Or <kbd class="calibre12">help?&gt; IO</kbd>:</p>
<p class="CDPAlignCenter"><img src="assets/09a9e60a-d1bd-40b5-9aa5-f265c9e44fa9.png" class="calibre27"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shell mode</h1>
                </header>
            
            <article>
                
<p class="calibre2">The shell mode is used to switch to a command-line interface similar to the system shell, for directly executing OS commands. To enter it, input a semicolon <kbd class="calibre12"><span>;</span></kbd> at the very beginning of the julian prompt:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ;</strong>  </pre>
<p class="calibre2">Upon typing <kbd class="calibre12">;</kbd> the prompt changes (in place) to <kbd class="calibre12">shell&gt;</kbd>:</p>
<div class="packttip">To enter shell mode in IJulia and execute a shell command, prefix the command with <kbd class="calibre24">;</kbd>, for example <kbd class="calibre24">;ls</kbd>.</div>
<p class="calibre2">Now we can execute system-wide commands directly, without the need to wrap them in Julia code. This will list the last ten lines of your <kbd class="calibre12">repl_history.jl</kbd> file. This file is used by Julia to keep a history of the commands executed in the REPL, so your output will be different from mine:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using REPL</strong><br class="title-page-name"/><strong class="calibre1">shell&gt; tail -n 10 ~/.julia/logs/repl_history.jl</strong><br class="title-page-name"/><strong class="calibre1">IO</strong><br class="title-page-name"/><strong class="calibre1"># time: 2018-09-02 21:56:47 CEST</strong><br class="title-page-name"/><strong class="calibre1"># mode: julia</strong><br class="title-page-name"/><strong class="calibre1">REPL.find_hist_file()</strong><br class="title-page-name"/><strong class="calibre1"># time: 2018-09-02 21:58:47 CEST</strong><br class="title-page-name"/><strong class="calibre1"># mode: shell</strong><br class="title-page-name"/><strong class="calibre1">tail -n 10 ~/.julia/logs/repl_history.jl</strong> </pre>
<p class="calibre2">While in REPL mode we can access Julia's API, making this a very powerful combo. For example, in order to programmatically get the path to the REPL history file, we can use the <kbd class="calibre12">REPL.find_hist_file()</kbd> function, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; REPL.find_hist_file() 
"/Users/adrian/.julia/logs/repl_history.jl"</strong> </pre>
<p class="calibre2">The path to the file will be different for you.</p>
<p class="calibre2">We can use this in the shell mode by wrapping the command in <kbd class="calibre12">$()</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">shell&gt; tail -n 10 $(REPL.find_hist_file()) 
    REPL.find_hist_file() 
# time: 2018-09-02 21:58:47 CEST 
# mode: shell 
    tail -n 10 ~/.julia/logs/repl_history.jl 
# time: 2018-09-02 22:00:03 CEST 
# mode: shell 
    tail -n 10 $(REPL.find_hist_file())</strong> </pre>
<p class="calibre2">Similarly to the help mode, the shell mode can be exited without executing any command by pressing backspace at the beginning of the line or typing <em class="calibre16">Ctrl</em> + <em class="calibre16">C</em>.</p>
<p class="calibre2">In IJulia, the command can be executed by prefixing the input with <kbd class="calibre12">;</kbd>, like this:</p>
<pre class="calibre17"><strong class="calibre1">;tail -n 10 ~/.julia/logs/repl_history.jl</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Search modes</h1>
                </header>
            
            <article>
                
<p class="calibre2">Besides the help and the shell modes, there are two search modes. These are not necessarily Julia specific, being common to many *nix style editing apps.</p>
<p class="calibre2">Press the <em class="calibre16">Ctrl</em> key and the <em class="calibre16">R</em> key at the same time in order to initiate a reverse incremental search. The prompt will change to <kbd class="calibre12">(reverse-i-search)</kbd>. Start typing your query and the most recent result will show. To find older results, type <em class="calibre16">Ctrl</em> + <em class="calibre16">R</em> again.</p>
<p class="calibre2">The counterpart of <em class="calibre16">Ctrl</em> + <em class="calibre16">R</em> is <em class="calibre16">Ctrl</em> + <em class="calibre16">S</em>, initiating an incremental search. The two may be used in conjunction to move through the previous or next matching results, respectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The startup.jl file</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you want to automatically execute some code every time you run Julia, you can add it to a special file called <kbd class="calibre12">startup.jl</kbd>. This file is not automatically created, so you'll have to add it yourself to your Julia configuration directory. Any code you add to it will be run by Julia each time it starts up. Let's have some fun and do this using Julia—and practice a bit of what we've learned so far.</p>
<p class="calibre2">First, go into shell mode and run these three commands:</p>
<pre class="calibre17"><strong class="calibre1">shell&gt; mkdir $(dirname(REPL.find_hist_file()))/../config 
 
shell&gt; cd $(dirname(REPL.find_hist_file()))/../config 
/Users/adrian/.julia/config 
 
shell&gt; touch startup.jl </strong></pre>
<p class="calibre2">Then, in julian mode, execute the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; write("startup.jl", "println(\"Welcome to Julia!\")") 
28 </strong></pre>
<p class="calibre2">What did we just do? In shell mode, we created a new directory, called <kbd class="calibre12">config</kbd>, just one folder up from where our history file was. Then we <kbd class="calibre12">cd</kbd> into the newly created folder, where we created a new file called <kbd class="calibre12">startup.jl</kbd>. Finally, we asked Julia to add the line <kbd class="calibre12">"println(\"Welcome to Julia!\")"</kbd> to the <kbd class="calibre12">startup.jl</kbd> file. Next time we start the Julia REPL we'll be greeted by this welcome message. Check this out:</p>
<p class="CDPAlignCenter"><img src="assets/c5d8e674-f26c-4f07-8447-58183054c605.png" class="calibre28"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REPL hooks</h1>
                </header>
            
            <article>
                
<p class="calibre2">It is also possible to define a function that will be automatically called before starting a REPL session. To achieve this, you need to use the <kbd class="calibre12">atreplinit(f)</kbd> function, which registers a one-argument function <kbd class="calibre12">f</kbd> to be called before the REPL interface is initialized in interactive sessions. This function should be called from within the <kbd class="calibre12">startup.jl</kbd> file.</p>
<p class="calibre2">Let's say that we edit our <kbd class="calibre12">startup.jl</kbd> file so that it now looks like this:</p>
<pre class="calibre17">println("Welcome to Julia!") 
 
atreplinit() do (f) 
  println("And welcome to you too!") 
end </pre>
<p class="calibre2">Our REPL will now greet us twice:</p>
<p class="CDPAlignCenter"><img src="assets/3ce7247b-89de-4606-a154-3c88d1258c23.png" class="calibre29"/></p>
<p class="calibre2">The <kbd class="calibre12">atreplinit</kbd> function can be used in tandem with <kbd class="calibre12">isinteractive</kbd>, which returns a <kbd class="calibre12">Boolean true</kbd> or <kbd class="calibre12">false</kbd> value that tells us whether or not Julia is running an interactive session.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exiting the REPL</h1>
                </header>
            
            <article>
                
<p class="calibre2">In order to exit the REPL, you can type <kbd class="calibre12">^ D</kbd> (<em class="calibre16">Ctrl</em> + <em class="calibre16">D</em>). However, that will only work if you're at the beginning of the line (when the text buffer is empty). Otherwise just type <kbd class="calibre12">^C</kbd> (<em class="calibre16">Ctrl</em> + <em class="calibre16">C</em>) to first interrupt (or <em class="calibre16">c</em>ancel) and clear the line. You can also run <kbd class="calibre12">exit()</kbd>, which will stop the execution of the current Julia process.</p>
<div class="packttip">For the complete list of key bindings at the REPL and how to customise them, you can read the official documentation at <a href="https://docs.julialang.org/en/v1.0/stdlib/REPL/#Key-bindings-1" class="calibre19">https://docs.julialang.org/en/v1.0/stdlib/REPL/#Key-bindings-1</a>. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The package system</h1>
                </header>
            
            <article>
                
<p class="calibre2">Your Julia installation comes with a powerful package manager called <kbd class="calibre12">Pkg</kbd>. This handles all the expected operations, such as adding and removing packages, resolving dependencies and keeping installed packages up to date, running tests, and even assisting with publishing our own packages.</p>
<p class="calibre2">Packages play a pivotal role by providing a wide range of functionality, seamlessly extending the core language. Let's take a look at the most important package management functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a package</h1>
                </header>
            
            <article>
                
<p class="calibre2">In order to be known to <kbd class="calibre12">Pkg</kbd>, the packages must be added to a registry that is available to Julia. <kbd class="calibre12">Pkg</kbd> supports working with multiple registries simultaneously—including private ones hosted behind corporate firewalls. By default, <kbd class="calibre12">Pkg</kbd> is configured to use Julia's General registry, a repository of free and open sources packages maintained by the Julia community.</p>
<p class="calibre2"><kbd class="calibre12">Pkg</kbd> is quite a powerful beast and we'll use it extensively throughout the book. Package management is a common task when developing with Julia so we'll have multiple opportunities to progressively dive deeper. We'll take our first steps now as we'll learn how to add packages—and we'll do this by stacking a few powerful new features to our Julia setup.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OhMyREPL</h1>
                </header>
            
            <article>
                
<p class="calibre2">One of my favourite packages is called <kbd class="calibre12">OhMyREPL</kbd>. It implements a few super productive features for the Julia REPL, most notably syntax highlighting and brackets pairing. It's a great addition that makes the interactive coding experience even more pleasant and efficient.</p>
<p class="calibre2"><span class="calibre5">Julia's </span><kbd class="calibre12"><span>Pkg</span></kbd><span class="calibre5"> is centered around GitHub. The creators distribute the packages as git repos, hosted on GitHub—and even the General registry is a GitHub repository itself. </span><kbd class="calibre12"><span>OhMyREPL</span></kbd><span class="calibre5"> is no exception. If you want to learn more about it before installing it—always a good idea when using code from third parties — you can check it out at </span><a href="https://github.com/KristofferC/OhMyREPL.jl" class="calibre9">https://github.com/KristofferC/OhMyREPL.jl </a></p>
<p class="calibre2"><span class="calibre5">Keep in mind that even if it's part of the General registry, the packages come with no guarantees and they're not necessarily checked, validated or endorsed by the Julia community. However, there are a few common sense indicators which provide insight into the quality of the package, most notably the number of stars, the status of the tests as well as the support for the most recent Julia versions.</span></p>
<p class="calibre2">The first thing we need to do in order to add a package is to enter the <kbd class="calibre12">Pkg</kbd> REPL-mode. We do this by typing <kbd class="calibre12">]</kbd> at the beginning of the line:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt;]</strong> </pre>
<p class="calibre2">The cursor will change to reflect that we're now ready to manage packages:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt;</strong> </pre>
<div class="packttip">IJulia does not (yet) support the <kbd class="calibre24">pkg&gt;</kbd> mode, but we can execute <kbd class="calibre24">Pkg</kbd> commands by wrapping them in <kbd class="calibre24">pkg"..."</kbd> as in <kbd class="calibre24">pkg"add OhMyREPL"</kbd>.</div>
<p class="calibre2"><kbd class="calibre12">Pkg</kbd> uses the concept of <em class="calibre16">environments</em>, allowing us to define distinct and independent sets of packages on a per-project basis. This is a very powerful and useful feature, as it eliminates dependency conflicts caused by projects that rely on different versions of the same package (the so-called <strong class="calibre4">dependency hell</strong>).</p>
<p class="calibre2">Given that we haven't created any project yet, <kbd class="calibre12">Pkg</kbd> will just use the default project, <kbd class="calibre12">v1.0</kbd>, indicated by the value between the parenthesis. This represents the Julia version that you're running on—and it's possible that you'll get a different default project depending on your very own version of Julia.</p>
<p class="calibre2">Now we can just go ahead and <kbd class="calibre12">add OhMyREPL</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; add OhMyREPL 
  Updating registry at `~/.julia/registries/General` 
  Updating git-repo `https://github.com/JuliaRegistries/General.git` 
 Resolving package versions... 
  Updating `~/.julia/environments/v1.0/Project.toml` 
  [5fb14364] + OhMyREPL v0.3.0 
  Updating `~/.julia/environments/v1.0/Manifest.toml` 
  [a8cc5b0e] + Crayons v1.0.0 
  [5fb14364] + OhMyREPL v0.3.0 
  [0796e94c] + Tokenize v0.5.2 
  [2a0f44e3] + Base64 
  [ade2ca70] + Dates 
  [8ba89e20] + Distributed 
  [b77e0a4c] + InteractiveUtils 
  [76f85450] + LibGit2 
  [8f399da3] + Libdl 
  [37e2e46d] + LinearAlgebra 
  [56ddb016] + Logging 
  [d6f4376e] + Markdown 
  [44cfe95a] + Pkg 
  [de0858da] + Printf 
  [3fa0cd96] + REPL 
  [9a3f8284] + Random 
  [ea8e919c] + SHA 
  [9e88b42a] + Serialization 
  [6462fe0b] + Sockets 
  [8dfed614] + Test 
  [cf7118a7] + UUIDs 
  [4ec0a83e] + Unicode </strong> </pre>
<div class="packttip">The IJulia equivalent of the previous command is <kbd class="calibre24">pkg"add OhMyREPL"</kbd>.</div>
<p class="calibre2">When running <kbd class="calibre12">pkg&gt; add</kbd> on a fresh Julia installation, <kbd class="calibre12">Pkg</kbd> will clone Julia's General registry and use it to look up the names of the package we requested. Although we only explicitly asked for <kbd class="calibre12">OhMyREPL</kbd>, most Julia packages have external dependencies that also need to be installed. As we can see, our package has quite a few—but they were promptly installed by <kbd class="calibre12">Pkg</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom package installation</h1>
                </header>
            
            <article>
                
<p class="calibre2">Sometimes we might want to use packages that are not added to the general registry. This is usually the case with packages that are under (early) development—or private packages. For such situations, we can pass <kbd class="calibre12">pkg&gt; add</kbd> the URL of the repository, instead of the package's name:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; add https://github.com/JuliaLang/Example.jl.git 
   Cloning git-repo `https://github.com/JuliaLang/Example.jl.git` 
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git` 
 Resolving package versions... 
  Updating `~/.julia/environments/v1.0/Project.toml` 
  [7876af07] + Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) 
  Updating `~/.julia/environments/v1.0/Manifest.toml` 
  [7876af07] + Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)</strong> </pre>
<p class="calibre2">Another common scenario is when we want to install a certain branch of a package's repository. This can be easily achieved by appending <kbd class="calibre12">#name_of_the_branch</kbd> at the end of the package's name or URL:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; add OhMyREPL#master 
   Cloning git-repo `https://github.com/KristofferC/OhMyREPL.jl.git` 
  Updating git-repo `https://github.com/KristofferC/OhMyREPL.jl.git` 
 Resolving package versions... 
 Installed Crayons ─ v0.5.1 
  Updating `~/.julia/environments/v1.0/Project.toml` 
  [5fb14364] ~ OhMyREPL v0.3.0 ⇒ v0.3.0 #master (https://github.com/KristofferC/OhMyREPL.jl.git) 
  Updating `~/.julia/environments/v1.0/Manifest.toml`</strong></pre>
<pre class="calibre17">  [a8cc5b0e] ↓ Crayons v1.0.0 ⇒ v0.5.1 
  [5fb14364] ~ OhMyREPL v0.3.0 ⇒ v0.3.0 #master (<a href="https://github.com/KristofferC/OhMyREPL.jl.git" class="calibre30">https://github.com/KristofferC/OhMyREPL.jl.git</a>)</pre>
<p class="calibre2">Or, for unregistered packages, use the following:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; add https://github.com/JuliaLang/Example.jl.git#master</strong> </pre>
<p class="calibre2">If we want to get back to using the published branch, we need to <kbd class="calibre12">free</kbd> the package:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; free OhMyREPL 
 Resolving package versions... 
  Updating `~/.julia/environments/v1.0/Project.toml` 
  [5fb14364] ~ OhMyREPL v0.3.0 #master (https://github.com/KristofferC/OhMyREPL.jl.git) ⇒ v0.3.0 
  Updating `~/.julia/environments/v1.0/Manifest.toml` 
  [a8cc5b0e] ↑ Crayons v0.5.1 ⇒ v1.0.0 
  [5fb14364] ~ OhMyREPL v0.3.0 #master (https://github.com/KristofferC/OhMyREPL.jl.git) ⇒ v0.3.0</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Revise</h1>
                </header>
            
            <article>
                
<p class="calibre2">That was easy, but practice makes perfect. Let's add one more! This time we'll install <kbd class="calibre12">Revise</kbd>, another must-have package that enables a streamlined development workflow by monitoring and detecting changes in your Julia files and automatically reloading the code when needed. Before <kbd class="calibre12">Revise</kbd> it was notoriously difficult to load changes in the current Julia process, developers usually being forced to restart the REPL—a time-consuming and inefficient process. <kbd class="calibre12">Revise</kbd> can eliminate the overhead of restarting, loading packages, and waiting for code to compile.</p>
<div class="packttip">You can learn more about Revise by reading its docs at <a href="https://timholy.github.io/Revise.jl/latest/" class="calibre19"><span>https://timholy.github.io/Revise.jl/latest/</span></a>.</div>
<p class="calibre2">Unsurprisingly, we only have to invoke <kbd class="calibre12">add</kbd> one more time, this time passing in <kbd class="calibre12">Revise</kbd> for the package name:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; add Revise 
Resolving package versions... 
 Installed Revise ─ v0.7.5 
  Updating `~/.julia/environments/v1.0/Project.toml` 
  [295af30f] + Revise v0.7.5 
  Updating `~/.julia/environments/v1.0/Manifest.toml` 
  [bac558e1] + OrderedCollections v0.1.0</strong></pre>
<pre class="calibre17">  [295af30f] + Revise v0.7.5 
  [7b1f6079] + FileWatching </pre>
<div class="packttip">The <kbd class="calibre24">add</kbd> command also accepts multiple packages at once. We added them one by one now, for learning purposes, but otherwise, we could've just executed <kbd class="calibre24">(v1.0) pkg&gt; add OhMyREPL Revise</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the package status</h1>
                </header>
            
            <article>
                
<p class="calibre2">We can confirm that the operations were successful by checking our project's status, using the aptly named <kbd class="calibre12">status</kbd> command:</p>
<pre class="calibre17"><strong class="calibre1"> (v1.0) pkg&gt; status 
    Status `~/.julia/environments/v1.0/Project.toml` 
  [7876af07] Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) 
  [5fb14364] OhMyREPL v0.3.0 
  [295af30f] Revise v0.7.5 </strong></pre>
<p class="calibre2">The <kbd class="calibre12">status</kbd> command displays all the installed packages, including, from left to right, the short version of the package's id (called the <strong class="calibre4">UUID</strong>), the name of the package and the version number. Where appropriate, it will also indicate the branch that we're tracking, as in the case of <kbd class="calibre12">Example</kbd>, where we're on the <kbd class="calibre12">master</kbd> branch.</p>
<div class="packttip"><kbd class="calibre24">Pkg</kbd> also supports a series of shortcuts, if you want to save a few keystrokes. In this case, <kbd class="calibre24">st</kbd> can be used instead of <kbd class="calibre24">status</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using packages</h1>
                </header>
            
            <article>
                
<p class="calibre2">Once a package has been added, in order to access its functionality we have to bring into scope. That's how we tell Julia that we intend to use it, asking the compiler to make it available for us. For that, first, we need to exit pkg mode. Once we're at the julian prompt, in order to use <kbd class="calibre12">OhMyREPL</kbd>, all we need to do is execute:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using OhMyREPL</strong><br class="title-page-name"/><strong class="calibre1">[ Info: Precompiling OhMyREPL [5fb14364-9ced-5910-84b2-373655c76a03]</strong></pre>
<p class="calibre2">That's all it takes—<kbd class="calibre12">OhMyREPL</kbd> is now automatically enhancing the current REPL session. To see it in action, here is what the <em class="calibre16">regular</em> REPL looks like:</p>
<p class="CDPAlignCenter"><img src="assets/78f2947b-7269-43bd-97b4-3d03c4dfcebb.png" class="calibre31"/></p>
<p class="calibre2">And here is the same code, enhanced by <kbd class="calibre12">OhMyREPL</kbd>:</p>
<p class="CDPAlignCenter"><img src="assets/8a1b2be7-71f1-4f3c-bcd4-90772ef61512.png" class="calibre32"/></p>
<p class="calibre2">Syntax highlighting and bracket matching make the code more readable, reducing syntax errors. Looks pretty awesome, doesn't it?</p>
<div class="packttip"><kbd class="calibre24">OhMyREPL</kbd> has a few more cool features up its sleeve—you can learn about them by checking the official documentation at <a href="https://kristofferc.github.io/OhMyREPL.jl/latest/index.html" class="calibre19"><span>https://kristofferc.github.io/OhMyREPL.jl/latest/index.html</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One more step</h1>
                </header>
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">OhMyREPL</kbd> and <kbd class="calibre12">Revise</kbd> are excellent development tools and it's very useful to have them loaded automatically in all the Julia sessions. This is exactly why the <kbd class="calibre12">startup.jl</kbd> file exists—and now we have the opportunity to put it to good use (not that our heartfelt and welcoming greetings were not impressive enough!).</p>
<p class="calibre2">Here's a neat trick, to get us started—Julia provides an <kbd class="calibre12">edit</kbd> function that will open a file in the configured editor. Let's use it to open the <kbd class="calibre12">startup.jl</kbd> file:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; edit("~/.julia/config/startup.jl")</strong> </pre>
<p class="calibre2">This will open the file in the default editor. If you haven't yet deleted our previously added welcome messages, feel free to do it now (unless you really like them and in that case, by all means, you can keep them). Now, <kbd class="calibre12">Revise</kbd> needs to be used before any other module that we want to track—so we'll want to have it at the top of the file. As for <kbd class="calibre12">OhMyREPL</kbd>, it can go next. Your <kbd class="calibre12">startup.jl</kbd> file should look like this:</p>
<pre class="calibre17">using Revise 
using OhMyREPL </pre>
<p class="calibre2">Save it and close the editor. Next time you start Julia, both <kbd class="calibre12">Revise</kbd> and <kbd class="calibre12">OhMyREPL</kbd> will be already loaded.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating packages</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia boosts a thriving ecosystem and packages get updated at a rapid pace. It's a good practice to regularly check for updates with <kbd class="calibre12">pkg&gt; update</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; update</strong> </pre>
<p class="calibre2">When this command is issued, Julia will first retrieve the latest version of the general repository, where it will check if any of the packages need to be updated.</p>
<p class="calibre2">Beware that issuing the <kbd class="calibre12">update</kbd> command will update all the available packages. As we discussed earlier, when mentioning <em class="calibre16">dependency hell</em>, this might not be the best thing. In the upcoming chapters, we will see how to work with individual projects and manage dependencies per individual application. Until then though, it's important to know that you can cherry pick the packages that you want to update by passing in their names:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; update OhMyREPL Revise</strong> </pre>
<p class="calibre2"><kbd class="calibre12">Pkg</kbd> also exposes a preview mode, which will show what will happen when running a certain command without actually making any of the changes:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; preview update OhMyREPL 
(v1.0) pkg&gt; preview add HTTP</strong> </pre>
<div class="packttip">The shortcut for <kbd class="calibre24">pkg&gt; update</kbd> is <kbd class="calibre24">pkg&gt; up</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pinning packages</h1>
                </header>
            
            <article>
                
<p class="calibre2">Sometimes though we might want to ensure that certain packages will not be updated. That's when we <kbd class="calibre12">pin</kbd> them:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; pin OhMyREPL 
 Resolving package versions... 
  Updating `~/.julia/environments/v1.0/Project.toml` 
  [5fb14364] ~ OhMyREPL v0.3.0 ⇒ v0.3.0
  Updating `~/.julia/environments/v1.0/Manifest.toml` 
  [5fb14364] ~ OhMyREPL v0.3.0 ⇒ v0.3.0</strong></pre>
<p class="calibre2">Pinned packages are marked with the <kbd class="calibre12">⚲</kbd> symbol—also present now when checking the status:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; st 
    Status `~/.julia/environments/v1.0/Project.toml` 
  [5fb14364] OhMyREPL v0.3.0
  [295af30f] Revise v0.7.5</strong> </pre>
<p class="calibre2">If we want to unpin a package, we can use <kbd class="calibre12">pkg&gt; free</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; free OhMyREPL 
  Updating `~/.julia/environments/v1.0/Project.toml` 
  [5fb14364] ~ OhMyREPL v0.3.0 ⇒ v0.3.0 
  Updating `~/.julia/environments/v1.0/Manifest.toml` 
  [5fb14364] ~ OhMyREPL v0.3.0 ⇒ v0.3.0 
 
(v1.0) pkg&gt; st 
    Status `~/.julia/environments/v1.0/Project.toml` 
  [5fb14364] OhMyREPL v0.3.0 
  [295af30f] Revise v0.7.5</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing packages</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you no longer plan on using some packages you can delete (or remove them), with the (you guessed it) <kbd class="calibre12">pkg&gt; remove</kbd> command. For instance, let's say that we have the following configuration:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; st 
    Status `~/.julia/environments/v1.0/Project.toml` 
  [7876af07] Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) 
  [5fb14364] OhMyREPL v0.3.0 
  [295af30f] Revise v0.7.5</strong> </pre>
<p class="calibre2">We can remove the <kbd class="calibre12">Example</kbd> package with the following code:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; remove Example 
  Updating `~/.julia/environments/v1.0/Project.toml` 
  [7876af07] - Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) 
  Updating `~/.julia/environments/v1.0/Manifest.toml` 
  [7876af07] - Example v0.5.1+ #master (<a href="https://github.com/JuliaLang/Example.jl.git" class="calibre30">https://github.com/JuliaLang/Example.jl.git</a>)</strong> </pre>
<p class="calibre2">Sure enough, it's now gone:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; st 
    Status `~/.julia/environments/v1.0/Project.toml` 
  [5fb14364] OhMyREPL v0.3.0 
  [295af30f] Revise v0.7.5</strong> </pre>
<div class="packttip">The shortcut for <kbd class="calibre24">pkg&gt; remove</kbd> is <kbd class="calibre24">pkg&gt; rm</kbd>.</div>
<p class="calibre2">Besides the explicit removal of undesired packages, <kbd class="calibre12">Pkg</kbd> also has a built-in auto-cleanup function. As package versions evolve and package dependencies change, some of the installed packages will become obsolete and will no longer be used in any existing project. <kbd class="calibre12">Pkg</kbd> keeps a log of all the projects used so it can go through the log and see exactly which projects are still needing which packages—and thus identify the ones that are no longer necessary. These can be deleted in one swoop with the <kbd class="calibre12">pkg&gt; gc</kbd> command:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt; gc Active manifests at: `/Users/adrian/.julia/environments/v1.0/Manifest.toml` `/Users/adrian/.julia/environments/v0.7/Manifest.toml` Deleted /Users/adrian/.julia/packages/Acorn/exWWb: 40.852 KiB Deleted /Users/adrian/.julia/packages/BufferedStreams/hCA7W: 102.235 KiB Deleted /Users/adrian/.julia/packages/Crayons/e1SsX: 49.133 KiB Deleted /Users/adrian/.julia/packages/Example/ljaU2: 4.625 KiB Deleted /Users/adrian/.julia/packages/Genie/XOia2: 2.031 MiB Deleted /Users/adrian/.julia/packages/HTTPClient/ZQR55: 37.669 KiB Deleted /Users/adrian/.julia/packages/Homebrew/l8kUw: 277.296 MiB Deleted /Users/adrian/.julia/packages/LibCURL/Qs5og: 11.599 MiB Deleted /Users/adrian/.julia/packages/LibExpat/6jLDP: 127.247 KiB Deleted /Users/adrian/.julia/packages/LibPQ/N7lDU: 134.734 KiB Deleted /Users/adrian/.julia/packages/Libz/zMAun: 80.744 KiB Deleted /Users/adrian/.julia/packages/Nettle/LMDZh: 50.371 KiB</strong></pre>
<pre class="calibre17">   Deleted /Users/adrian/.julia/packages/OhMyREPL/limOC: 448.493 KiB 
   Deleted /Users/adrian/.julia/packages/WinRPM/rDDZz: 24.925 KiB 
   Deleted 14 package installations : 292.001 MiB </pre>
<div class="packttip">Besides the dedicated <kbd class="calibre24">Pkg</kbd> REPL mode, Julia also provides a powerful API for programmatically managing packages. We won't cover it, but if you want to learn about it, you can check the official documentation at <a href="https://docs.julialang.org/en/latest/stdlib/Pkg/#References-1" class="calibre19"><span>https://docs.julialang.org/en/latest/stdlib/Pkg/#References-1</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovering packages</h1>
                </header>
            
            <article>
                
<p class="calibre2"><span class="calibre5">Package discovery is not yet as simple as it could be, but there are a few good options. I recommend starting with this list of curated Julia packages: <a href="https://github.com/svaksha/Julia.jl" target="_blank" class="calibre9">https://github.com/svaksha/Julia.jl</a>. It groups a large collection of packages by domain, covering topics such as AI, Biology, Chemistry, Databases, Graphics, Data Science, Physics, Statistics, Super-Computing and more.</span></p>
<p class="calibre2"><span class="calibre5">If that is not enough, you can always go to </span><span class="calibre5"><a href="https://discourse.julialang.org/" target="_blank" class="calibre9">https://discourse.julialang.org</a> </span><span class="calibre5">where the Julia community discusses a multitude of topics related to the language. You can search and browse the existing threads, especially the package announcements section, hosted at <a href="https://discourse.julialang.org/c/community/packages" class="calibre9">https://discourse.julialang.org/c/community/packages</a>.</span></p>
<p class="calibre2"><span class="calibre5">Of course you can always ask the community for help—Julians are very friendly and welcoming, and a lot of effort is put towards moderation, in order to keep the discussion civilized and constructive. A free Discourse account is required in order to create new topics and post replies.</span></p>
<p class="calibre2"><span class="calibre5">Finally, <a href="https://juliaobserver.com/packages" target="_blank" class="calibre9">https://juliaobserver.com/packages</a></span><span class="calibre5"> is a third party website that provides a more polished way to look for packages—and it also performs a GitHub search, thus including unregistered packages too.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registered versus unregistered</h1>
                </header>
            
            <article>
                
<p class="calibre2">Although I already touched upon the topic in the previous paragraphs, I want to close the discussion about <kbd class="calibre12">Pkg</kbd> with a word of caution. The fact that a package is registered does not necessarily mean that it has been vetted in terms of functionality or security. It simply means that the package has been submitted by the creator and that it met certain technical requirements to be added to the general registry. The package sources are available on GitHub, and like with any open source software, make sure that you understand what it does, how it should be used, and that you accept the licensing terms.</p>
<p class="calibre2">This concludes our initial discussion about package management. But as this is one of the most common tasks, we'll come back to it again and again in future chapters, where we'll also see a few scenarios for more advanced usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia is a new programming language that takes advantage of recent innovations in compiler technology to offer the functionality, ease-of-use, and intuitive syntax of dynamic programming languages at the speed of C. One if its goals is to eliminate the so-called <strong class="calibre4">two language problem</strong>—when the users code in a high-level language, such as R and Python, but performance-critical parts have to be rewritten in C or C++. Julia feels like a dynamic language and offers all the productivity features associated with these. But at the same time, it eliminates the performance trade-offs, proving to be productive enough for prototyping and exploratory coding, and efficient enough for performance-critical applications.</p>
<p class="calibre2">Its built-in package manager provides access to over 2,000 third-party libraries that seamlessly extend the language with powerful new features—and we've learned how to take advantage of these. And if that is not enough, Julia has the ability to call functions written in other languages, such as C, Fortran, Python, or Java, to name just a few.</p>
<p class="calibre2">Julia is free and open source (MIT licensed) and can be deployed on all the major operating systems, including Windows, the main Linux distributions, and macOS. It also comes with some very good IDE and editor options.</p>
<p class="calibre2">Now that we have successfully set up our development environment, it's time to dive deeper into Julia's syntax. In the next chapter, we'll take a look at some of the basic building blocks of the language—defining variables and constants, manipulating and using <kbd class="calibre12">Strings</kbd> and numeric types, and working with <kbd class="calibre12">Arrays</kbd>. As a testament to Julia's productivity, that's all we'll need (together with some extra packages that we'll add) in order to perform powerful exploratory data analysis on the Iris flowers dataset. Meet you in the next chapter!</p>


            </article>

            
        </section>
    </body></html>