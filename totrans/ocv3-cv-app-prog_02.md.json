["```py\n    void salt(cv::Mat image, int n) { \n\n      // C++11 random number generator \n      std::default_random_engine generator; \n      std::uniform_int_distribution<int>  \n                   randomRow(0, image.rows - 1); \n      std::uniform_int_distribution<int>  \n                   randomCol(0, image.cols - 1); \n\n      int i,j; \n      for (int k=0; k<n; k++) { \n\n        // random image coordinate \n        i= randomCol(generator); \n        j= randomRow(generator); \n\n        if (image.type() == CV_8UC1) { // gray-level image \n\n          // single-channel 8-bit image \n          image.at<uchar>(j,i)= 255;  \n\n        } else if (image.type() == CV_8UC3) { // color image \n\n          // 3-channel image \n          image.at<cv::Vec3b>(j,i)[0]= 255;  \n          image.at<cv::Vec3b>(j,i)[1]= 255;  \n          image.at<cv::Vec3b>(j,i)[2]= 255;  \n        } \n      } \n    } \n\n```", "```py\n      // open the image \n      cv::Mat image= cv::imread(\"boldt.jpg\",1); \n\n      // call function to add noise \n      salt(image,3000); \n\n      // display result \n      cv::namedWindow(\"Image\"); \n      cv::imshow(\"Image\",image); \n\n```", "```py\n         image.at<uchar>(j,i)= 255; \n\n```", "```py\n    image.at<cv::Vec3b>(j,i)[channel]= value; \n\n```", "```py\n    image.at<cv::Vec3b>(j, i) = cv::Vec3b(255, 255, 255); \n\n```", "```py\n    // use image with a Mat_ template \n    cv::Mat_<uchar> img(image); \n    img(50,100)= 0; // access to row 50 and column 100 \n\n```", "```py\n    void colorReduce(cv::Mat image, int div=64); \n\n```", "```py\n    void colorReduce(cv::Mat image, int div=64) { \n\n      int nl= image.rows; // number of lines \n      // total number of elements per line \n      int nc= image.cols * image.channels();  \n\n      for (int j=0; j<nl; j++) { \n\n        // get the address of row j \n        uchar* data= image.ptr<uchar>(j); \n\n        for (int i=0; i<nc; i++) { \n\n          // process each pixel --------------------- \n\n          data[i]= data[i]/div*div + div/2; \n\n          // end of pixel processing ---------------- \n\n        } // end of line \n      } \n    } \n\n```", "```py\n    // read the image \n    image= cv::imread(\"boldt.jpg\"); \n    // process the image \n    colorReduce(image,64); \n    // display the image \n    cv::namedWindow(\"Image\"); \n    cv::imshow(\"Image\",image); \n\n```", "```py\n    int nc= image.cols * image.channels(); \n\n```", "```py\n    uchar* data= image.ptr<uchar>(j); \n\n```", "```py\n    *data++= *data/div*div + div2;  \n\n```", "```py\n    data[i]= (data[i]/div)*div + div/2; \n\n```", "```py\n    data[i]= data[i] - data[i]%div + div/2; \n\n```", "```py\n    // mask used to round the pixel value \n    uchar mask= 0xFF<<n; // e.g. for div=16, mask= 0xF0 \n\n```", "```py\n    *data &= mask;      // masking \n    *data++ += div>>1;  // add div/2;  \n    // bitwise OR could also be used above instead of + \n\n```", "```py\n    // read the image \n    image= cv::imread(\"boldt.jpg\"); \n    // clone the image \n    cv::Mat imageClone= image.clone(); \n    // process the clone \n    // orginal image remains untouched \n    colorReduce(imageClone); \n    // display the image result \n    cv::namedWindow(\"Image Result\"); \n    cv::imshow(\"Image Result\",imageClone); \n\n```", "```py\n  void colorReduce(const cv::Mat &image, // input image  \n                   cv::Mat &result,      // output image \n                   int div=64); \n\n```", "```py\n    colorReduce(image,image); \n\n```", "```py\n    cv::Mat result;    \n    colorReduce(image,result); \n\n```", "```py\n    result.create(image.rows,image.cols,image.type()); \n\n```", "```py\n    for (int j=0; j<nl; j++) { \n\n      // get the addresses of input and output row j \n      const uchar* data_in= image.ptr<uchar>(j); \n      uchar* data_out= result.ptr<uchar>(j); \n\n      for (int i=0; i<nc*nchannels; i++) { \n\n        // process each pixel --------------------- \n\n        data_out[i]= data_in[i]/div*div + div/2; \n\n        // end of pixel processing ---------------- \n\n      } // end of line \n    } \n\n```", "```py\n    // check if size of a line (in bytes) \n    // equals the number of columns times pixel size in bytes \n    image.step == image.cols*image.elemSize(); \n\n```", "```py\n    void colorReduce(cv::Mat image, int div=64) { \n\n      int nl= image.rows; // number of lines \n      // total number of elements per line \n      int nc= image.cols * image.channels();  \n\n      if (image.isContinuous())  { \n        // then no padded pixels \n        nc= nc*nl; \n        nl= 1;  // it is now a 1D array \n      } \n\n        int n= staic_cast<int>( \n          log(static_cast<double>(div))/log(2.0) + 0.5); \n        // mask used to round the pixel value \n        uchar mask= 0xFF<<n; // e.g. for div=16, mask= 0xF0 \n        uchar div2 = div >> 1; // div2 = div/2 \n\n        // this loop is executed only once \n        // in case of continuous images \n        for (int j=0; j<nl; j++) { \n\n          uchar* data= image.ptr<uchar>(j); \n\n          for (int i=0; i<nc; i++) { \n\n            *data &= mask; \n            *data++ += div2; \n          } // end of line \n        } \n    } \n\n```", "```py\n      if (image.isContinuous())  \n      { \n        // no padded pixels \n        image.reshape(1,   // new number of channels \n                      1);  // new number of rows \n      } \n\n      int nl= image.rows; // number of lines \n      int nc= image.cols * image.channels();  \n\n```", "```py\n    uchar *data= image.data; \n\n```", "```py\n    data+= image.step;  // next line \n\n```", "```py\n    // address of pixel at (j,i) that is &image.at(j,i)      \n    data= image.data+j*image.step+i*image.elemSize();     \n\n```", "```py\n      cv::MatIterator_<cv::Vec3b> it; \n\n```", "```py\n     cv::Mat_<cv::Vec3b>::iterator it; \n\n```", "```py\n    void colorReduce(cv::Mat image, int div=64) { \n\n      // div must be a power of 2 \n      int n= staic_cast<int>( \n    log(static_cast<double>(div))/log(2.0) + 0.5); \n      // mask used to round the pixel value \n      uchar mask= 0xFF<<n; // e.g. for div=16, mask= 0xF0 \n      uchar div2 = div >> 1; // div2 = div/2 \n\n      // get iterators \n      cv::Mat_<cv::Vec3b>::iterator it= image.begin<cv::Vec3b>(); \n      cv::Mat_<cv::Vec3b>::iterator itend= image.end<cv::Vec3b>(); \n\n      // scan all pixels \n      for ( ; it!= itend; ++it) { \n\n        (*it)[0]&= mask; \n        (*it)[0]+= div2; \n        (*it)[1]&= mask; \n        (*it)[1]+= div2; \n        (*it)[2]&= mask; \n        (*it)[2]+= div2; \n      } \n    } \n\n```", "```py\n      *it= *it/div*div+offset; \n\n```", "```py\n    while (it!= itend) {  \n\n      // process each pixel --------------------- \n\n      ... \n\n      // end of pixel processing ---------------- \n\n      ++it; \n    } \n\n```", "```py\n    cv::MatConstIterator_<cv::Vec3b> it; \n\n```", "```py\n    cv::Mat_<cv::Vec3b>::const_iterator it; \n\n```", "```py\n    cv::Mat_<cv::Vec3b> cimage(image); \n    cv::Mat_<cv::Vec3b>::iterator it= cimage.begin(); \n    cv::Mat_<cv::Vec3b>::iterator itend= cimage.end(); \n\n```", "```py\n    const int64 start = cv::getTickCount(); \n    colorReduce(image); // a function call \n    // elapsed time in seconds \n    double duration = (cv::getTickCount()-start)/ \n                               cv::getTickFrequency(); \n\n```", "```py\n    for (int i=0; i<image.cols * image.channels(); i++) { \n      *data &= mask; \n      *data++ += div/2; \n\n```", "```py\n    int nc= image.cols * image.channels(); \n    uchar div2= div>>1;  \n\n    for (int i=0; i<nc; i++) { \n      *(data+i) &= mask; \n      *(data+i) += div2; \n\n```", "```py\n    for (int j=0; j<nl; j++) { \n      for (int i=0; i<nc; i++) { \n\n        image.at<cv::Vec3b>(j,i)[0]= \n               image.at<cv::Vec3b>(j,i)[0]/div*div + div/2; \n        image.at<cv::Vec3b>(j,i)[1]=     \n              image.at<cv::Vec3b>(j,i)[1]/div*div + div/2; \n        image.at<cv::Vec3b>(j,i)[2]=     \n              image.at<cv::Vec3b>(j,i)[2]/div*div + div/2; \n\n      } // end of line \n    } \n\n```", "```py\n    sharpened_pixel= 5*current-left-right-up-down; \n\n```", "```py\n    void sharpen(const cv::Mat &image, cv::Mat &result) { \n\n      // allocate if necessary \n      result.create(image.size(), image.type());  \n      int nchannels= image.channels(); // get number of channels \n\n      // for all rows (except first and last) \n      for (int j= 1; j<image.rows-1; j++) {  \n\n        const uchar* previous= image.ptr<const uchar>(j-1);// previous row \n        const uchar* current= image.ptr<const uchar>(j);   // current row \n        const uchar* next= image.ptr<const uchar>(j+1);    // next row \n\n        uchar* output= result.ptr<uchar>(j); // output row \n\n        for (int i=nchannels; i<(image.cols-1)*nchannels; i++) { \n\n          // apply sharpening operator \n          *output++= cv::saturate_cast<uchar>( \n                  5*current[i]-current[i-nchannels]- \n                  current[i+nchannels]-previous[i]-next[i]);  \n        } \n      } \n\n      // Set the unprocessed pixels to 0 \n      result.row(0).setTo(cv::Scalar(0)); \n      result.row(result.rows-1).setTo(cv::Scalar(0)); \n      result.col(0).setTo(cv::Scalar(0)); \n      result.col(result.cols-1).setTo(cv::Scalar(0)); \n    } \n\n```", "```py\n    result.row(0).setTo(cv::Scalar(0)); \n\n```", "```py\n    void sharpen2D(const cv::Mat &image, cv::Mat &result) { \n\n      // Construct kernel (all entries initialized to 0) \n      cv::Mat kernel(3,3,CV_32F,cv::Scalar(0)); \n      // assigns kernel values \n      kernel.at<float>(1,1)= 5.0; \n      kernel.at<float>(0,1)= -1.0; \n      kernel.at<float>(2,1)= -1.0; \n      kernel.at<float>(1,0)= -1.0; \n      kernel.at<float>(1,2)= -1.0; \n\n      //filter the image \n      cv::filter2D(image,result,image.depth(),kernel); \n    } \n\n```", "```py\n  cv::addWeighted(image1,0.7,image2,0.9,0.,result); \n\n```", "```py\n    // c[i]= a[i]+b[i]; \n    cv::add(imageA,imageB,resultC);  \n    // c[i]= a[i]+k; \n    cv::add(imageA,cv::Scalar(k),resultC);  \n    // c[i]= k1*a[i]+k2*b[i]+k3;  \n    cv::addWeighted(imageA,k1,imageB,k2,k3,resultC); \n    // c[i]= k*a[i]+b[i];  \n    cv::scaleAdd(imageA,k,imageB,resultC); \n\n```", "```py\n    // if (mask[i]) c[i]= a[i]+b[i]; \n    cv::add(imageA,imageB,resultC,mask); \n\n```", "```py\n    result= 0.7*image1+0.9*image2; \n\n```", "```py\n     image=(image&cv::Scalar(mask,mask,mask)) \n                  +cv::Scalar(div/2,div/2,div/2); \n\n```", "```py\n    // create vector of 3 images \n    std::vector<cv::Mat> planes; \n    // split 1 3-channel image into 3 1-channel images \n    cv::split(image1,planes); \n    // add to blue channel \n    planes[0]+= image2; \n    // merge the 3 1-channel images into 1 3-channel image \n    cv::merge(planes,result); \n\n```", "```py\n    // remapping an image by creating wave effects \n    void wave(const cv::Mat &image, cv::Mat &result) { \n\n      // the map functions \n      cv::Mat srcX(image.rows,image.cols,CV_32F); \n      cv::Mat srcY(image.rows,image.cols,CV_32F); \n\n      // creating the mapping \n      for (int i=0; i<image.rows; i++) { \n        for (int j=0; j<image.cols; j++) { \n\n          // new location of pixel at (i,j) \n          srcX.at<float>(i,j)= j; // remain on same column \n                                  // pixels originally on row i are now \n                                  // moved following a sinusoid \n          srcY.at<float>(i,j)= i+5*sin(j/10.0); \n        } \n      } \n\n      // applying the mapping \n      cv::remap(image,                // source image \n                result,               // destination image \n                srcX,                 // x map \n                srcY,                 // y map \n                cv::INTER_LINEAR);    // interpolation method \n    } \n\n```", "```py\n    // the map functions \n    cv::Mat srcX(image.rows,image.cols,CV_32F); // x-map \n    cv::Mat srcY(image.rows,image.cols,CV_32F); // y-map \n\n```", "```py\n    ( srcX.at<float>(i,j) , srcY.at<float>(i,j) ) \n\n```", "```py\n    // creating the mapping \n    for (int i=0; i<image.rows; i++) { \n      for (int j=0; j<image.cols; j++) { \n\n        // horizontal flipping \n        srcX.at<float>(i,j)= image.cols-j-1; \n        srcY.at<float>(i,j)= i; \n      } \n    } \n\n```", "```py\n    // applying the mapping \n    cv::remap(image,             // source image\n              result,            // destination image \n              srcX,              // x map \n              srcY,              // y map \n              cv::INTER_LINEAR); // interpolation method \n\n```"]