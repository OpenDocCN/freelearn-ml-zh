- en: Getting Started with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer vision applications are interesting and useful, but the underlying
    algorithms are computationally intensive. With the advent of cloud computing,
    we are getting more processing power to work with.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenCV library enables us to run computer vision algorithms efficiently
    in real time. It has been around for many years, and has become the standard library
    in this field. One of the main advantages of OpenCV is that it is highly optimized,
    and available on almost all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: This book will cover the various algorithms we will be using, why we are using
    them, and how to implement them in OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to install OpenCV on various operating
    systems. We will discuss what OpenCV offers out of the box, and the various things
    that we can do using the inbuilt functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How do humans process visual data, and how do they understand image content?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can we do with OpenCV, and what are the various modules available in OpenCV
    that can be used to achieve those things?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we install OpenCV on Windows, Linux, and Mac OS X?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the human visual system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into OpenCV functionalities, we need to understand why those
    functions were built in the first place. It's important to understand how the
    human visual system works, so that you can develop the right algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of computer vision algorithms is to understand the content of images
    and videos. Humans seem to do it effortlessly! So, how do we get machines to do
    it with the same accuracy?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b852a3b-bc18-4cb4-b42f-98edb1327ca8.png)'
  prefs: []
  type: TYPE_IMG
- en: The human eye captures all the information that comes along the way, such as
    color, shape, brightness, and so on. In the preceding image, the human eye captures
    all the information about the two main objects and stores it in a certain way.
    Once we understand how our system works, we can take advantage of it to achieve
    what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are a few things we need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: Our visual system is more sensitive to low-frequency content than high-frequency
    content. Low-frequency content refers to planar regions where pixel values don't
    change rapidly, and high-frequency content refers to regions with corners and
    edges where pixel values fluctuate a lot. We can easily see if there are blotches
    on a planar surface, but it's difficult to spot something like that on a highly-textured
    surface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The human eye is more sensitive to changes in brightness than to changes in
    color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our visual system is sensitive to motion. We can quickly recognize if something
    is moving in our field of vision, even though we are not directly looking at it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We tend to make a mental note of salient points in our field of vision. Let's
    say you look at a white table with four black legs, and a red dot at one of the
    corners of the table surface. When you look at this table, you'll immediately
    make a mental note that the surface and legs have opposing colors, and that there
    is a red dot on one of the corners. Our brain is really smart that way! We do
    this automatically so that we can immediately recognize an object if we encounter
    it again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get an idea of our field of view, let''s look at the top view of a human,
    and the angles at which we see various things:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/385f2bbd-533c-4438-be64-188d0b1b59a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Our visual system is actually capable of a lot more, but this should be good
    enough to get us started. You can explore further by reading up on **Human Visual
    System** (**HVS**) models on the web.
  prefs: []
  type: TYPE_NORMAL
- en: How do humans understand image content?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look around, you will see a lot of objects. You encounter many different
    objects every day, and you recognize them almost instantaneously without any effort.
    When you see a chair, you don't wait for a few minutes before realizing that it
    is in fact a chair. You just know that it's a chair right away.
  prefs: []
  type: TYPE_NORMAL
- en: Computers, on the other hand, find it very difficult to do this task. Researchers
    have been working for many years to find out why computers are not as good as
    we are at this.
  prefs: []
  type: TYPE_NORMAL
- en: To get an answer to that question, we need to understand how humans do it. The
    visual data processing happens in the ventral visual stream. This ventral visual
    stream refers to the pathway in our visual system that is associated with object
    recognition. It is basically a hierarchy of areas in our brain that helps us recognize
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Humans can recognize different objects effortlessly, and can cluster similar
    objects together. We can do this because we have developed some sort of invariance
    toward objects of the same class. When we look at an object, our brain extracts
    the salient points in such a way that factors such as orientation, size, perspective,
    and illumination don't matter.
  prefs: []
  type: TYPE_NORMAL
- en: A chair that is double the normal size and rotated by 45 degrees is still a
    chair. We can recognize it easily because of the way we process it. Machines cannot
    do that so easily. Humans tend to remember an object based on its shape and important
    features. Regardless of how the object is placed, we can still recognize it.
  prefs: []
  type: TYPE_NORMAL
- en: In our visual system, we build up these hierarchical invariances with respect
    to position, scale, and viewpoint that help us to be very robust. If you look
    deeper into our system, you will see that humans have cells in their visual cortex
    that can respond to shapes such as curves and lines.
  prefs: []
  type: TYPE_NORMAL
- en: As we move further along our ventral stream, we will see more complex cells
    that are trained to respond to more complex objects such as trees, gates, and
    so on. The neurons along our ventral stream tend to show an increase in the size
    of the receptive field. This is coupled with the fact that the complexity of their
    preferred stimuli increases as well.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it difficult for machines to understand image content?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now understand how visual data enters the human visual system, and how our
    system processes it. The issue is that we still don't fully understand how our
    brain recognizes and organizes this visual data. In machine learning, we just
    extract some features from images, and ask the computers to learn them using algorithms.
    We still have these variations, such as shape, size, perspective, angle, illumination,
    occlusion, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the same chair looks very different to a machine when you look
    at it from the profile view. Humans can easily recognize that it's a chair, regardless
    of how it's presented to us. So, how do we explain this to our machines?
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this would be to store all the different variations of an object,
    including sizes, angles, perspectives, and so on. But this process is cumbersome
    and time-consuming. Also, it's actually not possible to gather data that can encompass
    every single variation. The machines would consume a huge amount of memory and
    a lot of time to build a model that can recognize these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Even with all this, if an object is partially occluded, computers still won't
    recognize it. This is because they think this is a new object. So when we build
    a computer vision library, we need to build the underlying functional blocks that
    can be combined in many different ways to formulate complex algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV provides a lot of these functions, and they are highly optimized. So
    once we understand what OpenCV is capable of, we can use it effectively to build
    interesting applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and explore that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: What can you do with OpenCV?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using OpenCV, you can pretty much do every computer vision task you can think
    of. Real-life problems require you to use many computer vision algorithms and
    modules together to achieve the desired result. So, you just need to understand
    which OpenCV modules and functions to use, in order to get what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what OpenCV can do out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Inbuilt data structures and input/output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best things about OpenCV is that it provides a lot of in-built primitives
    to handle operations related to image processing and computer vision. If you have
    to write something from scratch, you will have to define `Image`, `Point`, `Rectangle`,
    and so on. These are fundamental to almost any computer vision algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV comes with all these basic structures out of the box, contained in the
    core module. Another advantage is that these structures have already been optimized
    for speed and memory, and so you don't have to worry about the implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: The `imgcodecs` module handles reading and writing of image files. When you
    operate on an input image and create an output image, you can save it as a `.jpg`
    or a `.png` file with a simple command.
  prefs: []
  type: TYPE_NORMAL
- en: You will be dealing with a lot of video files when you work with cameras. The
    `videoio` module handles everything related to the input and output of video files.
    You can easily capture a video from the webcam or read a video file in many different
    formats. You can even save a bunch of frames as a video file by setting properties
    such as frames per second, frame size, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Image processing operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write a computer vision algorithm, there are a lot of basic image processing
    operations that you will use over and over again. Most of these functions are
    present in the `imgproc` module. You can do things such as image filtering, morphological
    operations, geometric transformations, color conversions, drawing on images, histograms,
    shape analysis, motion analysis, feature detection, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ae19f9b-34bf-44b2-a8fc-2a7220ce9ba6.png)'
  prefs: []
  type: TYPE_IMG
- en: The right image is a rotated version of the one on the left. We can carry out
    this transformation with a single line in OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: There is another module, called `ximgproc`, which contains advanced image processing
    algorithms such as structured forests for edge detection, domain transform filter,
    adaptive manifold filter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV provides a module called `highgui` that handles all the high-level user
    interface operations. Let's say you are working on a problem, and you want to
    check what the image looks like before you proceed to the next step. This module
    has functions that can be used to create windows to display images and/or videos.
  prefs: []
  type: TYPE_NORMAL
- en: There is a waiting function that will wait until you hit a key on your keyboard
    before it goes on to the next step. There is also a function that can detect mouse
    events. This is very useful in developing interactive applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this functionality, you can draw rectangles on those input windows, and
    then proceed based on the selected region. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bb9b533-be4b-45ea-b55f-e19cdd52c8b7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we drew a green rectangle on top of the window. Once we have
    the coordinates of that rectangle, we can operate only on that region.
  prefs: []
  type: TYPE_NORMAL
- en: Video analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Video analysis includes tasks such as analyzing the motion between successive
    frames in a video, tracking different objects in a video, creating models for
    video surveillance, and so on. OpenCV provides a module called `video` that can
    handle all of this.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a module called `videostab` that deals with video stabilization.
    Video stabilization is important, as when you are capturing videos by holding
    the camera in your hands, there's usually a lot of shake that needs correcting.
    All modern devices use video stabilization to process the video before it's presented
    to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 3D reconstruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3D reconstruction is an important topic in computer vision. Given a set of 2D
    images, we can reconstruct the 3D scene using relevant algorithms. OpenCV provides
    algorithms that can find the relationship between various objects in those 2D
    images to compute their 3D positions in its `calib3d` module.
  prefs: []
  type: TYPE_NORMAL
- en: This module can also handle camera calibration, which is essential for estimating
    the parameters of the camera. These parameters define how the camera sees the
    scene in front of it. We need to know these parameters to design algorithms, or
    else we might get unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a240217-624e-4efb-87f3-d36c73cefd50.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see here, the same object is captured from multiple positions. Our
    job is to reconstruct the original object using these 2D images.
  prefs: []
  type: TYPE_NORMAL
- en: Feature extraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, the human visual system tends to extract the salient
    features from a given scene to remember it for retrieval later. To mimic this,
    people started designing various feature extractors that can extract these salient
    points from a given image. Popular algorithms include **Scale Invariant Feature
    Transform** (**SIFT**), **Speeded Up Robust Features** (**SURF**), and **F****eatures
    From Accelerated Segment Test** (**FAST**).
  prefs: []
  type: TYPE_NORMAL
- en: An OpenCV module called `features2d` provides functions to detect and extract
    all these features. Another module called `xfeatures2d` provides a few more feature
    extractors, some of which are still in the experimental phase. You can play around
    with these if you get the chance.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a module called `bioinspired` that provides algorithms for biologically-inspired
    computer vision models.
  prefs: []
  type: TYPE_NORMAL
- en: Object detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object detection refers to detecting the location of an object in a given image.
    This process is not concerned with the type of object. If you design a chair detector,
    it will not tell you whether the chair in a given image is red with a high back,
    or blue with a low back—it will just tell you the location of the chair.
  prefs: []
  type: TYPE_NORMAL
- en: 'Detecting the location of objects is a critical step in many computer vision
    systems. Consider the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaa400c1-1994-457e-a3d1-bb5d7d2a65c6.png)'
  prefs: []
  type: TYPE_IMG
- en: If you run a chair detector on this image, it will put a green box around all
    the chairs—but it won't tell you what kind of chair it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object detection used to be a computationally-intensive task because of the
    number of calculations required to perform the detection at various scales. To
    solve this, Paul Viola and Michael Jones came up with a great algorithm in their
    seminal 2001 paper, which you can read at the following link: [https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf](https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf).
    They provided a fast way to design an object detector for any object.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV has modules called `objdetect` and `xobjdetect` that provide the framework
    to design an object detector. You can use it to develop detectors for random items
    such as sunglasses, boots, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machine learning algorithms are used extensively to build computer vision systems
    for object recognition, image classification, face detection, visual search, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV provides a module called `ml`, which has many machine learning algorithms
    bundled into it, including a **Bayes classifier**, **k-nearest neighbors** (**KNN**),
    **support vector machines** (**SVM**), **decision trees**, **neural networks**,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: It also has a module called **Fast Approximate Nearest Neighbor Search Library**
    (**FLANN**), which contains algorithms for fast nearest neighbor searches in large
    datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Computational photography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computational photography refers to using advanced image processing techniques
    to improve the images captured by cameras. Instead of focusing on optical processes
    and image capture methods, computational photography uses software to manipulate
    visual data. Applications include high dynamic range imaging, panoramic images,
    image relighting, and light field cameras.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12c9b784-2399-48be-9428-a3a919108bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: Look at those vivid colors! This is an example of a high dynamic range image,
    and it wouldn't be possible to get this using conventional image capture techniques.
    To do this, we have to capture the same scene at multiple exposures, register
    those images with each other, and then blend them nicely to create this image.
  prefs: []
  type: TYPE_NORMAL
- en: The `photo` and `xphoto` modules contain various algorithms that provide algorithms
    pertaining to computational photography. There is also a module called `stitching`
    that provides algorithms to create panoramic images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image shown can be found here: [https://pixabay.com/en/hdr-high-dynamic-range-landscape-806260/](https://pixabay.com/en/hdr-high-dynamic-range-landscape-806260/).'
  prefs: []
  type: TYPE_NORMAL
- en: Shape analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notion of shape is crucial in computer vision. We analyze visual data by
    recognizing various different shapes in the image. This is actually an important
    step in many algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you are trying to identify a particular logo in an image. You know
    that it can appear in various shapes, orientations, and sizes. One good way to
    get started is to quantify the characteristics of the shape of the object.
  prefs: []
  type: TYPE_NORMAL
- en: The `shape` module provides all the algorithms required to extract different
    shapes, measure similarity between them, transform the shapes of objects, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Optical flow algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optical flow algorithms are used in videos to track features across successive
    frames. Let's say you want to track a particular object in a video. Running a
    feature extractor on each frame would be computationally expensive; hence, the
    process would be slow. So, you just extract the features from the current frame,
    and then track those features in successive frames.
  prefs: []
  type: TYPE_NORMAL
- en: Optical flow algorithms are heavily used in video-based applications in computer
    vision. The `optflow` module contains all the algorithms required to perform optical
    flow. There is also a module called `tracking` that contains more algorithms that
    can be used to track features.
  prefs: []
  type: TYPE_NORMAL
- en: Face and object recognition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Face recognition refers to identifying the person in a given image. This is
    not the same as face detection, where you simply identify the location of a face
    in the given image.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to build a practical biometric system that can recognize the person
    in front of the camera, you first need to run a face detector to identify the
    location of the face, and then run a separate face recognizer to identify who
    the person is. There is an OpenCV module called `face` that deals with face recognition.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, computer vision tries to model algorithms based on
    how humans perceive visual data. So, it would be helpful to find salient regions
    and objects in the images that can help with different applications such as object
    recognition, object detection and tracking, and so on. There is a module called
    `saliency` that's designed for this purpose. It provides algorithms that can detect
    salient regions in static images and videos.
  prefs: []
  type: TYPE_NORMAL
- en: Surface matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are increasingly interacting with devices that can capture the 3D structure
    of the objects around us. These devices essentially capture depth information,
    along with the regular 2D color images. So, it's important for us to build algorithms
    that can understand and process 3D objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kinect** is a good example of a device that captures depth information along
    with the visual data. The task at hand is to recognize the input 3D object, by
    matching it to one of the models in our database. If we have a system that can
    recognize and locate objects, then it can be used for many different applications.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a module called `surface_matching` that contains algorithms for 3D
    object recognition and a pose estimation algorithm using 3D features.
  prefs: []
  type: TYPE_NORMAL
- en: Text detection and recognition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identifying text in a given scene and recognizing the content is becoming increasingly
    important. Applications include number plate recognition, recognizing road signs
    for self-driving cars, book scanning to digitize content, and more.
  prefs: []
  type: TYPE_NORMAL
- en: There is a module called `text` that contains various algorithms to handle text
    detection and recognition.
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deep learning has a big impact on computer vision and image recognition, and
    achieves a higher level of accuracy than other machine learning and artificially
    intelligent algorithms. Deep learning is not a new concept; it was introduced
    to the community around 1986, but it started a revolution around 2012 when new
    GPU hardware was optimized for parallel computing and **Convolutional Neural Network**
    (**CNN**) implementations and other techniques allowed the training of complex
    neural network architectures in reasonable times.
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning can be applied to multiple use cases such as image recognition,
    object detection, voice recognition, and natural language processing. Since version
    3.4, OpenCV has been implementing deep learning algorithms—in the latest version,
    multiple importers for important frameworks such as **TensorFlow** and **Caffe**
    have been added.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how to get OpenCV up and running on various operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep things easy, let's install OpenCV using pre-built libraries. Go to [opencv.org](https://opencv.org/)
    and download the latest version for Windows. The current version is 4.0.0, and
    you can get the download link from the OpenCV homepage. You should make sure you
    have admin rights before you proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The downloaded file will be an executable file, so just double-click on it to
    start the installation. The installer expands the content into a folder. You will
    be able to choose the installation path, and check the installation by inspecting
    the files.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done with the previous step, we need to set the OpenCV environment
    variables and add them to the system path to complete the installation. We will
    set up an environment variable that will hold the build directory of the OpenCV
    library. We will be using this in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Terminal and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are assuming that you have a 64-bit machine with Visual Studio 2015 installed.
    If you have Visual Studio 2012, replace `vc14` with `vc11` in the command. The
    path specified is where we would have our OpenCV binaries, and you should see
    two folders inside that path called `lib` and `bin`. If you are using Visual Studio
    2018, you should compile OpenCV from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and add a path to the `bin` folder to our system path. The reason
    we need to do this is because we will be using the OpenCV library in the form
    of **dynamic link libraries** (**DLL**s). Essentially, all the OpenCV algorithms
    are stored here, and our operating system will only load them during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do that, our operating system needs to know where they are located.
    The `PATH` system variable contains a list of all the folders where it can find
    DLLs. So, naturally, we need to add the path of the OpenCV library to this list.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to do all this? Well, the other option is to copy the required
    DLLs in the same folder as the application's executable file (`.exe` file). This
    is an unnecessary overhead, especially when we are working with many different
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to edit the `PATH` variable to add this folder. You can use software
    such as Path Editor to do this, which you can download from here: [https://patheditor2.codeplex.com](https://patheditor2.codeplex.com).
    Once you install it, start it up and add the following new entry (you can right-click
    on the path to insert a new item):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and save it to the registry. We are done!
  prefs: []
  type: TYPE_NORMAL
- en: Mac OS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to install OpenCV on Mac OS X. Precompiled
    binaries are not available for Mac OS X, so we need to compile OpenCV from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, we need to install CMake. If you don''t already have CMake
    installed, you can download it from here: [https://cmake.org/files/v3.12/cmake-3.12.0-rc1-Darwin-x86_64.dmg](https://cmake.org/files/v3.12/cmake-3.12.0-rc1-Darwin-x86_64.dmg).
    It''s a `.dmg` file, so once you download it, just run the installer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the latest version of OpenCV from [opencv.org](https://opencv.org/).
    The current version is 4.0.0, and you can download it from here: [https://github.com/opencv/opencv/archive/4.0.0.zip](https://github.com/opencv/opencv/archive/4.0.0.zip).
    Unzip the contents into a folder of your choice.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV 4.0.0 also has a new package called `opencv_contrib`, containing user
    contributions that are not yet considered stable, and some algorithms that are
    not freely available for commercial use in all the latest computer vision algorithms,
    which is worth keeping in mind. Installing this package is optional—OpenCV will
    work just fine if you don't install `opencv_contrib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are installing OpenCV anyway, it''s good to install this package so
    that you can experiment with it later on (as opposed to going through the whole
    installation process again). It is a great way to learn and play around with new
    algorithms. You can download it from the following link: [https://github.com/opencv/opencv_contrib/archive/4.0.0.zip](https://github.com/opencv/opencv_contrib/archive/4.0.0.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the contents of the zip file into a folder of your choice. For convenience,
    unzip it into the same folder as before, so that the `opencv-4.0.0` and `opencv_contrib-4.0.0`
    folders are in the same main folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to build OpenCV. Open up your Terminal and navigate to the
    folder where you unzipped the contents of OpenCV 4.0.0\. Run the following commands
    after substituting the right paths in the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to install OpenCV 4.0.0\. Go to the `/full/path/to/opencv-4.0.0/build`
    directory, and run the following commands on your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, the **`-j4`** flag indicates that it should be using
    four cores to install it. It''s faster this way! Now, let''s set the library path.
    Open up your `~/.profile` file in your Terminal using the `vi ~/.profile` command,
    and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to copy the `pkgconfig` file in `opencv.pc` to `/usr/local/lib/pkgconfig`
    and name it `opencv4.pc`. This way, if you already have an existing OpenCV 3.x.x
    installation, there will be no conflict. Let''s go ahead and do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to update our `PKG_CONFIG_PATH` variable as well. Open up your `~/.profile`
    file and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload your `~/.profile` file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re finished! Let''s see if it''s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you see Welcome to OpenCV 4.0.0 printed on your Terminal, you are good to
    go. We will be using CMake to build our OpenCV projects throughout this book.
    We will cover it in more detail in [Chapter 2](37cf2702-b8c6-41ff-a935-fd4030f8ce64.xhtml),
    *An Introduction to the Basics of OpenCV*.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to install OpenCV on Ubuntu. We need to install some dependencies
    before we begin. Let''s install them using the package manager by running the
    following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have installed the dependencies, let''s download, build, and install
    OpenCV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s copy the `pkgconfig` file in `opencv.pc` to `/usr/local/lib/pkgconfig`,
    and name it `opencv4.pc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We're finished! We will now be able to use it to compile our OpenCV programs
    from the command line. Also, if you already have an existing OpenCV 3.x.x installation,
    there will be no conflict.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the installation is working properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you see Welcome to OpenCV 4.0.0 printed on your Terminal, you should be good
    to go. In the following chapters, we will learn how to use CMake to build our
    OpenCV projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the human visual system, and how humans process
    visual data. We explained why it's difficult for machines to do the same, and
    what we need to consider when designing a computer vision library.
  prefs: []
  type: TYPE_NORMAL
- en: We learned what could be done using OpenCV, and the various modules that can
    be used to complete those tasks. Finally, we learned how to install OpenCV in
    various operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to operate on images and how we can
    manipulate them using various functions. We will also learn about building a project
    structure for our OpenCV applications.
  prefs: []
  type: TYPE_NORMAL
