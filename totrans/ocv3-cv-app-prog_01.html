<html><head></head><body><div class="calibre1" title="Chapter&#xA0;1.&#xA0;Playing with Images"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title"><a id="ch01" class="calibre6"/>Chapter 1. Playing with Images</h1></div></div></div><p class="calibre8">In this chapter, we will get you started with the <span><strong class="calibre15">OpenCV</strong></span> library. You will learn how to perform the following tasks:</p><div class="calibre1"><ul class="itemizedlist"><li class="listitem">Installing the OpenCV library</li><li class="listitem">Loading, displaying, and saving images</li><li class="listitem">Exploring the <code class="literal">cv::Mat</code> data structure</li><li class="listitem">Defining regions of interest</li></ul></div><div class="calibre1" title="Introduction"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch01lvl1sec8" class="calibre6"/>Introduction</h1></div></div></div><p class="calibre8">This chapter will teach you the basic elements of OpenCV and will show you how to accomplish the most fundamental image processing tasks: reading, displaying, and saving images. However, before you start with OpenCV, you need to install the library. This is a simple process that is explained in the first recipe of this chapter.</p><p class="calibre8">All your computer vision applications will involve the processing of images. This is why OpenCV offers you a data structure to handle images and matrices. It is a powerful data structure with many useful attributes and methods. It also incorporates an advanced memory management model that greatly facilitates the development of applications. The last two recipes of this chapter will teach you how to use this important data structure of OpenCV.</p></div></div>
<div class="calibre1" title="Installing the OpenCV library"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch01lvl1sec9" class="calibre6"/>Installing the OpenCV library</h1></div></div></div><p class="calibre8">OpenCV is an open source library for developing computer vision applications that can run on multiple platforms, such as Windows, Linux, Mac, Android, and iOS. It can be used in both academic and commercial applications under a BSD license that allows you to freely use, distribute, and adapt it. This recipe will show you how to install the library on your machine.</p><div class="calibre1" title="Getting ready"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec13" class="calibre6"/>Getting ready</h2></div></div></div><p class="calibre8">When you visit the OpenCV official website at <a href="http://opencv.org/">
http://opencv.org/
</a>, you will find the latest release of the library, the online documentation describing the <span><strong class="calibre15">Application Programming Interface</strong></span> (<span><strong class="calibre15">API</strong></span>), and many other useful resources on OpenCV.</p></div><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec14" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">From the OpenCV website, find the latest available downloads and select the one that corresponds to the platform of your choice (Windows, Linux/Mac, or iOS). Once the OpenCV package is downloaded, run the WinZip self-extractor and select the location of your choice. An <code class="literal">opencv</code> directory will be created; it is a good idea to rename it in a way that will show which version you are using (for example, in Windows, your final directory could be <code class="literal">C:\opencv-3.2</code>). This directory will contain a collection of files and directories that constitute the library. Notably, you will find the <code class="literal">sources</code> directory that will contain all the source files (yes, it is open source!).</p><p class="calibre8">In order to complete the installation of the library and have it ready for use, you need to take an important step: generate the binary files of the library for the environment of your choice. This is indeed the point where you have to make a decision on the target platform you wish to use to create your OpenCV applications. Which operating system do you prefer to use? Which compiler should you select? Which version? 32-bit or 64-bit? As you can see, there are many possible options, and this is why you have to build the library that fits your needs.</p><p class="calibre8">The <span><strong class="calibre15">Integrated Development Environment</strong></span> (<span><strong class="calibre15">IDE</strong></span>) you will use in your project development will also guide you to make these choices. Note that the library package also comes with precompiled binaries that you can directly use if they correspond to your situation (check the <code class="literal">build</code> directory adjacent to the <code class="literal">sources</code> directory). If one of the precompiled binaries satisfies your requirements, then you are ready to go.</p><p class="calibre8">One important remark, however. Since version 3, OpenCV has been split into two major components. The first one is the main OpenCV source repository that includes the mature algorithms. This is the one you have downloaded. A separate contribution repository also exists, and it contains the new computer vision algorithm, recently added by the OpenCV contributors. If your plan is to use only the core functions of OpenCV, you do not need the <code class="literal">contrib</code> package. But if you want to play with the latest state-of-the-art algorithms, then there is a good chance that you will need this extra module. As a matter of fact, this cookbook will show you how to use several of these advanced algorithms. You therefore need the <code class="literal">contrib</code> modules to follow the recipes of this book. So you have to go to <a href="https://github.com/opencv/opencv_contrib">
https://github.com/opencv/opencv_contrib
</a> and download OpenCV's extra modules (download the ZIP file). You can unzip the extra modules into the directory of your choice; these modules should be found at <code class="literal">opencv_contrib-master/modules</code>. For simplicity, you can rename this directory as <code class="literal">contrib</code> and copy it directly inside the <code class="literal">sources</code> directory of the main package. Note that you can also pick the extra modules of your choice and only save them; however, you will probably find it easier, at this point, to simply keep everything.</p><p class="calibre8">You are now ready to proceed with the installation. To build the OpenCV binaries, it is highly suggested that you use the <span><strong class="calibre15">CMake</strong></span> tool, available at <a href="http://cmake.org">
http://cmake.org
</a>. CMake is another open source software tool designed to control the compilation process of a software system using platform-independent configuration files. It generates the required <code class="literal">makefile</code> or <code class="literal">solution</code> files needed for compiling a software library in your environment. Therefore, you have to download and install CMake. Also see the <span><em class="calibre16">There's more...</em></span> section of this recipe for an additional software package, the <span><strong class="calibre15">Visualization Toolkit</strong></span> (<span><strong class="calibre15">VTK</strong></span>), that you may want to install before compiling the library.</p><p class="calibre8">You can run <code class="literal">cmake</code> using a command-line interface, but it is easier to use <code class="literal">CMake</code> with its graphical interface (<span><strong class="calibre15">cmake-gui</strong></span>). In the latter case, all you need to do is specify the folder containing the OpenCV library source and the one that will contain the binaries. Now click on <span><strong class="calibre15">Configure</strong></span> and select the compiler of your choice:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_01_001.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">Once this initial configuration is completed, CMake will provide you with a number of configuration options. You have to decide, for example, whether you want to have the documentation installed or whether you wish to have some additional libraries installed. Unless you know what you are doing, it is probably better to leave the default options as they are. However, since we want to include the extra modules, we have to specify the directory where they can be found:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_01_002.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">Once the extra module path is specified, click on <span><strong class="calibre15">Configure</strong></span> again. You are now ready to generate the project files by clicking on the <span><strong class="calibre15">Generate</strong></span> button. These files will allow you to compile the library. This is the last step of the installation process, which will make the library ready to be used in your development environment. For example, if you select MS Visual Studio, then all you need to do is open the top-level solution file that CMake has created for you (the <code class="literal">OpenCV.sln</code> file). You then select the <span><strong class="calibre15">INSTALL</strong></span> project (under <span><strong class="calibre15">CMakeTargets</strong></span>) and issue the <span><strong class="calibre15">Build</strong></span> command (use right-click).</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_01_003.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">To get both a <span><strong class="calibre15">Release</strong></span> and <span><strong class="calibre15">Debug</strong></span> build, you will have to repeat the compilation process twice, one for each configuration. If everything goes well, you will have an <code class="literal">install</code> directory (under <code class="literal">build</code>) created. This directory will contain all the <code class="literal">binary</code> files of the OpenCV library to be linked with your application as well as the dynamic library files that your executables have to call at runtime. Make sure you set your system's <code class="literal">PATH</code> environment variable (from <span><strong class="calibre15">Control Panel</strong></span>) such that your operating system would be able to find the <code class="literal">.dll</code> files when you run your applications (for example, <code class="literal">C:\opencv-3.2\build \install\x64\vc14\bin</code>). You should also define the environment variable, <code class="literal">OPENCV_DIR</code> pointing to the <code class="literal">INSTALL</code> directory. This way, CMake will be able to find the library when configuring future projects.</p><p class="calibre8">In Linux environments, you can use Cmake to generate the required <code class="literal">Makefiles</code>; you then complete the installation by executing a <code class="literal">sudo make install</code> command. Alternatively, you could also use the packaging tool <code class="literal">apt-get</code> which can automatically perform a complete installation of the library. For Mac OS, you should use the <code class="literal">Homebrew</code> package manager. Once installed, you just have to type <code class="literal">brew install opencv3 --with-contrib</code> in order to have the complete library installed (run <code class="literal">brew info opencv3</code> to view all possible options). </p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec15" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">OpenCV is a library that is in constant evolution. With version 3, the library continues to expand offering a lot of new functionalities with enhanced performances. The move to having a full C++ API, which was initiated in version 2, is now almost complete, and more uniform interfaces have been implemented. One of the major changes introduced in this new version is the restructuring of the modules of the library in order to facilitate its distribution. In particular, a separate repository containing the most recent algorithms has been created. This <code class="literal">contrib</code> repository also contains non-free algorithms that are subject to specific licenses. The idea is for OpenCV to be able to offer state-of-the-art functionalities that developers and researchers want to share while still being able to offer a very stable and well-maintained core API. The main modules are therefore the ones you get when you download the library at <a href="http://opencv.org/">http://opencv.org/</a>. The extra modules must be downloaded directly from the development repository hosted on GitHub (<a href="https://github.com/opencv/">
https://github.com/opencv/
</a>). Since these extra modules are in constant development, you should expect more frequent changes to the algorithms they contain.</p><p class="calibre8">The OpenCV library is divided into several modules. For example, the <code class="literal">opencv_core</code> module contains the core functionalities of the library; the <code class="literal">opencv_imgproc</code> module includes the main image processing functions; the <code class="literal">opencv_highgui</code> module offers the image and video reading and writing functions along with some user interface functions; and so on. To use a particular module, you have to include the corresponding top-level header file. For instance, most applications that use OpenCV start with the following declarations:</p><pre class="programlisting">    #include &lt;opencv2/core.hpp&gt; 
    #include &lt;opencv2/imgproc.hpp&gt; 
    #include &lt;opencv2/highgui.hpp&gt; 
</pre><p class="calibre8">As you learn to work with OpenCV, you will discover more and more functionalities available in its numerous modules.</p></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec16" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">The OpenCV website at <a href="http://opencv.org/">
http://opencv.org/
</a> contains detailed instructions on how to install the library. It also contains complete online documentation that includes several tutorials on the different components of the library.</p><div class="calibre1" title="The Visualization Toolkit and the cv::viz module"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch01lvl3sec0" class="calibre6"/>The Visualization Toolkit and the cv::viz module</h3></div></div></div><p class="calibre8">In some applications, computer vision is used to reconstruct the 3D information of a scene from images. When working with 3D data, it is often useful to be able to visualize the results in some 3D virtual world. As you will learn in <a href="ch11.html" title="Chapter 11. Reconstructing 3D Scenes">
Chapter 11
</a>, <span><em class="calibre16">Reconstructing 3D Scenes</em></span>, the <code class="literal">cv::viz</code> module offers many useful functions that allow you to visualize scene objects and cameras in 3D. However, this module is built on top of another open source library: VTK. Therefore, if you want to use the <code class="literal">cv::viz</code> module, you need to install VTK on your machine before compiling OpenCV.</p><p class="calibre8">VTK is available at <a href="http://www.vtk.org/">http://www.vtk.org/</a>. All you have to do is download the library and use CMake in order to create the binaries for your development environment. In this book, we used version 6.3.0. In addition, you should define the <code class="literal">VTK_DIR</code> environment variable, pointing to the directory containing the built files. Also, in the configuration options proposed during the OpenCV installation process with CMake, make sure that the <code class="literal">WITH_VTK</code> option is checked.</p></div><div class="calibre1" title="The OpenCV developer site"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch01lvl3sec1" class="calibre6"/>The OpenCV developer site</h3></div></div></div><p class="calibre8">OpenCV is an open source project that welcomes user contributions. The library is hosted on GitHub, a web service that offers version control and source code management tools based on Git. You can access the developer site at <a href="https://github.com/opencv/opencv/wiki">
https://github.com/opencv/opencv/wiki
</a>. Among other things, you can access the currently developed version of OpenCV. The community uses Git as their version control system. Git is also a free open source software system; it is probably the best tool you can use to manage your own source code.</p><div class="note" title="Note"><div class="inner"><h3 class="title4"><a id="note1" class="calibre6"/>Note</h3><p class="calibre19">Downloading the example source code of this book:
The source code files of the examples presented in this cookbook are also hosted on GitHub. Please visit the author's repository at <a href="https://github.com/laganiere">
https://github.com/laganiere
</a> to obtain the latest version of the code.
Note that you can download the example code files for all the Packt books you have purchased from your account at <a href="http://www.packtpub.com">
http://www.packtpub.com
</a>. If you have purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">
http://www.packtpub.com/support
</a> and register yourselves there to have the files e-mailed directly to you.</p></div></div></div></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec17" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The author's website (<a href="http://www.laganiere.name/">http://www.laganiere.name/</a>) also presents step-by-step instructions on how to install the latest versions of the OpenCV library</li><li class="listitem">Visit <a href="https://git-scm.com/">https://git-scm.com/</a> and <a href="https://github.com/">https://github.com/</a> to learn more about source code management.</li></ul></div></div></div>
<div class="calibre1" title="Loading, displaying, and saving images"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch01lvl1sec10" class="calibre6"/>Loading, displaying, and saving images</h1></div></div></div><p class="calibre8">It is now time to run your first OpenCV application. Since OpenCV is about processing images, this task will show you how to perform the most fundamental operations needed in the development of imaging applications. These are loading an input image from a file, displaying an image on a window, applying a processing function, and saving the output image.</p><div class="calibre1" title="Getting ready"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec18" class="calibre6"/>Getting ready</h2></div></div></div><p class="calibre8">Using your favorite IDE (for example, MS Visual Studio or Qt), create a new console application with a <code class="literal">main</code> function that is ready to be filled.</p></div><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec19" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">The first thing to do is to include the header files, declaring the classes and functions you wish to use. Here, we simply want to display an image, so we need the <code class="literal">core</code> header that declares the image data structure and the <code class="literal">highgui</code> header file that contains all the graphical interface functions:</p><pre class="programlisting">    #include &lt;opencv2/core.hpp&gt; 
    #include &lt;opencv2/highgui.hpp&gt; 
</pre><p class="calibre8">Our main function starts by declaring a variable that will hold the image. Under OpenCV, this is done by defining an object of the <code class="literal">cv::Mat</code> class:</p><pre class="programlisting">    cv::Mat image; // create an empty image 
</pre><p class="calibre8">This definition creates an image of size <code class="literal">0x0</code>. This can be confirmed by accessing the <code class="literal">cv::Mat</code> size attributes:</p><pre class="programlisting">    std::cout &lt;&lt; "This image is " &lt;&lt; image.rows &lt;&lt; " x "  
              &lt;&lt; image.cols &lt;&lt; std::endl; 
</pre><p class="calibre8">Next, a simple call to the reading function will read an image from a file, decode it, and allocate the memory:</p><pre class="programlisting">    image=  cv::imread("puppy.bmp"); // read an input image 
</pre><p class="calibre8">You are now ready to use this image. However, you should first check whether the image has been correctly read (an error will occur if the file is not found, is corrupted, or is not in a recognizable format). The validity of the image is tested using the following code:</p><pre class="programlisting">    if (image.empty()) {  // error handling 
      // no image has been created... 
      // possibly display an error message 
      // and quit the application  
      ... 
    } 
</pre><p class="calibre8">The <code class="literal">empty</code> method returns <code class="literal">true</code> if no image data has been allocated.</p><p class="calibre8">The first thing you might want to do with this image is display it. You can do this using the functions of the <code class="literal">highgui</code> module. Start by declaring the window on which you want to display the images, then specify the image to be shown on this special window:</p><pre class="programlisting">    // define the window (optional) 
    cv::namedWindow("Original Image"); 
    // show the image  
    cv::imshow("Original Image", image); 
</pre><p class="calibre8">As you can see, the window is identified by a name. You can reuse this window to display another image later, or you can create multiple windows with different names. When you run this application, you will see an image window, as follows:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_01_004.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">Now, you would normally apply some processing to the image. OpenCV offers a wide selection of processing functions, and several of them are explored in this book. Let's start with a very simple one that flips an image horizontally. Several image transformations in OpenCV can be performed in-place, meaning the transformation is applied directly on the input image (no new image is created). This is the case for the flipping method. However, we can always create another matrix to hold the output result, and this is what we will do:</p><pre class="programlisting">    cv::Mat result; // we create another empty image 
    cv::flip(image,result,1); // positive for horizontal 
                              // 0 for vertical, 
                              // negative for both 
</pre><p class="calibre8">The result is displayed on another window:</p><pre class="programlisting">    cv::namedWindow("Output Image");    // the output window 
    cv::imshow("Output Image", result); 
</pre><p class="calibre8">Since it is a console window that will terminate when it reaches the end of the <code class="literal">main</code> function, we add an extra <code class="literal">highgui</code> function to wait for a user key before we end the program:</p><pre class="programlisting">    cv::waitKey(0); // 0 to indefinitely wait for a key pressed 
                    // specifying a positive value will wait for 
                    // the given amount of msec 
</pre><p class="calibre8">You can then see that the output image is displayed in a distinct window, as shown in the following screenshot:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_01_005.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">Finally, you will probably want to save the processed image on your disk. This is done using the following <code class="literal">highgui</code> function:</p><pre class="programlisting">    cv::imwrite("output.bmp", result); // save result 
</pre><p class="calibre8">The file extension determines which codec will be used to save the image. Other popular supported image formats are JPG, TIFF, and PNG.</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec20" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">All classes and functions in the C++ API of OpenCV are defined within the <code class="literal">cv</code> namespace. You have two ways to access them. First, precede the <code class="literal">main</code> function's definition with the following declaration:</p><pre class="programlisting">    using namespace cv; 
</pre><p class="calibre8">Alternatively, prefix all OpenCV class and function names with the namespace specification, that is, <code class="literal">cv::</code>, as we will do in this book. The use of this prefix makes the OpenCV classes and functions easier to identify within your code.</p><p class="calibre8">The <code class="literal">highgui</code> module contains a set of functions that allow you to easily visualize and interact with your images. When you load an image with the <code class="literal">imread</code> function, you also have the option to read it as a gray-level image. This is very advantageous since several computer vision algorithms require gray-level images. Converting an input color image on the fly as you read it will save you time and minimize your memory usage. This can be done as follows:</p><pre class="programlisting">    // read the input image as a gray-scale image 
    image=  cv::imread("puppy.bmp", cv::IMREAD_GRAYSCALE); 
</pre><p class="calibre8">This will produce an image made of unsigned bytes (<code class="literal">unsigned char</code> in C++) that OpenCV designates with the constant <code class="literal">CV_8U</code>. Alternatively, it is sometimes necessary to read an image as a three-channel color image even if it has been saved as a gray-level image. This can be achieved by calling the <code class="literal">imread</code> function with a positive second argument:</p><pre class="programlisting">    // read the input image as a 3-channel color image 
    image=  cv::imread("puppy.bmp", cv::IMREAD_COLOR); 
</pre><p class="calibre8">This time, an image made of 3 bytes per pixel will be created and designated as <code class="literal">CV_8UC3</code> in OpenCV. Of course, if your input image has been saved as a gray-level image, all three channels will contain the same value. Finally, if you wish to read the image in the format in which it has been saved, then simply input a negative value as the second argument. The number of channels in an image can be checked using the <code class="literal">channels</code> method:</p><pre class="programlisting">    std::cout &lt;&lt; "This image has "  
              &lt;&lt; image.channels() &lt;&lt; " channel(s)"; 
</pre><p class="calibre8">Pay attention when you open an image with <code class="literal">imread</code> without specifying a full path (as we did here). In such a case, the default directory will be used. When you run your application from the console, this directory is obviously the current console's directory. However, if you run the application directly from your IDE, the default directory will most often be the one that contains your project file. Consequently, make sure that your input image file is located in the right directory.</p><p class="calibre8">When you use <code class="literal">imshow</code> to display an image made up of integers (designated as <code class="literal">CV_16U</code> for 16-bit unsigned integers or as <code class="literal">CV_32S</code> for 32-bit signed integers), the pixel values of this image will be divided by <code class="literal">256</code> first. This is done in an attempt to make it displayable with <code class="literal">256</code> gray shades. Similarly, an image made up of floating points will be displayed by assuming a range of possible values between <code class="literal">0.0</code> (displayed as black) and <code class="literal">1.0</code> (displayed as white). Values outside this defined range are displayed in white (for values above <code class="literal">1.0</code>) or black (for values below <code class="literal">0.0</code>).</p><p class="calibre8">The <code class="literal">highgui</code> module is very useful to build quick prototypal applications. When you are ready to produce a finalized version of your application, you will probably want to use the GUI module offered by your IDE in order to build an application with a more professional look.</p><p class="calibre8">Here, our application uses both input and output images. As an exercise, you should rewrite this simple program such that it takes advantage of the function's in-place processing, that is, by not declaring the output image and writing it instead:</p><pre class="programlisting">    cv::flip(image,image,1); // in-place processing 
</pre></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec21" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">The <code class="literal">highgui</code> module contains a rich set of functions that help you interact with your images. Using these, your applications can react to mouse or key events. You can also draw shapes and write text on images.</p><div class="calibre1" title="Clicking on images"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch01lvl3sec2" class="calibre6"/>Clicking on images</h3></div></div></div><p class="calibre8">You can program your mouse to perform specific operations when it is over one of the image windows you created. This is done by defining an appropriate <span><strong class="calibre15">callback</strong></span> function. A callback function is a function that you do not explicitly call but which is called by your application in response to specific events (here, the events that concern the mouse interacting with an image window). To be recognized by applications, callback functions need to have a specific signature and must be registered. In the case of a mouse event handler, the callback function must have the following signature:</p><pre class="programlisting">    void onMouse( int event, int x, int y, int flags, void* param); 
</pre><p class="calibre8">The first parameter is an integer that is used to specify which type of mouse event has triggered the call to the callback function. The other two parameters are simply the pixel coordinates of the mouse location when the event has occurred. The flags are used to determine which button was pressed when the mouse event was triggered. Finally, the last parameter is used to send an extra parameter to the function in the form of a pointer to any object. This callback function can be registered in the application through the following call:</p><pre class="programlisting">    cv::setMouseCallback("Original Image", onMouse,  
                          reinterpret_cast&lt;void*&gt;(&amp;image)); 
</pre><p class="calibre8">In this example, the <code class="literal">onMouse</code> function is associated with the image window called <span><strong class="calibre15">Original Image</strong></span>, and the address of the displayed image is passed as an extra parameter to the function. Now, if we define the <code class="literal">onMouse</code> callback function as shown in the following code, then each time the mouse is clicked, the value of the corresponding pixel will be displayed on the console (here, we assume that it is a gray-level image):</p><pre class="programlisting">    void onMouse( int event, int x, int y, int flags, void* param)  { 
 
      cv::Mat *im= reinterpret_cast&lt;cv::Mat*&gt;(param); 
 
      switch (event) {  // dispatch the event 
 
        case cv::EVENT_LBUTTONDOWN: // left mouse button down event 
 
          // display pixel value at (x,y) 
          std::cout &lt;&lt; "at (" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ") value is: "  
                    &lt;&lt; static_cast&lt;int&gt;(               
                            im-&gt;at&lt;uchar&gt;(cv::Point(x,y))) &lt;&lt; std::endl; 
          break; 
      } 
    } 
</pre><p class="calibre8">Note that in order to obtain the pixel value at <code class="literal">(x,y)</code>, we used the <code class="literal">at</code> method of the <code class="literal">cv::Mat</code> object; this is discussed in <a href="ch02.html" title="Chapter 2. Manipulating Pixels">
Chapter 2
</a>, <span><em class="calibre16">Manipulating Pixels</em></span>. Other possible events that can be received by the mouse event callback function include <code class="literal">cv::EVENT_MOUSEMOVE</code>, <code class="literal">cv::EVENT_LBUTTONUP</code>, <code class="literal">cv::EVENT_RBUTTONDOWN</code>, and <code class="literal">cv::EVENT_RBUTTONUP</code>.</p></div><div class="calibre1" title="Drawing on images"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch01lvl3sec3" class="calibre6"/>Drawing on images</h3></div></div></div><p class="calibre8">OpenCV also offers a few functions to draw shapes and write text on images. The examples of basic shape-drawing functions are <code class="literal">circle</code>, <code class="literal">ellipse</code>, <code class="literal">line</code>, and <code class="literal">rectangle</code>. The following is an example of how to use the <code class="literal">circle</code> function:</p><pre class="programlisting">    cv::circle(image,                // destination image  
               cv::Point(155,110),   // center coordinate 
               65,                   // radius   
               0,                    // color (here black) 
               3);                   // thickness 
</pre><p class="calibre8">The <code class="literal">cv::Point</code> structure is often used in OpenCV methods and functions to specify a pixel coordinate. Note that here we assume that the drawing is done on a gray-level image; this is why the color is specified with a single integer. In the next recipe, you will learn how to specify a color value in the case of color images that use the <code class="literal">cv::Scalar</code> structure. It is also possible to write text on an image. This can be done as follows:</p><pre class="programlisting">    cv::putText(image,                    // destination image 
                "This is a dog.",         // text 
                cv::Point(40,200),        // text position 
                cv::FONT_HERSHEY_PLAIN,   // font type 
                2.0,                      // font scale 
                255,                      // text color (here white) 
                2);                       // text thickness 
</pre><p class="calibre8">Calling these two functions on our test image will then result in the following screenshot:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="Drawing on images" src="graphics/image_01_006.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">Note that you have to include the top-level module header <code class="literal">opencv2/imgproc.hpp</code> for these examples to work.</p></div></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec22" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The <code class="literal">cv::Mat</code> class is the data structure that is used to hold your images (and obviously, other matrix data). This data structure is at the core of all OpenCV classes and functions; the next recipe offers a detailed explanation of this data structure.</li></ul></div></div></div>
<div class="calibre1" title="Exploring the cv::Mat data structure"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch01lvl1sec11" class="calibre6"/>Exploring the cv::Mat data structure</h1></div></div></div><p class="calibre8">In the previous recipe, you were introduced to the <code class="literal">cv::Mat</code> data structure. As mentioned, this is a key component of the library. It is used to manipulate images and matrices (in fact, an image is a matrix from a computational and mathematical point of view). Since you will be using this data structure extensively in your application development processes, it is imperative that you become familiar with it. Notably, in this recipe, you will learn that this data structure incorporates an elegant memory management mechanism.</p><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec23" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">Let's write the following test program that will allow us to test the different properties of the <code class="literal">cv::Mat</code> data structure:</p><pre class="programlisting">    #include &lt;iostream&gt; 
    #include &lt;opencv2/core.hpp&gt; 
    #include &lt;opencv2/highgui.hpp&gt; 
 
    // test function that creates an image 
    cv::Mat function() { 
       // create image 
       cv::Mat ima(500,500,CV_8U,50); 
       // return it 
       return ima; 
    } 
 
    int main() { 
      // create a new image made of 240 rows and 320 columns 
      cv::Mat image1(240,320,CV_8U,100); 
  
      cv::imshow("Image", image1); // show the image 
      cv::waitKey(0); // wait for a key pressed 
 
      // re-allocate a new image 
      image1.create(200,200,CV_8U); 
      image1= 200; 
 
      cv::imshow("Image", image1); // show the image 
      cv::waitKey(0); // wait for a key pressed 
 
      // create a red color image 
      // channel order is BGR 
      cv::Mat image2(240,320,CV_8UC3,cv::Scalar(0,0,255)); 
 
      // or: 
      // cv::Mat image2(cv::Size(320,240),CV_8UC3); 
      // image2= cv::Scalar(0,0,255); 
 
      cv::imshow("Image", image2); // show the image 
      cv::waitKey(0); // wait for a key pressed 
 
      // read an image 
      cv::Mat image3=  cv::imread("puppy.bmp");  
 
      // all these images point to the same data block 
      cv::Mat image4(image3); 
      image1= image3; 
 
      // these images are new copies of the source image 
      image3.copyTo(image2); 
      cv::Mat image5= image3.clone(); 
 
      // transform the image for testing 
      cv::flip(image3,image3,1);  
 
      // check which images have been affected by the processing 
      cv::imshow("Image 3", image3);  
      cv::imshow("Image 1", image1);  
      cv::imshow("Image 2", image2);  
      cv::imshow("Image 4", image4);  
      cv::imshow("Image 5", image5);  
      cv::waitKey(0); // wait for a key pressed 
   
 
      // get a gray-level image from a function 
      cv::Mat gray= function(); 
 
      cv::imshow("Image", gray); // show the image 
      cv::waitKey(0); // wait for a key pressed 
 
      // read the image in gray scale 
      image1= cv::imread("puppy.bmp", CV_LOAD_IMAGE_GRAYSCALE);  
      image1.convertTo(image2,CV_32F,1/255.0,0.0); 
 
      cv::imshow("Image", image2); // show the image 
      cv::waitKey(0); // wait for a key pressed 
 
      return 0; 
    } 
</pre><p class="calibre8">Run this program and take a look at the images it produces:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_01_007.jpg" class="calibre17"/></div><p class="calibre8">
</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec24" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">The <code class="literal">cv::Mat</code> data structure is essentially made up of two parts: a header and a data block. The header contains all of the information associated with the matrix (size, number of channels, data type, and so on). The previous recipe showed you how to access some of the attributes of this structure contained in its header (for example, by using <code class="literal">cols</code>, <code class="literal">rows</code>, or <code class="literal">channels</code>). The data block holds all the pixel values of an image. The header contains a pointer variable that points to this data block; it is the <code class="literal">data</code> attribute. An important property of the <code class="literal">cv::Mat</code> data structure is the fact that the memory block is only copied when explicitly requested for. Indeed, most operations will simply copy the <code class="literal">cv::Mat</code> header such that multiple objects will point to the same data block. This memory management model makes your applications more efficient while avoiding memory leaks, but its consequences need to be understood. The examples of this recipe illustrate this fact.</p><p class="calibre8">By default, the <code class="literal">cv::Mat</code> objects have a zero size when they are created, but you can also specify an initial size as follows:</p><pre class="programlisting">    // create a new image made of 240 rows and 320 columns 
    cv::Mat image1(240,320,CV_8U,100); 
</pre><p class="calibre8">In this case, you also need to specify the type of each matrix element-<code class="literal">CV_8U</code> here, which corresponds to 1-byte pixel (grayscale) images. The <code class="literal">U</code> letter here means it is unsigned. You can also declare signed numbers using <code class="literal">S</code>. For a color image, you would specify three channels (<code class="literal">CV_8UC3</code>). You can also declare integers (signed or unsigned) of size <code class="literal">16</code> and <code class="literal">32</code> (for example, <code class="literal">CV_16SC3</code>). You also have access to 32-bit and 64-bit floating-point numbers (for example, <code class="literal">CV_32F</code>).</p><p class="calibre8">Each element of an image (or a matrix) can be composed of more than one value (for example, the three channels of a color image); therefore, OpenCV has introduced a simple data structure that is used when pixel values are passed to functions. This is the <code class="literal">cv::Scalar</code> structure, which is generally used to hold one or three values. For example, to create a color image initialized with red pixels, write the following code:</p><pre class="programlisting">    // create a red color image 
    // channel order is BGR 
    cv::Mat image2(240,320,CV_8UC3,cv::Scalar(0,0,255)); 
</pre><p class="calibre8">Similarly, the initialization of the gray-level image could have also been done using this structure by writing <code class="literal">cv::Scalar(100)</code>.</p><p class="calibre8">The image size often needs to be passed to functions as well. We have already mentioned that the <code class="literal">cols</code> and <code class="literal">rows</code> attributes can be used to get the dimensions of a <code class="literal">cv::Mat</code> instance. The size information can also be provided through the <code class="literal">cv::Size</code> structure that simply contains the height and width of the matrix. The <code class="literal">size()</code> method allows you to obtain the current matrix size. This is the format that is used in many methods where a matrix size must be specified.</p><p class="calibre8">For example, an image could be created as follows:</p><pre class="programlisting">    // create a non-initialized color image  
    cv::Mat image2(cv::Size(320,240),CV_8UC3); 
</pre><p class="calibre8">The data block of an image can always be allocated or reallocated using the <code class="literal">create</code> method. When an image has already been previously allocated, its old content is deallocated first. For reasons of efficiency, if the new proposed size and type matches the already existing size and type, then no new memory allocation is performed:</p><pre class="programlisting">    // re-allocate a new image 
    // (only if size or type are different) 
    image1.create(200,200,CV_8U); 
</pre><p class="calibre8">When no more references point to a given <code class="literal">cv::Mat</code> object, the allocated memory is automatically released. This is very convenient because it avoids the common memory leak problems often associated with dynamic memory allocation in C++. This is a key mechanism in OpenCV (introduced in version 2) that is accomplished by having the <code class="literal">cv::Mat</code> class implement reference counting and shallow copy. Therefore, when an image is assigned to another one, the image data (that is, the pixels) is not copied; both images will point to the same memory block. This also applies to images either passed or returned by a value. A reference count is kept such that the memory will be released only when all the references to the image are destructed or assigned to another image:</p><pre class="programlisting">    // all these images point to the same data block 
    cv::Mat image4(image3); 
    image1= image3; 
</pre><p class="calibre8">Any transformation applied to one of the preceding images will also affect the other images. If you wish to create a deep copy of the content of an image, use the <code class="literal">copyTo</code> method. In this case, the <code class="literal">create</code> method is called on the destination image. Another method that produces a copy of an image is the <code class="literal">clone</code> method, which creates a new identical image as follows:</p><pre class="programlisting">    // these images are new copies of the source image 
    image3.copyTo(image2); 
    cv::Mat image5= image3.clone(); 
</pre><p class="calibre8">In the example of this recipe, we applied a transformation to <code class="literal">image3</code>. The other images also contain this image; some of them share the same image data, while others hold a copy of this image. Check the displayed images and find out which ones were affected by the <code class="literal">image3</code> transformation.</p><p class="calibre8">If you need to copy an image into another image that does not necessarily have the same data type, use the <code class="literal">convertTo</code> method:</p><pre class="programlisting">    // convert the image into a floating point image [0,1] 
    image1.convertTo(image2,CV_32F,1/255.0,0.0); 
</pre><p class="calibre8">In this example, the source image is copied into a floating-point image. The method includes two optional parameters: a scaling factor and an offset. Note that both the images must, however, have the same number of channels.</p><p class="calibre8">The allocation model for the <code class="literal">cv::Mat</code> objects also allows you to safely write functions (or class methods) that return an image:</p><pre class="programlisting">    cv::Mat function() { 
 
      // create image 
      cv::Mat ima(240,320,CV_8U,cv::Scalar(100)); 
      // return it 
      return ima; 
   } 
</pre><p class="calibre8">We can also call this function from our <code class="literal">main</code> function as follows:</p><pre class="programlisting">      // get a gray-level image 
      cv::Mat gray= function(); 
</pre><p class="calibre8">If we do this, the <code class="literal">gray</code> variable will then hold the image created by the function without extra memory allocation. Indeed, as we explained, only a shallow copy of the image will be transferred from the returned <code class="literal">cv::Mat</code> instance to the gray image. When the <code class="literal">ima</code> local variable goes out of scope, this variable is deallocated. However, since the associated reference counter indicates that its internal image data is being referred to by another instance (that is, the <code class="literal">gray</code> variable), its memory block is not released.</p><p class="calibre8">It's worth noting that in the case of classes, you should be careful and not return image class attributes. Here is an example of an error-prone implementation:</p><pre class="programlisting">    class Test { 
      // image attribute 
      cv::Mat ima; 
      public: 
        // constructor creating a gray-level image 
        Test() : ima(240,320,CV_8U,cv::Scalar(100)) {} 
 
        // method return a class attribute, not a good idea... 
        cv::Mat method() { return ima; } 
    }; 
</pre><p class="calibre8">Here, if a function calls the method of this class, it obtains a shallow copy of the image attributes. If this copy is modified later, the <code class="literal">class</code> attribute will also be surreptitiously modified, which can affect the subsequent behavior of the class (and vice versa). This is a violation of the important principle of encapsulation in object-oriented programming. To avoid these kinds of errors, you should instead return a clone of the attribute.</p></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec25" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">When you are manipulating the <code class="literal">cv::Mat</code> class, you will discover that OpenCV also includes several other related classes. It will be important for you to become familiar with them.</p><div class="calibre1" title="The input and output arrays"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch01lvl3sec4" class="calibre6"/>The input and output arrays</h3></div></div></div><p class="calibre8">If you look at the OpenCV documentation, you will see that many methods and functions accept parameters of the <code class="literal">cv::InputArray</code> type as an input. This type is a simple proxy class introduced to generalize the concept of arrays in OpenCV and thus avoid the duplication of several versions of the same method or function with different input parameter types. It basically means that you can supply either a <code class="literal">cv::Mat</code> object or other compatible types as an argument. Since it is declared as an input array, you have the guarantee that your data structure will not be modified by the function. It is interesting to know that <code class="literal">cv::InputArray</code> can also be constructed from the popular <code class="literal">std::vector</code> class. This means that such objects can be used as input parameters to OpenCV methods and functions (however, never use this class inside your classes and functions). Other compatible types are <code class="literal">cv::Scalar</code> and <code class="literal">cv::Vec</code>; the latter structure will be presented in the next chapter. There is also a <code class="literal">cv::OutputArray</code> proxy class that is used to designate parameters that correspond to an image that is returned by a function or method.</p></div><div class="calibre1" title="Manipulating small matrices"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch01lvl3sec5" class="calibre6"/>Manipulating small matrices</h3></div></div></div><p class="calibre8">When writing your applications, you might have to manipulate small matrices. You can then use the <code class="literal">cv::Matx</code> template class and its subclasses. For example, the following code declares a <code class="literal">3x3</code> matrix of double-precision floating-point numbers and a 3-element vector. These two are then multiplied together:</p><pre class="programlisting">      // a 3x3 matrix of double 
      cv::Matx33d matrix(3.0, 2.0, 1.0, 
                         2.0, 1.0, 3.0, 
                         1.0, 2.0, 3.0); 
      // a 3x1 matrix (a vector) 
      cv::Matx31d vector(5.0, 1.0, 3.0); 
      // multiplication 
      cv::Matx31d result = matrix*vector; 
</pre><p class="calibre8">As you can see, the usual math operators can be applied to these matrices.</p></div></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec26" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The complete OpenCV documentation can be found at <a href="http://docs.opencv.org/">
http://docs.opencv.org/
</a></li><li class="listitem"><a href="ch02.html" title="Chapter 2. Manipulating Pixels">Chapter 2
</a>, <span><em class="calibre16">Manipulating Pixels</em></span>, will show you how to efficiently access and modify the pixel values of an image represented by the <code class="literal">cv::Mat</code> class</li><li class="listitem">The next recipe, <span><em class="calibre16">Defining regions of interest</em></span> , will explain how to define a region of interest inside an image</li></ul></div></div></div>
<div class="calibre1" title="Defining regions of interest"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h1 class="title1"><a id="ch01lvl1sec12" class="calibre6"/>Defining regions of interest</h1></div></div></div><p class="calibre8">Sometimes, a processing function needs to be applied only to a portion of an image. OpenCV incorporates an elegant and simple mechanism to define a subregion in an image and manipulate it as a regular image. This recipe will teach you how to define a region of interest inside an image.</p><div class="calibre1" title="Getting ready"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec27" class="calibre6"/>Getting ready</h2></div></div></div><p class="calibre8">Suppose we want to copy a small image onto a larger one. For example, let's say we want to insert the following logo into our test image:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="Getting ready" src="graphics/image_01_008.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">To do this, a <span><strong class="calibre15">Region Of Interest</strong></span> (<span><strong class="calibre15">ROI</strong></span>) can be defined over which the copy operation can be applied. As we will see, the position of the ROI will determine where the logo will be inserted in the image.</p></div><div class="calibre1" title="How to do it..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec28" class="calibre6"/>How to do it...</h2></div></div></div><p class="calibre8">The first step consists of defining the ROI. Once defined, the ROI can be manipulated as a regular <code class="literal">cv::Mat</code> instance. The key is that the ROI is indeed a <code class="literal">cv::Mat</code> object that points to the same data buffer as its parent image and has a header that specifies the coordinates of the ROI. Inserting the logo is then accomplished as follows:</p><pre class="programlisting">    // define image ROI at image bottom-right 
    cv::Mat imageROI(image,  
              cv::Rect(image.cols-logo.cols,   // ROI coordinates 
                       image.rows-logo.rows, 
                       logo.cols,logo.rows));  // ROI size 
 
    // insert logo 
    logo.copyTo(imageROI); 
</pre><p class="calibre8">Here, <code class="literal">image</code> is the destination image and <code class="literal">logo</code> is the logo image (of a smaller size). The following image is then obtained by executing the previous code:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_01_009.jpg" class="calibre17"/></div><p class="calibre8">
</p></div><div class="calibre1" title="How it works..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec29" class="calibre6"/>How it works...</h2></div></div></div><p class="calibre8">One way to define an ROI is to use a <code class="literal">cv::Rect</code> instance. As the name indicates, it describes a rectangular region by specifying the position of the upper-left corner (the first two parameters of the constructor) and the size of the rectangle (the width and height are given in the last two parameters). In our example, we used the size of the image and the size of the logo in order to determine the position where the logo would cover the bottom-right corner of the image. Obviously, the ROI should always be completely inside the parent image.</p><p class="calibre8">The ROI can also be described using row and column ranges. A range is a continuous sequence from a start index to an end index (excluding both). The <code class="literal">cv::Range</code> structure is used to represent this concept. Therefore, an ROI can be defined from two ranges; in our example, the ROI could have been equivalently defined as follows:</p><pre class="programlisting">    imageROI= image(cv::Range(image.rows-logo.rows,image.rows),  
                    cv::Range(image.cols-logo.cols,image.cols)); 
</pre><p class="calibre8">In this case, the <code class="literal">operator()</code> function of <code class="literal">cv ::Mat</code> returns another <code class="literal">cv::Mat</code> instance that can then be used in subsequent calls. Any transformation of the ROI will affect the original image in the corresponding area because the image and the ROI share the same image data. Since the definition of an ROI does not include the copying of data, it is executed in a constant amount of time, no matter the size of the ROI.</p><p class="calibre8">If you want to define an ROI made up of some lines of an image, the following call can be used:</p><pre class="programlisting">    cv::Mat imageROI= image.rowRange(start,end); 
</pre><p class="calibre8">Similarly, for an ROI made up of some image columns, the following can be used:</p><pre class="programlisting">    cv::Mat imageROI= image.colRange(start,end); 
</pre></div><div class="calibre1" title="There's more..."><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec30" class="calibre6"/>There's more...</h2></div></div></div><p class="calibre8">The OpenCV methods and functions include many optional parameters that are not discussed in the recipes of this book. When you wish to use a function for the first time, you should always take the time to look at the documentation to learn more about the possible options that the function offers. One very common option is the possibility to define image masks.</p><div class="calibre1" title="Using image masks"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h3 class="title3"><a id="ch01lvl3sec6" class="calibre6"/>Using image masks</h3></div></div></div><p class="calibre8">Some OpenCV operations allow you to define a mask that will limit the applicability of a given function or method, which is normally supposed to operate on all the image pixels. A mask is an 8-bit image that should be nonzero at all locations where you want an operation to be applied. At the pixel locations that correspond to the zero values of the mask, the image is untouched. For example, the <code class="literal">copyTo</code> method can be called with a mask. We can use it here to copy only the white portion of the logo shown previously, as follows:</p><pre class="programlisting">    // define image ROI at image bottom-right 
    imageROI= image(cv::Rect(image.cols-logo.cols, 
                             image.rows-logo.rows, 
                             logo.cols,logo.rows)); 
    // use the logo as a mask (must be gray-level) 
    cv::Mat mask(logo); 
 
    // insert by copying only at locations of non-zero mask 
    logo.copyTo(imageROI,mask); 
</pre><p class="calibre8">The following image is obtained by executing the previous code:</p><p class="calibre8">
</p><div class="mediaobject"><img alt="Using image masks" src="graphics/image_01_010.jpg" class="calibre17"/></div><p class="calibre8">
</p><p class="calibre8">The background of our logo was black (therefore, it had the value <code class="literal">0</code>); this is why it was easy to use it as both the copied image and the mask. Of course, you can define the mask of your choice in your application; most OpenCV pixel-based operations give you the opportunity to use masks.</p></div></div><div class="calibre1" title="See also"><div class="calibre1"><div class="calibre1"><div class="calibre1"><h2 class="title2"><a id="ch01lvl2sec31" class="calibre6"/>See also</h2></div></div></div><div class="calibre1"><ul class="itemizedlist"><li class="listitem">The <code class="literal">row</code> and <code class="literal">col</code> methods will be used in the <span><em class="calibre16">Scanning an image with neighbor access</em></span> recipe of <a href="ch02.html" title="Chapter 2. Manipulating Pixels">
Chapter 2
</a>, <span><em class="calibre16">Manipulating Pixels</em></span>. These are a special case of the <code class="literal">rowRange</code> and <code class="literal">colRange</code> methods in which the start and end indexes are equal in order to define a single-line or single-column ROI.</li></ul></div></div></div></body></html>