- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the PID Algorithm to Follow Walls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built a robot with multiple sensors and used distance sensors in [*Chapter
    8*](B18001_08.xhtml#_idTextAnchor166), *Sensing Distances to Detect Objects with
    Pico*. We can use smarter algorithms with these sensors to make smoother behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will investigate the PID algorithm, building its stages
    into something that will follow objects, then turning that into something that
    will follow a wall. We will use our new ability to graph over Bluetooth to tune
    the settings and get a smooth result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the PID algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a PID to follow a wall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PID tuning – using graphs to tune the PID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following items for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot and code from [*Chapter 9*](B18001_09.xhtml#_idTextAnchor189), *Teleoperating
    Raspberry Pi Pico Robot with* *Bluetooth LE*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An open space with room to move, and objects suitable for following
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Android/iOS device with the Bluefruit app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hand screwdriver with a 2 mm bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital calipers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pencil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-10](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-10).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the PID algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce the different parts of the PID algorithm
    while building on what you have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: Control and feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Controlling robot systems generally depends on feedback loops like the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Control and feedback loop ](img/Figure_10.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Control and feedback loop
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows data from the sensors going into a control algorithm.
    The algorithm controls the motor as its output. The motor will cause the robot
    to move. This movement leads to a feedback loop as the sensor reading changes
    and goes through the cycle again. This concept is known as **closed-loop control**.
  prefs: []
  type: TYPE_NORMAL
- en: This closed-loop lets the robot interact with the real world, adjusting its
    behavior to produce the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: We built a simple system like this for our distance sensors. We’ll look more
    closely at that system next.
  prefs: []
  type: TYPE_NORMAL
- en: Bang-bang control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples provided in [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166),
    *Sensing Distances to Detect Objects with Pico*, the system compared the distance
    sensors on our robot against a threshold. For example, look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Bang-bang motor control ](img/Figure_10.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Bang-bang motor control
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.2* summarizes **bang-bang control**. This control system has two
    modes. If the actual measurement is above the expected value and too far away,
    it will drive forward; otherwise, it assumes that it is below the value and too
    close and will drive backward. It will always drive in one of the directions and
    at a fixed motor power. Controlling with only a fixed power is known as **constant
    correction**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is simple and suitable in some situations, but occasionally, something
    smoother is needed. What if we wanted the robot’s motor power to change depending
    on how far away it is from the object? We’ll need to calculate an error value,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Calculating an error value ](img/Figure_10.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Calculating an error value
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.3* shows how we calculate the error value. By subtracting the
    actual value from the expected, we will get the error. This error will change
    in magnitude, depending on how different things are, and change in direction,
    depending on which side of the expected measurement the actual measurement falls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we multiply this error by some value, this could be turned into a motor
    speed, such that a higher magnitude error will lead to a larger motor movement.
    This process will form the feedback control loop shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – A proportional feedback loop ](img/Figure_10.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – A proportional feedback loop
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.4* builds upon *Figure 10**.1*, feeding an error value through
    a multiplier (or gain) to calculate the motor speed, which moves the robot. Robot
    movement feedback changes the sensor reading. With the right gain value, this
    robot will slow down as it approaches the object.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying the error value to control the output like this is known as **proportional
    control**, which is one part of the system we are building. The amount by which
    we multiply the error is known as the **proportional gain**.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I think we are ready to write the code for this.
  prefs: []
  type: TYPE_NORMAL
- en: Distance sensing with proportional control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll write code to approach an object and maintain the expected
    distance from the object. Create a folder on the host named `proportional-distance-control`.
    We’ll copy the content of this folder into the top directory on the Pico. We can
    also copy the robot and `pio_encoder` files there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `code.py` file, starting with imports and enabling the UART:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add our proportional controller as a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code lets us make proportional controller (`PController`) objects with
    a proportional gain, `kp`. We can call the `calculate` method with an error value
    to get the control value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set up a sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We make a set point of 10 cm for our expected distance. Then, we have our `distance_controller`,
    which is using the `PController` object.
  prefs: []
  type: TYPE_NORMAL
- en: When our robot is further away, we need to drive forward, so we need to use
    a negative proportional gain. The motor speeds are between -1 and 1, so -0.1 will
    reduce the distance by a tenth and negate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main loop will only check the `PController` when there’s a new distance
    reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this with the set point to calculate the error and feed it into
    the proportional controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'While we’re here, we can send the numbers to the UART (so that we can plot
    them). We have a speed from the error. Now, we can send this speed to both motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must reset the sensor for another reading and delay it a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Send this code to the robot. If you place an object in front of the robot, it
    will find and hold a position about 10 cm from the object. You should also be
    able to plot the output.
  prefs: []
  type: TYPE_NORMAL
- en: The motors here may be beeping a lot; this is not good for them and will make
    them hot. We can use code to establish a **dead zone**, where we expect the control
    output to be too small for the motors to respond and turn them off instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the speed calculation to stop the beeping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code uses `abs` to get the magnitude of the speed only. If the magnitude
    is below 0.3, it sends a `0` instead. I found `0.3` experimentally, but this may
    be different on your robot.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you should test this on the robot and check the next section
    if this behavior did not try to find the distance to the object.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some solutions to try if you aren’t getting the follow behavior
    to work:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check the distance sensor functionality using the [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166)
    code. Then, verify the sensor and motor connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the robot is driving the wrong way, reverse the proportional constant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a problem where this robot may get close to the right place but leave
    a gap for small distances. As a result, it might not generate a speed large enough
    to move the motors. In the next section, we’ll see why.
  prefs: []
  type: TYPE_NORMAL
- en: Using the integral to handle small distances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following graph shows a small error remaining after activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Small remaining error ](img/Figure_10.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Small remaining error
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows a graph of the error and motor output versus time.
    The error line varies by up to 10 units. The motor graph is more flat. This line
    is between 0 and 1 and in the opposite direction, as expected from the proportional
    experiment. The graph is divided into two portions. Portion A shows the robot
    moving as we move an object closer and further away, with the motor responding.
    In portion B, we gradually move the object, creating a small error of -1\. This
    small error results in a speed of 0.1, which is insufficient to move.
  prefs: []
  type: TYPE_NORMAL
- en: What we have is a **steady-state error**. The system has not converged on the
    set point and will not act further to reduce the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This situation is where the integral element is useful. The **integral** is
    equivalent to an area under a graph. Look at the following graph for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Plotting the integral ](img/Figure_10.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Plotting the integral
  prefs: []
  type: TYPE_NORMAL
- en: This graph has two elements. The bars represent the error value from the previous
    graph, approximated as discrete time steps. Then, there’s the thick line over
    this, which represents the integral. While the graph varies, the integral varies
    perhaps a little later. However, when it reaches a steady state, the graph starts
    to pull downwards continuously.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take this and multiply it by another small constant, we can cause the
    motors to move a little to iron out a steady-state error. We call this the `ki`.
    The following diagram shows the control system with the integral term:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – The feedback loop with the integral ](img/Figure_10.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – The feedback loop with the integral
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the feedback loop control system with the integral
    added – this box shows *I * ki*, the integral multiplied by an integral gain.
    It feeds into the motor speed, which is added to the proportional output. The
    integral is given the same error term as the proportional element.
  prefs: []
  type: TYPE_NORMAL
- en: The integral will store the area of the error graph seen until this point. This
    would be the area under a graph. How do we calculate the area? We can take each
    error and multiply it by the time interval during which it was produced. Adding
    this to a running total represents a good approximation of the area.
  prefs: []
  type: TYPE_NORMAL
- en: The following code extends the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `PController` code so that it’s a `PIController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added `ki` as an integral gain to scale our integral.
    We also store an integral total, starting at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Prefixing gain constants like these with *k* is due to them being treated as
    *constants* by the PID algorithm, but the outer code can tune these. So, mathematically,
    this is a constant, but not a constant in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must change the `calculate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`calculate` now adds the error to the integral, which means the integral will
    continue moving in the error direction. However, we will multiply this by the
    elapsed time (or delta time, `dt`), so that a longer interval between measurements
    will result in a larger area. The last line multiplies the current integral by
    the integral gain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need to set the integral constant when we create the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The values of `–0.19` and `–0.005` work for my robot. We will learn how to tune
    these later in the chapter. The integral constant should be negative in this case
    and small. Larger values will cause overshoots, and the system will go back and
    forth (oscillate).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now alter the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted changes start with the time delta calculations. We keep a previous
    time (`prev_time`) so that we can subtract this from `current_time` later and
    feed this time difference into the controller with the error. Next, we store `current_time`
    in `prev_time` so that we are ready for the next loop. The `time.monotonic` function
    provides a time in seconds with fractions, guaranteeing that subsequent calls
    cannot return a lower value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also send the current integral value to the UART to plot it. Send this code
    to the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Oscillation versus smaller integral ](img/Figure_10.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Oscillation versus smaller integral
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10**.8 (a)* the screenshot shows an error with a large integral gain.
    This rise makes the motors move and carry on while the system overshoots, until
    the integral flips the other way - this causes oscillation. In *Figure 10**.8
    (b)* the integral gain is much lower, so the integral must reach a higher value
    before it creates a change. The motors respond to the proportional change first,
    but the integral makes a slight adjustment later. This setting may still oscillate
    a tiny amount, but the oscillations will be slow and subtle.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the robot corrects the steady state and the error reaches zero,
    this doesn’t reduce the integral.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Stop the code (or robot) if the wheels/motors are not moving the robot forward,
    and restart the code when the wheels are in contact with the floor or motors are
    turned on (they are on battery power only). Otherwise, the system can build up
    a large integral and will ram the next object placed in front of it. This problem
    is known as **integral wind-up** and can be a big problem if you do not account
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Some overshoot here is inevitable, but the system is reacting to steady-state
    errors. This PI controller will work, but if you move the target object quickly,
    you may still be able to induce oscillation. How can we dampen that? We’ll see
    how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with oscillations using the derivative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oscillations are made due to sudden state changes, creating a large reacting
    output, which can cause a large change of state in the opposite direction. This
    may repeat on either side of the set point. The state change is equivalent to
    a slope on a graph at any point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph shows a varying value, with the slopes marked at a few
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Slopes on a graph ](img/Figure_10.09_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Slopes on a graph
  prefs: []
  type: TYPE_NORMAL
- en: The preceding graph shows an error PID response settling. Along the graph are
    dots, with dashed lines showing the slope. The derivative represents this slope
    at any point.
  prefs: []
  type: TYPE_NORMAL
- en: The essential factor is that when there is a steep change in the error, there
    is a steeper slope. This slope value is the **derivative**. It represents the
    rate of change in our system. Using this value with a gain can reduce overshoot,
    dampening the system. So, we could add this along with the PI components and dampen
    the movement a little.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we do that, there is another issue: the output from the distance
    sensors is a little noisy. The following zoomed-in view shows noise on the sensor
    when the robot is not moving:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Noise from the sensor ](img/Figure_10.10_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Noise from the sensor
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot is enlarged to show the sensor data noise. One of the
    lines is frequently going above or below the line. This noise is slight but makes
    many fast changes in the slope.
  prefs: []
  type: TYPE_NORMAL
- en: Using the derivative directly with this noise may cause our robot to produce
    large movements. To reduce this, we will use a **low pass filter** in front of
    the integral. This only allows sustained error movements in, filtering out the
    constant jiggle of noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this as a feedback control diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Feedback flow for the PID controller ](img/Figure_10.11_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Feedback flow for the PID controller
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.11* extends *Figure 10**.7* by adding two additional blocks. First,
    the error splits through a block labeled LPF – this is a low pass filter, with
    a stylized frequency graph showing how this tails off for higher frequencies.
    The LPF block feeds into the next block – the derivative multiplied by a `kd`
    derivative gain. This block has a stylized graph showing the slope lines. The
    derivative output is then added to the other PI outputs to make the motor speed
    signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen how this operates, let’s modify the code, starting with
    the PID class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we add two additional construction parameters to the `PIDController`
    class – a derivative gain, `kd`, and a derivative filter gain. We also store a
    previous error to calculate the difference from the current error. The `calculate`
    function also changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We need the difference between the current error and the previous error. We
    multiply this difference by the filter gain, and add this onto the previous error.
    This means that the error changes by a smoothed out amount and sets us up for
    the next calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The next line divides this difference by the change in time, to get the rate
    of change. We store this in `self.derivative` so that we can graph this term later.
    Finally, we multiply `self.derivative` by the `d` gain (`kd`) and add this to
    the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The PID controller is now complete. We can make this reusable by moving the
    `PIDController` class into a `pid_controller.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `code.py` file can use `pid_controller` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted parts of the code show how this changed from the previous `code.py`
    example. First, we imported the `PIDController` class. Then, we swapped our use
    of `PIController` for `PIDController`. PID tuning parameters are tuned as we expand
    on this code. Adding additional terms, such as the derivative, will make tuning
    the others necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We send the error and time difference into the controller calculation to get
    the speed, then send the derivative to the UART to see what our robot is doing
    and tune the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve built a PID controller and used it to keep a certain amount
    of distance from an object. We’ll make this into a more dynamic example in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using PID to follow a wall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Driving along a wall using the PID algorithm requires a little more coordination.
    Let’s visualize the problem with a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – The robot following a wall ](img/Figure_10.12_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – The robot following a wall
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.12* shows how our robot will follow a wall. First, the robot drives
    forward in the direction shown by the solid line with an arrow. We have turned
    the sensor out so that it can detect the wall in its cone (these distance sensors
    cover around 20 degrees). Based on the return of a close object (shown as a dashed
    line), the robot will adjust its heading to try and keep a constant distance.
    When the robot faces the wall, it will curve outward, and it may overshoot, but
    also, there is a step change in the wall, so the robot will adjust its path and
    straighten up.'
  prefs: []
  type: TYPE_NORMAL
- en: We have a few issues. First, we have put the motors a little forward, and turning
    the sensor with the current placement would have the wheel in the path of the
    sensor, so we’ll need to move them back. Then, we’ll need to make that 90-degree
    sensor turn. After, we’ll need to use the PID to determine how much to change
    the robot’s heading, a deflection, as the robot drives forward.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by making some changes to move the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the sensor’s placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to make some changes to our CAD sketches, then use a drawing to
    drill some holes. Note that with the front of the robot facing down in the CAD
    sketches, the left-hand side of the CAD sketch is for the robot’s right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following FreeCAD screenshots show how to make the CAD changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – FreeCAD sketches for turning the sensor sideways ](img/Figure_10.13_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – FreeCAD sketches for turning the sensor sideways
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand screenshot of *Figure 10**.13* shows how we move the motor back
    in the `UpperParts` sketch. First, delete the horizontal constraint between the
    bottom corner of the motor (shown on the left) and the breadboard. Then, add an
    18 mm vertical dimension between the same two points. Moving the motor back 18
    mm gives ample space for the sensor, but it will also mean we can reuse one of
    the existing holes since the distance between them is 18 mm. In addition, the
    two motors have symmetry constraints so that they will move together. Now, you
    can close this sketch.
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand side of *Figure 10**.13* is a screenshot of the sketch for an
    additional front sensor hole at 90 degrees. Import the existing distance sensor
    holes as external geometry. Then, use construction lines to constrain the distance
    between this hole and the top outer hole so that it is equal to the distance between
    the initial distance sensor holes. Add an equals constraint on the circles and
    a perpendicular constraint between the lines. You can make a similar circle on
    the other side, although we will only use one sensor for this demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the CAD drawing and parts fitted in new positions
    on the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The drawing and result of this robot change ](img/Figure_10.14_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The drawing and result of this robot change
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side of the preceding figure shows the drawing. I’ve marked the
    new holes, using the existing ones as a reference. You will need to detach the
    motors and sensors to do this – unbolt them but leave the wiring connected and
    put them carefully to one side while doing this. After removing the motors, attach
    one side of the motor bracket and use the hole on the other side of the bracket
    to mark the new hole.
  prefs: []
  type: TYPE_NORMAL
- en: With the distance sensor, remove the inner bolt, then turn it to face out 90
    degrees. You can then use the inner bolt hole to mark where to drill.
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand side of the preceding figure shows the motor and sensor moved
    into position. Ensure that the connections are still correct.
  prefs: []
  type: TYPE_NORMAL
- en: This robot is ready for us to write wall-following code on it. Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: Wall-following code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wall following is an extension of the code we’ve already been working on, with
    a few key differences. First, our robot will drive at a constant speed, but depending
    on the sensor feedback, it will steer closer to/farther from the wall. It can
    do this by adding a PID output to the speed of one side and subtracting it from
    another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by taking a copy of the previous code example. We’ll make changes to
    `code.py`. The imports and setup stay the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, along with the other settings, we must add a base speed for the robot
    to drive. The distance set point should also be further out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have set up the PID here so that you can tweak its settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main loop gets the sensor data and error in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we calculate the PID, we now store it in `deflection`, describing how
    fast we will turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We write this to the UART so that we can plot and debug it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The code uses this deflection by adding it to the right motor speed and subtracting
    it from the left. This deflection should pull us toward the set point, a distance
    from the wall, while driving forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish by resetting the sensor and sleeping a bit before looping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can send this to the robot and start it near a wall, and it may try to follow
    it. I’ve found a few boxes in the middle of the room good as it can drive around
    them; however, it will likely struggle with anything concave.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this may be unstable, so we’ll need to tune this PID. However,
    even if unstable, it should try to follow the wall, even if it collides.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try these steps if the robot isn’t following or starting:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check the distance sensor wiring; now that you’ve moved it, the wires
    may have been dislodged. [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166), *Sensing
    Distances to Detect Objects with Pico*, contains guides on sensor wiring if you
    need to check this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure you have a fresh set of batteries – this won’t work well on low batteries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the robot is spinning, put it closer to the wall, and if it is reacting too
    hard, bring down the P value. We’ll tune this more shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should now have a robot that is kind of following the wall but may be quite
    unstable or crashing somewhat. To make this work well, we’ll need to tune the
    PID.
  prefs: []
  type: TYPE_NORMAL
- en: PID tuning – using graphs to tune the PID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PID algorithm is great for responding to sensor input, adjusting for constant
    errors, and dampening out overcompensation with the derivative. The only problem
    is that getting these three values right is tricky. How you tune a PID depends
    on the system. In our case, for wall following, much of this will be on how the
    robot feels in the situation. This method works for small robots, but there are
    formal methods that require a mathematical model of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the situation, we may only use one constant, but for this, we’ll
    try to use all three. It’s also a good practice to change only one gain constant
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We already have graphing for our system on the phone. While we are starting,
    we’ll only show the error and response; we can add other components as needed.
    The derivative and integral components can dwarf the proportional component, and
    the Bluefruit app does not allow plots with different scales on the same graph.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to add some controls other than graphing. Otherwise, you’ll
    be plugging the robot in to reprogram a lot! So, let’s start with some basic controls.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling motor speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we’ll need the ability to start and stop our motors. Currently, our system
    starts with motors live and running. Turning the motors off or slowing things
    down will make tuning far less frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: 'The motor speeds are down to the PWM system. The current PWM settings on our
    robot have a frequency of 500 Hz. This is a little high for DC motors, which means
    they can stall (stop) at low speeds. So, we’ll reduce the motor PWM frequency.
    In `robot.py`, make the highlighted changes on the matching lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In `code.py`, we will modify our system to allow motors to be turned off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll want to add UART control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`if` checks for waiting commands; if we have one, we read in a line of input
    and decode it. `strip` removes the line end character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start checking for commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code means we can send the robot an instruction such as `M0.7` via the
    Bluefruit UART app, and the straight motor speed will be 0.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to be able to activate/deactivate the motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can stop or start the motors by sending the `G` instruction to the robot.
    This handler toggles the `motors_active` variable. It will always stop the motors.
    The next loop cycle will turn them on only if it’s active, ensuring they stop.
  prefs: []
  type: TYPE_NORMAL
- en: Finally this resets the integral to avoid integral wind up while the motors
    are not running. Having the integral running while the robot cannot act to counter
    it is known as **integral wind-up** and can cause big problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this with the existing proportional and send it to the robot. You
    should be able to test the instructions from the UART panel in the Bluefruit app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`G` -> Enable/disable robot motors: think Go/Stop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M<speed>` -> Set the motor speed: this should be between 0.3 and 1.0\. It
    will likely not move under 0.3\. This will behave incorrectly at negative speeds,
    and the motor code truncates values above 1.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have control of the robot, let’s figure out how to tweak the proportional
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The proportional component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proportional gain constant, `pk`, is the starting point and is usually dominant
    in a system. Multiplying the error by `pk` will create the most immediate reaction
    to a sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by adding code to change the proportional constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code checks for the input, `P<proportional gain>`, and uses it in the
    same way as the motor speed. When you type a value, the proportional constant
    is updated. So, let’s review the state of the robot by adding an instruction to
    inspect these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This handler for `?` will print the PID constants and speed settings. The `.3f`
    annotation encodes the value as a number with 3 decimal places. Because the robot
    usually outputs the graph values via UART, we pause for 3 seconds here. Do not
    use this command with the motors active.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we send this to the robot, we have two additional control abilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`P0.045` -> Set the proportional gain value to `0.045`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?` -> Print the current state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Send this to the robot. Before we engage the motors (`G`), let’s consider a
    good proportional value. For this example, we expect an error between 5 and -5,
    giving us a range of 10 cm. Corners will go beyond this and set the turning at
    full (saturation, maximum value). With a speed of 0.7, to turn back, we would
    need an output of -1.4\. We can divide 1.4 by 10, giving us a starting guess of
    0.14\. Send `P0.14` to set this and `G` to start the robot moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'This setting is responding but has some oscillation. Use `G` to stop it. We
    will use trial and error here by halving the P value and trying again. We can
    test this and use two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If the robot is oscillating too much, divide the value by 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the robot responds too slowly, multiply by 1.5 (the value between here and
    the previous one is high).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method lets us home in on a value. When you find values that you like,
    you can put them back into `code.py` to keep for later. Use `?` to see the last
    `P` setting you had.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how this looks on the graph output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Proportional response ](img/Figure_10.15_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Proportional response
  prefs: []
  type: TYPE_NORMAL
- en: The preceding phone screenshot shows a graph with only a proportional response.
    The X axis specifies the time in seconds. The Y axis is the distance in cm for
    the error, but more arbitrary for the output value. The error has a higher range
    in tens of cms. The robot is driving around some obstacles. The huge swings are
    when it reaches a corner and drives around it. The blue line shows the PID output
    and the deflection. The deflection scale is usually below 1, but the large swings
    will take it above that. Motor speeds are clamped between -1.0 and 1.0, so those
    large corners will saturate the motors, making the robot turn on the spot.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a high proportional gain will make a system respond quickly, but
    it will overshoot and may even start to oscillate. Too low, and it will not respond
    fast enough.
  prefs: []
  type: TYPE_NORMAL
- en: A proportional-only system can oversteer when there are larger changes. We want
    to damp this out. We’ll adjust the *D* component to deal with this.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the derivative gain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The derivative component allows the robot to deal with large changes in the
    error and react by either damping or pulling harder if there’s a sudden change,
    such as oversteering, running out of wall (a corner), or finding a step change
    in the wall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our code to make it easier to work with the derivative. In `code.py`,
    add `,{distance_controller.derivative}` to the `uart.write` line after we calculate
    the deflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to control the derivative. Add the following after the `P` command
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this sets a simple pattern, the same as `P`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start this with half the P value, `D0.035`, which results in fewer
    collisions with occasional bouncing. The following screenshot shows the robot
    going around boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Initial derivative graph ](img/Figure_10.16_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Initial derivative graph
  prefs: []
  type: TYPE_NORMAL
- en: The preceding graph shows the derivative in orange, overlaid on the error in
    red, and the output in blue. Note that the derivative spikes are very large but
    can sometimes be the opposite sign of the error allowing it to dampen changes.
    The largest spikes are still walls. Between 10 and 15 seconds, the derivative
    dampens the proportional output.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sudden distance increase, such as the end of a wall, can cause strong oscillation,
    as shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Strong derivative oscillations ](img/Figure_10.17_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Strong derivative oscillations
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, at around 42 seconds, the robot encounters a concave
    step. That step caused the derivative to overshoot, pushing the robot right out.
    However, this put the sensor past the obstacle and detected a long-range distance,
    going rapidly from too close to too far. The derivative swings strongly back the
    other way – time to stop with `G`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can roughly half the value again to `0.017` for another attempt, but it
    will still have the same issue. We need to be more aggressive with reducing `D`
    than we were with `P`. We can divide the proportional constant by 10 (`0.0035`)
    for a more stable robot. The resulting plot looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – The tuned derivative graph ](img/Figure_10.18_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – The tuned derivative graph
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows a graph with the same properties as *Figure 10**.17*
    but using a `0.0035` setting. While the corners still show up as large spikes,
    the blue output graph is now calmer, with the derivative dampening the output.
    The robot will now be driving quite smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: We may need a slightly different scenario to tune the integral.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning the integral
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an environment with many step changes, such as driving around boxes in a
    room, the integral will not play as much of a part. Not every problem requires
    all three parts of the PID, and in this case, the integral may not be particularly
    suitable. Let’s set this nice and slow and find a long straight wall. I had to
    use a garden path for this (and change some values to suit).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the integral control and output to the `code.py` file first. The output
    is swapping `{distance_controller.derivative}` for `{distance_controller.integral}`
    in the output line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add this to the control handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will accept a command such as `I0.001` to set the integral. This is also
    a good starting value. We now have a comprehensive control system.
  prefs: []
  type: TYPE_NORMAL
- en: Send `M0.35` to reduce the speed. We can send half the `P` and `D` values to
    match, using `?` to see what they were. Send `I0.001` and then `G` to start the
    robot against a long straight wall.
  prefs: []
  type: TYPE_NORMAL
- en: You should see some large adjustments as the `P` and `D` terms settle; then,
    the `I` term will settle more slowly. Observe the graph while driving.
  prefs: []
  type: TYPE_NORMAL
- en: For this term, the strategy I use is settling on a small value and slowly incrementing
    it if the reaction to a constant error is too slow. Like the other terms, making
    this too high will lead to instability. If the starting point of `0.001` pushes
    the system into instability, divide it by 10 and slowly increment that.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a strategy to tune PID values on a robot, along with a control
    system to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Closing notes on tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuning a PID will take time. Algorithms such as Ziegler-Nichols can be used
    to solve this with mathematical modeling and will work in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that changes in the system response, such as its turning
    circle, will alter things. For example, driving a robot on a carpet causes drag
    on the wheels, making turning slower. If a PID was tuned to work well on carpet,
    putting the same robot on wooden flooring may cause it to oversteer as its steering
    effort results in larger changes. Tune a PID for a particular behavior to the
    environment where you expect it to be operating.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PID controller is a great way to build robot behavior that adjusts to sensor
    input. In this chapter, you learned what a PID controller and its components are,
    including where a low-pass filter makes it behave better.
  prefs: []
  type: TYPE_NORMAL
- en: The PID controller allows for dynamic responses but requires a lot of tuning
    to get it right. You’ve seen how to add a wireless control method, which is essential
    for tuning a PID. You’ve also observed the graphs of PID systems, understanding
    how they relate to their operations and tuning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking our PID controller and using it with
    encoders to drive in straight lines.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These exercises will deepen your understanding of the topics discussed in this
    chapter and make the robot code better:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhance the settings code so that the set point can be adjusted in the same
    way. `S<set point>` is probably a good idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the command handlers for setting PID values to stop the motors and reset
    the integral when these values change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try adapting the control code back to the distance control app used earlier
    in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try the robot wall-follow when driving on a completely different surface and
    adjust the PID values to get a smooth wall following.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These study aids will let you read on and dive deeper into the PID algorithm
    and its quirks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Christopher Lam on YouTube has an excellent control theory video course: [https://www.youtube.com/playlist?list=PLxdnSsBqCrrF9KOQRB9ByfB0EUMwnLO9o](https://www.youtube.com/playlist?list=PLxdnSsBqCrrF9KOQRB9ByfB0EUMwnLO9o).
    This uses MATLAB and goes into detail about control systems such as PID, tuning
    them, problems with them, modeling them, and analyzing them. There are at least
    30 hours of content that takes a very mathematical approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a deeper dive into PID control systems, consider *PID-based Practical Digital
    Control with Raspberry Pi and Arduino Uno* from Elektor Electronics. This book
    discusses control theory, transform functions, and PID tuning, while providing
    code and practical examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PID Control Fundamentals*, by Jens Graf, published via CreateSpace, is a comprehensive
    look at PID control systems. This provides more detail on each of the components
    and building PI, PD, and full PID algorithm control systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
