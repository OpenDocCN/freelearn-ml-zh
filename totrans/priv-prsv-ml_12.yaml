- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Homomorphic Encryption and Secure Multiparty Computation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Homomorphic encryption is a cryptographic technique that allows computation
    on encrypted data without decrypting it. It has the potential to revolutionize
    data privacy and security, enabling the secure computation of sensitive data without
    revealing the data itself. In this chapter, you will learn about homomorphic encryption
    and secure multiparty computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption, anonymization, and de-identification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homomorphic encryption and the mathematics behind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source Python frameworks for homomorphic encryption and Paillier schemes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning using homomorphic encryption (HE)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Federated learning with **Partially homomorphic** **encryption** **PHE**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of homomorphic encryption
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure Multiparty Computation** (**SMC**) and its use cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A use case implementation using the **Private Set Interaction** (**PSI**) SMC
    technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A high-level overview of zero-knowledge proofs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption, anonymization, and de-identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption, anonymization, and de-identification are all techniques used to
    protect sensitive data, but they differ in their approach and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption**'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption is the process of transforming data into a form that can only be
    read by authorized parties with access to a decryption key. The purpose of encryption
    is to ensure the confidentiality and integrity of data. Encrypted data remains
    readable by those who have the appropriate decryption key, but it is unintelligible
    to anyone who intercepts it without the key. Encryption is widely used to protect
    sensitive data in transit and data at rest, such as credit card numbers, passwords,
    and personally identifiable information.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s some simple Python code to implement basic encryption
  prefs: []
  type: TYPE_NORMAL
- en: '*Source* *code: Encryption_Example.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: Develop a function to encrypt the given text using a basic encryption algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two arguments: `text`, which is the plaintext to be encrypted,
    and `shift`, which is the number of positions by which each letter in the plaintext
    should be shifted in the alphabet. The function returns the encrypted text.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you call simple_encryption (“Privacy Preserved Machine Learning
    “, 5), then the function will return the string “Uwnafhd Uwjxjwaji Rfhmnsj Qjfwsnsl”,
    which is the encrypted version of “Privacy Preserved Machine Learning” with a
    shift of 5.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many popular encryption algorithms used today for securing data and
    communications. The most common are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Encryption Standard** (**AES**): A symmetric-key encryption algorithm
    widely used for securing data in transit and at rest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rivest-Shamir-Adleman** (**RSA**): An asymmetric-key encryption algorithm
    used for secure communication and digital signatures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Encryption Standard** (**DES**): A symmetric-key encryption algorithm
    widely used in the past, but now considered less secure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blowfish**: A symmetric-key encryption algorithm designed for high-speed
    and efficient encryption of large amounts of data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twofish**: A symmetric-key encryption algorithm that is a successor to Blowfish,
    designed for higher security and flexibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ChaCha20**: A symmetric-key encryption algorithm that is becoming increasingly
    popular due to its high security and performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elliptic Curve Cryptography** (**ECC**): An asymmetric-key encryption algorithm
    that uses elliptic curves instead of prime numbers, resulting in smaller key sizes
    and faster performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few of the most popular encryption algorithms. There are many
    others, and new ones are constantly being developed as computing power and security
    needs evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption example using AES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Source* *code: Encryption_Example.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Develop a function to encrypt the given text using the AES encryption algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example program, we used the PyCrypto library to implement AES encryption
    with **cipher-block chaining** (**CBC**) mode.
  prefs: []
  type: TYPE_NORMAL
- en: The `aes_encrypt` function takes a 128-bit key and plaintext message as the
    input and returns the encrypted ciphertext. The `aes_decrypt` function takes a
    key and ciphertext as input and returns the decrypted plaintext message. We used
    the PKCS7 padding scheme to pad the plaintext to a multiple of the block size
    and to remove the padding after decryption. It generates a random initialization
    vector for each encryption operation to add an additional layer of security.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Encryption doesn’t provide anonymity or de-identification of data. Encrypted
    data may contain sensitive information that could be used to identify individuals.
    Encryption only protects data while it is being transmitted (data in motion) or
    stored (data at rest, i.e., in a persistent store), but it doesn’t control who
    has access to it or how it is used once decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Data anonymization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anonymization is the process of removing identifiable information from data
    so that individuals cannot be identified. The main purpose of anonymization is
    to protect the privacy of individuals while still allowing the data to be used
    for analysis or research use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some example Python code for data anonymization:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Source* *code: Example_Data_annomization.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used Python’s `hashlib` library to hash the name and
    email fields of each record in the dataset using a random salt value. The hashed
    values are then stored in place of the original values. This technique can be
    used to protect the privacy of sensitive information in a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Is anonymization alone sufficient to protect sensitive data? In short, no, it
    is not sufficient, as we’ll see in the following case study from the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world case study (Netflix user data anonymization)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our Netflix data anonymization case study dates back to 2006 when Netflix launched
    the Netflix Prize, a competition aimed at improving the accuracy of the company’s
    recommendation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the competition, Netflix released a dataset containing the viewing
    history of 500,000 subscribers, with personally identifiable information removed.
    The dataset was made available to researchers to develop better algorithms. In
    2009, researchers published a paper that showed that it was possible to re-identify
    individuals in the Netflix dataset by using information from the **Internet Movie
    Database** (**IMDb**). The researchers were able to match the anonymized viewing
    history with the reviews that users had posted on IMDb, allowing them to re-identify
    individuals with high accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Following this discovery, Netflix took steps to improve its anonymization techniques,
    but in 2010, researchers once again showed that it was possible to re-identify
    individuals in the Netflix dataset. This time, researchers used external data
    sources such as social networks and movie rating websites to re-identify individuals.
  prefs: []
  type: TYPE_NORMAL
- en: In response to these privacy concerns, Netflix stopped releasing anonymized
    datasets to researchers in 2010\. Instead, the company created an internal research
    program where researchers could analyze Netflix data without any personally identifiable
    information being shared. However, in 2020, a group of researchers from the University
    of Texas at Austin and the University of California, Irvine showed that they could
    still re-identify Netflix users by analyzing their viewing history and correlating
    it with publicly available datasets. The researchers were able to accurately re-identify
    users even when no personally identifiable information was present in the Netflix
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: These findings showed that the anonymization techniques alone were not enough
    to protect users’ privacy as they are prone to data linkage attacks, which we
    learned about in [*Chapter 1*](B16573_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of anonymization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anonymization may not completely eliminate the risk of re-identification. If
    enough data is available, it may be possible to identify individuals by linking
    the anonymized data with other available information such as public datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymization may result in loss of data quality or accuracy, as certain data
    elements may be removed or masked in the process.
  prefs: []
  type: TYPE_NORMAL
- en: De-identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: De-identification is the process of removing or masking identifiable information
    in data so that it cannot be used to identify individuals. The purpose of de-identification
    is to protect the privacy of individuals while still allowing the data to be used
    for research, analysis, or other applications. De-identified data may be used
    for healthcare research, marketing analysis, financial use cases, IoT use cases,
    and other applications where sensitive data is required.
  prefs: []
  type: TYPE_NORMAL
- en: De-identification algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One-way hashing algorithms can be used to run de-identification processes on
    data. One-way hashing algorithms, also known as cryptographic hash functions,
    are mathematical functions that take an input message of any length and generate
    a fixed-size output, which is referred to as a hash or message digest. The key
    property of one-way hash algorithms is that they are designed such that it should
    be computationally infeasible to reverse-engineer the original input message from
    the hash value.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different hashing algorithms, and new ones are continually being
    developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the most widely used hashing algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Digest 5** (**MD5**): This is a widely used hashing algorithm that
    produces a 128-bit hash value. It is now considered to be insecure due to vulnerabilities
    in its design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure Hash Algorithm 1** (**SHA-1**): This is another widely used hashing
    algorithm that produces a 160-bit hash value. It is also now considered to be
    insecure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure Hash Algorithm 2** (**SHA-2**): This is a family of hashing algorithms
    that includes SHA-224, SHA-256, SHA-384, and SHA-512\. These algorithms produce
    hash values of 224, 256, 384, and 512 bits, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure Hash Algorithm 3** (**SHA-3**): This is a family of hashing algorithms
    that includes SHA3-224, SHA3-256, SHA3-384, and SHA3-512\. These algorithms are
    designed as a replacement for SHA-2 and produce hash values of 224, 256, 384,
    and 512 bits, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BLAKE2**: This is a family of hashing algorithms that includes BLAKE2b and
    BLAKE2s. These algorithms were designed to be faster than SHA-3 while still providing
    strong security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RACE Integrity Primitives Evaluation Message Digest** (**RIPEMD**): This
    is a family of hashing algorithms that includes RIPEMD-128, RIPEMD-160, RIPEMD-256,
    and RIPEMD-320\. These algorithms were designed as a replacement for the MD4 and
    MD5 algorithms and produce hash values of 128, 160, 256, and 320 bits, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Whirlpool**: This is a hashing algorithm that produces a 512-bit hash value.
    It was designed to be an alternative to the SHA-2 family of algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the examples of hashing algorithms available. The choice of
    which algorithm to use will depend on the specific application and the desired
    balance between security, speed, and other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Example Python code to de-identify the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed, De-identification is the process of removing or masking identifiable
    information in data so that it cannot be used to identify the original data. In
    the code below, let’s de-identify a given data (in this case a string) using the
    SHA256 hashing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '*Source code:* *De-Identify_Exmple.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `hashlib` library is used to compute a SHA-256 hash of
    a given input string. We define a `deidentify_data` function that takes data as
    input, removes any leading/trailing whitespace, converts the data to lowercase,
    and then hashes it using the `hash_string` function.
  prefs: []
  type: TYPE_NORMAL
- en: This ensures that the same input name will always produce the same output hash.
    Note that because one-way hashing is an irreversible process, there is no way
    to retrieve the original name from the hashed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hashlib` library in Python provides a collection of hashing algorithms.
    The following methods are available in the `hashlib` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hashlib.md5()**: This method returns an MD5 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha1()**: This method returns a SHA-1 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha224()**: This method returns a SHA-224 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha256()**: This method returns a SHA-256 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha384()**: This method returns a SHA-384 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha512()**: This method returns a SHA-512 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.blake2s()**: This method returns a BLAKE2s hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.blake2b()**: This method returns a BLAKE2b hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha3_224()**: This method returns a SHA3-224 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha3_256()**: This method returns a SHA3-256 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha3_384()**: This method returns a SHA3-384 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hashlib.sha3_512()**: This method returns a SHA3-512 hash object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of de-identification is to make it difficult or impossible to identify
    individuals based on their personal information.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of de-identification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: De-identification may not completely eliminate the risk of re-identification.
    If enough data is available, it may be possible to identify individuals based
    on other available information. De-identification may result in the loss of data
    quality or accuracy, as certain data elements may be removed or masked in the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, each technique has its own strengths and limitations, and the appropriate
    technique should be selected based on the specific use case and requirements.
    Encryption is the most secure way to protect data, but it does not provide anonymity
    or de-identification. Anonymization and de-identification can both provide privacy
    protection, but they may not be sufficient in all cases and may result in data
    quality or accuracy issues.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Homomorphic encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Homomorphic Encryption** (**HE**) is a cryptographic technique that allows
    computation on encrypted data without decrypting it. In other words, it is possible
    to perform operations on ciphertexts, generating new ciphertexts that are decrypted
    to the result of the operation on the plaintexts. HE has the potential to revolutionize
    data privacy and security, enabling secure computation of sensitive data without
    revealing the data itself. HE is based on mathematical concepts such as algebraic
    structures, number theory, and polynomial theory. The most common types of HE
    are based on the following algebraic structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Ring-based
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of cryptography, an algebraic structure refers to a set of mathematical
    operations that can be performed on elements of the set in a specific way. In
    the case of a ring, the set of elements is closed under addition and multiplication,
    and the operations satisfy certain properties, such as associativity, commutativity,
    and the existence of an identity element and inverse elements. In the context
    of HE, an algebraic structure is used to perform computations on encrypted data
    without first decrypting it. The underlying algebraic structure is a ring, which
    is a set of elements with two binary operations (addition and multiplication)
    that satisfy certain properties. The most widely used ring-based HE is the **Brakerski-Gentry-Vaikuntanathan**
    (**BGV**) scheme.
  prefs: []
  type: TYPE_NORMAL
- en: The BGV scheme is a **fully homomorphic encryption** (**FHE**) scheme based
    on the **learning with errors** (**LWE**) problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now examine a mathematical description of the scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Key generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To generate a public key, the following steps are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose two integers n and q, where q is a prime number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate a random matrix A with integer entries in the range [-q/2, q/2].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate a random vector with integer entries in the range [-q/2, q/2].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute the vector b = As + e, where e is a random vector with entries in the
    range [-B/2, B/2] for some integer B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the public key to be (A, b).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To generate a secret key, a random vector s is chosen with integer entries in
    the range [-q/2, q/2].
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To encrypt a message m, the following steps are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Represent the message m as a polynomial m(x) with integer coefficients modulo
    q.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a random polynomial r(x) with integer coefficients modulo q.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute c = (A*r + b + m(x)*t)/q, where t is a scaling factor that controls
    the noise in the ciphertext.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting ciphertext c consists of a matrix and a polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: Decryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To decrypt a ciphertext c, the following steps are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute c’ = c*s/q.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Round each entry of c’ to the nearest integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recover the polynomial m(x) by subtracting A*r from c’.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homomorphic operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The BGV scheme allows homomorphic addition and multiplication on ciphertexts.
    These operations are performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Homomorphic addition: To add two ciphertexts c1 and c2, add their corresponding
    polynomials modulo q, and add their matrices element-wise modulo q.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Homomorphic multiplication: To multiply two ciphertexts c1 and c2, compute
    their product modulo q using the polynomial multiplication algorithm, and multiply
    their matrices using matrix multiplication modulo q.'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To perform more than one homomorphic multiplication, the BGV scheme uses a technique
    called bootstrapping to “refresh” the ciphertext. The bootstrapping process involves
    decoding the ciphertext, performing a homomorphic operation, and then re-encrypting
    the result with a new set of keys. The bootstrapping process allows an arbitrary
    number of homomorphic operations to be performed on the ciphertext while still
    maintaining the security of the scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Lattice-based
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HE based on lattices uses the mathematical concept of lattices, which are geometric
    structures in higher dimensions that allow the efficient computation of certain
    types of problems. The most widely used lattice-based HE is the FHE scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve-based
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HE based on elliptic curves uses elliptic curves over finite fields to create
    the cryptographic scheme. This type of HE is relatively new, and not as widely
    used as the other two types.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the mathematics behind HE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mathematics behind HE is based on two main concepts: encryption and homomorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encryption is the process of transforming plaintext into ciphertext using an
    encryption algorithm and a secret key. The ciphertext can then be transmitted
    over a network or stored in a database without fear of unauthorized access. To
    decrypt the ciphertext and obtain the plaintext, the recipient must possess the
    secret key that was used to encrypt the data.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Homomorphism is a mathematical property that allows an operation to be performed
    on ciphertexts, generating a new ciphertext that is the result of the operation
    on the plaintexts. This means that if we have two plaintexts x and y, and their
    respective ciphertexts C(x) and C(y), we can perform an operation on C(x) and
    C(y) to obtain a new ciphertext C(x+y), which can be decrypted to obtain the result
    of the operation on x and y.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used homomorphic operations are addition and multiplication,
    but other operations such as subtraction and division can also be performed. The
    level of homomorphism determines how many operations can be performed on the ciphertexts
    before the noise introduced during the encryption process becomes too high and
    the ciphertext becomes unusable.
  prefs: []
  type: TYPE_NORMAL
- en: HE is based on the concept of adding noise to the ciphertext to make it impossible
    to recover the plaintext without the secret key. The noise is added in such a
    way that homomorphic operations can be performed on the ciphertext without revealing
    the plaintext. The amount of noise added determines the level of security of the
    encryption. The noise is also the reason why the level of homomorphism is limited
    in HE, as too many homomorphic operations can cause the noise to become too high
    and the ciphertext to become unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Types of HE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three types of implementation for HE. Let’s examine them now.
  prefs: []
  type: TYPE_NORMAL
- en: Fully Homomorphic Encryption (FHE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FHE is a type of encryption that allows computation to be performed on encrypted
    data without decrypting it. It means that the ciphertext can be used as input
    for a computation and the result will be a ciphertext as well, which can be decrypted
    to get the result of the computation. FHE is a powerful tool that can be used
    in various applications such as cloud computing, machine learning, and secure
    outsourcing. One of the main challenges of FHE is its computational complexity,
    which makes it impractical for many applications. However, recent advancements
    in FHE have led to the development of more efficient algorithms that reduce the
    computational overhead of FHE.
  prefs: []
  type: TYPE_NORMAL
- en: The Gentry scheme is one of the earliest and most well-known FHE schemes, but
    it has a high computational cost. More recent schemes, such as the CKKS scheme
    and the BFV scheme, offer more efficient FHE algorithms that are suitable for
    practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Somewhat Homomorphic Encryption (SHE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SHE is a type of encryption that allows limited computations on encrypted data.
    Unlike FHE, SHE cannot perform arbitrary computations on encrypted data. Instead,
    it can only perform a limited set of operations, such as addition and multiplication,
    on the encrypted data. While SHE is less powerful than FHE, it is still useful
    in many applications, such as secure voting, secure messaging, and secure database
    queries. SHE is less computationally intensive than FHE, which makes it more practical
    for certain applications.
  prefs: []
  type: TYPE_NORMAL
- en: Partially Homomorphic Encryption (PHE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHE is a type of encryption that allows for computations on encrypted data,
    but only for one type of operation, either addition or multiplication. PHE is
    less powerful than both FHE and SHE but is still useful in some applications,
    such as secure key generation, secure function evaluation, and secure scalar product
    calculation. PHE is less computationally intensive than both FHE and SHE, which
    makes it more practical for some applications. However, its limited functionality
    means that it is less flexible than FHE and SHE and cannot be used in as many
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: FHE, SHE, and PHE are three related encryption schemes that provide different
    levels of functionality and computational complexity. FHE is the most powerful
    but also the most computationally intensive, while PHE is the least powerful but
    also the least computationally intensive. SHE provides a middle ground between
    FHE and PHE in terms of functionality and computational complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Paillier scheme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Paillier scheme is a public key cryptosystem that is used for the encryption
    and decryption of data. It is based on the mathematical assumption i.e **decisional
    composite residuality assumption** (**DCRA**), which is a hard computational problem.
    The scheme is named after its creator, Pascal Paillier, who introduced it in 1999.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Paillier scheme is an asymmetric encryption algorithm, which means that
    it uses two different keys: a public key for encryption and a private key for
    decryption. The scheme is designed to be probabilistic, which means that each
    encryption of a given plaintext results in a different ciphertext. The scheme
    is also homomorphic, which means that it supports certain types of operations
    on the encrypted data.'
  prefs: []
  type: TYPE_NORMAL
- en: Key generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use the Paillier scheme, a user first generates a public key and a corresponding
    private key. The public key consists of two large prime numbers, p and q, which
    are kept secret. The user then calculates n = p * q and lambda = LCM(p - 1, q
    - 1), where LCM is the least common multiple function. The value of lambda is
    used to generate the private key.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To encrypt a message, the sender uses the recipient’s public key. The plaintext
    message is represented as an integer m, where 0 <= m < n. The sender then chooses
    a random number r, where 0 <= r < n, and computes c = g^m * r^n mod n^2, where
    g is a random generator modulo n^2\. The ciphertext c is then sent to the recipient.
  prefs: []
  type: TYPE_NORMAL
- en: Decryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To decrypt the ciphertext, the recipient uses their private key. The recipient
    first computes the value of
  prefs: []
  type: TYPE_NORMAL
- en: '**mu = (L(g^lambda mod n^2)^-1 mod n)^(lambda^-1** **mod n)**'
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '**L(x) = (x - 1) / n**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of mu is used to calculate the plaintext message m as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**m = L(c^lambda mod n^2) * mu** **mod n**'
  prefs: []
  type: TYPE_NORMAL
- en: The recipient can then recover the original message from m.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphic properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Paillier scheme supports two homomorphic properties: additive and multiplicative.'
  prefs: []
  type: TYPE_NORMAL
- en: The additive property allows the recipient to perform addition on the encrypted
    data. Given two ciphertexts c1 and c2 that correspond to plaintext messages m1
    and m2, the recipient can compute a new ciphertext c3 that corresponds to the
    sum of m1 and m2 by multiplying c1 * c2 mod n^2.
  prefs: []
  type: TYPE_NORMAL
- en: The multiplicative property allows the recipient to perform multiplication on
    the encrypted data. Given a ciphertext c that corresponds to a plaintext message
    m, the recipient can compute a new ciphertext c’ that corresponds to the product
    of m and a constant k by raising c to the power of k mod n^2.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Paillier scheme is also resistant to known plaintext attacks and chosen
    plaintext attacks. The scheme is used in various applications, including electronic
    voting, privacy-preserving data mining, and secure multiparty computation.
  prefs: []
  type: TYPE_NORMAL
- en: Python frameworks for HE the following section, we will cover the open source
    Python frameworks that are used to implement HE. We will implement a few examples
    in detail to understand homomorphic operations in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Pyfhel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pyfhel is a Python library for FHE. It provides an easy-to-use interface for
    performing FHE operations on encrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'URL: [https://pyfhel.readthedocs.io/en/latest/](https://pyfhel.readthedocs.io/en/latest/)'
  prefs: []
  type: TYPE_NORMAL
- en: SEAL Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SEAL Python is a Python wrapper for the **Simple Encrypted Arithmetic Library**
    (**SEAL**) C++ library. SEAL Python provides a high-level interface for performing
    HE and decryption operations on data using the Brakerski/Fan-Vercauteren (BFV)
    and Cheon-Kim-Kim-Song (CKKS) schemes.
  prefs: []
  type: TYPE_NORMAL
- en: 'URL: [https://github.com/Huelse/SEAL-Python](https://github.com/Huelse/SEAL-Python)'
  prefs: []
  type: TYPE_NORMAL
- en: TenSEAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TenSEAL is a Python library for homomorphic encryption on *n* tensors, built
    on top of Microsoft SEAL and using the CKKS scheme. It provides an easy-to-use
    interface for performing FHE operations on encrypted data with support for batching
    and batching rotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features offered by TenSEAL are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption/decryption of the vectors of integers using BFV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption/decryption of the vectors of real numbers using CKKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element-wise addition, subtraction, and multiplication of encrypted-encrypted
    vectors and encrypted-plain vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dot product and vector-matrix multiplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'URL: [https://github.com/OpenMined/TenSEAL](https://github.com/OpenMined/TenSEAL)'
  prefs: []
  type: TYPE_NORMAL
- en: phe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: phe is a Python library for **partially homomorphic encryption** (**PHE**) using
    the Paillier scheme. It provides an API for performing PHE operations on encrypted
    data.
  prefs: []
  type: TYPE_NORMAL
- en: It is a simple and easy-to-use library. It only supports three operations (addition,
    subtraction, and scalar multiplication) on HE out of four operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'URL: [https://pypi.org/project/phe/](https://pypi.org/project/phe/)'
  prefs: []
  type: TYPE_NORMAL
- en: The homomorphic properties of the Paillier cryptographic system work as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypted numbers can be added together:'
  prefs: []
  type: TYPE_NORMAL
- en: Enc(m1)+Enc(m2)≡Enc(m1+m2)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Homomorphic addition](img/B16573_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Homomorphic addition
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypted numbers can be subtracted from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: Enc(m1)-Enc(m2)≡Enc(m1-m2)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Homomorphic subtraction](img/B16573_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Homomorphic subtraction
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypted numbers can be multiplied by a non-encrypted scalar:'
  prefs: []
  type: TYPE_NORMAL
- en: n⋅Enc(m) ≡ Enc(n*m)
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.3 – Homomorphic-encrypted nu\uFEFFmber multiplied by a non-encrypted\
    \ scalar](img/B16573_08_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Homomorphic-encrypted number multiplied by a non-encrypted scalar
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypted numbers can be added to non-encrypted scalars:'
  prefs: []
  type: TYPE_NORMAL
- en: n+Enc(m) ≡ Enc(n+m)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Homomorphic-encrypted number added to a non-encrypted scalar](img/B16573_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Homomorphic-encrypted number added to a non-encrypted scalar
  prefs: []
  type: TYPE_NORMAL
- en: Implementing HE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement HE, choose a suitable HE library from those outlined previously.
    Make sure your choice is appropriate based on your specific use case, then perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate the public and private keys required for the encryption scheme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the plaintext data that needs to be encrypted into a suitable format
    for the encryption scheme, such as a polynomial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encrypt the plaintext data using the public key generated in *step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the homomorphic operations on the ciphertext data without decrypting
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrypt the resulting ciphertext data using the private key generated in *step
    2* to obtain the result of the homomorphic operations on the plaintext data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing HE can be complex and requires expertise in cryptography and mathematics.
    It is important to ensure that the implementation is secure and efficient, as
    HE can be computationally intensive.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing PHE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will implement an example of Paillier PHE using the open source `phe` Python
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we install the `phe` library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate the public and private keys using the **generate_paillier_keypair**
    method from **phe.paillier** class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypt the plaintext data (15 in this example) using the **encrypt** method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform homomorphic operations on the ciphertext data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ciphertext1 = ciphertext * 3 // encrypted number multiplied by a scalar
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ciphertext2 = ciphertext + ciphertext1 // adding two encrypted numbers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ciphertext3 = ciphertext1 + 250 // adding scalar to a encrypted number
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ciphertext4 = ciphertext3 - ciphertext2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, decrypt the resulting ciphertext data using the **decrypt** method
    and print the decrypted results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Source* *code: FHE-Example.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How about multiplying an encrypted number with another encrypted number?
  prefs: []
  type: TYPE_NORMAL
- en: Will the following work with PHE?
  prefs: []
  type: TYPE_NORMAL
- en: Enc(m1) * Enc(m2)≡Enc(m1* m2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this and find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It throws *NotImplementedError*, which basically means that phe doesn’t support
    this (multiplying an encrypted number with another encrypted number) property
    of HE.
  prefs: []
  type: TYPE_NORMAL
- en: When your requirements call for developing applications involving tensors, matrices,
    arrays, and all homomorphic operations, TenSEAL is the best framework to use.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing HE using the TenSEAL library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will implement an example of HE using the open source TenSEAL Python library.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we install the TenSEAL library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Source* *code :TenSeal_Example.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: Develop the sample applictions in the following way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example code, we first create a context using the CKKS scheme
    with a polynomial modulus degree of 8,192 and four coefficient modulus bit sizes
    of 60, 40, 40, and 60\. Then, we create two CKKS vectors and encrypt our data.
    Next, we perform two operations on our encrypted data: addition and multiplication.
    Finally, we decrypt the results of these operations and print them out.'
  prefs: []
  type: TYPE_NORMAL
- en: This library also supports creating context using the BFV scheme as well in
    the same manner and the homomorphic operations using the BFV Scheme as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example, and in practice, HE can be computationally intensive
    and requires specialized hardware or cloud resources. It is also important to
    ensure that the implementation is secure and that no encrypted data leaks out
    during the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of HE frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s review a comparison of some of the most popular HE frameworks in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Pyfhel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pyfhel is a Python-based fully HE library that supports operations on encrypted
    integers and vectors. It is built on top of the HElib C++ library and offers a
    simplified interface for Python developers. Pyfhel has good performance and can
    handle large integers and vectors efficiently. However, it does not yet support
    operations on floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: TenSEAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TenSEAL is a Python-based library for HE that supports both FHE and PHE. It
    uses the CKKS and BFV encryption schemes and offers APIs for encrypted operations
    on floating-point numbers and matrices. TenSEAL is designed to be easy to use
    and has a simpler API compared to some other HE libraries. It has a relatively
    high performance for encrypted operations on floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: PALISADE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PALISADE is a C++ library for HE that has Python bindings. It supports both
    FHE and PHE and offers a wide range of encryption schemes, including CKKS, BFV,
    and GSW. PALISADE is designed for performance and can handle large plaintexts
    and ciphertexts efficiently. The Python bindings are relatively new, and the API
    can be more complex compared to other Python-based HE libraries.
  prefs: []
  type: TYPE_NORMAL
- en: PySEAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PySEAL is a Python-based library for HE that supports FHE operations on encrypted
    integers and vectors. It is built on top of the SEAL C++ library and provides
    a simplified Python interface. PySEAL has good performance for integer and vector
    operations and can handle large plaintexts and ciphertexts. However, it does not
    yet support operations on floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: TFHE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TFHE is a C++ library for HE that has Python bindings. It supports PHE operations
    on encrypted integers and booleans and is designed for high performance. TFHE
    can handle large ciphertexts efficiently and has a relatively simple API. The
    Python bindings are relatively new, and the documentation can be limited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table offers a high-level summary of the comparisons between
    the preceding HE libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operations | PySEAL | TenSEAL | Paillier | Pyfhel |'
  prefs: []
  type: TYPE_TB
- en: '| Addition | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Subtraction | Yes | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication | Yes | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Division | No | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Comparison (<, >, <=, >=, and ==) | No | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Support for vector operations (addition, dot product, etc.) | Yes | Yes |
    No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Matrix operations | Yes | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Encrypted number added to scalar (non-encrypted number) | Yes | Yes | Yes
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Encrypted number multiplied by scalar (non-encrypted number) | Yes | Yes
    | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – High-level comparison of HE frameworks
  prefs: []
  type: TYPE_NORMAL
- en: Each HE framework has its own set of strengths and weaknesses, and the best
    choice will depend on your specific use case and requirements. Pyfhel and PySEAL
    are good choices for FHE operations on integers and vectors, while TenSEAL is
    a good choice for FHE operations on floating-point numbers and matrices. PALISADE
    offers a wide range of encryption schemes and is designed for performance, while
    TFHE is a good choice for PHE operations on integers and booleans.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning with HE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HE can be used in **Machine Learning** (**ML**) models to encrypt the training
    data, test data, or even the complete model itself to achieve model security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the options to implement ML models with HE:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt the weights (model parameters) and intercept, and make use of them to
    calculate the accuracy of the model on the test data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypt the test data and make use of the encrypted data with an encrypted model
    to find out the accuracy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the models with training data encrypted and without the encryption.Calculate
    the accuracy of the clear text model as well as the model with encrypted training
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypt the training data and train the model on encrypted data, then run the
    inference and decrypt the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we will encrypt the model parameters and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the fraud detection model example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load the fraud transaction data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Split the data as train and test
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the logistic regression model to train the data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From the model, find out the intercept and coefficients ( weights)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the Paillier PHE library, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform HE on the model parameters (i.e., the intercept values and model weights)
    using the public key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Find out the predictions using the encrypted intercept and encrypted model
    weights:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the score by doing the homomorphic operations (encrypted weights multiplied
    by test feature data and the addition of encrypted numbers)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypt the calculated score using homomorphic decryption and find out the error/accuracy
    rates
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Encryption of model parameters using HE](img/B16573_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Encryption of model parameters using HE
  prefs: []
  type: TYPE_NORMAL
- en: '*Source* *code: FHE_Logistic.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: Following code implements the steps mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this way, ML engineers are able to share the public key generated using HE,
    along with the encrypted model weights, with others while retaining the security
    of their ML models.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted evaluation of ML models and inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to perform encrypted evaluations and inference, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt the training data using the public key (i.e., the HE key).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Train the model with the encrypted data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the encrypted results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypt the results with the secret key (i.e., the private key).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Encrypted evaluation of ML model and inference](img/B16573_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Encrypted evaluation of ML model and inference
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of HE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HE is a powerful cryptographic technique that allows computations to be performed
    on encrypted data without the need for decryption. While HE has several benefits,
    it also has some limitations, which we’ll take a look at now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: HE is computationally intensive and can be slow, especially
    when working with large amounts of data. The overhead associated with encryption
    and decryption can significantly impact the performance of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited functionality**: HE is still a developing field, and current implementations
    have limited functionality. Complex computations are often difficult to perform
    using HE, and not all types of computations can be performed using current HE
    techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key management**: HE requires the management of large cryptographic keys,
    which can be challenging, especially in distributed systems. The key management
    problem becomes more complex as the number of parties involved in the computation
    increases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security assumptions**: HE is based on certain security assumptions, and
    if these assumptions are violated, the security of the system can be compromised.
    For example, the security of the system can be compromised if the attacker has
    access to the secret key or the encrypted data is leaked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage requirements**: HE can result in large ciphertexts that require more
    storage space than plaintext. This can be a challenge in systems where storage
    space is limited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned limitations need to be taken into account when considering
    the use of HE in a system. While HE has the potential to provide a secure and
    privacy-preserving solution, it is essential to carefully evaluate the limitations
    and trade-offs before using it in a real-world system.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Multiparty Computation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Secure Multiparty Computation** (**SMC**) is a cryptographic technique that
    enables two or more parties to jointly compute a function on their private data
    without revealing their data to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: SMC is an important tool in privacy-preserving computation, where parties may
    not trust each other or a central authority and may have sensitive data that they
    do not want to share with other parties.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about the basic principles of SMC, its applications,
    and some techniques used for SMC.
  prefs: []
  type: TYPE_NORMAL
- en: Basic principles of SMC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic principle of SMC is that each party has private data that they want
    to keep secret from other parties, but they want to compute a function on the
    common joint data. SMC enables multiple parties to do this securely by dividing
    the computation into smaller, less sensitive sub-computations, which are performed
    locally on each party’s private data. Then, the parties communicate with each
    other to reveal only the final output of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: SMC ensures that no party learns any information about the other parties’ data,
    except for what is necessary to compute the final output. The computations performed
    in SMC are designed such that no party can learn anything about other parties’
    data by analyzing the messages sent during the computation.
  prefs: []
  type: TYPE_NORMAL
- en: The security of SMC relies on cryptographic techniques such as secret sharing,
    HE, and oblivious transfer. These techniques ensure that each party only sees
    a small portion of the input data and that the output is computed in such a way
    that no party can determine the input data of other parties.
  prefs: []
  type: TYPE_NORMAL
- en: Applications of SMC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SMC has several applications in various domains, including healthcare, finance,
    and data privacy. We’ll examine these in more detail now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data analysis**: In many scenarios, data is distributed across different
    parties, and it is not possible or desirable to centralize the data in one location.
    SMC can be used to enable the parties to perform computations on their private
    data without revealing their data to each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ML**: SMC can be used to enable multiple parties to jointly train ML models
    on their private data without sharing their data with each other. This can be
    useful in scenarios where data privacy is a concern, such as in healthcare or
    financial services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privacy-preserving** **authentication**: SMC can be used to enable multiple
    parties to authenticate themselves without revealing their identity to each other.
    For example, a group of users can use SMC to authenticate themselves with a service
    provider without revealing their identities to each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fraud detection**: SMC can be used to enable different parties to detect
    fraudulent activity without revealing any sensitive information. For example,
    multiple banks can use SMC to compute the intersection of their transaction lists
    to detect fraudulent transactions without revealing any customer data. We have
    already covered using federated learning with differential privacy, but the same
    use case, that is, detection of fraudulent transactions, can be applied with SMC
    as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques used for SMC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SMC can be performed using various techniques, including secret sharing, HE,
    and oblivious transfer. Let’s review these techniques now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secret sharing**: This is a cryptographic technique that divides a secret
    into multiple shares, where each share is given to a different party. The secret
    can only be reconstructed when a sufficient number of shares are combined. In
    SMC, secret sharing can be used to divide the input data into multiple shares,
    which are then used to perform computations locally on each party’s data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HE**: This is a type of encryption that allows computations to be performed
    on ciphertexts without decrypting them. In SMC, HE can be used to compute the
    intermediate values of the computation without revealing the parties’ data. HE
    is computationally expensive, so it is not suitable for all SMC applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oblivious transfer**: This is a cryptographic protocol where a sender has
    multiple messages, and a receiver selects one of the messages without revealing
    the other messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing SMC – high-level steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a high-level overview of the steps required to implement SMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define the computation**: The first step in implementing SMC is to define
    the computation that needs to be performed on the private data. This computation
    should be divided into smaller sub-computations, each of which can be performed
    locally on each party’s private data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Secure communication**: The parties involved in the SMC computation need
    to communicate securely with each other to exchange messages without revealing
    their private data. This can be achieved using secure communication protocols
    such as SSL or TLS.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Secret sharing**: The input data needs to be divided into shares, which are
    distributed among the parties. Each party holds a share of the input data, and
    computations are performed locally on each party’s share. Secret sharing can be
    implemented using cryptographic techniques such as Shamir’s Secret Sharing Scheme.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Computation**: Once the input data has been shared among the parties, the
    computation can be performed locally on each party’s share of the data. The intermediate
    values of the computation need to be encrypted using HE to prevent any party from
    learning anything about the other parties’ data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reveal the output**: After the computation is complete, the parties reveal
    only the final output of the computation to each other. The output can be reconstructed
    by combining the shares of the output that each party holds.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SMC requires expertise in cryptography, programming, and network security. It
    is a complex process that requires careful design and implementation to ensure
    the security and privacy of the parties involved.
  prefs: []
  type: TYPE_NORMAL
- en: Python frameworks that can be used to implement SMC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are a number of Python frameworks that can be used to implement
    SMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PySyft** is an open source framework for SMC and federated learning. It provides
    tools for secure multi-party computation, differential privacy, and homomorphic
    encryption. It is built on top of PyTorch and provides a simple and easy-to-use
    interface for implementing SMC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obliv-C** is a language and framework for implementing SMC in C and Python.
    It provides a high-level programming interface for implementing SMC, as well as
    low-level primitives for building custom protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Charm** is a Python library for cryptography that provides support for SMC,
    HE, and other cryptographic primitives. It provides a high-level programming interface
    for implementing SMC, as well as low-level primitives for building custom protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MPyC** is a Python library for SMC that provides a high-level programming
    interface for implementing secure computations. It is built on top of the **asyncio**
    library, which provides support for asynchronous programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SecureML** is a Python library for implementing SMC and other privacy-preserving
    ML techniques. It provides a high-level programming interface for implementing
    SMC, as well as support for other privacy-preserving techniques such as differential
    privacy and federated learning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Private Set Interaction (PSI) SMC – case study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Private Set Intersection** (**PSI**) is a cryptographic technique that allows
    two or more parties to securely compute the intersection of their private sets
    without disclosing any other information about their sets. PSI can be used in
    various fintech applications where sensitive financial data needs to be shared
    between parties while preserving privacy.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now examine an example case study concerning the implementation of PSI
    SMC for fraud detection in the fintech sector.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fraud Detection**: In the fintech industry, fraud detection is a critical
    task that requires sharing information between banks, financial institutions,
    and payment processors to identify fraudulent transactions. However, sharing customer
    data between these entities can violate their customers’ privacy. To overcome
    this problem, PSI can be used to enable the secure sharing of data between different
    entities without disclosing any sensitive information.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose a bank wants to share its list of suspicious transactions
    with another bank without revealing the details of the transactions or customers
    involved. PSI can be used to compute the intersection of the two banks’ transaction
    lists. The bank’s transaction list would form one subset, and the other bank’s
    transaction list would form the other subset. By using PSI, both banks can securely
    compute the intersection of their transaction lists without revealing any sensitive
    information about their transactions or customers.
  prefs: []
  type: TYPE_NORMAL
- en: To implement PSI SMC in this use case, SMC techniques can be used. SMC ensures
    that the parties involved can jointly compute the intersection of their datasets
    without revealing any other information about their datasets. The computation
    can be performed using techniques such as **Oblivious Transfer** (**OT**) or **Garbled
    Circuits** (**GC**) to ensure the privacy and security of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Example of secure multiparty computation with shared keys](img/B16573_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Example of secure multiparty computation with shared keys
  prefs: []
  type: TYPE_NORMAL
- en: '*Source* *code: PSI-SMC_Example.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement a simple SMC example to understand the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Zero-knowledge proofs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Zero-Knowledge Proofs** (**ZKPs**) are a type of cryptographic protocol that
    allows one party (the Prover) to demonstrate to another party (the Verifier) that
    they possess knowledge of a particular piece of information, without revealing
    any other information about that knowledge. The concept of zero knowledge was
    first introduced by Goldwasser, Micali, and Rackoff in 1985\. Since then, zero-knowledge
    protocols have been widely used in cryptography, particularly in privacy-preserving
    protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of zero knowledge is based on the idea of interactive proof systems.
    In an interactive proof system, a Prover tries to convince a Verifier that a statement
    is true by sending a series of messages to the Verifier. The Verifier examines
    each message and either accepts or rejects the statement. In a zero-knowledge
    proof, the Prover can convince the Verifier of the truth of the statement without
    revealing any other information beyond the fact that they know the statement to
    be true. The central idea behind ZKPs is to show that a Prover has knowledge of
    some secret information, without revealing any details about that information.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that Alice wants to prove to Bob that she knows the value
    of a secret number x, without revealing the value of x itself. With a ZKP, Alice
    can prove to Bob that she knows x by interacting with him in such a way that he
    becomes convinced that she knows the value of x, but learns nothing else about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Types of ZKPs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three main types of ZPKs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero-Knowledge Proof of Knowledge** (**ZKPK**): In a ZKPK, the Prover proves
    to the Verifier that they know a particular secret without revealing any information
    about that secret. An example of this is proving that you know the password to
    an account without revealing the password itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero-Knowledge Proof of Possession** (**ZKPP**): In a ZKPP, the Prover proves
    to the Verifier that they possess a particular item without revealing any information
    about the item. An example of this is proving that you have a valid driver’s license
    without revealing any personal information beyond what is already printed on the
    license.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero-Knowledge Proof of Identity** (**ZKPI**): In a ZKPI, the Prover proves
    to the Verifier that they are the same person or entity that was previously identified
    without revealing any other information about themselves. An example of this is
    proving that you are the same person who previously registered for an online service
    without revealing any other personal information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications of ZKPs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ZKPs have numerous applications in cryptography, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privacy-preserving authentication**: ZKPs can be used to authenticate a user
    without revealing their identity or any other personal information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure messaging**: ZKPs can be used to ensure the confidentiality and integrity
    of messages exchanged between two parties without revealing the content of the
    messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure computation**: ZKPs can be used to prove that a computation was performed
    correctly without revealing any details about the computation or the inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptocurrency**: ZKPs are used in some cryptocurrencies (such as Zcash)
    to ensure the privacy and anonymity of transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ZKPs are a powerful tool in cryptography that allow secure and private communication
    and computation. They have numerous applications in various fields, including
    finance, healthcare, and online identity verification. As technology continues
    to advance, the use of ZKPs is likely to become more widespread, helping to protect
    the privacy and security of individuals and organizations alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example Python program that implements a ZKPK for a simple
    scenario where a Prover wants to prove to a Verifier that they know the value
    of a secret number:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Source* *code: ZNP_Example.ipynb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the Prover generates two commitments based on the
    secret number and a random blinding factor and sends them to the Verifier. The
    Verifier then sends a random challenge value to the Prover, and the Prover responds
    with either the secret number or the blinding factor, depending on the challenge.
    The Verifier checks the response against the commitments and determines whether
    the Prover has successfully proven knowledge of the secret number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some popular Python frameworks for ZKPs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PyZPK**: A Python library for constructing and verifying **Zero-Knowledge
    Succinct Non-interactive Arguments of Knowledge** (**zk-SNARK**s) scheme. It provides
    a simple and intuitive interface for building ZKPs and is designed to work well
    with other Python libraries, such as NumPy and SciPy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bulletproofs-Builder**: A Python library for building and verifying bulletproofs.
    It provides a high-level interface for creating range proofs and other types of
    ZKPs. It is designed to be easy to use and can easily integrate with other Python
    libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**starkware-libs**: A collection of Python libraries for building and verifying
    Scalable Transparent Argument of Knowledge (STARKs). It includes libraries for
    constructing STARK-friendly hash functions, building constraint systems, and performing
    **Fast Fourier Transform** (**FFT**) operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In summary, in this chapter, we have covered encryption, anonymization, and
    de-identification techniques in detail, along with some example Python implementations
    and a discussion of their limitations. We learned about the foundations and types
    of HE and secure multiparty computation and saw how they help in achieving privacy
    when working with ML models (including applications such as the encryption of
    training data, test data, models, model parameters, and inference results).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about confidential computing, why it
    is needed, and how it helps to protect us from privacy threats facing data in
    memory. We will also learn about securing ML models through trusted execution
    environments.
  prefs: []
  type: TYPE_NORMAL
