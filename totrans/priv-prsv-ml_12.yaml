- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Homomorphic Encryption and Secure Multiparty Computation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同态加密和安全多方计算
- en: Homomorphic encryption is a cryptographic technique that allows computation
    on encrypted data without decrypting it. It has the potential to revolutionize
    data privacy and security, enabling the secure computation of sensitive data without
    revealing the data itself. In this chapter, you will learn about homomorphic encryption
    and secure multiparty computation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 同态加密是一种密码学技术，它允许在加密数据上执行计算，而无需解密它。它有可能彻底改变数据隐私和安全，使得在不泄露数据本身的情况下安全地计算敏感数据。在本章中，你将了解同态加密和安全的多方计算。
- en: 'We will cover the following main topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Encryption, anonymization, and de-identification
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密、匿名化和去标识化
- en: Homomorphic encryption and the mathematics behind
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同态加密及其背后的数学
- en: Open source Python frameworks for homomorphic encryption and Paillier schemes
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于同态加密和Paillier方案的开放源代码Python框架
- en: Machine learning using homomorphic encryption (HE)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同态加密（HE）进行机器学习
- en: Federated learning with **Partially homomorphic** **encryption** **PHE**
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联邦学习与**部分同态**加密**PHE**
- en: Limitations of homomorphic encryption
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同态加密的限制
- en: '**Secure Multiparty Computation** (**SMC**) and its use cases'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全多方计算**（**SMC**）及其用例'
- en: A use case implementation using the **Private Set Interaction** (**PSI**) SMC
    technique
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**私有集交互**（**PSI**）SMC技术的一个用例实现
- en: A high-level overview of zero-knowledge proofs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零知识证明的高级概述
- en: Encryption, anonymization, and de-identification
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密、匿名化和去标识化
- en: Encryption, anonymization, and de-identification are all techniques used to
    protect sensitive data, but they differ in their approach and limitations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 加密、匿名化和去标识化都是用于保护敏感数据的技巧，但它们在方法和限制上有所不同。
- en: '**Encryption**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密**'
- en: Encryption is the process of transforming data into a form that can only be
    read by authorized parties with access to a decryption key. The purpose of encryption
    is to ensure the confidentiality and integrity of data. Encrypted data remains
    readable by those who have the appropriate decryption key, but it is unintelligible
    to anyone who intercepts it without the key. Encryption is widely used to protect
    sensitive data in transit and data at rest, such as credit card numbers, passwords,
    and personally identifiable information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是将数据转换为只有有权访问解密密钥的授权方才能读取的形式的过程。加密的目的是确保数据的机密性和完整性。加密数据对于拥有适当解密密钥的人来说仍然是可读的，但对于没有密钥的拦截者来说则是不可理解的。加密被广泛用于保护传输中和静止状态下的敏感数据，如信用卡号、密码和个人可识别信息。
- en: Here’s some simple Python code to implement basic encryption
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些简单的Python代码，用于实现基本的加密
- en: '*Source* *code: Encryption_Example.ipynb*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：Encryption_Example.ipynb'
- en: Develop a function to encrypt the given text using a basic encryption algorithm.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个函数，使用基本的加密算法加密给定的文本。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function takes two arguments: `text`, which is the plaintext to be encrypted,
    and `shift`, which is the number of positions by which each letter in the plaintext
    should be shifted in the alphabet. The function returns the encrypted text.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数：`text`，表示要加密的明文，以及`shift`，表示明文中的每个字母在字母表中应该移动的位置数。该函数返回加密后的文本。
- en: For example, if you call simple_encryption (“Privacy Preserved Machine Learning
    “, 5), then the function will return the string “Uwnafhd Uwjxjwaji Rfhmnsj Qjfwsnsl”,
    which is the encrypted version of “Privacy Preserved Machine Learning” with a
    shift of 5.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你调用simple_encryption（“Privacy Preserved Machine Learning”，5），那么该函数将返回字符串“Uwnafhd
    Uwjxjwaji Rfhmnsj Qjfwsnsl”，这是“Privacy Preserved Machine Learning”加密后的版本，移动了5个位置。
- en: Encryption algorithms
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密算法
- en: 'There are many popular encryption algorithms used today for securing data and
    communications. The most common are the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有许多流行的加密算法用于保护数据和通信。最常见的是以下几种：
- en: '**Advanced Encryption Standard** (**AES**): A symmetric-key encryption algorithm
    widely used for securing data in transit and at rest'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级加密标准**（**AES**）：一种对称密钥加密算法，广泛用于保护传输中和静止状态下的数据'
- en: '**Rivest-Shamir-Adleman** (**RSA**): An asymmetric-key encryption algorithm
    used for secure communication and digital signatures'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rivest-Shamir-Adleman**（**RSA**）：一种用于安全通信和数字签名的非对称密钥加密算法'
- en: '**Data Encryption Standard** (**DES**): A symmetric-key encryption algorithm
    widely used in the past, but now considered less secure'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据加密标准**（**DES**）：一种过去广泛使用的对称密钥加密算法，但现在被认为不够安全'
- en: '**Blowfish**: A symmetric-key encryption algorithm designed for high-speed
    and efficient encryption of large amounts of data'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blowfish**：一种对称密钥加密算法，专为高速和高效加密大量数据而设计'
- en: '**Twofish**: A symmetric-key encryption algorithm that is a successor to Blowfish,
    designed for higher security and flexibility'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Twofish**：一种对称密钥加密算法，是Blowfish的后继，旨在提供更高的安全性和灵活性'
- en: '**ChaCha20**: A symmetric-key encryption algorithm that is becoming increasingly
    popular due to its high security and performance'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChaCha20**：一种对称密钥加密算法，由于其高安全性和性能而越来越受欢迎'
- en: '**Elliptic Curve Cryptography** (**ECC**): An asymmetric-key encryption algorithm
    that uses elliptic curves instead of prime numbers, resulting in smaller key sizes
    and faster performance'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**椭圆曲线密码学**（**ECC**）：一种非对称密钥加密算法，使用椭圆曲线而不是素数，从而实现更小的密钥大小和更快的性能'
- en: These are just a few of the most popular encryption algorithms. There are many
    others, and new ones are constantly being developed as computing power and security
    needs evolve.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是最受欢迎的加密算法中的一部分。还有很多其他的算法，随着计算能力和安全需求的不断演变，新的算法也在不断被开发。
- en: Encryption example using AES
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AES加密的加密示例
- en: '*Source* *code: Encryption_Example.ipynb*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：Encryption_Example.ipynb'
- en: 'Develop a function to encrypt the given text using the AES encryption algorithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个函数，使用AES加密算法加密给定的文本：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This results in the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下输出：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example program, we used the PyCrypto library to implement AES encryption
    with **cipher-block chaining** (**CBC**) mode.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例程序中，我们使用了PyCrypto库来实现AES加密，使用**密码块链接**（**CBC**）模式。
- en: The `aes_encrypt` function takes a 128-bit key and plaintext message as the
    input and returns the encrypted ciphertext. The `aes_decrypt` function takes a
    key and ciphertext as input and returns the decrypted plaintext message. We used
    the PKCS7 padding scheme to pad the plaintext to a multiple of the block size
    and to remove the padding after decryption. It generates a random initialization
    vector for each encryption operation to add an additional layer of security.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`aes_encrypt`函数接受128位密钥和明文消息作为输入，并返回加密的密文。`aes_decrypt`函数接受密钥和密文作为输入，并返回解密后的明文消息。我们使用了PKCS7填充方案来将明文填充到块大小的倍数，并在解密后移除填充。它为每次加密操作生成一个随机的初始化向量，以增加额外的安全层。'
- en: Limitations of encryption
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密的局限性
- en: Encryption doesn’t provide anonymity or de-identification of data. Encrypted
    data may contain sensitive information that could be used to identify individuals.
    Encryption only protects data while it is being transmitted (data in motion) or
    stored (data at rest, i.e., in a persistent store), but it doesn’t control who
    has access to it or how it is used once decrypted.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 加密并不提供匿名化或数据去标识化。加密数据可能包含可用于识别个人的敏感信息。加密仅保护数据在传输（数据在运动中）或存储（静止数据，即在持久存储中）时的安全，但它不控制谁有权访问它或解密后如何使用它。
- en: Data anonymization
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据匿名化
- en: Anonymization is the process of removing identifiable information from data
    so that individuals cannot be identified. The main purpose of anonymization is
    to protect the privacy of individuals while still allowing the data to be used
    for analysis or research use cases.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名化是从数据中移除可识别信息的过程，这样个人就无法被识别。匿名化的主要目的是在允许数据用于分析或研究用例的同时保护个人的隐私。
- en: 'Here’s some example Python code for data anonymization:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些用于数据匿名化的Python代码示例：
- en: '*Source* *code: Example_Data_annomization.ipynb*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：Example_Data_annomization.ipynb'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This results in the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下输出：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we used Python’s `hashlib` library to hash the name and
    email fields of each record in the dataset using a random salt value. The hashed
    values are then stored in place of the original values. This technique can be
    used to protect the privacy of sensitive information in a dataset.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了Python的`hashlib`库，使用随机盐值对数据集中的每个记录的名称和电子邮件字段进行哈希处理。然后，将这些哈希值存储在原始值的位置。这种技术可以用来保护数据集中敏感信息的隐私。
- en: Is anonymization alone sufficient to protect sensitive data? In short, no, it
    is not sufficient, as we’ll see in the following case study from the real world.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的匿名化是否足以保护敏感数据？简而言之，不够，正如我们将在以下真实案例研究中看到的那样。
- en: Real-world case study (Netflix user data anonymization)
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实世界的案例研究（Netflix用户数据匿名化）
- en: Our Netflix data anonymization case study dates back to 2006 when Netflix launched
    the Netflix Prize, a competition aimed at improving the accuracy of the company’s
    recommendation algorithm.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Netflix数据匿名化案例研究可以追溯到2006年，当时Netflix推出了Netflix Prize，这是一项旨在提高公司推荐算法准确性的竞赛。
- en: As part of the competition, Netflix released a dataset containing the viewing
    history of 500,000 subscribers, with personally identifiable information removed.
    The dataset was made available to researchers to develop better algorithms. In
    2009, researchers published a paper that showed that it was possible to re-identify
    individuals in the Netflix dataset by using information from the **Internet Movie
    Database** (**IMDb**). The researchers were able to match the anonymized viewing
    history with the reviews that users had posted on IMDb, allowing them to re-identify
    individuals with high accuracy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为比赛的一部分，Netflix发布了一个包含50万订阅者观看历史的数据集，其中已移除个人可识别信息。该数据集可供研究人员开发更好的算法。2009年，研究人员发表了一篇论文，表明可以通过使用**互联网电影数据库**（**IMDb**）的信息来重新识别Netflix数据集中的个人。研究人员能够将匿名化的观看历史与用户在IMDb上发布的评论相匹配，从而以高精度重新识别个人。
- en: Following this discovery, Netflix took steps to improve its anonymization techniques,
    but in 2010, researchers once again showed that it was possible to re-identify
    individuals in the Netflix dataset. This time, researchers used external data
    sources such as social networks and movie rating websites to re-identify individuals.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一发现之后，Netflix采取了措施改进其匿名化技术，但到了2010年，研究人员再次表明，在Netflix数据集中重新识别个人是可能的。这一次，研究人员使用了外部数据源，如社交网络和电影评分网站来重新识别个人。
- en: In response to these privacy concerns, Netflix stopped releasing anonymized
    datasets to researchers in 2010\. Instead, the company created an internal research
    program where researchers could analyze Netflix data without any personally identifiable
    information being shared. However, in 2020, a group of researchers from the University
    of Texas at Austin and the University of California, Irvine showed that they could
    still re-identify Netflix users by analyzing their viewing history and correlating
    it with publicly available datasets. The researchers were able to accurately re-identify
    users even when no personally identifiable information was present in the Netflix
    dataset.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这些隐私问题，Netflix于2010年停止向研究人员发布匿名化数据集。相反，公司创建了一个内部研究项目，研究人员可以在不共享任何个人可识别信息的情况下分析Netflix数据。然而，到了2020年，德克萨斯大学奥斯汀分校和加州大学欧文分校的一组研究人员表明，他们可以通过分析观看历史并将其与公开可用的数据集相关联来重新识别Netflix用户。研究人员能够在Netflix数据集中没有个人可识别信息的情况下准确重新识别用户。
- en: These findings showed that the anonymization techniques alone were not enough
    to protect users’ privacy as they are prone to data linkage attacks, which we
    learned about in [*Chapter 1*](B16573_01.xhtml#_idTextAnchor015).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些发现表明，仅靠匿名化技术不足以保护用户隐私，因为它们容易受到数据关联攻击的影响，我们在[*第一章*](B16573_01.xhtml#_idTextAnchor015)中了解到这一点。
- en: Limitations of anonymization
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匿名化的局限性
- en: Anonymization may not completely eliminate the risk of re-identification. If
    enough data is available, it may be possible to identify individuals by linking
    the anonymized data with other available information such as public datasets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名化可能无法完全消除重新识别的风险。如果数据足够充分，通过将匿名化数据与其他可用信息（如公共数据集）关联，可能识别出个人。
- en: Anonymization may result in loss of data quality or accuracy, as certain data
    elements may be removed or masked in the process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名化可能导致数据质量或准确性的损失，因为在过程中可能会删除或掩盖某些数据元素。
- en: De-identification
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去标识化
- en: De-identification is the process of removing or masking identifiable information
    in data so that it cannot be used to identify individuals. The purpose of de-identification
    is to protect the privacy of individuals while still allowing the data to be used
    for research, analysis, or other applications. De-identified data may be used
    for healthcare research, marketing analysis, financial use cases, IoT use cases,
    and other applications where sensitive data is required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 去标识化是去除或掩盖数据中的可识别信息的过程，以便无法用于识别个人。去标识化的目的是在允许数据用于研究、分析或其他应用的同时保护个人隐私。去标识化数据可用于医疗保健研究、市场营销分析、金融用例、物联网用例和其他需要敏感数据的用例。
- en: De-identification algorithms
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 去标识化算法
- en: One-way hashing algorithms can be used to run de-identification processes on
    data. One-way hashing algorithms, also known as cryptographic hash functions,
    are mathematical functions that take an input message of any length and generate
    a fixed-size output, which is referred to as a hash or message digest. The key
    property of one-way hash algorithms is that they are designed such that it should
    be computationally infeasible to reverse-engineer the original input message from
    the hash value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单向哈希算法可用于对数据进行去标识化处理。单向哈希算法，也称为加密哈希函数，是数学函数，它接受任何长度的输入消息并生成一个固定大小的输出，这被称为哈希或信息摘要。单向哈希算法的关键特性是它们被设计成从哈希值中逆向工程原始输入消息在计算上是不可行的。
- en: There are many different hashing algorithms, and new ones are continually being
    developed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的哈希算法，并且新的算法正在不断被开发。
- en: 'The following are some of the most widely used hashing algorithms:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最广泛使用的哈希算法：
- en: '**Message Digest 5** (**MD5**): This is a widely used hashing algorithm that
    produces a 128-bit hash value. It is now considered to be insecure due to vulnerabilities
    in its design.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息摘要 5** (**MD5**): 这是一个广泛使用的哈希算法，它产生一个 128 位的哈希值。由于设计中的漏洞，现在被认为是不安全的。'
- en: '**Secure Hash Algorithm 1** (**SHA-1**): This is another widely used hashing
    algorithm that produces a 160-bit hash value. It is also now considered to be
    insecure.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全哈希算法 1** (**SHA-1**): 这是另一个广泛使用的哈希算法，它产生一个 160 位的哈希值。现在它被认为是不安全的。'
- en: '**Secure Hash Algorithm 2** (**SHA-2**): This is a family of hashing algorithms
    that includes SHA-224, SHA-256, SHA-384, and SHA-512\. These algorithms produce
    hash values of 224, 256, 384, and 512 bits, respectively.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全哈希算法 2** (**SHA-2**): 这是一个包括 SHA-224、SHA-256、SHA-384 和 SHA-512 的哈希算法系列。这些算法分别产生
    224 位、256 位、384 位和 512 位的哈希值。'
- en: '**Secure Hash Algorithm 3** (**SHA-3**): This is a family of hashing algorithms
    that includes SHA3-224, SHA3-256, SHA3-384, and SHA3-512\. These algorithms are
    designed as a replacement for SHA-2 and produce hash values of 224, 256, 384,
    and 512 bits, respectively.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全哈希算法 3** (**SHA-3**): 这是一个包括 SHA3-224、SHA3-256、SHA3-384 和 SHA3-512 的哈希算法系列。这些算法被设计为
    SHA-2 的替代品，并分别产生 224 位、256 位、384 位和 512 位的哈希值。'
- en: '**BLAKE2**: This is a family of hashing algorithms that includes BLAKE2b and
    BLAKE2s. These algorithms were designed to be faster than SHA-3 while still providing
    strong security.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BLAKE2**: 这是一个包括 BLAKE2b 和 BLAKE2s 的哈希算法系列。这些算法被设计得比 SHA-3 更快，同时仍然提供强大的安全性。'
- en: '**RACE Integrity Primitives Evaluation Message Digest** (**RIPEMD**): This
    is a family of hashing algorithms that includes RIPEMD-128, RIPEMD-160, RIPEMD-256,
    and RIPEMD-320\. These algorithms were designed as a replacement for the MD4 and
    MD5 algorithms and produce hash values of 128, 160, 256, and 320 bits, respectively.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RACE 完整性原语评估信息摘要** (**RIPEMD**): 这是一个包括 RIPEMD-128、RIPEMD-160、RIPEMD-256
    和 RIPEMD-320 的哈希算法系列。这些算法被设计为 MD4 和 MD5 算法的替代品，并分别产生 128 位、160 位、256 位和 320 位的哈希值。'
- en: '**Whirlpool**: This is a hashing algorithm that produces a 512-bit hash value.
    It was designed to be an alternative to the SHA-2 family of algorithms.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Whirlpool**: 这是一个产生 512 位哈希值的哈希算法。它被设计为 SHA-2 算法系列的替代品。'
- en: These are some of the examples of hashing algorithms available. The choice of
    which algorithm to use will depend on the specific application and the desired
    balance between security, speed, and other factors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可用的哈希算法的一些示例。选择使用哪种算法将取决于具体的应用和所需的在安全性、速度和其他因素之间的平衡。
- en: Example Python code to de-identify the data
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于去标识化数据的示例 Python 代码
- en: As discussed, De-identification is the process of removing or masking identifiable
    information in data so that it cannot be used to identify the original data. In
    the code below, let’s de-identify a given data (in this case a string) using the
    SHA256 hashing algorithm.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，去标识化是删除或屏蔽数据中的可识别信息的过程，以便无法用它来识别原始数据。在下面的代码中，我们将使用 SHA256 哈希算法对给定的数据（在这种情况下是一个字符串）进行去标识化。
- en: '*Source code:* *De-Identify_Exmple.ipynb*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码:* *De-Identify_Exmple.ipynb*'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This results in the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `hashlib` library is used to compute a SHA-256 hash of
    a given input string. We define a `deidentify_data` function that takes data as
    input, removes any leading/trailing whitespace, converts the data to lowercase,
    and then hashes it using the `hash_string` function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，使用 `hashlib` 库计算给定输入字符串的 SHA-256 哈希。我们定义了一个 `deidentify_data` 函数，该函数接受数据作为输入，删除任何前导/尾随空白，将数据转换为小写，然后使用
    `hash_string` 函数对其进行哈希处理。
- en: This ensures that the same input name will always produce the same output hash.
    Note that because one-way hashing is an irreversible process, there is no way
    to retrieve the original name from the hashed value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了相同的输入名称将始终产生相同的输出哈希。请注意，由于单向哈希是一个不可逆的过程，因此无法从哈希值中检索原始名称。
- en: 'The `hashlib` library in Python provides a collection of hashing algorithms.
    The following methods are available in the `hashlib` library:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 `hashlib` 库提供了一系列哈希算法。`hashlib` 库中可用的方法如下：
- en: '**hashlib.md5()**: This method returns an MD5 hash object'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.md5()**: 此方法返回一个 MD5 哈希对象'
- en: '**hashlib.sha1()**: This method returns a SHA-1 hash object'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha1()**: 此方法返回一个 SHA-1 哈希对象'
- en: '**hashlib.sha224()**: This method returns a SHA-224 hash object'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha224()**: 此方法返回一个 SHA-224 哈希对象'
- en: '**hashlib.sha256()**: This method returns a SHA-256 hash object'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha256()**: 此方法返回一个 SHA-256 哈希对象'
- en: '**hashlib.sha384()**: This method returns a SHA-384 hash object'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha384()**: 此方法返回一个 SHA-384 哈希对象'
- en: '**hashlib.sha512()**: This method returns a SHA-512 hash object'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha512()**: 此方法返回一个 SHA-512 哈希对象'
- en: '**hashlib.blake2s()**: This method returns a BLAKE2s hash object'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.blake2s()**: 此方法返回一个 BLAKE2s 哈希对象'
- en: '**hashlib.blake2b()**: This method returns a BLAKE2b hash object'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.blake2b()**: 此方法返回一个 BLAKE2b 哈希对象'
- en: '**hashlib.sha3_224()**: This method returns a SHA3-224 hash object'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha3_224()**: 此方法返回一个 SHA3-224 哈希对象'
- en: '**hashlib.sha3_256()**: This method returns a SHA3-256 hash object'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha3_256()**: 此方法返回一个 SHA3-256 哈希对象'
- en: '**hashlib.sha3_384()**: This method returns a SHA3-384 hash object'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha3_384()**: 此方法返回一个 SHA3-384 哈希对象'
- en: '**hashlib.sha3_512()**: This method returns a SHA3-512 hash object'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hashlib.sha3_512()**: 此方法返回一个 SHA3-512 哈希对象'
- en: The purpose of de-identification is to make it difficult or impossible to identify
    individuals based on their personal information.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 去标识化的目的是使个人信息难以或无法识别个人。
- en: Limitations of de-identification
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 去标识化的局限性
- en: De-identification may not completely eliminate the risk of re-identification.
    If enough data is available, it may be possible to identify individuals based
    on other available information. De-identification may result in the loss of data
    quality or accuracy, as certain data elements may be removed or masked in the
    process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 去标识化可能无法完全消除重新识别的风险。如果数据足够多，可能根据其他可用信息识别个人。去标识化可能导致数据质量或准确性下降，因为在处理过程中可能会删除或掩盖某些数据元素。
- en: In summary, each technique has its own strengths and limitations, and the appropriate
    technique should be selected based on the specific use case and requirements.
    Encryption is the most secure way to protect data, but it does not provide anonymity
    or de-identification. Anonymization and de-identification can both provide privacy
    protection, but they may not be sufficient in all cases and may result in data
    quality or accuracy issues.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，每种技术都有其自身的优势和局限性，应根据具体的使用场景和需求选择合适的技术。加密是保护数据最安全的方式，但它不提供匿名性或去标识化。匿名化和去标识化都可以提供隐私保护，但在所有情况下可能并不足够，并可能导致数据质量或准确性问题。
- en: Exploring Homomorphic encryption
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索同态加密
- en: '**Homomorphic Encryption** (**HE**) is a cryptographic technique that allows
    computation on encrypted data without decrypting it. In other words, it is possible
    to perform operations on ciphertexts, generating new ciphertexts that are decrypted
    to the result of the operation on the plaintexts. HE has the potential to revolutionize
    data privacy and security, enabling secure computation of sensitive data without
    revealing the data itself. HE is based on mathematical concepts such as algebraic
    structures, number theory, and polynomial theory. The most common types of HE
    are based on the following algebraic structures.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**同态加密**（**HE**）是一种加密技术，允许在不解密数据的情况下对加密数据进行计算。换句话说，可以对密文执行操作，生成新的密文，这些密文解密后即为对明文操作的结果。HE
    有潜力彻底改变数据隐私和安全，允许在不泄露数据本身的情况下安全地计算敏感数据。HE 基于数学概念，如代数结构、数论和多项式理论。最常见的 HE 类型基于以下代数结构。'
- en: Ring-based
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于环
- en: In the context of cryptography, an algebraic structure refers to a set of mathematical
    operations that can be performed on elements of the set in a specific way. In
    the case of a ring, the set of elements is closed under addition and multiplication,
    and the operations satisfy certain properties, such as associativity, commutativity,
    and the existence of an identity element and inverse elements. In the context
    of HE, an algebraic structure is used to perform computations on encrypted data
    without first decrypting it. The underlying algebraic structure is a ring, which
    is a set of elements with two binary operations (addition and multiplication)
    that satisfy certain properties. The most widely used ring-based HE is the **Brakerski-Gentry-Vaikuntanathan**
    (**BGV**) scheme.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学的背景下，代数结构指的是可以在集合的元素上以特定方式执行的一组数学运算。在环的情况下，元素集合在加法和乘法下是封闭的，并且操作满足某些性质，例如结合性、交换性和存在单位元素和逆元素。在HE的背景下，代数结构用于在加密数据上执行计算，而无需首先解密它。底层代数结构是一个环，它是一组元素，具有满足某些性质的两个二元运算（加法和乘法）。最广泛使用的基于环的HE是**Brakerski-Gentry-Vaikuntanathan**（**BGV**）方案。
- en: The BGV scheme is a **fully homomorphic encryption** (**FHE**) scheme based
    on the **learning with errors** (**LWE**) problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: BGV方案是基于**学习错误**（**LWE**）问题的**全同态加密**（**FHE**）方案。
- en: Let’s now examine a mathematical description of the scheme.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来考察该方案的数学描述。
- en: Key generation
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密钥生成
- en: 'To generate a public key, the following steps are performed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成公钥，执行以下步骤：
- en: Choose two integers n and q, where q is a prime number.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择两个整数n和q，其中q是素数。
- en: Generate a random matrix A with integer entries in the range [-q/2, q/2].
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个具有整数项且在范围[-q/2, q/2]内的随机矩阵A。
- en: Generate a random vector with integer entries in the range [-q/2, q/2].
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个具有整数项且在范围[-q/2, q/2]内的随机向量。
- en: Compute the vector b = As + e, where e is a random vector with entries in the
    range [-B/2, B/2] for some integer B.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算向量b = As + e，其中e是具有范围[-B/2, B/2]的随机向量，B是某个整数。
- en: Set the public key to be (A, b).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将公钥设置为(A, b)。
- en: To generate a secret key, a random vector s is chosen with integer entries in
    the range [-q/2, q/2].
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成私钥，选择一个具有整数项且在范围[-q/2, q/2]内的随机向量s。
- en: Encryption
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密
- en: 'To encrypt a message m, the following steps are performed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密消息m，执行以下步骤：
- en: Represent the message m as a polynomial m(x) with integer coefficients modulo
    q.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息m表示为具有模q整数系数的多项式m(x)。
- en: Choose a random polynomial r(x) with integer coefficients modulo q.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个具有模q整数系数的随机多项式r(x)。
- en: Compute c = (A*r + b + m(x)*t)/q, where t is a scaling factor that controls
    the noise in the ciphertext.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算c = (A*r + b + m(x)*t)/q，其中t是控制密文噪声的缩放因子。
- en: The resulting ciphertext c consists of a matrix and a polynomial.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的密文c由一个矩阵和一个多项式组成。
- en: Decryption
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解密
- en: 'To decrypt a ciphertext c, the following steps are performed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密密文c，执行以下步骤：
- en: Compute c’ = c*s/q.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算新的c’ = c*s/q。
- en: Round each entry of c’ to the nearest integer.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将c’的每个条目四舍五入到最接近的整数。
- en: Recover the polynomial m(x) by subtracting A*r from c’.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从c’中减去A*r来恢复多项式m(x)。
- en: Homomorphic operations
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同态操作
- en: 'The BGV scheme allows homomorphic addition and multiplication on ciphertexts.
    These operations are performed as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: BGV方案允许在密文上执行同态加法和乘法。这些操作如下所示：
- en: 'Homomorphic addition: To add two ciphertexts c1 and c2, add their corresponding
    polynomials modulo q, and add their matrices element-wise modulo q.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同态加法：为了将两个密文c1和c2相加，将它们对应的多项式在模q下相加，并逐元素地将它们的矩阵相加，模q。
- en: 'Homomorphic multiplication: To multiply two ciphertexts c1 and c2, compute
    their product modulo q using the polynomial multiplication algorithm, and multiply
    their matrices using matrix multiplication modulo q.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同态乘法：为了将两个密文c1和c2相乘，使用多项式乘法算法计算它们在模q下的乘积，并使用模q的矩阵乘法来乘以它们的矩阵。
- en: Bootstrapping
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自举
- en: To perform more than one homomorphic multiplication, the BGV scheme uses a technique
    called bootstrapping to “refresh” the ciphertext. The bootstrapping process involves
    decoding the ciphertext, performing a homomorphic operation, and then re-encrypting
    the result with a new set of keys. The bootstrapping process allows an arbitrary
    number of homomorphic operations to be performed on the ciphertext while still
    maintaining the security of the scheme.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行多个同态乘法，BGV方案使用一种称为引导（bootstrapping）的技术来“刷新”密文。引导过程包括解码密文，执行同态运算，然后使用一组新密钥重新加密结果。引导过程允许在保持方案安全性的同时，在密文中执行任意数量的同态运算。
- en: Lattice-based
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于格的
- en: HE based on lattices uses the mathematical concept of lattices, which are geometric
    structures in higher dimensions that allow the efficient computation of certain
    types of problems. The most widely used lattice-based HE is the FHE scheme.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于格的HE使用数学概念格，这是高维空间中的几何结构，允许高效地计算某些类型的问题。最广泛使用的基于格的HE是FHE方案。
- en: Elliptic curve-based
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于椭圆曲线的
- en: HE based on elliptic curves uses elliptic curves over finite fields to create
    the cryptographic scheme. This type of HE is relatively new, and not as widely
    used as the other two types.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于椭圆曲线的HE使用有限域上的椭圆曲线来创建加密方案。这种类型的HE相对较新，不如其他两种类型广泛使用。
- en: Exploring the mathematics behind HE
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索HE背后的数学
- en: 'The mathematics behind HE is based on two main concepts: encryption and homomorphism.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: HE背后的数学基于两个主要概念：加密和同态。
- en: Encryption
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密
- en: Encryption is the process of transforming plaintext into ciphertext using an
    encryption algorithm and a secret key. The ciphertext can then be transmitted
    over a network or stored in a database without fear of unauthorized access. To
    decrypt the ciphertext and obtain the plaintext, the recipient must possess the
    secret key that was used to encrypt the data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是将明文通过加密算法和密钥转换成密文的过程。密文可以在网络上传输或存储在数据库中，而不用担心未授权的访问。要解密密文并获取明文，接收者必须拥有用于加密数据的密钥。
- en: Homomorphism
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同态
- en: Homomorphism is a mathematical property that allows an operation to be performed
    on ciphertexts, generating a new ciphertext that is the result of the operation
    on the plaintexts. This means that if we have two plaintexts x and y, and their
    respective ciphertexts C(x) and C(y), we can perform an operation on C(x) and
    C(y) to obtain a new ciphertext C(x+y), which can be decrypted to obtain the result
    of the operation on x and y.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 同态是一种数学属性，允许在密文中执行运算，生成一个新的密文，它是明文运算的结果。这意味着如果我们有两个明文x和y，以及它们各自的密文C(x)和C(y)，我们可以在C(x)和C(y)上执行一个运算，以获得一个新的密文C(x+y)，该密文可以解密以获得x和y运算的结果。
- en: The most commonly used homomorphic operations are addition and multiplication,
    but other operations such as subtraction and division can also be performed. The
    level of homomorphism determines how many operations can be performed on the ciphertexts
    before the noise introduced during the encryption process becomes too high and
    the ciphertext becomes unusable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的同态运算是加法和乘法，但也可以执行减法和除法等其他运算。同态运算的水平决定了在加密过程中引入的噪声变得过高，密文变得无法使用之前，可以在密文中执行多少操作。
- en: HE is based on the concept of adding noise to the ciphertext to make it impossible
    to recover the plaintext without the secret key. The noise is added in such a
    way that homomorphic operations can be performed on the ciphertext without revealing
    the plaintext. The amount of noise added determines the level of security of the
    encryption. The noise is also the reason why the level of homomorphism is limited
    in HE, as too many homomorphic operations can cause the noise to become too high
    and the ciphertext to become unusable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: HE基于向密文中添加噪声的概念，使得没有密钥就无法恢复明文。噪声以这种方式添加，使得可以在不泄露明文的情况下对密文执行同态运算。添加的噪声量决定了加密的安全性级别。噪声也是同态运算水平受限的原因，因为过多的同态运算会导致噪声过高，使得密文无法使用。
- en: Types of HE
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HE的类型
- en: There are three types of implementation for HE. Let’s examine them now.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: HE有三种实现类型。现在让我们来探讨它们。
- en: Fully Homomorphic Encryption (FHE)
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全同态加密（FHE）
- en: FHE is a type of encryption that allows computation to be performed on encrypted
    data without decrypting it. It means that the ciphertext can be used as input
    for a computation and the result will be a ciphertext as well, which can be decrypted
    to get the result of the computation. FHE is a powerful tool that can be used
    in various applications such as cloud computing, machine learning, and secure
    outsourcing. One of the main challenges of FHE is its computational complexity,
    which makes it impractical for many applications. However, recent advancements
    in FHE have led to the development of more efficient algorithms that reduce the
    computational overhead of FHE.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: FHE是一种允许在加密数据上执行计算而不解密的加密类型。这意味着密文可以用作计算的输入，计算结果也将是密文，该密文可以被解密以获取计算结果。FHE是一种强大的工具，可用于各种应用，如云计算、机器学习和安全外包。FHE的主要挑战之一是其计算复杂性，这使得它在许多应用中不切实际。然而，FHE的近期进展导致了更高效算法的发展，这些算法降低了FHE的计算开销。
- en: The Gentry scheme is one of the earliest and most well-known FHE schemes, but
    it has a high computational cost. More recent schemes, such as the CKKS scheme
    and the BFV scheme, offer more efficient FHE algorithms that are suitable for
    practical applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Gentry方案是早期且最著名的FHE方案之一，但它具有很高的计算成本。更近期的方案，如CKKS方案和BFV方案，提供了更高效的FHE算法，适用于实际应用。
- en: Somewhat Homomorphic Encryption (SHE)
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分同态加密（SHE）
- en: SHE is a type of encryption that allows limited computations on encrypted data.
    Unlike FHE, SHE cannot perform arbitrary computations on encrypted data. Instead,
    it can only perform a limited set of operations, such as addition and multiplication,
    on the encrypted data. While SHE is less powerful than FHE, it is still useful
    in many applications, such as secure voting, secure messaging, and secure database
    queries. SHE is less computationally intensive than FHE, which makes it more practical
    for certain applications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: SHE是一种允许在加密数据上执行有限计算的加密类型。与FHE不同，SHE不能在加密数据上执行任意计算。相反，它只能在加密数据上执行有限的操作集，例如加法和乘法。虽然SHE在功能上不如FHE强大，但它仍然在许多应用中很有用，例如安全投票、安全消息传递和安全数据库查询。SHE的计算复杂度低于FHE，这使得它在某些应用中更加实用。
- en: Partially Homomorphic Encryption (PHE)
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分同态加密（PHE）
- en: PHE is a type of encryption that allows for computations on encrypted data,
    but only for one type of operation, either addition or multiplication. PHE is
    less powerful than both FHE and SHE but is still useful in some applications,
    such as secure key generation, secure function evaluation, and secure scalar product
    calculation. PHE is less computationally intensive than both FHE and SHE, which
    makes it more practical for some applications. However, its limited functionality
    means that it is less flexible than FHE and SHE and cannot be used in as many
    applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: PHE是一种允许对加密数据进行计算的加密类型，但仅限于一种操作，要么是加法要么是乘法。PHE在功能上不如FHE和SHE强大，但在某些应用中仍然有用，例如安全密钥生成、安全函数评估和安全标量积计算。PHE的计算复杂度低于FHE和SHE，这使得它在某些应用中更加实用。然而，其有限的功能意味着它不如FHE和SHE灵活，并且不能用于那么多的应用。
- en: FHE, SHE, and PHE are three related encryption schemes that provide different
    levels of functionality and computational complexity. FHE is the most powerful
    but also the most computationally intensive, while PHE is the least powerful but
    also the least computationally intensive. SHE provides a middle ground between
    FHE and PHE in terms of functionality and computational complexity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: FHE、SHE和PHE是三种相关的加密方案，提供了不同层次的功能和计算复杂性。FHE功能最强大，但计算复杂度也最高，而PHE功能最弱，但计算复杂度也最低。SHE在功能和计算复杂性方面介于FHE和PHE之间。
- en: Paillier scheme
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Paillier方案
- en: The Paillier scheme is a public key cryptosystem that is used for the encryption
    and decryption of data. It is based on the mathematical assumption i.e **decisional
    composite residuality assumption** (**DCRA**), which is a hard computational problem.
    The scheme is named after its creator, Pascal Paillier, who introduced it in 1999.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Paillier方案是一种用于数据加密和解密的公钥密码系统。它基于数学假设，即**决策复合剩余性假设**（**DCRA**），这是一个计算难题。该方案以它的创造者Pascal
    Paillier的名字命名，他在1999年引入了它。
- en: 'The Paillier scheme is an asymmetric encryption algorithm, which means that
    it uses two different keys: a public key for encryption and a private key for
    decryption. The scheme is designed to be probabilistic, which means that each
    encryption of a given plaintext results in a different ciphertext. The scheme
    is also homomorphic, which means that it supports certain types of operations
    on the encrypted data.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Paillier方案是一种非对称加密算法，这意味着它使用两个不同的密钥：一个公钥用于加密，一个私钥用于解密。该方案被设计为概率性的，这意味着对给定明文的每次加密都会产生不同的密文。该方案也是同态的，这意味着它支持对加密数据执行某些类型的操作。
- en: Key generation
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密钥生成
- en: To use the Paillier scheme, a user first generates a public key and a corresponding
    private key. The public key consists of two large prime numbers, p and q, which
    are kept secret. The user then calculates n = p * q and lambda = LCM(p - 1, q
    - 1), where LCM is the least common multiple function. The value of lambda is
    used to generate the private key.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Paillier方案，用户首先生成一个公钥和一个相应的私钥。公钥由两个大素数p和q组成，这些数是保密的。然后，用户计算n = p * q和lambda
    = LCM(p - 1, q - 1)，其中LCM是最小公倍数函数。lambda的值用于生成私钥。
- en: Encryption
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密
- en: To encrypt a message, the sender uses the recipient’s public key. The plaintext
    message is represented as an integer m, where 0 <= m < n. The sender then chooses
    a random number r, where 0 <= r < n, and computes c = g^m * r^n mod n^2, where
    g is a random generator modulo n^2\. The ciphertext c is then sent to the recipient.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密消息，发送者使用接收者的公钥。明文消息表示为一个整数m，其中0 <= m < n。然后，发送者选择一个随机数r，其中0 <= r < n，并计算c
    = g^m * r^n mod n^2，其中g是n^2模下的随机生成器。然后，将密文c发送给接收者。
- en: Decryption
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解密
- en: To decrypt the ciphertext, the recipient uses their private key. The recipient
    first computes the value of
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密密文，接收者使用他们的私钥。接收者首先计算以下值
- en: '**mu = (L(g^lambda mod n^2)^-1 mod n)^(lambda^-1** **mod n)**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**mu = (L(g^lambda mod n^2)^-1 mod n)^(lambda^-1** **mod n)**'
- en: where
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '**L(x) = (x - 1) / n**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**L(x) = (x - 1) / n**'
- en: 'The value of mu is used to calculate the plaintext message m as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mu值来计算明文消息m，如下所示：
- en: '**m = L(c^lambda mod n^2) * mu** **mod n**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**m = L(c^lambda mod n^2) * mu** **mod n**'
- en: The recipient can then recover the original message from m.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，接收者可以从m中恢复原始消息。
- en: Homomorphic properties
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同态属性
- en: 'The Paillier scheme supports two homomorphic properties: additive and multiplicative.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Paillier方案支持两种同态属性：加法和乘法。
- en: The additive property allows the recipient to perform addition on the encrypted
    data. Given two ciphertexts c1 and c2 that correspond to plaintext messages m1
    and m2, the recipient can compute a new ciphertext c3 that corresponds to the
    sum of m1 and m2 by multiplying c1 * c2 mod n^2.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 加法属性允许接收者对加密数据进行加法操作。给定两个对应于明文消息m1和m2的密文c1和c2，接收者可以通过将c1 * c2模n^2来计算一个新的密文c3，该密文对应于m1和m2的和。
- en: The multiplicative property allows the recipient to perform multiplication on
    the encrypted data. Given a ciphertext c that corresponds to a plaintext message
    m, the recipient can compute a new ciphertext c’ that corresponds to the product
    of m and a constant k by raising c to the power of k mod n^2.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法属性允许接收者对加密数据进行乘法操作。给定一个对应于明文消息m的密文c，接收者可以通过将c提升到k次幂并取模n^2来计算一个新的密文c'，该密文对应于m和常数k的乘积。
- en: Security
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性
- en: The Paillier scheme is also resistant to known plaintext attacks and chosen
    plaintext attacks. The scheme is used in various applications, including electronic
    voting, privacy-preserving data mining, and secure multiparty computation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Paillier方案也抵抗已知的明文攻击和选择明文攻击。该方案被用于各种应用中，包括电子投票、隐私保护数据挖掘和安全的多方计算。
- en: Python frameworks for HE the following section, we will cover the open source
    Python frameworks that are used to implement HE. We will implement a few examples
    in detail to understand homomorphic operations in a better way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍用于实现HE的Python框架。我们将详细实现一些示例，以便更好地理解同态操作。
- en: Pyfhel
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pyfhel
- en: Pyfhel is a Python library for FHE. It provides an easy-to-use interface for
    performing FHE operations on encrypted data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Pyfhel是一个用于FHE的Python库。它提供了一个易于使用的接口，用于在加密数据上执行FHE操作。
- en: 'URL: [https://pyfhel.readthedocs.io/en/latest/](https://pyfhel.readthedocs.io/en/latest/)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'URL: [https://pyfhel.readthedocs.io/en/latest/](https://pyfhel.readthedocs.io/en/latest/)'
- en: SEAL Python
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SEAL Python
- en: SEAL Python is a Python wrapper for the **Simple Encrypted Arithmetic Library**
    (**SEAL**) C++ library. SEAL Python provides a high-level interface for performing
    HE and decryption operations on data using the Brakerski/Fan-Vercauteren (BFV)
    and Cheon-Kim-Kim-Song (CKKS) schemes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SEAL Python 是一个用于 **Simple Encrypted Arithmetic Library** (**SEAL**) C++ 库的
    Python 封装。SEAL Python 提供了一个高级接口，用于使用 Brakerski/Fan-Vercauteren (BFV) 和 Cheon-Kim-Kim-Song
    (CKKS) 方案在数据上执行同态加密和解密操作。
- en: 'URL: [https://github.com/Huelse/SEAL-Python](https://github.com/Huelse/SEAL-Python)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'URL: [https://github.com/Huelse/SEAL-Python](https://github.com/Huelse/SEAL-Python)'
- en: TenSEAL
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TenSEAL
- en: TenSEAL is a Python library for homomorphic encryption on *n* tensors, built
    on top of Microsoft SEAL and using the CKKS scheme. It provides an easy-to-use
    interface for performing FHE operations on encrypted data with support for batching
    and batching rotations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: TenSEAL 是一个在 *n* 张张量上执行同态加密的 Python 库，基于 Microsoft SEAL 并使用 CKKS 方案。它提供了一个易于使用的接口，用于在加密数据上执行
    FHE 操作，并支持批处理和批处理旋转。
- en: 'The main features offered by TenSEAL are the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: TenSEAL 提供的主要功能如下：
- en: Encryption/decryption of the vectors of integers using BFV
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 BFV 对整数向量进行加密/解密
- en: Encryption/decryption of the vectors of real numbers using CKKS
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CKKS 对实数向量进行加密/解密
- en: Element-wise addition, subtraction, and multiplication of encrypted-encrypted
    vectors and encrypted-plain vectors
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密-加密向量和加密-明文向量逐元素加法、减法和乘法
- en: Dot product and vector-matrix multiplication
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点积和向量-矩阵乘法
- en: 'URL: [https://github.com/OpenMined/TenSEAL](https://github.com/OpenMined/TenSEAL)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'URL: [https://github.com/OpenMined/TenSEAL](https://github.com/OpenMined/TenSEAL)'
- en: phe
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: phe
- en: phe is a Python library for **partially homomorphic encryption** (**PHE**) using
    the Paillier scheme. It provides an API for performing PHE operations on encrypted
    data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: phe 是一个使用 Paillier 方案进行 **部分同态加密** (**PHE**) 的 Python 库。它提供了一个 API，用于在加密数据上执行
    PHE 操作。
- en: It is a simple and easy-to-use library. It only supports three operations (addition,
    subtraction, and scalar multiplication) on HE out of four operations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个简单易用的库。它只支持四个操作中的三个（加法、减法和标量乘法）在 HE 上。
- en: 'URL: [https://pypi.org/project/phe/](https://pypi.org/project/phe/)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'URL: [https://pypi.org/project/phe/](https://pypi.org/project/phe/)'
- en: The homomorphic properties of the Paillier cryptographic system work as follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Paillier 密码系统的同态属性工作如下。
- en: 'Encrypted numbers can be added together:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 加密的数字可以相加：
- en: Enc(m1)+Enc(m2)≡Enc(m1+m2)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Enc(m1)+Enc(m2)≡Enc(m1+m2)
- en: '![Figure 8.1 – Homomorphic addition](img/B16573_08_01.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 同态加法](img/B16573_08_01.jpg)'
- en: Figure 8.1 – Homomorphic addition
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 同态加法
- en: 'Encrypted numbers can be subtracted from each other:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加密的数字可以相互减去：
- en: Enc(m1)-Enc(m2)≡Enc(m1-m2)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Enc(m1)-Enc(m2)≡Enc(m1-m2)
- en: '![Figure 8.2 – Homomorphic subtraction](img/B16573_08_02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 同态减法](img/B16573_08_02.jpg)'
- en: Figure 8.2 – Homomorphic subtraction
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 同态减法
- en: 'Encrypted numbers can be multiplied by a non-encrypted scalar:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 加密的数字可以乘以一个非加密标量：
- en: n⋅Enc(m) ≡ Enc(n*m)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: n⋅Enc(m) ≡ Enc(n*m)
- en: "![Figure 8.3 – Homomorphic-encrypted nu\uFEFFmber multiplied by a non-encrypted\
    \ scalar](img/B16573_08_03.jpg)"
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 同态加密的数字乘以非加密标量](img/B16573_08_03.jpg)'
- en: Figure 8.3 – Homomorphic-encrypted number multiplied by a non-encrypted scalar
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 同态加密的数字乘以非加密标量
- en: 'Encrypted numbers can be added to non-encrypted scalars:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 加密的数字可以加到非加密标量上：
- en: n+Enc(m) ≡ Enc(n+m)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: n+Enc(m) ≡ Enc(n+m)
- en: '![Figure 8.4 – Homomorphic-encrypted number added to a non-encrypted scalar](img/B16573_08_04.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 同态加密的数字加到非加密标量上](img/B16573_08_04.jpg)'
- en: Figure 8.4 – Homomorphic-encrypted number added to a non-encrypted scalar
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 同态加密的数字加到非加密标量上
- en: Implementing HE
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 HE
- en: 'To implement HE, choose a suitable HE library from those outlined previously.
    Make sure your choice is appropriate based on your specific use case, then perform
    the following steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 HE，从之前概述的库中选择一个合适的 HE 库。确保你的选择基于你的特定用例，然后执行以下步骤：
- en: Generate the public and private keys required for the encryption scheme.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成加密方案所需的公钥和私钥。
- en: Convert the plaintext data that needs to be encrypted into a suitable format
    for the encryption scheme, such as a polynomial.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将需要加密的明文数据转换为加密方案所需的合适格式，例如多项式。
- en: Encrypt the plaintext data using the public key generated in *step 2*.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在 *步骤2* 中生成的公钥加密明文数据。
- en: Perform the homomorphic operations on the ciphertext data without decrypting
    it.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在密文数据上执行同态操作，而不进行解密。
- en: Decrypt the resulting ciphertext data using the private key generated in *step
    2* to obtain the result of the homomorphic operations on the plaintext data.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在 *步骤 2* 中生成的私钥解密生成的密文数据，以获得对明文数据进行同态运算的结果。
- en: Implementing HE can be complex and requires expertise in cryptography and mathematics.
    It is important to ensure that the implementation is secure and efficient, as
    HE can be computationally intensive.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 HE 可能很复杂，需要密码学和数学方面的专业知识。确保实现既安全又高效很重要，因为 HE 可能计算密集。
- en: Implementing PHE
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 PHE
- en: We will implement an example of Paillier PHE using the open source `phe` Python
    library.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用开源的 `phe` Python 库实现 Paillier PHE 的一个示例。
- en: 'First, we install the `phe` library as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们按照以下方式安装 `phe` 库：
- en: '[PRE8]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we implement the following steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行以下步骤：
- en: Generate the public and private keys using the **generate_paillier_keypair**
    method from **phe.paillier** class.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **phe.paillier** 类中的 **generate_paillier_keypair** 方法生成公钥和私钥。
- en: Encrypt the plaintext data (15 in this example) using the **encrypt** method.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **encrypt** 方法加密明文数据（本例中为 15）。
- en: 'Perform homomorphic operations on the ciphertext data:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对密文数据进行同态运算：
- en: ciphertext1 = ciphertext * 3 // encrypted number multiplied by a scalar
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ciphertext1 = ciphertext * 3 // 加密数字乘以一个标量
- en: ciphertext2 = ciphertext + ciphertext1 // adding two encrypted numbers
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ciphertext2 = ciphertext + ciphertext1 // 两个加密数字相加
- en: ciphertext3 = ciphertext1 + 250 // adding scalar to a encrypted number
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ciphertext3 = ciphertext1 + 250 // 将标量加到一个加密数字上
- en: ciphertext4 = ciphertext3 - ciphertext2
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ciphertext4 = ciphertext3 - ciphertext2
- en: Finally, decrypt the resulting ciphertext data using the **decrypt** method
    and print the decrypted results.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用 **decrypt** 方法解密生成的密文数据，并打印解密结果。
- en: '*Source* *code: FHE-Example.ipynb*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：FHE-Example.ipynb'
- en: '[PRE9]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How about multiplying an encrypted number with another encrypted number?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个加密数字乘以另一个加密数字怎么样？
- en: Will the following work with PHE?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作与 PHE 是否兼容？
- en: Enc(m1) * Enc(m2)≡Enc(m1* m2)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Enc(m1) * Enc(m2)≡Enc(m1 * m2)
- en: 'Let’s try this and find out:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个，看看结果如何：
- en: '[PRE10]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It throws *NotImplementedError*, which basically means that phe doesn’t support
    this (multiplying an encrypted number with another encrypted number) property
    of HE.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它抛出 *NotImplementedError*，这基本上意味着 phe 不支持这个（将一个加密数字与另一个加密数字相乘）HE 属性。
- en: When your requirements call for developing applications involving tensors, matrices,
    arrays, and all homomorphic operations, TenSEAL is the best framework to use.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的需求需要开发涉及张量、矩阵、数组以及所有同态运算的应用程序时，TenSEAL 是最佳框架。
- en: Implementing HE using the TenSEAL library
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TenSEAL 库实现 HE
- en: We will implement an example of HE using the open source TenSEAL Python library.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用开源的 TenSEAL Python 库实现 HE 的一个示例。
- en: 'First, we install the TenSEAL library as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们按照以下方式安装 TenSEAL 库：
- en: '[PRE11]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Source* *code :TenSeal_Example.ipynb*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：TenSeal_Example.ipynb'
- en: Develop the sample applictions in the following way.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式开发示例应用程序。
- en: '[PRE12]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example code, we first create a context using the CKKS scheme
    with a polynomial modulus degree of 8,192 and four coefficient modulus bit sizes
    of 60, 40, 40, and 60\. Then, we create two CKKS vectors and encrypt our data.
    Next, we perform two operations on our encrypted data: addition and multiplication.
    Finally, we decrypt the results of these operations and print them out.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们首先使用 CKKS 方案创建一个上下文，其多项式模数度为 8,192，四个系数模数位大小为 60、40、40 和 60。然后，我们创建两个
    CKKS 向量并加密我们的数据。接下来，我们在加密数据上执行两个操作：加法和乘法。最后，我们解密这些操作的成果并打印出来。
- en: This library also supports creating context using the BFV scheme as well in
    the same manner and the homomorphic operations using the BFV Scheme as well.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此库还支持使用 BFV 方案创建上下文，以及以相同方式使用 BFV 方案进行同态运算。
- en: This is a simple example, and in practice, HE can be computationally intensive
    and requires specialized hardware or cloud resources. It is also important to
    ensure that the implementation is secure and that no encrypted data leaks out
    during the computation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，在实践中，HE 可能计算密集，需要专用硬件或云资源。同时，确保实现的安全性也很重要，以防止在计算过程中加密数据泄露。
- en: Comparison of HE frameworks
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HE 框架的比较
- en: Let’s review a comparison of some of the most popular HE frameworks in Python.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 Python 中一些最受欢迎的 HE 框架的比较。
- en: Pyfhel
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pyfhel
- en: Pyfhel is a Python-based fully HE library that supports operations on encrypted
    integers and vectors. It is built on top of the HElib C++ library and offers a
    simplified interface for Python developers. Pyfhel has good performance and can
    handle large integers and vectors efficiently. However, it does not yet support
    operations on floating-point numbers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Pyfhel 是一个基于 Python 的完全 HE 库，支持在加密整数和向量上执行操作。它建立在 HElib C++ 库之上，并为 Python 开发者提供了简化的接口。Pyfhel
    具有良好的性能，可以高效地处理大整数和向量。然而，它目前还不支持浮点数的操作。
- en: TenSEAL
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TenSEAL
- en: TenSEAL is a Python-based library for HE that supports both FHE and PHE. It
    uses the CKKS and BFV encryption schemes and offers APIs for encrypted operations
    on floating-point numbers and matrices. TenSEAL is designed to be easy to use
    and has a simpler API compared to some other HE libraries. It has a relatively
    high performance for encrypted operations on floating-point numbers.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: TenSEAL 是一个基于 Python 的 HE 库，支持 FHE 和 PHE。它使用 CKKS 和 BFV 加密方案，并提供加密浮点数和矩阵操作的
    API。TenSEAL 设计得易于使用，与一些其他 HE 库相比，API 更简单。它在加密浮点数操作方面具有相对较高的性能。
- en: PALISADE
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PALISADE
- en: PALISADE is a C++ library for HE that has Python bindings. It supports both
    FHE and PHE and offers a wide range of encryption schemes, including CKKS, BFV,
    and GSW. PALISADE is designed for performance and can handle large plaintexts
    and ciphertexts efficiently. The Python bindings are relatively new, and the API
    can be more complex compared to other Python-based HE libraries.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: PALISADE 是一个具有 Python 绑定的 C++ HE 库。它支持 FHE 和 PHE，并提供包括 CKKS、BFV 和 GSW 在内的广泛加密方案。PALISADE
    设计用于性能，可以高效地处理大明文和大密文。Python 绑定相对较新，API 相比其他基于 Python 的 HE 库可能更复杂。
- en: PySEAL
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PySEAL
- en: PySEAL is a Python-based library for HE that supports FHE operations on encrypted
    integers and vectors. It is built on top of the SEAL C++ library and provides
    a simplified Python interface. PySEAL has good performance for integer and vector
    operations and can handle large plaintexts and ciphertexts. However, it does not
    yet support operations on floating-point numbers.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: PySEAL 是一个基于 Python 的 HE 库，支持在加密整数和向量上执行 FHE 操作。它建立在 SEAL C++ 库之上，并为 Python
    提供了简化的接口。PySEAL 在整数和向量操作方面具有良好的性能，可以处理大明文和大密文。然而，它目前还不支持浮点数的操作。
- en: TFHE
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFHE
- en: TFHE is a C++ library for HE that has Python bindings. It supports PHE operations
    on encrypted integers and booleans and is designed for high performance. TFHE
    can handle large ciphertexts efficiently and has a relatively simple API. The
    Python bindings are relatively new, and the documentation can be limited.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: TFHE 是一个具有 Python 绑定的 C++ HE 库。它支持在加密整数和布尔值上执行 PHE 操作，并设计用于高性能。TFHE 可以高效地处理大密文，并且具有相对简单的
    API。Python 绑定相对较新，文档可能有限。
- en: 'The following table offers a high-level summary of the comparisons between
    the preceding HE libraries:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下表提供了一个关于前面 HE 库之间比较的高级概述：
- en: '| Operations | PySEAL | TenSEAL | Paillier | Pyfhel |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | PySEAL | TenSEAL | Paillier | Pyfhel |'
- en: '| Addition | Yes | Yes | Yes | Yes |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | 是 | 是 | 是 | 是 |'
- en: '| Subtraction | Yes | Yes | Yes | No |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | 是 | 是 | 是 | 否 |'
- en: '| Multiplication | Yes | Yes | No | Yes |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | 是 | 是 | 否 | 是 |'
- en: '| Division | No | No | No | No |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | 否 | 否 | 否 | 否 |'
- en: '| Comparison (<, >, <=, >=, and ==) | No | No | No | No |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 比较运算（<, >, <=, >=, 和 ==） | 否 | 否 | 否 | 否 |'
- en: '| Support for vector operations (addition, dot product, etc.) | Yes | Yes |
    No | No |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 支持向量操作（加法、点积等） | 是 | 是 | 否 | 否 |'
- en: '| Matrix operations | Yes | Yes | No | No |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 矩阵操作 | 是 | 是 | 否 | 否 |'
- en: '| Encrypted number added to scalar (non-encrypted number) | Yes | Yes | Yes
    | Yes |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 加密数与标量（非加密数）相加 | 是 | 是 | 是 | 是 |'
- en: '| Encrypted number multiplied by scalar (non-encrypted number) | Yes | Yes
    | Yes | Yes |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 加密数与标量（非加密数）相乘 | 是 | 是 | 是 | 是 |'
- en: Table 8.1 – High-level comparison of HE frameworks
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 – HE 框架的高级比较
- en: Each HE framework has its own set of strengths and weaknesses, and the best
    choice will depend on your specific use case and requirements. Pyfhel and PySEAL
    are good choices for FHE operations on integers and vectors, while TenSEAL is
    a good choice for FHE operations on floating-point numbers and matrices. PALISADE
    offers a wide range of encryption schemes and is designed for performance, while
    TFHE is a good choice for PHE operations on integers and booleans.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HE框架都有其自身的优点和缺点，最佳选择将取决于您的具体用例和需求。Pyfhel和PySEAL是用于整数和向量FHE操作的不错选择，而TenSEAL是用于浮点数和矩阵FHE操作的不错选择。PALISADE提供了广泛的加密方案，并针对性能设计，而TFHE是用于整数和布尔值PHE操作的不错选择。
- en: Machine learning with HE
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HE进行机器学习
- en: HE can be used in **Machine Learning** (**ML**) models to encrypt the training
    data, test data, or even the complete model itself to achieve model security.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: HE可用于**机器学习**（**ML**）模型，以加密训练数据、测试数据，甚至整个模型本身，以实现模型安全。
- en: 'The following are some of the options to implement ML models with HE:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些实现使用HE的ML模型选项：
- en: Encrypt the weights (model parameters) and intercept, and make use of them to
    calculate the accuracy of the model on the test data.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密权重（模型参数）和截距，并利用它们来计算测试数据上模型的准确率。
- en: Encrypt the test data and make use of the encrypted data with an encrypted model
    to find out the accuracy.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密测试数据，并使用加密模型和加密数据来找出准确率。
- en: Build the models with training data encrypted and without the encryption.Calculate
    the accuracy of the clear text model as well as the model with encrypted training
    data.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密的训练数据构建模型，并计算明文模型以及加密训练数据模型的准确率。
- en: Encrypt the training data and train the model on encrypted data, then run the
    inference and decrypt the results.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密训练数据，在加密数据上训练模型，然后运行推理并解密结果。
- en: 'In this example, we will encrypt the model parameters and do the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将加密模型参数并执行以下操作：
- en: 'Using the fraud detection model example:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用欺诈检测模型示例：
- en: Load the fraud transaction data
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载欺诈交易数据
- en: Split the data as train and test
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据分为训练集和测试集
- en: Use the logistic regression model to train the data
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑回归模型训练数据
- en: From the model, find out the intercept and coefficients ( weights)
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模型中找出截距和系数（权重）
- en: 'Using the Paillier PHE library, do the following:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Paillier PHE库，执行以下操作：
- en: Perform HE on the model parameters (i.e., the intercept values and model weights)
    using the public key
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公钥对模型参数（即截距值和模型权重）进行HE操作
- en: 'Find out the predictions using the encrypted intercept and encrypted model
    weights:'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密的截距和加密模型权重找出预测：
- en: Calculate the score by doing the homomorphic operations (encrypted weights multiplied
    by test feature data and the addition of encrypted numbers)
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过同态操作（加密权重乘以测试特征数据并添加加密数字）计算分数
- en: Decrypt the calculated score using homomorphic decryption and find out the error/accuracy
    rates
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同态解密解密计算出的分数，并找出错误/准确率
- en: '![Figure 8.5 – Encryption of model parameters using HE](img/B16573_08_05.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 使用HE加密模型参数](img/B16573_08_05.jpg)'
- en: Figure 8.5 – Encryption of model parameters using HE
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 使用HE加密模型参数
- en: '*Source* *code: FHE_Logistic.ipynb*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源* *代码: FHE_Logistic.ipynb*'
- en: Following code implements the steps mentioned above.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了上述步骤。
- en: '[PRE13]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This results in the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE14]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this way, ML engineers are able to share the public key generated using HE,
    along with the encrypted model weights, with others while retaining the security
    of their ML models.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，ML工程师能够在保持其ML模型安全性的同时，与他人共享使用HE生成的公钥以及加密的模型权重。
- en: Encrypted evaluation of ML models and inference
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密评估ML模型和推理
- en: 'In order to perform encrypted evaluations and inference, follow these steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行加密评估和推理，请遵循以下步骤：
- en: Encrypt the training data using the public key (i.e., the HE key).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公钥（即HE密钥）加密训练数据。
- en: Train the model with the encrypted data.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密数据训练模型。
- en: Get the encrypted results.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取加密结果。
- en: Decrypt the results with the secret key (i.e., the private key).
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密钥（即私钥）解密结果。
- en: '![Figure 8.6 – Encrypted evaluation of ML model and inference](img/B16573_08_06.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 加密评估ML模型和推理](img/B16573_08_06.jpg)'
- en: Figure 8.6 – Encrypted evaluation of ML model and inference
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 加密评估ML模型和推理
- en: Limitations of HE
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HE的局限性
- en: 'HE is a powerful cryptographic technique that allows computations to be performed
    on encrypted data without the need for decryption. While HE has several benefits,
    it also has some limitations, which we’ll take a look at now:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: HE是一种强大的密码学技术，允许在加密数据上执行计算，而无需解密。虽然HE有多个优点，但它也有一些限制，我们现在将探讨这些限制：
- en: '**Performance**: HE is computationally intensive and can be slow, especially
    when working with large amounts of data. The overhead associated with encryption
    and decryption can significantly impact the performance of the system.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：HE计算密集，可能运行缓慢，尤其是在处理大量数据时。与加密和解密相关的开销可能会显著影响系统的性能。'
- en: '**Limited functionality**: HE is still a developing field, and current implementations
    have limited functionality. Complex computations are often difficult to perform
    using HE, and not all types of computations can be performed using current HE
    techniques.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能有限**：HE仍然是一个发展中的领域，当前的实现具有有限的功能。复杂的计算通常难以使用HE执行，并且并非所有类型的计算都可以使用当前的HE技术执行。'
- en: '**Key management**: HE requires the management of large cryptographic keys,
    which can be challenging, especially in distributed systems. The key management
    problem becomes more complex as the number of parties involved in the computation
    increases.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥管理**：HE需要管理大量的加密密钥，这可能具有挑战性，尤其是在分布式系统中。随着参与计算各方数量的增加，密钥管理问题变得更加复杂。'
- en: '**Security assumptions**: HE is based on certain security assumptions, and
    if these assumptions are violated, the security of the system can be compromised.
    For example, the security of the system can be compromised if the attacker has
    access to the secret key or the encrypted data is leaked.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全假设**：HE基于某些安全假设，如果这些假设被违反，系统的安全性可能会受到损害。例如，如果攻击者可以访问密钥或加密数据泄露，系统的安全性可能会受到损害。'
- en: '**Storage requirements**: HE can result in large ciphertexts that require more
    storage space than plaintext. This can be a challenge in systems where storage
    space is limited.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储需求**：HE可能导致大的密文，需要比明文更多的存储空间。在存储空间有限的情况下，这可能是一个挑战。'
- en: The aforementioned limitations need to be taken into account when considering
    the use of HE in a system. While HE has the potential to provide a secure and
    privacy-preserving solution, it is essential to carefully evaluate the limitations
    and trade-offs before using it in a real-world system.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑在系统中使用HE（同态加密）时，需要考虑上述限制。虽然HE有潜力提供一种安全和隐私保护解决方案，但在将其用于现实世界系统之前，仔细评估其限制和权衡是至关重要的。
- en: Secure Multiparty Computation
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全多方计算
- en: '**Secure Multiparty Computation** (**SMC**) is a cryptographic technique that
    enables two or more parties to jointly compute a function on their private data
    without revealing their data to each other.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全多方计算**（**SMC**）是一种密码学技术，它允许两个或多个各方在他们的私有数据上共同计算一个函数，而无需向彼此透露他们的数据。'
- en: SMC is an important tool in privacy-preserving computation, where parties may
    not trust each other or a central authority and may have sensitive data that they
    do not want to share with other parties.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: SMC（安全多方计算）是隐私保护计算中的一个重要工具，在这种计算中，各方可能不信任彼此或中心权威机构，并且可能拥有他们不想与其他方共享的敏感数据。
- en: In this section, we will learn about the basic principles of SMC, its applications,
    and some techniques used for SMC.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解SMC的基本原则、其应用以及用于SMC的一些技术。
- en: Basic principles of SMC
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SMC的基本原则
- en: The basic principle of SMC is that each party has private data that they want
    to keep secret from other parties, but they want to compute a function on the
    common joint data. SMC enables multiple parties to do this securely by dividing
    the computation into smaller, less sensitive sub-computations, which are performed
    locally on each party’s private data. Then, the parties communicate with each
    other to reveal only the final output of the computation.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: SMC的基本原则是，每个方都有他们希望保密的私有数据，但他们希望对共同联合数据上的函数进行计算。SMC通过将计算划分为更小、更不敏感的子计算，并在每个方的私有数据上本地执行这些子计算，使多个方能够安全地这样做。然后，各方相互沟通，仅揭示计算的最终输出。
- en: SMC ensures that no party learns any information about the other parties’ data,
    except for what is necessary to compute the final output. The computations performed
    in SMC are designed such that no party can learn anything about other parties’
    data by analyzing the messages sent during the computation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: SMC确保没有任何一方能够了解其他各方数据的任何信息，除非是计算最终输出所必需的。在SMC中进行的计算设计得使得任何一方都无法通过分析计算过程中发送的消息来了解其他各方的数据。
- en: The security of SMC relies on cryptographic techniques such as secret sharing,
    HE, and oblivious transfer. These techniques ensure that each party only sees
    a small portion of the input data and that the output is computed in such a way
    that no party can determine the input data of other parties.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: SMC的安全性依赖于诸如秘密共享、HE和 oblivious transfer 等密码学技术。这些技术确保每个方只能看到输入数据的一小部分，并且输出是以一种方式计算的，使得任何一方都无法确定其他各方的输入数据。
- en: Applications of SMC
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SMC的应用
- en: 'SMC has several applications in various domains, including healthcare, finance,
    and data privacy. We’ll examine these in more detail now:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: SMC在各个领域都有多个应用，包括医疗保健、金融和数据隐私。现在我们将更详细地探讨这些应用：
- en: '**Data analysis**: In many scenarios, data is distributed across different
    parties, and it is not possible or desirable to centralize the data in one location.
    SMC can be used to enable the parties to perform computations on their private
    data without revealing their data to each other.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分析**：在许多情况下，数据分布在不同的各方之间，不可能或不需要将数据集中在一个位置。SMC可以用来使各方能够在不向彼此泄露数据的情况下对其私有数据进行计算。'
- en: '**ML**: SMC can be used to enable multiple parties to jointly train ML models
    on their private data without sharing their data with each other. This can be
    useful in scenarios where data privacy is a concern, such as in healthcare or
    financial services.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ML**：SMC可以用来使多个各方能够在他们的私有数据上联合训练ML模型，而无需相互共享他们的数据。这在数据隐私是关注点的情况下非常有用，例如在医疗保健或金融服务中。'
- en: '**Privacy-preserving** **authentication**: SMC can be used to enable multiple
    parties to authenticate themselves without revealing their identity to each other.
    For example, a group of users can use SMC to authenticate themselves with a service
    provider without revealing their identities to each other.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私保护** **认证**：SMC可以用来使多个各方能够在不向彼此泄露身份的情况下进行认证。例如，一组用户可以使用SMC与服务提供商进行认证，而不向彼此泄露他们的身份。'
- en: '**Fraud detection**: SMC can be used to enable different parties to detect
    fraudulent activity without revealing any sensitive information. For example,
    multiple banks can use SMC to compute the intersection of their transaction lists
    to detect fraudulent transactions without revealing any customer data. We have
    already covered using federated learning with differential privacy, but the same
    use case, that is, detection of fraudulent transactions, can be applied with SMC
    as well.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**欺诈检测**：SMC可以用来使不同的各方能够检测欺诈活动，而不泄露任何敏感信息。例如，多个银行可以使用SMC来计算它们的交易列表的交集，以检测欺诈交易，而不泄露任何客户数据。我们已经讨论了使用带有差分隐私的联邦学习，但同样的用例，即检测欺诈交易，也可以使用SMC来实现。'
- en: Techniques used for SMC
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SMC使用的技巧
- en: 'SMC can be performed using various techniques, including secret sharing, HE,
    and oblivious transfer. Let’s review these techniques now:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: SMC可以使用各种技巧进行，包括秘密共享、HE和 oblivious transfer。现在让我们回顾这些技巧：
- en: '**Secret sharing**: This is a cryptographic technique that divides a secret
    into multiple shares, where each share is given to a different party. The secret
    can only be reconstructed when a sufficient number of shares are combined. In
    SMC, secret sharing can be used to divide the input data into multiple shares,
    which are then used to perform computations locally on each party’s data.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密共享**：这是一种密码学技术，将秘密分成多个份额，每个份额分配给不同的方。只有当足够数量的份额结合在一起时，才能恢复秘密。在SMC中，秘密共享可以用来将输入数据分成多个份额，然后用于在每个方的数据上本地执行计算。'
- en: '**HE**: This is a type of encryption that allows computations to be performed
    on ciphertexts without decrypting them. In SMC, HE can be used to compute the
    intermediate values of the computation without revealing the parties’ data. HE
    is computationally expensive, so it is not suitable for all SMC applications.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HE**：这是一种允许在密文上执行计算而不需要解密的加密类型。在SMC中，HE可以用来计算计算的中间值，而不泄露各方的数据。HE计算成本高昂，因此不适合所有SMC应用。'
- en: '**Oblivious transfer**: This is a cryptographic protocol where a sender has
    multiple messages, and a receiver selects one of the messages without revealing
    the other messages.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '** oblivious transfer**：这是一种加密协议，其中发送者有多条消息，接收者选择其中一条消息，而不泄露其他消息。'
- en: Implementing SMC – high-level steps
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施SMC – 高级步骤
- en: 'The following is a high-level overview of the steps required to implement SMC:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现SMC所需步骤的高级概述：
- en: '**Define the computation**: The first step in implementing SMC is to define
    the computation that needs to be performed on the private data. This computation
    should be divided into smaller sub-computations, each of which can be performed
    locally on each party’s private data.'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义计算**：实施SMC的第一步是定义需要在私有数据上执行的计算。这个计算应该被分成更小的子计算，每个子计算都可以在每个参与方的私有数据上本地执行。'
- en: '**Secure communication**: The parties involved in the SMC computation need
    to communicate securely with each other to exchange messages without revealing
    their private data. This can be achieved using secure communication protocols
    such as SSL or TLS.'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安全通信**：参与SMC计算的各方需要通过安全通信协议（如SSL或TLS）相互安全通信，以交换消息而不泄露他们的私有数据。'
- en: '**Secret sharing**: The input data needs to be divided into shares, which are
    distributed among the parties. Each party holds a share of the input data, and
    computations are performed locally on each party’s share. Secret sharing can be
    implemented using cryptographic techniques such as Shamir’s Secret Sharing Scheme.'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**秘密共享**：输入数据需要分成份额，这些份额被分配给各方。每个参与方持有输入数据的一个份额，计算是在每个参与方的份额上本地执行的。秘密共享可以使用如Shamir秘密共享方案之类的密码学技术实现。'
- en: '**Computation**: Once the input data has been shared among the parties, the
    computation can be performed locally on each party’s share of the data. The intermediate
    values of the computation need to be encrypted using HE to prevent any party from
    learning anything about the other parties’ data.'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算**：一旦输入数据在各方之间共享，就可以在每个参与方数据的份额上本地执行计算。计算的中间值需要使用HE进行加密，以防止任何一方了解其他方的数据。'
- en: '**Reveal the output**: After the computation is complete, the parties reveal
    only the final output of the computation to each other. The output can be reconstructed
    by combining the shares of the output that each party holds.'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**揭示输出**：计算完成后，各方只向彼此揭示计算的最终输出。输出可以通过组合各方持有的输出份额来重建。'
- en: SMC requires expertise in cryptography, programming, and network security. It
    is a complex process that requires careful design and implementation to ensure
    the security and privacy of the parties involved.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: SMC需要密码学、编程和网络安全的专长。这是一个复杂的过程，需要仔细设计和实施，以确保参与方的安全和隐私。
- en: Python frameworks that can be used to implement SMC
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以用于实现SMC的Python框架
- en: 'The following are a number of Python frameworks that can be used to implement
    SMC:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用于实现SMC的几个Python框架：
- en: '**PySyft** is an open source framework for SMC and federated learning. It provides
    tools for secure multi-party computation, differential privacy, and homomorphic
    encryption. It is built on top of PyTorch and provides a simple and easy-to-use
    interface for implementing SMC.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PySyft** 是一个用于SMC和联邦学习的开源框架。它提供了用于安全多方计算、差分隐私和同态加密的工具。它建立在PyTorch之上，提供了一个简单且易于使用的接口来实施SMC。'
- en: '**Obliv-C** is a language and framework for implementing SMC in C and Python.
    It provides a high-level programming interface for implementing SMC, as well as
    low-level primitives for building custom protocols.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Obliv-C** 是一个用于在C和Python中实现SMC的语言和框架。它提供了一个高级编程接口来实施SMC，以及用于构建自定义协议的低级原语。'
- en: '**Charm** is a Python library for cryptography that provides support for SMC,
    HE, and other cryptographic primitives. It provides a high-level programming interface
    for implementing SMC, as well as low-level primitives for building custom protocols.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Charm** 是一个提供SMC、HE和其他密码学原语支持的Python库。它提供了一个高级编程接口来实施SMC，以及用于构建自定义协议的低级原语。'
- en: '**MPyC** is a Python library for SMC that provides a high-level programming
    interface for implementing secure computations. It is built on top of the **asyncio**
    library, which provides support for asynchronous programming.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MPyC** 是一个用于SMC的Python库，它提供了一个高级编程接口来实施安全计算。它建立在 **asyncio** 库之上，该库提供了对异步编程的支持。'
- en: '**SecureML** is a Python library for implementing SMC and other privacy-preserving
    ML techniques. It provides a high-level programming interface for implementing
    SMC, as well as support for other privacy-preserving techniques such as differential
    privacy and federated learning.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SecureML** 是一个用于实现 SMC 和其他隐私保护机器学习技术的 Python 库。它提供了一个高级编程接口来实现 SMC，以及支持差分隐私和联邦学习等其他隐私保护技术。'
- en: Implementing Private Set Interaction (PSI) SMC – case study
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施私有集合交互（PSI）SMC – 案例研究
- en: '**Private Set Intersection** (**PSI**) is a cryptographic technique that allows
    two or more parties to securely compute the intersection of their private sets
    without disclosing any other information about their sets. PSI can be used in
    various fintech applications where sensitive financial data needs to be shared
    between parties while preserving privacy.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有集合交集**（**PSI**）是一种密码学技术，它允许两个或多个参与方在不泄露其集合中任何其他信息的情况下安全地计算其私有集合的交集。PSI
    可用于各种金融科技应用，在这些应用中，需要在各方之间共享敏感的财务数据，同时保护隐私。'
- en: Let’s now examine an example case study concerning the implementation of PSI
    SMC for fraud detection in the fintech sector.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分析一个关于在金融科技领域实施 PSI SMC 用于欺诈检测的案例研究。
- en: '**Fraud Detection**: In the fintech industry, fraud detection is a critical
    task that requires sharing information between banks, financial institutions,
    and payment processors to identify fraudulent transactions. However, sharing customer
    data between these entities can violate their customers’ privacy. To overcome
    this problem, PSI can be used to enable the secure sharing of data between different
    entities without disclosing any sensitive information.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**欺诈检测**：在金融科技行业，欺诈检测是一项关键任务，需要银行、金融机构和支付处理器之间共享信息以识别欺诈交易。然而，在这些实体之间共享客户数据可能会侵犯其客户的隐私。为了克服这个问题，PSI
    可以用来实现不同实体之间安全的数据共享，而不泄露任何敏感信息。'
- en: For example, suppose a bank wants to share its list of suspicious transactions
    with another bank without revealing the details of the transactions or customers
    involved. PSI can be used to compute the intersection of the two banks’ transaction
    lists. The bank’s transaction list would form one subset, and the other bank’s
    transaction list would form the other subset. By using PSI, both banks can securely
    compute the intersection of their transaction lists without revealing any sensitive
    information about their transactions or customers.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一家银行想要与另一家银行共享其可疑交易列表，而不透露交易或涉及的客户的详细信息。PSI 可以用于计算两家银行交易列表的交集。银行的交易列表将形成一个子集，另一家银行的交易列表将形成另一个子集。通过使用
    PSI，两家银行可以安全地计算其交易列表的交集，而不透露任何关于其交易或客户的敏感信息。
- en: To implement PSI SMC in this use case, SMC techniques can be used. SMC ensures
    that the parties involved can jointly compute the intersection of their datasets
    without revealing any other information about their datasets. The computation
    can be performed using techniques such as **Oblivious Transfer** (**OT**) or **Garbled
    Circuits** (**GC**) to ensure the privacy and security of the computation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此用例中实施 PSI SMC，可以使用 SMC 技术。SMC 确保参与方可以共同计算其数据集的交集，而不泄露关于其数据集的任何其他信息。计算可以使用诸如
    **隐写传输**（**OT**）或 **乱码电路**（**GC**）等技术进行，以确保计算的隐私和安全。
- en: '![Figure 8.7 – Example of secure multiparty computation with shared keys](img/B16573_08_07.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 使用共享密钥的保密多方计算示例](img/B16573_08_07.jpg)'
- en: Figure 8.7 – Example of secure multiparty computation with shared keys
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 使用共享密钥的保密多方计算示例
- en: '*Source* *code: PSI-SMC_Example.ipynb*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码：PSI-SMC_Example.ipynb*'
- en: 'Let’s implement a simple SMC example to understand the steps:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的 SMC 示例，以了解步骤：
- en: '[PRE15]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Zero-knowledge proofs
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零知识证明
- en: '**Zero-Knowledge Proofs** (**ZKPs**) are a type of cryptographic protocol that
    allows one party (the Prover) to demonstrate to another party (the Verifier) that
    they possess knowledge of a particular piece of information, without revealing
    any other information about that knowledge. The concept of zero knowledge was
    first introduced by Goldwasser, Micali, and Rackoff in 1985\. Since then, zero-knowledge
    protocols have been widely used in cryptography, particularly in privacy-preserving
    protocols.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**零知识证明**（**ZKPs**）是一种加密协议，允许一方（证明者）向另一方（验证者）证明他们知道特定信息，而不透露关于该知识的任何其他信息。零知识的概念最早由Goldwasser、Micali和Rackoff于1985年提出。从那时起，零知识协议在密码学中得到了广泛的应用，尤其是在保护隐私的协议中。'
- en: Basic concepts
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本概念
- en: The concept of zero knowledge is based on the idea of interactive proof systems.
    In an interactive proof system, a Prover tries to convince a Verifier that a statement
    is true by sending a series of messages to the Verifier. The Verifier examines
    each message and either accepts or rejects the statement. In a zero-knowledge
    proof, the Prover can convince the Verifier of the truth of the statement without
    revealing any other information beyond the fact that they know the statement to
    be true. The central idea behind ZKPs is to show that a Prover has knowledge of
    some secret information, without revealing any details about that information.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 零知识的概念基于交互式证明系统的理念。在交互式证明系统中，证明者通过向验证者发送一系列消息来试图说服验证者一个陈述是真实的。验证者检查每条消息，并接受或拒绝该陈述。在零知识证明中，证明者可以在不透露任何其他信息（除了他们知道该陈述是真实的事实之外）的情况下，说服验证者该陈述的真实性。ZKPs背后的核心思想是展示证明者知道一些秘密信息，而不透露关于该信息的任何细节。
- en: For example, imagine that Alice wants to prove to Bob that she knows the value
    of a secret number x, without revealing the value of x itself. With a ZKP, Alice
    can prove to Bob that she knows x by interacting with him in such a way that he
    becomes convinced that she knows the value of x, but learns nothing else about
    it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，Alice想要向Bob证明她知道一个秘密数字x的值，而不透露x本身的值。使用ZKP，Alice可以通过与Bob的互动来证明她知道x的值，使他确信她知道x的值，但不会了解到其他任何信息。
- en: Types of ZKPs
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZKPs的类型
- en: 'There are three main types of ZPKs:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ZPKs主要有三种类型：
- en: '**Zero-Knowledge Proof of Knowledge** (**ZKPK**): In a ZKPK, the Prover proves
    to the Verifier that they know a particular secret without revealing any information
    about that secret. An example of this is proving that you know the password to
    an account without revealing the password itself.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零知识证明知识**（**ZKPK**）：在ZKPK中，证明者向验证者证明他们知道某个秘密，而不透露关于该秘密的任何信息。例如，证明你知道某个账户的密码，而不透露密码本身。'
- en: '**Zero-Knowledge Proof of Possession** (**ZKPP**): In a ZKPP, the Prover proves
    to the Verifier that they possess a particular item without revealing any information
    about the item. An example of this is proving that you have a valid driver’s license
    without revealing any personal information beyond what is already printed on the
    license.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零知识证明拥有**（**ZKPP**）：在零知识证明中，证明者向验证者证明他们拥有某个特定物品，而不透露任何关于该物品的信息。例如，证明你有有效的驾照，而不透露驾照上未打印的任何个人信息。'
- en: '**Zero-Knowledge Proof of Identity** (**ZKPI**): In a ZKPI, the Prover proves
    to the Verifier that they are the same person or entity that was previously identified
    without revealing any other information about themselves. An example of this is
    proving that you are the same person who previously registered for an online service
    without revealing any other personal information.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零知识证明身份**（**ZKPI**）：在ZKPI中，证明者向验证者证明他们是之前已识别的同一人或实体，而不透露关于他们自己的任何其他信息。例如，证明你是之前注册过在线服务的同一人，而不透露任何其他个人信息。'
- en: Applications of ZKPs
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZKPs的应用
- en: 'ZKPs have numerous applications in cryptography, including the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ZKPs在密码学中有许多应用，包括以下内容：
- en: '**Privacy-preserving authentication**: ZKPs can be used to authenticate a user
    without revealing their identity or any other personal information.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护隐私的认证**：ZKPs可以用来认证用户，而不透露他们的身份或任何其他个人信息。'
- en: '**Secure messaging**: ZKPs can be used to ensure the confidentiality and integrity
    of messages exchanged between two parties without revealing the content of the
    messages.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全消息传递**：零知识证明可以用来确保两个当事人之间交换的消息的机密性和完整性，而不透露消息的内容。'
- en: '**Secure computation**: ZKPs can be used to prove that a computation was performed
    correctly without revealing any details about the computation or the inputs.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全计算**：ZKPs可以用来证明计算的正确性，而不泄露关于计算或输入的任何细节。'
- en: '**Cryptocurrency**: ZKPs are used in some cryptocurrencies (such as Zcash)
    to ensure the privacy and anonymity of transactions.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密货币**：ZKPs被用于某些加密货币（如Zcash）中，以确保交易的隐私和匿名性。'
- en: ZKPs are a powerful tool in cryptography that allow secure and private communication
    and computation. They have numerous applications in various fields, including
    finance, healthcare, and online identity verification. As technology continues
    to advance, the use of ZKPs is likely to become more widespread, helping to protect
    the privacy and security of individuals and organizations alike.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ZKPs是密码学中的一个强大工具，它允许安全且私密的通信和计算。它们在金融、医疗保健和在线身份验证等众多领域都有广泛应用。随着技术的不断进步，ZKPs的使用可能会变得更加普遍，有助于保护个人和组织双方的隐私和安全。
- en: 'The following is an example Python program that implements a ZKPK for a simple
    scenario where a Prover wants to prove to a Verifier that they know the value
    of a secret number:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例Python程序，它实现了一个ZKPK，用于简单场景，其中证明者想要向验证者证明他们知道一个秘密数字的值：
- en: '*Source* *code: ZNP_Example.ipynb*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*：ZNP_Example.ipynb'
- en: '[PRE16]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, the Prover generates two commitments based on the
    secret number and a random blinding factor and sends them to the Verifier. The
    Verifier then sends a random challenge value to the Prover, and the Prover responds
    with either the secret number or the blinding factor, depending on the challenge.
    The Verifier checks the response against the commitments and determines whether
    the Prover has successfully proven knowledge of the secret number.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，证明者基于秘密数字和一个随机盲化因子生成两个承诺，并将它们发送给验证者。验证者随后向证明者发送一个随机挑战值，证明者则根据挑战值回应秘密数字或盲化因子。验证者将回应与承诺进行核对，以确定证明者是否成功证明了其对秘密数字的了解。
- en: 'The following are some popular Python frameworks for ZKPs:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的用于ZKPs的Python框架：
- en: '**PyZPK**: A Python library for constructing and verifying **Zero-Knowledge
    Succinct Non-interactive Arguments of Knowledge** (**zk-SNARK**s) scheme. It provides
    a simple and intuitive interface for building ZKPs and is designed to work well
    with other Python libraries, such as NumPy and SciPy.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyZPK**：一个用于构建和验证**零知识简洁非交互式知识论证**（zk-SNARKs）方案的Python库。它提供了一个简单直观的接口来构建ZKPs，并设计得与NumPy和SciPy等其他Python库良好协作。'
- en: '**Bulletproofs-Builder**: A Python library for building and verifying bulletproofs.
    It provides a high-level interface for creating range proofs and other types of
    ZKPs. It is designed to be easy to use and can easily integrate with other Python
    libraries.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bulletproofs-Builder**：一个用于构建和验证bulletproofs的Python库。它提供了一个高级接口来创建范围证明和其他类型的ZKPs。它设计得易于使用，并且可以轻松集成到其他Python库中。'
- en: '**starkware-libs**: A collection of Python libraries for building and verifying
    Scalable Transparent Argument of Knowledge (STARKs). It includes libraries for
    constructing STARK-friendly hash functions, building constraint systems, and performing
    **Fast Fourier Transform** (**FFT**) operations.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**starkware-libs**：一组用于构建和验证可扩展透明知识论证（STARKs）的Python库。它包括构建STARK友好哈希函数、构建约束系统以及执行**快速傅里叶变换**（FFT）操作的库。'
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In summary, in this chapter, we have covered encryption, anonymization, and
    de-identification techniques in detail, along with some example Python implementations
    and a discussion of their limitations. We learned about the foundations and types
    of HE and secure multiparty computation and saw how they help in achieving privacy
    when working with ML models (including applications such as the encryption of
    training data, test data, models, model parameters, and inference results).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们详细介绍了加密、匿名化和去标识化技术，以及一些Python实现示例和它们局限性的讨论。我们学习了HE和安全的多方计算的基础和类型，并了解了它们如何帮助在处理ML模型时实现隐私（包括加密训练数据、测试数据、模型、模型参数和推理结果等应用）。
- en: In the next chapter, we will learn more about confidential computing, why it
    is needed, and how it helps to protect us from privacy threats facing data in
    memory. We will also learn about securing ML models through trusted execution
    environments.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于机密计算的知识，了解为什么它必不可少，以及它是如何帮助我们抵御内存中数据所面临的隐私威胁的。我们还将学习如何通过可信执行环境来确保机器学习模型的安全。
