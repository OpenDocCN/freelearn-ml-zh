<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/><a id="_idTextAnchor015"/><em class="italic">Chapter 1</em>: Introducing MLflow</h1>
			<p><strong class="bold">MLflow</strong> is an open source platform for the <strong class="bold">machine learning </strong>(<strong class="bold">ML</strong>) life cycle, with a focus on <em class="italic">reproducibility</em>, <em class="italic">training</em>, and <em class="italic">deployment</em>. It is based on an open interface design and is able to work with any language or platform, with clients in Python and Java, and is accessible through a REST API. Scalability is also an important benefit that an ML developer can leverage with MLflow.</p>
			<p>In this chapter of the book, we will take a look at how MLflow works, with the help of examples and sample code. This will build the necessary foundation for the rest of the book in order to use the concept to engineer an end-to-end ML project.</p>
			<p>Specifically, we will look at the following sections in this chapter:</p>
			<ul>
				<li>What is MLflow?</li>
				<li>Getting started with MLflow</li>
				<li>Exploring MLflow modules</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>For this chapter, you will need the following prerequisites:</p>
			<ul>
				<li>The latest version of Docker installed in your machine. In case you don't have the latest version, please follow the instructions at the following URL: <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>.</li>
				<li>Access to a bash terminal (Linux or Windows).</li>
				<li>Access to a browser.</li>
				<li>Python 3.5+ installed.</li>
				<li>PIP installed.</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>What is MLflow?</h1>
			<p>Implementing a product based on ML can be a laborious task. There is a general need to reduce the friction between different steps of the ML development life cycle, and between teams <a id="_idIndexMarker000"/>of data scientists and engineers that are involved in the process. </p>
			<p>ML practitioners, such as data scientists and ML engineers, operate with different systems, standards, and tools. While data scientists spend most of their time developing models in tools such as Jupyter Notebooks, when running in production, the model is deployed in the context of a software application with an environment that is more demanding in terms of scale and reliability. </p>
			<p>A common occurrence in ML projects is to have the models reimplemented by an engineering team, creating a custom-made system to serve the specific model. A set of challenges are common with teams that follow bespoke approaches regarding model development:</p>
			<ul>
				<li>ML projects that run over budget due to the need to create bespoke software infrastructure to develop and serve models</li>
				<li>Translation errors when reimplementing the models produced by data scientists</li>
				<li>Scalability issues when serving predictions</li>
				<li>Friction in terms of reproducing training processes between data scientists due to a lack of standard environments</li>
			</ul>
			<p>Companies leveraging ML tend to create their own (often extremely laborious) internal systems in order to ensure a smooth and structured process of ML development. Widely documented ML platforms include systems such as Michelangelo and FBLearner, from Uber and Facebook, respectively. </p>
			<p>It is in the context of the increasing adoption of ML that MLflow was initially created at Databricks and open sourced as a platform, to aid in the implementation of ML systems.</p>
			<p>MLflow enables an everyday practitioner in one platform to manage the ML life cycle, from iteration on model development up to deployment in a reliable and scalable environment that is compatible with modern software system requirements.<a id="_idTextAnchor018"/><a id="_idTextAnchor019"/></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor020"/>Getting started with MLflow</h1>
			<p>Next, we will install MLflow on your machine and prepare it for use in this chapter. You will have <a id="_idIndexMarker001"/>two options when it comes to installing MLflow. The first option is through a Docker container-based recipe provided in the repository of the book: <a href="https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Mlflow.git">https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Mlflow.git</a>.</p>
			<p>To install it, follow these instructions:</p>
			<ol>
				<li>Use the following commands to install the software:<p class="source-code">$ git clone https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Mlflow.git</p><p class="source-code">$ cd Machine-Learning-Engineering-with-Mlflow</p><p class="source-code">$ cd Chapter01</p></li>
				<li>The Docker image is very simple at this stage: it simply contains MLflow and sklearn, the main tools to be used in this chapter of the book. For illustrative purposes, you can look at the content of the <strong class="source-inline">Dockerfile</strong>:<p class="source-code">FROM jupyter/scipy-notebook</p><p class="source-code">RUN pip install mlflow</p><p class="source-code">RUN pip install sklearn</p></li>
				<li>To build the image, you should now run the following command:<p class="source-code">docker build -t chapter_1_homlflow</p></li>
				<li>Right after building the image, you can run the <strong class="source-inline">./run.sh</strong> command:<p class="source-code">./run.sh</p><p class="callout-heading">Important note</p><p class="callout">It is important to ensure that you have the latest version of Docker installed on your machine.</p></li>
				<li>Open your browser to <a href="http://localhost:888">http://localhost:888</a> and you should be able to navigate to the <strong class="source-inline">Chapter01</strong> folder.</li>
			</ol>
			<p>In the <a id="_idIndexMarker002"/>following section, we will be developing our first model with MLflow in the Jupyter environment created in the previous set of steps.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor021"/>Developing your first model with MLflow </h2>
			<p>From the point of view of simplicity, in this section, we will use the built-in sample datasets in sklearn, the ML <a id="_idIndexMarker003"/>library that we will use initially to explore MLflow features. For this section, we will choose the famous <strong class="source-inline">Iris</strong> dataset to train a multi-class classifier using MLflow.</p>
			<p>The Iris <a id="_idIndexMarker004"/>dataset (one of sklearn's built-in datasets available from <a href="https://scikit-learn.org/stable/datasets/toy_dataset.html">https://scikit-learn.org/stable/datasets/toy_dataset.html</a>) contains the following elements as features: sepal length, sepal width, petal length, and petal width. The target variable is the class of the iris: Iris Setosa, Iris Versocoulor, or Iris Virginica:</p>
			<ol>
				<li value="1">Load the sample dataset:<p class="source-code">from sklearn import datasets</p><p class="source-code">from sklearn.model_selection import train_test_split</p><p class="source-code">dataset = datasets.load_iris()</p><p class="source-code">X_train, X_test, y_train, y_test = train_test_split(dataset.data, dataset.target, test_size=0.4)</p></li>
				<li>Next, let's train your model.<p>Training a simple machine model with a framework such as scikit-learn involves instantiating an estimator such as <strong class="source-inline">LogisticRegression</strong> and calling the <strong class="source-inline">fit</strong> command to execute training over the <strong class="source-inline">Iris</strong> dataset built in scikit-learn:</p><p class="source-code">from sklearn.linear_model import LogisticRegression</p><p class="source-code">clf = LogisticRegression()</p><p class="source-code">clf.fit(X_train, y_train)</p><p>The preceding lines of code are just a small portion of the ML<strong class="bold"> Engineering</strong> process. As will be demonstrated, a non-trivial amount of code needs to <a id="_idIndexMarker005"/>be created in order to productionize and make sure that the preceding training code is usable and reliable. One of the main objectives of MLflow is to aid in the process of setting up ML systems <a id="_idIndexMarker006"/>and projects. In the following sections, we will demonstrate how MLflow can be used to make your solutions robust and reliable.</p></li>
				<li>Then, we will add MLflow.<p>With a few more lines of code, you should be able to start your first MLflow interaction. In the following code listing, we start by importing the <strong class="source-inline">mlflow</strong> module, followed by the <strong class="source-inline">LogisticRegression</strong> class in scikit-learn. You can use the accompanying Jupyter notebook to run the next section:</p><p class="source-code">import mlflow</p><p class="source-code">from sklearn.linear_model import LogisticRegression</p><p class="source-code">mlflow.sklearn.autolog()</p><p class="source-code">with mlflow.start_run():</p><p class="source-code">    clf = LogisticRegression()</p><p class="source-code">    clf.fit(X_train, y_train)</p><p>The <strong class="source-inline">mlflow.sklearn.autolog()</strong> instruction enables you to automatically log the experiment in <a id="_idIndexMarker007"/>the local directory. It captures the metrics produced by the underlying ML library in use. <strong class="bold">MLflow Tracking</strong> is the module responsible for handling metrics and logs. By default, the metadata of an MLflow run is stored in the local filesystem. </p></li>
				<li>If you run the following excerpt on the accompanying notebook's root document, you should now have the following files in your home directory as a result of running the following command:<p class="source-code">$ ls -l </p><p class="source-code">total 24</p><p class="source-code">-rw-r--r-- 1 jovyan users 12970 Oct 14 16:30 chapther_01_introducing_ml_flow.ipynb</p><p class="source-code">-rw-r--r-- 1 jovyan users    53 Sep 30 20:41 Dockerfile</p><p class="source-code">drwxr-xr-x 4 jovyan users   128 Oct 14 16:32 mlruns</p><p class="source-code">-rwxr-xr-x 1 jovyan users    97 Oct 14 13:20 run.sh</p><p>The <strong class="source-inline">mlruns</strong> folder is generated alongside your notebook folder and contains all the experiments <a id="_idIndexMarker008"/>executed by your code in the current context. </p><p>The <strong class="source-inline">mlruns</strong> folder will contain a folder with a sequential number identifying your experiment. The outline of the folder will appear as follows:</p><p class="source-code">├── 46dc6db17fb5471a9a23d45407da680f</p><p class="source-code">│   ├── artifacts</p><p class="source-code">│   │   └── model</p><p class="source-code">│   │       ├── MLmodel</p><p class="source-code">│   │       ├── conda.yaml</p><p class="source-code">│   │       ├── input_example.json</p><p class="source-code">│   │       └── model.pkl</p><p class="source-code">│   ├── meta.yaml</p><p class="source-code">│   ├── metrics</p><p class="source-code">│   │   └── training_score</p><p class="source-code">│   ├── params</p><p class="source-code">│   │   ├── C</p><p class="source-code">│   │   …..</p><p class="source-code">│   └── tags</p><p class="source-code">│       ├── mlflow.source.type</p><p class="source-code">│       └── mlflow.user</p><p class="source-code">└── meta.yaml</p><p>So, with very little effort, we have a lot of traceability available to us, and a good foundation to improve upon.</p></li>
			</ol>
			<p>Your experiment <a id="_idIndexMarker009"/>is identified as <strong class="source-inline">UUID</strong> on the preceding sample by <strong class="source-inline">46dc6db17fb5471a9a23d45407da680f</strong>. At the root of the directory, you have a <strong class="source-inline">yaml</strong> file named <strong class="source-inline">meta.yaml</strong>, which contains the content:</p>
			<p class="source-code">artifact_uri: file:///home/jovyan/mlruns/0/518d3162be7347298abe4c88567ca3e7/artifacts</p>
			<p class="source-code">end_time: 1602693152677</p>
			<p class="source-code">entry_point_name: ''</p>
			<p class="source-code">experiment_id: '0'</p>
			<p class="source-code">lifecycle_stage: active</p>
			<p class="source-code">name: ''</p>
			<p class="source-code">run_id: 518d3162be7347298abe4c88567ca3e7</p>
			<p class="source-code">run_uuid: 518d3162be7347298abe4c88567ca3e7</p>
			<p class="source-code">source_name: ''</p>
			<p class="source-code">source_type: 4</p>
			<p class="source-code">source_version: ''</p>
			<p class="source-code">start_time: 1602693152313</p>
			<p class="source-code">status: 3</p>
			<p class="source-code">tags: []</p>
			<p class="source-code">user_id: jovyan</p>
			<p>This is the basic metadata of your experiment, with information including start time, end time, identification of the run (<strong class="source-inline">run_id</strong> and <strong class="source-inline">run_uuid</strong>), an assumption of the life cycle stage, and the <a id="_idIndexMarker010"/>user who executed the experiment. The settings are basically based on a default run, but provide valuable and readable information regarding your experiment:</p>
			<p class="source-code">├── 46dc6db17fb5471a9a23d45407da680f</p>
			<p class="source-code">│   ├── artifacts</p>
			<p class="source-code">│   │   └── model</p>
			<p class="source-code">│   │       ├── MLmodel</p>
			<p class="source-code">│   │  ^   ├── conda.yaml</p>
			<p class="source-code">│   │       ├── input_example.json</p>
			<p class="source-code">│   │       └── model.pkl</p>
			<p>The <strong class="source-inline">model.pkl</strong> file contains a serialized version of the model. For a scikit-learn model, there is a binary version of the Python code of the model. Upon autologging, the metrics are leveraged from the underlying machine library in use. The default packaging strategy was based on a <strong class="source-inline">conda.yaml</strong> file, with the right dependencies to be able to serialize the model. </p>
			<p>The <strong class="source-inline">MLmodel</strong> file is the main definition of the project from an MLflow project with information related to how to run inference on the current model.</p>
			<p>The <strong class="source-inline">metrics</strong> folder contains the training score value of this particular run of the training process, which can be used to benchmark the model with further model improvements down the line.</p>
			<p>The <strong class="source-inline">params</strong> folder on <a id="_idIndexMarker011"/>the first listing of folders contains the default parameters of the logistic regression model, with the different default possibilities listed transparently and stored automatically.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor022"/>Exploring MLflow modules</h1>
			<p>MLflow modules are software components that deliver the core features that aid in the different phases <a id="_idIndexMarker012"/>of the ML life cycle. MLflow features are delivered through modules, extensible components that organize related features in the platform.</p>
			<p>The following are the built-in modules in MLflow:</p>
			<ul>
				<li><strong class="bold">MLflow Tracking</strong>: Provides a mechanism and UI to handle metrics and artifacts generated by ML executions (training and inference)</li>
				<li><strong class="bold">Mlflow Projects</strong>: A package format to standardize ML projects</li>
				<li><strong class="bold">Mlflow Models</strong>: A mechanism that deploys to different types of environments, both on-premises and in the cloud</li>
				<li><strong class="bold">Mlflow Model Registry</strong>: A module that handles the management of models in MLflow and its life cycle, including state</li>
			</ul>
			<p>In order to explore the different modules, we will install MLflow in your local environment using the following command:</p>
			<p class="source-code">pip install mlflow</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">It is crucial that the technical requirements are correctly installed on your local machine to allow you to follow along. You can also use the <strong class="source-inline">pip</strong> command with the required permissions.</p>
			<h2 id="_idParaDest-21">Exploring ML<a id="_idTextAnchor023"/>flow projects</h2>
			<p>An MLflow project represents the basic unit of organization of ML projects. There are three different <a id="_idIndexMarker013"/>environments supported <a id="_idIndexMarker014"/>by MLflow projects: the Conda environment, Docker, and the local system. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Model details of the different parameters available on an MLProject file can be consulted in the official documentation available at <a href="https://www.mlflow.org/docs/latest/projects.html#running-projects">https://www.mlflow.org/docs/latest/projects.html#running-projects</a>.</p>
			<p>The following is an example of an <strong class="source-inline">MLproject</strong> file of a <strong class="source-inline">conda</strong> environment:</p>
			<p class="source-code">name: condapred</p>
			<p class="source-code">conda_env:</p>
			<p class="source-code">  image: conda.yaml</p>
			<p class="source-code">entry_points:</p>
			<p class="source-code">  main:</p>
			<p class="source-code">    command: "python mljob.py"</p>
			<p>In the <strong class="source-inline">conda</strong> option, the assumption is that there is a <strong class="source-inline">conda.yaml</strong> file with the required dependencies. MLflow, when asked to run the project, will start the environment with the specified dependencies.</p>
			<p>The system-based environment will look like the following; it's actually quite simple: </p>
			<p class="source-code">name: syspred</p>
			<p class="source-code">entry_points:</p>
			<p class="source-code">  main:</p>
			<p class="source-code">    command: "python mljob.py"</p>
			<p>The preceding system variant will basically rely on the local environment dependencies, assuming that the underlying operating system contains all the dependencies. This approach is particularly prone to library conflicts with the underlying operating system; it might be valuable in contexts where there is already an existing operating system environment that fits the project.</p>
			<p>The following <a id="_idIndexMarker015"/>is a Docker environment-based <strong class="source-inline">MLproject</strong> file:</p>
			<p class="source-code">name: syspred</p>
			<p class="source-code">docker_env:</p>
			<p class="source-code">  image: stockpred-docker</p>
			<p class="source-code">entry_points:</p>
			<p class="source-code">  main:</p>
			<p class="source-code">    command: "python mljob.py"</p>
			<p>Once you <a id="_idIndexMarker016"/>have your environment, the main file that defines how your project should look is the <strong class="source-inline">MLProject</strong> file. This file is used by MLflow to understand how it should run your project.</p>
			<h3>Developing your first end-to-end pipeline in MLflow</h3>
			<p>We will prototype a simple stock prediction project in this section with MLflow and will document <a id="_idIndexMarker017"/>the different files and <a id="_idIndexMarker018"/>phases of the solution. You will develop it in your local system using the MLflow and Docker installed locally.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In this section, we are assuming that MLflow and Docker are installed locally, as the steps in this section will be executed in your local environment.</p>
			<p>The task in this illustrative project is to create a basic MLflow project and produce a working baseline ML model to predict, based on market signals over a certain number of days, whether the stock market will go up or down.</p>
			<p>In this section, we will use a Yahoo Finance dataset available for quoting the BTC-USD pair in <a href="https://finance.yahoo.com/quote/BTC-USD/">https://finance.yahoo.com/quote/BTC-USD/</a> over a period of 3 months. We will train a model to predict whether the quote will be going up or not on a given day. A REST API will be made available for predictions through MLflow.</p>
			<p>We will illustrate, step by step, the creation of an MLflow project to train a classifier on stock data, using the Yahoo API for financial information retrieved using the package's pandas data reader:</p>
			<ol>
				<li value="1">Add your <strong class="source-inline">MLProject</strong> file:<p class="source-code">name: stockpred</p><p class="source-code">docker_env:</p><p class="source-code">  image: stockpred-docker</p><p class="source-code">entry_points:</p><p class="source-code">  main:</p><p class="source-code">    command: "python train.py"</p><p>The preceding <strong class="source-inline">MLProject</strong> file specifies that dependencies will be managed in Docker with a specific image name. MLflow will try to pull the image using the version of Docker installed on your system. If it doesn't find it, it will try to retrieve <a id="_idIndexMarker019"/>it from Docker Hub. For the goals of this chapter, it is completely fine to have MLflow running on your local machine. </p><p>The second <a id="_idIndexMarker020"/>configuration that we add to our project is the main entry point command. The command to be executed will invoke in the Docker environment the <strong class="source-inline">train.py</strong> Python file, which contains the code of our project.</p></li>
				<li>Add a Docker file to the project.<p>Additionally, you can specify the Docker registry URL of your image. The advantage of running Docker is that your project is not bound to the Python language, as we will see in the advanced section of this book. The MLflow API is available in a Rest interface alongside the official clients: Python, Java, and R: </p><p class="source-code">FROM continuumio/miniconda:4.5.4</p><p class="source-code">RUN pip install mlflow==1.11.0 \</p><p class="source-code">    &amp;&amp; pip install numpy==1.14.3 \</p><p class="source-code">    &amp;&amp; pip install scipy \</p><p class="source-code">    &amp;&amp; pip install pandas==0.22.0 \</p><p class="source-code">    &amp;&amp; pip install scikit-learn==0.20.4 \</p><p class="source-code">    &amp;&amp; pip install cloudpickle \</p><p class="source-code">    &amp;&amp; pip install pandas_datareader&gt;=0.8.0</p><p>The preceding Docker image file is based on the open source package Miniconda, a free minimal installer with a minimal set of packages for data science that allow us to control the details of the packages that we need in our environment.</p><p>We will <a id="_idIndexMarker021"/>specify the version <a id="_idIndexMarker022"/>of MLflow (our ML platform), <strong class="source-inline">numpy</strong>, and <strong class="source-inline">scipy</strong> for numerical calculations. <strong class="source-inline">Cloudpickle</strong> allows us to easily serialize objects. We will use <strong class="source-inline">pandas</strong> to manage data frames, and <strong class="source-inline">pandas_datareader</strong> to allow us to easily retrieve the data from public sources.</p></li>
				<li>Import the packages required for the project.<p>On the following listing, we explicitly import all the libraries that we will use during the execution of the training script: the library to read the data, and the different <strong class="source-inline">sklearn</strong> modules related to the chosen initial ML model:</p><p class="source-code">import numpy as np</p><p class="source-code">import datetime</p><p class="source-code">import pandas_datareader.data as web</p><p class="source-code">from sklearn.model_selection import train_test_split</p><p class="source-code">from sklearn.ensemble import RandomForestClassifier</p><p class="source-code">from sklearn.metrics import classification_report</p><p class="source-code">from sklearn.metrics import precision_score</p><p class="source-code">from sklearn.metrics import recall_score</p><p class="source-code">from sklearn.metrics import f1_score</p><p class="source-code">import mlflow.sklearn</p><p>We explicitly chose for the stock market movement detection problem a <strong class="source-inline">RandomForestClassifier</strong>, due to the fact that it's an extremely versatile and widely accepted baseline model for classification problems.</p></li>
				<li>Acquire <a id="_idIndexMarker023"/>your training data.<p>The <a id="_idIndexMarker024"/>component of the code that acquires the Yahoo Finance stock dataset is intentionally small, so we choose a specific interval of 3 months to train our classifier.</p><p>The <strong class="source-inline">acquire_training_data</strong> method returns a <strong class="source-inline">pandas</strong> data frame with the relevant dataset:</p><p class="source-code">def acquire_training_data():</p><p class="source-code">    start = datetime.datetime(2019, 7, 1)</p><p class="source-code">    end = datetime.datetime(2019, 9, 30)</p><p class="source-code">    df = web.DataReader("BTC-USD", 'yahoo', start, end)</p><p class="source-code">    return df</p><p>The format of the data acquired is the classic format for financial securities in exchange APIs. For every day of the period, we retrieve the following data: the highest value of the stock, the lowest, opening, and close values of the stock, as well as the volume. The final column represents the adjusted close value, the value after dividends, and splits:</p><div id="_idContainer007" class="IMG---Figure"><img src="image/image001.jpg" alt="Figure 1.1 – Excerpt from the acquired data&#13;&#10;"/></div><p class="figure-caption">Figure 1.1 – Excerpt from the acquired data</p><p><em class="italic">Figure 1.2</em> is illustrative of the target variable that we would like to achieve by means of the current data preparation process:</p><div id="_idContainer008" class="IMG---Figure"><img src="image/image002.jpg" alt="Figure 1.2 – Excerpt from the acquired data with the prediction column&#13;&#10;"/></div><p class="figure-caption">Figure 1.2 – Excerpt from the acquired data with the prediction column</p></li>
				<li>Make <a id="_idIndexMarker025"/>the data usable by scikit-learn.<p>The data <a id="_idIndexMarker026"/>acquired in the preceding step is clearly not directly usable by <strong class="source-inline">RandomForestAlgorithm</strong>, which thrives on categorical features. In order to facilitate the execution of this, we will transform the raw data into a feature vector using the rolling window technique.</p><p>Basically, the feature vector for each day becomes the deltas between the current and <a id="_idIndexMarker027"/>previous window <a id="_idIndexMarker028"/>days. In this case, we use the previous day's market movement (1 for a stock going up, 0 otherwise):</p><p class="source-code">def digitize(n):</p><p class="source-code">    if n &gt; 0:</p><p class="source-code">        return 1</p><p class="source-code">    return 0</p><p class="source-code">def rolling_window(a, window):</p><p class="source-code">    """</p><p class="source-code">        Takes np.array 'a' and size 'window' as parameters</p><p class="source-code">        Outputs an np.array with all the ordered sequences of values of 'a' of size 'window'</p><p class="source-code">        e.g. Input: ( np.array([1, 2, 3, 4, 5, 6]), 4 )</p><p class="source-code">             Output:</p><p class="source-code">                     array([[1, 2, 3, 4],</p><p class="source-code">                           [2, 3, 4, 5],</p><p class="source-code">                           [3, 4, 5, 6]])</p><p class="source-code">    """</p><p class="source-code">    shape = a.shape[:-1] + (a.shape[-1] - window + 1, window)</p><p class="source-code">    strides = a.strides + (a.strides[-1],)</p><p class="source-code">    return np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)</p><p class="source-code">def prepare_training_data(data):</p><p class="source-code">    data['Delta'] = data['Close'] - data['Open']</p><p class="source-code">    data['to_predict'] = data['Delta'].apply(lambda d: digitize(d))</p><p class="source-code">    return data</p><p>The following example is illustrative of the data frame output produced with the binarized ups and downs of the previous days:</p><div id="_idContainer009" class="IMG---Figure"><img src="image/image003.jpg" alt="Figure 1.3 – Feature vector with binarized market ups and downs &#13;&#10;"/></div><p class="figure-caption">Figure 1.3 – Feature vector with binarized market ups and downs </p></li>
				<li>Train and <a id="_idIndexMarker029"/>store your model in MLflow.<p>This portion <a id="_idIndexMarker030"/>of the following code listing calls the data preparation methods declared previously and executes the prediction process.</p><p>The main execution also explicitly logs the ML model trained in the current execution in the MLflow environment.</p><p class="source-code">if __name__ == "__main__":</p><p class="source-code">    with mlflow.start_run():</p><p class="source-code">    training_data = acquire_training_data()</p><p class="source-code">    prepared_training_data_df = prepare_training_data(training_data)</p><p class="source-code">    btc_mat = prepared_training_data_df.as_matrix()</p><p class="source-code">    WINDOW_SIZE = 14</p><p class="source-code">    X = rolling_window(btc_mat[:, 7], WINDOW_SIZE)[:-1, :]</p><p class="source-code">    Y = prepared_training_data_df['to_predict'].as_matrix()[WINDOW_SIZE:]</p><p class="source-code">    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.25, random_state=4284, stratify=Y)</p><p class="source-code">    clf = RandomForestClassifier(bootstrap=True, criterion='gini', min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=50, random_state=4284, verbose=0)</p><p class="source-code">    clf.fit(X_train, y_train)</p><p class="source-code">    predicted = clf.predict(X_test)</p><p class="source-code">    mlflow.sklearn.log_model(clf, "model_random_forest")</p><p class="source-code">    mlflow.log_metric("precision_label_0", precision_score(y_test, predicted, pos_label=0))</p><p class="source-code">    mlflow.log_metric("recall_label_0", recall_score(y_test, predicted, pos_label=0))</p><p class="source-code">    mlflow.log_metric("f1score_label_0", f1_score(y_test, predicted, pos_label=0))</p><p class="source-code">    mlflow.log_metric("precision_label_1", precision_score(y_test, predicted, pos_label=1))</p><p class="source-code">    mlflow.log_metric("recall_label_1", recall_score(y_test, predicted, pos_label=1))</p><p class="source-code">    mlflow.log_metric("f1score_label_1", f1_score(y_test, predicted, pos_label=1))</p><p>The <strong class="source-inline">mlflow.sklearn.log_model(clf, "model_random_forest")</strong> method takes care of persisting the model upon training. In contrast to the previous example, we are <a id="_idIndexMarker031"/>explicitly asking MLflow to log <a id="_idIndexMarker032"/>the model and the metrics that we find relevant. This flexibility in the items to log allows one program to log multiple models into MLflow.</p><p>In the end, your project layout should look like the following, based on the files created previously: </p><p class="source-code">├── Dockerfile</p><p class="source-code">├── MLproject</p><p class="source-code">├── README.md</p><p class="source-code">└── train.py</p></li>
				<li>Build your project's Docker image.<p>In order to build your Docker image, you should run the following command:</p><p class="source-code"><strong class="bold">docker build -t stockpred -f dockerfile</strong></p><p>This will build the image specified previously with the <strong class="source-inline">stockpred</strong> tag. This image will be usable in MLflow in the subsequent steps as the model is now logged into your local registry. </p><p>Following execution of this command, you should expect a successful Docker build:</p><p class="source-code">---&gt; 268cb080fed2</p><p class="source-code">Successfully built 268cb080fed2</p><p class="source-code">Successfully tagged stockpred:latest</p></li>
				<li>Run your project.<p>In order <a id="_idIndexMarker033"/>to run your project, you can now run the MLflow project:</p><p class="source-code"><strong class="bold">mlflow run .</strong></p><p>Your output <a id="_idIndexMarker034"/>should look similar to the excerpt presented here: </p><p class="source-code">MLFLOW_EXPERIMENT_ID=0 stockpred:3451a1f python train.py' in run with ID '442275f18d354564b6259a0188a12575' ===</p><p class="source-code">              precision    recall  f1-score   support</p><p class="source-code">           0       0.61      1.00      0.76        11</p><p class="source-code">           1       1.00      0.22      0.36         9</p><p class="source-code">    accuracy                           0.65        20</p><p class="source-code">   macro avg       0.81      0.61      0.56        20</p><p class="source-code">weighted avg       0.79      0.65      0.58        20</p><p class="source-code">2020/10/15 19:19:39 INFO mlflow.projects: === Run (ID '442275f18d354564b6259a0188a12575') succeeded ===</p><p>This contains a printout of your model, the ID of your experiment, and the metrics captured during the current run.</p></li>
			</ol>
			<p>At this stage, you have a simple, reproducible baseline of a stock predictor pipeline using MLflow that you can improve on and easily share with others.</p>
			<h3>Re-running experiments</h3>
			<p>Another extremely useful feature of MLflow is the ability to re-run a specific experiment with the same <a id="_idIndexMarker035"/>parameters as it was run with originally.</p>
			<p>For instance, you should be able to run your previous project by specifying the GitHub URL of the project: </p>
			<p class="source-code">mlflow run https://github.com/PacktPublishing/Machine-Learning-Engineering-with-MLflow/tree/master/Chapter01/stockpred</p>
			<p>Basically, what happens with the previous command is that MLflow clones the repository to a temporary directory and executes it, according to the recipe on MLProject.</p>
			<p>The ID of the experiment (or the name) allows you to run the project with the original parameters, thereby enabling complete reproducibility of the project.</p>
			<p>The MLflow projects feature allows your project to run in advanced cloud environments such as Kubernetes and Databricks. Scaling your ML job seamlessly is one of the main selling points of a platform such as MLflow.</p>
			<p>As you have seen from the current section, the <strong class="bold">MLflow project</strong> module allows the execution of a reproducible ML job that is treated as a self-contained project.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>Exploring MLflow tracking</h2>
			<p>The <strong class="bold">MLflow tracking</strong> component <a id="_idIndexMarker036"/>is responsible for observability. The main <a id="_idIndexMarker037"/>features of this module <a id="_idIndexMarker038"/>are the logging of metrics, artifacts, and parameters of an MLflow execution. It provides vizualisations and artifact management features.</p>
			<p>In a production setting, it is used as a centralized tracking server implemented in Python that can be shared by a group of ML practitioners in an organization. This enables improvements in ML models to be shared within the organization.</p>
			<p>In <em class="italic">Figure 1.4</em>, you can see an interface that logs all the runs of your model and allows you to log your experiment's observables (metrics, files, models and artifacts). For each run, you can look and compare the different metrics and parameters of your module.</p>
			<p>It addresses common pain points when model developers are comparing different iterations of their models on different parameters and settings.</p>
			<p>The following <a id="_idIndexMarker039"/>screenshot presents the different <a id="_idIndexMarker040"/>metrics for our last run of the previous model:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/image004.jpg" alt="Figure 1.4 – Sample of the MLFlow interface/UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Sample of the MLFlow interface/UI</p>
			<p>MLflow allows the inspection of arbitrary artifacts associated with each model and its associated metadata, allowing metrics of different runs to be compared. You can see the RUN IDs and the Git hash of the code that generated the specific run of your experiment:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/image005.jpg" alt="Figure 1.5 – Inspecting logged model artifacts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Inspecting logged model artifacts</p>
			<p>In your <a id="_idIndexMarker041"/>current directory of <strong class="source-inline">stockpred</strong>, you can <a id="_idIndexMarker042"/>run the following command to have access to the results of your runs:</p>
			<p class="source-code">mlflow ui</p>
			<p>Running the MLflow UI locally will make it available at the following URL: <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>.</p>
			<p>In the particular case of the runs shown in the following screenshot, we have a named experiment where the parameter of the size of the window in the previous example was tweaked. Clear differences can be seen between the performance of the algorithms in terms of F1 score:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/image006.jpg" alt="Figure 1.6 – Listing of MLflow runs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Listing of MLflow runs</p>
			<p>Another very <a id="_idIndexMarker043"/>useful feature of MLFlow <a id="_idIndexMarker044"/>tracking is the ability to compare between different runs of jobs:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/image007.jpg" alt="Figure 1.7 – Comparison of F1 metrics of job runs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Comparison of F1 metrics of job runs</p>
			<p>This preceding visualization allows a practitioner to make a decision as to which model to use in production or whether to iterate further.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor025"/>Exploring MLflow Models</h2>
			<p><strong class="bold">MLflow Models</strong> is the <a id="_idIndexMarker045"/>core component that handles the different model <a id="_idIndexMarker046"/>flavors that are supported in MLflow and intermediates the deployment into different execution environments.</p>
			<p>We will <a id="_idIndexMarker047"/>now delve into the different models supported in the latest version of MLflow.</p>
			<p>As shown in the <em class="italic">Getting started with MLflow</em> section, MLflow models have a specific serialization approach for when the model is persisted in its internal format. For example, the serialized folder of the model implemented on the <strong class="source-inline">stockpred</strong> project would look like the following: </p>
			<p class="source-code">├── MLmodel</p>
			<p class="source-code">├── conda.yaml</p>
			<p class="source-code">└── model.pkl</p>
			<p>Internally, MLflow sklearn models are persisted with the <strong class="source-inline">conda</strong> files with their dependencies at the moment of being run and a pickled model as logged by the source code:</p>
			<p class="source-code">artifact_path: model_random_forest</p>
			<p class="source-code">flavors:</p>
			<p class="source-code">  python_function:</p>
			<p class="source-code">    env: conda.yaml</p>
			<p class="source-code">    loader_module: mlflow.sklearn</p>
			<p class="source-code">    model_path: model.pkl</p>
			<p class="source-code">    python_version: 3.7.6</p>
			<p class="source-code">  sklearn:</p>
			<p class="source-code">    pickled_model: model.pkl</p>
			<p class="source-code">    serialization_format: cloudpickle</p>
			<p class="source-code">    sklearn_version: 0.23.2</p>
			<p class="source-code">run_id: 22c91480dc2641b88131c50209073113</p>
			<p class="source-code">utc_time_created: '2020-10-15 20:16:26.619071'</p>
			<p class="source-code">~</p>
			<p>MLflow, by default, supports serving models in two flavors, namely, as a <strong class="source-inline">python_function</strong> or in <strong class="source-inline">s</strong><strong class="source-inline">klearn</strong> format. The flavors are basically a format to be used by tools or environments serving models.</p>
			<p>A good <a id="_idIndexMarker048"/>example of using the preceding is being <a id="_idIndexMarker049"/>able to serve your model without any extra code by executing the following command:</p>
			<p class="source-code">mlflow models serve -m ./mlruns/0/b9ee36e80a934cef9cac3a0513db515c/artifacts/model_random_forest/</p>
			<p>You have access to a very simple web server that can run your model. Your model prediction interface can be executed by running the following command:</p>
			<p class="source-code">curl http://127.0.0.1:5000/invocations -H 'Content-Type: application/json' -d '{"data":[[1,1,1,1,0,1,1,1,0,1,1,1,0,0]]}' [1]%</p>
			<p>The response to the API call to our model was <strong class="source-inline">1</strong>; as defined in our predicted variable, this means that in the next reading, the stock will move up.</p>
			<p>The final few steps outline how powerful MLflow is as an end-to-end tool for model development, including for the prototyping of REST-based APIs for ML services. </p>
			<p>The MLflow Models component allows the creation of custom-made Python modules that will have the same benefits as the built-in models, as long as a prediction interface is followed.</p>
			<p>Some of the notable model types supported will be explored in upcoming chapters, including the following: </p>
			<ul>
				<li>XGBoost model format</li>
				<li>R functions</li>
				<li>H2O model</li>
				<li>Keras</li>
				<li>PyTorch</li>
				<li>Sklearn</li>
				<li>Spark MLib</li>
				<li>TensorFlow</li>
				<li>Fastai</li>
			</ul>
			<p>Support for <a id="_idIndexMarker050"/>the most prevalent ML types of <a id="_idIndexMarker051"/>models, combined with its built-in capability for on-premises and cloud deployment, is one of the strongest features of MLflow Models. We will explore this in more detail in the deployment-related chapters.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor026"/>Exploring MLflow Model Registry</h2>
			<p>The model registry component in MLflow gives the ML developer an abstraction for model life <a id="_idIndexMarker052"/>cycle management. It is a <a id="_idIndexMarker053"/>centralized store for an organization or function that allows models in the organization to be shared, created, and archived collaboratively.</p>
			<p>The management of the model can be made with the different APIs of MLflow and with the UI. <em class="italic">Figure 1.7</em> demonstrates the Artifacts UI in the track<a id="_idTextAnchor027"/>ing server that can be used to register a model:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/image008.jpg" alt="Figure 1.8 – Registering a model as an artifact&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Registering a model as an artifact</p>
			<p>Upon registering the model, you can annotate the registered model with the relevant metadata and manage its life cycle. One example is to have models in a staging pre-production environment and manage the life cycle by sending the model to production:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/image009.jpg" alt="Figure 1.9 – Managing different model versions and stages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Managing different model versions and stages</p>
			<p>The model <a id="_idIndexMarker054"/>registry module will be <a id="_idIndexMarker055"/>explored further in the book, with details on how to set up a centralized server and manage ML model life cycles, from conception through to phasing out a model.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor028"/>Summary</h1>
			<p>In this chapter, we introduced MLflow, and explored some of the motivation behind adopting a ML platform to reduce the time from model development to production in ML development. With the knowledge and experience acquired in this chapter, you can start improving and making your ML development workflow reproducible and trackable.</p>
			<p>We delved into each of the important modules of the platform: projects, models, trackers, and model registry. A particular emphasis was given to practical examples to illustrate each of the core capabilities, allowing you to have a hands-on approach to the platform. MLflow offers multiple out-of-the-box features that will reduce friction in the ML development life cycle with minimum code and configuration. Out-of-the-box metrics management, model management, and reproducibility are provided by MLflow.</p>
			<p>We will build on this introductory knowledge and expand our skills and knowledge in terms of building practical ML platforms in the rest of the chapters. </p>
			<p>We briefly introduced in this chapter the use case of stock market prediction, which will be used in the rest of the book. In the next chapter, we will focus on defining rigorously the ML problem of stock market prediction.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor029"/>Further reading</h1>
			<p>In order to enhance your knowledge, you can consult the documentation available at the following links:</p>
			<ul>
				<li>Reference information for MLflow is available here: <a href="https://www.mlflow.org/docs/latest/">https://www.mlflow.org/docs/latest/</a></li>
				<li>Review notes on ML platforms: <a href="https://medium.com/nlauchande/review-notes-of-ml-platforms-uber-michelangelo-e133eb6031da">https://medium.com/nlauchande/review-notes-of-ml-platforms-uber-michelangelo-e133eb6031da</a></li>
				<li>MLflow technical paper: <a href="https://www-cs.stanford.edu/people/matei/papers/2018/ieee_mlflow.pdf">https://www-cs.stanford.edu/people/matei/papers/2018/ieee_mlflow.pdf</a></li>
			</ul>
		</div>
	</body></html>