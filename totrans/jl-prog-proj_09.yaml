- en: Working with Dates, Times, and Time Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've had quite an amazing and rewarding journey through the realm of machine
    learning. We have learned how to use algorithms to classify labeled data and apply
    our findings to make recommendations. We have seen how to extract business value
    from raw, unlabeled information by using unsupervised machine learning and clustering
    algorithms. However, one key component has been missing from our analysis so far—the
    temporal dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '*Time is money,* the saying goes—and as such, organisations of all sizes, from
    small businesses to large corporations, to governments, to complex multinational
    institutions such as the European Union, continuously measure and monitor a multitude
    of economic indicators over time. To be meaningful, the data is collected at regular
    intervals, allowing analysts to identify hidden structures and patterns, and predict
    future developments based on past and present conditions. These values, measured
    regularly on a time scale, represent a time series. Time series analysis and forecasting
    can provide extremely valuable insight, allowing market actors to understand trends
    and make informed decisions based on accurate historical data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will dedicate two chapters, this one and the next one, to learning about
    time series and performing analysis and forecasting. In this chapter, we''ll lay
    the foundations by learning about:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with dates and times in Julia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling time zone information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing time series data with `TimeSeries`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting time series data with the powerful `Plots` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TimeArray` data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to install a specific version of a package you need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Working with dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia provides a very rich API for handling date and time information. All the
    functionality is packed into the `Dates` module. The module is built in to the
    language so there's no need for additional package installs. In order to access
    its functionality, all we have to do is declare that we'll be `using Dates`.
  prefs: []
  type: TYPE_NORMAL
- en: The dates module exposes three main types—`Date`, `DateTime`, and `Time`. They
    are all subtypes of the abstract `TimeType` type and represent day, millisecond,
    and nanosecond precision, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia tries to make working with dates and times as simple as possible. This
    is the reason why, on the one hand, it provides three distinct types, each with
    its own temporal representation:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Date` object maps to a date—a time entity defined by a day, a month, and
    a year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of `Time` is a moment in time—the hour, the minute, the second,
    and the milliseconds, but with absolutely no information about the date itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DateTime`, as you may have guessed from the name, is an object which puts
    together a `Date` and a `Time`, specifying an exact moment in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, all these types have, by default and by design, a naive approach
    to representing dates and times—that is, they do not take into consideration things
    like time zones, daylight savings, or leap seconds. It's a portrayal of your computer's
    local date and time, without any extra information.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to construct new date/time objects representing the current date or
    time, Julia provides two helper functions, `now` and `today`. Let''s look at some
    examples in the **read-eval-print loop** (**REPL**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `now` function can also accept an additional argument to return the UTC
    time (without local adjustments for daylight savings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, all the types wrap an `Int64` value that can be accessed through
    the `instant` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `instant` property of the objects reflects the precision level of each type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can also instantiate objects that represent any random moment
    in time using the dedicated constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructors work in similar ways for `Date` and `Time`—here are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructors will prevent us from passing the wrong values, resulting in
    an error. This can be different from other languages that automatically perform
    date-time arithmetic where, for instance, December 22, 2018 would be automatically
    converted into January 1, 2019\. That won''t happen in Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also constructors for the individual date and time components—years,
    months, days, hours, minutes, seconds, and milliseconds. They return instances
    of the corresponding `Period` type (we''ll take a look at periods in detail a
    bit later). Periods can be used to create date/time objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Parsing strings into dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common requirement is parsing properly formatted strings coming from an external
    input (databases, files, user input, and so on) into corresponding date and time
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the special date-time characters recognised by Julia, together with
    their significations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`y`: Year digit, example `yyyy` for `2015`, `yy` for `15`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: Month digit, example `m => 3` or `03`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: Short month name, example `Jan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U`: long month name, example `January`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e`: Short day of week, example `Tue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E`: Long day of week, example `Tuesday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: Day, example `3` or `03`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`: Hour digit, example `HH` = `00`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: Minute digit, example `MM` = `00`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S`: Second digit, example `s` = `00`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: Millisecond digit, example `.000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these, we can parse any date/time string into the correct object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also parse multiple strings at once, as elements of an array. First,
    we create an array of strings that represents valid dates, formatted as `yyyy-mm-dd`.
    We use a comprehension to create the array and name it `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use dot notation to process the array element-wise using the `Date`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, instead of using a string to represent the format of the date,
    we can use a specialized `DateFormat` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a `DateFormat` is recommended when parsing a large number of strings
    for better performance. Julia provides a few formats as part of the standard library,
    for instance, `ISODateTimeFormat` and `RFC1123Format`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Formatting dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we can parse date-formatted strings into date/time objects, we can also
    do the reverse. We can output our dates and times as strings using various formats.
    See the following, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Defining other locales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Julia will use the `english` locale, meaning that the names of
    the days and months will be in English. However, we can internationalize our dates
    by defining additional locales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dates.DateLocale` function expects four arrays, corresponding to each
    of the month names, abbreviated month names, day names, and abbreviated day names.
    As you can see, we haven''t provided the abbreviated versions of the names. As
    long as we don''t try to use them, we''ll be fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, attempting to use the abbreviated day name will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Working with date and time accessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to access the individual parts of a date (year, month, day), we
    can retrieve the various components through the available accessor functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The API also exposes compound methods, for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar accessors are available for `DateTime`—but no compound methods are
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternative accessors that return `Period` objects are also defined—they have
    uppercase names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Querying dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have a date object, we can get a wealth of extra information about it,
    such as the day of the week, leap year, day of the year, and so on. We can use
    the `Dates` API to extract this kind of information about our date/time object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Are you curious when Yoga day falls in 2019? Let''s use our Julia skills to
    figure that out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you need the numerical value of the day (within the week), there's also `dayofweek(yoga_day)`,
    that obviously returns `5`, since Friday is the fifth day of the week.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can use localized names here too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Another useful function we can call is `dayofweekofmonth(yoga_day)`, which will
    tell us which Friday of the month it is—it's the third Friday of the month of
    June, in 2019.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not sure how this can be useful, take for example, events that always
    take place with regularity on a certain day of the month. A good example is a
    meetup I attend that always takes place on the third Thursday of each month.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also get a wealth of information about the month and the year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `Dates` API is very rich, including a lot more methods than it would make
    sense to present here. Please visit the documentation page at [https://docs.julialang.org/en/v1/stdlib/Dates/index.html#stdlib-dates-api-1](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#stdlib-dates-api-1).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the date ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia allows us to define ranges of dates to express continuous periods of
    time. For example, we could represent the whole year as the range of days between
    January 1 and December 31:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a date range with a step of one day—so `365` items, since 2019
    is not a leap year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate the actual `Date` objects using the aptly named `collect`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, of course, we can access the elements by index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to define ranges with other steps, such as monthly intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass any `Period` object for the step, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Period types and period arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen some of the `Period` constructors. These are all the available
    ones—`Day`, `Week`, `Month`, `Year`, `Hour`, `Minute`, `Second`, `Millisecond`,
    `Microsecond`, and `Nanosecond`. The `Period` type is an abstract type with two
    concrete subtypes, `DatePeriod` and `TimePeriod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`Period` in Julia represents a duration of time. It is a very useful abstraction
    representing vague time concepts that people use routinely. Think about a month—how
    many days does a month have—30 or 31? What about 28? Or 29?'
  prefs: []
  type: TYPE_NORMAL
- en: Many times, it can be useful to work with vague abstractions without switching
    to actual dates until more information is provided. Take, for instance, the hypothetical
    case of a trip to Mars. According to [https://image.gsfc.nasa.gov/poetry/venus/q2811.html](https://image.gsfc.nasa.gov/poetry/venus/q2811.html)[,
    a return trip to Mars will take `21 months`—`9` to get there, `3` to stay there,
    and `9` more to get back:](https://image.gsfc.nasa.gov/poetry/venus/q2811.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Exactly how long these 21 months will take is undetermined until we actually
    decide when we start the trip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can compute how long the astronauts will be gone for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if, for technical reasons, the launch date will be postponed by five
    months, the result will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It is important to keep in mind that unlike other programming languages, which
    make assumptions about the default length of a month—such as 31 days in JavaScript
    or 30 days in PHP—Julia takes a different approach. For a detailed explanation
    of `Period` arithmetic, you can read the official documentation at [https://docs.julialang.org/en/v1/stdlib/Dates/index.html#TimeType-Period-Arithmetic-1.](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#TimeType-Period-Arithmetic-1)
  prefs: []
  type: TYPE_NORMAL
- en: 'A period doesn''t necessarily need to be a complete amount of time. Julia allows
    us to express irregular intervals like `1` month and `2` weeks. However, an irregular
    amount of time (which combines different types of periods) will be internally
    represented by a different type—not the `Period`, but the `CompoundPeriod`. Here''s
    how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Date adjustments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Period` arithmetic is very powerful, but sometimes we need to express more
    flexible rules that are dependent on other dates. I''m thinking about *last day
    of the next month*, *next Tuesday*, or *the third Monday of each month*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For such cases, the `Dates` module exposes the adjuster API. For starters,
    we have the `firstdayof*` and the `lastdayof*` family of functions—`firstdayofweek`,
    `firstdayofmonth`, `firstdayofquarter`, and `firstdayofyear`; plus `lastdayofweek`,
    `lastdayofmonth`, `lastdayofquarter`, and `lastdayofyear`, respectively. They
    take as input a date/time object and *adjust* it to the indicated point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In 2019, the first day of the week includes January 31 is Monday, 28.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lastdayof*` family of functions works in a similar manner. But useful
    as they are, they don''t provide enough flexibility. Luckily, we''re covered.
    If we need other dates apart from the first or the last day, we have to reach
    for the `tonext` and `toprev` pair of functions. They come in two flavors. The
    first method takes a subtype of `TimeType` (that is, any `Time`, `Date`, `DateTime`)
    and a day of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The next Saturday after April Fool's Day falls on April 7 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other method of `tonext` is even more powerful—it accepts a similar `TimeType`
    and a function. It will adjust the date until the function returns `true`. To
    understand how useful this is, let''s get back to our previous meetup example,
    the meeting I attend every third Thursday of each month. To find out when the
    next meeting will take place, all I have to do is ask Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `toprev` function works in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another function, `filter`, allows us to obtain all the matching dates as an
    `Iterator`. Following up on our meetups schedule, let''s try to find out the dates
    of all the meetings in 2019\. But we must also take into account that in the second
    half of May, the organizer will attend a business trip, and that August is a holiday
    month. So, there won''t be meetings during these intervals. How would we express
    this? It turns out that with Julia, it''s quite simple (and very readable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Rounding of dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There might be situations where we have a date/time and a need to compute the
    previous, or next complete time interval, for example, the next hour, or the previous
    day. The `Dates` API exposes a few methods for rounding `Date` and `DateTime`
    objects—`floor`, `ceil`, and `time`. They are quite intuitive and very powerful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ceil` function works similarly, but instead of rounding down, it rounds
    up. As for the `round` function, it will round up or down, depending on whichever
    is the closest value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Rounding can behave unexpectedly in a few edge cases—for more details please
    check the official documentation at [https://docs.julialang.org/en/v1/stdlib/Dates/index.html#Rounding-1](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#Rounding-1).
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for time zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously mentioned, by default, Julia''s date/time objects operate in
    local time, completely ignoring time zones. However, we can easily extend them
    to become time-zone aware using the `TimeZones` package. Please install it in
    the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once we inform the compiler that we'll be using `TimeZones`, a wealth of timezone-related
    functionalities become available at our fingertips.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by exploring the available time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a time zone object for `Amsterdam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In Julia, a `TimeZone` is an abstract type that represents information regarding
    a specific time zone, which means that it can't be instantiated—we can't create
    objects of this type. Instead, one of its two subtypes will be automatically used—`VariableTimeZone`
    or `FixedTimeZone`. `VariableTimeZone` represents a time zone whose offset changes
    depending on the time of the year—to take into account summertime/daylight savings
    time. `FixedTimeZone` has an invariable offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Europe/Amsterdam (UTC+1/UTC+2)` is such a `VariableTimeZone`. This is
    indicated by the information within the round brackets, signaling the two offsets
    of this time zone. Checking the type will confirm it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The time zones that don''t change their offsets are instances of `FixedTimeZone`.
    Such examples are `UTC` and `GMT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TimeZones` package also provides a special string literal, `tz"..."`.
    It exposes the same functionality as `TimeZone(...)` with a bit less typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Armed with this knowledge, we can now create time zone-aware date/time values.
    These come in the form of `ZonedDateTime` objects, and, as the name suggests,
    represent a mixture of `DateTime` and `TimeZone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be written a bit more succinctly by skipping the explicit invocation
    of `DateTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TimeZones` module also provides a series of utility methods. First of
    all, we can retrieve the local time zone by using the aptly named `localzone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: I live in Barcelona, so this is my current time zone—your output will correspond
    to your actual time zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two extension methods are provided for `now` and `today`—in the form of `now(::TimeZone)`
    and `today(::TimeZone)`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of `today(::TimeZone)`, another function, `todayat`, can be used with
    two arguments—the time of the day as a `Time` object and a `TimeZone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This time we get 10:30 P.M., `Moscow` time.
  prefs: []
  type: TYPE_NORMAL
- en: Converting time zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most basic things we''ll want to do is to convert a `DateTime` from
    one time zone to another. That''s straightforward with the `astimezone` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: While you're celebrating Christmas in Vienna at 8 P.M., in Sydney, Australia,
    it will already be 6 A.M. the next day.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing date strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how to parse date and date/time strings using Julia''s
    `Dates` API. The `TimeZones` package takes this functionality one step further,
    allowing us to parse date/time strings that include time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: ZonedDateTime period arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be happy to hear that arithmetic with time zone-aware objects works
    just like its regular `TimeType` counterpart. However, you have to take extra
    care when dealing with periods of time that start in an offset (as in wintertime)
    and finish in another offset (say, summertime). For instance, let's see what happens
    when we play with times around the moment when Europe switches to daylight savings
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The clock changes during the last Sunday of March. Take a minute and try to
    find out the date of the last Sunday of March in 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s my solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s give it a time zone—let''s say, London''s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a day to this will cause the time zone to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if we now remove the equivalent of one day, but in hours? We should
    get the value of `london_time` again, right? Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Oops, not quite! Subtracting `24` hours actually pushed us one hour earlier
    than `london_time`. The reason for this is that the change of offset (switching
    to summertime) effectively caused a whole hour at 2 A.M. to be skipped on the
    25th, making that day only 23 hours long.
  prefs: []
  type: TYPE_NORMAL
- en: Time zone-aware date ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important thing to keep in mind when dealing with time zones involves
    date ranges. If the start item of your range is in a time zone, but the end item
    is in a different time zone, the resulting value corresponding to the end item
    will be silently converted to the time zone of the start item. An example will
    make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The last item in the array, `2018-08-01T15:00:00+01:00`, represents the same
    time as the end item in the interval, `2018-08-02T00:00:00+10:00`—but it''s using
    the London time zone, not Sydney''s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It's the same time, but a different time zone.
  prefs: []
  type: TYPE_NORMAL
- en: Time series data in Julia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A time series is a collection of observations of well-defined data items obtained
    via repeated measurements over time. This collection of quantitative observations
    is ordered, allowing us to understand the underlying structure. Examples of such
    data include the daily closing price of a company's stock, quarterly sales figures
    for a retailer, continuous monitoring of a person's blood glucose levels, or hourly
    air temperatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia''s package ecosystem provides a powerful functionality for working with
    time series through the `TimeSeries` package. The package provides an extensive
    API that covers the full range of tasks, from reading and writing CSV files with
    temporal data, to filtering and segmenting time series, to mathematical and logical
    operators, and plotting. Let''s add it to our toolbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get some time series data. The easiest thing we can do is to reach
    for the `MarketData` package, it provides open source financial data for research
    and testing and works flawlessly with `TimeSeries`. Once you install it in the
    usual way (`pkg> add MarketData`), the module will expose a series of variables
    corresponding to different datasets. Some of them are small test databases, called
    `cl`, `ohcl`, `ohlcv`, and so on. For example, the `ohcl` dataset contains 500
    rows of market data, from January 3, 2000 to December 31, 2001—each row contains
    a `Date`, plus the `Open`, `High`, `Low`, and `Close` values. Here''s what it
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that it''s of the type `TimeArray` and it spans the time interval
    I just mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb05f02d-8eab-4dfd-aa5f-0736a22adb87.png)'
  prefs: []
  type: TYPE_IMG
- en: The `MarketData` module also exposes larger historical prices and volume data
    for three major companies—Apple (`AAPL`), Boeing (`BA`), and Caterpillar (`CAT`).
  prefs: []
  type: TYPE_NORMAL
- en: A quick look at our data with Plots and PyPlot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the old saying goes, A* picture is worth a thousand words*, so let's get
    a quick feel for our data by plotting it. It's a great opportunity to introduce
    one of the best Julia data visualization packages—`Plots`. Unlike `Gadfly`, which
    we've previously used, `Plots` takes a different approach—it's an interface over
    many different plotting libraries. Basically, it's like middleware, providing
    a common, unifying API for other plotting packages (called **backends**). In Julia,
    different plotting packages have different features and strengths—and depending
    on the user's specific needs, they may be forced to learn yet another library,
    change the code, and so on, in order to interchangeably use different plotting
    packages. `Plots` addresses this problem through a unifying API coupled with a
    simple mechanism that allows for swapping backends on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: The `Plots` package supports the following backends—`PyPlot`, `Plotly` or `PlotlyJS`,
    `GR`, `UnicodePlots`, `PGFPlots`, `InspectDR`, and `HDFS5`. Which one should you
    use? It depends on the actual use case, but as a general rule, in the words of
    `Plots` author—*GR for speed, Plotly(JS) for interactivity, PyPlot otherwise*.
  prefs: []
  type: TYPE_NORMAL
- en: Please read the official documentation at [http://docs.juliaplots.org/latest/backends/](http://docs.juliaplots.org/latest/backends/)
    to understand the pros and cons of each backend.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use `PyPlot`, a Julia wrapper for the popular Python package with the
    same name. Let's install both `Plots` and `PyPlot`. Running `pkg> add Plots` should
    be straightforward. Next, `pkg> add PyPlot` will be more involved. As `PyPlot`
    uses `PyCall.jl` to invoke Python code, depending on your current Julia installation,
    `Pkg` might also have to install the `miniconda` Python distribution. So it might
    take a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using `Plots` with `PyPlot`, please make sure you run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `pyplot` function configures the `PyPlot` backend to be used by `Plots`.
  prefs: []
  type: TYPE_NORMAL
- en: Right after installing `PyPlot`, when attempting to run `pyplot()`, you might
    get an error. Please follow the instructions provided by the package and restart
    the Julia REPL if so advised.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now ready to go! The module exposes the `plot` function, which at its
    simplest can be invoked with two collections of values, corresponding to the x
    and y coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a plot being rendered in a new window—mine looks like this,
    but since we''re visualising random values, yours will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24e3b1b9-6fa8-40b5-9482-315774c49d10.png)'
  prefs: []
  type: TYPE_IMG
- en: It's a plot of ten random values, rendered by `PyPlot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One cool thing about these plots is that they can be mutated using the `plot!`
    function. For instance, we can add two lines to it by plotting a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e2175ee-847b-4e60-992e-c05ada127727.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Plots can be enhanced using attributes. They allow us to add labels, titles,
    and to style the visualizations and so on. For instance, here''s how we''d render
    our previous plot with extra attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5689f91d-543f-4d47-ab6f-029a6eae6867.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The API also exposes functions for modifying the plot after it has been rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/396804be-9e5f-457b-992e-caaceafbb178.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Going back to our market data, you''ll be happy to hear that `TimeSeries` provides
    out-of-the-box integration with `Plots`. All we have to do is run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/773c1573-a29b-47c6-8e9b-4357d1258405.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the market had been growing, reaching a peak in March 2000,
    then dropping suddenly to around 50–60\. It stayed there for a few months, and
    then it dropped again at the end of September and stayed under 30 all the way
    through to the end of 2001\. The four values, `Open`, `Close`, `High`, and `Low`
    seem to be highly correlated. We can plot them individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9fd4d5e-cf7f-49ae-8805-8a86d4ee1388.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can append extra values like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29a912d7-2bf6-4fab-b2b5-18350a9f8a5a.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing the high versus low values, we can see higher variations in the
    periods before the market crash.
  prefs: []
  type: TYPE_NORMAL
- en: The TimeArray type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So what''s with this `TimeArray` then, you may be wondering? It does look like
    an interesting beast, in that we can index into it using square brackets and the
    names of columns. We can use the `fieldnames` function to see what properties
    it exposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, a `TimeArray` is a composite type—a `struct`, in Julia parlance—with
    four fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `timestamp` field represents a vector of time values—the ones that hold
    the temporal coordinates of our time series. So if we look at our `TimeArray`
    object, we''ll see this in the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb9db558-b55e-4d3c-954e-9343e9c66ade.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this output, `2000-01-03` is the first value in the `timestamp` array. We
    can access the array using the `timestamp` getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the actual information in the dataset, its type can be `Date` (as
    in our case), `Time`, or `DateTime`—any subtype of `TimeType`.
  prefs: []
  type: TYPE_NORMAL
- en: When constructing a `TimeArray`, you must be careful because the `timestamp`
    data has to be sorted—otherwise, the constructor will error out.
  prefs: []
  type: TYPE_NORMAL
- en: 'By analogy, with the `timestamp` field, you can probably guess what the `values`
    property is all about. It holds the numerical data of the time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8b84b6a-445e-4ffd-a2c5-ae055a8b7e07.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, the row count of the `values` array must match the length of the
    `timestamp` collection. Less obviously, all the values inside the `values` array
    must be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, each row in a `TimeArray` is composed of an item from the `timestamp`
    collection and the corresponding row from the `values` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6814dcbf-990b-40f3-8638-045d726da3fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `colnames` function returns the array of column names for each column in
    the values field. They are returned as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The only hard constraint here is that the number of items in the `colnames`
    vector must match the number of columns in the `values` collection. Due to the
    fact that `TimeArrays` are indexable by column name, duplicate strings in the
    `colnames` vector will be modified automatically by the constructor. Each subsequent
    duplicate name will be appended with *n,* where *n* starts from `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not happy with the columns names, they can be changed using the
    `rename` method, passing in the `TimeArray` object and an array of column names
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `meta` field is supposed to be used for attaching meta-information
    to the object. By default, it is empty and can be set by the programmer, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing the TimeArray objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `TimeSeries` library exposes a powerful API for accessing information structured
    as `TimeArray` data. We have already seen that we can access individual columns
    by indexing by column name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'It results in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/586df468-4d42-44f5-9328-7d3101990d98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can even use a combination of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52baa074-d17e-424a-b380-3906fbfbbcb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also index into the array using row IDs and dates/times (corresponding
    to the `timestamp` values). Let''s try to pick up the row with the highest `Close`
    value. First, let''s find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The highest closing value was `144.19`. Please note that indexing by column
    name returns another instance of `TimeArray`, so to get its underlying numerical
    values, we need to use the `values` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can find its corresponding index. We can quickly get an array of the
    indices of all the values that are equal to `144.19` by using `findall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'That would be row `56`. We can use this information to index into the time
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42806baa-f24a-4cfb-a27e-efbab4071af9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is March 22, 2000. If we''d like to see the rows before and after, we
    can do it easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the resulting `TimeArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f0b8825-445a-4517-845e-e95f831e19f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to check the values for the same day of the week, before and after
    our date, indexing by range supports a step parameter. We can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We filter every seventh day, starting with the seventh row, all the way to
    the seventieth row; that is, every `Wednesday`, as indicated by `Dates.dayname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: If we want to retrieve all the Wednesdays, we can, of course, use the `end`
    keyword, as in `MarketData.ohlc[7:7:end]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we''re happy with this, but we''d like to get more context on our
    date. So, we want all the Wednesdays plus the day before and the day after our
    date. We can do this too by indexing with an array of indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/145d0095-c6e0-45fb-a710-166e61811c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we pull each seventh row between 7 and 49, then the rows 54, 55, 56, and
    57, and then each seventh row between 63 and 70.
  prefs: []
  type: TYPE_NORMAL
- en: '`TimeArray` indexing is very flexible, but keep in mind that the rows must
    always be ordered by date. This is the reason why we can''t say, for instance,
    [`7:7:70`; `54;55;56;57`]—the elements would be out of order. And speaking of
    errors, including duplicate rows will also result in an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also index using date/time objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/186fe5fa-0504-4ba5-8ecc-03f9b669a4cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And yes, we can use date/time ranges too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec7bca41-878f-4422-8d74-01e6cf5fe4e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using other date range steps will work equally well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining multiple indices works too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can come up with any combination of columns and rows we can imagine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5779849-23df-4573-9bc9-9baaee302341.png)'
  prefs: []
  type: TYPE_IMG
- en: Querying TimeArray objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TimeSeries` module exposes a powerful, query-like API for filtering time
    series data. Let's take a look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The when() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `when` method allows for aggregating elements from a `TimeArray` into specific
    time periods. For instance, we can use this function to pick the Wednesdays in
    our dataset in a more concise fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not limited to just `Dates.dayname`; we can use many of the `Dates`
    functions we covered in the previous section—`day`, `dayname`, `week`, `month`,
    `monthname`, `year`, `dayofweek`, `dayofweekofmonth`, `dayofyear`, `quarterofyear`,
    and `dayofquarter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The from() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function truncates a `TimeArray` starting with the date passed to the
    method. The row corresponding to the passed date is included in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55b57b0f-a293-455c-a2b0-0dab1525eef2.png)'
  prefs: []
  type: TYPE_IMG
- en: The to() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `to()` method returns the rows up to and including the date passed as an
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The findall() and findwhen() methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This family of functions tests a condition and returns the results for which
    the condition is true. The only difference is that `findall()` returns an array
    containing the numbers of the rows, while `findwhen()` returns a vector of date/time
    objects. For example, if we want to find all the rows where the closing value
    was at least 10% higher than the opening value, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '`findwhen` will produce a similar output, but for the dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating time series objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TimeSeries` exposes a minimalist, yet productive set of methods for modifying
    `TimeArray` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: merge()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For starters, we can combine the data from two `TimeArrays`. The `merge` method
    uses the timestamps as the join columns—and by default, it performs an inner join.
    But it''s also possible to perform left, right, and outer joins. Let''s generate
    some random data to experiment with. We''ll start by creating a time series with
    random values, spread over a week, starting today:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48da86e4-5b2e-47c9-9a5a-7f2805468a5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we''ll create another time series object spread over ten days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f8eeb8c-ad11-46b2-9e8d-86caa687e8d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So now we have two `TimeArray` instances, `t1` and `t2`. The `t2` object has
    values for all the days in `t1` plus three more days. A regular (inner join) `merge`
    will only use the rows with timestamps that are present in both `t1` and `t2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39a85886-a371-49c0-8d6a-f6c5cdbb1269.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right, left, and outer joins will introduce `NaN` values for the rows that
    don''t correspond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/540ce8d0-6f8f-4667-af5a-78e86e19902c.png)'
  prefs: []
  type: TYPE_IMG
- en: The vcat() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `vcat()` method can be considered the counterpart of `merge`. If `merge`
    joins the columns of two time series, `vcat` combines their rows. Its most obvious
    use case is for putting together data from a dataset that is split into multiple
    files. Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c45534bb-8872-49f5-a4d3-09e88dbbb1c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have created a new `TimeArray` which covers the time period between two
    weeks and three weeks from today:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the resulting `TimeArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/007b4a8f-21bc-41fe-8aea-05e93947e9d2.png)'
  prefs: []
  type: TYPE_IMG
- en: The resulting time series combines data from both `t1` and `t3`.
  prefs: []
  type: TYPE_NORMAL
- en: The collapse() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method allows for compressing data into a larger time frame, for instance
    converting daily data into weekly data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/610ec7a7-e78c-4718-8593-139b1f9adfdc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to `collapse` the `january` time series, we need to decide what
    to do about the data that''s being collapsed. This is achieved by passing function
    arguments. The general form of the method is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, we can `collapse` the data for January into a weekly period (the
    `<time function>`) by keeping the last day of the period (the `<time filtering
    function>`) and by computing the mean of the values (the `<value collapsing function>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd0c2612-3271-47ef-845d-a2e3c898aa3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `<value collapsing function>` is optional and if not provided, the values
    that correspond to the timestamp will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc35d17e-515d-43a4-99ba-3625b30aae4e.png)'
  prefs: []
  type: TYPE_IMG
- en: The map() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, the `map()` function allows us to iterate over each row in the time
    series and apply a function to both the timestamps and the values. We could easily
    postpone the first week in the `january` time series by one year, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6703bb47-ea7a-4990-8be1-bda091b7c9b8.png)'
  prefs: []
  type: TYPE_IMG
- en: There is more to say about `TimeSeries`. But for now, we'll stop here. We'll
    get back to `TimeArray` in the next chapter, where we will use it to perform time
    series analysis and forecasting on the European Union's unemployment numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about working with dates and times in Julia.
    The language provides a powerful, yet accessible API that follows Julia's overall
    philosophy—you can start simple and augment your code as you become more knowledgeable.
    Thus, by default, the date/time objects use local time, ignoring complex details
    like time zones. However, time zone support is only one package away. We have
    seen how to extend Julia's `Dates` API by using the functionality provided by
    `TimeZones`.
  prefs: []
  type: TYPE_NORMAL
- en: Using our understanding of temporal data, we were able to take yet another step
    towards becoming proficient Julia programmers and learned about time series and
    the powerful `TimeArray`. We've seen how to plot time series with `Plots`, an
    extremely versatile plotting library for Julia—in fact, it's middleware providing
    a common API for a series of visualization packages, allowing us to swap backends
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our discussion of time series by performing
    analytics and forecasting on unemployment levels in the European Union. In the
    process, we'll learn about the most important patterns of time series analysis—trends,
    seasonality, and irregularity, and we will expand our knowledge of `TimeSeries`
    by performing various time series transformations.
  prefs: []
  type: TYPE_NORMAL
