- en: Working with Dates, Times, and Time Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与日期、时间和时间序列一起工作
- en: We've had quite an amazing and rewarding journey through the realm of machine
    learning. We have learned how to use algorithms to classify labeled data and apply
    our findings to make recommendations. We have seen how to extract business value
    from raw, unlabeled information by using unsupervised machine learning and clustering
    algorithms. However, one key component has been missing from our analysis so far—the
    temporal dimension.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在机器学习的领域中经历了一段非常令人惊叹和有益的旅程。我们学习了如何使用算法对标记数据进行分类，并将我们的发现应用于提出建议。我们看到了如何通过使用无监督机器学习和聚类算法从原始、未标记的信息中提取商业价值。然而，到目前为止，我们的分析中一直缺少一个关键组成部分——时间维度。
- en: '*Time is money,* the saying goes—and as such, organisations of all sizes, from
    small businesses to large corporations, to governments, to complex multinational
    institutions such as the European Union, continuously measure and monitor a multitude
    of economic indicators over time. To be meaningful, the data is collected at regular
    intervals, allowing analysts to identify hidden structures and patterns, and predict
    future developments based on past and present conditions. These values, measured
    regularly on a time scale, represent a time series. Time series analysis and forecasting
    can provide extremely valuable insight, allowing market actors to understand trends
    and make informed decisions based on accurate historical data.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “时间就是金钱”，这句俗语说得好——因此，从小型企业到大型企业，再到政府，以及像欧盟这样的复杂跨国机构，所有规模的组织都会随着时间的推移持续测量和监控大量的经济指标。为了有意义，数据需要在固定的时间间隔内收集，以便分析师能够识别隐藏的结构和模式，并根据过去和现在的条件预测未来的发展。这些值在时间尺度上定期测量，代表时间序列。时间序列分析和预测可以提供极其宝贵的见解，使市场参与者能够理解趋势，并基于准确的历史数据做出明智的决策。
- en: 'We will dedicate two chapters, this one and the next one, to learning about
    time series and performing analysis and forecasting. In this chapter, we''ll lay
    the foundations by learning about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用两章内容，这一章和下一章，来学习时间序列以及进行分析和预测。在这一章中，我们将通过学习以下内容来打下基础：
- en: Working with dates and times in Julia
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中与日期和时间一起工作
- en: Handling time zone information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时区信息
- en: Processing time series data with `TimeSeries`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TimeSeries` 处理时间序列数据
- en: Plotting time series data with the powerful `Plots` package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用强大的 `Plots` 包绘制时间序列数据
- en: The `TimeArray` data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeArray` 数据结构'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的包生态系统正在持续发展中，并且每天都有新的包版本发布。大多数时候，这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍在测试版（版本
    0.x）中，任何新版本都可能引入破坏性更改。因此，书中展示的代码可能停止工作。为了确保您的代码将产生与书中描述相同的结果，建议使用相同的包版本。以下是本章使用的外部包及其特定版本：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，您需要运行：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过下载章节提供的 `Project.toml` 文件并使用 `pkg>` 实例化来安装所有使用的包，如下所示：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Working with dates and times
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与日期和时间一起工作
- en: Julia provides a very rich API for handling date and time information. All the
    functionality is packed into the `Dates` module. The module is built in to the
    language so there's no need for additional package installs. In order to access
    its functionality, all we have to do is declare that we'll be `using Dates`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了一个非常丰富的 API 来处理日期和时间信息。所有功能都打包在 `Dates` 模块中。该模块是语言内建的，因此不需要安装额外的包。为了访问其功能，我们只需声明我们将使用
    `Dates`。
- en: The dates module exposes three main types—`Date`, `DateTime`, and `Time`. They
    are all subtypes of the abstract `TimeType` type and represent day, millisecond,
    and nanosecond precision, respectively.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 日期模块公开了三种主要类型——`Date`、`DateTime`和`Time`。它们都是抽象`TimeType`类型的子类型，分别代表天、毫秒和纳秒精度。
- en: 'Julia tries to make working with dates and times as simple as possible. This
    is the reason why, on the one hand, it provides three distinct types, each with
    its own temporal representation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Julia试图使处理日期和时间尽可能简单。这也是为什么，一方面，它提供了三种不同的类型，每种类型都有自己的时间表示：
- en: A `Date` object maps to a date—a time entity defined by a day, a month, and
    a year
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Date`对象映射到一个日期——一个由日、月和年定义的时间实体
- en: An instance of `Time` is a moment in time—the hour, the minute, the second,
    and the milliseconds, but with absolutely no information about the date itself
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time`的一个实例是一个时间点——小时、分钟、秒和毫秒，但没有任何关于日期本身的信息'
- en: The `DateTime`, as you may have guessed from the name, is an object which puts
    together a `Date` and a `Time`, specifying an exact moment in time
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您从名称中猜到的，`DateTime`是一个将`Date`和`Time`组合在一起的对象，指定了一个确切的时间点
- en: On the other hand, all these types have, by default and by design, a naive approach
    to representing dates and times—that is, they do not take into consideration things
    like time zones, daylight savings, or leap seconds. It's a portrayal of your computer's
    local date and time, without any extra information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，所有这些类型默认且按设计采用了一种天真的方式来表示日期和时间——也就是说，它们不考虑诸如时区、夏令时或闰秒等因素。这是一种描绘你计算机本地日期和时间的方式，没有任何额外信息。
- en: Constructing dates and times
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建日期和时间
- en: 'In order to construct new date/time objects representing the current date or
    time, Julia provides two helper functions, `now` and `today`. Let''s look at some
    examples in the **read-eval-print loop** (**REPL**):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建表示当前日期或时间的新的日期/时间对象，Julia提供了两个辅助函数，`now`和`today`。让我们看看**读取-评估-打印循环**（**REPL**）中的几个例子：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `now` function can also accept an additional argument to return the UTC
    time (without local adjustments for daylight savings):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`now`函数还可以接受一个额外的参数来返回UTC时间（不进行夏令时调整）：'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Internally, all the types wrap an `Int64` value that can be accessed through
    the `instant` field:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，所有类型都封装了一个可以通过`instant`字段访问的`Int64`值：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `instant` property of the objects reflects the precision level of each type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的`instant`属性反映了每种类型的精度级别。
- en: 'Of course, we can also instantiate objects that represent any random moment
    in time using the dedicated constructors:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用专门的构造函数实例化表示任何随机时刻的对象：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The constructors work in similar ways for `Date` and `Time`—here are a few
    examples:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`和`Time`的构造函数以类似的方式工作——这里有一些例子：'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The constructors will prevent us from passing the wrong values, resulting in
    an error. This can be different from other languages that automatically perform
    date-time arithmetic where, for instance, December 22, 2018 would be automatically
    converted into January 1, 2019\. That won''t happen in Julia:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将阻止我们传递错误的值，从而导致错误。这与其他语言自动执行日期时间算术的情况不同，例如，2018年12月22日会自动转换为2019年1月1日。这种情况在Julia中不会发生：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are also constructors for the individual date and time components—years,
    months, days, hours, minutes, seconds, and milliseconds. They return instances
    of the corresponding `Period` type (we''ll take a look at periods in detail a
    bit later). Periods can be used to create date/time objects:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有个体日期和时间组件的构造函数——年、月、日、时、分、秒和毫秒。它们返回相应的`Period`类型实例（我们稍后会详细探讨周期）。周期可以用来创建日期/时间对象：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Parsing strings into dates and times
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串解析为日期和时间
- en: 'A common requirement is parsing properly formatted strings coming from an external
    input (databases, files, user input, and so on) into corresponding date and time
    objects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是将来自外部输入（数据库、文件、用户输入等）的格式化字符串正确解析为相应的日期和时间对象：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These are the special date-time characters recognised by Julia, together with
    their significations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Julia识别的特殊日期时间字符及其含义：
- en: '`y`: Year digit, example `yyyy` for `2015`, `yy` for `15`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：年份数字，例如`2015`的`yyyy`，`15`的`yy`'
- en: '`m`: Month digit, example `m => 3` or `03`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：月份数字，例如`m => 3`或`03`'
- en: '`u`: Short month name, example `Jan`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`：短月份名称，例如`Jan`'
- en: '`U`: long month name, example `January`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U`：长月份名称，例如`January`'
- en: '`e`: Short day of week, example `Tue`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`：短星期几，例如`Tue`'
- en: '`E`: Long day of week, example `Tuesday`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E`：长星期几，例如`Tuesday`'
- en: '`d`: Day, example `3` or `03`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：日，例如`3`或`03`'
- en: '`H`: Hour digit, example `HH` = `00`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`：小时数，例如`HH` = `00`'
- en: '`M`: Minute digit, example `MM` = `00`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`：分钟数，例如`MM` = `00`'
- en: '`S`: Second digit, example `s` = `00`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`：秒数，例如`s` = `00`'
- en: '`s`: Millisecond digit, example `.000`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：毫秒数，例如`.000`'
- en: 'With these, we can parse any date/time string into the correct object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些，我们可以将任何日期/时间字符串解析为正确的对象：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also parse multiple strings at once, as elements of an array. First,
    we create an array of strings that represents valid dates, formatted as `yyyy-mm-dd`.
    We use a comprehension to create the array and name it `d`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以一次性解析多个字符串，作为数组的元素。首先，我们创建一个表示有效日期的字符串数组，格式为`yyyy-mm-dd`。我们使用列表推导式创建数组，并将其命名为`d`：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we can use dot notation to process the array element-wise using the `Date`
    constructor:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用点符号来使用`Date`构造函数逐个处理数组元素：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, instead of using a string to represent the format of the date,
    we can use a specialized `DateFormat` type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们不用字符串来表示日期的格式，而可以使用专门的`DateFormat`类型：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using a `DateFormat` is recommended when parsing a large number of strings
    for better performance. Julia provides a few formats as part of the standard library,
    for instance, `ISODateTimeFormat` and `RFC1123Format`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 解析大量字符串时，建议使用`DateFormat`以提高性能。Julia提供了标准库中的一些格式，例如`ISODateTimeFormat`和`RFC1123Format`：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Formatting dates
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期格式化
- en: 'If we can parse date-formatted strings into date/time objects, we can also
    do the reverse. We can output our dates and times as strings using various formats.
    See the following, for instance:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以将日期格式的字符串解析为日期/时间对象，我们也可以做相反的操作。我们可以使用各种格式将日期和时间输出为字符串。例如，看以下内容：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Defining other locales
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义其他区域设置
- en: 'By default, Julia will use the `english` locale, meaning that the names of
    the days and months will be in English. However, we can internationalize our dates
    by defining additional locales:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Julia将使用`english`区域设置，这意味着星期和月份的名称将是英文。然而，我们可以通过定义额外的区域设置来国际化我们的日期：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Dates.DateLocale` function expects four arrays, corresponding to each
    of the month names, abbreviated month names, day names, and abbreviated day names.
    As you can see, we haven''t provided the abbreviated versions of the names. As
    long as we don''t try to use them, we''ll be fine:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dates.DateLocale`函数期望四个数组，分别对应月份名称、缩写月份名称、星期名称和缩写星期名称。正如你所看到的，我们没有提供名称的缩写版本。只要我们不尝试使用它们，我们就会没事：'
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, attempting to use the abbreviated day name will result in an error:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试使用缩写星期名称会导致错误：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Working with date and time accessors
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日期和时间访问器工作
- en: 'If we want to access the individual parts of a date (year, month, day), we
    can retrieve the various components through the available accessor functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想访问日期的各个部分（年、月、日），我们可以通过可用的访问器函数检索各个组件：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The API also exposes compound methods, for brevity:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: API还公开了复合方法，以简化操作：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similar accessors are available for `DateTime`—but no compound methods are
    provided:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DateTime`也有类似的访问器可用——但没有提供复合方法：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternative accessors that return `Period` objects are also defined—they have
    uppercase names:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 也定义了返回`Period`对象的替代访问器——它们具有大写名称：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Querying dates
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询日期
- en: Once we have a date object, we can get a wealth of extra information about it,
    such as the day of the week, leap year, day of the year, and so on. We can use
    the `Dates` API to extract this kind of information about our date/time object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了日期对象，我们就可以获取关于它的丰富额外信息，例如星期几、闰年、年中的天数等等。我们可以使用`Dates` API来提取我们日期/时间对象这类信息。
- en: 'Consider this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这一点：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Are you curious when Yoga day falls in 2019? Let''s use our Julia skills to
    figure that out:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道瑜伽日2019年落在哪一天吗？让我们用我们的Julia技能来找出答案：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you need the numerical value of the day (within the week), there's also `dayofweek(yoga_day)`,
    that obviously returns `5`, since Friday is the fifth day of the week.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一周内某天的数值，也可以使用`dayofweek(yoga_day)`，它显然会返回`5`，因为星期五是每周的第五天。
- en: 'Of course, we can use localized names here too:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以在这里使用本地化名称：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Another useful function we can call is `dayofweekofmonth(yoga_day)`, which will
    tell us which Friday of the month it is—it's the third Friday of the month of
    June, in 2019.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以调用的有用函数是`dayofweekofmonth(yoga_day)`，它会告诉我们这是哪个月的星期五——2019年6月的第三个星期五。
- en: If you're not sure how this can be useful, take for example, events that always
    take place with regularity on a certain day of the month. A good example is a
    meetup I attend that always takes place on the third Thursday of each month.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定这有什么用，可以举例说明，比如总在每月某一天定期举行的活动。一个很好的例子是我参加的一个每月第三个星期四举行的活动。
- en: 'We can also get a wealth of information about the month and the year:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获取关于月份和年份的大量信息：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Dates` API is very rich, including a lot more methods than it would make
    sense to present here. Please visit the documentation page at [https://docs.julialang.org/en/v1/stdlib/Dates/index.html#stdlib-dates-api-1](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#stdlib-dates-api-1).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dates` API 非常丰富，包括比这里展示的更多方法。请访问文档页面 [https://docs.julialang.org/en/v1/stdlib/Dates/index.html#stdlib-dates-api-1](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#stdlib-dates-api-1)。'
- en: Defining the date ranges
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义日期范围
- en: 'Julia allows us to define ranges of dates to express continuous periods of
    time. For example, we could represent the whole year as the range of days between
    January 1 and December 31:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 允许我们定义日期范围来表示连续的时间段。例如，我们可以将整个年份表示为 1 月 1 日和 12 月 31 日之间的天数范围：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have created a date range with a step of one day—so `365` items, since 2019
    is not a leap year:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个以一天为步长的日期范围——因此有 `365` 个项目，因为 2019 年不是闰年：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can instantiate the actual `Date` objects using the aptly named `collect`
    function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用名为 `collect` 的函数实例化实际的 `Date` 对象：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Also, of course, we can access the elements by index as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以通过索引访问元素，如下所示：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It''s also possible to define ranges with other steps, such as monthly intervals:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以定义具有其他步长的范围，例如月度间隔：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can pass any `Period` object for the step, for instance:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何 `Period` 对象传递给步长，例如：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Period types and period arithmetic
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时期类型和时期算术
- en: 'We have already seen some of the `Period` constructors. These are all the available
    ones—`Day`, `Week`, `Month`, `Year`, `Hour`, `Minute`, `Second`, `Millisecond`,
    `Microsecond`, and `Nanosecond`. The `Period` type is an abstract type with two
    concrete subtypes, `DatePeriod` and `TimePeriod`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些 `Period` 构造函数。这些都是可用的——`Day`、`Week`、`Month`、`Year`、`Hour`、`Minute`、`Second`、`Millisecond`、`Microsecond`
    和 `Nanosecond`。`Period` 类型是一个抽象类型，有两个具体的子类型，`DatePeriod` 和 `TimePeriod`：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Period` in Julia represents a duration of time. It is a very useful abstraction
    representing vague time concepts that people use routinely. Think about a month—how
    many days does a month have—30 or 31? What about 28? Or 29?'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，`Period` 代表时间的持续时间。这是一个非常有用的抽象概念，代表了人们经常使用的模糊时间概念。想想看，一个月有多少天——30
    或 31 天？28 天呢？还是 29 天？
- en: Many times, it can be useful to work with vague abstractions without switching
    to actual dates until more information is provided. Take, for instance, the hypothetical
    case of a trip to Mars. According to [https://image.gsfc.nasa.gov/poetry/venus/q2811.html](https://image.gsfc.nasa.gov/poetry/venus/q2811.html)[,
    a return trip to Mars will take `21 months`—`9` to get there, `3` to stay there,
    and `9` more to get back:](https://image.gsfc.nasa.gov/poetry/venus/q2811.html)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，在没有提供更多信息之前，与模糊的抽象概念一起工作可能很有用。以火星旅行的假设情况为例。根据 [https://image.gsfc.nasa.gov/poetry/venus/q2811.html](https://image.gsfc.nasa.gov/poetry/venus/q2811.html)[，往返火星将需要
    `21 个月`——`9` 个月到达，`3` 个月停留，以及 `9` 个月返回：](https://image.gsfc.nasa.gov/poetry/venus/q2811.html)
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Exactly how long these 21 months will take is undetermined until we actually
    decide when we start the trip:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这 21 个月究竟需要多长时间，直到我们实际决定何时开始旅行之前是无法确定的：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we can compute how long the astronauts will be gone for:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算宇航员将离开多久：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'However, if, for technical reasons, the launch date will be postponed by five
    months, the result will be different:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果由于技术原因，发射日期将推迟五个月，结果将不同：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is important to keep in mind that unlike other programming languages, which
    make assumptions about the default length of a month—such as 31 days in JavaScript
    or 30 days in PHP—Julia takes a different approach. For a detailed explanation
    of `Period` arithmetic, you can read the official documentation at [https://docs.julialang.org/en/v1/stdlib/Dates/index.html#TimeType-Period-Arithmetic-1.](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#TimeType-Period-Arithmetic-1)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，与其他编程语言不同，它们对月份的默认长度做出假设——例如 JavaScript 中的 31 天或 PHP 中的 30 天——Julia
    采用不同的方法。有关 `Period` 算术的详细解释，请阅读官方文档 [https://docs.julialang.org/en/v1/stdlib/Dates/index.html#TimeType-Period-Arithmetic-1.](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#TimeType-Period-Arithmetic-1)
- en: 'A period doesn''t necessarily need to be a complete amount of time. Julia allows
    us to express irregular intervals like `1` month and `2` weeks. However, an irregular
    amount of time (which combines different types of periods) will be internally
    represented by a different type—not the `Period`, but the `CompoundPeriod`. Here''s
    how this works:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 时期不一定是完整的时间量。Julia 允许我们表达不规则的间隔，例如 `1` 个月和 `2` 个星期。然而，不规则的时间量（结合了不同类型的时期）将内部表示为不同的类型——不是
    `Period`，而是 `CompoundPeriod`。以下是它是如何工作的：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Date adjustments
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期调整
- en: '`Period` arithmetic is very powerful, but sometimes we need to express more
    flexible rules that are dependent on other dates. I''m thinking about *last day
    of the next month*, *next Tuesday*, or *the third Monday of each month*.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period` 运算非常强大，但有时我们需要表达更灵活的规则，这些规则依赖于其他日期。我想到了下个月的最后一天、下一个星期二，或者每个月的第三个星期一。'
- en: 'For such cases, the `Dates` module exposes the adjuster API. For starters,
    we have the `firstdayof*` and the `lastdayof*` family of functions—`firstdayofweek`,
    `firstdayofmonth`, `firstdayofquarter`, and `firstdayofyear`; plus `lastdayofweek`,
    `lastdayofmonth`, `lastdayofquarter`, and `lastdayofyear`, respectively. They
    take as input a date/time object and *adjust* it to the indicated point in time:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类情况，`Dates` 模块公开了调整器 API。首先，我们有 `firstdayof*` 和 `lastdayof*` 函数系列——`firstdayofweek`、`firstdayofmonth`、`firstdayofquarter`
    和 `firstdayofyear`；以及 `lastdayofweek`、`lastdayofmonth`、`lastdayofquarter` 和 `lastdayofyear`，分别。它们接受一个日期/时间对象作为输入，并将其
    *调整* 到指定的时间点：
- en: '[PRE42]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In 2019, the first day of the week includes January 31 is Monday, 28.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2019 年，如果一周的第一天包括 1 月 31 日，那么星期一是 28 日。
- en: 'The `lastdayof*` family of functions works in a similar manner. But useful
    as they are, they don''t provide enough flexibility. Luckily, we''re covered.
    If we need other dates apart from the first or the last day, we have to reach
    for the `tonext` and `toprev` pair of functions. They come in two flavors. The
    first method takes a subtype of `TimeType` (that is, any `Time`, `Date`, `DateTime`)
    and a day of the week:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastdayof*` 函数系列的工作方式类似。但尽管它们很有用，但提供的灵活性还不够。幸运的是，我们有解决方案。如果我们需要除了第一天或最后一天之外的其他日期，我们必须求助于
    `tonext` 和 `toprev` 函数对。它们有两种风味。第一种方法接受 `TimeType` 的子类型（即任何 `Time`、`Date`、`DateTime`）和一周中的某一天：'
- en: '[PRE43]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The next Saturday after April Fool's Day falls on April 7 2019.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 而下一个愚人节之后的周六落在 2019 年 4 月 7 日。
- en: 'The other method of `tonext` is even more powerful—it accepts a similar `TimeType`
    and a function. It will adjust the date until the function returns `true`. To
    understand how useful this is, let''s get back to our previous meetup example,
    the meeting I attend every third Thursday of each month. To find out when the
    next meeting will take place, all I have to do is ask Julia:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`tonext` 的另一种方法甚至更强大——它接受一个类似的 `TimeType` 和一个函数。它将调整日期，直到函数返回 `true`。为了了解这有多有用，让我们回到我们之前的会议示例，我每月第三个星期四参加的会议。为了找出下一次会议将在何时举行，我只需要问
    Julia：'
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `toprev` function works in a similar way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`toprev` 函数的工作方式与此类似。'
- en: 'Another function, `filter`, allows us to obtain all the matching dates as an
    `Iterator`. Following up on our meetups schedule, let''s try to find out the dates
    of all the meetings in 2019\. But we must also take into account that in the second
    half of May, the organizer will attend a business trip, and that August is a holiday
    month. So, there won''t be meetings during these intervals. How would we express
    this? It turns out that with Julia, it''s quite simple (and very readable):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数 `filter` 允许我们以 `Iterator` 的形式获取所有匹配的日期。继续我们的会议日程，让我们尝试找出 2019 年所有会议的日期。但我们必须考虑到五月中旬，组织者将参加商务旅行，以及八月是假期月份。因此，在这些时间段内不会有会议。我们该如何表达这一点？结果是，使用
    Julia，这相当简单（且易于阅读）：
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Rounding of dates
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期的四舍五入
- en: 'There might be situations where we have a date/time and a need to compute the
    previous, or next complete time interval, for example, the next hour, or the previous
    day. The `Dates` API exposes a few methods for rounding `Date` and `DateTime`
    objects—`floor`, `ceil`, and `time`. They are quite intuitive and very powerful:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，我们有一个日期/时间，需要计算上一个或下一个完整的时间间隔，例如下一个小时或上一个日子。`Dates` API 提供了一些用于四舍五入
    `Date` 和 `DateTime` 对象的方法——`floor`、`ceil` 和 `time`。它们非常直观且功能强大：
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `ceil` function works similarly, but instead of rounding down, it rounds
    up. As for the `round` function, it will round up or down, depending on whichever
    is the closest value:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ceil` 函数的工作方式类似，但不是向下取整，而是向上取整。至于 `round` 函数，它将向上或向下取整，取决于哪个值更接近：'
- en: '[PRE47]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Rounding can behave unexpectedly in a few edge cases—for more details please
    check the official documentation at [https://docs.julialang.org/en/v1/stdlib/Dates/index.html#Rounding-1](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#Rounding-1).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些边缘情况下，舍入可能会表现得不可预期——更多细节请查看官方文档[https://docs.julialang.org/en/v1/stdlib/Dates/index.html#Rounding-1](https://docs.julialang.org/en/v1/stdlib/Dates/index.html#Rounding-1)。
- en: Adding support for time zones
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对时区的支持
- en: 'As previously mentioned, by default, Julia''s date/time objects operate in
    local time, completely ignoring time zones. However, we can easily extend them
    to become time-zone aware using the `TimeZones` package. Please install it in
    the usual way:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，默认情况下，Julia的日期/时间对象以本地时间操作，完全忽略时区。然而，我们可以很容易地使用`TimeZones`包将它们扩展为时区感知。请按照常规方式安装它：
- en: '[PRE48]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once we inform the compiler that we'll be using `TimeZones`, a wealth of timezone-related
    functionalities become available at our fingertips.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通知编译器我们将使用`TimeZones`，大量的时区相关功能将变得触手可及。
- en: 'We can start by exploring the available time zones:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从探索可用的时区开始：
- en: '[PRE49]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s create a time zone object for `Amsterdam`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`Amsterdam`创建一个时区对象：
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In Julia, a `TimeZone` is an abstract type that represents information regarding
    a specific time zone, which means that it can't be instantiated—we can't create
    objects of this type. Instead, one of its two subtypes will be automatically used—`VariableTimeZone`
    or `FixedTimeZone`. `VariableTimeZone` represents a time zone whose offset changes
    depending on the time of the year—to take into account summertime/daylight savings
    time. `FixedTimeZone` has an invariable offset.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，`TimeZone`是一个抽象类型，它代表有关特定时区的信息，这意味着它不能被实例化——我们不能创建这种类型的对象。相反，它的两个子类型之一将被自动使用——`VariableTimeZone`或`FixedTimeZone`。`VariableTimeZone`代表一个时区，其偏移量根据年份的时间而变化——为了考虑夏令时/夏令时。`FixedTimeZone`有一个不变的偏移量。
- en: 'The `Europe/Amsterdam (UTC+1/UTC+2)` is such a `VariableTimeZone`. This is
    indicated by the information within the round brackets, signaling the two offsets
    of this time zone. Checking the type will confirm it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Europe/Amsterdam (UTC+1/UTC+2)`是一个这样的`VariableTimeZone`。这由圆括号内的信息表示，表明这个时区的两个偏移量。检查类型将确认这一点：'
- en: '[PRE51]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The time zones that don''t change their offsets are instances of `FixedTimeZone`.
    Such examples are `UTC` and `GMT`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不改变其偏移量的时区是`FixedTimeZone`的实例。这样的例子有`UTC`和`GMT`：
- en: '[PRE52]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `TimeZones` package also provides a special string literal, `tz"..."`.
    It exposes the same functionality as `TimeZone(...)` with a bit less typing:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeZones`包还提供了一个特殊的字符串字面量，`tz"..."`。它提供了与`TimeZone(...)`相同的功能，但输入更少：'
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Armed with this knowledge, we can now create time zone-aware date/time values.
    These come in the form of `ZonedDateTime` objects, and, as the name suggests,
    represent a mixture of `DateTime` and `TimeZone`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这个知识，我们现在可以创建对时区有感知的日期/时间值。这些值以`ZonedDateTime`对象的形式出现，正如其名所示，代表`DateTime`和`TimeZone`的混合：
- en: '[PRE54]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This can be written a bit more succinctly by skipping the explicit invocation
    of `DateTime`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过省略对`DateTime`的显式调用而写得更加简洁：
- en: '[PRE55]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `TimeZones` module also provides a series of utility methods. First of
    all, we can retrieve the local time zone by using the aptly named `localzone`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeZones`模块还提供了一系列实用方法。首先，我们可以使用名为`localzone`的函数检索本地时区：'
- en: '[PRE56]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: I live in Barcelona, so this is my current time zone—your output will correspond
    to your actual time zone.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我住在巴塞罗那，所以这是我当前所在的时区——你的输出将对应于你的实际时区。
- en: 'Two extension methods are provided for `now` and `today`—in the form of `now(::TimeZone)`
    and `today(::TimeZone)`, respectively:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为`now`和`today`提供了两个扩展方法——分别是`now(::TimeZone)`和`today(::TimeZone)`。
- en: '[PRE57]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Instead of `today(::TimeZone)`, another function, `todayat`, can be used with
    two arguments—the time of the day as a `Time` object and a `TimeZone`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`today(::TimeZone)`，可以使用另一个函数`todayat`，它接受两个参数——一天中的时间作为一个`Time`对象和一个`TimeZone`：
- en: '[PRE58]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This time we get 10:30 P.M., `Moscow` time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们得到了晚上10:30的莫斯科时间。
- en: Converting time zones
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换时区
- en: 'One of the most basic things we''ll want to do is to convert a `DateTime` from
    one time zone to another. That''s straightforward with the `astimezone` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最基本想要做的事情之一是将一个`DateTime`从一个时区转换到另一个时区。这可以通过`astimezone`函数直接完成：
- en: '[PRE59]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: While you're celebrating Christmas in Vienna at 8 P.M., in Sydney, Australia,
    it will already be 6 A.M. the next day.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在维也纳庆祝平安夜，晚上8点时，在澳大利亚的悉尼，已经是第二天早上6点了。
- en: Parsing date strings
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析日期字符串
- en: 'We have already seen how to parse date and date/time strings using Julia''s
    `Dates` API. The `TimeZones` package takes this functionality one step further,
    allowing us to parse date/time strings that include time zones:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用Julia的`Dates` API解析日期和日期/时间字符串。`TimeZones`包将这一功能推进了一步，允许我们解析包含时区的日期/时间字符串：
- en: '[PRE60]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ZonedDateTime period arithmetic
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZonedDateTime时间段算术
- en: You will be happy to hear that arithmetic with time zone-aware objects works
    just like its regular `TimeType` counterpart. However, you have to take extra
    care when dealing with periods of time that start in an offset (as in wintertime)
    and finish in another offset (say, summertime). For instance, let's see what happens
    when we play with times around the moment when Europe switches to daylight savings
    time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你会很高兴听到，时区感知对象的算术运算与常规的`TimeType`对应物的工作方式完全一样。然而，在处理开始于一个偏移量（例如冬季）并结束于另一个偏移量（比如说夏季）的时间段时，你必须格外小心。例如，让我们看看当我们玩弄欧洲切换到夏令时的时间点周围的时刻会发生什么。
- en: The clock changes during the last Sunday of March. Take a minute and try to
    find out the date of the last Sunday of March in 2019.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 三月的最后一个星期日会进行时钟调整。花一分钟时间，试着找出2019年三月最后一个星期日的日期。
- en: 'Here''s my solution:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的解决方案：
- en: '[PRE61]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s give it a time zone—let''s say, London''s:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给它一个时区——比如说伦敦的：
- en: '[PRE62]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Adding a day to this will cause the time zone to change:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 向这个日期加一天将导致时区发生变化：
- en: '[PRE63]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'But what if we now remove the equivalent of one day, but in hours? We should
    get the value of `london_time` again, right? Take a look:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们现在移除相当于一天的时间，但以小时计算呢？我们应该再次得到`london_time`的值，对吧？看看：
- en: '[PRE64]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Oops, not quite! Subtracting `24` hours actually pushed us one hour earlier
    than `london_time`. The reason for this is that the change of offset (switching
    to summertime) effectively caused a whole hour at 2 A.M. to be skipped on the
    25th, making that day only 23 hours long.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，不是这样的！减去`24`小时实际上使我们比`london_time`提前了一个小时。这是因为偏移量的变化（切换到夏令时）实际上导致25日凌晨2点的整整一个小时被跳过，使得那天只有23个小时长。
- en: Time zone-aware date ranges
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时区感知日期范围
- en: 'Another important thing to keep in mind when dealing with time zones involves
    date ranges. If the start item of your range is in a time zone, but the end item
    is in a different time zone, the resulting value corresponding to the end item
    will be silently converted to the time zone of the start item. An example will
    make this clear:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理时区时，还有另一件重要的事情需要记住，那就是日期范围。如果你的范围开始项在一个时区，但结束项在另一个时区，则对应于结束项的结果值将默默地转换为开始项的时区。一个例子将使这一点变得清晰：
- en: '[PRE65]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last item in the array, `2018-08-01T15:00:00+01:00`, represents the same
    time as the end item in the interval, `2018-08-02T00:00:00+10:00`—but it''s using
    the London time zone, not Sydney''s:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的最后一个项目，`2018-08-01T15:00:00+01:00`，代表与区间结束项相同的时刻，`2018-08-02T00:00:00+10:00`——但它使用的是伦敦时区，而不是悉尼的：
- en: '[PRE66]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It's the same time, but a different time zone.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 时间相同，但时区不同。
- en: Time series data in Julia
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia中的时间序列数据
- en: A time series is a collection of observations of well-defined data items obtained
    via repeated measurements over time. This collection of quantitative observations
    is ordered, allowing us to understand the underlying structure. Examples of such
    data include the daily closing price of a company's stock, quarterly sales figures
    for a retailer, continuous monitoring of a person's blood glucose levels, or hourly
    air temperatures.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是一组通过重复测量在一段时间内获得的对定义良好的数据项的观察。这个定量观察的集合是有序的，使我们能够理解其底层结构。此类数据的例子包括公司股票的每日收盘价、零售商的季度销售额、对个人血糖水平的连续监测，或每小时空气温度。
- en: 'Julia''s package ecosystem provides a powerful functionality for working with
    time series through the `TimeSeries` package. The package provides an extensive
    API that covers the full range of tasks, from reading and writing CSV files with
    temporal data, to filtering and segmenting time series, to mathematical and logical
    operators, and plotting. Let''s add it to our toolbox:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的包生态系统通过`TimeSeries`包提供了强大的时间序列处理功能。该包提供了一个广泛的API，涵盖了从读取和写入具有时间数据的CSV文件，到过滤和分割时间序列，再到数学和逻辑运算符，以及绘图的全套任务。让我们将其添加到我们的工具箱中：
- en: '[PRE67]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s get some time series data. The easiest thing we can do is to reach
    for the `MarketData` package, it provides open source financial data for research
    and testing and works flawlessly with `TimeSeries`. Once you install it in the
    usual way (`pkg> add MarketData`), the module will expose a series of variables
    corresponding to different datasets. Some of them are small test databases, called
    `cl`, `ohcl`, `ohlcv`, and so on. For example, the `ohcl` dataset contains 500
    rows of market data, from January 3, 2000 to December 31, 2001—each row contains
    a `Date`, plus the `Open`, `High`, `Low`, and `Close` values. Here''s what it
    looks like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取一些时间序列数据。我们能够做的最简单的事情就是使用`MarketData`包，它为研究和测试提供开源的金融数据，并且与`TimeSeries`完美兼容。一旦您以常规方式（`pkg>
    add MarketData`）安装它，该模块将暴露一系列变量，对应不同的数据集。其中一些是小型测试数据库，称为`cl`、`ohcl`、`ohlcv`等。例如，`ohcl`数据集包含从2000年1月3日到2001年12月31日的500行市场数据——每一行包含一个`Date`，以及`Open`、`High`、`Low`和`Close`值。以下是它的样子：
- en: '[PRE68]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can see that it''s of the type `TimeArray` and it spans the time interval
    I just mentioned:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它属于`TimeArray`类型，并且跨越了我刚才提到的时段：
- en: '![](img/eb05f02d-8eab-4dfd-aa5f-0736a22adb87.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb05f02d-8eab-4dfd-aa5f-0736a22adb87.png)'
- en: The `MarketData` module also exposes larger historical prices and volume data
    for three major companies—Apple (`AAPL`), Boeing (`BA`), and Caterpillar (`CAT`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketData`模块还公开了三家主要公司的更大历史价格和成交量数据——苹果（`AAPL`）、波音（`BA`）和卡特彼勒（`CAT`）。'
- en: A quick look at our data with Plots and PyPlot
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Plots和PyPlot快速查看我们的数据
- en: As the old saying goes, A* picture is worth a thousand words*, so let's get
    a quick feel for our data by plotting it. It's a great opportunity to introduce
    one of the best Julia data visualization packages—`Plots`. Unlike `Gadfly`, which
    we've previously used, `Plots` takes a different approach—it's an interface over
    many different plotting libraries. Basically, it's like middleware, providing
    a common, unifying API for other plotting packages (called **backends**). In Julia,
    different plotting packages have different features and strengths—and depending
    on the user's specific needs, they may be forced to learn yet another library,
    change the code, and so on, in order to interchangeably use different plotting
    packages. `Plots` addresses this problem through a unifying API coupled with a
    simple mechanism that allows for swapping backends on the fly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如古老的谚语所说，“一图胜千言”，让我们通过绘图来快速了解我们的数据。这是一个介绍最好的Julia数据可视化包——`Plots`的好机会。与之前我们使用的`Gadfly`不同，`Plots`采用不同的方法——它是一个覆盖多个不同绘图库的接口。基本上，它就像中间件，为其他绘图包（称为**后端**）提供了一个通用、统一的API。在Julia中，不同的绘图包有不同的功能和优势——根据用户的特定需求，他们可能被迫学习另一个库，更改代码，等等，以便可以互换使用不同的绘图包。`Plots`通过一个统一的API和一种简单的机制来解决此问题，该机制允许动态交换后端。
- en: The `Plots` package supports the following backends—`PyPlot`, `Plotly` or `PlotlyJS`,
    `GR`, `UnicodePlots`, `PGFPlots`, `InspectDR`, and `HDFS5`. Which one should you
    use? It depends on the actual use case, but as a general rule, in the words of
    `Plots` author—*GR for speed, Plotly(JS) for interactivity, PyPlot otherwise*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plots`包支持以下后端——`PyPlot`、`Plotly`或`PlotlyJS`、`GR`、`UnicodePlots`、`PGFPlots`、`InspectDR`和`HDFS5`。您应该使用哪一个？这取决于实际用例，但根据`Plots`作者的表述——*GR用于速度，Plotly(JS)用于交互性，否则使用PyPlot*。'
- en: Please read the official documentation at [http://docs.juliaplots.org/latest/backends/](http://docs.juliaplots.org/latest/backends/)
    to understand the pros and cons of each backend.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读官方文档[http://docs.juliaplots.org/latest/backends/](http://docs.juliaplots.org/latest/backends/)，以了解每个后端的优势和劣势。
- en: We'll use `PyPlot`, a Julia wrapper for the popular Python package with the
    same name. Let's install both `Plots` and `PyPlot`. Running `pkg> add Plots` should
    be straightforward. Next, `pkg> add PyPlot` will be more involved. As `PyPlot`
    uses `PyCall.jl` to invoke Python code, depending on your current Julia installation,
    `Pkg` might also have to install the `miniconda` Python distribution. So it might
    take a few minutes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`PyPlot`，这是对同名流行Python包的Julia包装器。让我们安装`Plots`和`PyPlot`。运行`pkg> add Plots`应该是直接的。接下来，`pkg>
    add PyPlot`将更加复杂。由于`PyPlot`使用`PyCall.jl`来调用Python代码，根据您当前的Julia安装，`Pkg`可能还需要安装`miniconda`
    Python发行版。因此，可能需要几分钟。
- en: 'To start using `Plots` with `PyPlot`, please make sure you run the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`Plots`与`PyPlot`，请确保您运行以下命令：
- en: '[PRE69]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `pyplot` function configures the `PyPlot` backend to be used by `Plots`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyplot`函数配置`PyPlot`后端，以便`Plots`使用。'
- en: Right after installing `PyPlot`, when attempting to run `pyplot()`, you might
    get an error. Please follow the instructions provided by the package and restart
    the Julia REPL if so advised.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装`PyPlot`后，尝试运行`pyplot()`时，你可能会遇到错误。如果建议这样做，请遵循包提供的说明并重新启动Julia REPL。
- en: 'We''re now ready to go! The module exposes the `plot` function, which at its
    simplest can be invoked with two collections of values, corresponding to the x
    and y coordinates:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始了！该模块公开了`plot`函数，在最简单的情况下，可以通过两个值集合来调用，对应于x和y坐标：
- en: '[PRE70]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You should see a plot being rendered in a new window—mine looks like this,
    but since we''re visualising random values, yours will be different:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个新窗口中渲染的图表——我的看起来像这样，但由于我们正在可视化随机值，你的可能会有所不同：
- en: '![](img/24e3b1b9-6fa8-40b5-9482-315774c49d10.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24e3b1b9-6fa8-40b5-9482-315774c49d10.png)'
- en: It's a plot of ten random values, rendered by `PyPlot`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由`PyPlot`渲染的十个随机值的图表。
- en: 'One cool thing about these plots is that they can be mutated using the `plot!`
    function. For instance, we can add two lines to it by plotting a matrix:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表的一个有趣之处在于，它们可以使用`plot!`函数进行修改。例如，我们可以通过绘制一个矩阵来向其中添加两条线：
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The resulting output is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '![](img/3e2175ee-847b-4e60-992e-c05ada127727.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e2175ee-847b-4e60-992e-c05ada127727.png)'
- en: 'Plots can be enhanced using attributes. They allow us to add labels, titles,
    and to style the visualizations and so on. For instance, here''s how we''d render
    our previous plot with extra attributes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用属性来增强图表。它们允许我们添加标签、标题，以及样式化可视化等等。例如，以下是使用额外属性渲染我们之前的图表的方法：
- en: '[PRE72]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/5689f91d-543f-4d47-ab6f-029a6eae6867.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5689f91d-543f-4d47-ab6f-029a6eae6867.png)'
- en: 'The API also exposes functions for modifying the plot after it has been rendered:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: API还公开了在渲染后修改图表的函数：
- en: '[PRE73]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/396804be-9e5f-457b-992e-caaceafbb178.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/396804be-9e5f-457b-992e-caaceafbb178.png)'
- en: 'Going back to our market data, you''ll be happy to hear that `TimeSeries` provides
    out-of-the-box integration with `Plots`. All we have to do is run the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的市场数据，你可能会很高兴地听到`TimeSeries`提供了与`Plots`的即插即用集成。我们只需要运行以下命令：
- en: '[PRE74]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This is what we get:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们得到的结果：
- en: '![](img/773c1573-a29b-47c6-8e9b-4357d1258405.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/773c1573-a29b-47c6-8e9b-4357d1258405.png)'
- en: 'We can see that the market had been growing, reaching a peak in March 2000,
    then dropping suddenly to around 50–60\. It stayed there for a few months, and
    then it dropped again at the end of September and stayed under 30 all the way
    through to the end of 2001\. The four values, `Open`, `Close`, `High`, and `Low`
    seem to be highly correlated. We can plot them individually:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到市场一直在增长，在2000年3月达到顶峰，然后突然下降到大约50-60。它在那里停留了几个月，然后在9月底再次下降，一直保持在30以下，直到2001年底。四个值，`Open`（开盘价）、`Close`（收盘价）、`High`（最高价）和`Low`（最低价）似乎高度相关。我们可以单独绘制它们：
- en: '[PRE75]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We get the following result:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![](img/f9fd4d5e-cf7f-49ae-8805-8a86d4ee1388.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9fd4d5e-cf7f-49ae-8805-8a86d4ee1388.png)'
- en: 'We can append extra values like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样添加额外的值：
- en: '[PRE76]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/29a912d7-2bf6-4fab-b2b5-18350a9f8a5a.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29a912d7-2bf6-4fab-b2b5-18350a9f8a5a.png)'
- en: Visualizing the high versus low values, we can see higher variations in the
    periods before the market crash.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可视化高值与低值，我们可以看到在市场崩溃前的时期有更高的变化。
- en: The TimeArray type
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`TimeArray`类型'
- en: 'So what''s with this `TimeArray` then, you may be wondering? It does look like
    an interesting beast, in that we can index into it using square brackets and the
    names of columns. We can use the `fieldnames` function to see what properties
    it exposes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个`TimeArray`到底是什么呢？你可能想知道？它看起来像是一个有趣的生物，因为我们可以用方括号和列名来索引它。我们可以使用`fieldnames`函数来查看它暴露了哪些属性：
- en: '[PRE77]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Indeed, a `TimeArray` is a composite type—a `struct`, in Julia parlance—with
    four fields.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一个`TimeArray`是一个复合类型——在Julia中我们称之为`struct`，它有四个字段。
- en: 'The `timestamp` field represents a vector of time values—the ones that hold
    the temporal coordinates of our time series. So if we look at our `TimeArray`
    object, we''ll see this in the first row:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestamp`字段代表一个时间值向量——它们持有时间序列的时间坐标。因此，如果我们查看我们的`TimeArray`对象，我们会在第一行看到这个：'
- en: '[PRE78]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'It looks like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '![](img/bb9db558-b55e-4d3c-954e-9343e9c66ade.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb9db558-b55e-4d3c-954e-9343e9c66ade.png)'
- en: 'In this output, `2000-01-03` is the first value in the `timestamp` array. We
    can access the array using the `timestamp` getter:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，`2000-01-03`是`timestamp`数组中的第一个值。我们可以使用`timestamp`获取器来访问数组：
- en: '[PRE79]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Depending on the actual information in the dataset, its type can be `Date` (as
    in our case), `Time`, or `DateTime`—any subtype of `TimeType`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据集中的实际信息，其类型可以是 `Date`（如我们的情况），`Time` 或 `DateTime`——`TimeType` 的任何子类型。
- en: When constructing a `TimeArray`, you must be careful because the `timestamp`
    data has to be sorted—otherwise, the constructor will error out.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 `TimeArray` 时，你必须小心，因为 `timestamp` 数据必须排序——否则，构造函数将出错。
- en: 'By analogy, with the `timestamp` field, you can probably guess what the `values`
    property is all about. It holds the numerical data of the time series:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，与 `timestamp` 字段一样，你可能可以猜到 `values` 属性的内容。它包含时间序列的数值数据：
- en: '[PRE80]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c8b84b6a-445e-4ffd-a2c5-ae055a8b7e07.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8b84b6a-445e-4ffd-a2c5-ae055a8b7e07.png)'
- en: Obviously, the row count of the `values` array must match the length of the
    `timestamp` collection. Less obviously, all the values inside the `values` array
    must be of the same type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`values` 数组的行数必须与 `timestamp` 集合的长度相匹配。不那么明显的是，`values` 数组内部的所有值必须属于同一类型。
- en: 'Thus, each row in a `TimeArray` is composed of an item from the `timestamp`
    collection and the corresponding row from the `values` array:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`TimeArray` 中的每一行都由 `timestamp` 集合中的一个项目以及 `values` 数组中的对应行组成：
- en: '![](img/6814dcbf-990b-40f3-8638-045d726da3fd.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6814dcbf-990b-40f3-8638-045d726da3fd.png)'
- en: 'The `colnames` function returns the array of column names for each column in
    the values field. They are returned as symbols:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`colnames` 函数返回值字段中每个列的列名数组。它们作为符号返回：'
- en: '[PRE81]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The only hard constraint here is that the number of items in the `colnames`
    vector must match the number of columns in the `values` collection. Due to the
    fact that `TimeArrays` are indexable by column name, duplicate strings in the
    `colnames` vector will be modified automatically by the constructor. Each subsequent
    duplicate name will be appended with *n,* where *n* starts from `1`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一硬性约束是 `colnames` 向量中的项目数必须与 `values` 集合中的列数相匹配。由于 `TimeArrays` 可以通过列名索引，`colnames`
    向量中的重复字符串将由构造函数自动修改。每个后续的重复名称将附加一个 *n*，其中 *n* 从 `1` 开始。
- en: 'If you are not happy with the columns names, they can be changed using the
    `rename` method, passing in the `TimeArray` object and an array of column names
    as symbols:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对列名不满意，可以使用 `rename` 方法进行更改，传入 `TimeArray` 对象和列名符号数组：
- en: '[PRE82]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Finally, the `meta` field is supposed to be used for attaching meta-information
    to the object. By default, it is empty and can be set by the programmer, as needed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`meta` 字段应该用于将元信息附加到对象上。默认情况下，它是空的，可以根据需要由程序员设置。
- en: Indexing the TimeArray objects
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引 `TimeArray` 对象
- en: 'The `TimeSeries` library exposes a powerful API for accessing information structured
    as `TimeArray` data. We have already seen that we can access individual columns
    by indexing by column name:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSeries` 库公开了一个强大的 API，用于访问结构化为 `TimeArray` 数据的信息。我们已经看到，我们可以通过按列名索引来访问单个列：'
- en: '[PRE83]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'It results in this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这就得到了以下结果：
- en: '![](img/586df468-4d42-44f5-9328-7d3101990d98.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/586df468-4d42-44f5-9328-7d3101990d98.png)'
- en: 'We can even use a combination of columns:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用列的组合：
- en: '[PRE84]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/52baa074-d17e-424a-b380-3906fbfbbcb6.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52baa074-d17e-424a-b380-3906fbfbbcb6.png)'
- en: 'We can also index into the array using row IDs and dates/times (corresponding
    to the `timestamp` values). Let''s try to pick up the row with the highest `Close`
    value. First, let''s find it:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用行 ID 和日期/时间（对应于 `timestamp` 值）来索引数组。让我们尝试获取 `Close` 值最高的行。首先，让我们找到它：
- en: '[PRE85]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The highest closing value was `144.19`. Please note that indexing by column
    name returns another instance of `TimeArray`, so to get its underlying numerical
    values, we need to use the `values` function.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最高收盘价为 `144.19`。请注意，按列名索引返回另一个 `TimeArray` 实例，因此要获取其底层数值，我们需要使用 `values` 函数。
- en: 'Now we can find its corresponding index. We can quickly get an array of the
    indices of all the values that are equal to `144.19` by using `findall`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以找到其对应的索引。我们可以通过使用 `findall` 快速获取所有等于 `144.19` 的值的索引数组：
- en: '[PRE86]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'That would be row `56`. We can use this information to index into the time
    series:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 那将是第 `56` 行。我们可以使用这些信息来索引时间序列：
- en: '[PRE87]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/42806baa-f24a-4cfb-a27e-efbab4071af9.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42806baa-f24a-4cfb-a27e-efbab4071af9.png)'
- en: 'This is March 22, 2000. If we''d like to see the rows before and after, we
    can do it easily:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 2000 年 3 月 22 日。如果我们想查看其前后行，可以轻松做到：
- en: '[PRE88]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is the resulting `TimeArray`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的 `TimeArray`：
- en: '![](img/0f0b8825-445a-4517-845e-e95f831e19f8.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f0b8825-445a-4517-845e-e95f831e19f8.png)'
- en: 'If we want to check the values for the same day of the week, before and after
    our date, indexing by range supports a step parameter. We can use it as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要检查我们日期前后同一星期的值，使用范围索引支持步长参数。我们可以如下使用它：
- en: '[PRE89]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We filter every seventh day, starting with the seventh row, all the way to
    the seventieth row; that is, every `Wednesday`, as indicated by `Dates.dayname`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过滤每隔第七天，从第七行开始，一直到第七十行；也就是说，每个`星期三`，如`Dates.dayname`所示：
- en: '[PRE90]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If we want to retrieve all the Wednesdays, we can, of course, use the `end`
    keyword, as in `MarketData.ohlc[7:7:end]`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要检索所有的星期三，当然可以使用 `end` 关键字，例如 `MarketData.ohlc[7:7:end]`。
- en: 'Let''s say we''re happy with this, but we''d like to get more context on our
    date. So, we want all the Wednesdays plus the day before and the day after our
    date. We can do this too by indexing with an array of indices:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对此满意，但还想获取更多关于我们日期的上下文信息。因此，我们想要所有星期三以及我们日期的前一天和后一天。我们也可以通过索引索引数组来实现这一点：
- en: '[PRE91]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/145d0095-c6e0-45fb-a710-166e61811c4a.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/145d0095-c6e0-45fb-a710-166e61811c4a.png)'
- en: Here, we pull each seventh row between 7 and 49, then the rows 54, 55, 56, and
    57, and then each seventh row between 63 and 70.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们抽取7到49之间的每第七行，然后是第54、55、56和57行，然后是63到70之间的每第七行。
- en: '`TimeArray` indexing is very flexible, but keep in mind that the rows must
    always be ordered by date. This is the reason why we can''t say, for instance,
    [`7:7:70`; `54;55;56;57`]—the elements would be out of order. And speaking of
    errors, including duplicate rows will also result in an error.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeArray` 索引非常灵活，但请注意，行必须始终按日期排序。这就是为什么我们不能说，例如，`[7:7:70; 54;55;56;57]`——元素会顺序错乱。至于错误，包括重复行也会导致错误。'
- en: 'We can also index using date/time objects:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用日期/时间对象进行索引：
- en: '[PRE92]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This produces the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '![](img/186fe5fa-0504-4ba5-8ecc-03f9b669a4cb.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/186fe5fa-0504-4ba5-8ecc-03f9b669a4cb.png)'
- en: 'And yes, we can use date/time ranges too:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们也可以使用日期/时间范围：
- en: '[PRE93]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The output is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/ec7bca41-878f-4422-8d74-01e6cf5fe4e5.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec7bca41-878f-4422-8d74-01e6cf5fe4e5.png)'
- en: 'Using other date range steps will work equally well:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他日期范围步长同样有效：
- en: '[PRE94]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Combining multiple indices works too:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 结合多个索引也行得通：
- en: '[PRE95]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, we can come up with any combination of columns and rows we can imagine:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以组合任何我们想象得到的列和行：
- en: '[PRE96]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This is the result:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![](img/d5779849-23df-4573-9bc9-9baaee302341.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5779849-23df-4573-9bc9-9baaee302341.png)'
- en: Querying TimeArray objects
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询 `TimeArray` 对象
- en: The `TimeSeries` module exposes a powerful, query-like API for filtering time
    series data. Let's take a look at each of them.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSeries` 模块提供了一个强大的、类似查询的API，用于过滤时间序列数据。让我们看看它们中的每一个。'
- en: The when() method
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`when()` 方法'
- en: 'The `when` method allows for aggregating elements from a `TimeArray` into specific
    time periods. For instance, we can use this function to pick the Wednesdays in
    our dataset in a more concise fashion:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 方法允许将 `TimeArray` 中的元素聚合到特定的时期。例如，我们可以使用这个函数以更简洁的方式选择数据集中的星期三：'
- en: '[PRE97]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We are not limited to just `Dates.dayname`; we can use many of the `Dates`
    functions we covered in the previous section—`day`, `dayname`, `week`, `month`,
    `monthname`, `year`, `dayofweek`, `dayofweekofmonth`, `dayofyear`, `quarterofyear`,
    and `dayofquarter`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于使用 `Dates.dayname`；我们还可以使用之前章节中提到的许多 `Dates` 函数——`day`、`dayname`、`week`、`month`、`monthname`、`year`、`dayofweek`、`dayofweekofmonth`、`dayofyear`、`quarterofyear`
    和 `dayofquarter`：
- en: '[PRE98]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The from() method
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`from()` 方法'
- en: 'This function truncates a `TimeArray` starting with the date passed to the
    method. The row corresponding to the passed date is included in the result:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从传递给方法的日期开始截断 `TimeArray`。与传递的日期对应的行包含在结果中：
- en: '[PRE99]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output is as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/55b57b0f-a293-455c-a2b0-0dab1525eef2.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55b57b0f-a293-455c-a2b0-0dab1525eef2.png)'
- en: The to() method
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`to()` 方法'
- en: 'The `to()` method returns the rows up to and including the date passed as an
    argument:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`to()` 方法返回作为参数传递的日期及之前的所有行：'
- en: '[PRE100]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The findall() and findwhen() methods
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`findall()` 和 `findwhen()` 方法'
- en: 'This family of functions tests a condition and returns the results for which
    the condition is true. The only difference is that `findall()` returns an array
    containing the numbers of the rows, while `findwhen()` returns a vector of date/time
    objects. For example, if we want to find all the rows where the closing value
    was at least 10% higher than the opening value, we can run the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数族测试一个条件，并返回条件为真的结果。唯一的区别是`findall()`返回一个包含行号的数组，而`findwhen()`返回一个日期/时间对象的向量。例如，如果我们想找到所有收盘价至少比开盘价高10%的行，我们可以运行以下代码：
- en: '[PRE101]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '`findwhen` will produce a similar output, but for the dates:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`findwhen`将产生类似的输出，但针对日期：'
- en: '[PRE102]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Manipulating time series objects
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间序列对象
- en: '`TimeSeries` exposes a minimalist, yet productive set of methods for modifying
    `TimeArray` objects.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSeries`提供了一组简约但高效的方法来修改`TimeArray`对象。'
- en: merge()
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`merge()`'
- en: 'For starters, we can combine the data from two `TimeArrays`. The `merge` method
    uses the timestamps as the join columns—and by default, it performs an inner join.
    But it''s also possible to perform left, right, and outer joins. Let''s generate
    some random data to experiment with. We''ll start by creating a time series with
    random values, spread over a week, starting today:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将两个`TimeArrays`的数据合并起来。`merge`方法使用时间戳作为连接列，并且默认执行内连接。但也可以执行左连接、右连接和外连接。让我们生成一些随机数据来实验。我们将从创建一个包含随机值的时间序列开始，这些值分布在从今天开始的整个星期内：
- en: '[PRE104]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output is as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/48da86e4-5b2e-47c9-9a5a-7f2805468a5b.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48da86e4-5b2e-47c9-9a5a-7f2805468a5b.png)'
- en: 'Next, we''ll create another time series object spread over ten days:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个跨越十天的时间序列对象：
- en: '[PRE105]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This results in the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](img/0f8eeb8c-ad11-46b2-9e8d-86caa687e8d1.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f8eeb8c-ad11-46b2-9e8d-86caa687e8d1.png)'
- en: 'So now we have two `TimeArray` instances, `t1` and `t2`. The `t2` object has
    values for all the days in `t1` plus three more days. A regular (inner join) `merge`
    will only use the rows with timestamps that are present in both `t1` and `t2`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有两个`TimeArray`实例，`t1`和`t2`。`t2`对象包含`t1`中所有天的值以及额外三天。一个常规的（内连接）`merge`只会使用`t1`和`t2`中都存在的时间戳的行：
- en: '[PRE106]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This is the output:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![](img/39a85886-a371-49c0-8d6a-f6c5cdbb1269.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39a85886-a371-49c0-8d6a-f6c5cdbb1269.png)'
- en: 'Right, left, and outer joins will introduce `NaN` values for the rows that
    don''t correspond:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 正确，左连接、右连接和外连接将为不对应的行引入`NaN`值：
- en: '[PRE107]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The output is as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/540ce8d0-6f8f-4667-af5a-78e86e19902c.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/540ce8d0-6f8f-4667-af5a-78e86e19902c.png)'
- en: The vcat() method
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`vcat()`方法'
- en: 'The `vcat()` method can be considered the counterpart of `merge`. If `merge`
    joins the columns of two time series, `vcat` combines their rows. Its most obvious
    use case is for putting together data from a dataset that is split into multiple
    files. Let''s see it in action:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`vcat()`方法可以被认为是`merge`的对应方法。如果`merge`连接两个时间序列的列，`vcat`则合并它们的行。它最明显的用例是将来自多个文件的分割数据集的数据组合在一起。让我们看看它的实际应用：'
- en: '[PRE108]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The output is as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c45534bb-8872-49f5-a4d3-09e88dbbb1c8.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c45534bb-8872-49f5-a4d3-09e88dbbb1c8.png)'
- en: 'We have created a new `TimeArray` which covers the time period between two
    weeks and three weeks from today:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`TimeArray`，它覆盖了从今天开始的两周到三周的时间段：
- en: '[PRE110]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This is the resulting `TimeArray`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的`TimeArray`：
- en: '![](img/007b4a8f-21bc-41fe-8aea-05e93947e9d2.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/007b4a8f-21bc-41fe-8aea-05e93947e9d2.png)'
- en: The resulting time series combines data from both `t1` and `t3`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的结果时间序列结合了`t1`和`t3`的数据。
- en: The collapse() method
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`collapse()`方法'
- en: 'This method allows for compressing data into a larger time frame, for instance
    converting daily data into weekly data:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许将数据压缩到更大的时间框架中，例如将每日数据转换为每周数据：
- en: '[PRE111]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'It produces the following output:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生以下输出：
- en: '![](img/610ec7a7-e78c-4718-8593-139b1f9adfdc.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/610ec7a7-e78c-4718-8593-139b1f9adfdc.png)'
- en: 'If we want to `collapse` the `january` time series, we need to decide what
    to do about the data that''s being collapsed. This is achieved by passing function
    arguments. The general form of the method is the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要`collapse`一月份的时间序列，我们需要决定如何处理被压缩的数据。这是通过传递函数参数来实现的。该方法的一般形式如下：
- en: '[PRE112]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'For instance, we can `collapse` the data for January into a weekly period (the
    `<time function>`) by keeping the last day of the period (the `<time filtering
    function>`) and by computing the mean of the values (the `<value collapsing function>`):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过保留周期内的最后一天（`<time filtering function>`）并计算值的平均值（`<value collapsing
    function>`）来将一月份的数据`collapse`到一个周期间：
- en: '[PRE113]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/fd0c2612-3271-47ef-845d-a2e3c898aa3d.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd0c2612-3271-47ef-845d-a2e3c898aa3d.png)'
- en: 'The `<value collapsing function>` is optional and if not provided, the values
    that correspond to the timestamp will be used:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`<value collapsing function>` 是可选的，如果没有提供，则将使用与时间戳对应的值：'
- en: '[PRE114]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This is what we get:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们得到的结果：
- en: '![](img/bc35d17e-515d-43a4-99ba-3625b30aae4e.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc35d17e-515d-43a4-99ba-3625b30aae4e.png)'
- en: The map() method
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: map() 方法
- en: 'Finally, the `map()` function allows us to iterate over each row in the time
    series and apply a function to both the timestamps and the values. We could easily
    postpone the first week in the `january` time series by one year, as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`map()` 函数允许我们对时间序列中的每一行进行迭代，并对时间戳和值应用一个函数。我们可以轻松地将 `january` 时间序列的第一周推迟一年，如下所示：
- en: '[PRE115]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The output is as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/6703bb47-ea7a-4990-8be1-bda091b7c9b8.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6703bb47-ea7a-4990-8be1-bda091b7c9b8.png)'
- en: There is more to say about `TimeSeries`. But for now, we'll stop here. We'll
    get back to `TimeArray` in the next chapter, where we will use it to perform time
    series analysis and forecasting on the European Union's unemployment numbers.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `TimeSeries` 还有更多要说的。但到目前为止，我们先到此为止。我们将在下一章回到 `TimeArray`，我们将用它来对欧盟的失业数据进行时间序列分析和预测。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about working with dates and times in Julia.
    The language provides a powerful, yet accessible API that follows Julia's overall
    philosophy—you can start simple and augment your code as you become more knowledgeable.
    Thus, by default, the date/time objects use local time, ignoring complex details
    like time zones. However, time zone support is only one package away. We have
    seen how to extend Julia's `Dates` API by using the functionality provided by
    `TimeZones`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在 Julia 中处理日期和时间的方法。该语言提供了一个强大且易于访问的 API，遵循 Julia 的整体哲学——你可以从简单开始，随着知识的增长而增强你的代码。因此，默认情况下，日期/时间对象使用本地时间，忽略像时区这样的复杂细节。然而，时区支持只需一个包即可实现。我们看到了如何通过使用
    `TimeZones` 提供的功能来扩展 Julia 的 `Dates` API。
- en: Using our understanding of temporal data, we were able to take yet another step
    towards becoming proficient Julia programmers and learned about time series and
    the powerful `TimeArray`. We've seen how to plot time series with `Plots`, an
    extremely versatile plotting library for Julia—in fact, it's middleware providing
    a common API for a series of visualization packages, allowing us to swap backends
    as needed.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对时间数据的理解，我们又能向前迈出一大步，成为熟练的 Julia 程序员，并学习了时间序列和强大的 `TimeArray`。我们看到了如何使用
    `Plots` 库来绘制时间序列，这是一个为 Julia 提供极其灵活绘图功能的库——实际上，它是一个中间件，为一系列可视化包提供了一个通用的 API，使我们能够根据需要交换后端。
- en: In the next chapter, we will continue our discussion of time series by performing
    analytics and forecasting on unemployment levels in the European Union. In the
    process, we'll learn about the most important patterns of time series analysis—trends,
    seasonality, and irregularity, and we will expand our knowledge of `TimeSeries`
    by performing various time series transformations.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论时间序列，通过对欧盟的失业水平进行分析和预测来执行。在这个过程中，我们将了解时间序列分析最重要的模式——趋势、季节性和不规则性，并且我们将通过执行各种时间序列转换来扩展我们对
    `TimeSeries` 的知识。
