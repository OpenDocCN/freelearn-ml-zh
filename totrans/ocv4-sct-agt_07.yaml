- en: Equipping Your Car with a Rearview Camera and Hazard Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的汽车配备后视摄像头和危险检测
- en: '"Comes the morning and the headlights fade away."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"当晨光来临，车灯逐渐消失。"'
- en: – The Living Daylights (1987)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 《致命武器》（1987）
- en: James Bond is a car thief. The movies show that he has stolen many automobiles,
    often from innocent bystanders. We do not know whether these unfortunate people
    ever recovered their property but, even if they did, the damages from collisions,
    submersions, bullets, and rockets would have had a lasting impact on their insurance
    premiums. Bond has also stolen a propeller plane, a tank, and a moon buggy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯·邦德是一个汽车盗贼。电影显示他偷了许多汽车，通常是从无辜的旁观者那里偷的。我们不知道这些不幸的人是否恢复了他们的财产，但即使他们恢复了，碰撞、沉没、子弹和火箭的损害也会对他们的保险费率产生持久的影响。邦德还偷了一架螺旋桨飞机、一辆坦克和一辆月球车。
- en: The man has been driving since the 1950s, and perhaps it is time that he stopped.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人自从 1950 年代就开始开车，也许是他应该停止的时候了。
- en: Be that as it may, we can break away from the old Cold War days of indifference
    to collateral damage. With modern technology, we can provide a driver with timely
    information about others who are sharing the road. This information may make it
    easier to avoid collisions and to properly aim the vehicle's rocket launchers
    so that a chase scene can be conducted in an orderly manner, without flattening
    whole city blocks. Secret agents will not lose so many cars and, thus, will not
    feel compelled to steal so many.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以摆脱冷战时期对附带损害漠不关心的旧观念。利用现代技术，我们可以为驾驶员提供关于共享道路上的其他人的及时信息。这些信息可能有助于避免碰撞，并正确瞄准车辆的火箭发射器，以便有序地进行追逐场景，而不会压平整个城市街区。秘密特工不会损失那么多车，因此，他们不会感到有必要偷那么多。
- en: Since driver assistance is a broad topic, let's focus on one scenario. Twilight
    and nighttime are difficult times for drivers, including secret agents. We might
    be blinded by the lack of natural light or the glare of headlights. However, we
    can make a computer vision system that sees headlights (or rear lights) clearly
    and can estimate their distance from them. This system can also distinguish between
    lights of different colors, a feature which is relevant to identifying signals
    and types of vehicles.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于驾驶辅助是一个广泛的话题，让我们专注于一个场景。黄昏和夜晚对驾驶员来说都是困难时期，包括秘密特工。我们可能会因为缺乏自然光或车灯的眩光而失明。然而，我们可以制作一个计算机视觉系统，该系统能够清楚地看到车灯（或尾灯），并可以估计它们与它们的距离。此系统还可以区分不同颜色的灯光，这一特性与识别信号和车辆类型相关。
- en: We will choose computationally inexpensive techniques, suitable for a low-powered
    computer—namely, Raspberry Pi—which we can plug into a car's cigarette lighter
    through an adapter. An LCD panel can display the relevant information, along with
    a live, rear-view video feed that is less glaring than real headlights.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择计算成本低的技巧，适合低功耗计算机——即 Raspberry Pi——我们可以通过适配器将其插入汽车的点烟器。一个液晶面板可以显示相关信息，以及一个比真实车灯不那么刺眼的实时倒车视频流。
- en: 'This project presents us with several new topics and challenges, such as the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目给我们带来了几个新的主题和挑战，如下所示：
- en: How to detect blobs of light and classify their color
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测光斑并分类其颜色
- en: How to estimate the distance from the camera to a detected object whose real-world
    size is known
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何估计从相机到已知实际尺寸的检测对象的距离
- en: How to set up a low-budget lab where we can experiment with lights of many colors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置一个低成本实验室，我们可以在这里实验多种颜色的灯光
- en: How to set up a Raspberry Pi and peripherals in a car
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在车内设置 Raspberry Pi 和外围设备
- en: Realistically, our quick, homemade project is not sufficiently robust to be
    relied upon as an automotive safety tool, so take it with a grain of salt. However,
    it is a fun introduction to analyzing signal lights and wiring up a custom in-car
    computer. The choice of Raspberry Pi as a platform challenges us to think about
    the car as an environment for rapid prototyping. We can plug in any standard peripherals,
    including a webcam, keyboard, mouse, and even a monitor, giving us a complete
    desktop Linux system with Python—on wheels! (Snakes in a car!) For more exotic
    projects, the Pi is compatible with many electronics kits, too! A smartphone or
    tablet is also a good alternative for use in a car, and is easier to power than
    a Pi with a monitor, but the Pi excels as a well-rounded prototyping tool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的快速自制项目不足以作为汽车安全工具的依赖，所以请带着怀疑的态度看待它。然而，它是对分析信号灯和连接定制车载计算机的有趣介绍。选择 Raspberry
    Pi 作为平台挑战我们思考汽车作为快速原型设计环境。我们可以插入任何标准外围设备，包括摄像头、键盘、鼠标，甚至显示器，给我们一个完整的桌面 Linux 系统，带有
    Python——在轮子上！（车里的蛇！）对于更复杂的项目，Pi 也与许多电子套件兼容！智能手机或平板电脑也是汽车中使用的良好替代品，比带显示器的 Pi 更容易供电，但
    Pi 作为全面的原型设计工具表现出色。
- en: All we need now is a name for our project. So, let the app be known as `The
    Living Headlights`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要的只是为我们项目起一个名字。因此，让这个应用程序被称为 `The Living Headlights`。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter''s project has the following software dependencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目有以下软件依赖：
- en: '**A Python environment with the following modules**: OpenCV, NumPy, SciPy,
    wxPython'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有以下模块的 Python 环境**：OpenCV, NumPy, SciPy, wxPython'
- en: Setup instructions are covered in [Chapter 1](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml),
    *Preparing for the Mission*. Refer to the setup instructions for any version requirements.
    Basic instructions for running Python code are covered in [Appendix C](c44b1aaa-fe12-4054-85fb-37d584f15d3b.xhtml),
    *Running with Snakes (or, First Steps with Python)*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设置说明在 [第 1 章](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml)，*准备任务* 中介绍。请参阅设置说明以了解任何版本要求。运行
    Python 代码的基本说明在 [附录 C](c44b1aaa-fe12-4054-85fb-37d584f15d3b.xhtml)，*与蛇一起运行（或，Python
    的第一步）* 中介绍。
- en: The completed project for this chapter can be found in this book's GitHub repository, [https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition](https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition),
    in the `Chapter005` folder.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完成项目可以在本书的 GitHub 仓库中找到，[https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition](https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition)，在
    `Chapter005` 文件夹中。
- en: Planning The Living Headlights app
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划 `The Living Headlights` 应用程序
- en: For this app, we need to return to the cross-platform wxPython framework. Optionally,
    we can also develop and test our wxPython application on a Windows, Mac, or Linux
    desktop or laptop before deploying it to our Raspberry Pi computer. With the Raspbian
    operating system, the Pi can run wxPython, just as any Linux desktop could.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们需要回到跨平台的 wxPython 框架。可选地，我们也可以在 Windows、Mac 或 Linux 桌面或笔记本电脑上开发和测试我们的
    wxPython 应用程序，然后再将其部署到我们的 Raspberry Pi 计算机上。使用 Raspbian 操作系统，Pi 可以运行 wxPython，就像任何
    Linux 桌面一样。
- en: 'The GUI for `The Living Headlights` includes a live video feed, a set of controls
    where the user can enter their true distance from headlights, and a label that
    initially displays a set of instructions, as seen in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`The Living Headlights` 的 GUI 包括实时视频流，一组用户可以输入他们与车头灯真实距离的控制，以及一个最初显示一组说明的标签，如下面的截图所示：'
- en: '![](img/1ac2b3e7-2f88-40ba-96a3-6aa0bce4c04c.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ac2b3e7-2f88-40ba-96a3-6aa0bce4c04c.png)'
- en: 'When a pair of headlights is detected, the user must perform a one-time calibration
    step. This step consists of entering the true distance between the camera and
    headlights (specifically, the midpoint between the headlights) and then clicking
    on the Calibrate button. Thereafter, the app continuously updates and displays
    an estimate of the headlights'' distance and color, as seen in the label at the
    bottom of the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到一对车头灯时，用户必须执行一次校准步骤。这一步骤包括输入相机和车头灯之间的真实距离（具体来说，是车头灯之间的中点）然后点击校准按钮。之后，应用程序会持续更新并显示车头灯距离和颜色的估计值，如下面的截图底部标签所示：
- en: '![](img/b5f11f4d-a46c-4e46-b15d-6f825222e86c.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5f11f4d-a46c-4e46-b15d-6f825222e86c.png)'
- en: The calibration and the selected unit (Meters or Feet) are stored in a configuration
    file when the app closes. They are reloaded from this file when the app reopens.
    The calibration remains valid as long as the same camera and lens are used, the
    lens does not zoom, and the spacing between two headlights in a pair remains approximately
    constant for all pairs of headlights.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用关闭时，校准和选定的单位（米或英尺）存储在配置文件中。当应用重新打开时，它们从这个文件中重新加载。只要使用相同的相机和镜头，镜头不缩放，一对车头灯之间的间距对所有车头灯对保持大致恒定，校准就保持有效。
- en: Atop the video feed, colored circles are drawn to mark detected lights, and
    lines are drawn between pairs of detected lights whose colors match. Such a pair
    is considered to be a set of headlights.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频流上方，用彩色圆圈标记检测到的灯光，并在颜色匹配的检测到的灯光对之间画线。这样的对被认为是车头灯的一组。
- en: Next, let's consider techniques for detecting lights and classifying their colors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑检测灯光和分类它们颜色的技术。
- en: Detecting lights as blobs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将灯光检测为块
- en: To the human eye, light can appear both very bright and very colorful. Imagine
    a sunny landscape or a storefront lit by a neon sign; they are bright and colorful!
    However, a camera captures a range of contrast that is much narrower and not as
    intelligently selected, so that the sunny landscape or neon-lit storefront can
    look washed out. This problem of poorly controlled contrast is especially bad
    in cheap cameras or cameras that have small sensors, such as webcams. As a result,
    bright light sources tend to be imaged as big white blobs with thin rims of color.
    These blobs also tend to mimic a lens's iris—typically, a polygon approximating
    a circle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对人眼来说，光可以显得既非常明亮又非常多彩。想象一下晴朗的风景或被霓虹灯照亮的店面；它们既明亮又多彩！然而，相机捕捉到的对比度范围要窄得多，且选择并不智能，因此晴朗的风景或霓虹灯照亮的店面可能会看起来褪色。这种对比度控制不佳的问题在廉价的相机或具有小传感器的相机（如网络摄像头）中尤为严重。因此，明亮的灯光源往往被成像为带有薄色边的白色块。这些块也倾向于模仿镜头的光圈——通常是一个近似圆形的多边形。
- en: The thought of all lights becoming white and circular makes the world seem like
    a poorer place, if you ask me. Nonetheless, in computer vision, we can take advantage
    of such a predictable pattern. We can look for white blobs that are nearly circular
    and we can infer their human-perceptible color from a sample that includes extra
    pixels around the rim.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有灯光都变成白色和圆形的想法，在我看来，让这个世界显得更加贫瘠。然而，在计算机视觉中，我们可以利用这种可预测的图案。我们可以寻找几乎圆形的白色块，并可以从包含边缘周围额外像素的样本中推断出它们的人类可感知颜色。
- en: '**Blob detection** is actually a major branch of computer vision. Unlike the
    face detectors (or other object detectors) that we discussed in previous chapters,
    a blob detector is not trained. There is no concept of a reference image, so meaningful
    classifications such as *This blob is a light* or *This blob is skin *are more
    complicated to produce. Classification goes beyond the ken of the blob detector
    itself. We explicitly define thresholds between non-lights and lights, and between
    different human-perceptible colors of lights, based on *a priori* knowledge about
    typical shapes and colors of light sources, as imaged by a webcam.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**块检测**实际上是计算机视觉的一个主要分支。与我们在前几章中讨论的面部检测器（或其他对象检测器）不同，块检测器没有经过训练。没有参考图像的概念，因此像“这个块是灯光”或“这个块是皮肤”这样的有意义的分类就更加复杂。分类超出了块检测器本身的范围。我们根据关于典型光源形状和颜色的先验知识，基于
    webcam 捕获的图像，明确地定义了非灯光和灯光之间，以及不同人类可感知灯光颜色的阈值。'
- en: Other terms for a blob include a *connected component* and a *region*. However,
    in this book, we just say *blob*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 块的其他术语包括*连通分量*和*区域*。然而，在这本书中，我们只说*块*。
- en: 'At its simplest, blob detection consists of the five following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的层面上，块检测包括以下五个步骤：
- en: Partition the image into two or more colors. For example, this can be accomplished
    by *binary thresholding* (also called **binarization**), whereby all grayscale
    values above a threshold are converted into white and all grayscale values below
    the threshold are converted into black.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像分成两种或更多颜色。例如，这可以通过*二值阈值*（也称为**二值化**）来实现，其中所有高于阈值的灰度值被转换为白色，所有低于阈值的灰度值被转换为黑色。
- en: Find the *contour* of each contiguously colored region, that is, each blob.
    The contour is a set of points describing the region's outline.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到每个连续着色区域的*轮廓*，即每个块。轮廓是一组描述区域轮廓的点。
- en: Merge blobs that are deemed to be neighbors.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并被认为是邻居的块。
- en: Optionally, determine each blob's *features*. These arehigher-level measurements
    such as the center point, radius, and circularity. The usefulness of these features
    lies in their simplicity. For further blob-related computations and logic, it
    may be best to avoid complex representation, such as a contour's many points.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，确定每个块的特征。这些是更高层次的测量，例如中心点、半径和圆形度。这些特征的有用之处在于它们的简单性。对于进一步的块相关计算和逻辑，最好避免复杂的表示，例如轮廓的许多点。
- en: Reject blobs that fail to meet certain measurable criteria.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拒绝未能满足某些可测量标准的块。
- en: 'OpenCV implements a simple blob detector in a class called `cv2.SimpleBlobDetector`
    (appropriately enough). This class''s constructor takes an instance of a helper
    class called `cv2.SimpleBlobDetector_Params`, which describes the criteria for
    accepting or rejecting a candidate blob. `SimpleBlobDetector_Params` has the following
    member variables:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV在名为`cv2.SimpleBlobDetector`的类中实现了一个简单的块检测器（恰如其分）。这个类的构造函数接受一个名为`cv2.SimpleBlobDetector_Params`的辅助类实例，该实例描述了接受或拒绝候选块的标准。`SimpleBlobDetector_Params`有以下成员变量：
- en: '`thresholdStep`, `minThreshold`, and `maxThreshold`: The search for blobs is
    based on a series of binarized images (analogous to the series of scaled images
    that are searched by a Haar cascade detector, as described in [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml),
    *Training a Smart Alarm to Recognize the Villain and His Cat*). The thresholds
    for binarization are based on the range and step size given by these variables.
    We use `8`, `191`, and `255`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thresholdStep`、`minThreshold`和`maxThreshold`：块搜索基于一系列二值化图像（类似于在[第3章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)，*训练智能警报识别恶棍和他的猫*中描述的Haar级联检测器搜索的一系列缩放图像）。二值化的阈值基于这些变量给出的范围和步长。我们使用`8`、`191`和`255`。'
- en: '`minRepeatability`: This variable minus one is the minimum number of neighbors
    that a blob must have. We use `2`, meaning that a blob must have at least one
    neighbor. If we did not require at least one neighbor, the detector would tend
    to report a large number of blobs, with a lot of overlap between blobs.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minRepeatability`：此变量减一是一个块必须拥有的最小邻居数。我们使用`2`，这意味着一个块必须至少有一个邻居。如果我们不要求至少有一个邻居，检测器往往会报告大量重叠的块。'
- en: '`minDistBetweenBlobs`: Blobs must be at least this many pixels apart. Blobs
    that are closer than the minimum distance from each other are counted as neighbors.
    We use a minimum distance calculated as two percent of the image''s larger dimension
    (typically width).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minDistBetweenBlobs`：块之间至少需要相隔这么多像素。彼此距离小于最小距离的块被视为邻居。我们使用一个计算为图像较大尺寸（通常是宽度）的2%的最小距离。'
- en: '`filterByColor` (`True` or `False`) and `blobColor`: If `filterByColor` is
    `True`, a blob''s central pixel must exactly match `blobColor`. We use `True`
    and `255` (white), based on our assumption that light sources are white blobs.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterByColor`（`True`或`False`）和`blobColor`：如果`filterByColor`为`True`，则块的中心像素必须与`blobColor`完全匹配。我们使用`True`和`255`（白色），基于我们的假设，光源是白色块。'
- en: '`filterByArea` (`True` or `False`), `minArea`, and `maxArea`: If `filterByArea`
    is `True`, a blob''s area in pixels must fall within the given range. We use `True`
    and a range calculated as 0.5 percent to 10 percent of the image''s larger dimension
    (typically width).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterByArea`（`True`或`False`）、`minArea`和`maxArea`：如果`filterByArea`为`True`，则块在像素中的面积必须在给定的范围内。我们使用`True`和计算为图像较大尺寸（通常是宽度）的0.5%到10%的范围。'
- en: '`filterByCircularity` (`True` or `False`), `minCircularity`, and `maxCircularity`:
    If `filterByCircularity` is `True`, a blob''s circularity must fall within the
    given range, where circularity is defined as `4 * PI * area / (perimeter ^ 2)`.
    A circle''s circularity is 1.0 and a line''s circularity is 0.0\. For our approximately
    circular light sources, we use `True` and the range 0.7 to 1.0.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterByCircularity`（`True`或`False`）、`minCircularity`和`maxCircularity`：如果`filterByCircularity`为`True`，则块必须在其给定的范围内，其中圆形度定义为`4
    * PI * area / (perimeter ^ 2)`。圆的圆形度为1.0，线的圆形度为0.0。对于我们的大致圆形光源，我们使用`True`和范围0.7到1.0。'
- en: '`filterByInertia` (`True` or `False`), `minInertiaRatio`, and `maxInertiaRatio`:
    If `filterByInertia` is `True`, a blob''s inertia ratio must fall within the given
    range. A relatively high inertia ratio implies that the blob is relatively elongated
    (and would thus require more torque to rotate along its longest axis). A circle''s
    inertia ratio is 1.0 and a line''s inertia ratio is 0.0\. We use `filterByInertia=False`
    (no filtering by inertia) because the circularity test already gives sufficient
    control over the shape for our purposes.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterByInertia` (`True` 或 `False`), `minInertiaRatio`, 和 `maxInertiaRatio`:
    如果 `filterByInertia` 是 `True`，则一个区域的惯性比必须在给定的范围内。相对较高的惯性比意味着区域相对细长（因此旋转其最长轴需要更大的扭矩）。圆的惯性比是
    1.0，线的惯性比是 0.0。我们使用 `filterByInertia=False`（不按惯性过滤）是因为圆形测试已经足够控制形状以满足我们的目的。'
- en: '`filterByConvexity` (`True` or `False`), `minConvexity`, and `maxConvexity`:
    If `filterByConvexity` is `True`, a blob''s convexity must fall within the given
    range, where convexity is defined as `area/hullArea`. Here, `hullArea` refers
    to the area of the convex hull—the convex polygon surrounding all the points of
    a contour with the minimum area. Convexity is always more than 0.0 and less than
    1.0\. A relatively high convexity implies that the contour is relatively smooth.
    We use `filterByConvexity=False` (no filtering by convexity) because the circularity
    test already gives sufficient control over the shape for our purposes.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterByConvexity` (`True` 或 `False`), `minConvexity`, 和 `maxConvexity`: 如果
    `filterByConvexity` 是 `True`，则一个区域的凸性必须在给定的范围内，其中凸性定义为 `面积/凸包面积`。在这里，`凸包面积` 指的是凸包的面积——围绕轮廓所有点的最小面积的凸多边形。凸性始终大于
    0.0 且小于 1.0。相对较高的凸性意味着轮廓相对平滑。我们使用 `filterByConvexity=False`（不按凸性过滤）是因为圆形测试已经足够控制形状以满足我们的目的。'
- en: Although these parameters cover many useful criteria, they are designed for
    grayscale images and do not provide a practical means of filtering or classifying
    blobs based on separate criteria for hue, saturation, and luminosity. The suggested
    values in the preceding list are tuned to extract bright blobs of light. However,
    we may want to classify such blobs by subtle variations in color, especially around
    the blob's edge.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些参数涵盖了许多有用的标准，但它们是为灰度图像设计的，并且不提供基于色调、饱和度和亮度单独标准的实际过滤或分类区域的手段。前面列表中建议的值是为了提取明亮的区域。然而，我们可能希望根据颜色在区域边缘的细微变化来分类这样的区域。
- en: '**Hue** refers to a color''s angle on the color wheel, where *0* degrees is
    red, *120* is green, and *240* is blue. The hue in degrees can be calculated from
    RGB values with the following formula:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**色调**指的是颜色在色轮上的角度，其中 *0* 度是红色，*120* 度是绿色，*240* 度是蓝色。色调（以度为单位）可以通过以下公式从 RGB
    值计算得出：'
- en: '![](img/85334e33-6266-4d3c-b482-05437d6097d8.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85334e33-6266-4d3c-b482-05437d6097d8.png)'
- en: '**Saturation** refers to a color''s distance from grayscale. There are several
    alternative formulations of an RGB color''s saturation. We use the following formulation,
    which some authors call **chroma** instead of saturation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**饱和度**指的是颜色与灰度的距离。RGB 颜色的饱和度有几种不同的公式。我们使用以下公式，一些作者将其称为 **色度** 而不是饱和度：'
- en: '![](img/e863ddc6-697d-461c-8dd0-600f505f599f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e863ddc6-697d-461c-8dd0-600f505f599f.png)'
- en: We can classify a light source's human-perceptible color based on the average
    hue and saturation of the blob and some surrounding pixels. The combination of
    a low saturation and a blue or yellow hue tends to suggest that the light will
    appear white to human vision. Other light sources may appear (in order of ascending
    hue) as red, orange/amber/yellow, green (a wide range from spring green to emerald),
    blue/purple (another wide range), or pink, to give just a few examples. Threshold
    values can be chosen based on trial and error.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据区域和周围像素的平均色调和饱和度来分类光源的人眼可感知颜色。低饱和度和蓝色或黄色的色调组合往往意味着光线在人类视觉中会显得白色。其他光源可能（按色调升序排列）呈现为红色、橙色/琥珀色/黄色、绿色（从春绿色到翡翠的广泛范围）、蓝色/紫色（另一个广泛范围）或粉色，仅举几个例子。阈值值可以根据试错法选择。
- en: Using the techniques we've mentioned, we can detect the location, pixel radius,
    and perceptual color of light sources. However, we need additional techniques
    to get an estimate of the real distance between the camera and a pair of headlights.
    Let's turn our attention to this problem now.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们提到的技术，我们可以检测光源的位置、像素半径和感知颜色。然而，我们需要额外的技术来估计相机与一对车头灯之间的实际距离。现在让我们关注这个问题。
- en: Estimating distances (a cheap approach)
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 估计距离（一种经济的方法）
- en: 'Suppose we have an object sitting in front of a pinhole camera. Regardless
    of the distance between the camera and the object, the following equation holds
    true:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个物体坐在针孔相机的前面。无论相机和物体之间的距离如何，以下方程始终成立：
- en: '![](img/90fd8367-ddea-474b-a401-522814d03c63.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90fd8367-ddea-474b-a401-522814d03c63.png)'
- en: We may use any unit (such as pixels) in the equation's left-hand side and any
    unit (such as meters) in its right-hand side (on each side of the equation, the
    division cancels the unit). Moreover, we may define the object's size based on
    anything linear that we can detect in the image, such as the diameter of a detected
    blob or the width of a detected face rectangle.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在方程的左边使用任何单位（例如像素），在右边使用任何单位（例如米）（在方程的每一侧，除法会消除单位）。此外，我们可以根据我们在图像中可以检测到的任何线性特征来定义物体的大小，例如检测到的斑块的直径或检测到的面部矩形的宽度。
- en: 'Let''s rearrange the equation to illustrate that the distance to the object
    is inversely proportional to the object''s size in the image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新排列方程，以说明物体到距离与图像中物体的大小成反比：
- en: '![](img/034b8d7f-f388-49a7-88af-e6cedf04b718.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/034b8d7f-f388-49a7-88af-e6cedf04b718.png)'
- en: 'Let''s assume that the object''s real size and the camera''s focal length are
    constant (a constant focal length means that the lens does not zoom and we do
    not swap the lens for a different lens). Consider the following arrangement, which
    isolates this pair of constants on the right-hand side of the equation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设物体的真实尺寸和相机的焦距是恒定的（恒定焦距意味着镜头不会变焦，我们不会更换镜头）。考虑以下安排，它将这对常数隔离在方程的右边：
- en: '![](img/7627267c-3d3f-464d-9942-bb924375dd37.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7627267c-3d3f-464d-9942-bb924375dd37.png)'
- en: 'As the right-hand side of the equation is constant, so is the left. We may
    conclude that the following relationship holds true over time:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方程的右边是恒定的，所以左边也是。我们可以得出以下关系在时间上成立：
- en: '![](img/d50c2596-5ff5-4127-8000-20e550eece2e.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d50c2596-5ff5-4127-8000-20e550eece2e.png)'
- en: 'Let''s solve the following equation for the new distance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解以下方程以得到新的距离：
- en: '![](img/9898b8b0-4da5-4ae8-aa7b-649f9632fbeb.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9898b8b0-4da5-4ae8-aa7b-649f9632fbeb.png)'
- en: 'Now, let''s think about applying this equation in software. To provide a ground
    truth, the user must take a single, true measurement of the distance to use as
    the *old* distance in all future calculations. As well as this, we must know the
    object''s old pixel size and its subsequent new size so that we can compute the
    new distance any time there is a detection result. Let''s review the following
    assumptions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑在软件中应用这个方程。为了提供一个基准，用户必须进行一次真实的距离测量，作为所有未来计算中使用的*旧*距离。此外，我们必须知道物体的旧像素大小及其随后的新大小，这样我们就可以在检测结果出现时计算新的距离。让我们回顾以下假设：
- en: There is no lens distortion; the pinhole camera model applies
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有镜头畸变；应用针孔相机模型
- en: Focal length is constant; no zoom is applied and the lens is not swapped for
    a different lens
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦距是恒定的；没有应用变焦，且镜头没有更换为不同镜头
- en: The object is rigid; its real-world measurements do not change
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物体是刚性的；其真实世界的测量值不会改变
- en: The camera is always viewing the same side of the object; the relative rotation
    of the camera and object does not change
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机总是观察物体的同一侧；相机和物体的相对旋转不会改变
- en: You might wonder whether the first assumption is problematic, as webcams often
    have cheap wide angle lenses with significant distortion. Despite lens distortion,
    does the object's size in the image remain inversely proportional to the real
    distance between the camera and object? The following paper reports experimental
    results for a lens that appears to distort badly and an object that is located
    off-center (in an image region where distortion is likely to be especially bad)—M.
    N. A. Wahab, N. Sivadev, and K. Sundaraj. *Target distance estimation using monocular
    vision system for mobile robot*. **IEEE Conference on Open Systems** (**ICOS**)
    2011 Proceedings, vol. 11, no. 15, p. 25-28\. September 2011.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道第一个假设是否有问题，因为网络摄像头通常配备便宜的广角镜头，具有显著的畸变。尽管存在镜头畸变，图像中的物体大小是否仍然与相机和物体之间的真实距离成反比？以下论文报告了对于看起来畸变很严重的镜头和位于非中心位置（在畸变可能特别严重的图像区域）的物体的实验结果——M.
    N. A. Wahab，N. Sivadev和K. Sundaraj。*使用单目视觉系统进行移动机器人目标距离估计*。**IEEE开放系统会议**（**ICOS**）2011年会议论文集，第11卷，第15期，第25-28页。2011年9月。
- en: 'Using exponential regression, the authors show that the following model is
    a good fit for experimental data (*R^2=0.995*):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指数回归，作者们表明以下模型是实验数据的良好拟合（*R^2=0.995*）：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the exponent is close to *-1*, and thus the statistical model is not
    far from the ideal inverse relationship. (Even the poor-quality lens and off-center
    subject did not disprove our assumptions!)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，指数接近于**-1**，因此统计模型并不远离理想的反比关系。（即使是质量较差的镜头和偏离中心的物体也没有否定我们的假设！）
- en: We can also ensure that the second assumption (no zooming and no swapping of
    the lens) holds true.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以确保第二个假设（没有缩放和镜头交换）是正确的。
- en: Let's consider the third and fourth assumptions (rigidity and constant rotation)
    in the case of a camera and object—one in each car on a highway. Except in a crash,
    most of a car's exterior parts are rigid. Except when passing or pulling over,
    one car travels directly behind the other on a surface that is mostly flat and
    mostly straight. However, on a road that is hilly or has many turns, these assumptions
    start to fall apart. It becomes more difficult to predict which side of the object
    is currently being viewed; thus, it is more difficult to say whether our reference
    measurements apply to a particular side.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑第三个和第四个假设（刚性和恒定旋转）在相机和物体的情况下一一对应——在高速公路上的每辆汽车上。除非发生碰撞，否则一辆汽车的大部分外部部件都是刚性的。除非在超车或停车时，一辆汽车通常直接跟在另一辆汽车后面，行驶在大部分平坦且大部分直线的路面上。然而，在多山或有许多转弯的道路上，这些假设开始失效。预测物体当前被观察的侧面变得更加困难；因此，说我们的参考测量是否适用于特定的侧面也更加困难。
- en: Of course, we need to define a generic car part to be our *object*. The headlights
    (and the space between them) are a decent choice, since we have a method for detecting
    them and the distance between headlights is consistent across many cars—although
    not all.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要定义一个通用的汽车部件作为我们的**对象**。前灯（以及它们之间的空间）是一个不错的选择，因为我们有检测它们的方法，而且许多汽车的前灯距离是一致的——尽管并非所有汽车都是这样。
- en: 'All distance estimation techniques in computer vision rely on some assumptions
    or calibration steps that relate to the camera, the object, the relationship between
    camera and object, or lighting. For comparison, let''s consider some of the following
    common distance estimation techniques:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉中的所有距离估计技术都依赖于一些假设或与相机、物体、相机与物体之间的关系或照明相关的校准步骤。为了比较，让我们考虑以下一些常见的距离估计技术：
- en: A **time-of-flight** (**ToF**) camera shines a light on objects and measures
    the intensity of any reflected light. This intensity is used to estimate the distance
    at each pixel based on the known fall-off characteristics of the light source.
    Some ToF cameras, such as Microsoft Kinect, use an infrared light source. Other,
    more expensive ToF cameras scan a scene with a laser or even use a grid of lasers.
    ToF cameras may suffer from interference if other bright lights are being imaged,
    so they are poorly suited to our application.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**飞行时间**（**ToF**）相机向物体发射光线，并测量任何反射光的强度。这个强度被用来根据光源已知的衰减特性来估计每个像素的距离。一些ToF相机，如微软Kinect，使用红外光源。其他更昂贵的ToF相机使用激光扫描场景，甚至使用激光阵列。如果正在成像其他明亮的光源，ToF相机可能会受到干扰，因此它们不适合我们的应用。'
- en: A **stereo camera** consists of two parallel cameras with a known, fixed distance
    between them. In each frame, a pair of images is captured, features are identified,
    and a *disparity* or pixel distance is calculated for each pair of corresponding
    features. We can convert disparity into real distance based on the cameras' known
    field of view and the distance between them. For our application, stereo techniques
    would be feasible, but they are also computationally expensive and use a lot of
    input bus bandwidth. Optimizing these techniques for Raspberry Pi would be a big
    challenge.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立体相机**由两个平行相机组成，它们之间有一个已知且固定的距离。在每一帧中，捕获一对图像，识别特征，并计算每对对应特征之间的**视差**或像素距离。我们可以根据相机的已知视场和它们之间的距离将视差转换为实际距离。对于我们的应用，立体技术是可行的，但它们在计算上也很昂贵，并且使用大量的输入总线带宽。优化这些技术在树莓派上将会是一个巨大的挑战。'
- en: '**Structure from Motion** (**SfM**) techniques only need a single, regular
    camera, but rely on moving the camera by known distances over time. For each pair
    of images taken from neighboring locations, disparities are calculated, as with
    a stereo camera. In this scenario, as well as knowing the camera''s movements,
    we must know the object''s movements or lack thereof. Due to these limitations,
    SfM techniques are poorly suited to our application, as our camera and object
    are mounted on two freely moving vehicles.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从运动结构**（**SfM**）技术只需要一个常规相机，但依赖于相机随时间移动已知距离。对于从相邻位置拍摄的每一对图像，都会计算视差，就像立体相机一样。在这种情况下，除了知道相机的移动外，我们还必须知道物体的移动或静止。由于这些限制，SfM技术不适合我们的应用，因为我们的相机和物体都安装在两个自由移动的车辆上。'
- en: Various **3D feature tracking** techniques entail estimating the rotation of
    an object, as well as its distance and other coordinates. Edges and texture details
    are also considered. The differences between models of cars make it difficult
    to define one set of features that are suitable for 3D tracking, and so 3D feature
    tracking is not well-suited to our application. Moreover, 3D tracking is computationally
    expensive, especially by the standards of a low-powered computer such as Raspberry
    Pi.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种**3D特征跟踪**技术包括估计物体的旋转、距离和其他坐标。边缘和纹理细节也被考虑在内。汽车模型之间的差异使得难以定义一套适用于3D跟踪的特征，因此3D特征跟踪不适合我们的应用。此外，3D跟踪计算成本高，尤其是在像Raspberry
    Pi这样的低功耗计算机的标准下。
- en: 'For more information on these techniques, refer to the following books, available
    from Packt Publishing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些技术的更多信息，请参阅以下由Packt Publishing出版的书籍：
- en: Kinect and other ToF cameras are covered in the first edition of my book, *OpenCV
    Computer Vision with Python*, specifically *Chapter 5, Detecting Foreground/Background
    Regions and Depth*.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我的第一版书籍《使用Python的OpenCV计算机视觉》中介绍了Kinect和其他ToF相机，具体是第5章“检测前景/背景区域和深度”。
- en: 3D feature tracking and SfM are covered in *Mastering OpenCV with Practical
    Computer Vision Projects*, specifically *Chapter 3, Markerless Augmented Reality,* and *Chapter
    4, Exploring Structure from Motion Using OpenCV*.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D特征跟踪和SfM（从运动结构）在《精通OpenCV：基于实际计算机视觉项目的实践》一书中有所介绍，具体是第3章“无标记增强现实”和第4章“使用OpenCV探索从运动结构”。
- en: Stereo vision and 3D feature tracking are covered in Robert Laganière's *OpenCV
    3 Computer Vision Application Programming Cookbook*, specifically *Chapter 10,
    Estimating Projective Relations in Images*.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立体视觉和3D特征跟踪在Robert Laganière的《OpenCV 3计算机视觉应用编程食谱》一书中有所介绍，具体是第10章“在图像中估计投影关系”。
- en: Stereo vision and 3D pose estimation are also covered in Alexey Spizhevoy and
    Aleksandr Rybnikov's *OpenCV 3 Computer Vision with Python Cookbook*, specifically *Chapter
    9, Multiple View Geometry*.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Alexey Spizhevoy和Aleksandr Rybnikov的《使用Python的OpenCV 3计算机视觉食谱》一书中也介绍了立体视觉和3D姿态估计，具体是第9章“多视图几何”。
- en: On balance, the simplistic approach—based on pixel distances being inversely
    proportional to real distances—is a justifiable choice given our application and
    our intent to support the Pi.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 综合来看，基于像素距离与实际距离成反比这一简单方法，鉴于我们的应用和意图支持Pi，是一个合理的选择。
- en: Implementing The Living Headlights app
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现The Living Headlights应用程序
- en: '`The Living Headlights` app will use the following files:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`The Living Headlights`应用程序将使用以下文件：'
- en: '`LivingHeadlights.py`: This is a new file that contains our application class
    and its `main` function.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LivingHeadlights.py`：这是一个新文件，包含我们的应用程序类及其`main`函数。'
- en: '`ColorUtils.py`: This is a new file that contains the utility functions required
    to convert colors into different representations.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorUtils.py`：这是一个新文件，包含将颜色转换为不同表示所需的实用函数。'
- en: '`GeomUtils.py`: This contains utility functions for geometric calculations.
    Copy or link to the version that we used in [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*,
    Training a Smart Alarm to Recognize the Villain and His Cat*.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GeomUtils.py`：这包含用于几何计算的实用函数。复制或链接到我们在[第3章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*，训练智能警报识别恶人和他的猫*中使用的版本。'
- en: '`PyInstallerUtils.py`: This contains utility functions for accessing resources
    in a PyInstaller application bundle. Copy or link to the version that we used
    in [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*, Training a Smart
    Alarm to Recognize the Villain and His Cat*.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyInstallerUtils.py`：这包含用于访问PyInstaller应用程序包中资源的实用函数。复制或链接到我们在[第3章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*，训练智能警报识别恶人和他的猫*中使用的版本。'
- en: '`ResizeUtils.py`: This contains utility functions for resizing images, including
    camera capture dimensions. Copy or link to the version that we used in [Chapter
    3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*, Training a Smart Alarm to Recognize
    the Villain and His Cat*.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResizeUtils.py`：这包含用于调整图像大小的实用函数，包括摄像头捕获尺寸。复制或链接到我们在 [第 3 章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*训练智能闹钟以识别恶人和他的猫*
    中使用的版本。'
- en: '`WxUtils.py`: This contains utility functions for using OpenCV images in wxPython
    apps. Copy or link to the version that we used in [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*,
    Training a Smart Alarm to Recognize the Villain and His Cat*.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WxUtils.py`：这包含在 wxPython 应用中使用 OpenCV 图像的实用函数。复制或链接到我们在 [第 3 章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*训练智能闹钟以识别恶人和他的猫*
    中使用的版本。'
- en: 'Let''s get started with the creation of `ColorUtils.py`. Here, we need functions
    to calculate a color''s hue and saturation according to the formulae mentioned
    in the *Detecting lights as blobs* section. The module''s implementation is shown
    in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建 `ColorUtils.py` 开始。在这里，我们需要根据 *检测灯光作为块* 部分中提到的公式计算颜色的色调和饱和度。该模块的实现如下面的代码所示：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we want to convert an entire image (that is, every pixel) to hue, saturation,
    and either luminosity or value, we can use the following OpenCV method, `cvtColor`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将整个图像（即每个像素）转换为色调、饱和度以及亮度或值，我们可以使用以下 OpenCV 方法，`cvtColor`：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See the following Wikipedia article for definitions of saturation, luminosity,
    and value in HSV and HSL color models at [https://en.wikipedia.org/wiki/HSL_and_HSV](https://en.wikipedia.org/wiki/HSL_and_HSV).
    Our definition of saturation is called **chroma** in the Wikipedia article, which
    differs from HSL saturation, and in turn differs again from HSV saturation. Moreover,
    OpenCV represents hue in units of two degrees (a range of `0` to `180`) so that
    the hue channel fits inside a byte.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有关饱和度、亮度和 HSV 和 HSL 颜色模型中值的定义，请参阅以下维基百科文章：[https://en.wikipedia.org/wiki/HSL_and_HSV](https://en.wikipedia.org/wiki/HSL_and_HSV)。我们在维基百科文章中的饱和度定义被称为
    **色度**，这与 HSL 饱和度不同，并且又与 HSV 饱和度不同。此外，OpenCV 以两度（范围从 `0` 到 `180`）为单位表示色调，以便色调通道适合在一个字节内。
- en: For some types of image segmentation problems, it is useful to convert the entire
    image into HSV, HSL, or another color model. For example, see Rebecca Stone's
    blog post about segmenting images of clown fish at [https://realpython.com/python-opencv-color-spaces/](https://realpython.com/python-opencv-color-spaces/),
    or Vikas Gupta's blog post about segmenting images of Rubik's cubes at [https://www.learnopencv.com/color-spaces-in-opencv-cpp-python/](https://www.learnopencv.com/color-spaces-in-opencv-cpp-python/).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的图像分割问题，将整个图像转换为 HSV、HSL 或其他颜色模型是有用的。例如，参见 Rebecca Stone 关于分割海葵图像的博客文章：[https://realpython.com/python-opencv-color-spaces/](https://realpython.com/python-opencv-color-spaces/)，或
    Vikas Gupta 关于分割魔方图像的博客文章：[https://www.learnopencv.com/color-spaces-in-opencv-cpp-python/](https://www.learnopencv.com/color-spaces-in-opencv-cpp-python/)。
- en: We have written our own conversion functions because, for our purposes, converting
    an entire image is unnecessary; we just need to convert a sample from each blob.
    We also prefer a more accurate floating-point representation instead of the byte-sized
    integer representation that OpenCV imposes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了自己的转换函数，因为，对于我们的目的来说，转换整个图像是不必要的；我们只需要转换每个块的一个样本。我们还更喜欢更精确的浮点数表示，而不是 OpenCV
    强制的字节大小整数表示。
- en: 'We also need to modify `GeomUtils.py` by adding a function to calculate the
    Euclidean distance between two 2D points, such as the pixel coordinates of two
    headlights in an image. At the top of the file, let''s add an import statement
    and implement the function, as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要通过添加一个计算两个二维点之间欧几里得距离的函数来修改 `GeomUtils.py` 文件，例如计算图像中两个前灯的像素坐标。在文件顶部，让我们添加一个导入语句并实现该函数，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Distances (and other magnitudes) can also be calculated using NumPy''s `linalg.norm` function,
    as seen in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 的 `linalg.norm` 函数也可以计算距离（和其他量级），如下面的代码所示：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `a0` and `a1` can be any size and shape. However, for a low-dimensional
    space such as 2D or 3D coordinate vectors, the overhead of using NumPy arrays
    is probably not worthwhile, so a utility function such as ours is a reasonable
    alternative.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a0` 和 `a1` 可以是任何大小和形状。然而，对于二维或三维坐标向量这样的低维空间，使用 NumPy 数组的开销可能并不值得，因此像我们这样的实用函数是一个合理的替代方案。
- en: 'The preceding code contains all the new utility functions. Now, let''s create
    a file, `LivingHeadlights.py`, for the app''s `main` class, `LivingHeadlights`.
    Like `InteractiveRecognizer` in [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*,
    Training a Smart Alarm to Recognize the Villain and His Cat*, `LivingHeadlights`
    is a class for a wxPython app that captures and processes images on a background
    thread (to avoid blocking the GUI on the main thread), allows a user to enter
    reference data, serializes its reference data when exiting, and deserializes its
    reference data when starting up again. This time, serialization and deserialization
    is accomplished using Python''s `cPickle` module or, if `cPickle` is unavailable
    for any reason, the less-optimized `pickle` module. Let''s add the following import
    statements to the start of `LivingHeadlights.py`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码包含了所有新的实用函数。现在，让我们创建一个文件，名为 `LivingHeadlights.py`，用于应用程序的 `main` 类，`LivingHeadlights`。与
    [第 3 章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*训练智能闹钟识别恶棍及其猫* 中的 `InteractiveRecognizer`
    类一样，`LivingHeadlights` 是一个 wxPython 应用程序的类，它可以在后台线程中捕获和处理图像（以避免在主线程上阻塞 GUI），允许用户输入参考数据，在退出时序列化其参考数据，并在再次启动时反序列化其参考数据。这次，序列化和反序列化是通过
    Python 的 `cPickle` 模块完成的，或者如果由于任何原因 `cPickle` 不可用，则使用较不优化的 `pickle` 模块。让我们在 `LivingHeadlights.py`
    的开头添加以下导入语句：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s also define some BGR color values and names at the start of the module.
    We will classify each blob as one of the following colors, depending on its hue
    and saturation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在模块的开头也定义一些 BGR 颜色值和名称。我们将根据每个 blob 的色调和饱和度将其分类为以下颜色之一：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s begin implementing the class. The initializer takes several arguments
    relating to the configuration of the blob detector and the camera. Refer back
    to the *Detecting lights as blobs* section for explanations of the blob detection
    parameters supported by OpenCV''s `SimpleBlobDetector` and `SimpleBlobDetector_Params`
    classes. The class declaration and initializer declaration is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现这个类。初始化器接受与 blob 检测器和相机配置相关的几个参数。请参阅 *将灯光检测为 blob* 部分以了解 OpenCV 的
    `SimpleBlobDetector` 和 `SimpleBlobDetector_Params` 类支持的 blob 检测参数的解释。类的声明和初始化器声明如下：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We start the initializer''s implementation by setting a public Boolean variable
    that indicates to the app to display a mirrored image and a protected Boolean
    variable that ensures the app is running, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从初始化器的实现开始，设置一个公共布尔变量，指示应用程序显示镜像图像，以及一个受保护的布尔变量，确保应用程序正在运行，如下所示：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If there is any configuration file saved from a previous run of the app, we
    deserialize the reference measurements (the pixel distance between lights and
    the real distance in meters between lights and the camera), as well as the user''s
    preferred unit of measurement (`meters` or `feet`), as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序的先前运行中保存了任何配置文件，我们将反序列化参考测量（灯光与灯光之间的像素距离以及灯光与相机之间实际的米距离），以及用户的首选计量单位（`meters`
    或 `feet`），如下所示：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we initialize a `VideoCapture` object and try to configure the size of
    the captured images. If the requested size is unsupported, we fall back to the
    default size, as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们初始化一个 `VideoCapture` 对象并尝试配置捕获图像的大小。如果请求的大小不受支持，我们将回退到默认大小，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to declare variables for the images we will capture, process,
    and display. Initially, these are `None`. We also need to create a lock to manage
    thread-safe access to an image that will be captured and processed on one thread,
    and then drawn to the screen on another thread. The relevant declarations are
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要声明我们将要捕获、处理和显示的图像的变量。最初，这些是 `None`。我们还需要创建一个锁来管理对将在一个线程中捕获和处理的图像的线程安全访问，然后将其绘制到屏幕上的另一个线程。相关的声明如下：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we create a `SimpleBlobDetector_Params` object and a `SimpleBlobDetector`
    object based on the arguments passed to the app''s initializer, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个 `SimpleBlobDetector_Params` 对象和一个基于传递给应用程序初始化器的参数的 `SimpleBlobDetector`
    对象，如下所示：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we specify the style of the app''s window and we initialize the following
    base class, `wx.Frame`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定应用程序窗口的样式并初始化以下基类，`wx.Frame`：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now need to bind the *Esc* key to a callback that closes the app, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将 *Esc* 键绑定到关闭应用程序的回调，如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s create the GUI elements, including the bitmap, the text field for
    the reference distance, radio buttons for the unit (`meters` or `feet`), and the
    Calibrate button. We also need to bind callbacks for various input events, as
    shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建GUI元素，包括位图、参考距离的文本字段、单位（`meters`或`feet`）的单选按钮和校准按钮。我们还需要绑定各种输入事件的回调，如下所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need to ensure that the proper radio buttons start in the selected state,
    depending on the configuration data that we deserialized earlier, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保适当的单选按钮以选中状态开始，这取决于我们之前反序列化的配置数据，如下所示：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we stack the radio buttons vertically using a `BoxSizer`, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`BoxSizer`垂直堆叠单选按钮，如下所示：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then line up all of our controls horizontally, again using a `BoxSizer`,
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将所有控件水平排列，再次使用`BoxSizer`，如下所示：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To finish our layout, we place the controls below the image, as shown in the
    following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的布局，我们将控件放置在图像下方，如下所示：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The last thing we do in the initializer is start a background thread to capture
    and process images from the camera using the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器的最后，我们启动一个后台线程，使用以下代码从摄像头捕获和处理图像：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When closing the app, we first ensure that the capture thread terminates, just
    as we did for the `InteractiveRecognizer` in [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml),
    *Training a Smart Alarm to Recognize the Villain and His Cat*. We also use `pickle`
    or `cPickle` to serialize the reference measurements and preferred unit (`meters`
    or `feet`) to a file. The implementation of the relevant callback is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当关闭应用程序时，我们首先确保捕获线程终止，就像我们在[第3章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)的《训练一个智能警报器来识别恶棍和他的猫》中对`InteractiveRecognizer`所做的那样。我们还使用`pickle`或`cPickle`将参考测量值和首选单位（`meters`或`feet`）序列化到文件中。相关回调的实现如下：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The callback associated with the *Esc* button just closes the app, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与*Esc*按钮关联的回调只是关闭应用程序，如下所示：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The video panel''s erase and paint events are bound to callbacks, `_onVideoPanelEraseBackground`
    and`_onVideoPanelPaint`, which have the same implementations as `InteractiveRecognizer` in
    [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml), *Training a Smart Alarm
    to Recognize the Villain and His Cat*, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 视频面板的擦除和绘制事件绑定到回调`_onVideoPanelEraseBackground`和`_onVideoPanelPaint`，它们的实现与[第3章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)中的`InteractiveRecognizer`相同，如下所示：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When either of the radio buttons are selected, we need to record the newly
    selected unit of measurement, as seen in the following two callback methods:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择任一单选按钮时，我们需要记录新选中的测量单位，如下两个回调方法所示：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Whenever a new character is entered in the text field, we need to call a helper
    method to validate the text as potential input, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在文本字段中输入新字符时，我们需要调用一个辅助方法来验证文本作为潜在输入，如下所示：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When the Calibrate button is clicked, we parse the measurement from the text
    field, clear the text field, convert the measurement into `meters` if necessary,
    and store it. The button''s callback is implemented as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击校准按钮时，我们解析文本字段中的测量值，清除文本字段，如果需要，将测量值转换为`meters`，并存储它。按钮的回调实现如下：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As in [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml), *Training a
    Smart Alarm to Recognize the Villain and His Cat*, the background thread runs
    a loop, which includes capturing an image, calling a helper method to process
    the image, and then handing the image to another thread for display. Optionally,
    the image may be mirrored (flipped horizontally) before being displayed. The loop''s
    implementation is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[第3章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)中所述的《训练一个智能警报器来识别恶棍和他的猫》，后台线程运行一个循环，该循环包括捕获图像、调用辅助方法处理图像，然后将图像交给另一个线程进行显示。可选地，在显示之前，图像可能被镜像（水平翻转）。循环的实现如下：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The helper method for processing the image is quite long, so let''s look at
    it in several chunks. First, we detect blobs in a gray version of the image and
    then initialize a dictionary to sort the blobs by color, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 处理图像的辅助方法相当长，所以让我们分几个部分来看。首先，我们在图像的灰度版本中检测块，然后初始化一个字典来按颜色排序块，如下所示：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For each blob, we crop out a square region that is likely to include a white
    circle of light, plus some more saturated pixels around the edge, as shown in
    the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个块，我们裁剪出一个可能包含白色光圈和一些边缘饱和像素的方形区域，如下所示：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we find the average hue and saturation of the region and, using those
    values, we classify the blob as one of the colors we defined at the top of this
    module, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们找到该区域的平均色调和饱和度，并使用这些值将块分类为我们模块顶部定义的颜色之一，如下所示：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Depending on your camera's color rendition, you may need to tweak some of the
    hue and saturation thresholds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的摄像机的色彩表现，你可能需要调整一些色调和饱和度阈值。
- en: Note that our color-matching logic is based on perceptual (subjective) similarity
    and not on the geometric distance in any color model, such as RGB, HSV, or HSL.
    Perceptually, a *green* light could be emerald green (geometrically close to cyan),
    neon green, or even spring green (geometrically close to yellow), but most people
    would never mistake a spring green light for an *amber* light, nor a yellowish-orange
    light for a *red* light. Within the reddish and yellowish ranges, most people
    perceive more abrupt distinctions between colors.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的颜色匹配逻辑基于感知（主观）相似性，而不是任何颜色模型（如RGB、HSV或HSL）中的几何距离。从感知上来说，一束*绿色*光可能是翡翠绿（在几何上接近青色），霓虹绿，甚至是春绿色（在几何上接近黄色），但大多数人永远不会把春绿色光误认为是*琥珀色*光，也不会把黄橙色光误认为是*红色*光。在红色和黄色的范围内，大多数人感知到颜色之间的区别更为明显。
- en: 'Finally, after classifying all blobs, we call a helper method that handles
    the classification results and a helper method that may enable or disable the
    Calibrate button, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在分类完所有块之后，我们调用一个处理分类结果的辅助方法，以及一个可能启用或禁用校准按钮的辅助方法，如下所示：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Based on the color classification results, we want to highlight the blobs in
    certain colors, draw lines that connect pairs of like-colored blobs (if any),
    and display a message about the estimated distance to the first such pair of blobs.
    We use the BGR color values and human-readable color names that we defined at
    the top of this module. The relevant code is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据颜色分类结果，我们想要突出显示某些颜色的块，绘制连接相同颜色块的线条（如果有），并显示关于估计距离的第一对这样的块的消息。我们使用在模块顶部定义的BGR颜色值和可读的颜色名称。相关代码如下：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, let''s look at the helper method that enables or disables the Calibrate
    button. The button should be enabled only when a pixel distance between two lights
    is being measured and a number (the real distance between the lights and camera)
    is in the text field. The following code illustrates the tests for these conditions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看启用或禁用校准按钮的辅助方法。按钮只有在测量两个灯之间的像素距离并且文本字段中有一个数字（灯和相机之间的实际距离）时才应该启用。以下代码展示了这些条件的测试：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The helper method that shows the instructional message is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 显示说明信息的辅助方法如下：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The helper method that shows the estimated distance in either `meters` or `feet` is
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 显示估计距离为`米`或`英尺`的辅助方法如下：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the message is cleared, we need to leave an endline character so that
    the label still has the same height as when it is populated, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消息被清除，我们需要留下一个换行符，这样标签的高度仍然和它被填充时一样，如下所示：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Showing a message simply entails changing the text of the `StaticText` object,
    as seen in the following helper method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 显示信息只是简单地改变`StaticText`对象的文本，如下面的辅助方法所示：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The class is complete. Now, we just need the following `main` function (similar
    to our `main` functions for previous wxPython apps) to specify a file path for
    serialization and deserialization and to launch the app, as shown in the following
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类已经完成。现在，我们只需要以下`main`函数（类似于我们之前wxPython应用的`main`函数），指定一个用于序列化和反序列化的文件路径，并启动应用，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There we have it! That's the whole implementation of `The Living Headlights`
    app! This project's code is short, but it does include some unusual requirements
    for setup and testing. Let's turn to these tasks now.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这就是“活车灯”应用的全部实现！这个项目的代码很短，但它确实包括一些设置和测试的非常规要求。现在让我们转向这些任务。
- en: Testing The Living Headlights app at home
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在家中测试“活车灯”应用
- en: Do not run out onto the highway at night to point your laptop's webcam into
    the headlights! We can devise more convenient and safer ways to test `The Living
    Headlights`, even if you don't own a car or don't drive.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在夜间跑到高速公路上，把你的笔记本电脑的摄像头指向车灯！我们可以设计更方便、更安全的测试“活车灯”的方法，即使你没有车或者不驾驶。
- en: 'A pair of LED flashlights is a good proxy for a pair of headlights. A flashlight
    with many LEDs (for example, 19) is preferable because it creates a denser circle
    of light that is more likely to be detected as exactly one blob. To ensure that
    the distance between the two flashlights remains constant, we can attach them
    to a rigid object, such as a board, using brackets, clamps, or tape. My father
    Bob Howse is great at constructing such things. Take a look at my flashlight holder
    in the following image:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一对LED手电筒可以作为一对前照灯的良好替代品。具有许多LED（例如，19个）的手电筒更可取，因为它产生一个更密集的光圈，更可能被检测为一个单独的物体。为了确保两个手电筒之间的距离保持恒定，我们可以使用夹具、夹具或胶带将它们固定在刚性物体上，如一块板。我的父亲鲍勃·豪斯擅长构建这类东西。请看以下图像中的我的手电筒支架：
- en: '![](img/70d2121d-7996-49c6-8aad-302ceee5bcd8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70d2121d-7996-49c6-8aad-302ceee5bcd8.png)'
- en: 'The following image shows a frontal view of the flashlight holder, including
    a decorative grill:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了手电筒支架的前视图，包括装饰栅格：
- en: '![](img/6b2646bc-1b73-4a68-8467-a514a82bf34d.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b2646bc-1b73-4a68-8467-a514a82bf34d.png)'
- en: 'Set up the lights in front of the webcam (parallel to the webcam''s lens),
    run the app, and make sure that the lights are being detected. Then, using a tape
    measure, find the distance between the webcam and the center point between the
    front of the lights, as seen in the following image:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将灯光设置在摄像头前面（与摄像头的镜头平行），运行应用程序，确保灯光被检测到。然后，使用卷尺，找到摄像头与灯光前部中心点之间的距离，如图所示：
- en: '![](img/fecc212d-5b48-4ead-8f7d-06d1cd67abaa.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fecc212d-5b48-4ead-8f7d-06d1cd67abaa.png)'
- en: Type the distance into the text field and click Calibrate. Then, move the lights
    either closer to or further away from the camera, ensuring they are parallel to
    the camera's lens. Check that the app is updating the distance estimate appropriately.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将距离输入文本字段，然后点击校准。然后，将灯光移近或移远摄像头，确保它们与摄像头的镜头平行。检查应用程序是否适当地更新了距离估计。
- en: 'To simulate colored car lights, place a thick piece of colored glass in front
    of the flashlights, as close to the light source as possible. Stained glass (the
    kind used in church windows) works well, and you may find it in craft supply stores.
    Colored lens filters for photography or videography should also work. They are
    widely available, new or used, from camera stores. Colored acetate or other thin
    materials do not work as well, as the LED lights are very intense. The following
    image shows an existing light setup using an orange or amber-colored stained glass
    filter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟彩色汽车灯光，请将一块厚厚的彩色玻璃放置在手电筒前面，尽可能靠近光源。彩色玻璃（用于教堂窗户的那种）效果很好，你可以在工艺品商店找到。摄影或视频摄影的彩色镜头过滤器也应该有效。它们在相机商店中广泛可用，无论是新的还是二手的。彩色醋酸酯或其他薄材料效果不佳，因为LED灯光非常强烈。以下图像显示了使用橙色或琥珀色彩色玻璃滤镜的现有照明设置：
- en: '![](img/9d2840c7-1398-4453-adfb-2fcd5ec5c20f.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d2840c7-1398-4453-adfb-2fcd5ec5c20f.png)'
- en: 'The following screenshot shows the app''s analysis of the lighting setup:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了应用程序对照明设置的分析：
- en: '![](img/416095d9-f470-4c71-b227-184acd6ed462.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/416095d9-f470-4c71-b227-184acd6ed462.png)'
- en: Check that the app is reporting the appropriate color for the detected lights.
    Depending on your particular camera's color rendition, you may find that you'll
    need to adjust some of the hue and saturation thresholds in the `detectAndEstimateDistance`
    method. You might also want to experiment with adjusting the attributes of the `SimpleBlobDetector_Params`
    object in the initializer to see their effects on the detection of lights and
    other blobs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 确认应用程序报告了检测到的灯光的正确颜色。根据你特定摄像机的色彩表现，你可能需要调整`detectAndEstimateDistance`方法中的某些色调和饱和度阈值。你也可能想通过调整初始化器中`SimpleBlobDetector_Params`对象的属性来实验它们对灯光和其他物体检测的影响。
- en: Once we are satisfied that the app is working well with our homemade apparatus,
    we can step up to a more realistic level of testing!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确信应用程序与我们的自制装置配合良好，我们就可以进行更现实的测试水平！
- en: Testing The Living Headlights app in a car
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在汽车中测试“活前照灯”应用程序
- en: 'When choosing the hardware for a car-based setup, it''s important to consider
    the following questions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择基于汽车的硬件时，考虑以下问题非常重要：
- en: Can the car's outlets power the hardware?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车的插座能否为硬件供电？
- en: Can the hardware fit conveniently in the car?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件能否方便地安装在车内？
- en: 'A Raspberry Pi draws power from a 5V supply through its micro USB port. We
    can satisfy this power requirement by plugging a USB adapter into the car''s cigarette
    lighter and then connecting it to the Pi through a USB to micro USB cable. Make
    sure that your adapter''s voltage is exactly 5V and that its amperage is equal
    to or greater than the recommended amperage for your Pi model. For example, the
    official documentation at [https://www.raspberrypi.org/documentation/faqs/](https://www.raspberrypi.org/documentation/faqs/)
    recommends a 5V, 2.5A power supply for Raspberry Pi 3 Model B. The following image
    shows a setup using a first-generation Raspberry Pi Model A:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派通过其微型USB端口从5V电源供电。我们可以通过将USB适配器插入汽车的点烟器并使用USB到微型USB线将其连接到树莓派来满足这一电源需求。请确保您的适配器电压正好为5V，并且其电流等于或大于您树莓派型号推荐的电流。例如，官方文档在[https://www.raspberrypi.org/documentation/faqs/](https://www.raspberrypi.org/documentation/faqs/)中推荐为Raspberry
    Pi 3 Model B提供5V、2.5A的电源。以下图片展示了使用第一代树莓派Model A的设置：
- en: '![](img/e7383f4d-d5de-431f-90d5-b31e8fb30f74.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7383f4d-d5de-431f-90d5-b31e8fb30f74.png)'
- en: Normally, the cigarette lighter is a 12V power source, so it can power a variety
    of devices through an adapter. You could even power a chain of devices, and the
    Pi need not be the first device in the chain. Later in this section, we will discuss
    the example of a Pi drawing power from a USB port on a SunFounder LCD display,
    which in turn draws power from a cigarette lighter receptacle through an adapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，点烟器是一个12V电源，因此可以通过适配器为各种设备供电。甚至可以为一个设备链供电，而树莓派不必是链中的第一个设备。在本节稍后，我们将讨论一个树莓派从SunFounder
    LCD显示屏的USB端口取电的例子，该显示屏通过适配器从点烟器插座取电。
- en: Standard USB peripherals, such as a webcam, mouse, and keyboard, can draw enough
    power from Pi's USB ports. Although the Pi only has two USB ports, we can use
    a USB splitter to power to a webcam, mouse, and keyboard simultaneously. Alternatively,
    some keyboards have a built-in touchpad that can be used as a mouse. Another option
    is to simply make do with only using two peripherals at a time and swapping one
    of them for the third peripheral as needed. In any case, once our app has been
    started and calibrated (and once we are driving!), we no longer need the keyboard
    or mouse input.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 标准USB外设，如摄像头、鼠标和键盘，可以从树莓派的USB端口获取足够的电源。尽管树莓派只有两个USB端口，但我们可以使用USB分线器同时为摄像头、鼠标和键盘供电。或者，一些键盘内置触摸板可以用作鼠标。另一个选择是简单地一次只使用两个外设，并在需要时交换其中一个外设以使用第三个外设。无论如何，一旦我们的应用程序启动并校准（以及一旦我们开始驾驶！），我们就不再需要键盘或鼠标输入。
- en: 'The webcam should sit against the inside of the car''s rear window. The webcam''s
    lens should be as close to the window as possible to reduce the visibility of
    grime, moisture, and reflections (for example, the reflection of the webcam''s
    *on* light). If the Raspberry Pi lies just behind the car''s front seats, the
    webcam cable should be able to reach the back window, while the power cable should
    still reach the USB adapter in the cigarette lighter receptacle. If not, use a
    longer USB to micro USB cable for the power and, if necessary, position the Pi
    farther back in the car. Alternatively, use a webcam with a longer cable. The
    following image shows the suggested positioning of the Pi:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头应放置在汽车后窗的内侧。摄像头的镜头应尽可能靠近窗户，以减少污垢、湿气和反射（例如，摄像头*开启*灯的反射）的可见性。如果树莓派位于汽车前排座椅的后面，摄像头线应该能够到达后窗，而电源线仍然能够到达点烟器插座中的USB适配器。如果不能，请使用更长的USB到微型USB线供电，如果需要，将树莓派放置在车内更靠后的位置。或者，使用带有更长电缆的摄像头。以下图片显示了树莓派的建议位置：
- en: '![](img/00e2cfac-3746-40bc-9453-ddc9e96bc302.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00e2cfac-3746-40bc-9453-ddc9e96bc302.png)'
- en: 'Similarly, the following image shows the suggested positioning of the camera:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下图片显示了摄像头的建议位置：
- en: '![](img/3639c08b-2644-4899-baf9-d0e412b24505.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3639c08b-2644-4899-baf9-d0e412b24505.png)'
- en: Now, it's time for the hard part—the display. For video output, the Pi supports
    HDMI (as found in new TVs and many new monitors). Some older Pi models also support
    composite RCA (as found in old TVs). For other common connectors, we can use an
    adapter, such as HDMI to DVI or HDMI to VGA. The Pi also has limited support (through
    third-party kernel extensions) for video output through DSI or SPI (as found in
    cellphone displays and prototyping kits).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行困难的部分了——显示器。对于视频输出，Pi支持HDMI（如新电视和许多新显示器中所示）。一些较老的Pi型号也支持复合RCA（如旧电视中所示）。对于其他常见连接器，我们可以使用适配器，例如HDMI到DVI或HDMI到VGA。Pi还有限制性的支持（通过第三方内核扩展）通过DSI或SPI进行视频输出（如手机显示屏和原型套件中所示）。
- en: Do not use a CRT television or monitor in a vehicle or in any environment where
    it is liable to be bumped. A CRT may implode if the glass is damaged. Instead,
    use an LCD television or monitor.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在车辆或任何可能被撞击的环境中使用CRT电视或显示器。如果玻璃损坏，CRT可能会爆炸。相反，请使用LCD电视或显示器。
- en: A small display is desirable because it can be more conveniently mounted on
    the dashboard and it consumes less power. For example, the SunFounder Raspberry
    Pi 10.1 HDMI IPS LCD Monitor requires a 12V, 1A power source. This display includes
    a USB port that can deliver 5V, 2A of power, which satisfies the recommended power
    specs for most Pi versions, including Raspberry Pi 2 Model B, but not quite Raspberry
    Pi 3 Model B. For more information, see the product's page on the SunFounder website, [https://www.sunfounder.com/10-1-inch-hdmi-lcd.html](https://www.sunfounder.com/10-1-inch-hdmi-lcd.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 小型显示器是首选，因为它可以更方便地安装在仪表盘上，并且消耗的电量更少。例如，SunFounder Raspberry Pi 10.1 HDMI IPS
    LCD Monitor需要一个12V，1A的电源。此显示器包括一个USB端口，可以提供5V，2A的电力，这满足了大多数Pi版本（包括Raspberry Pi
    2 Model B）的推荐电源规格，但并不适用于Raspberry Pi 3 Model B。更多信息，请参阅SunFounder网站上的产品页面，[https://www.sunfounder.com/10-1-inch-hdmi-lcd.html](https://www.sunfounder.com/10-1-inch-hdmi-lcd.html)。
- en: 'Typically, though, a display needs a much higher voltage and wattage than the
    cigarette lighter can supply. Conveniently, some cars have an electrical outlet
    that resembles a wall socket, with the standard voltage for the type of socket
    but a lower maximum wattage. My car has a 110V, 150W, outlet for two-pronged North
    American plugs (NEMA 1-15P). As seen in the following image, I used an extension
    cord to convert the two-pronged connection into a three-pronged connection (NEMA
    5-15P) that my monitor cables use:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，显示器需要比点烟器能提供的电压和功率高得多。方便的是，一些汽车有一个看起来像墙插座的电源插座，具有该类型插座的标称电压，但最大功率较低。我的车有一个110V，150W的插座，用于两脚北美插头（NEMA
    1-15P）。如图所示，我使用延长线将两脚连接转换为三脚连接（NEMA 5-15P），这是我的显示器电缆所使用的：
- en: '![](img/6f690c8b-30ce-4df9-9e8a-0b4ce99aa708.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f690c8b-30ce-4df9-9e8a-0b4ce99aa708.png)'
- en: 'I tried plugging in three different monitors (one at a time, of course), with
    the following results:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试插入三个不同的显示器（当然是一个接一个），结果如下：
- en: '**HP Pavilion 25xi (25", *1920 x 1080*)**: Does not turn on. Presumably requires
    a higher wattage.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HP Pavilion 25xi (25", 1920 x 1080)**: 无法开机。可能需要更高的功率。'
- en: '**HP w2207 (22", *1680 x 1050*, 19.8 lbs)**: Does not turn on, but its weight
    and sturdy hinge make it useful as a flail to beat off hijackers—just in case
    the rocket launchers fail.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HP w2207 (22", 1680 x 1050, 19.8 lbs)**: 无法开机，但它的重量和坚固的铰链使其可以作为击退劫机的工具——以防火箭发射器失效。'
- en: '**Xplio XP22WD (22", *1440 x 900*)**: Turns on and works!'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xplio XP22WD (22", 1440 x 900)**: 开机并工作！'
- en: If you are unable to power a monitor from any of your car's outlets, an alternative
    is to use a battery block to power the monitor. Another alternative is to use
    a laptop or netbook as a substitute for the entire Pi-based system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法从汽车的任何插座为显示器供电，另一种选择是使用电池块为显示器供电。另一种选择是使用笔记本电脑或上网本作为基于Pi的整个系统的替代品。
- en: 'The XP22WD''s ports are seen in the following image. To connect the Pi, I am
    using an HDMI to DVI cable because the monitor does not have an HDMI port:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: XP22WD的端口如图所示。为了连接Pi，我正在使用HDMI到DVI电缆，因为显示器没有HDMI端口：
- en: '![](img/906fccc5-3bee-47a8-a032-4aa8cabd7b9f.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/906fccc5-3bee-47a8-a032-4aa8cabd7b9f.png)'
- en: 'Unfortunately, my monitors are too big to mount on a dashboard! However, for
    the purpose of testing the system on my driveway, placing the monitor in the passenger
    seat is fine, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我的显示器太大，无法安装在仪表盘上！然而，为了测试系统在我的车道上，将显示器放在乘客座位上是可行的，如下所示：
- en: '![](img/1b727ae1-5f32-4b70-af26-2bc582d4608c.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b727ae1-5f32-4b70-af26-2bc582d4608c.png)'
- en: Voilà! We've proved that a car can power a Pi, peripherals, and a desktop monitor!
    As soon as the car is turned on, our system boots and runs in exactly the same
    way as a Linux desktop. We can now launch `The Living Headlights` app from the
    command line, or from an IDE such as Geany. Our app's behavior on Pi should be
    identical to its behavior on a conventional desktop system, except that on Pi,
    we will experience a lower frame rate (less *frequent* frame updates) and greater
    lag (less *timely* frame updates). Raspberry Pi has relatively limited processing
    power; therefore, it will need more time to process each frame, and a greater
    number of camera frames will be dropped while the software processes an old frame.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经证明汽车可以为 Pi、外围设备和台式显示器供电！一旦汽车启动，我们的系统就会以与 Linux 桌面完全相同的方式启动和运行。现在我们可以从命令行或从
    IDE（如 Geany）启动“活车头灯”应用程序。我们的应用程序在 Pi 上的行为应该与其在传统桌面系统上的行为相同，只是在 Pi 上，我们将体验到较低的帧率（更少*频繁*的帧更新）和更大的延迟（更少*及时*的帧更新）。Raspberry
    Pi 的处理能力相对有限；因此，它需要更多的时间来处理每一帧，在软件处理旧帧的同时，会有更多的相机帧被丢弃。
- en: Once you get your app running in a car, remember to recalibrate it so that it
    estimates distances based on the size of real headlights and not the size of a
    flashlight rig! The most practical way to perform this recalibration would be
    with two parked cars. One parked car should have its headlights on, and it should
    be behind the car that contains the Pi. Measure the distance between the parked
    cars, and use this as the calibration value.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用程序在汽车上运行，记得重新校准它，以便它根据真实车头灯的大小而不是手电筒装置的大小来估计距离！执行此校准的最实用方法是与两辆停着的汽车一起进行。一辆停着的汽车应该打开车头灯，并且它应该在包含
    Pi 的汽车后面。测量两辆停着的汽车之间的距离，并使用这个值作为校准值。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter gave us the opportunity to scale down the complexity of our algorithms
    to support low-powered hardware. We also played with colorful lights, a homemade
    toy car, a puzzle of adapters, and a real car!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了将算法的复杂性降低以支持低功耗硬件的机会。我们还玩弄了五彩缤纷的灯光、一个自制的玩具车、一个适配器拼图，以及一辆真正的汽车！
- en: There is plenty of scope for extending the functionality of `The Living Headlights`.
    For example, we could take an average of multiple reference measurements or store
    different reference measurements for different colors of lights. We could analyze
    patterns of flashing, colored lights across multiple frames to judge whether the
    vehicle behind us is a police car or a road maintenance truck, or is even signaling
    to turn. We could try to detect the flash of rocket launchers, though testing
    might be problematic.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展“活车头灯”功能的空间很大。例如，我们可以对多个参考测量值取平均值，或者为不同颜色的灯光存储不同的参考测量值。我们可以分析多个帧中闪烁的灯光模式，以判断我们后面的车辆是否是警车或道路维护卡车，甚至是否在打信号转弯。我们可以尝试检测火箭发射器的闪光，尽管测试可能存在问题。
- en: The next chapter's project is not something a driver should use, though! In
    the next chapter, we are going to take a pen-and-paper sketch in one hand and
    a smartphone in the other as we turn a geometric drawing into a physics simulation!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章的项目不是驾驶员应该使用的！在下一章中，我们将一手拿笔和纸草图，另一手拿智能手机，将几何图形转换为物理模拟！
