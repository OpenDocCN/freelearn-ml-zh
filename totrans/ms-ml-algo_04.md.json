["```py\nimport numpy as np\n\ndef X1_sample(p=0.35):\n    return np.random.binomial(1, p)\n\ndef X2_sample(p=0.65):\n    return np.random.binomial(1, p)\n\ndef X3_sample(x1, x2, p1=0.75, p2=0.4):\n    if x1 == 1 and x2 == 1:\n        return np.random.binomial(1, p1)\n    else:\n        return np.random.binomial(1, p2)\n\ndef X4_sample(x3, p1=0.65, p2=0.5):\n    if x3 == 1:\n        return np.random.binomial(1, p1)\n    else:\n        return np.random.binomial(1, p2)\n```", "```py\nN = 4\nNsamples = 5000\n\nS = np.zeros((N, Nsamples))\nFsamples = {}\n\nfor t in range(Nsamples):\n    x1 = X1_sample()\n    x2 = X2_sample()\n    x3 = X3_sample(x1, x2)\n    x4 = X4_sample(x3)\n\n    sample = (x1, x2, x3, x4)\n\n    if sample in Fsamples:\n        Fsamples[sample] += 1\n    else:\n        Fsamples[sample] = 1\n```", "```py\nsamples = np.array(list(Fsamples.keys()), dtype=np.bool_)\nprobabilities = np.array(list(Fsamples.values()), dtype=np.float64) / Nsamples\n\nfor i in range(len(samples)):\n    print('P{} = {}'.format(samples[i], probabilities[i]))\n\nP[ True False  True  True] = 0.0286\nP[ True  True False  True] = 0.024\nP[ True  True  True False] = 0.06\nP[False False False False] = 0.0708\nP[ True False  True False] = 0.0166\nP[False  True  True  True] = 0.1006\nP[False False  True  True] = 0.054\n...\n```", "```py\np4t = np.argwhere(samples[:, 3]==True)\nprint(np.sum(probabilities[p4t]))\n\n0.5622\n```", "```py\nimport numpy as np\n\ndef prior(x):\n    return 0.1 * np.exp(-0.1 * x)\n\ndef likelihood(x):\n    a = np.sqrt(0.2 / (2.0 * np.pi * np.power(x, 3)))\n    b = - (0.2 * np.power(x - 1.0, 2)) / (2.0 * x)\n    return a * np.exp(b)\n\ndef g(x):\n    return likelihood(x) * prior(x)\n\ndef q(xp):\n    return np.random.normal(xp)\n```", "```py\nnb_iterations = 100000\nx = 1.0\nsamples = []\n\nfor i in range(nb_iterations):\n    xc = q(x)\n\n    alpha = g(xc) / g(x)\n    if np.isnan(alpha):\n        continue\n\n    if alpha >= 1:\n        samples.append(xc)\n        x = xc\n    else:\n        if np.random.uniform(0.0, 1.0) < alpha:\n            samples.append(xc)\n            x = xc\n```", "```py\nhist, _ = np.histogram(samples, bins=100)\nhist_p = hist / len(samples)\n```", "```py\nimport pymc3 as pm\n\n model = pm.Model()\n```", "```py\nimport pymc3.distributions.continuous as pmc\nimport pymc3.distributions.discrete as pmd\nimport pymc3.math as pmm\n\nwith model:\n    passenger_onboarding = pmc.Wald('Passenger Onboarding', mu=0.5, lam=0.2)\n    refueling = pmc.Wald('Refueling', mu=0.25, lam=0.5)\n    departure_traffic_delay = pmc.Wald('Departure Traffic Delay', mu=0.1, lam=0.2)\n\n    departure_time = pm.Deterministic('Departure Time', \n                                      12.0 + departure_traffic_delay + \n                                      pmm.switch(passenger_onboarding >= refueling, \n                                                 passenger_onboarding, \n                                                 refueling))\n\n    rough_weather = pmd.Bernoulli('Rough Weather', p=0.35)\n\n    flight_time = pmc.Exponential('Flight Time', lam=0.5 - (0.1 * rough_weather))\n    arrival_traffic_delay = pmc.Wald('Arrival Traffic Delay', mu=0.1, lam=0.2)\n\n    arrival_time = pm.Deterministic('Arrival time', \n                                    departure_time + \n                                    flight_time + \n                                    arrival_traffic_delay)\n```", "```py\nnb_samples = 500\n\nwith model:\n    samples = pm.sample(draws=nb_samples, random_seed=1000)\n```", "```py\npm.summary(samples)\n\n...\n\nArrival time:\n\n  Mean             SD               MC Error         95% HPD interval\n  -------------------------------------------------------------------\n\n  15.174           2.670            0.102            [12.174, 20.484]\n\n  Posterior quantiles:\n  2.5            25             50             75             97.5\n  |--------------|==============|==============|--------------|\n\n  12.492         13.459         14.419         16.073         22.557\n```", "```py\nimport numpy as np\n\nobservations = np.array([[0], [1], [1], [0], [1], [1], [1], [0], [1], \n                         [0], [0], [0], [1], [0], [1], [1], [0], [1], \n                         [0], [0], [1], [0], [1], [0], [0], [0], [1], \n                         [0], [1], [0], [1], [0], [0], [0], [0], [0]], dtype=np.int32)\n```", "```py\nfrom hmmlearn import hmm\n\nhmm_model = hmm.MultinomialHMM(n_components=2, n_iter=100, random_state=1000)\nhmm_model.fit(observations)\n\nprint(hmm_model.monitor_.converged)\nTrue\n```", "```py\nprint(hmm_model.transmat_)\n\n[[ 0.0025384   0.9974616 ]\n [ 0.69191905  0.30808095]]\n```", "```py\nsequence = np.array([[1], [1], [1], [0], [1], [1], [1], [0], [1], \n                     [0], [1], [0], [1], [0], [1], [1], [0], [1], \n                     [1], [0], [1], [0], [1], [0], [1], [0], [1], \n                     [1], [1], [0], [0], [1], [1], [0], [1], [1]], dtype=np.int32)\n\nlp, hs = hmm_model.decode(sequence)\n\nprint(hs)\n[0 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 0 1 1 0 1 0 1 0 1 0 1 1 1 1 0 1 1 0 1 1]\n\nprint(lp)\n-30.489992468878615\n```", "```py\npp = hmm_model.predict_proba(sequence)\nprint(pp)\n\n[[  1.00000000e+00   5.05351938e-19]\n [  3.76687160e-05   9.99962331e-01]\n [  1.31242036e-03   9.98687580e-01]\n [  9.60384736e-01   3.96152641e-02]\n [  1.27156616e-03   9.98728434e-01]\n [  3.21353749e-02   9.67864625e-01]\n [  1.23481962e-03   9.98765180e-01]\n\n...\n```"]