- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying, Testing, and Operating an Intelligent MSA Enterprise System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we talked in detail about microservices, monolithic
    architecture, the pros and cons of each architecture, how to transition into MSA,
    and how to make the MSA system smarter using AI services. We also discussed, in
    [*Chapter 11*](B18934_11.xhtml#_idTextAnchor132), some of the best practices for
    deploying the MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: In this final chapter, we will integrate all the topics and concepts covered
    throughout the book to understand how we can apply what we have learned through
    hands-on and practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the details, we need to understand what existing system
    we have in place first.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, every organization is different and has different deployment needs,
    criteria, and dependencies. Some organizations will deploy in a greenfield, and
    others in a brownfield. In order to walk you through detailed practical examples
    and steps for deploying, testing, and operating an intelligent MSA system, we
    will assume a brownfield environment with an existing monolithic architecture
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will sometimes use our ABC-Monolith as an example of the existing system
    to illustrate the concepts covered in the chapter. In this chapter, we will cover,
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overcoming deployment dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the MSA system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and tuning the MSA system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The post-deployment review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overcoming system dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before deploying the ABC-Intelligent-MSA system we built earlier in [*Chapter
    10*](B18934_10.xhtml#_idTextAnchor115), it is important to first decide what our
    deployment strategy should be. Based on the requirements, cost, complexity, and
    pros and cons of the deployment strategies we discussed in [*Chapter 11*](B18934_11.xhtml#_idTextAnchor132),
    we believe the best deployment strategy for our ABC system would be a mix between
    the ramped deployment and canary deployment strategies.
  prefs: []
  type: TYPE_NORMAL
- en: This deployment strategy will allow us to keep the ABC-Monolith system online
    and serve users uninterrupted while we deploy the new ABC-Intelligent-MSA system.
    We will gradually replace older components in ABC-Monolith with the corresponding
    microservices in the ABC-Intelligent-MSA system. This can be accomplished by routing
    traffic from the older components to those ABC-Intelligent-MSA system microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Although this trickle approach has lower cost, lower complexity, and lower risk
    than other deployment approaches, we still need to carefully study the incompatibilities,
    dependencies, and the proper integration between older and newer components.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will need to evaluate which of our infrastructure and existing
    system ABC-Monolith’s components can be reused in the new architecture, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable ABC-Monolith components and dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot think of a specific ABC-Monolith code base component that can be reused
    as is without modification. All of the ABC-Monolith components will have to be
    either rewritten from scratch or modified to different degrees to be compatible
    with the ABC-Intelligent-MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the ABC-Monolith and existing infrastructure components that we know
    can be reused are the business logic itself, server infrastructure, operating
    systems, virtualization infrastructure, data storage, network infrastructure,
    existing monitoring, and network management tools, and some of the software and
    database licensing. Nevertheless, even these components may need to be updated
    or upgraded in order to perform the functions of the new system.
  prefs: []
  type: TYPE_NORMAL
- en: In our system installation, command line, and code examples listed in earlier
    chapters, we had the most updated Ubuntu, Python, and database versions. In a
    real-life situation, however, that may not be the case; we will likely have the
    monolithic application running in an older operating system and have an older
    Python and/or database version.
  prefs: []
  type: TYPE_NORMAL
- en: These situations may produce some incompatibilities between the older components
    and the newer ones. An older Python version, for example, may have some deprecated
    functions that are no longer valid with the new MSA code base, and hence, will
    require some updates or upgrades to the existing system. Furthermore, the potentially
    different technology stack may also produce more dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In order to minimize these dependencies, we would rather deploy the new system
    components on a separate server or virtual infrastructure with their own environment,
    including their own data storage and using their own technology stack. The new
    environment will have a container engine that will carry all of our ABC-Intelligent-MSA
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that each system is different, and the specific reusable
    and non-reusable components will vary depending on the existing monolithic system.
    A thorough analysis and evaluation of the existing system’s components is necessary
    to determine what can and cannot be reused when migrating to a microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating ABC-Intelligent-MSA deployment risks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the risks discussed in [*Chapter 11*](B18934_11.xhtml#_idTextAnchor132)
    are relevant to our scenario. However, we still need to determine which CAPEX
    risks are applicable, examine the risks related to deployment time, potential
    service disruption, and OPEX, and take specific actions to mitigate these risks.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using containers on top of virtualized infrastructure in our implementation,
    CAPEX risks are significantly reduced. As long as the existing infrastructure
    has the storage and workload capacity to absorb the new ABC system, we are safe.
    If additional infrastructure resources are needed, we may then need to look into
    some capacity planning and upgrades to be able to run the system during and after
    the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting a trickle migration approach gives us the chance to catch up quickly
    with any learning curve involved with the new technologies being deployed, which,
    in return, helps mitigate system failure risks and deployment delays.
  prefs: []
  type: TYPE_NORMAL
- en: The ramped deployment strategy also helps mitigate other OPEX risks. As we will
    discuss in this chapter, during the deployment, we can test and monitor the performance
    of the newly deployed components, identify and resolve any issues, and make necessary
    adjustments before redirecting all traffic to these new components.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of mitigating OPEX risks is to establish a robust change management
    process by establishing a structured and transparent process for managing changes.
    This includes creating clear guidelines for how changes will be proposed, evaluated,
    approved, and implemented, as well as communicating the changes to relevant stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of the change management process is the rollback plan. The rollback plan
    is essential to bringing back the system to an operational state if a specific
    technical change is unsuccessful. The following are the steps we need to consider
    to build a successful rollback plan:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify some checkpoints for the change where a rollback may be needed. In
    our example, and should the ACL be used, the ACL would be deployed prior to switching
    any traffic to the new microservice. During the change (and right after switching
    some test traffic to the ABC-Intelligent-MSA), a few good checkpoint examples
    would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the payment verification communication between ABC-Monolith and the
    ACL
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing how the ACL processes the requests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the communication between the ACL and the ABC-Intelligent-MSA system
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing how the overall end-to-end requests are handled and whether they are
    processed as expected
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Common Docker and Linux commands to test and troubleshoot the communication
    between the ACL, the monolith, and the MSA include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`curl`, to simulate an API call to the ACL or a specific microservice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netstat`, to check whether a specific service is actively listening to connections,
    what the listening port is, and whether there are any active connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker inspect`, to return detailed JSON information about a specific microservice’s
    configuration, state, and network settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker log`, to view the logs of a running container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a plan for reversing the change at each of the preceding specified checkpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever possible, test the rollback plan in a test or staging environment to
    ensure it is workable and complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Know the time by which the rollback plan needs to be completely executed at
    each of the specified checkpoints, and allocate a reasonable amount of time in
    your change for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor the system throughout the change and make adjustments as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a post-mortem after the change, especially in case of a change failure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In case the rollback plan is executed, the team will then need to include in
    the post-mortem the reasons for the change failure, and how effective the rollback
    plan was. They need to accordingly make the necessary adjustments to the deployment
    and rollback plan before scheduling another change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By this point, we should have a clear understanding of the deployment dependencies
    and risks and be able to determine methods for mitigating them. We are ready now
    to create a deployment plan and execute it in a manner that minimizes downtime
    and maintains business continuity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build the ABC-Intelligent-MSA system’s deployment
    plan in the presence of the running ABC-Monolith system.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the MSA system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B18934_09.xhtml#_idTextAnchor102) and [*Chapter 10*](B18934_10.xhtml#_idTextAnchor115),
    we discussed in detail how to install Docker, containers, and other components
    for our ABC-Intelligent-MSA system. This installation was mostly done in a lab
    environment with no specific regard to any existing system in the environment.
    We were basically just simulating a real-life development or staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus rather on how we can take the ABC-Intelligent-MSA
    system we built, and gradually migrate it into a brownfield production environment
    where we have the ABC-Monolith system already running in production. The goal
    is to ramp up the ABC-Intelligent-MSA system’s operations until the system is
    able to carry the entire existing traffic, then completely phase out the old ABC-Monolith.
    Everything should be done with minimal operational interruptions.
  prefs: []
  type: TYPE_NORMAL
- en: The current status by now is that we still have ABC-Monolith running in production,
    and the ABC-Intelligent-MSA running in the staging environment. The following
    are detailed broken-down deployment plans with their execution steps.
  prefs: []
  type: TYPE_NORMAL
- en: The anti-corruption layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both our ABC-Monolith and ABC-Intelligent-MSA systems use the same type of RESTful
    APIs and the same JSON data formats. Moreover, our demo system is not complicated
    enough to justify an ACL. We, therefore, won’t be needing an ACL in our migration.
    However, we developed an ACL in our demo just in case you decide to try it out.
  prefs: []
  type: TYPE_NORMAL
- en: In case you are interested in trying the ACL, the first step you would need
    to do is to get the ACL up and running. The ACL will act as a buffer and handle
    the communication between the ABC-Monolith and the ABC-Intelligent-MSA systems.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Deploying with the ACL](img/B18934_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Deploying with the ACL'
  prefs: []
  type: TYPE_NORMAL
- en: ACLs are usually a specific custom-built code for the organization’s specific
    situation, the old system, and the new MSA system. We built the `abc_acl` ACL
    for our ABC system. The `abc_acl` code can be found in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: It would make much more sense to deploy all the new components, including `abc_acl`,
    on a separate host or virtual workload. In our lab examples, however, and for
    simplicity, we are building the new system’s containers on the same host that’s
    running the ABC-Monolith.
  prefs: []
  type: TYPE_NORMAL
- en: We built the **Facade**, **Adaptor**, and **Translator** components all together
    as part of the ACL in one microservice. The Facade is created to interface with
    the ABC-Monolith, the Adaptor to interface with the ABC-Intelligent-MSA, and the
    translator for input/output data format mappings. Since we are using the same
    data formats in both the monolith and the MSA systems, the translator code is
    not doing any processing and is just used as a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set up and start the `abc_acl` microservice the same way we did with
    other microservices in [*Chapter 9*](B18934_09.xhtml#_idTextAnchor102) and [*Chapter
    10*](B18934_10.xhtml#_idTextAnchor115), using the `docker build` command to build
    the `abc_acl_image` image from the Dockerfile, then using the `docker run` command
    to create the `abc_acl_container` container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the image is successfully created, use the following command to run the
    container, and start listening to port TCP/8020 on the host’s IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now the ACL is running, it is time to test it before routing any traffic to
    it. We can do that using the shell `curl` command as we did in the previous chapters,
    or we can use some of the ACL built-in API tools created to verify the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `curl` command issued on the host machine to ensure that
    the ACL is running successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of another way to test the ACL – more specifically,
    to test the communication between the ACL and both ABC-Monolith and ABC-Intelligent-MSA
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first `curl` command ensures that the ACL is listening to API calls from
    both ABC-Monolith and ABC-Intelligent-MSA, while the second `curl` command ensures
    that the ACL can successfully communicate with both systems.
  prefs: []
  type: TYPE_NORMAL
- en: The ACL operation is now verified; in the next subsection, we will start migrating
    the MSA services from the staging (or lab) environment to the actual production
    environment running the old monolithic system.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the MSA system’s services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the ACL now up and running and tested successfully, we are ready to start
    switching specific traffic to specific parts of the ABC-Intelligent-MSA. We will,
    however, use direct interaction between both the monolith and the MSA system since
    the ACL is not really needed in our demo example.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, depending on the existing monolith structure, design, and
    system’s code base, this process could either be very straightforward or as complicated
    as can be. Our deployment strategy requires some code changes in the monolith
    system to be able to route some parts of the traffic to the new MSA.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, we may very well choose, in some systems, to have the MSA completely
    tested in a staging environment, then put the MSA on an LA period where partial
    production traffic is passing through the system for deeper testing. Then, once
    comfortable with the new MSA system’s performance, we can just start forwarding
    the entire production traffic, and finally, shut down the old monolith.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.2* shows a high-level view of the migration before and after status.
    During the migration, we will route a specific function of ABC-Monolith to one
    microservice in ABC-Intelligent-MSA. That microservice should be able to replace
    the corresponding function in the ABC-Monolith system. After we test the operation
    of that part of the migration, we then move traffic of another monolithic function,
    then another, and so on, until we end up migrating all of the ABC-Monolith functions
    to the ABC-Intelligent-MSA system.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: A high-level view of where we are and where to be](img/B18934_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: A high-level view of where we are and where to be'
  prefs: []
  type: TYPE_NORMAL
- en: We can start with a simple microservice such as `abc_msa_notify_user_container`).
    We can route the traffic destined to the `notify_user()` function in the ABC-Monolith
    by replacing the function’s code with an API call to `abc_msa_notify_user_container`.
    All user traffic will still flow through the ABC-Monolith, but all user notifications
    will be processed through the ABC-Intelligent-MSA.
  prefs: []
  type: TYPE_NORMAL
- en: In the same manner, the `abc_msa_customer_management_container`) should replace
    the `register_customer()` function from the ABC-Monolith, and `place_order()`
    and `order_status_update()` functions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As the system stabilizes, we gradually migrate to other MSA services. That migration
    cycle is shown in *Figure 12**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: By following the migration cycle, eventually, all of the ABC-Monolith functions
    will be replaced with microservices in the ABC-Intelligent-MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: The microservices integration testing and tuning cycle](img/B18934_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The microservices integration testing and tuning cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.4* shows a snapshot of the system status during the migration
    process. In the figure, we have the **Notification Management**, **Customer Management**,
    and **Order Management** microservices successfully migrated, but not any other
    microservice yet.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: A system snapshot during the migration process](img/B18934_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: A system snapshot during the migration process'
  prefs: []
  type: TYPE_NORMAL
- en: Monitor the system closely during the monolithic function migration, and use
    the rollback plan if necessary. Once the last ABC-Monolith function is migrated
    to the new system, we will need to carefully run an end-to-end test on the ABC-Intelligent-MSA
    system to ensure the system is running properly and independent of the ABC-Monolith.
  prefs: []
  type: TYPE_NORMAL
- en: Testing all microservice logs and stats is essential in the testing process.
    We need to have a formal testing process in place every step of the way during
    the migration process. The test process is described in more detail in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Keep both systems running for a period of time just in case some overseen issues
    take place and always be prepared with a contingency plan.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is shutting down the monolith. If the migration steps were followed
    and tested correctly, user traffic and system operations should not be impacted.
    However, complex systems may have a component or more still processing traffic.
    To avoid business interruptions in this situation, it is best to shut down the
    monolith during a maintenance window to allow the migration team to analyze any
    unforeseen issues and create a plan to resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, using our ABC system, we explained the MSA system deployment
    process using an ACL and using a direct monolith-to-microservices approach. We
    covered the steps to be taken, what to watch for, and how to make the transition
    to the new system as smooth as possible with minimal system interruption.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover the formal test methodology that should be
    planned and followed after every microservice migration to ensure system reliability
    and stability.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and tuning the MSA system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to deploying microservices, a formal testing or QA process should be applied
    to each microservice to prevent errors during deployment and in production.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of tests that need to be performed on the MSA system microservices
    before deploying them in the production environment. First, testing the microservice
    itself as a standalone and before integrating it into any parts of the ABC system
    – what we refer to it as, **unit testing**. Second, testing the integration of
    that microservice into the ABC-Intelligent-MSA system – what we refer to it as
    **integration testing**. And third, testing how the microservice functions during
    an interim mix of operations between the ABC-Monolith and the ABC-Intelligent-MSA
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the ABC system functions every time a new microservice is deployed is
    crucial to ensure a successful migration and that the system is able to properly
    function and sustain the applied traffic load and user requests.
  prefs: []
  type: TYPE_NORMAL
- en: Building structured test cases is an important part of the testing process.
    Test cases are a set of steps that describe how to test a specific feature or
    functionality of a system. These test cases should be well defined, easy to understand,
    and should cover all possible scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a test case should include the following main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the requirements of the system and the feature or functionality that
    we want to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a test case that describes the steps to be taken to test that feature
    or functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the test case, specify any prerequisites that are required to run the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the pass/fail criteria based on the expected outcome of the test case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test case and compare the test results to the expected outcome. Accordingly,
    and based on the pass/criteria specified, record the result of the test in simple
    PASS or FAIL terms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following is a simple example of a test case for the **Notification Management**
    microservice. The test case verifies that the microservice is actually sending
    an SMS notification to a registered user’s mobile number. Another test case should
    also be written to test the microservice’s email *Send* functionality. We can
    write as many test cases as needed for each individual microservice, and for the
    system functionality overall.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Test** **Case Details** |'
  prefs: []
  type: TYPE_TB
- en: '| Title | ABC-Intelligent-MSA Notification Management Microservice SMS Functionality
    |'
  prefs: []
  type: TYPE_TB
- en: '| ID | 002912 |'
  prefs: []
  type: TYPE_TB
- en: '| Description | To ensure that the microservice is actually sending an SMS
    notification to the specified mobile number |'
  prefs: []
  type: TYPE_TB
- en: '| Requirement(s) | Access to the SMS gateway. |'
  prefs: []
  type: TYPE_TB
- en: '| Test Setup | Have access to the receiver test phone +1 (555) 555-5555.Have
    access to the Ubuntu test environment.Verify SMS gateway access. |'
  prefs: []
  type: TYPE_TB
- en: '| Procedure | Ensure the `abc_msa_notify_user_container` container is running,
    or start it as follows:`docker container` `start abc_msa_notify_user_container`Issue
    a shell `curl` command as follows:`curl http://192.168.1.100:8010/api?func=send_sms&num=15555555555&msg=order+received`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Test Type | Unit testing |'
  prefs: []
  type: TYPE_TB
- en: '| Pass/Fail Criteria | Test case passes if you receive the message “order received”
    on the test phone |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – A sample test case for notification management in ABC-Intelligent-MSA
  prefs: []
  type: TYPE_NORMAL
- en: Testing the AI services of the ABC-Intelligent-MSA system can be more challenging,
    and the conventional test case approach may not be sufficient. Testing the AI
    part of the system will require a multi-level approach that would require including
    the microservice itself in isolation (unit testing), integration testing, functional
    testing, performance testing, data validation testing, and human-in-the-loop testing.
    By using all these approaches together in building your test cases, we can ensure
    that the AI components of the system are functioning as intended and are making
    accurate predictions and decisions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the importance of building a structured testing
    process and built a test case example as part of our system’s testing process.
    We discussed how to create a test case and identify the requirements and expected
    outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about the importance of conducting a post-deployment
    review after the completion of the ABC-Intelligent-MSA system deployment. The
    section will also cover the different types of post-deployment reviews, including
    user feedback reviews.
  prefs: []
  type: TYPE_NORMAL
- en: The post-deployment review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ABC-Intelligent-MSA system is currently running, but it hasn’t been operational
    for a sufficient amount of time to guarantee its stability and resilience under
    typical traffic patterns and loads. A post-deployment review is crucial for ensuring
    the success of the ABC system deployment and its compliance, as well as enhancing
    its functionality and overall user satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: During the post-deployment review, we will need to monitor the system closely
    and look for any errors, bugs, or any other operational problems that may happen.
    Then, we will need to make recommendations for addressing system issues and making
    necessary improvements to the system to ensure that the system is meeting the
    user requirements it was created for.
  prefs: []
  type: TYPE_NORMAL
- en: We need to have special monitoring for the AI services we built in the system
    to make sure they are performing as they are supposed to and continuously improving
    themselves and the system’s operations overall. A closer look at the AI services
    logs that we discussed in [*Chapter 10*](B18934_10.xhtml#_idTextAnchor115) is
    important to ensure the system’s stability and enhanced performance.
  prefs: []
  type: TYPE_NORMAL
- en: The following are some of the aspects and criteria that need to be considered
    when conducting a post-deployment review.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the new system’s performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by defining performance metrics, which will help us create a baseline
    for what to expect from the system, in terms of response time, user interactions,
    network traffic, and so on. We can use tools available on the internet or the
    `ms_perfmon.py` we previously discussed in [*Chapter 10*](B18934_10.xhtml#_idTextAnchor115)
    to measure the performance of the new system and compare that to the monolith’s
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: The variance between both the old and the new system’s performances would highly
    depend on the design, architecture, operational criteria, and infrastructure used
    in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and fixing system defects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This goes back to the testing and tuning process discussed earlier, and how
    the process should be conducted. It is important to point out here that post-deployment,
    identifying system defects is not yet part of the QA process until they are first
    documented in the organization’s defect tracking system.
  prefs: []
  type: TYPE_NORMAL
- en: We are talking here about monitoring the operational aspects of the system and
    ensuring proper system supportability. The support process may very well lead
    to filing specific issues found in the system post-deployment. Later, a thorough
    investigation of customer support cases with their severity levels will need to
    be conducted to address and fix these issues.
  prefs: []
  type: TYPE_NORMAL
- en: System issues can also be identified by gathering customer feedback, as we will
    discuss in the next couple of sections, as well as from the outcomes of the different
    audit processes conducted on the system post-deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Compliance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perform regular maintenance and updates to the system to keep it running smoothly.
    As briefly discussed in [*Chapter 8*](B18934_08.xhtml#_idTextAnchor086), a considerable
    part of compliance can be done through automation or commercial tools. The tools
    will help audit the system for different types of compliances, such as the GDPR,
    PCI, HIPAA, SCSEM, and so on. The specific compliances that an organization has
    to comply with will depend on the organization’s business itself, the nature of
    the system, and what processes and users it is serving.
  prefs: []
  type: TYPE_NORMAL
- en: Start by identifying the relevant regulations and standards that apply to the
    new system. This may include data privacy regulations, industry-specific standards,
    and cybersecurity standards.
  prefs: []
  type: TYPE_NORMAL
- en: Conduct a risk assessment the way we described in the previous chapter, to identify
    any potential areas of non-compliance and their associated risks. This may involve
    reviewing the process of the system’s design, architecture, and data processing.
    Then, put together a mitigation plan to mitigate the identified risks.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the organization’s staff are fully aware of compliance, its importance,
    and the individual roles and responsibilities in that regard. Keeping the staff
    trained is another aspect of keeping the organization compliant with specific
    rules, regulations, and specific industry compliances.
  prefs: []
  type: TYPE_NORMAL
- en: The compliance process is not a one-time thing, the organization has to conduct
    regular audits to maintain that compliance. Audits may include regularly running
    specific automated audit tools, and conducting manual system audits by checking
    system logs, data checks, physical and digital security checks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: System maintenance and updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like your preventive car maintenance, performing regular system maintenance
    and updates is important to keep the system running smoothly with no sudden unplanned
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'By planning, preparing, testing, implementing, monitoring, documenting the
    process, and taking a proactive role, we can ensure that our newly deployed system
    is functioning as expected and able to minimize operational interruptions. The
    following are a few points to consider in the maintenance plan:'
  prefs: []
  type: TYPE_NORMAL
- en: Put together a regular maintenance plan. This is a must-have for successful
    and reliable operations. This includes which part of the system needs to be updated,
    what maintenance activities need to be conducted and how often, prioritizing the
    maintenance tasks, and determining the resources required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you have a regular system backup plan in place and have an updated
    backup before any maintenance work. This is important to bring back the system
    to its original state in case of any work mishaps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test any planned work before actually applying the update or the change. Test
    the change thoroughly in a lab or staging environment to ensure it is functioning
    as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor the system after the updates have been deployed. This includes monitoring
    performance metrics, running automated checks, checking users’ feedback, and checking
    system logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update your documentation with the changes, and document the maintenance and
    update outcome. The documentation will help ensure that the maintenance and update
    process is repeatable for future reference, and help troubleshoot in case of any
    issues that may happen in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the beginning, the maintenance plan may not be as perfect as you may like
    it to be, but as the process is repeated during the lifetime of the system, the
    process will eventually get refined to a very accurate level.
  prefs: []
  type: TYPE_NORMAL
- en: User satisfaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monitoring and improving user satisfaction are sometimes underestimated in the
    success of deploying any new IT system. By gathering feedback from the system’s
    internal and external customers, analyzing that feedback, prioritizing changes,
    implementing changes, monitoring progress, and continuously improving, we can
    ensure that the system meets customer requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a four-step cycle for ensuring high customer satisfaction
    post-deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: The four-step customer satisfaction cycle](img/B18934_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: The four-step customer satisfaction cycle'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in monitoring our customer satisfaction is to gather feedback
    from the system users. The feedback can be collected through surveys, direct customer
    interaction and visits, phone conversations, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze the gathered feedback to identify common complaints, common patterns,
    and specific use cases that may have not been covered during the system testing
    phase. This will help us understand the strengths of the system and the areas
    where we need to improve.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prioritize whatever system changes are decided as an outcome of the gathered
    feedback. This part should have the biggest impact on customer satisfaction. It
    will show customers that you are addressing their concerns, reacting to their
    requests, and, sometimes, even being proactive to customer needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the changes as prioritized. Start with the changes with the highest
    impact and lowest effort similar to what we discussed in [*Chapter 11*](B18934_11.xhtml#_idTextAnchor132)
    under the *Risk mitigation* section and in *Figure 11**.2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to continuously regather customer feedback to regularly monitor customer
    satisfaction progress. This will ensure that the changes being carried out are
    having the desired customer satisfaction effect.
  prefs: []
  type: TYPE_NORMAL
- en: The four-step process will help continuously meet customer needs and improve
    customer satisfaction accordingly. The process helps also constantly improve the
    system features, supportability, reliability, and stability to enhance the overall
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the post-deployment review process, the different
    aspects, and activities that need to be considered when conducting the review,
    and how that is essential in the overall success of the ABC-Intelligent-MSA system
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed, the various steps involved in the successful
    deployment of the new system. We talked about the importance of overcoming the
    system deployment dependencies, the importance of building structured test cases,
    and the steps involved in testing and tuning the system.
  prefs: []
  type: TYPE_NORMAL
- en: By following the steps outlined in this chapter, organizations can ensure the
    successful deployment of their MSA system, including overcoming dependencies,
    integrating with the monolith during the transition phase, testing and tuning
    the system, and conducting a post-deployment review. The chapter concluded by
    emphasizing the significance of following a customer satisfaction cycle and having
    customers engaged in the process of adapting the new system’s operations.
  prefs: []
  type: TYPE_NORMAL
