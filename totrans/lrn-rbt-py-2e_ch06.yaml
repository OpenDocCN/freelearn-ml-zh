- en: Interfacing Actuators and Sensors to the Robot Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the selection of the hardware components
    needed to build our robot. The important components in a robot are actuators and
    sensors. Actuators provide mobility to the robot and sensors provide information
    about the robot environment. In this chapter, we will concentrate on the different
    types of actuators and sensors that we are going to use in this robot and how
    they can be interfaced with Tiva C LaunchPad, which is a 32 bit ARM micro controller
    board from Texas Instruments, working at 80 MHz. We will start by discussing actuators.
    The actuator that we are going to discuss first is a DC-geared motor with an encoder.
    A DC-geared motor works using direct current and has gear reduction to reduce
    the shaft speed and increase the torque of the final shaft. These kinds of motors
    are very economical and satisfy our robot design requirement. We will use this
    motor in our robot prototype.
  prefs: []
  type: TYPE_NORMAL
- en: In the first section of this chapter, we will deal with the design of our robot
    drive system. The **drive system** of our robot is a differential drive and consists
    of two DC-geared motors with encoders and a motor driver. The motor driver is
    controlled by Tiva C LaunchPad. We will look at the interfacing of the motor driver
    and quadrature encoder with Tiva C Launchpad. After that, we will look at some
    of the latest actuators that can replace the existing DC-geared motor with an
    encoder. If the desired robot needs more payload and accuracy, we have to switch
    to these kinds of actuators. Finally, we will look at some different sensors that
    are commonly used for robots.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing a DC-geared motor with Tiva C LaunchPad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing a quadrature encoder with Tiva C LaunchPad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of interfacing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing Dynamixel actuators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing ultrasonic sensors and IR proximity sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing inertial measurement units (IMUs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the necessary robot hardware component and Energia IDE set up
    in Ubuntu 16.04 LTS.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing DC geared motor to Tiva C LaunchPad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we selected a DC-geared motor with an encoder from
    Pololu and an embedded board from Texas Instruments, called Tiva C LaunchPad.
    We need the following components to interface the motor with LaunchPad:'
  prefs: []
  type: TYPE_NORMAL
- en: Two Pololu metal gear motors, 37Dx73L mm with 64 counts per revolution encoder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pololu wheel, 90x10 mm and a matching hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pololu dual VNH2SP30 motor driver carrier, MD03A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sealed lead acid/lithium ion battery of 12V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A logic level convertor of 3.3V to 5V; visit [https://www.sparkfun.com/products/11978](https://www.sparkfun.com/products/11978).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Tiva C LaunchPad and its compatible interfacing wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the interfacing circuit of two motors using Pololu
    H-Bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ce9e995-90df-474d-a082-35bceab88334.png)'
  prefs: []
  type: TYPE_IMG
- en: Motor interfacing circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'To interface with Launchpad, we have to connect a level shifter board in between
    these two motors. The motor driver works in 5V but the Launchpad works in 3.3V,
    so we have to connect a level shifter, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62074ed0-c097-4073-b041-9cb8cc46deb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Level shifter circuit
  prefs: []
  type: TYPE_NORMAL
- en: The two geared DC motors are connected to **OUT1A**, **OUT1B**, and **OUT2A**,
    **OUT2B** of the motor driver. **VIN (+)** and **GND (-)** are the supply voltage
    of the motor. These DC motors can work with a 12V supply, so we give 12V as the
    input voltage. The motor driver will support an input voltage ranging from 5.5V
    to 16V.
  prefs: []
  type: TYPE_NORMAL
- en: The control signals/input pins of the motor drivers are on the left side of
    the driver. The first pin is **1DIAG/EN**; in most cases, we leave this pin disconnected.
    These pins are externally pulled high in the driver board itself. The main use
    of this pin is to enable or disable the H-bridge chip. It is also used to monitor
    the faulty condition of the H-Bridge IC. Pins **1INA** and **1INB** control the
    direction of the rotation of the motor. The **1PWM** pin will switch the motor
    to the ON and OFF state. We achieve speed control using **PWM** pins. The **CS**
    pin will sense the output current. It will output 0.13V per Ampere of the output
    current. The **VIN** and **GND** pins give the same input voltage that we supplied
    for the motor. We are not using these pins here. The **+5V(IN)** and **GND** pins
    are the supply for the motor driver IC. The supply to the motor driver and motors
    are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the truth table of the input and output combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| INA | INB | DIAGA/ENA | DIAGB/ENB | OUTA | OUTB | CS | Operating mode |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | H | H | High Imp | Brake to Vcc |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | H | L | Isense = Iout / K | Clockwise (CW) |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | L | H | Isense = Iout / K | Counterclockwise (CCW) |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | L | L | High Imp | Breaker to GND |'
  prefs: []
  type: TYPE_TB
- en: The value **DIAG/EN** pins are always high because these pins are externally
    pulled high in the driver board itself. Using the aforementioned signal combinations,
    we can move the robot in any direction and by adjusting the PWM signal, we can
    adjust the speed of the motor too. This is the basic logic behind controlling
    a DC motor using an H-Bridge circuit.
  prefs: []
  type: TYPE_NORMAL
- en: While interfacing motors to Launchpad, we may require a level shifter. This
    is because the output pins of Launchpad can only supply 3.3V but the motor driver
    needs 5V to trigger; so, we have to connect 3.3V to the 5V logic level convertor
    to start working.
  prefs: []
  type: TYPE_NORMAL
- en: The two motors work in a differential drive mechanism. The following section
    discusses the differential drive and its operation.
  prefs: []
  type: TYPE_NORMAL
- en: Differential wheeled robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The robot we have designed is a differential wheeled/drive robot. In a differential
    wheeled robot, the movement is based on two separately driven wheels placed on
    either side of the robot''s body. It can change its direction by changing the
    relative rate of rotation of its wheels, and hence, doesn''t require additional
    steering motion. To balance the robot, a free turning wheel or caster wheels may
    be added. The following diagram shows a typical representation of a differential
    drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96923b01-7cc8-446a-914d-97042a6273cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Differential wheeled robot
  prefs: []
  type: TYPE_NORMAL
- en: 'If the two motors are in the same direction, the robot will move forward or
    backward. If one motor has more speed than the other, then the robot turns to
    the slower motor side; so, to turn left, stop the left motor and move the right
    motor. The following diagram shows how we connect the two motors in our robot.
    The two motors are mounted on the opposite sides of the base plate and we put
    two casters in the front and back of the robot for balancing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cd00226-487c-45e0-8698-6154eb64ce0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Top view of robot base
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can program the motor controller using Launchpad according to the truth
    table data. Programming is done using an IDE called **Energia** ([http://energia.nu/](http://energia.nu/)).
    We are programming Launchpad using the C++ language, very similar to Arduino boards
    ([http://energia.nu/Reference_Index.html](http://energia.nu/Reference_Index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Energia IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can download the latest version of Energia from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://energia.nu/download/](http://energia.nu/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the installation procedure mainly on Ubuntu 16.04 LTS, 64-bit.
    The Energia version that we will use is 0101E0018:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Energia for Linux 64-bit from the preceding link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the Energia compressed file into the Home folder of the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The instructions for setting the Tiva C Launchpad boards are given in the following
    link: [http://energia.nu/guide/guide_linux/](http://energia.nu/guide/guide_linux/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have to download the `71-ti-permissions.rules` file from the following
    link: [http://energia.nu/files/71-ti-permissions.rules](http://energia.nu/files/71-ti-permissions.rules)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The rules file will give permission to the user for reading and writing to
    the Launchpad board. You have to save the file as 71-ti-permissions.rules and
    execute the following command from the current path to copy the rules files into
    a system folder to get the permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After copying the file, execute the following command to activate the rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can plug the Tiva C Launchpad to your PC now and execute the `dmesg` command
    in the Linux Terminal to see the Linux kernel log. If it is created, a serial
    port device will show at the end of the messages, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/543ba969-e43e-4869-ae48-3c8cc61aadb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Top view of robot base
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can see the serial port device, then start Energia using the following
    command inside the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the Energia IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9a39ae5-9f7b-48e3-82ad-b20bb3d685f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Energia IDE
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have to select the board tm4c123 in the IDE for compiling the code specific
    for this board. To do so, we have to install the packages of this board. You can
    select the option Tools | Boards | Boards Manager to install the packages.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4fd0270-51aa-4ab5-92c4-4a38a0f1a753.png)'
  prefs: []
  type: TYPE_IMG
- en: Board Manager of Energia
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the packages, you can select the board by navigating to Tools
    | Boards | Launchpad (Tiva C) w/tm4c123 (80MHz), as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/87043600-18d4-40bb-8b8a-3f866ca0b4ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Energia board selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select the serial port by navigating to Tools | Serial Port | /dev/ttyACM0,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac0c8dfc-a033-455b-9863-3c00eac17947.png)'
  prefs: []
  type: TYPE_IMG
- en: Energia serial port selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and upload the code by using the Upload button. The Upload button will
    do both the processes. The following screenshot illustrates a successful upload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d41d768-e211-4e1a-a33d-103dcb5d7216.png)'
  prefs: []
  type: TYPE_IMG
- en: Energia serial port selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the following links to install Energia on Linux, macOS X, and Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [http://energia.nu/guide/guide_linux/](http://energia.nu/guide/guide_linux/)
    for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [http://energia.nu/Guide_MacOSX.html](http://energia.nu/Guide_MacOSX.html)
    for macOS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [http://energia.nu/Guide_Windows.html](http://energia.nu/Guide_Windows.html)
    for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor interfacing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code in Energia can be used to test the two motors in the differential
    drive configuration. This code can move the robot forward for 5 seconds and backward
    for 5 seconds. Then, it moves the robot to the left for 5 seconds and right for
    5 seconds. After each movement, the robot will stop for 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start of the code, we define pins for INA, INB, and PWM of the two motors,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The pinout for Launchpad is given at: [http://energia.nu/pin-maps/guide_tm4c123launchpad/](http://energia.nu/pin-maps/guide_tm4c123launchpad/)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the five functions to move the robot forward, backward,
    left, and right. The fifth function is to stop the robot. We will use the `digitalWrite()`
    function to write a digital value to a pin. The first argument of `digitalWrite()`
    is the pin number and the second argument is the value to be written to the pin.
    The value can be `HIGH` or `LOW`. We will use the `analogWrite()` function to
    write a PWM value to a pin. The first argument of this function is the pin number
    and the second is the PWM value. The range of this value is from 0-255\. At high
    PWM, the motor driver will switch fast and have more speed. At low PWM, switching
    inside the motor driver will be slow, so the motor will also be slow. Currently,
    we are running at full speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We first set the `INA` and `INB` pins of the two motors to the `OUTPUT` mode,
    so that we can write `HIGH` or `LOW` values to these pins. The `pinMode()` function
    is used to set the mode of the I/O pin. The first argument of `pinMode()` is the
    pin number and the second argument is the mode. We can set a pin as input or output.
    To set a pin as output, give the `OUTPUT` argument as the second argument; to
    set it as input, give `INPUT` as the second argument, as shown in following code.
    There is no need to set the PWM pin as the output because `analogWrite()` writes
    the PWM signal without setting `pinMode()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet is the main loop of the code. It will call each function,
    such as `move forward()`, `move_backward()`, `move_left()`, and `move_right(),`for
    `5` seconds. After calling each function, the robot stops for `1` second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Interfacing quadrature encoder with Tiva C Launchpad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wheel encoder is a sensor attached to the motor to sense the number of rotations
    of the wheel. If we know the number of rotations, we can compute the velocity
    and displacement of the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this robot, we have chosen a motor with an in-built encoder. This encoder
    is a quadrature type, which can sense both the direction and speed of the motor.
    Encoders use different types of sensors, such as optical and hall sensors, to
    detect these parameters. This encoder uses the hall effect to sense the rotation.
    The quadrature encoder has two channels, namely **Channel A** and **Channel B**.
    Each channel will generate digital signals with a 90-degree phase shift. The following
    diagram shows the wave form of a typical quadrature encoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7969c070-2911-431d-a5dc-916a8fbd6335.png)'
  prefs: []
  type: TYPE_IMG
- en: Quadrature encoder waveforms
  prefs: []
  type: TYPE_NORMAL
- en: If the motor rotates in a clockwise direction, **Channel A** will lead **Channel
    B,** and if the motor rotates counterclockwise, **Channel B** will lead **Channel
    A**. This reading will be useful to sense the direction of rotation of the motor.
    The following section discusses how we can translate the encoder output to useful
    measurements, such as displacement and velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Processing encoder data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encoder data is a two-channel pulse out with 90 degrees out of phase. Using
    this data, we can find the direction of rotation and how many times the motor
    has rotated, and thereby find the displacement and velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the terms that specify encoder resolution are **pulses per revolution**
    (**PPR**) or **lines per revolution** (**LPR**) and **counts per revolution**
    (**CPR**). PPR specifies how many electrical pulses (0 to 1 transitions) there
    will be during one revolution of the motor final shaft. Some manufactures use
    the name CPR instead of PPR, because each pulse will contain two edges (rising
    and falling) and there are two pulse channels (A and B) with 90-degree phase shift;
    the total number of edges will be four times the number of PPR. Most quadrature
    receivers use the so-called 4X decoding to count all the edges from encoder A
    and B channels yielding 4X resolution compared to the raw PPR value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our motor, Pololu specifies that the CPR is 64 for the motor shaft, which
    corresponds to 8,400 CPR of the gearbox''s output shaft. In effect, we get 8,400
    counts from the gearbox output shaft when the motor''s final shaft completes one
    revolution. The following diagram shows how we can compute the count from the
    encoder pulses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6324108-5123-4d55-b66a-56716c982163.png)'
  prefs: []
  type: TYPE_IMG
- en: Encoder pulses with count value
  prefs: []
  type: TYPE_NORMAL
- en: 'In this encoder specification, the count per revolution is given; it is calculated
    by the encoder channel edge transitions. One pulse of an encoder channel corresponds
    to four counts. So, to get 8,400 counts in our motor, the PPR will be *8,400 /
    4 = 2,100*. From the preceding diagram, we will be able to calculate the number
    of counts in one revolution, but we also need to sense the direction of movement.
    This is because irrespective of whether the robot moves forward or backward, the
    counts that we get will be same; so, sensing the direction is important in order
    to decode the signal. The following diagram shows how we can decode the encoder
    pulses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf1151a7-310f-42dc-80c0-bd5357fd5e0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Detecting motor direction from encoder pulses
  prefs: []
  type: TYPE_NORMAL
- en: If we observe the code pattern, we can understand that it follows the 2-bit
    Gray code. A Gray code is the encoding of numbers, so that adjacent numbers have
    a single digit differing by 1\. Gray code ([http://en.wikipedia.org/wiki/Gray_code](http://en.wikipedia.org/wiki/Gray_code))
    is commonly used in rotary encoders for efficient coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can predict the direction of rotation of a motor by state transitions. The
    state transition table is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| State | Clockwise transition | Counterclockwise transition |'
  prefs: []
  type: TYPE_TB
- en: '| 0,0 | 0,1 to 0,0 | 1,0 to 0,0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1,0 | 0,0 to 1,0 | 1,1 to 1,0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1,1 | 1,0 to 1,1 | 0,1 to 1,1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0,1 | 1,1 to 0,1 | 0,0 to 0,1 |'
  prefs: []
  type: TYPE_TB
- en: 'It will be more convenient if we represent it in a state transition diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ced2e452-275e-43f7-b313-231d8549f634.png)'
  prefs: []
  type: TYPE_IMG
- en: State transition diagram of encoders
  prefs: []
  type: TYPE_NORMAL
- en: After getting this Gray code, we can process the pulses using a microcontroller.
    The channel pins of the motor have to be connected to the interrupt pins of the
    microcontroller. So, when the channel has edge transitions, it will generate an
    interrupt or trigger in the pins, and if any interrupts arrives in that pin, an
    interrupt service routine, or simply a function, will be executed inside the microcontroller
    program. It can read the current state of the two pins. According to the current
    state of the pins and previous values, we can determine the direction of rotation
    and can decide whether we have to increment or decrement the count. This is the
    basic logic for encoder handling.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the count, we can calculate the angle of rotation (in degrees)
    using *Angle = (Count Value / CPR) * 360*. Here, if we substitute CPR with 8,400,
    the equation becomes *Angle = 0.04285 * Count Value*; that is, for turning one
    degree, 24 counts have to be received or six encoded channel pulses have to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the interfacing circuit of one motor encoder with
    Tiva C LaunchPad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/617798bd-cbd8-45c5-8d3f-a24f53b9e415.png)'
  prefs: []
  type: TYPE_IMG
- en: Interfacing encoder to Launchpad
  prefs: []
  type: TYPE_NORMAL
- en: From the above diagram, you can find motor pins CH A and CH B which are the
    output from the motor encoders. These pins are interfaced to PB2 and PB7 pins
    of the Tiva C Launchpad. The pins ENC VCC and ENC GND are the power pins of the
    encoder,  so we have to provide +5V and GND to these pins.  The next set of pins
    are for powering the motors. The MOTOR VCC  and MOTOR GND are marked as OUTA and
    OUTB which is directly going to Motor driver in order to control the motor speed.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum voltage level of output pulse is in between 0V to 5V from the encoder.
    In this case, we can directly interface the encoder with Launchpad because it
    can receive input up to 5V, or we can use a 3.3V to 5V level shifter like we used
    for motor driver interfacing earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will upload code in Energia to test the quadrature encoder
    signal. We need to check whether we get a proper count from the encoder.
  prefs: []
  type: TYPE_NORMAL
- en: Quadrature encoder interfacing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This code will print the count of the left and right motor encoder via a serial
    port. The two encoders are in a 2X decoding scheme, so we will get 4,200 CPR.
    In the first section of the code, we are defining pins for two channel outputs
    of two encoders and we are declaring the count variable for two encoders. The
    encoder variable uses a volatile keyword before the variable data type. The main
    use of `volatile` is that the variable with the `volatile` keyword will store
    in RAM memory, whereas normal variables are in CPU registers. Encoder values will
    change very quickly, so using an ordinary variable will not be accurate. In order
    to get accuracy, we will use `volatile` for encoder variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet is the definition of the `setup()` function. In
    Energia, `setup()` is a built-in function used for initialization and for one-time
    execution of variables and functions. Inside `setup()`, we initialize the serial
    data communication with a baud rate of `115200` and call a user-defined `SetupEncoders()`
    function to initialize pins of the encoders. The serial data communication is
    mainly done to check the encoder count via the serial terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of `SetupEncoders()` is given in the code that follows. To receive
    the encoder pulse, we need two pins in Launchpad as the input. Configure the encoder
    pins to Launchpad as the input and activate its pull-up resistor. The `attachInterrupt
    ()` function will configure one of the encoder pins as an interrupt. The `attachInterrupt
    ()` function has three arguments. The first argument is the pin number, the second
    argument is the **interrupt service routine** (**ISR**), and the third argument
    is the interrupt condition, that is, the condition in which the interrupt has
    to fire ISR. In this code, we are configuring `PinA` of the left and right encoder
    pins as the interrupt; it calls the ISR when there is a rise in the pulse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the built-in `loop()` function in Energia. The `loop()`
    function is an infinite loop where we put our main code. In this code, we call
    the `Update_Encoders()` function to print the encoder value continuously through
    the serial Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the function definition of the `Update_Encoders()` function.
    It prints two encoder values in a line with a starting character `e` and the values
    are separated by tab spaces. The `Serial.print()` function is a built-in function
    that will print the character/string given as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the ISR definition of the left and right encoders. When
    a rising edge is detected on each of the pins, one of the ISRs will be called.
    The current interrupt pins are `PinA` of each of the encoders. After getting the
    interrupt, we can assume that the rising `PinA` has a higher value state, so there
    is no need to read that pin. Read `PinB` of both the encoders and store the pin
    state to `LeftEncoderBSet` or `RightEncoderBSet`. The current state is compared
    to the previous state of `PinB` and can detect the direction and decide whether
    the count has to be incremented or decremented according to the state transition
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Upload the sketch and view the output using the serial monitor in Energia.
    Navigate to Tools | Serial monitor. Move the two motors manually and you will
    see the count changing. Set the baud rate in the serial monitor, which is the
    same as that initialized in the code; in this case, it is **115200**. The output
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2718f894-08de-4d89-b453-c6e701eeab4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Interfacing encoder to Launchpad
  prefs: []
  type: TYPE_NORMAL
- en: If we want to upgrade the robot to high accuracy and payload, we have to consider
    high quality actuators, such as Dynamixel. Dynamixel servos are intelligent actuators,
    which have in-built PID control and monitoring of the servo and encoder parameters,
    such as torque, position, and so on. In this robot, we are not using Dynamixel.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Dynamixel actuators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dynamixel** is a kind of networked actuator for robots developed by the Korean
    manufacture, ROBOTIS. It is widely used by companies, universities, and hobbyists
    due to its versatile expansion capability, power feedback function, position,
    speed, internal temperature, input voltage, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The Dynamixel servos can be connected in a daisy chain; it is a method of connecting
    devices in a serial fashion, connecting one device to another through the connected
    devices, and can control all the connected servos from one controller. Dynamixel
    servos communicate via RS485 or TTL. The list of available Dynamixel servos is
    given at [http://www.robotis.com/xe/dynamixel_en](http://www.robotis.com/xe/dynamixel_en).
  prefs: []
  type: TYPE_NORMAL
- en: 'The interfacing of Dynamixel is very easy. Dynamixel comes with a controller
    called USB2Dyanmixel, which will convert a USB to Dynamixel compatible TTL/RS485
    levels. The following diagram shows the interfacing diagram of Dynamixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49479e5f-e31f-43b8-8a35-ce370c301094.png)'
  prefs: []
  type: TYPE_IMG
- en: Interfacing Dynamixel actuators to a PC
  prefs: []
  type: TYPE_NORMAL
- en: ROBOTIS provides Dynamixel SDK for accessing motor registers; we can read and
    write values to Dynamixel registers and retrieve data, such as position, temperature,
    voltage, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions to set USB2Dynamixel and Dynamixel SDK are given at [support.robotis.com/en/](http://support.robotis.com/en/).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamixel can be programed using Python libraries. One of the Python libraries
    for handling Dynamixel servos is **pydynamixel**. This package is available for
    Windows and Linux. Pydynamixel will support RX, MX, and EX series servos.
  prefs: []
  type: TYPE_NORMAL
- en: We can download the the pydynamixel Python package from [https://pypi.python.org/pypi/dynamixel/](https://pypi.python.org/pypi/dynamixel/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the package and extract it to the `home` folder. Open a terminal/DOS
    prompt and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the package, we can try the following Python example, which
    will detect the servo attached to the USB2Dynamixel and write some random position
    to the servo. This example will work with RX and MX servos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will import the necessary Python modules required for this
    example. This includes Dynamixel Python modules too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code defines the main parameters needed for Dynamixel communication
    parameters. The `nServos` variable denotes the number of Dynamixel servos connected
    to the bus. The `portName` variable indicates the serial port of USB2Dynamixel
    to which Dynamixel servos are connected. The `baudRate` variable is the communication
    speed of USB2Dynamixel and Dynamixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the Dynamixel Python function to connect to Dynamixel
    servos. If it is connected, the program will print it and scan the communication
    bus to find the number of servos starting from ID `1` to `255`. The servo ID is
    the identification of each servo. We are given `nServos` as `1`, so it will stop
    scanning after getting one servo on the bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will append the Dynamixel ID and the servo object to the
    `myActutors` list. We can write servo values to each servo using the servo ID
    and servo object. We can use the `myActutors` list for further processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will write random positions from 450 to 600 to each Dynamixel
    actuator that is available on the bus. The range of positions in Dynamixel is
    0 to 1,023\. This will set the servo parameters, such as `speed`, `torque,torque_limt`,
    `max_torque`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will print the current position of the current actuator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will read all data from the actuators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Working with ultrasonic distance sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the important capabilities of a mobile robot is navigation. An ideal
    navigation means a robot can plan its path from its current position to the destination
    and can move without any obstacles. We use ultrasonic distance sensors in this
    robot for detecting near objects that can't be detected using the Kinect sensor.
    A combination of Kinect and ultrasonic sound sensors provides ideal collision
    avoidance on this robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultrasonic distance sensors work in the following manner. The transmitter will
    send an ultrasonic sound that is not audible to human ears. After sending an ultrasonic
    wave, it will wait for an echo of the transmitted wave. If there is no echo, it
    means there are no obstacles in front of the robot. If the receiving sensor receives
    any echo, a pulse will be generated on the receiver, and it can calculate the
    total time the wave will take to travel to the object and return to the receiver
    sensors. If we get this time, we can compute the distance to the obstacle using
    the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Speed of Sound * Time Passed /2 = Distance from Object*.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the speed of sound can be taken as 340 m/s.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the ultrasonic range sensors have a distance range from 2 cm to 400
    cm. In this robot, we use a sensor module called HC-SR04\. We look at how to interface
    HC-SR04 with Tiva C LaunchPad to get the distance from the obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing HC-SR04 to Tiva C LaunchPad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the interfacing circuit of the HC-SR04 ultrasonic
    sound sensor with Tiva C LaunchPad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef11ee4-03be-46e4-bcd2-6b6e13c39834.png)'
  prefs: []
  type: TYPE_IMG
- en: Interfacing ultrasonic sound sensors to Launchpad
  prefs: []
  type: TYPE_NORMAL
- en: The working voltage of the ultrasonic sensor is 5V and the input/output of this
    sensor is also 5V, so we need a level shifter on the **Trig** and **Echo** pins
    for interfacing into the **3.3V** level Launchpad. In the level shifter, we need
    to apply high voltage, that is, 5V, and low voltage, that is, 3.3V, as shown in
    the preceding diagram, to switch from one level to another level. **Trig** and
    **Echo** pins are connected on the high voltage side of the level shifter and
    the low voltage side pins are connected to Launchpad. The **Trig** pin and **Echo**
    are connected to the 10th and 9th pins of Launchpad. After interfacing the sensor,
    we can see how to program the two I/O pins.
  prefs: []
  type: TYPE_NORMAL
- en: Working of HC-SR04
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The timing of the waveform on each pin is shown in the following diagram. We
    need to apply a short 10 µs pulse to the trigger input to start the ranging and
    then the module will send out an eight-cycle burst of ultrasound at 40 KHz and
    raise its echo. The echo is a distance object that is the pulse width and the
    range in proportion. You can calculate the range through the time interval between
    sending trigger signals and receiving echo signals using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Range = high level time of echo pin output * velocity (340 M/S) / 2*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be better to use a delay of 60 ms before each trigger to avoid overlapping
    between trigger and echo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c24f5ba9-eef8-422d-a8ef-e32675e839cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Input and output waveform of ultrasound sensor
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing Code of Tiva C Launchpad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following Energia code for Launchpad reads values from the ultrasound sensor
    and monitors the values through a serial port.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code defines the pins in Launchpad to handle ultrasonic echo
    and trigger pins and also defines variables for the duration of the pulse and
    the distance in centimeters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The following code snippet is the `setup()` function. The `setup()` function
    is called when the program starts. Use this to initialize variables, pin modes,
    to start using libraries, and so on. The setup function will only run once, after
    each power up or reset of the Launchpad board. Inside `setup()`, we initialize
    serial communication with a baud rate of 115200 and set up the mode of ultrasonic
    handling pins by calling a `SetupUltrasonic();function:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the setup function for the ultrasonic sensor; it will configure
    the `Trigger` pin as `OUTPUT` and the `Echo` pin as `INPUT`. The `pinMode()` function
    is used to set the pin as `INPUT` or `OUTPUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After creating a `setup()` function, which initializes and sets the initial
    values, the `loop()` function does precisely what its name suggests, and loops
    consecutively, allowing your program to change and respond. Use it to actively
    control the Launchpad board.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main loop of this is in the following code. This function is an infinite
    loop and calls the `Update_Ultra_Sonic()` function to update and print the ultrasonic
    readings through a serial port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The following code is the definition of the `Update_Ultra_Sonic()` function.
    This function will do the following operations. First it will take the trigger
    pin to the `LOW` state for `2` microseconds and `HIGH` for `10` microseconds.
    After `10` microseconds, it will again return the pin to the `LOW` state. This
    is according to the timing diagram. We already saw that 10 µs is the trigger pulse
    width.
  prefs: []
  type: TYPE_NORMAL
- en: 'After triggering with 10 µs, we have to read the time duration from the Echo
    pin. The time duration is the time taken for the sound to travel from the sensor
    to the object and from the object to the sensor receiver. We can read the pulse
    duration by using the `pulseIn()` function. After getting the time duration, we
    can convert the time into centimeters by using the `microsecondsToCentimeters()`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the conversion function from microseconds to distance
    in centimeters. The speed of sound is 340 m/s, that is, 29 microseconds per centimeter.
    So, we get the total distance by diving the total microseconds by 29/2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After uploading the code, open the serial monitor from the Energia menu under
    Tools | Serial Monitor and change the baud rate to 115200\. The values from the
    ultrasonic sensor are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f4f56c0-8820-4164-b093-96609d030585.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the ultrasonic distance sensor in Energia serial monitor
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing Tiva C LaunchPad with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how to connect Tiva C LaunchPad with Python
    to receive data from Launchpad in a PC.
  prefs: []
  type: TYPE_NORMAL
- en: The **PySerial** module can be used for interfacing Launchpad to Python. The
    detailed documentation of PySerial and its installation procedure for Windows,
    Linux, and OS X can be found here : [http://pyserial.sourceforge.net/pyserial.html](http://pyserial.sourceforge.net/pyserial.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[](http://pyserial.sourceforge.net/pyserial.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'PySerial is available in the Ubuntu package manager and it can be easily installed
    in Ubuntu using the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After installing the `python-serial` package, we can write Python code to interface
    Launchpad. The interfacing code is given in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code imports the Python `serial` module and the `sys` module.
    The `serial` module handles the serial ports of Launchpad and performs operations
    such as reading, writing, and so on. The `sys` module provides access to some
    variables used or maintained by the interpreter and to functions that interact
    strongly with the interpreter. It is always available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When we plug Launchpad to the computer, the device registers on the OS as a
    virtual serial port. In Ubuntu, the device name looks like `/dev/ttyACMx`. Here,
    x can be a number; if there is only one device, it will probably be 0\. To interact
    with Launchpad, we need to handle this device file only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will try to open the serial port `/dev/ttyACM0` of Launchpad
    with a baud rate of `115200`. If it fails, it will print `Unable to open serial
    port`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will read the serial data until the serial character becomes
    a new line (`''n''`) and prints it on the Terminal. If we press Ctrl + C on the
    keyboard, to quit the program, it will exit by calling `sys.exit(0)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving the file, change the permission of the file to executable using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the script will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8883a773-2d2e-4bf9-b7ef-1cddc170630e.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the ultrasonic distance sensor in Energia serial monitor
  prefs: []
  type: TYPE_NORMAL
- en: Working with the IR proximity sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infrared sensors are another method to find obstacles and the distance from
    the robot. The principle of infrared distance sensors is based on the infrared
    light that is reflected from a surface when hitting an obstacle. An IR receiver
    will capture the reflected light and the voltage is measured based on the amount
    of light received.
  prefs: []
  type: TYPE_NORMAL
- en: One of the popular IR range sensors is Sharp GP2D12\. The product link can be
    found here: [http://www.robotshop.com/en/sharp-gp2y0a21yk0f-ir-range-sensor.html](http://www.robotshop.com/en/sharp-gp2y0a21yk0f-ir-range-sensor.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the Sharp GP2D12 sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b860054a-dc96-4bbc-adb2-1b64eec7fbd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The sensor sends out a beam of IR light and uses triangulation to measure the
    distance. The detection range of the GP2D12 is between 10 cm and 80 cm. The beam
    is 6 cm wide at a distance of 80 cm. The transmission and reflection of the IR
    light sensor is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08cd0547-f099-46c0-a2b1-6f56d60a8e2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Obstacle sensing using IR light sensor
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left of the sensor is an IR transmitter, which continuously sends IR
    radiation. After hitting into some objects, the IR light will reflect and it will
    be received by the IR receiver. The interfacing circuit of the IR sensor is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ac903e7-cd5f-4439-9768-00e2ada402f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Pinout of Sharp IR sensor
  prefs: []
  type: TYPE_NORMAL
- en: 'The analog out pin **Vo** can be connected to the ADC pin of Launchpad. The
    interfacing code of the Sharp distance sensor with the Tiva C Launchpad is discussed
    further in this section. In this code, we select the 18th pin of Launchpad and
    set it to the ADC mode and read the voltage levels from the Sharp distance sensor.
    The range equation of the GP2D12 IR sensor is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Range = (6,787 / (Volt - 3)) - 4*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *Volt* is the analog voltage value from the ADC of the Volt pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first section of the code, we set the 18th pin of Tiva C LaunchPad
    as the input pin and start a serial communication at a baud rate of 115200:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following section of code, the controller continuously reads the analog
    pin and converts it to the distance value in centimeters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the basic code to interface a sharp distance sensor. There are some
    drawbacks with IR sensors. Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can't use them in direct or indirect sunlight, so it's difficult to use them
    in an outdoor robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may not work if the object is not reflective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range equation only works within the range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will discuss the IMU and its interfacing with Tiva C
    LaunchPad. An IMU can give the odometry data and it can be used as the input to
    navigation algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Inertial Measurement Units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **inertial measurement unit** (**IMU**) is an electronic device that measures
    velocity, orientation, and gravitational forces using a combination of accelerometers,
    gyroscopes, and magnetometers. IMUs have a lot of applications in robotics; some
    of the applications are applied in balancing of **unmanned aerial vehicles** (**UAVs**)
    and robot navigation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the role of IMUs in mobile robot navigation
    and some of the latest IMUs on the market and their interfacing with Launchpad.
  prefs: []
  type: TYPE_NORMAL
- en: Inertial navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IMU provides acceleration and orientation relative to inertial space. If
    you know the initial position, velocity, and orientation, you can calculate the
    velocity by integrating the sensed acceleration and the second integration gives
    the position. To get the correct direction of the robot, the orientation of the
    robot is required; this can be obtained by integrating sensed angular velocity
    from a gyroscope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates an inertial navigation system, which will
    convert IMU values to odometry data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96725089-cfd4-4614-9161-c6e5ea42f5b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Block diagram of IMU
  prefs: []
  type: TYPE_NORMAL
- en: 'The values we get from the IMU are converted into navigational information
    using navigation equations and feeding them into estimation filters, such as the
    Kalman filter. The **Kalman** filter is an algorithm that estimates the state
    of a system from the measured data ([http://en.wikipedia.org/wiki/Kalman_filter](http://en.wikipedia.org/wiki/Kalman_filter)).
    The data from an **inertial navigation system** (**INS**) will have some drift
    because of the error from the accelerometer and gyroscope. To limit the drift,
    an INS is usually aided by other sensors that provide direct measurements of the
    integrated quantities. Based on the measurements and sensor error models, the
    Kalman filter estimates errors in the navigation equations and all the colored
    sensors'' errors. The following diagram illustrates an aided inertial navigation
    system using the Kalman filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eac139d5-1f99-4cfd-9e7c-2a8975f60b91.png)'
  prefs: []
  type: TYPE_IMG
- en: IMU with inertial navigation system
  prefs: []
  type: TYPE_NORMAL
- en: Along with the motor encoders, the value from the IMU can be taken as the odometer
    value and it can be used for **dead reckoning**, the process of finding the current
    position of a moving object by using a previously determined position.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to look at one of the most popular IMUs from
    InvenSense, called **MPU 6050**.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing MPU 6050 with Tiva C LaunchPad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MPU-6000/MPU-6050 family of parts is the world's first and only six-axis
    motion tracking devices designed for the low power, low cost, and high-performance
    requirements of smartphones, tablets, wearable sensors, and robotics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MPU-6000/6050 devices combine a three-axis gyroscope and three-axis accelerometer
    on the silicon die together with an onboard digital motion processor capable of
    processing complex nine-axis motion fusion algorithms. The following diagram shows
    the system diagram of MPU 6050 and break out of MPU 6050:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3155f85-5dea-4496-b7e4-e43717a72ef1.png)'
  prefs: []
  type: TYPE_IMG
- en: Block diagram of MPU 6050
  prefs: []
  type: TYPE_NORMAL
- en: 'The breakout board of MPU 6050 is shown in the following diagram and it can
    be purchased from here [http://a.co/7C3yL96](http://a.co/7C3yL96):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9d921ce-0ffe-4c31-a559-8eff293c3c11.png)'
  prefs: []
  type: TYPE_IMG
- en: MPU 6050 breakout board
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection from Launchpad to MPU 6050 is given in the following table.
    The remaining pins can be left disconnected:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Launchpad pins | MPU6050 pins |'
  prefs: []
  type: TYPE_TB
- en: '| +3.3V | VCC/VDD |'
  prefs: []
  type: TYPE_TB
- en: '| GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| PD0 | SCL |'
  prefs: []
  type: TYPE_TB
- en: '| PD1 | SDA |'
  prefs: []
  type: TYPE_TB
- en: 'The following diagram shows the interfacing of MPU 6050 and Tiva C Launchpad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f91bf3ea-20e4-4715-9754-9882297e09b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Interfacing MPU 6050 breakout board to Launchpad
  prefs: []
  type: TYPE_NORMAL
- en: MPU 6050 and Launchpad communicate using the I2C protocol. The supply voltage
    is 3.3V and it is taken from Launchpad.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the MPU 6050 library in Energia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interfacing code of Energia is discussed in this section. The interfacing
    code uses the [https://github.com/jrowberg/i2cdevlib/zipball/master](https://github.com/jrowberg/i2cdevlib/zipball/master)
    library for interfacing MPU 6050.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the ZIP file from the preceding link and navigate to Preference from
    File | Preference in Energia, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b88d717b-08da-41dc-b6bd-fdbe7b916eda.png)'
  prefs: []
  type: TYPE_IMG
- en: Interfacing MPU 6050 breakout board to Launchpad
  prefs: []
  type: TYPE_NORMAL
- en: Go to Sketchbook location under Preferences, as seen in the preceding screenshot,
    and create a folder called `libraries`. Extract the files inside the Arduino folder
    inside the ZIP file to the `sketchbook/libraries` location. The Arduino packages
    in this repository are also compatible with Launchpad. The extracted files contain
    the `I2Cdev`, `Wire`, and `MPU6050` packages that are required for the interfacing
    of the MPU 6050 sensor. There are other sensor packages that are present in the
    `libraries` folder but we are not using them now.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding procedure is done in Ubuntu, but it is the same for Windows and
    macOS X.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing code of Energia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This code is used to read the raw value from MPU 6050 to Launchpad. It uses
    an MPU 6050 third-party library compatible with Energia IDE. The following are
    the explanations of each block of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first section of code, we include the necessary headers for interfacing
    MPU 6050 to Launchpad, such as `12C`, `Wire` and the `MPU6050` library, and create
    an object of `MPU6050` with the name `accelgyro`. The `MPU6050.h` library contains
    a class named `MPU6050` to send and receive data to and from the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following section, we start the I2C and serial communication to communicate
    with MPU 6050 and print sensor values through the serial port. The serial communication
    baud rate is `115200` and `Setup_MPU6050()` is the custom function to initialize
    the MPU 6050 communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following section is the definition of the `Setup_MPU6050()` function.
    The `Wire` library allows you to communicate with the I2C devices. MPU 6050 can
    communicate using I2C. The `Wire.begin()` function will start the I2C communication
    between MPU 6050 and Launchpad; also, it will initialize the MPU 6050 device using
    the `initialize()` method defined in the `MPU6050` class. If everything is successful,
    it will print connection successful; otherwise, it will print connection failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the `loop()` function, which continuously reads the sensor
    value and prints its values through the serial port: The `Update_MPU6050()` custom
    function is responsible for printing the updated value from MPU 6050:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of `Update_MPU6050()` is given as follows. It declares six variables
    to handle the accelerometer and gyroscope value in three-axis. The `getMotion6()`
    function in the MPU 6050 class is responsible for reading the new values from
    the sensor. After reading them, it will print via the serial port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the serial monitor is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43c41c23-6657-4d2b-8332-ab2ea0c1341e.png)'
  prefs: []
  type: TYPE_IMG
- en: Output from MPU 6050 in the serial monitor
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read these values using the Python code that we used for ultrasonic.
    The following is the screenshot of the Terminal when we run the Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1731f2d5-8b4a-4609-94fb-c55811f65a8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Output from MPU 6050 in the Linux Terminal
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the interfacing of the motors that we are
    using in our robot. We have looked at motor and encoder interfacing with a controller
    board called Tiva C Launchpad. We have discussed the controller code for interfacing
    motors and encoders. In the future, if the robot requires high accuracy and torque,
    we have looked at Dynamixel servos that can substitute current DC motors. We have
    also looked at the robotic sensors that can be used in our robot. The sensors
    we discussed are ultrasonic distance sensors, IR proximity sensors, and IMUs.
    These three sensors help in the navigation of the robot. We also discussed the
    basic code to interface these sensors to Tiva C LaunchPad. We will discuss the
    vision sensors used in this robot further in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the H-Bridge circuit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a quadrature encoder?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the 4X encoding scheme?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we calculate displacement from encoder data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the features of the Dynamixel actuator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are ultrasonic sensors and how do they work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you calculate distance from the ultrasonic sensor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the IR proximity sensor and how does it work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read more about Energia programming at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://energia.nu/guide/](http://energia.nu/guide/)'
  prefs: []
  type: TYPE_NORMAL
