- en: Modules, Packages, and Data Type Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses several organizational techniques for developing large-scale
    applications. Believe it or not, this is often something that is easily overlooked.
    When developing applications, we typically focus on building data types, functions,
    control flows, and so on. It is equally important, however, to organize the code
    properly so that it is clean and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: In the later part of this chapter, we will introduce Julia's type system. Data
    types are the most fundamental building blocks of any application. Julia's type
    system is one of its strongest features when compared to other programming languages.
    A solid understanding of the type system will enable us to achieve better designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The growing pains of developing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with namespaces, modules, and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing package dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing abstract types and concrete types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parametric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should know how to create your own packages,
    divide code into separate modules, and start creating new data types for your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code from this chapter is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: The growing pains of developing applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Start where you are. Use what you have. Do what you can. "'
  prefs: []
  type: TYPE_NORMAL
- en: '- Arthur Ashe'
  prefs: []
  type: TYPE_NORMAL
- en: Everyone's journey is different. Julia is a versatile, dynamic programming language
    that can be used in many interesting use cases. More specifically, you can use
    it to easily code and solve a problem without thinking too much about system architecture
    and design. This is often sufficient for small research projects; however, when
    a project becomes more critical to the business, or when you have to harden a
    proof of concept into a production environment, it requires better organization,
    architecture, and design so that the project or application can live longer and
    be more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: What kinds of project do we typically deal with? Let's explore some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Data science projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical data science project starts with the idea of learning from a set of
    data and making a prediction. A lot of the upfront work goes into data collection,
    data cleaning, data analysis, and visualization. Then, data is further digested
    into features as inputs a machine learning model. The process up until this point
    is called *data engineering*. The data scientist then chooses one or more machine
    learning models and keeps on refining and tuning the model to arrive at a good
    level of accuracy for the predictive model. This process is called *model development*.
    When the model is ready for production, it is deployed and sometimes a frontend
    is created for the end user. The final process is referred to as *model deployment*.
  prefs: []
  type: TYPE_NORMAL
- en: The data engineering and model development processes can be interactive at the
    beginning, but they usually end up getting automated. That's because the process
    needs to be repeatable and the results have to be consistent. Data scientists
    may use a variety of tools during development, ranging from a number of Jupyter
    notebooks to a suite of related libraries and programs.
  prefs: []
  type: TYPE_NORMAL
- en: When a predictive model becomes production-ready, it can be deployed as a web
    service so that it can be used to make real-time predictions. At this point, the
    model needs to have a life cycle and be maintained, just like any other production
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People developing enterprise applications have a different mindset. Unlike data
    science projects, software engineers typically know upfront what they need to
    build the system. They also know whether they have to live with certain assumptions
    and policies. For example, the technology stack may already be known when the
    project starts. Other factors that may already be familiar include the system
    architecture that will be used, which cloud vendor will be utilized, what database
    the application must integrate with, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise applications typically require a rich business domain object model.
    Data objects are created, manipulated, and transferred to different layers of
    the application. The system architecture may include a user interface, a middle
    tier, and a database backend.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise applications also tend to require a high level of integration with
    other systems. For example, a trading system used by an investment firm is typically
    hooked up to an accounting system, a trade-settlement system, a reporting system,
    and so on. As such, these applications are often designed to handle both *data
    at rest* (for example, data stored in a database) or *data in motion* (for example,
    data being streamed to another system). Furthermore, data movement may happen
    in real-time or as an overnight batch process.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting to growth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter what kind of application you develop, it should not be hard to recognize
    growing pains.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a data science project, the following signs typically indicate a growth-related
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: <q><q>"My notebook is getting too long. I often have to scroll up and down to
    understand what I have done before and what I'm doing now. There are too many
    variables created in between and I'm losing track of what they mean and how they
    are used."</q></q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <q>"The data structure is too complex. I was working on a data frame and have
    transformed it in ten different ways. I have now lost track of which transformed
    version represents what, and why they were needed in the first place."</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <q>"I have saved a bunch of machine learning models on disk, and I'm losing
    track of how each one was trained and what assumptions were made for each of those
    models."</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <q>"I have too much code scattered across many notebooks. Some code is duplicated
    or tweaked for a slightly different purpose. I am unable to achieve consistent
    results."</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As for an enterprise application, similar symptoms may surface:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>*"The application logic is too complicated, and there is a huge component
    performing too many functions."*</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <q>*"It's becoming difficult to add new features without breaking existing functions."*</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <q>*"It takes a lot of time for a new person to comprehend the code in this
    module and it seems that the same person has to relearn it again every now and
    then." *</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not fun to handle unorganized code and data. If you find yourself uttering
    some of the preceding phrases, it may be a good time to rethink your strategy
    and start organizing your program properly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start our learning journey by organizing code better with Julia.
    As we are working at a high level, we will introduce the concept of namespaces,
    and we will go over how to create modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Working with namespaces, modules, and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Julia ecosystem lives on a namespace; in fact, this is the only way we can
    keep things in order. Why do I say that? The reason is that namespaces are used
    to logically separate fragments of source code so that they can be developed independently
    without affecting each other. If I define a function in one namespace, I will
    still be able to define another function in a different namespace even though
    both functions have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: In Julia, namespaces are created using modules and submodules. In order to manage
    distribution and dependencies, modules are generally organized as packages. There
    is a standard directory structure for Julia packages. Although the top level directory
    structure is well defined, the programmer still has a lot of freedom in organizing
    source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create modules and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create submodules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to organize files in a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn about each in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a namespace? Let's try a real-life example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every language has its own set of words as defined in its dictionary. When
    people from different cultures talk to each other, they often end up in amusing
    situations. Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conversation 1**:'
  prefs: []
  type: TYPE_NORMAL
- en: American: *Your pants look dirty. You should change them.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: British: *Do you mean my trousers? My underpants are... quite clean and well!*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conversation 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: American: *These biscuits are yummy!*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: British: *Where? Where are the cookies...?*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conversation 3**:'
  prefs: []
  type: TYPE_NORMAL
- en: American: *I want to get back in shape and have tried many trainers but none
    of them are good.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: British: *Have you tried the new running ones from Nike? I found them comfortable
    enough for my daily jogging routines.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In fact, you don''t even need to be from a different culture to experience
    this problem. Sometimes the same word already has different meanings depending
    on the context. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Pool - swimming pool or a group of things?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squash - the vegetable or the sport?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current - electrical current or a flow of water?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no way that we can enforce a single vocabulary across all domains
    because of ambiguities such as these. Fortunately, computer scientists are smart
    and long ago solved the problem as it pertains to their field: to distinguish
    two different meanings for a single word, we can just prefix the word with the
    respective context. Using the examples from the preceding list, we can qualify
    each word as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Facility.Pool` and `Grouping.Pool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vegetable.Squash` and `Sport.Squash`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Electricity.Current` and `Liquid.Current`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prefix is known as a **namespace**. Now that the words are qualified with
    their respective namespaces, they are no longer ambiguous and have a clear meaning.
  prefs: []
  type: TYPE_NORMAL
- en: In Julia, namespaces are created using modules, which we will learn about in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules are used to create new namespaces. In Julia, creating a module is as
    simple as wrapping your code around a module block, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In general, modules are created for the purpose of sharing and reuse, and the
    best way to achieve this is to organize code in Julia packages. A Julia package
    is a directory and file structure for maintaining module definitions, test scripts,
    documentation, and related data.
  prefs: []
  type: TYPE_NORMAL
- en: There is a standard directory structure and convention for Julia packages; however,
    it would be a hassle to manually configure a new program in the same structure
    every single time. Fortunately, there are some open source tools that automatically
    create the structure for a new package. Without officially endorsing any specific
    tool, I have chosen the `PkgTemplates` package for demonstration, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not installed the `PkgTemplates` package before, it can be installed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/177bd713-5ae8-47e5-ab7b-67e5ff272b4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it is installed, we can use it to create our sample module. The first
    step is to create a `Template` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb89662a-b5ca-41e7-ae6a-a7a2de47d8b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Basically, the `template` object contains some default values that will be used
    to create new packages. Then, creating a new package is easy as calling the `generate`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/034a707f-5a03-497d-8f2f-27f698a6c75a.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, the package generator creates the new directory in the `~/.julia/dev` folder,
    but it is customizable with the `dir` keyword argument of the `Template` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `generate` command is used to create a new package called `Calculator`.
    It automatically creates a directory with the following package structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/835fcfff-df65-4c60-aa95-ae1f86787a7f.png)'
  prefs: []
  type: TYPE_IMG
- en: At this time, you can start editing the `Calculator.jl` file and replace the
    file contents with your own source code.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to Julia, make sure that you check out the `Revise` package,
    which allows you to edit source code and have your working environment updated
    automatically. Your productivity using Julia will be increased by a factor of
    10, guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work on the `Calculator` module by implementing some financial calculations.
    Over the course of this example, we will learn how to manage the accessibility
    of variables and functions from external clients. Our initial code is set up as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code should be saved to the `Calculator.jl` file.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functional behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Calculator` module defines two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `interest` function is used to calculate the interest for a deposit amount,
    `amount`, with the specified interest rate, `rate`, for a full investment period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rate` function is used to calculate the interest rate for which you can
    invest the deposit amount, `amount`, and receive the interest amount, `interest`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that *interest* and *rate* may mean completely different things outside
    the context of Calculator.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions defined inside a module are not exposed to the outside world. To
    expose them, the `interest` and `rate` functions can be exported using the `export`
    statement, so that users of this module can easily bring them into their own namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the functions are exported, they will be available in the client''s scope
    where the module is loaded with the `using` keyword. Let''s try to reference these
    functions from the Julia REPL before loading the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d3547c1-2da3-459b-ba38-fa4348fb7395.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because we have not loaded the `Calculator` package yet, neither `interest`
    nor `rate` is defined. Let''s bring them in now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fd33db8-3cc2-4e47-9f4a-8266bf7cb817.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the `using` statement is executed, all symbols exported from the module
    are brought into the current namespace. From the Julia REPL, the current module
    is called `Main`, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b733c478-b700-461d-bcf0-98fc25ecf660.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible for us to bring in a subset of the names by qualifying the `using`
    statement with specific names. Let''s restart the Julia REPL and try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e97eb30f-7c68-4700-9719-a9fae5a37214.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, only the `interest` function was brought into the `Main` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2e18976-1d12-49a5-8efa-3dfc7af6f50d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are actually several ways to import names from another module into the
    current namespace. For the sake of simplicity, we can summarize them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18043909-0fa4-4c6b-a480-5684bb7b8a64.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are four ways (namely, 1, 2, 4, and 5 in the preceding
    table) to bring the `interest` function into the current namespace. There are
    some subtleties in choosing between `using` and `import` statements. A good rule
    of thumb is to use the `using` statement when you are using the functionality,
    but choose the `import` statement when you need to extend the functionality from
    the module. Extending functions from another package is a key language feature
    of Julia, and you will learn more about that from various examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The picture, however, is not always rosy. Let''s imagine that the main program
    needs to use another module called `Rater`, which provides rating services for
    online books. In this scenario, the main program may try to take functions from
    both modules, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d613a4b5-acb6-4b92-9867-1c0497a68c1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But, *Houston, we have a problem!* The `rate` function was brought in from
    the `Calculator` module, but it happens to be in conflict with the other one from
    the `Rater` module. Julia automatically detects this conflict on first use, prints
    a warning, and, from then on, requires the programmer to use their fully qualified
    names to access either function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/411c28b3-6330-42cc-8014-97a9a8c37aea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are not happy with this, especially the ugly-looking warning, then there
    is an alternative. First, you can ask yourself whether both `rate` functions are
    actually needed in the main program. If only one `rate` function is needed, then
    just bring one into scope so that there is no more conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From my experience, bringing specific names into the current namespace is indeed
    the best choice for most use cases. The reason for this is that it will be immediately
    obvious which functions you depend on. Such dependency is also self-documented
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally, you may need to use both `rate` functions. In such cases, you
    can solve the problem by using the regular `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This way, it only loads the packages and does not bring any name into the current
    namespace. You can now refer to both `rate` functions with their fully qualified
    names—that is, `Calculator.rate` and `Rater.rate`. After creating these modules,
    let's move on to see how to create submodules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating submodules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a module becomes too large, it may make sense to split it into smaller
    parts so that it's easier to develop and maintain. One way to solve this problem
    is to create submodules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating submodules is convenient as they are just defined within the scope
    of the parent module. Let''s say we organize the `Calculator` module with two
    submodules—`Mortgage` and `Banking`. These submodules can be defined in separate
    files and can be included directly into the parent module. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Submodules, just like regular modules, are also defined using module blocks. The
    source code for `Mortgage` looks just like a regular module definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because the source code from `Mortgage` is included inside the `Calculator` module
    block, it forms a nested structure. The usage of submodules is the same as that
    of any regular module, except that you have to reference them via the parent module.
    In this case, you'd use `Calculator.Mortgage` or `Calculator.Banking`.
  prefs: []
  type: TYPE_NORMAL
- en: Using submodules is an effective way to separate code for larger codebases.
    Next, we will go over how to organize source code in a module.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing files in a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for modules is typically organized as multiple source files.
    Although there is no hard and fast rule about how source files are organized,
    the following are useful guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Coupling**: Highly coupled functions should be placed in the same file. Doing
    so allows less context switching when editing source files. For example, when
    you change the signature of a function, all callers of that function may need
    to be updated. Ideally, you would want to minimize the *blast radius* and not
    have to change many files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File size**: Having more than a few hundred lines of code in a single file
    could be a warning sign. If the code inside the file is all tightly coupled, then
    it may be better to redesign the system to reduce coupling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordering**:Julia loads the source files in the order in which you include
    them. As data types and utility functions are usually shared, it is better to
    save them in a `types.jl` and `utils.jl` file respectively and include them at
    the beginning of the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, the same considerations apply when organizing test scripts.
  prefs: []
  type: TYPE_NORMAL
- en: By now, we have learned how to create new namespaces using modules and submodules.
    More conveniently, a module is organized in a package so that it can be reused
    from an application. Once we have created multiple packages, it is unavoidable
    that they may have to depend on each other. It is important that we know how to
    handle these dependencies properly; this will be our primary topic in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Managing package dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Julia ecosystem has a rich set of open source packages. When packages are
    designed with a single objective, they can be reused more easily; however, working
    with a large codebase is not an easy task because it is more likely to depend
    on third-party packages. It takes a considerable amount of time and effort for
    a developer to maintain and manage these dependencies in order to avoid *dependency
    hell.*
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that dependencies exist not just between packages,
    but also between specific versions of packages. Luckily, the Julia language has
    strong support for semantic versioning, which can help solve a lot of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the semantic versioning scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying dependencies for Julia packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding circular dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's take a quick look at the semantic versioning scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the semantic versioning scheme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Semantic versioning ([https://semver.org/](https://semver.org/)) is a scheme
    developed by Tom Preston-Werner, most famously known as the co-founder and CTO
    of GitHub. Semantic versioning serves a very specific purpose, which is to provide
    the meaning—that is, the semantics—of version number changes.
  prefs: []
  type: TYPE_NORMAL
- en: When we use a third-party package and it is upgraded, how do we know whether
    our application needs to be updated? What kind of risk are we taking if we just
    upgrade the dependent package without doing any testing with our own application?
  prefs: []
  type: TYPE_NORMAL
- en: Before semantic versioning, it was almost always a guess. A more diligent and
    risk-averse developer, however, would at least examine the release notes of the
    dependent package, try to figure out whether there are any breaking changes, then
    take proper actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will quickly summarize how semantic versioning works. First of all,
    a version number is constructed using the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish, the version number can be followed by a release tag and a build
    number at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Every part of the version number reveals a meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: The `major` release number, when changed, means that a major change has been
    introduced in this release that is incompatible with the previous release. It
    is highly risky for applications to incorporate the new release as existing functions
    will likely break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `minor` release number, when changed, means that there are nonbreaking enhancements
    in this release. It is moderately risky for applications to incorporate the new
    release because previous functions should, at least in theory, continue to work
    as they are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `patch `release number, when changed, means that there are nonbreaking bug
    fixes in this release. The risk is low for applications to incorporate the new
    release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pre-release` tag, when present, indicates a pre-release candidate, such
    as alpha, beta, or **release candidates** (**RCs**). The release is considered
    unstable and applications should never use it in a production environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `build` tag is considered to be meta information and can be ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that semantic versioning is only useful when all packages use it properly.
    Semantic versioning is like a common language that package developers can use
    to easily indicate the impact of their changes when making new releases.
  prefs: []
  type: TYPE_NORMAL
- en: The Julia package ecosystem encourages semantic versioning. Next, we will take
    a look at how the Julia package manager, `Pkg`, handles dependencies using semantic
    versioning.
  prefs: []
  type: TYPE_NORMAL
- en: While Julia encourages semantic versioning, many open source packages still
    have a pre-1.0 version number, even though they can be quite stable for production
    use. A major version number of zero is special—it basically means that every new
    release is breaking.
  prefs: []
  type: TYPE_NORMAL
- en: As the Julia language matures, more package authors will mark their packages
    as 1.0, and the situation regarding package compatibility will get better over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying dependencies for Julia packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can tell when a package depends on another by examining the `using` or `import`
    keywords in the source files; however, the Julia runtime environment is designed to
    be more explicit by tracking the dependencies. Such information is stored in the
    `Project.toml` file in the package directory. In addition, a `Manifest.toml` file
    in the same directory contains more information about the complete dependency
    tree. These files are written in the TOML file format. Although it is easy enough
    to edit these files by hand, the `Pkg` package manager's **command-line interface**
    (**CLI**) could be used to manage dependencies more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new dependent package, you just need to carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the Julia REPL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Pkg` mode by pressing the `]` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the project environment using the `activate` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the dependent package using the `add` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let''s add the `SaferIntegers` package to our `Calculator` package
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8c5fc8f-485e-42e0-a194-598c14a5c072.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s first examine the contents of the `Project.toml` file, as shown in the
    following screenshot. The funny-looking hash code `88634af6-177f-5301-88b8-7819386cfa38`
    represents the **universal unique identifier** (**UUID**) of the `SaferIntegers`
    package. Note that there is no version number specified for the `SaferIntegers`
    package, even though we know version 2.5.0 was installed from the preceding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/778c2259-af10-43c5-99e8-e53da5bf2a96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Manifest.toml` file contains the complete dependency tree of the package.
    First, we find the following section regarding our `SaferIntegers` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60ef38e3-b502-4fd8-8ebc-1b217dd07336.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the `SaferIntegers` package now has a specific version. `2.5.0`,
    in the manifest file. Why? It''s because the manifest is designed to capture the
    exact version information for all directly dependent *and* indirectly dependent
    packages. A second observation is that officially bundled packages, such as `Serialization`,
    `Sockets`, and `Test`, do not carry version numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d0528b9-751f-476d-b2fd-1d2edb42a5b5.png)'
  prefs: []
  type: TYPE_IMG
- en: These packages do not have version numbers because they are always released
    with the Julia binary. Their actual versions are pretty much determined by the
    specific Julia version.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to realize that neither `Project.toml` and `Manifest.toml`
    contains any versioning compatibility information, even though we know version
    2.5.0 of `SaferInteger` was installed. To specify compatibility constraints, we
    can manually edit the `Project.toml` file using the semantic versioning scheme.
    For example, if we know that `Calculator` is compatible with `SaferIntegers` version
    1.1.1 and later, then we can add this requirement to the `[compat]` section of
    the `Project.toml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This compatibility setting provides the necessary information for the Julia
    package manager to ensure that at least `SaferIntegers` version 1.1.1 is installed
    in order to use the `Calculator` package. Since the package manager is sensitive
    to semantic versioning, the preceding setting means that `Calculator` can work
    with all versions of `SaferIntegers` from 1.1.1 to the latest 1.*x*.*y* version,
    right up to 2.0\. In mathematical notation, the range of compatible versions is
    [1.1.1, 2.0.0), where 2.0.0 is excluded.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if `SaferIntegers` is improved and the package owner decides to release
    2.0.0? Well, because the major version number has advanced from 1 to 2, we have
    to expect breaking changes. If we don't do anything, the latest version, 2.0.0,
    will never be installed in the `Calculator` environment because we specifically
    implemented an exclusive upper bound of 2.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that, after thorough examination and testing, we conclude that `Calculator`
    is not affected by any breaking changes from `SaferIntegers` 2.0.0\. In that case,
    we can just make a small change to our `Project.toml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This line specifies the *union* of these two compatible version ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: The `1.1.1` specification indicates that the package is compatible with `SaferIntegers`
    versions [1.1.1, 2.0.0]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `2.0` specification indicates that the package is compatible with `SaferIntegers`
    versions [2.0.0, 3.0.0]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such information is important. If the `Calculator` package is used by someone
    who has an environment pinned to `SaferIntegers` version 1.1.1, then we know that
    `Calculator` is still compatible in that environment and can be loaded in it.
  prefs: []
  type: TYPE_NORMAL
- en: The package manager is actually very flexible, and it implements a few more
    version-specifier formats. You can refer to of `Pkg` reference manual for more
    information ([https://julialang.github.io/Pkg.jl/v1/compatibility/#Version-specifier-format-1](https://julialang.github.io/Pkg.jl/v1/compatibility/#Version-specifier-format-1)).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to specify compatibility between packages. By using the `Pkg`
    interface and editing the `Project.toml` file manually, we can manage dependencies
    properly, and the package manager will help us maintain the working environment
    in working order.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes, we may run into tricky dependency issues—for example, circular
    dependencies. We will look at how to handle such situations next.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding circular dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Circular dependencies are problematic. To understand why, consider the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have five packages (A, B, C, D, and E) with the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: A depends on B and C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C depends on D and E
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E depends on A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate these graphically, we can create a diagram where we can use an
    arrow notation to indicate dependencies between components. The direction of the
    arrow indicates the direction of the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e342d9b-ae0c-4d31-898c-90aa805106e9.png)'
  prefs: []
  type: TYPE_IMG
- en: What's the problem?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clearly there is a cycle, as A depends on C, C depends on E, and E depends on
    A. What is the problem with a cycle like this? Say that you have to make a change
    in package C that is supposed to be backward-compatible. To properly test the
    system with this change, we must make sure that C continues to have proper functionality
    given its dependencies. Now, if we trace this down the dependency chain, we must
    test C with D and E, and as E depends on A, we must include A as well. Now that
    A is included, we must include B and C. Because of the cycle, we now have to test
    all of the packages!
  prefs: []
  type: TYPE_NORMAL
- en: How do we fix this?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *acyclic dependency principle* states that dependencies between packages
    must be a **directed acyclic graph** (**DAG**)—that is, the dependency graph must
    have no cycle. If we do see a cycle in the graph, then it is a sign of a design
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter such a problem, we must refactor the code so that the specific
    dependent function is moved to a separate package. In this example, suppose that
    there's some code in package A that is used by the package internally and also
    used by package E. This dependency is basically E -> A.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then take this code and move it to a new package F. After this change,
    packages A and E would both depend on package F, effectively removing the cyclic
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bace0bad-d9f9-42a8-96f2-5f798342b34a.png)'
  prefs: []
  type: TYPE_IMG
- en: After this refactoring, when we make changes to C, we can just test the package
    with its dependencies, which would be D, E, and F only. Packages A and B can both
    be excluded.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to leverage semantic versioning to clearly communicate
    the impact of new versions of a package. We can use the `Project.toml` file to
    specify the compatibility of the current package with its dependent packages.
    We also reviewed a technique for resolving circular dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know this, we will look into how to design and develop data types in
    Julia.
  prefs: []
  type: TYPE_NORMAL
- en: Designing abstract and concrete types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's type system is the foundation of many of its language features, such
    as multiple dispatches. In this section, we will learn about both abstract types
    and concrete types, how to design and use them, and how they are different from
    other mainstream object-oriented programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing abstract types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing concrete types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `isa` and `<:` operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the difference between abstract and concrete types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first take a look at abstract types.
  prefs: []
  type: TYPE_NORMAL
- en: Designing abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to many other objected-oriented programming languages, Julia supports
    a hierarchy of abstract types. Abstract types are typically used to model real-world
    data concepts; for example, an `Animal` could be an abstract type for a cat or
    dog, and a `Vehicle` can be an abstract type for a car, truck, or bus. Being able
    to group types together and give the group a single name allows Julia programmers
    to apply generic code that is common to those types.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types are often conveniently defined in a type hierarchy for a specific
    domain. We can describe the relationship between abstract types as *parent–child*,
    or more technically, an *is-a-subtype-of* relationship. The terminology for the
    parent type and child type is *supertype* and *subtype* respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A unique feature of Julia's design, unlike the majority of other languages,
    is that abstract types are defined without any fields. For this reason, abstract
    types do not specify how data is actually stored in the memory. It may seem somewhat
    restrictive at first glance, but as we learn more about Julia, it will seem more
    natural when used in this design. As a result, abstract types are used solely
    to model behaviors for a set of objects rather than to specify how data is stored.
  prefs: []
  type: TYPE_NORMAL
- en: The Rectangle and Square object model is a classic example of how things can
    break down when an abstract type is allowed to define data fields. Suppose that
    we were able to define a Rectangle with `width` and `height` fields. A Square
    is a kind of Rectangle, so intuitively, we should be able to model Square as a
    subtype of Rectangle. But we soon get into trouble because a square does not need
    two fields to store the length of its sides; we should rather use a single `side
    length` field instead. Therefore, inheriting fields from supertypes makes no sense
    in this case. We will discuss this case with more details in [Chapter 12](97049a94-ad30-452a-bbb0-296d9438c886.xhtml),
    *Inheritance and Variance*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will work through an example of building an abstract
    type hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: A personal asset type hierarchy example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we are building a financial application that keeps track of a user''s
    wealth, which may include various types of asset. The following diagram shows
    a hierarchy of abstract types and their parent–child relationship. In this design,
    an Asset may be a Property, an Investment, or just Cash types. A Property can
    be a House or an Apartment. An Investment could be FixedIncome or Equity. As a
    convention, in order to indicate that they are abstract types rather than concrete
    types, we have chosen to italicize their names in the boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7da5c2a-c584-4a21-9b10-7f1a79716530.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create an abstract type hierarchy, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `<:` symbol represents an *is-a-subtype-of* relationship. So, the `Property`
    type is a subtype of `Asset`, the `Equity` type is a subtype of `Investment`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: While the `Asset` abstract type seems to be at the top level of the hierarchy
    in reality, it also has a supertype called `Any`, which is implicit when no supertype
    is specified and an abstract type is defined. The `Any` code phrase is the top-level
    supertype in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the type hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia provides some convenient functions to navigate the type hierarchy. To
    find the subtypes of an existing type, we can use the `subtypes` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46c834e8-6832-49ec-a7e2-66dec5643acb.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, to find the supertype of an existing type, we can use the `supertype`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/870c1fbb-1100-4662-bdce-4cd1780f0767.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, it''s convenient to see the complete hierarchy in a tree format.
    Julia comes with no standard function that we can use to achieve this, but we
    can easily create one ourselves using a recursion technique, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function can be quite convenient for new Julia users. In fact, I have the
    code saved in my `startup.jl` file so that it is loaded into the REPL automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The `startup.jl` file is a user-customized script that is located in the `$HOME/.julia/config`
    directory. It can be used to store any code or functions that the user wants to
    run every time the REPL is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now display the personal asset type hierarchy easily, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1512d6f8-9ade-4901-8631-6c4cfce05b6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that this function can only display a hierarchy of types that have already
    been loaded into memory. Now that we have defined abstract types, we should be
    able to associate functions with them. Let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions for abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all we have done is create a hierarchy of related concepts. With that
    limited knowledge, we can still define some functions to model behaviors. But
    how is this useful when we have no concrete data elements? When dealing with abstract
    types, we could just focus on specific behavior and the possible interaction between
    them. Let's continue with the example and see what kinds of function we can add.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although it does not sound very interesting, we can define functions that are
    solely based on the type itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we ever call `describe` with a data element that has a supertype of `Property`,
    then the description method for `Property` will be invoked accordingly. As we
    did not define any description function with the `Cash` type, when `describe`
    is called with a `Cash` data element it will return the description from the higher-level
    type, `Asset`.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have not defined any concrete types yet, we cannot prove the claim
    here that the `describe` function for a `Cash` object will resort to the `describe(a::Asset) `method.
    As it is a simple thing to do, I encourage the reader to do this as an exercise
    after reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Functional behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reason to have a hierarchy is to create an abstraction about common behaviors
    for types. For example, the `Apartment` and `House` types have the same supertype, `Property`.
    This is intentional because they both represent some kind of physical dwelling
    at a certain location. So, we can define a function for any `Property` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You may ask, *What have we done?* We have just implemented a function that
    does nothing but return an error! Well, believe it or not, defining this function
    actually serves several purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes it clear that any concrete subtype of `Property` must implement the `location` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime, if the `location` function is not defined for the respective concrete
    type, then this particular function will be called and a reasonable error will
    be thrown so that the programmer can correct the bug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The document string right above the function definition contains a useful description
    that concrete subtypes of `Property` should implement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, we can define an empty function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What is the difference between an empty function and one that throws an error?
    For this empty function, there will be no runtime error if the concrete type does
    not implement this function.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction between objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is also useful to define interactions between abstract types. Now that we
    know that every `Property` should have a location, we can define a function that
    calculates the walking distance between any two properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The logic completely lives in the abstract types! We have not even defined any
    concrete types, and yet we are able to develop generic code that works for any
    concrete subtypes of `Property` going forward.
  prefs: []
  type: TYPE_NORMAL
- en: The power of the Julia language allows us to define these behaviors at this level
    of abstraction. For a moment, let's imagine what we would have to do if we were
    not allowed to define functions at this level and could only implement logic with
    specific concrete types. In this case, we would have to define a separate `walking_distance`
    function for every combination of different types of properties. It would be too
    mundane and boring for programmers!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how abstract types work, let's continue our journey and
    take a look at how to create concrete types in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: Designing concrete types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A concrete type is used to define how data is organized. In Julia, there are
    two kinds of concrete type:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive types carry pure bits. Julia's `Base` package comes with a variety
    of primitive types—signed/unsigned integers that are 8-, 16-, 32-, 64-, or 128-bits
    wide. Currently, Julia only supports primitive types with numbers of bits that
    are multiples of 8\. For example, it is possible to define a 256-bit integer type
    (32 bytes) if we have a use case that requires very large integers. How to do
    this is outside the scope of this book. If you feel that this is an interesting
    project, you can consult Julia's source code on GitHub and see how existing primitive
    types are implemented. The Julia language is indeed largely written in Julia itself!
  prefs: []
  type: TYPE_NORMAL
- en: Composite types are defined by a set of named fields. Grouping fields into a
    single type allows easier reasoning, sharing, and manipulation. Composite types
    may be designated a specific supertype or defaulted to `Any`. Fields can also
    be annotated with their own types, if you wish, and types can be either abstract
    or concrete. When type information is absent for fields, they default to `Any`,
    which means that the field can hold objects of any type.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on composite types in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Designing composite types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composite types are defined with the `struct` keyword. Let''s carry on the
    example from the preceding abstract type section and continue building our personal
    asset type hierarchy. We will now create a concrete type called `Stock` as a subtype
    of `Equity`. To keep things simple, we will just represent a stock as a trading
    symbol and the name of the company:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate a composite type using the standard constructor, which just
    takes all the fields as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/545e24c6-ce93-4e1c-b2f9-686f0dd99ca2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, since `Stock` is a subtype of `Equity`, which is a subtype of `Investment`,
    which in turn is a subtype of `Asset`, we should obey the *contract* that we set
    forth earlier by defining the `describe` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` function just returns a string representation of the stock with
    both the trading symbol and company name.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composite types are by default immutable. This means that their fields are
    not changeable after the object is created. Immutability is a good thing as it
    eliminates surprises when system behavior changes unexpectedly because of data
    modification. We can easily prove that the concrete `Stock` type that we created
    in the last section is immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f1204bf-2ab9-42db-9062-f702f1ff2902.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s great! Now, the immutability guarantee actually stops at the field
    level. If the type contains a field and the field''s own type is mutable, then
    changing the underlying data is allowed. Let''s try a different example by creating
    a new composite type called `BasketOfStocks`, which is used to hold a vector (that
    is, a one-dimensional array) of stocks and the reason that we are holding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just create an object for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d66f128-0e67-49d1-98a0-fd4dad278a33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we already know, `BasketOfStocks` is an immutable type, so we cannot change
    any of the fields in it; however, let''s see if we can take away one of the stocks
    from the `stocks` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d506cfe-1b10-4719-991e-ebf2fbe83fca.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we just call the `pop!` function directly on the `stocks` object, and
    it will happily take away half of the presents for my wife! Let me repeat—the
    immutability guarantee does not have any effect on the underlying fields.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is by design. The programmer should be cautious about making any
    assumptions about immutability.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some situations, we may actually want an object to be mutable. The immutability
    constraint can be removed easily by just adding the `mutable` keyword in front
    of the type definition. To make the `Stock` type mutable, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try to update the `name` field in a hypothetical case where Apple
    changes its company name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dc50ddf-bca3-47e9-ac35-e09e0ecbdb12.png)'
  prefs: []
  type: TYPE_IMG
- en: The `name` field has been updated as we wish. Note that, when a type is declared
    mutable, all of its fields become mutable. So, in this case, we would be allowed
    to change the symbol as well. Depending on the situation, such behavior may or
    may not be desirable. In [Chapter 8](6b565339-641f-444c-ad42-f8ff7998001b.xhtml),
    *Robustness Patterns*, we will go over some design patterns that we can use to
    build a more robust solution.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable or immutable?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, mutable objects seem more flexible and give us good performance.
    But if that''s the case, then why wouldn''t we want everything to be mutable by
    default? There are a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects are easier to handle. Because the data in the object is fixed
    and never changes, a function that operates on these objects will always return
    consistent results. That is a very nice property to have because there are no
    surprises. And if we build a function that caches calculation results from such
    objects, the cache will always be good and return consistent results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable objects are more difficult to work with in a multi-threaded application.
    Let's say that a function is reading from a mutable object, but the content of
    the object is modified by another function from a different thread. Then the current
    function may produce incorrect results. In order to ensure consistency, the programmer
    must use a locking technique to synchronize the read/write operations to the object.
    Having to handle such a concurrent situation makes the code more complex and difficult
    to test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, mutability could be useful for high-performance use cases
    because memory allocation is a relatively expensive operation. We can reduce the
    system overhead by reusing allocated memory over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: All things considered, immutable objects are usually the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple types using Union types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we need to support multiple types in a field. This can be done using
    a `Union` type, which is defined as a type that can accept any specified types.
    To define a `Union` type, we can just enclose the types within curly braces after
    the `Union` keyword. For example, the `Union` type of `Int64` and `BigInt` can
    be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These `Union` types are quite useful when you need to incorporate data types
    that come from different data type hierarchies. Let''s extend our personal asset
    example further. For instance, say that we need to incorporate some exotic items
    into our data model, which may include things such as art pieces, antiques, paintings,
    and so on. These new concepts may have already been modeled with a different type
    hierarchy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As it turns out, my wife likes to collect paintings, and so I can just generalize
    the `BasketOfStock` type as `BasketOfThings`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The things inside the vector can be `Stock` or `Painting`. Remember that Julia
    is a strongly typed language, and it is important that the compiler knows what
    kinds of data type can fit into an existing field. Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bf242c2-9abf-4aaf-9e6a-6d3cdda92221.png)'
  prefs: []
  type: TYPE_IMG
- en: To create a vector that contains either `Painting` or `Stock`, we just specify
    the element type of the array in front of the square brackets, as in `Union{Painting,Stock}[stock,
    monalisa]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for `Union` types can be very verbose, especially when there are
    more than two types, so it is quite common for a constant to be defined with a
    meaningful name that represents the `Union` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `Thing` is much easier to read than `Union{Painting,Stock}`.
    Another benefit is that the `Union` type may be referenced in many parts of the
    source code. When we need to add more types later—for instance, an `Antique` type—then
    we only need to change it in one place, which is the definition of `Thing`. This
    means that the code can be maintained more easily.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, although we have chosen to use concrete types such as `Stock`
    and `Painting` for our example, there is no reason why we cannot use abstract
    types such as `Asset` and `Art` for the `Union` type.
  prefs: []
  type: TYPE_NORMAL
- en: Another common usage of the `Union` type is to incorporate `Nothing` as a valid
    value for a field. This can be achieved by declaring a field with the `Union{T,Nothing} `type,
    where `T` is the real data type that we want to use. In that case, the field can
    be assigned with a real value or just `Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will continue to learn how to work with type operators.
  prefs: []
  type: TYPE_NORMAL
- en: Working with type operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's data types are first-class citizens themselves. This means that you
    can assign them to variables, pass them to functions, and manipulate them in various
    ways. We will take a look at two commonly used operators in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The isa operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `isa` operator can be used to determine whether a value is a subtype of
    a type. For example, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65d7f375-620b-46fc-a9fb-0a0facbcce16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let me explain each of these results:'
  prefs: []
  type: TYPE_NORMAL
- en: The number `1` is an instance of the `Int` type, so it returns `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `Float64` is a different concrete type, it returns `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `Int` is a subtype of `Signed`, which is a subtype of `Integer`, which
    is a subtype of `Real`, it returns `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isa` operator could be useful for checking types in a function that accepts
    generic type arguments. For example, if the function can only work with `Real`
    numbers, then it may throw an error when a `Complex` value is passed by accident.
  prefs: []
  type: TYPE_NORMAL
- en: The <: operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *is-a-subtype-of* operator, `<:`, is used to determine whether a type is
    a subtype of another type. Taking the third example from the preceding section,
    we can check whether `Int` is indeed a subtype of `Real` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e081da-8d13-4fe2-8da1-0f2d9adf8a34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes the developer may be confused about the usage of the `isa` and `<:`
    operators because they are very similar. We can keep in mind that `isa` checks
    a *value* against a type, and `<:` checks a *type* against another type. The document
    string for these operators is actually quite helpful. From the Julia REPL, type
    a `?` character and enter the operator to find the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59b3c143-4d6f-491b-9347-d4fbc226f65c.png)'
  prefs: []
  type: TYPE_IMG
- en: As it turns out, both `isa` and `<:` are just functions, but they can also be
    used as infix operators.
  prefs: []
  type: TYPE_NORMAL
- en: These operators are quite useful for type-checking purposes; for example, we
    can throw an exception from a constructor function if the arguments being passed
    do not have the right types. They can also be used to execute different logic
    dynamically based upon the types being passed to a function.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types and concrete types are the fundamental building blocks for data
    types in Julia. It may be worth looking at a quick summary of the differences
    between them. Next, we will look at specific details.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between abstract and concrete types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having discussed abstract types and concrete types, you may be wondering how
    they differ from each other. We can summarize their differences in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Abstract Type** | **Concrete Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Has a supertype? | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Allows subtypes? | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Contains data fields? | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| First class? | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Can be part of a `Union` type? | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: For abstract types, we can build a hierarchy of types. The top-level type is
    just `Any`. Abstract types cannot contain any data fields as they are used to
    represent concepts rather than data storage. Abstract types are first-class, meaning
    that they can be stored and passed around, and there are functions that work with
    them—for example, the `isa` and `<:` operators.
  prefs: []
  type: TYPE_NORMAL
- en: A concrete type is associated with an abstract type as a supertype. If the supertype
    is not specified, then it is assumed to be `Any`. A concrete type does not allow
    subtypes. This means that every concrete type must be final, and would be a leaf
    node in a type hierarchy. Concrete types are also first class, just like abstract
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Both abstract types and concrete types can be referred to in a `Union` type.
  prefs: []
  type: TYPE_NORMAL
- en: What we just mentioned may be surprising to people who come from an object-oriented
    programming background. First, you may wonder why concrete types do not allow
    subtypes. Second, you may wonder why abstract types can't be defined with fields.
    This design is actually intentional and was debated heavily by the core Julia
    development team. The debate is related to behavioral inheritance versus structural
    inheritance, which will be discussed in [Chapter 12](97049a94-ad30-452a-bbb0-296d9438c886.xhtml),
    *Inheritance and Variance*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's switch gear and go over the parametric type feature of the Julia
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Working with parametric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful features of the Julia language is the ability to parameterize
    types. It is actually quite difficult to find any Julia package that does not
    use this feature. Parametric types allow the software designer to generalize types,
    and let the Julia runtime automatically compile to the concrete version based
    on the specified parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how this works with composite and abstract types.
  prefs: []
  type: TYPE_NORMAL
- en: Working with parametric composite types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing composite types, we should assign each field a type. Oftentimes,
    we don't really care exactly what those types are, as long as the type provides
    the functionality that we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'A classic example would be numeric types. The concept of numbers is simple:
    basically the same as we were taught in elementary school. In practice, many numeric
    types are implemented in computer systems because of the different physical storage
    and representations of data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Julia ships with the following numeric types; concrete types are
    darker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed69deaa-7703-4d91-9dd5-072bd38fe537.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Do you remember when we designed a composite type to represent a stock in an
    investment portfolio earlier in this chapter? Let''s revisit that example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If I have to hold some stocks in my brokerage account, then I should also keep
    track of the number of shares that I own. To do this, I can define a new type
    called `StockHolding`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Int` data type is by default aliased to either `Int64` or `Int32`, depending
    on whether you are using the 64-bit or 32-bit version of Julia. This seems reasonable
    just to get started, but what if we need to support fractional shares for a different
    use case? In that case, we can just change the type of `quantity` to `Float64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We basically widen the type of `quantity` field to a type that supports both
    integer and floating-point values. It may be a reasonable approach, but if we
    need to support both `Int` and `Float64` types, then we would have to maintain
    two slightly different types. Sadly, if we do create two different types, then
    it becomes a maintenance nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it more flexible, we can redesign the `StockHolding` type with a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The symbol `T` inside the curly braces is called a *type parameter*. It serves
    as a placeholder that can be used as a type in any of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have the best of both worlds. The `StockHolding{Int}` type refers to
    the type that contains a `quantity` field of the `Int` type. Likewise, the `StockHolding{Float64}`
    refers to the type that contains a `quantity` field of the `Float64` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the `T` type parameter can only be a numeric type, so we could
    further qualify `T` as any subtype of `Real`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here's how we read this—*the* `StockHolding` *type contains a stock and a quantity
    of the *`T` *type that is a subtype of* `Real`. The second part of the sentence
    is important; it means that we can create a new `StockHolding` with the type of `quantity`
    as `Float16`, `Float32`, `Float64`, `Int8`, `Int16`, `Int32`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try instantiating the `StockHolding` object with different kinds of
    type parameter, such as `Int`, `Float64`, and `Rational`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/481f7308-e43e-4b20-86e5-12f09c65965f.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that different `StockHolding{T}` types are created automatically
    according to the argument that was passed to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use of parametric types is to enforce the consistency of field types.
    Suppose that we want to design another kind of stock-holding object to track the
    price and market value of the holding. Let''s call it `StockHolding2` to avoid
    confusion with the preceding one. The following is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing that the type for `quantity` may not be the same as the type for `price`
    and `marketvalue`, we have added a new type parameter, `P`. Now, we can instantiate
    a `StockHolding2` object that contains an integer quantity while having floating-point
    values for price and market value fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/debf66c0-e43e-44a2-a70c-0dc844f8b4d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the type is `StockHolding2{Int64, Float64}`, as shown in the preceding
    screenshot. In this case, the type parameter `T` is `Int64` and the parameter `P`
    is `Float64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we declared that both the `price` and `marketvalue` fields must be of the
    same type, `P`, does Julia enforce this rule for us? Let''s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a65ab845-d29f-49cc-a4a8-8eb6448603ee.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Yes, it does!* We correctly received an error because we passed a `Float64`
    value for `price`, but an `Int64` for `marketvalue`. Let''s take a closer look
    at the error message, which revealed what the system expects. The closest candidate
    function for `StockHolding2` takes a `P` type for the third and fourth arguments,
    where `P` is any subtype of `AbstractFloat`. Because `In64` is not a subtype of
    `AbstractFloat`, there is no match and so an error was thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: Parametric types can be abstract as well. We will go over this next.
  prefs: []
  type: TYPE_NORMAL
- en: Working with parametric abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Abstract types can be enhanced in the same way that composite types can be
    parameterized. Let''s continue with the preceding example. Suppose that we want
    to build an abstract type called `Holding` that keeps track of a `P` type that
    is used by its subtypes. We can code it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, every subtype of `Holding{P}` must also take a  `P` type parameter. As
    an example, we can create two new types —`StockHolding3{T,P}` and `CashHolding{P}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can examine how these types are related as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a9dd07-410b-4a41-a02a-b4a485ef45a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a new `StockHolding3` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41285d50-bf70-4fac-a6e1-4455b4b3895e.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the `certificate_in_the_safe` object is a subtype of `Holding{Float64}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, when a type is parameterized, each variation is considered as a
    separate type that is unrelated to the others, except that they have a common
    supertype. As an example, `Holding{Int}` is a different type from `Holding{Float64}`,
    but they are both subtypes of `Holding`. Let''s quickly prove this to ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6371c808-59b0-463e-ba85-59b974c893e8.png)'
  prefs: []
  type: TYPE_IMG
- en: In summary, Julia comes with a very rich type system that a programmer can use
    to reason how each type relates to other types. Abstract types allow us to define
    behaviors in a hierarchy of relationships, and concrete types are used to define
    how data is stored. Parametric types are used to extend existing types to variations
    of field types. All of these language constructs allow the programmer to model
    data and behavior effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into data type conversions and how they apply to functions.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion between data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to convert data from one type to another in order to leverage
    existing library functions. A great working example would be the standard numerical
    data types. It is a common use case to convert a piece of date from an integer
    to a floating-point number in most mathematical functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about how data type conversion is performed in
    Julia. As it turns out, data type conversions are expected to be implemented explicitly;
    however, a set of rules has been implemented so that some conversions are automatically
    invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Performing simple data type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to convert a value from one data type to another. The obvious
    choice is to construct a new object from an existing value. For example, we can
    construct a `Float64` object from a rational number as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbf568bb-125b-42cc-af66-b9c3d1011b10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way is to use the `convert` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d6cb216-8e5b-4ee5-b537-343c21953ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: Either way works fine. There is an advantage from using the `convert` function
    when considering performance optimization, as we will explain later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of lossy conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to conversion, it is important to consider whether the conversion
    is lossless or lossy. In general, it is expected that data type conversion is
    lossless, which means that, when you convert from one type to another and back,
    you get the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the numerical representation of floating-point numbers, such perfect
    conversion is not always possible. For example, let''s try to convert `1//3` to `Float64` and
    then convert it back to `Rational`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b944aeed-5ed8-4231-8af0-40dea9469ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because of a rounding error, it is not possible to reconstruct `1//3` after
    it was converted to a `Float64` type. The problem is not restricted to the `Rational`
    type. We can easily break this again by converting the value from an `Int64` to
    a `Float64` and back, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/015472e3-fb61-42d6-8c91-77ce98cc730f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that there is a loss of precision here. While we may not be very
    satisfied with these results, there is really not much that we can do here as
    long as we use the `Float64` type. The `Float64` type is implemented according
    to the IEEE 754 floating-point specification, and it is expected to carry precision
    errors. If you need more precision, you can use `BigFloat` instead, which solves
    this particular problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc94641d-6994-4e4a-aa7d-23590048ec62.png)'
  prefs: []
  type: TYPE_IMG
- en: When handling floating-point values, we should be cautious about precision issues.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding numeric type conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia does not automatically perform conversion on data types for safety reasons.
    Every conversion must be explicitly defined by the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier for everyone, Julia already contains conversion functions
    for numeric types by default. For instance, you can find this interesting piece
    of code from the `Base` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Both functions take the first argument of the `Type{T}` type, where `T` is a
    subtype of `Number`. Valid values include all standard numeric types, such as
    `Int64`, `Int32`, `Float64`, `Float32`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand these two functions further:'
  prefs: []
  type: TYPE_NORMAL
- en: The first function says that it's as easy as returning the argument `x` itself
    when we want to convert `x` from the `T` type and to the `T` type (the same type)
    as long as `T` is a subtype of `Number`. This can be considered a performance
    optimization because there is really no need to do any conversion when the target
    type is the same as the input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second function is a little more interesting. In order to convert `x`, which
    is a subtype of `Number`, to type `T`, which is also a subtype of `Number`, it
    just calls the constructor of the `T` type with `x`. In other words, this function
    can handle the conversion of any `Number` type to another type that is a subtype
    of `Number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may wonder why we don't just use the constructor in the first place. This
    is because the `convert` function is designed to be invoked automatically for
    various common use cases. As you can see from what we looked at previously, this
    extra indirection also allows us to bypass the constructor when conversion is
    unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: When does `convert` get called? The answer is that Julia does not automatically
    do that, except for a few scenarios. We will explore these scenarios in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the rules for automatic conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As data type conversion is a fairly standard operation, Julia is designed to
    automatically call the `convert` function in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a value to an array converts the value to the array's element type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assigning a value to a field of an object converts the value to the declared
    type of the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructing an object with `new` converts the value to the object's declared
    field type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assigning a value to a variable with a declared type converts the value to that
    type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A function with a declared return type converts its return value to that type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passing a value to `ccall` converts the value to the corresponding argument
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's confirm that these are indeed working as advertised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 1: Assigning a value to an array'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, assigning the `1` value to a `Float64` array would
    convert the former into a floating-point value, `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dea2c68-d2ee-42cb-99c7-2715fa241ec1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Case 2: Assigning a value to a field of an object'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, the `Foo` struct accepts a `Float64` field. When
    the field is assigned a value of `2`, it is converted to `2.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d131da0-5931-403d-b326-ca428f788a07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Case 3: Constructing an object with the new function'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, the `Foo` constructor automatically converts `1`
    to `1.0` when creating the `Foo` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8105a156-8030-40f9-9a7f-8b503350c50e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Case 4: Assigning to a variable that has a declared type'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, the local variable `x` is declared as a `Float64`
    type. When it is assigned the `1` value, it is converted to `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dedf63f0-4e75-4ede-b457-c0157334d8da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Case 5: Function has a declared return type'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, the `foo` function is declared to return a `Float64`
    value. Even though the `return` statement says `1`, it is converted to `1.0` before
    it is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e667993-c8ba-49ba-bade-fa8f21030db4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Case 6: Passing a value to ccall'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, the `exp` function from the C library is used to
    calculate the exponent of a number. It expects a `Float64` value as an argument,
    so when the value of `2` is passed to `ccall`, it is converted to `2.0` before
    being passed to the C function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20fc4eaa-ee41-437e-a192-5f2a61730f26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All that is good, but something seems to be missing. What about the most common
    use case: passing an argument to a function? Wouldn''t it be called if Julia auto-converts
    the arguments as well? The answer may be a little surprising. Let''s look at this
    in more detail in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the rules for function dispatches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia is a strongly typed language, which means that the programmer has to be
    very clear about the types being passed around. A function can only be called
    (also known as dispatched) when the types of its arguments are matched properly.
    A proper match can be defined as one that matches exactly (same type) or when
    the argument being passed is a subtype of what is expected in the function's signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s create a function that doubles the value of its
    argument of the `AbstractFloat `type. We will use our `subtypetree` utility function
    to quickly find out its subtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0914d4c3-d9f0-4530-9ce4-0e59adb27ef7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What happens if we pass an integer to the function? Well, it doesn''t work
    too well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9dab163-8585-4866-91fe-0dcdef913ba3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Naively, we may think that the system should auto-convert the argument to `Float64`
    and then double the value. Well, it does not. It is not a conversion issue. To
    get that effect, we could obviously write another function that takes an `Int`
    argument, then converts it to `Float64`, and calls the original function. But
    the code would look exactly the same, and it''s a duplication of effort. This
    problem can be solved by just writing the function more generically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c90dabc-789b-4b96-9784-b5cccfab5487.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we feel that the argument has to be a `Number`, then we can restrict it
    again as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88d30233-35fd-4f07-a172-2010d57b28ee.png)'
  prefs: []
  type: TYPE_IMG
- en: What we choose to do here depends on how flexible we want the function to be.
    The benefit of specifying an abstract type, such as `Number`, is that we feel
    sure the function will work well for any type that implements the behavior set
    down by `Number`. On the other hand, if we leave it as untyped in the function
    definition, then we open up the possibility for other objects to be passed to
    the function as long as the `*` operator is defined.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about how data type conversion can be performed
    in Julia. In certain scenarios, Julia can also automatically convert numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started discussing the importance of organizing source code
    for larger applications. We explored in detail how to establish namespaces and
    how to implement them using modules and submodules. To manage package dependencies,
    we introduced the concept of semantic versioning and learned how to use it properly
    with Julia's package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we went over the details of how to design an abstract type hierarchy and
    define functions for abstract types. We also discussed concrete types and the
    concepts of immutability and mutability. We demonstrated how to use union types
    when working with data types from different abstract type hierarchies. We looked
    at two common operators (`isa` and *is-a-subtype-of*) for data types. To further
    reuse data types, we introduced parametric types and looked at how they apply
    to both concrete types and abstract types.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the `convert` function in Julia and how it is invoked
    automatically under certain circumstances. We learned how Julia’s function dispatch
    works and how to make a function more flexible by accepting broader abstract types
    in its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a good understanding about how to organize code
    and designing your own data types.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to define application behavior using
    functions and Julia's multiple-dispatch facility.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following questions to test your understanding of the subjects
    in this chapter.  The answers are provided at the back of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we create a new namespace?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we expose the functions of a module to the outside world?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we reference the proper function when the same function name is exported
    from different packages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When do we separate code into multiple modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is semantic versioning important in managing package dependencies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is defining functional behavior for abstract types useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should we make a type mutable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are parametric types useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
