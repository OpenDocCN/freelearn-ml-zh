["```py\n// IsImageTrousers invokes the Saved model to predict if image at given index is, in fact, of trousers\n// For simplicity, this loads the model from disk on every request, whereas loading it once and caching it\n// would be preferable in a commercial application.\n\nfunc IsImageTrousers(i int) (bool, error) {\n  model := linear.Logistic{}\n  if err := model.RestoreFromFile(\"model.dat\"); err != nil {\n    return false, err\n  }\n  prediction, err := model.Predict(testImages[i])\n  return prediction > 0.5, err\n}\n```", "```py\n// Prediction\n\nIsImageTrousers(16)\n```", "```py\ntrue <nil>\n```", "```py\n// Ground truth\n\ndf.Col(\"Label\").Elem(16).Int() == 1\n\n```", "```py\n// ImageSeriesToInts converts the dataframe's column containing image data for multiple images to a slice of int slices, where each int is between 0 and 255, representing the value of the pixel.\n\nfunc ImageSeriesToInts(df dataframe.DataFrame, col string) [][]int {\n\n  s := df.Col(col)\n\n  ret := make([][]int, s.Len(), s.Len())\n\n  for i := 0; i < s.Len(); i++ {\n\n    b := []byte(s.Elem(i).String())\n\n    ret[i] = NormalizeBytes(b)\n\n  }\n\n  return ret\n\n}\n```", "```py\n// InvokeAndWait invokes a Python 3 script with the given arguments, waits for it to finish, and returns the concatenated output of its STDOUT and STERRR.\nfunc InvokeAndWait(args ...string) ([]byte, error) {\n  var (\n    output []byte\n    errOutput []byte\n    err error\n  )\n  cmd := exec.Command(\"python3\", args...)\n  stdout, err := cmd.StdoutPipe()\n  if err != nil {\n    return nil, err\n  }\n  stderr, err := cmd.StderrPipe()\n  if err := cmd.Start(); err != nil {\n    return nil, err\n  }\n  if output, err = ioutil.ReadAll(stdout); err != nil {\n    return nil, err\n  }\n  if errOutput, err = ioutil.ReadAll(stderr); err != nil || len(errOutput) > 0 {\n\n    return nil, fmt.Errorf(\"Error running model: %s\", string(errOutput))\n  }\n  return output, nil\n}\n```", "```py\n// IsImageTrousers invokes the Python model to predict if image at given index is, in fact, of trousers\n\nfunc IsImageTrousers(i int) (bool, error){\n    b, err := json.Marshal(testImages[i])\n    if err != nil {\n        panic(err)\n    }\n    b, err = InvokeAndWait(\"model.py\", \"predict\", string(b))\n    if err != nil {\n        return false, err\n    } else {\n        var ret struct {\n            IsTrousers bool `json:\"is_trousers\"`\n        }\n        err := json.Unmarshal(b, &ret)\n        if err != nil {\n            return false, err\n        }\n        return ret.IsTrousers, nil\n    }\n}\n```", "```py\n// Prediction\nIsImageTrousers(16)\n```", "```py\ntrue <nil>\n```", "```py\n// Ground truth\ndf.Col(\"Label\").Elem(16).Int() == 1\n```", "```py\n// Predict returns whether the ith image represents trousers or not based on the logistic regression model\n\nfunc Predict(i int) (bool, error){\n    b, err := json.Marshal(testImages[i])\n    if err != nil {\n        return false, err\n    }\n    r := bytes.NewReader(b)\n    resp, err := http.Post(\"http://127.0.0.1:8001\", \"application/json\", r)\n    if err != nil {\n        return false, err\n    }\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        return false, err\n    }\n    resp.Body.Close()\n    var resp struct {\n        IsTrousers bool `json:\"is_trousers\"`\n    }\n    err := json.Unmarshal(body, &resp)\n    return resp.IsTrousers, err \n}\n```", "```py\n// Expected: true <nil>\n\nPredict(16)\n```", "```py\ntrue <nil>\n```", "```py\nFROM tensorflow/tensorflow\n\n## Install gcc for cgo ##\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n curl \\\n git \\\n wget \\\n g++ \\\n gcc \\\n libc6-dev \\\n make \\\n pkg-config \\\n && rm -rf /var/lib/apt/lists/*\n\n## Install TensorFlow C library ##\nRUN curl -L \\\n \"https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.13.1.tar.gz\" | \\\n tar -C \"/usr/local\" -xz\nRUN ldconfig\n\n## Install Go ##\nENV GOLANG_VERSION 1.9.2\n\nRUN wget -O go.tgz \"https://golang.org/dl/go${GOLANG_VERSION}.${goRelArch}.tar.gz\"; \\\n echo \"${goRelSha256} *go.tgz\" | sha256sum -c -; \\\n tar -C /usr/local -xzf go.tgz; \\\n rm go.tgz; \\\n \\\n if [ \"$goRelArch\" = 'src' ]; then \\\n echo >&2; \\\n echo >&2 'error: UNIMPLEMENTED'; \\\n echo >&2 'TODO install golang-any from jessie-backports for GOROOT_BOOTSTRAP (and uninstall after build)'; \\\n echo >&2; \\\n exit 1; \\\n fi; \\\n \\\n export PATH=\"/usr/local/go/bin:$PATH\"; \\\n go version\n\nENV GOPATH /go\nENV PATH $GOPATH/bin:/usr/local/go/bin:$PATH\n\nRUN mkdir -p \"$GOPATH/src\" \"$GOPATH/bin\" && chmod -R 777 \"$GOPATH\"\n\n## Go get tensorflow go library ##\nRUN \\\n go get github.com/tensorflow/tensorflow/tensorflow/go \\\n github.com/tensorflow/tensorflow/tensorflow/go/op\n\n## Set up the environment so we can just run our code ##\nRUN mkdir $GOPATH/src/model\n\nWORKDIR $GOPATH/src/model\n\nADD . $GOPATH/src/model\n\nCMD [\"go\", \"run\", \"main.go\"]\n```", "```py\nsavedModel, err := tf.LoadSavedModel(\"./saved_model\", []string{\"serve\"}, nil)\nif err != nil {\n  log.Fatalf(\"failed to load model: %v\", err)\n}\n```", "```py\ninput := savedModel.Graph.Operation(\"input_input_1\")\noutput := savedModel.Graph.Operation(\"output_1/BiasAdd\")\n```", "```py\nsession := savedModel.Session\ngraph := savedModel.Graph\ndefer session.Close()\nfmt.Println(\"Successfully imported model!\")\n```", "```py\ndocker build -t tfgo . && \\\ndocker run -it tfgo\n```", "```py\nSuccessfully built 9658a6232ef8\nSuccessfully tagged tfgo:latest\nSuccessfully imported model!\n```", "```py\nfunc makeBlankInputTensor() (*tf.Tensor, error) {\n  t := make([][]float32, 1)\n  t[0] = make([]float32, 784)\n  tensor, err := tf.NewTensor(t)\n  return tensor, err\n}\n```", "```py\ntensor, err := makeTensorFromImage(\"/path/to/fashion/MNIST\", 12)\nif err != nil {\n  log.Fatal(err)\n}\nprediction, err := session.Run(\n  map[tf.Output]*tf.Tensor{\n    graph.Operation(input.Name()).Output(0): tensor,\n  },\n  []tf.Output{\n    graph.Operation(output.Name()).Output(0),\n  },\n  nil)\nif err != nil {\n  log.Fatal(err)\n}\n\nprobability := prediction[0].Value().([][]float32)[0][0]\nif probability > 0.5 {\n  fmt.Printf(\"It's a pair of trousers! Probability: %v\\n\", probability)\n} else {\n  fmt.Printf(\"It's NOT a pair of trousers! Probability: %v\\n\", probability)\n}\n```", "```py\nSuccessfully built b7318b44f92d\nSuccessfully tagged tfgo:latest\nSuccessfully imported model!\nIt's NOT a pair of trousers! Probability: 0.04055497\n```"]