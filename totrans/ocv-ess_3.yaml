- en: Chapter 3. First Things First – Image Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。首要之事 – 图像处理
- en: Image processing refers to digital processing of any two-dimensional data (a
    picture) by a computer by applying signal processing methods. Image processing
    has a broad spectrum of applications, such as image representation, image enhancement
    or sharpening, image restoration by means of filtering, and geometrical correction.
    These applications are usually the first stage and input to the following stages
    in a computer vision system. In OpenCV, there is a specific module, `imgproc`,
    for image processing. In this chapter, we will cover the most important and frequently
    used methods available in the library, that is, pixel-level access, histogram
    manipulation, image equalization, brightness and contracts modeling, color spaces,
    filtering, and arithmetic and geometrical transforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理是指计算机通过应用信号处理方法对任何二维数据（图像）进行数字处理。图像处理有广泛的应用范围，如图像表示、图像增强或锐化、通过滤波进行图像恢复以及几何校正。这些应用通常是计算机视觉系统后续阶段的第一个阶段和输入。在OpenCV中，有一个专门的模块`imgproc`用于图像处理。在本章中，我们将介绍库中最重要和最常用的方法，即像素级访问、直方图操作、图像均衡化、亮度和对比度建模、颜色空间、滤波以及算术和几何变换。
- en: Pixel-level access and common operations
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素级访问和常见操作
- en: 'One of the most fundamental operations in image processing is pixel-level access.
    Since an image is contained in the `Mat` matrix type, there is a generic access
    form that uses the `at<>` template function. In order to use it, we have to specify
    the type of matrix cells, for example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理中最基本的操作之一是像素级访问。由于图像包含在`Mat`矩阵类型中，因此存在一个使用`at<>`模板函数的通用访问形式。为了使用它，我们必须指定矩阵单元格的类型，例如：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that color images use the `Vec3b` type, which is an array of three unsigned
    chars. Images with a fourth alpha (transparency) channel would be accessed using
    the type `Vec4b`. The `Scalar` type represents a 1 to 4-element vector and can
    also be used in all these cases. Note that `at<>` can be also used to change pixel
    values (that is, on the left-hand side of an assignment).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，彩色图像使用`Vec3b`类型，它是一个包含三个无符号字符的数组。具有第四个alpha（透明度）通道的图像将使用`Vec4b`类型访问。`Scalar`类型表示一个1到4元素的向量，也可以用于所有这些情况。注意，`at<>`也可以用于更改像素值（即赋值语句的左侧）。
- en: 'Apart from pixel access, there are a number of common operations for which
    we should know the corresponding snippets. The following table shows these common
    operations:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像素访问之外，还有一些常见的操作，我们应该知道相应的代码片段。以下表格显示了这些常见操作：
- en: '| Operation | Code example |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 代码示例 |'
- en: '| --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Obtain size of matrix |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 获取矩阵大小 |'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Obtain number of channels |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 获取通道数 |'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Obtain pixel data type |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 获取像素数据类型 |'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Set matrix values |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 设置矩阵值 |'
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Or
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Create a copy of the matrix |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 创建矩阵的副本 |'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Create a copy of the matrix (with optional mask) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 创建矩阵的副本（可选掩码） |'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Reference a submatrix |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 引用子矩阵 |'
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Create a new matrix from a submatrix (that is, image crop) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 从子矩阵创建新矩阵（即图像裁剪） |'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Note the difference in the last two rows: in the last row, a new matrix is
    created. The case of the penultimate row only creates a reference to a submatrix
    within `src`, but data is not actually copied.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后两行的区别：在最后一行中，创建了一个新的矩阵。在倒数第二行的情况下，仅创建了对`src`中子矩阵的引用，但数据实际上并未复制。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The most common operations, including additional iterator-based pixel access
    methods, are summarized in the *OpenCV 2.4 Cheat Sheet*, which can be downloaded
    from [http://docs.opencv.org/trunk/opencv_cheatsheet.pdf](http://docs.opencv.org/trunk/opencv_cheatsheet.pdf).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的操作，包括基于迭代器的额外像素访问方法，总结在*OpenCV 2.4 快速参考卡*中，可以从[http://docs.opencv.org/trunk/opencv_cheatsheet.pdf](http://docs.opencv.org/trunk/opencv_cheatsheet.pdf)下载。
- en: Image histogram
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像直方图
- en: An image histogram represents the frequency of the occurrence of the various
    gray levels or colors in the image, in case of 2D and 3D histograms respectively.
    Therefore, the histogram is similar to the probability density function of the
    different pixel values, that is, the gray levels, present in the image. In OpenCV,
    the image histogram may be calculated with the function `void calcHist(const Mat*
    images, int nimages, const int* channels, InputArray mask, OutputArray hist, int
    dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false)`.
    The first parameter is a pointer to the input image. It is possible to calculate
    the histogram of more than one input image. This allows you to compare image histograms
    and calculate the joint histogram of several images. The second parameter is the
    number of source images. The third input parameter is the list of the channels
    used to compute the histogram. It is possible to calculate the histogram of more
    than one channel of the same color image. Thus, in this case, the `nimages` value
    will be 1 and the `const int* channels` parameter will be an array with the list
    of channel numbers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图像直方图表示图像中各种灰度级别或颜色的出现频率，对于二维和三维直方图分别如此。因此，直方图类似于图像中不同像素值（即灰度级别）的概率密度函数。在 OpenCV
    中，可以使用函数 `void calcHist(const Mat* images, int nimages, const int* channels, InputArray
    mask, OutputArray hist, int dims, const int* histSize, const float** ranges, bool
    uniform=true, bool accumulate=false)` 计算图像直方图。第一个参数是指向输入图像的指针。可以计算多个输入图像的直方图。这允许你比较图像直方图并计算多个图像的联合直方图。第二个参数是源图像的数量。第三个输入参数是用于计算直方图的通道列表。可以计算同一颜色图像的多个通道的直方图。因此，在这种情况下，`nimages`
    的值将是 1，而 `const int* channels` 参数将是一个包含通道号的数组。
- en: The number of channels goes from zero to two. The parameter `InputArray mask`
    is an optional mask to indicate the array elements (image pixels) counted in the
    histogram. The fifth parameter is the output histogram. The parameter `int dims`
    is the histogram dimensionality that must be positive and not greater than 32
    (`CV_MAX_DIMS`). A histogram can be *n*-dimensional according to the number of
    bins used to quantize the pixel values of the image. The parameter `const int*
    histSize` is the array of histogram sizes in each dimension. It allows us to compute
    histograms with non-uniform binning (or quantification). The `const float** ranges`
    parameter is the array of the `dims` arrays of the histogram bin boundaries in
    each dimension. The last two parameters have Boolean values and by default are
    `true` and `false` respectively. They indicate that the histogram is uniform and
    non-accumulative.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通道数从零到二。参数 `InputArray mask` 是一个可选的掩码，用于指示直方图中计数的数组元素（图像像素）。第五个参数是输出直方图。参数 `int
    dims` 是直方图的维数，必须是正数且不超过 32 (`CV_MAX_DIMS`)。直方图可以是 *n*-维的，根据用于量化图像像素值的箱子数量。参数 `const
    int* histSize` 是每个维度的直方图大小的数组。它允许我们计算具有非均匀箱子（或量化）的直方图。参数 `const float** ranges`
    是每个维度的直方图箱子边界的 `dims` 数组的数组。最后两个参数具有布尔值，默认分别为 `true` 和 `false`。它们表示直方图是均匀的且非累积的。
- en: 'The following `ImgHisto` example shows how to calculate and display the one-dimensional
    histogram of a 2D image:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `ImgHisto` 示例展示了如何计算和显示二维图像的一维直方图：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code explanation is given here: the example creates three windows with
    the source image, the grayscale image, and the result of the 1D histogram. The
    1D histogram is shown as a bar diagram for the 255 gray values. Thus, first the
    color pixels are converted into gray values using the `cvtColor` function. The
    gray values are then normalized using the `normalize` function between 0 and the
    maximum gray level value. Then the 1D histogram is calculated by discretizing
    the colors in the image into a number of bins and counting the number of image
    pixels in each bin. The following screenshot shows the output of the example.
    Note that a new include file, `imgproc.hpp`, dedicated to image processing is
    needed.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：示例创建了三个窗口，分别显示源图像、灰度图像和一维直方图的结果。一维直方图以条形图的形式显示了 255 个灰度值。因此，首先使用 `cvtColor`
    函数将颜色像素转换为灰度值。然后使用 `normalize` 函数将灰度值归一化到 0 和最大灰度级别值之间。然后通过将图像中的颜色离散化到多个箱子中并计算每个箱子中的图像像素数量来计算一维直方图。以下截图显示了示例的输出。请注意，需要一个专门用于图像处理的新的包含文件
    `imgproc.hpp`。
- en: '![Image histogram](img/00013.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图像直方图](img/00013.jpeg)'
- en: Output of the histogram example
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图示例输出
- en: Histogram equalization
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: Once the image histogram is calculated, it can be modelled so that the image
    is modified and the histogram has a different shape. This is useful to change
    the low-contrast levels of images with narrow histograms, since this will spread
    out the gray levels and thus enhance the contrast. Histogram modeling, also known
    as histogram transfer, is a powerful technique for image enhancement. In histogram
    equalization, the goal is to obtain a uniform histogram for the output image.
    That is, a flat histogram where each pixel value has the same probability. In
    OpenCV, histogram equalization is performed with the function `void equalizeHist(InputArray
    src, OutputArray dst)`. The first parameter is the input image and the second
    one is the output image with the histogram equalized.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算了图像直方图，就可以对其进行建模，以便修改图像并使直方图具有不同的形状。这对于改变具有狭窄直方图的图像的低对比度级别很有用，因为这会将灰度级别分散开来，从而增强对比度。直方图建模，也称为直方图转换，是图像增强的一种强大技术。在直方图均衡化中，目标是获得输出图像的均匀直方图。也就是说，一个平坦的直方图，其中每个像素值具有相同的概率。在OpenCV中，直方图均衡化是通过函数
    `void equalizeHist(InputArray src, OutputArray dst)` 来实现的。第一个参数是输入图像，第二个参数是具有均衡化直方的输出图像。
- en: 'The following `EqualizeHist_Demo` example shows how to calculate and display
    the histogram equalized and the effect on the two-dimensional image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `EqualizeHist_Demo` 示例展示了如何计算和显示直方图均衡化及其对二维图像的影响：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code explanation is given as follows. The example first reads the original
    image and converts it to grayscale. Then, histogram equalization is performed
    using the `equalizeHist` function. Finally, the histogram of the equalized image
    is shown together with the two previous images. The following screenshot shows
    the output of the example, where three windows are created with the grayscale
    image, the equalized image, and its histogram:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码的解释。示例首先读取原始图像并将其转换为灰度图。然后，使用 `equalizeHist` 函数执行直方图均衡化。最后，显示均衡化图像的直方图以及前两个图像。以下截图显示了示例的输出，其中创建了三个窗口，分别显示灰度图像、均衡化图像及其直方图：
- en: '![Histogram equalization](img/00014.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![直方图均衡化](img/00014.jpeg)'
- en: Output of the histogram equalization example
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图均衡化示例的输出
- en: Brightness and contrast modeling
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亮度和对比度建模
- en: The brightness of an object is the perceived luminance or intensity and depends
    on the luminance of the environment. Two objects in different environments could
    have the same luminance but different brightness. The reason is that the human
    visual perception is sensitive to luminance contrast rather than absolute luminance.
    Contrast is the difference in luminance and/or color that makes an object distinguishable
    compared to other objects within the same field of view. The maximum contrast
    of an image is known as the contrast ratio or dynamic range.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的亮度是感知的亮度或强度，并取决于环境的亮度。在不同环境中，两个物体可能具有相同的亮度但不同的亮度。原因是人类视觉感知对亮度对比度敏感，而不是绝对亮度。对比度是亮度以及/或颜色之间的差异，使得物体在相同视野内的其他物体中可区分。图像的最大对比度称为对比度比或动态范围。
- en: It is possible to modify the brightness and contrast of an image by means of
    point-wise operations. Point operations map a given gray pixel value into a different
    gray level according to a transform previously defined. In OpenCV, point operations
    may be performed with the function `void Mat::convertTo(OutputArray m, int rtype,
    double alpha=1, double beta=0)`. The `convertTo` function converts an image array
    to another data type with optional scaling. The first parameter is the output
    image and the second parameter is the output matrix type, that is, the depth,
    since the number of channels is the same as the input image. Thus, the source
    pixel values `I(x,y)` are converted to the target data type with the new value
    `(I(x,y) * alpha + beta)`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点操作可以修改图像的亮度和对比度。点操作根据预先定义的转换将给定的灰度像素值映射到不同的灰度级别。在OpenCV中，可以使用函数 `void Mat::convertTo(OutputArray
    m, int rtype, double alpha=1, double beta=0)` 来执行点操作。`convertTo` 函数可以将图像数组转换为另一种数据类型，并可选择缩放。第一个参数是输出图像，第二个参数是输出矩阵类型，即深度，因为通道数与输入图像相同。因此，源像素值
    `I(x,y)` 被转换为具有新值 `(I(x,y) * alpha + beta)` 的目标数据类型。
- en: 'The following `BrightnessContrast` example shows how to perform an image pixel
    (point) operation to modify brightness and contrast:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `BrightnessContrast` 示例展示了如何执行图像像素（点）操作以修改亮度和对比度：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code explanation is given here: the example creates two windows with the
    grayscale image and its histogram. The new values for the brightness and contrast
    are selected by the user using the function `createTrackbar`. This function attaches
    two sliders or range controls to the image for brightness and contrast. The following
    screenshot shows the output of the `BrightnessContrast` example for a value of
    148 for brightness and 81 for contrast:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：示例创建两个窗口，一个用于灰度图像及其直方图。用户通过`createTrackbar`函数选择亮度和对比度的新值。此函数将两个滑块或范围控件附加到图像上，用于亮度和对比度。以下截图显示了`BrightnessContrast`示例的输出，亮度值为148，对比度值为81：
- en: '![Brightness and contrast modeling](img/00015.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![亮度对比度建模](img/00015.jpeg)'
- en: Output of the brightness and contrast image modification
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 亮度对比度图像修改的输出
- en: Histogram matching and LUT
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图匹配和查找表
- en: The histogram may also be used to modify the color of an image. Histogram matching
    is a method of color adjustment between two color images. Given a reference image
    and a target image, the result (destination image) will be equal to the target
    image except that its (three) histograms will look like those of the reference
    image. This effect is known as **color mapping** or **color transfer**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图还可以用于修改图像的颜色。直方图匹配是两种颜色图像之间颜色调整的方法。给定一个参考图像和一个目标图像，结果（目标图像）将与目标图像相等，除了其（三个）直方图将看起来像参考图像的直方图。这种效果被称为**颜色映射**或**颜色传递**。
- en: The histogram matching algorithm is run over each of the three color histograms
    independently. For each channel, the **cumulative distribution function** (**cdf**)
    has to be calculated. For a given channel, let `Fr` be the cdf of the reference
    image and `Ft` be the cdf of the target image. Then, for each pixel `v` in the
    reference image, we find the gray level `w`, for which `Fr(v)=Ft(w)`. The pixel
    with value `v` is thus changed to `w`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图匹配算法独立运行在每个三个颜色直方图上。对于每个通道，必须计算累积分布函数（CDF）。对于给定的通道，设`Fr`为参考图像的CDF，`Ft`为目标图像的CDF。然后，对于参考图像中的每个像素`v`，我们找到灰度级`w`，使得`Fr(v)=Ft(w)`。因此，具有值`v`的像素被更改为`w`。
- en: Next, we provide another example of histograms in which we use a technique called
    histogram matching. The example also uses **look-up tables** (**LUT**). A look-up
    table transformation assigns a new pixel value to each pixel in the input image
    (there is a good explanation and example of an LUT at [http://docs.opencv.org/doc/tutorials/core/how_to_scan_images/how_to_scan_images.html](http://docs.opencv.org/doc/tutorials/core/how_to_scan_images/how_to_scan_images.html)).
    The new values are given by a table. Thus, the first entry in this table gives
    the new value for pixel value 0, the second the new value for pixel value 1, and
    so on. Assuming we use a source and destination image, the transform is then given
    by `Dst(x,y)=LUT(Src(x,y))`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供另一个使用直方图的示例，其中我们使用一种称为直方图匹配的技术。该示例还使用了**查找表（LUT**）。查找表变换将新的像素值分配给输入图像中的每个像素（有关LUT的详细解释和示例，请参阅[http://docs.opencv.org/doc/tutorials/core/how_to_scan_images/how_to_scan_images.html](http://docs.opencv.org/doc/tutorials/core/how_to_scan_images/how_to_scan_images.html)）。新值由一个表给出。因此，该表的第一项给出像素值0的新值，第二项给出像素值1的新值，依此类推。假设我们使用源图像和目标图像，变换由`Dst(x,y)=LUT(Src(x,y))`给出。
- en: The OpenCV function for performing a look-up table transformation is `LUT(InputArray
    src, InputArray lut, OutputArray dst, int interpolation=0)`. The parameter `src`
    is an 8-bit image. The table is given in the parameter `lut`, which has 256 elements.
    The table has either one channel or the same number of channels as the source
    image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV执行查找表变换的函数是`LUT(InputArray src, InputArray lut, OutputArray dst, int interpolation=0)`。参数`src`是一个8位图像。表由参数`lut`给出，它包含256个元素。表包含一个通道或与源图像相同数量的通道。
- en: 'The following is the `histMatching` example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`histMatching`示例：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code explanation is given here: the example first reads the reference and
    target images. The output image is also allocated. The main function is `histMatch`.
    In it, the reference and target images are first split into the three color channels.
    Then, for every channel, we obtain the normalized histograms of reference and
    target images, followed by the respective cdfs. Next, the histogram matching transformation
    is performed.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：示例首先读取参考图像和目标图像。输出图像也被分配。主函数是`histMatch`。在其中，参考图像和目标图像首先被分割成三个颜色通道。然后，对于每个通道，我们获得参考图像和目标图像的归一化直方图，接着是相应的累积分布函数（CDF）。接下来，执行直方图匹配变换。
- en: Finally, we apply the new pixel values using the look-up table. Note that the
    transformation could also be applied by iterating over every pixel in the result
    image. The look-up table option is, however, much faster. The following screenshot
    shows the output of the sample. The color palette of the reference image (the
    `baboon.jpg` image) is transferred to the target image.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用查找表应用新的像素值。请注意，该转换也可以通过遍历结果图像中的每个像素来应用。然而，查找表选项要快得多。以下截图显示了样本的输出。参考图像（`baboon.jpg`图像）的颜色调色板被转移到目标图像中。
- en: '![Histogram matching and LUT](img/00016.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![直方图匹配和查找表](img/00016.jpeg)'
- en: Output of the histMatching example
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: histMatching示例的输出
- en: Conversion from RGB to other color spaces
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从RGB转换为其他颜色空间
- en: The color of an image may also be modified by changing the color space. In OpenCV,
    six color models are available and it is possible to convert from one to another
    by using the `cvtColor` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改颜色空间，图像的颜色也可能被修改。在OpenCV中，有六个颜色模型可用，并且可以使用`cvtColor`函数从一种转换为另一种。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default color format in OpenCV is often referred to as RGB but it is actually
    BGR (the channels are reversed).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中的默认颜色格式通常被称为RGB，但实际上是BGR（通道已反转）。
- en: The function `void cvtColor(InputArray src, OutputArray dst, int code, int dstCn=0)`
    has the input and output images as the first and second parameters. The third
    parameter is the color space conversion code and the last parameter is the number
    of channels in the output image; if this parameter is 0, the number of channels
    is obtained automatically from the input image.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `void cvtColor(InputArray src, OutputArray dst, int code, int dstCn=0)` 的输入和输出图像分别作为第一和第二个参数。第三个参数是颜色空间转换代码，最后一个参数是输出图像中的通道数；如果此参数为0，则自动从输入图像中获取通道数。
- en: 'The following `color_channels` example shows how to convert from RGB to HSV,
    Luv, Lab, YCrCb, and XYZ color spaces:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`color_channels`示例显示了如何将RGB转换为HSV、Luv、Lab、YCrCb和XYZ颜色空间：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code explanation is given here: the first example reads the original image
    and makes the conversion into five different color models. The original image
    in RGB and the results are then displayed. The following screenshot shows the
    output of the sample:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：第一个示例读取原始图像并将其转换为五种不同的颜色模型。然后显示RGB原始图像和结果。以下截图显示了样本的输出：
- en: '![Conversion from RGB to other color spaces](img/00017.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![从RGB转换为其他颜色空间](img/00017.jpeg)'
- en: Output of the different color spaces
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不同颜色空间的输出
- en: Filtering with the retina model
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视网膜模型进行滤波
- en: Image restoration is concerned with filtering the digital image to minimize
    the effect of degradations. Degradation is produced by the sensing environment
    during image acquisition by optical or electronic devices. The effectiveness of
    image filtering depends on the extent and the accuracy of the knowledge of the
    degradation process as well as on the filter design.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图像恢复涉及通过滤波数字图像以最小化退化效果。退化是在图像获取过程中由光学或电子设备中的传感环境产生的。图像滤波的有效性取决于对退化过程的了解程度和准确性以及滤波器设计。
- en: In OpenCV, there are several isotropic and anisotropic filters available operating
    on both spatial and frequency domains. One of the most recent filters is the retina
    filter, which is based on a model of the human visual system. There is a class
    named `Retina` to perform spatio-temporal filtering modeling the two main retina
    information channels, which are **parvocellular** (`parvo`) due to foveal vision
    and **magnocellular** (`magno`) due to peripheral vision. The `parvo` channel
    is related to detail extraction while the `magno` channel is dedicated to motion
    analysis.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV中，有几种各向同性滤波器和各向异性滤波器可用于空间和频率域。其中最新的一种滤波器是视网膜滤波器，它基于人类视觉系统的模型。有一个名为`Retina`的类来执行时空滤波建模，模拟两个主要的视网膜信息通道，即由于黄斑视觉而称为**小细胞**（`parvo`）和由于周边视觉而称为**大细胞**（`magno`）。`parvo`通道与细节提取相关，而`magno`通道专门用于运动分析。
- en: 'The `Retina` class may be applied on still images, images sequences, and video
    sequences to perform motion analysis. Here we present a simplified version of
    the `retinademo` algorithm provided in OpenCV. The algorithm `Filter_Retina.cpp`
    presented here demonstrates the use of the retina model images, which can be used
    to perform texture analysis with enhanced signal-to-noise ratio and enhanced details
    that are robust against input image luminance ranges. The main properties of the
    human retina model are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Retina` 类可以应用于静态图像、图像序列和视频序列以执行运动分析。在此，我们展示了 OpenCV 中提供的简化版 `retinademo` 算法。这里展示的
    `Filter_Retina.cpp` 算法演示了视网膜模型图像的使用，可用于执行具有增强信噪比和增强细节的纹理分析，这些细节对输入图像亮度范围具有鲁棒性。人类视网膜模型的主要特性如下：'
- en: Spectral whitening (mid-frequency detail enhancement)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频谱白化（中频细节增强）
- en: High-frequency spatio-temporal noise reduction (temporal noise and high-frequency
    spatial noise are minimized)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高频时空噪声降低（时间噪声和高频空间噪声最小化）
- en: 'Low-frequency luminance reduction (luminance range compression): High-luminance
    regions do not hide details in darker regions anymore'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低频亮度降低（亮度范围压缩）：高亮度区域不再隐藏较暗区域的细节
- en: Local logarithmic luminance compression allows details to be enhanced even in
    low-light conditions
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部对数亮度压缩允许在低光照条件下增强细节
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, refer to *Using Human Visual System Modeling for bio-inspired
    low level image processing, Benoit A., Caplier A., Durette B., Herault J.,* Elsevier,
    Computer Vision and Image Understanding 114 (2010), pp. 758-773\. DOI at [http://dx.doi.org/10.1016/j.cviu.2010.01.011](http://dx.doi.org/10.1016/j.cviu.2010.01.011).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 *《利用人类视觉系统建模进行生物启发式低级图像处理》，作者：Benoit A.，Caplier A.，Durette B.，Herault
    J.，Elsevier，计算机视觉与图像理解 114 (2010)，第 758-773 页。DOI：[http://dx.doi.org/10.1016/j.cviu.2010.01.011](http://dx.doi.org/10.1016/j.cviu.2010.01.011)。
- en: 'The following is the code for the example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为示例代码：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code explanation is given here: the example first reads the input image
    and obtains the retina model of the image using classical parameters for the model.
    The retina can be settled up with various parameters; by default, the retina cancels
    mean luminance and enforces all details of the visual scene. The filter is then
    run five times and the `parvo` and `magno` images and its details are shown. The
    following screenshot shows the output of the retina model filter after the five
    iterations:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：示例首先读取输入图像，并使用模型的经典参数获取图像的视网膜模型。视网膜可以用各种参数设置；默认情况下，视网膜取消平均亮度并强制所有视觉场景的细节。然后，过滤器运行五次，并显示
    `parvo` 和 `magno` 图像及其细节。以下截图显示了五次迭代后视网膜模型滤波器的输出：
- en: '![Filtering with the retina model](img/00018.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用视网膜模型进行过滤](img/00018.jpeg)'
- en: Output of the retina filter after five iterations
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 五次迭代后视网膜滤波器的输出
- en: Arithmetic and geometrical transforms
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术和几何变换
- en: An arithmetic transform changes the value of an image pixel and it is applied
    point to point, whereas a geometrical transform changes the position of the image
    pixels. Thus, points in an image get a new position in the output image without
    changing their intensity values. Examples of arithmetic transforms may be addition,
    subtraction, and division between images. Examples of geometrical transforms are
    scaling, translation, and rotation of images. More complex transformations are
    to solve the barrel and cushion deformations of an image produced by an optical
    lens.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 算术变换会改变图像像素的值，并且是点对点应用，而几何变换会改变图像像素的位置。因此，图像中的点在输出图像中获得新的位置，而不会改变它们的强度值。算术变换的例子可能包括图像之间的加法、减法和除法。几何变换的例子包括图像的缩放、平移和旋转。更复杂的变换是解决由光学镜头产生的图像的桶形和垫形变形。
- en: In OpenCV, there are several functions to perform arithmetic and geometrical
    transforms. Here we show two examples for image addition and perspective transformation
    by means of the functions `addWeighted` and `warpPerspective` respectively.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenCV 中，有几个函数可以执行算术和几何变换。这里我们展示了两个示例，通过 `addWeighted` 和 `warpPerspective`
    函数分别实现图像加法和透视变换。
- en: Arithmetic transform
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术变换
- en: The function `addWeighted` performs a linear combination of two images, that
    is, addition of two weighted images to carry out a linear blending. The function
    `void addWeighted(InputArray src1, double alpha, InputArray src2, double beta,
    double gamma, OutputArray dst, int dtype=-1)` has two input images as the first
    and third parameters with their weights (second and fourth parameter). Then, the
    output image is the sixth parameter. The fifth parameter, `gamma`, is a scalar
    added to each sum. The last parameter `dtype` is optional and refers to the depth
    of the output image; when both input images have the same depth, it can be set
    to `-1`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `addWeighted` 执行两个图像的线性组合，即通过将两个加权图像相加来实现线性混合。函数 `void addWeighted(InputArray
    src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst,
    int dtype=-1)` 有两个输入图像作为第一和第三个参数，它们具有相应的权重（第二个和第四个参数）。然后，输出图像是第六个参数。第五个参数 `gamma`
    是加到每个和上的标量。最后一个参数 `dtype` 是可选的，表示输出图像的深度；当两个输入图像具有相同的深度时，它可以设置为 `-1`。
- en: 'The following `LinearBlend` example shows how to perform a linear blending
    between two images:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `LinearBlend` 示例展示了如何执行两个图像之间的线性混合：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code explanation is given here: the example first reads two images, `src1=
    baboon.jpg` and `src2= lena.jpg`, and then performs a total of 101 linear combinations
    with different values of the weights `alpha` and `beta`. The first linear combination
    or blend is with `alpha` equal to zero, and therefore it is the `src1` image.
    The value of `alpha` increases in the loop while the value of `beta` decreases.
    Therefore, the `src2` image is combined and superimposed onto the `src1` image.
    This produces a morphing effect and the `baboon.jpg` image gradually changes into
    a different image, that is, into `lena.jpg`. The following screenshot shows the
    output of several linear blending steps at iterations `1`, `10`, `20`, `30`, `40`,
    `50`, `70`, `85`, and `100`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：示例首先读取两个图像，`src1= baboon.jpg` 和 `src2= lena.jpg`，然后使用不同的权重 `alpha` 和
    `beta` 值进行总共 101 次线性组合。第一次线性组合或混合时 `alpha` 等于零，因此是 `src1` 图像。在循环中 `alpha` 的值增加，而
    `beta` 的值减少。因此，`src2` 图像被组合并叠加到 `src1` 图像上。这产生了一种变形效果，`baboon.jpg` 图像逐渐变成另一幅图像，即
    `lena.jpg`。以下截图显示了迭代 `1`、`10`、`20`、`30`、`40`、`50`、`70`、`85` 和 `100` 时几个线性混合步骤的输出：
- en: '![Arithmetic transform](img/00019.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![算术变换](img/00019.jpeg)'
- en: Output of different lineal blending between two images
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 两种图像之间不同线性混合的输出
- en: Geometrical transforms
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何变换
- en: The function `warpPerspective, void ocl::warpPerspective(const oclMat& src,
    oclMat& dst, const Mat& M, Size dsize, int flags=INTER_LINEAR)` performs a perspective
    transformation on an image. It has the input or source image `src` as the first
    parameter and the output or destination image `dst` as the second parameter. Then,
    the third parameter is a 2 x 3 transformation matrix obtained from the `getPerspectiveTransform`
    function, which calculates a perspective transform from the positions of four
    points in the two images in four pairs of corresponding points. The fourth parameter
    of `warpPerspective` is the size of the output image and the last parameter is
    the interpolation method. By default, the interpolation method is linear, `INTER_LINEAR`;
    other methods supported are nearest neighbor `INTER_NEAREST` and cubic `INTER_CUBIC`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `warpPerspective, void ocl::warpPerspective(const oclMat& src, oclMat& dst,
    const Mat& M, Size dsize, int flags=INTER_LINEAR)` 对图像执行透视变换。它将输入或源图像 `src` 作为第一个参数，将输出或目标图像
    `dst` 作为第二个参数。然后，第三个参数是从 `getPerspectiveTransform` 函数获得的 2 x 3 变换矩阵，该函数从两个图像中四对对应点的位置计算透视变换。`warpPerspective`
    的第四个参数是输出图像的大小，最后一个参数是插值方法。默认情况下，插值方法是线性插值，`INTER_LINEAR`；支持的其他方法包括最近邻插值 `INTER_NEAREST`
    和三次插值 `INTER_CUBIC`。
- en: The following `Geometrical_Transform` example performs a perspective transformation
    to the input image `img.jpg`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `Geometrical_Transform` 示例对输入图像 `img.jpg` 执行透视变换。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For full details of the example, refer to *N. Amin*, *Automatic perspective
    correction for quadrilateral objects*, at [https://opencv-code.com/tutorials/automatic-perspective-correction-for-quadrilateral-objects/](https://opencv-code.com/tutorials/automatic-perspective-correction-for-quadrilateral-objects/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关示例的完整细节，请参阅 *N. Amin* 的 *四边形对象的自动透视校正*，链接为 [https://opencv-code.com/tutorials/automatic-perspective-correction-for-quadrilateral-objects/](https://opencv-code.com/tutorials/automatic-perspective-correction-for-quadrilateral-objects/)。
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code explanation is given here: the example first reads the input image
    (`img.jpg`) and calculates the key points of the region of interest or object
    to perform the perspective transformation. The key points are the corner points
    of the object. The algorithm only works for quadrilateral objects. The methods
    to calculate corners (Canny operator and Hough transforms) are explained in [Chapter
    4](part0035_split_000.html#page "Chapter 4. What''s in the Image? Segmentation"),
    *What''s in the Image, Segmentation*. The points corresponding to the object corners
    are the corners of the output image. These points are shown with circles on the
    original image. The dimension of the output image is set to the same height and
    half the width of the input image. Finally, the image with the corrected object
    is visualized. The perspective correction uses a linear transform, `INTER_LINEAR`.
    The following screenshot shows the output of the algorithm:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：示例首先读取输入图像（`img.jpg`）并计算感兴趣区域或对象的特征点以执行透视变换。特征点是对象的角点。该算法仅适用于四边形对象。计算角点的方法（Canny算子和霍夫变换）在[第4章](part0035_split_000.html#page
    "第4章. 图像中的内容？分割")*图像中的内容，分割*中进行了说明。对应于对象角点的点是输出图像的角点。这些点在原始图像上用圆圈表示。输出图像的尺寸设置为与输入图像相同的高度和宽度的一半。最后，可视化校正后的对象图像。透视校正使用线性变换，`INTER_LINEAR`。以下截图显示了算法的输出：
- en: '![Geometrical transforms](img/00020.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![几何变换](img/00020.jpeg)'
- en: Output of the geometrical transform performed to correct the perspective
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对透视进行校正所执行的几何变换的输出
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered the most common image processing methods used in computer
    vision. Image processing is often the step performed just before further computer
    vision applications. It has many methods and is usually applied for image corrections
    and enhancement such as image histograms, image equalization, brightness and contrast
    modeling, image color conversion by means of histogram matching and color space
    transformations, filtering using the model of the human retina, and arithmetic
    and geometrical transforms.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了计算机视觉中最常用的图像处理方法。图像处理通常是进行进一步计算机视觉应用之前的步骤。它有许多方法，通常用于图像校正和增强，例如图像直方图、图像均衡化、亮度与对比度建模、通过直方图匹配和颜色空间转换进行图像颜色转换、使用人眼视网膜模型进行滤波，以及算术和几何变换。
- en: The next chapter will cover the next stage in a computer vision system, that
    is, the segmentation process. We will see how to extract regions of interest within
    an image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍计算机视觉系统中的下一个阶段，即分割过程。我们将看到如何从图像中提取感兴趣区域。
- en: What else?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有什么？
- en: 'Other important functions in OpenCV for image processing are related to filtering.
    These functions have been omitted in the chapter since they are straightforward.
    OpenCV includes an example that shows how to use the main filters `([opencv_source_code]/samples/cpp/filter2D_demo.cpp`).
    The main filter functions are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中与图像处理相关的其他重要函数与滤波有关。由于它们很简单，这些函数在章节中已被省略。OpenCV包括一个示例，展示了如何使用主要滤波器（`([opencv_source_code]/samples/cpp/filter2D_demo.cpp`）。主要的滤波器函数包括：
- en: '`GaussianBlur` for a Gaussian filter'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GaussianBlur` 用于高斯滤波'
- en: '`medianBlur` for a median filter'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`medianBlur` 用于中值滤波'
- en: '`bilateralFilter` for anisotropic filtering'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bilateralFilter` 用于各向异性滤波'
- en: '`blur` for a homogeneous blur'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur` 用于均匀模糊'
