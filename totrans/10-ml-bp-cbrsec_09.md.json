["```py\npip install torch\npip install -q torch-scatter -f https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html\npip install -q torch-sparse -f https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html\npip install -q git+https://github.com/rusty1s/pytorch_geometric.git\n```", "```py\nimport torch\nimport torch_geometric\nversion = torch.__version__\nprint(\"Torch version is {}\".format(version))\n```", "```py\nfrom torch_geometric.datasets import UPFD\nDATA_ROOT = \"/content/FakeNewsNet/dataset\"\ntrain_data = UPFD(root = DATA_ROOT,\n                  name=\"gossipcop\", feature=\"content\",\n                  split=\"train\")\ntest_data = UPFD(root = DATA_ROOT,\n                 name=\"gossipcop\", feature=\"content\",\n                 split=\"test\")\n```", "```py\nprint(\"# Training Examples: {}\".format(len(train_data)))\nprint(\"# Test Examples: {}\".format(len(test_data)))\n```", "```py\n# Training Examples: 1092\n# Test Examples: 3826\n```", "```py\ntrain_data[0]\nData(x=[76, 310], edge_index=[2, 75], y=[1])\n```", "```py\npip install networkx\n```", "```py\nnx.draw(to_networkx(train_data[1]))\n```", "```py\ndef to_networkx(data, node_attrs=None, edge_attrs=None, to_undirected=False,\n                remove_self_loops=False):\n    if to_undirected:\n        G = nx.Graph()\n    else:\n        G = nx.DiGraph()\n    G.add_nodes_from(range(data.num_nodes))\n    node_attrs, edge_attrs = node_attrs or [], edge_attrs or []\n    values = {}\n    for key, item in data(*(node_attrs + edge_attrs)):\n        if torch.is_tensor(item):\n            values[key] = item.squeeze().tolist()\n        else:\n            values[key] = item\n        if isinstance(values[key], (list, tuple)) and len(values[key]) == 1:\n            values[key] = item[0]\n    for i, (u, v) in enumerate(data.edge_index.t().tolist()):\n        if to_undirected and v > u:\n            continue\n        if remove_self_loops and u == v:\n            continue\n        G.add_edge(u, v)\n        for key in edge_attrs:\n            G[u][v][key] = values[key][i]\n    for key in node_attrs:\n        for i, feat_dict in G.nodes(data=True):\n            feat_dict.update({key: values[key][i]})\n    return G\n```", "```py\nfrom torch_geometric.loader import DataLoader\ntrain_loader = DataLoader(train_data, batch_size=128, shuffle=True)\ntest_loader = DataLoader(test_data, batch_size=128, shuffle=False)\n```", "```py\nfrom torch_geometric.nn import global_max_pool as gmp\nfrom torch_geometric.nn import GATConv\nfrom torch.nn import Linear\nclass GNN(torch.nn.Module):\n    def __init__(self,\n                 n_in, n_hidden, n_out):\n        super().__init__()\n        # Graph Convolutions\n        self.convolution_1 = GATConv(n_in, n_hidden)\n        self.convolution_2 = GATConv(n_hidden, n_hidden)\n        self.convolution_3 = GATConv(n_hidden, n_hidden)\n        # Readout Layers\n        # For news features\n        self.lin_news = Linear(n_in, n_hidden)\n        # For processing graph features\n        self.lin0 = Linear(n_hidden, n_hidden)\n        # For pre-final layer for softmax\n        self.lin1 = Linear(2*n_hidden, n_out)\n    def forward(self, x, edge_index, batch):\n        # Graph Convolutions\n        h = self.conv1(x, edge_index).relu()\n        h = self.conv2(h, edge_index).relu()\n        h = self.conv3(h, edge_index).relu()\n        # Pooling\n        h = gmp(h, batch)\n        # Readout\n        h = self.lin0(h).relu()\n        # Following the UPFD paper, we include raw word2vec embeddings of news\n        root = (batch[1:] - batch[:-1]).nonzero(as_tuple=False).view(-1)\n        root = torch.cat([root.new_zeros(1), root + 1], dim=0)\n        news = x[root]\n        news = self.lin_news(news).relu()\n        out = self.lin1(torch.cat([h, news], dim=-1))\n        return torch.sigmoid(out)\n```", "```py\nif torch.cuda.is_available():\n  device = 'cuda'\nelse:\n  device = 'cpu'\nmodel = GNN(train_data.num_features, 128, 1).to(device)\noptimizer = torch.optim.Adam(model.parameters(),\n                            lr=0.01, weight_decay=0.01)\nloss_fnc = torch.nn.BCELoss()\n```", "```py\ndef train(epoch):\n    model.train()\n    total_loss = 0\n    for data in train_loader:\n        data = data.to(device)\n        optimizer.zero_grad()\n        out = model(data.x, data.edge_index, data.batch)\n        loss = loss_fnc(torch.reshape(out, (-1,)), data.y.float())\n        loss.backward()\n        optimizer.step()\n        total_loss += float(loss)   data.num_graphs\n    return total_loss / len(train_loader.dataset)\n```", "```py\nfrom sklearn.metrics import accuracy_score, f1_score\ndef metrics(predicted, actuals):\n    preds = torch.round(torch.cat(predicted))\n    acts = torch.cat(actuals)\n    acc = accuracy_score(preds, acts)\n    f1 = f1_score(preds, acts)\n    return acc, f1\n```", "```py\n@torch.no_grad()\ndef test(epoch):\n    model.eval()\n    total_loss = 0\n    all_preds = []\n    all_labels = []\n    for data in test_loader:\n        data = data.to(device)\n        out = model(data.x, data.edge_index, data.batch)\n        loss = loss_fnc(torch.reshape(out, (-1,)), data.y.float())\n        total_loss += float(loss)   data.num_graphs\n        all_preds.append(torch.reshape(out, (-1,)))\n        all_labels.append(data.y.float())\n    # Calculate Metrics\n    accuracy, f1 = metrics(all_preds, all_labels)\n    avg_loss = total_loss/len(test_loader.dataset)\n    return avg_loss, accuracy, f1\n```", "```py\nNUM_EPOCHS = 50\ntrain_losses = []\ntest_losses = []\nfor epoch in range(NUM_EPOCHS):\n    train_loss = train(epoch)\n    test_loss, test_acc, test_f1 = test(epoch)\n    train_losses.append(train_loss)\n    test_losses.append(test_loss)\n    print(f'Epoch: {epoch:04d}  ==  Training Loss: {train_loss:.4f}  ==  '\n          f'TestLoss: {test_loss:.4f}  ==  TestAcc: {test_acc:.4f}  ==  TestF1: {test_f1:.4f}')\n```", "```py\nimport matplotlib.pyplot as plt\nplt.plot(list(range(NUM_EPOCHS)),\n      train_losses,\n      color = 'blue', label = 'Training Loss')\nplt.plot(list(range(NUM_EPOCHS)),\n      test_losses,\n      color = 'red', label = 'Test Loss')\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"Loss\")\nplt.legend()\n```"]