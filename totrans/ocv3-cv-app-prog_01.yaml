- en: Chapter 1. Playing with Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 玩转图像
- en: 'In this chapter, we will get you started with the **OpenCV** library. You will
    learn how to perform the following tasks:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带你开始使用 **OpenCV** 库。你将学习如何执行以下任务：
- en: Installing the OpenCV library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 OpenCV 库
- en: Loading, displaying, and saving images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载、显示和保存图像
- en: Exploring the `cv::Mat` data structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `cv::Mat` 数据结构
- en: Defining regions of interest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义感兴趣的区域
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'This chapter will teach you the basic elements of OpenCV and will show you
    how to accomplish the most fundamental image processing tasks: reading, displaying,
    and saving images. However, before you start with OpenCV, you need to install
    the library. This is a simple process that is explained in the first recipe of
    this chapter.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这章将教你 OpenCV 的基本元素，并展示如何完成最基本图像处理任务：读取、显示和保存图像。然而，在开始使用 OpenCV 之前，你需要安装库。这是一个简单的过程，将在本章的第一个食谱中解释。
- en: All your computer vision applications will involve the processing of images.
    This is why OpenCV offers you a data structure to handle images and matrices.
    It is a powerful data structure with many useful attributes and methods. It also
    incorporates an advanced memory management model that greatly facilitates the
    development of applications. The last two recipes of this chapter will teach you
    how to use this important data structure of OpenCV.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你所有的计算机视觉应用程序都将涉及图像的处理。这就是为什么 OpenCV 提供了一个用于处理图像和矩阵的数据结构。这是一个功能强大的数据结构，具有许多有用的属性和方法。它还包含一个高级内存管理模型，这极大地简化了应用程序的开发。本章的最后两个食谱将教你如何使用这个重要的
    OpenCV 数据结构。
- en: Installing the OpenCV library
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 OpenCV 库
- en: OpenCV is an open source library for developing computer vision applications
    that can run on multiple platforms, such as Windows, Linux, Mac, Android, and
    iOS. It can be used in both academic and commercial applications under a BSD license
    that allows you to freely use, distribute, and adapt it. This recipe will show
    you how to install the library on your machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 是一个开源库，用于开发可在多个平台上运行的计算机视觉应用程序，例如 Windows、Linux、Mac、Android 和 iOS。它可以在遵循
    BSD 许可证的学术和商业应用中使用，该许可证允许你自由使用、分发和修改它。本食谱将向你展示如何在你的机器上安装这个库。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When you visit the OpenCV official website at [http://opencv.org/](http://opencv.org/)
    , you will find the latest release of the library, the online documentation describing
    the **Application Programming Interface** (**API**), and many other useful resources
    on OpenCV.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问 OpenCV 官方网站 [http://opencv.org/](http://opencv.org/) 时，你会找到库的最新版本，描述 **应用程序编程接口**（**API**）的在线文档，以及许多其他关于
    OpenCV 的有用资源。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: From the OpenCV website, find the latest available downloads and select the
    one that corresponds to the platform of your choice (Windows, Linux/Mac, or iOS).
    Once the OpenCV package is downloaded, run the WinZip self-extractor and select
    the location of your choice. An `opencv` directory will be created; it is a good
    idea to rename it in a way that will show which version you are using (for example,
    in Windows, your final directory could be `C:\opencv-3.2`). This directory will
    contain a collection of files and directories that constitute the library. Notably,
    you will find the `sources` directory that will contain all the source files (yes,
    it is open source!).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenCV 网站上找到最新可用的下载，并选择与你的选择平台（Windows、Linux/Mac 或 iOS）相对应的版本。一旦下载了 OpenCV
    软件包，运行 WinZip 自解压程序并选择你喜欢的位置。将创建一个 `opencv` 目录；将目录重命名以显示你使用的版本是一个好主意（例如，在 Windows
    上，你的最终目录可以是 `C:\opencv-3.2`）。这个目录将包含构成库的文件和目录集合。值得注意的是，你将找到包含所有源文件的 `sources`
    目录（是的，它是开源的！）。
- en: 'In order to complete the installation of the library and have it ready for
    use, you need to take an important step: generate the binary files of the library
    for the environment of your choice. This is indeed the point where you have to
    make a decision on the target platform you wish to use to create your OpenCV applications.
    Which operating system do you prefer to use? Which compiler should you select?
    Which version? 32-bit or 64-bit? As you can see, there are many possible options,
    and this is why you have to build the library that fits your needs.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成库的安装并使其准备好使用，你需要采取一个重要的步骤：为你的选择环境生成库的二进制文件。这确实是你要决定使用哪个目标平台来创建你的OpenCV应用程序的地方。你更喜欢使用哪个操作系统？应该选择哪个编译器？哪个版本？32位还是64位？正如你所见，有许多可能的选项，这就是为什么你必须构建适合你需求的库。
- en: The **Integrated Development Environment** (**IDE**) you will use in your project
    development will also guide you to make these choices. Note that the library package
    also comes with precompiled binaries that you can directly use if they correspond
    to your situation (check the `build` directory adjacent to the `sources` directory).
    If one of the precompiled binaries satisfies your requirements, then you are ready
    to go.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目开发中使用的**集成开发环境**（**IDE**）也将指导你做出这些选择。请注意，库包还附带预编译的二进制文件，如果你符合这种情况可以直接使用（检查`sources`目录旁边的`build`目录）。如果其中一个预编译的二进制文件满足你的要求，那么你就准备就绪了。
- en: One important remark, however. Since version 3, OpenCV has been split into two
    major components. The first one is the main OpenCV source repository that includes
    the mature algorithms. This is the one you have downloaded. A separate contribution
    repository also exists, and it contains the new computer vision algorithm, recently
    added by the OpenCV contributors. If your plan is to use only the core functions
    of OpenCV, you do not need the `contrib` package. But if you want to play with
    the latest state-of-the-art algorithms, then there is a good chance that you will
    need this extra module. As a matter of fact, this cookbook will show you how to
    use several of these advanced algorithms. You therefore need the `contrib` modules
    to follow the recipes of this book. So you have to go to [https://github.com/opencv/opencv_contrib](https://github.com/opencv/opencv_contrib)
    and download OpenCV's extra modules (download the ZIP file). You can unzip the
    extra modules into the directory of your choice; these modules should be found
    at `opencv_contrib-master/modules`. For simplicity, you can rename this directory
    as `contrib` and copy it directly inside the `sources` directory of the main package.
    Note that you can also pick the extra modules of your choice and only save them;
    however, you will probably find it easier, at this point, to simply keep everything.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个重要的说明。从版本3开始，OpenCV已经分为两个主要组件。第一个是包含成熟算法的主要OpenCV源代码库。这就是你下载的那个。还有一个单独的贡献代码库，它包含最近由OpenCV贡献者添加的新计算机视觉算法。如果你的计划是只使用OpenCV的核心功能，你不需要`contrib`包。但如果你想尝试最新的最先进算法，那么你很可能需要这个额外的模块。实际上，这本烹饪书将向你展示如何使用这些高级算法中的几个。因此，你需要`contrib`模块来遵循这本书的食谱。所以你必须去[https://github.com/opencv/opencv_contrib](https://github.com/opencv/opencv_contrib)下载OpenCV的额外模块（下载ZIP文件）。你可以将额外模块解压到你的选择目录；这些模块应该在`opencv_contrib-master/modules`中找到。为了简单起见，你可以将这个目录重命名为`contrib`并将其直接复制到主包的`sources`目录中。请注意，你也可以选择你想要的额外模块并只保存它们；然而，在这个阶段，你可能发现简单地保留所有内容会更容易。
- en: You are now ready to proceed with the installation. To build the OpenCV binaries,
    it is highly suggested that you use the **CMake** tool, available at [http://cmake.org](http://cmake.org)
    . CMake is another open source software tool designed to control the compilation
    process of a software system using platform-independent configuration files. It
    generates the required `makefile` or `solution` files needed for compiling a software
    library in your environment. Therefore, you have to download and install CMake.
    Also see the *There's more...* section of this recipe for an additional software
    package, the **Visualization Toolkit** (**VTK**), that you may want to install
    before compiling the library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好进行安装。为了构建OpenCV的二进制文件，强烈建议您使用位于[http://cmake.org](http://cmake.org)的**CMake**工具。CMake是另一个开源软件工具，它使用平台无关的配置文件来控制软件系统的编译过程。它生成在您的环境中编译软件库所需的`makefile`或`solution`文件。因此，您必须下载并安装CMake。另外，请参阅本食谱中的*更多内容...*部分，了解您可能希望在编译库之前安装的附加软件包，即**可视化工具包**（**VTK**）。
- en: 'You can run `cmake` using a command-line interface, but it is easier to use
    `CMake` with its graphical interface (**cmake-gui**). In the latter case, all
    you need to do is specify the folder containing the OpenCV library source and
    the one that will contain the binaries. Now click on **Configure** and select
    the compiler of your choice:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令行界面运行`cmake`，但使用带有图形界面的`CMake`（**cmake-gui**）会更简单。在后一种情况下，您只需指定包含OpenCV库源代码的文件夹和将包含二进制文件的文件夹。现在点击**Configure**并选择您选择的编译器：
- en: '![How to do it...](img/image_01_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_01_001.jpg)'
- en: 'Once this initial configuration is completed, CMake will provide you with a
    number of configuration options. You have to decide, for example, whether you
    want to have the documentation installed or whether you wish to have some additional
    libraries installed. Unless you know what you are doing, it is probably better
    to leave the default options as they are. However, since we want to include the
    extra modules, we have to specify the directory where they can be found:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成初始配置，CMake将为您提供一系列配置选项。例如，您必须决定是否希望安装文档或是否希望安装一些额外的库。除非您知道自己在做什么，否则最好保持默认选项不变。然而，由于我们想要包含额外的模块，我们必须指定它们可以找到的目录：
- en: '![How to do it...](img/image_01_002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_01_002.jpg)'
- en: Once the extra module path is specified, click on **Configure** again. You are
    now ready to generate the project files by clicking on the **Generate** button.
    These files will allow you to compile the library. This is the last step of the
    installation process, which will make the library ready to be used in your development
    environment. For example, if you select MS Visual Studio, then all you need to
    do is open the top-level solution file that CMake has created for you (the `OpenCV.sln`
    file). You then select the **INSTALL** project (under **CMakeTargets**) and issue
    the **Build** command (use right-click).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定了额外的模块路径，再次点击**Configure**。现在您就可以通过点击**Generate**按钮来生成项目文件。这些文件将允许您编译库。这是安装过程的最后一步，它将使库准备好在您的开发环境中使用。例如，如果您选择MS
    Visual Studio，那么您需要做的就是打开CMake为您创建的顶级解决方案文件（`OpenCV.sln`文件）。然后选择**INSTALL**项目（在**CMakeTargets**下）并执行**Build**命令（使用右键点击）。
- en: '![How to do it...](img/image_01_003.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_01_003.jpg)'
- en: To get both a **Release** and **Debug** build, you will have to repeat the compilation
    process twice, one for each configuration. If everything goes well, you will have
    an `install` directory (under `build`) created. This directory will contain all
    the `binary` files of the OpenCV library to be linked with your application as
    well as the dynamic library files that your executables have to call at runtime.
    Make sure you set your system's `PATH` environment variable (from **Control Panel**)
    such that your operating system would be able to find the `.dll` files when you
    run your applications (for example, `C:\opencv-3.2\build \install\x64\vc14\bin`).
    You should also define the environment variable, `OPENCV_DIR` pointing to the
    `INSTALL` directory. This way, CMake will be able to find the library when configuring
    future projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时获得 **发布版** 和 **调试版** 构建，你必须重复编译过程两次，一次针对每个配置。如果一切顺利，你将在 `build` 目录下创建一个 `install`
    目录。这个目录将包含所有与你的应用程序链接的 OpenCV 库的 `二进制` 文件以及你的可执行文件在运行时必须调用的动态库文件。确保你设置系统环境变量 `PATH`（从
    **控制面板**），以便操作系统在运行应用程序时能够找到 `.dll` 文件（例如，`C:\opencv-3.2\build \install\x64\vc14\bin`）。你还应该定义环境变量
    `OPENCV_DIR`，指向 `INSTALL` 目录。这样，CMake 就能在配置未来的项目时找到库。
- en: In Linux environments, you can use Cmake to generate the required `Makefiles`;
    you then complete the installation by executing a `sudo make install` command.
    Alternatively, you could also use the packaging tool `apt-get` which can automatically
    perform a complete installation of the library. For Mac OS, you should use the
    `Homebrew` package manager. Once installed, you just have to type `brew install
    opencv3 --with-contrib` in order to have the complete library installed (run `brew
    info opencv3` to view all possible options).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 环境中，你可以使用 Cmake 生成所需的 `Makefiles`；然后通过执行 `sudo make install` 命令来完成安装。或者，你也可以使用打包工具
    `apt-get`，它可以自动完成库的完整安装。对于 Mac OS，你应该使用 `Homebrew` 包管理器。一旦安装，你只需输入 `brew install
    opencv3 --with-contrib` 就可以安装完整的库（运行 `brew info opencv3` 查看所有可能的选项）。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: OpenCV is a library that is in constant evolution. With version 3, the library
    continues to expand offering a lot of new functionalities with enhanced performances.
    The move to having a full C++ API, which was initiated in version 2, is now almost
    complete, and more uniform interfaces have been implemented. One of the major
    changes introduced in this new version is the restructuring of the modules of
    the library in order to facilitate its distribution. In particular, a separate
    repository containing the most recent algorithms has been created. This `contrib`
    repository also contains non-free algorithms that are subject to specific licenses.
    The idea is for OpenCV to be able to offer state-of-the-art functionalities that
    developers and researchers want to share while still being able to offer a very
    stable and well-maintained core API. The main modules are therefore the ones you
    get when you download the library at [http://opencv.org/](http://opencv.org/).
    The extra modules must be downloaded directly from the development repository
    hosted on GitHub ( [https://github.com/opencv/](https://github.com/opencv/) ).
    Since these extra modules are in constant development, you should expect more
    frequent changes to the algorithms they contain.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 是一个不断发展的库。随着版本 3 的发布，该库继续扩展，提供了许多新的功能，并提高了性能。从版本 2 开始的全面 C++ API 的迁移现在几乎完成，并实现了更统一的接口。在这个新版本中引入的一个主要变化是重新组织库的模块，以方便其分发。特别是，创建了一个包含最新算法的独立仓库。这个
    `contrib` 仓库还包含受特定许可证约束的非自由算法。目标是让 OpenCV 能够提供开发者和研究人员想要共享的最先进的功能，同时仍然能够提供一个非常稳定且维护良好的核心
    API。因此，主要的模块是你从 [http://opencv.org/](http://opencv.org/) 下载库时获得的。额外的模块必须直接从托管在
    GitHub 上的开发仓库（[https://github.com/opencv/](https://github.com/opencv/)）下载。由于这些额外模块处于持续开发中，你应该预期它们包含的算法会有更频繁的变更。
- en: 'The OpenCV library is divided into several modules. For example, the `opencv_core`
    module contains the core functionalities of the library; the `opencv_imgproc`
    module includes the main image processing functions; the `opencv_highgui` module
    offers the image and video reading and writing functions along with some user
    interface functions; and so on. To use a particular module, you have to include
    the corresponding top-level header file. For instance, most applications that
    use OpenCV start with the following declarations:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 库分为几个模块。例如，`opencv_core` 模块包含库的核心功能；`opencv_imgproc` 模块包括主要图像处理函数；`opencv_highgui`
    模块提供图像和视频的读写功能以及一些用户界面函数；等等。要使用特定模块，您必须包含相应的顶级头文件。例如，大多数使用 OpenCV 的应用程序都从以下声明开始：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you learn to work with OpenCV, you will discover more and more functionalities
    available in its numerous modules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您学习使用 OpenCV，您将发现其众多模块中越来越多的功能。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The OpenCV website at [http://opencv.org/](http://opencv.org/) contains detailed
    instructions on how to install the library. It also contains complete online documentation
    that includes several tutorials on the different components of the library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 网站 [http://opencv.org/](http://opencv.org/) 包含有关如何安装库的详细说明。它还包含完整的在线文档，其中包括关于库不同组件的几个教程。
- en: The Visualization Toolkit and the cv::viz module
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化工具包和 cv::viz 模块
- en: 'In some applications, computer vision is used to reconstruct the 3D information
    of a scene from images. When working with 3D data, it is often useful to be able
    to visualize the results in some 3D virtual world. As you will learn in [Chapter
    11](ch11.html "Chapter 11. Reconstructing 3D Scenes") , *Reconstructing 3D Scenes*,
    the `cv::viz` module offers many useful functions that allow you to visualize
    scene objects and cameras in 3D. However, this module is built on top of another
    open source library: VTK. Therefore, if you want to use the `cv::viz` module,
    you need to install VTK on your machine before compiling OpenCV.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，计算机视觉用于从图像中重建场景的 3D 信息。当处理 3D 数据时，能够将结果可视化在某些 3D 虚拟世界中通常很有用。正如您将在 [第
    11 章](ch11.html "第 11 章。重建 3D 场景") 中所学到的，*重建 3D 场景*，`cv::viz` 模块提供了许多有用的函数，允许您在
    3D 中可视化场景对象和相机。然而，此模块是建立在另一个开源库 VTK 之上的。因此，如果您想使用 `cv::viz` 模块，在编译 OpenCV 之前，您需要在您的机器上安装
    VTK。
- en: VTK is available at [http://www.vtk.org/](http://www.vtk.org/). All you have
    to do is download the library and use CMake in order to create the binaries for
    your development environment. In this book, we used version 6.3.0\. In addition,
    you should define the `VTK_DIR` environment variable, pointing to the directory
    containing the built files. Also, in the configuration options proposed during
    the OpenCV installation process with CMake, make sure that the `WITH_VTK` option
    is checked.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: VTK 可在 [http://www.vtk.org/](http://www.vtk.org/) 获取。您只需下载库并使用 CMake 来为您的开发环境创建二进制文件。在这本书中，我们使用了版本
    6.3.0。此外，您应该定义 `VTK_DIR` 环境变量，指向包含构建文件的目录。同样，在 CMake 在 OpenCV 安装过程中提出的配置选项中，确保已勾选
    `WITH_VTK` 选项。
- en: The OpenCV developer site
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenCV 开发者网站
- en: OpenCV is an open source project that welcomes user contributions. The library
    is hosted on GitHub, a web service that offers version control and source code
    management tools based on Git. You can access the developer site at [https://github.com/opencv/opencv/wiki](https://github.com/opencv/opencv/wiki)
    . Among other things, you can access the currently developed version of OpenCV.
    The community uses Git as their version control system. Git is also a free open
    source software system; it is probably the best tool you can use to manage your
    own source code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 是一个开源项目，欢迎用户贡献。该库托管在 GitHub 上，这是一个基于 Git 的版本控制和源代码管理工具的在线服务。您可以通过 [https://github.com/opencv/opencv/wiki](https://github.com/opencv/opencv/wiki)
    访问开发者网站。在其他方面，您可以访问目前正在开发的 OpenCV 版本。社区使用 Git 作为其版本控制系统。Git 也是一个免费的开源软件系统；它可能是您管理自己的源代码的最佳工具。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Downloading the example source code of this book: The source code files of
    the examples presented in this cookbook are also hosted on GitHub. Please visit
    the author''s repository at [https://github.com/laganiere](https://github.com/laganiere)
    to obtain the latest version of the code. Note that you can download the example
    code files for all the Packt books you have purchased from your account at [http://www.packtpub.com](http://www.packtpub.com)
    . If you have purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register yourselves there to have the files e-mailed directly to you.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下载本书的示例源代码：本书中展示的示例源代码也托管在GitHub上。请访问作者的仓库[https://github.com/laganiere](https://github.com/laganiere)以获取代码的最新版本。请注意，您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: See also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The author's website ([http://www.laganiere.name/](http://www.laganiere.name/))
    also presents step-by-step instructions on how to install the latest versions
    of the OpenCV library
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者的网站([http://www.laganiere.name/](http://www.laganiere.name/))还提供了如何安装OpenCV库最新版本的逐步说明。
- en: Visit [https://git-scm.com/](https://git-scm.com/) and [https://github.com/](https://github.com/) to
    learn more about source code management.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问[https://git-scm.com/](https://git-scm.com/)和[https://github.com/](https://github.com/)了解更多关于源代码管理的信息。
- en: Loading, displaying, and saving images
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载、显示和保存图像
- en: It is now time to run your first OpenCV application. Since OpenCV is about processing
    images, this task will show you how to perform the most fundamental operations
    needed in the development of imaging applications. These are loading an input
    image from a file, displaying an image on a window, applying a processing function,
    and saving the output image.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行你的第一个OpenCV应用程序了。由于OpenCV是关于图像处理的，这个任务将向你展示如何在图像应用开发中执行最基本操作。这些操作包括从文件中加载输入图像、在窗口上显示图像、应用处理函数以及保存输出图像。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using your favorite IDE (for example, MS Visual Studio or Qt), create a new
    console application with a `main` function that is ready to be filled.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的IDE（例如，MS Visual Studio或Qt），创建一个新的控制台应用程序，其中包含一个准备填充的`main`函数。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first thing to do is to include the header files, declaring the classes
    and functions you wish to use. Here, we simply want to display an image, so we
    need the `core` header that declares the image data structure and the `highgui`
    header file that contains all the graphical interface functions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是包含头文件，声明你希望使用的类和函数。在这里，我们只想显示一张图片，因此我们需要包含声明图像数据结构的`core`头文件和包含所有图形界面函数的`highgui`头文件：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our main function starts by declaring a variable that will hold the image.
    Under OpenCV, this is done by defining an object of the `cv::Mat` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要函数首先声明一个将保存图片的变量。在OpenCV中，这是通过定义`cv::Mat`类的对象来完成的：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This definition creates an image of size `0x0`. This can be confirmed by accessing
    the `cv::Mat` size attributes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义创建了一个大小为`0x0`的图像。这可以通过访问`cv::Mat`的大小属性来确认：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, a simple call to the reading function will read an image from a file,
    decode it, and allocate the memory:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对读取函数的简单调用将从文件中读取一张图片，对其进行解码，并分配内存：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You are now ready to use this image. However, you should first check whether
    the image has been correctly read (an error will occur if the file is not found,
    is corrupted, or is not in a recognizable format). The validity of the image is
    tested using the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用这张图片了。但是，您应该首先检查图片是否被正确读取（如果文件找不到、损坏或不在可识别的格式中，将发生错误）。使用以下代码测试图像的有效性：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `empty` method returns `true` if no image data has been allocated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty`方法返回`true`表示没有分配图像数据。'
- en: 'The first thing you might want to do with this image is display it. You can
    do this using the functions of the `highgui` module. Start by declaring the window
    on which you want to display the images, then specify the image to be shown on
    this special window:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这张图片的第一件事可能是显示它。你可以使用`highgui`模块的功能来完成这个操作。首先，声明你想要显示图片的窗口，然后指定要在该特殊窗口上显示的图片：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the window is identified by a name. You can reuse this window
    to display another image later, or you can create multiple windows with different
    names. When you run this application, you will see an image window, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，窗口是通过名称来识别的。你可以重用这个窗口来稍后显示另一张图像，或者你可以创建具有不同名称的多个窗口。当你运行这个应用程序时，你会看到一个图像窗口，如下所示：
- en: '![How to do it...](img/image_01_004.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_01_004.jpg)'
- en: 'Now, you would normally apply some processing to the image. OpenCV offers a
    wide selection of processing functions, and several of them are explored in this
    book. Let''s start with a very simple one that flips an image horizontally. Several
    image transformations in OpenCV can be performed in-place, meaning the transformation
    is applied directly on the input image (no new image is created). This is the
    case for the flipping method. However, we can always create another matrix to
    hold the output result, and this is what we will do:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你通常会应用一些图像处理。OpenCV 提供了广泛的处理函数，本书中探索了其中的一些。让我们从一个非常简单的例子开始，即水平翻转图像。OpenCV
    中的一些图像变换可以在原地执行，这意味着变换直接应用于输入图像（不创建新图像）。翻转方法就是这样。然而，我们始终可以创建另一个矩阵来保存输出结果，这正是我们将要做的：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result is displayed on another window:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在另一个窗口中显示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since it is a console window that will terminate when it reaches the end of
    the `main` function, we add an extra `highgui` function to wait for a user key
    before we end the program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个在到达 `main` 函数末尾时会终止的控制台窗口，我们在结束程序之前添加了一个额外的 `highgui` 函数来等待用户按键：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then see that the output image is displayed in a distinct window, as
    shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，输出图像在以下屏幕截图所示的独立窗口中显示：
- en: '![How to do it...](img/image_01_005.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_01_005.jpg)'
- en: 'Finally, you will probably want to save the processed image on your disk. This
    is done using the following `highgui` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能想在磁盘上保存处理后的图像。这是使用以下 `highgui` 函数完成的：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The file extension determines which codec will be used to save the image. Other
    popular supported image formats are JPG, TIFF, and PNG.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名决定了将使用哪个编解码器来保存图像。其他流行的支持图像格式包括 JPG、TIFF 和 PNG。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'All classes and functions in the C++ API of OpenCV are defined within the `cv`
    namespace. You have two ways to access them. First, precede the `main` function''s
    definition with the following declaration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 的 C++ API 中所有类和函数都在 `cv` 命名空间内定义。你有两种方法可以访问它们。首先，在 `main` 函数的定义之前加上以下声明：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Alternatively, prefix all OpenCV class and function names with the namespace
    specification, that is, `cv::`, as we will do in this book. The use of this prefix
    makes the OpenCV classes and functions easier to identify within your code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过在所有 OpenCV 类和函数名称前加上命名空间指定符，即 `cv::`，来代替我们在这本书中所做的方式。使用这个前缀可以使你在代码中更容易识别
    OpenCV 类和函数。
- en: 'The `highgui` module contains a set of functions that allow you to easily visualize
    and interact with your images. When you load an image with the `imread` function,
    you also have the option to read it as a gray-level image. This is very advantageous
    since several computer vision algorithms require gray-level images. Converting
    an input color image on the fly as you read it will save you time and minimize
    your memory usage. This can be done as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`highgui` 模块包含一系列函数，允许你轻松地可视化和与你的图像交互。当你使用 `imread` 函数加载图像时，你也可以选择将其作为灰度图像读取。这非常有优势，因为许多计算机视觉算法都需要灰度图像。在读取图像时即时转换输入彩色图像可以节省你的时间并最小化你的内存使用。这可以通过以下方式完成：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will produce an image made of unsigned bytes (`unsigned char` in C++)
    that OpenCV designates with the constant `CV_8U`. Alternatively, it is sometimes
    necessary to read an image as a three-channel color image even if it has been
    saved as a gray-level image. This can be achieved by calling the `imread` function
    with a positive second argument:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个由无符号字节（C++中的 `unsigned char`）组成的图像，OpenCV 使用常量 `CV_8U` 来指定。或者，有时即使图像已保存为灰度图像，也必须以三通道彩色图像的形式读取图像。这可以通过使用正的第二个参数调用
    `imread` 函数来实现：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This time, an image made of 3 bytes per pixel will be created and designated
    as `CV_8UC3` in OpenCV. Of course, if your input image has been saved as a gray-level
    image, all three channels will contain the same value. Finally, if you wish to
    read the image in the format in which it has been saved, then simply input a negative
    value as the second argument. The number of channels in an image can be checked
    using the `channels` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，将创建一个每像素3字节的图像，并在 OpenCV 中指定为 `CV_8UC3`。当然，如果你的输入图像已被保存为灰度图像，所有三个通道将包含相同的值。最后，如果你希望以保存的格式读取图像，只需将第二个参数输入为负值。可以使用
    `channels` 方法检查图像中的通道数：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Pay attention when you open an image with `imread` without specifying a full
    path (as we did here). In such a case, the default directory will be used. When
    you run your application from the console, this directory is obviously the current
    console's directory. However, if you run the application directly from your IDE,
    the default directory will most often be the one that contains your project file.
    Consequently, make sure that your input image file is located in the right directory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `imread` 打开图像而没有指定完整路径（就像我们在这里做的那样）时，请注意。在这种情况下，将使用默认目录。当你从控制台运行应用程序时，这个目录显然是当前控制台的目录。然而，如果你直接从
    IDE 运行应用程序，默认目录通常是你项目文件所在的目录。因此，请确保你的输入图像文件位于正确的目录中。
- en: When you use `imshow` to display an image made up of integers (designated as
    `CV_16U` for 16-bit unsigned integers or as `CV_32S` for 32-bit signed integers),
    the pixel values of this image will be divided by `256` first. This is done in
    an attempt to make it displayable with `256` gray shades. Similarly, an image
    made up of floating points will be displayed by assuming a range of possible values
    between `0.0` (displayed as black) and `1.0` (displayed as white). Values outside
    this defined range are displayed in white (for values above `1.0`) or black (for
    values below `0.0`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `imshow` 显示由整数组成的图像（指定为 `CV_16U` 用于16位无符号整数或 `CV_32S` 用于32位有符号整数）时，该图像的像素值将首先除以
    `256`。这是为了尝试使其以 `256` 灰度级别可显示。同样，由浮点数组成的图像将通过假设可能的值范围在 `0.0`（显示为黑色）和 `1.0`（显示为白色）之间来显示。定义范围之外的价值将以白色（对于大于
    `1.0` 的值）或黑色（对于小于 `0.0` 的值）显示。
- en: The `highgui` module is very useful to build quick prototypal applications.
    When you are ready to produce a finalized version of your application, you will
    probably want to use the GUI module offered by your IDE in order to build an application
    with a more professional look.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`highgui` 模块对于构建快速原型应用非常有用。当你准备好制作应用程序的最终版本时，你可能会想使用 IDE 提供的 GUI 模块来构建一个外观更专业的应用程序。'
- en: 'Here, our application uses both input and output images. As an exercise, you
    should rewrite this simple program such that it takes advantage of the function''s
    in-place processing, that is, by not declaring the output image and writing it
    instead:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的应用程序使用输入和输出图像。作为一个练习，你应该重写这个简单的程序，使其利用函数的就地处理功能，也就是说，不声明输出图像，而是直接写入：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `highgui` module contains a rich set of functions that help you interact
    with your images. Using these, your applications can react to mouse or key events.
    You can also draw shapes and write text on images.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`highgui` 模块包含一套丰富的函数，可以帮助你与图像交互。使用这些函数，你的应用程序可以响应鼠标或键盘事件。你还可以在图像上绘制形状和写入文本。'
- en: Clicking on images
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点击图像
- en: 'You can program your mouse to perform specific operations when it is over one
    of the image windows you created. This is done by defining an appropriate **callback**
    function. A callback function is a function that you do not explicitly call but
    which is called by your application in response to specific events (here, the
    events that concern the mouse interacting with an image window). To be recognized
    by applications, callback functions need to have a specific signature and must
    be registered. In the case of a mouse event handler, the callback function must
    have the following signature:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编程你的鼠标，当它在创建的图像窗口之一上时执行特定操作。这是通过定义一个适当的**回调**函数来完成的。回调函数是一个你不会明确调用的函数，但你的应用程序会在响应特定事件时调用它（在这里，涉及鼠标与图像窗口交互的事件）。为了被应用程序识别，回调函数需要具有特定的签名，并且必须注册。在鼠标事件处理程序的情况下，回调函数必须具有以下签名：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first parameter is an integer that is used to specify which type of mouse
    event has triggered the call to the callback function. The other two parameters
    are simply the pixel coordinates of the mouse location when the event has occurred.
    The flags are used to determine which button was pressed when the mouse event
    was triggered. Finally, the last parameter is used to send an extra parameter
    to the function in the form of a pointer to any object. This callback function
    can be registered in the application through the following call:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个整数，用于指定哪种鼠标事件触发了回调函数的调用。其他两个参数简单地是事件发生时鼠标位置的像素坐标。标志用于确定鼠标事件触发时按下了哪个按钮。最后，最后一个参数用于将一个指针作为额外参数发送到函数中。这个回调函数可以通过以下调用在应用程序中注册：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, the `onMouse` function is associated with the image window
    called **Original Image**, and the address of the displayed image is passed as
    an extra parameter to the function. Now, if we define the `onMouse` callback function
    as shown in the following code, then each time the mouse is clicked, the value
    of the corresponding pixel will be displayed on the console (here, we assume that
    it is a gray-level image):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`onMouse`函数与称为**原始图像**的图像窗口相关联，显示的图像地址作为额外参数传递给函数。现在，如果我们定义如以下代码所示的`onMouse`回调函数，那么每次鼠标点击时，相应的像素值将在控制台上显示（这里，我们假设它是一个灰度图像）：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that in order to obtain the pixel value at `(x,y)`, we used the `at` method
    of the `cv::Mat` object; this is discussed in [Chapter 2](ch02.html "Chapter 2. Manipulating
    Pixels") , *Manipulating Pixels*. Other possible events that can be received by
    the mouse event callback function include `cv::EVENT_MOUSEMOVE`, `cv::EVENT_LBUTTONUP`,
    `cv::EVENT_RBUTTONDOWN`, and `cv::EVENT_RBUTTONUP`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了获取`(x,y)`处的像素值，我们使用了`cv::Mat`对象的`at`方法；这将在[第2章](ch02.html "第2章. 操作像素")，*操作像素*中讨论。鼠标事件回调函数可以接收的其他可能的事件包括`cv::EVENT_MOUSEMOVE`，`cv::EVENT_LBUTTONUP`，`cv::EVENT_RBUTTONDOWN`和`cv::EVENT_RBUTTONUP`。
- en: Drawing on images
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在图像上绘制
- en: 'OpenCV also offers a few functions to draw shapes and write text on images.
    The examples of basic shape-drawing functions are `circle`, `ellipse`, `line`,
    and `rectangle`. The following is an example of how to use the `circle` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV还提供了一些函数来在图像上绘制形状和写文本。基本形状绘制函数的例子有`circle`，`ellipse`，`line`和`rectangle`。以下是如何使用`circle`函数的例子：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `cv::Point` structure is often used in OpenCV methods and functions to
    specify a pixel coordinate. Note that here we assume that the drawing is done
    on a gray-level image; this is why the color is specified with a single integer.
    In the next recipe, you will learn how to specify a color value in the case of
    color images that use the `cv::Scalar` structure. It is also possible to write
    text on an image. This can be done as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Point`结构在OpenCV方法和函数中经常被用来指定一个像素坐标。注意，这里我们假设绘制是在灰度图像上进行的；这就是为什么颜色用单个整数指定。在下一道菜谱中，你将学习如何在使用`cv::Scalar`结构的情况下指定颜色值。也可以在图像上写文本。这可以按以下方式完成：'
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Calling these two functions on our test image will then result in the following
    screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试图像上调用这两个函数将导致以下截图：
- en: '![Drawing on images](img/image_01_006.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![在图像上绘制](img/image_01_006.jpg)'
- en: Note that you have to include the top-level module header `opencv2/imgproc.hpp`
    for these examples to work.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须包含顶层模块头文件`opencv2/imgproc.hpp`，这些示例才能正常工作。
- en: See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `cv::Mat` class is the data structure that is used to hold your images (and
    obviously, other matrix data). This data structure is at the core of all OpenCV
    classes and functions; the next recipe offers a detailed explanation of this data
    structure.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::Mat`类是用来存储你的图像（以及显然，其他矩阵数据）的数据结构。这个数据结构是所有OpenCV类和函数的核心；下一道菜谱将详细解释这个数据结构。'
- en: Exploring the cv::Mat data structure
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索cv::Mat数据结构
- en: In the previous recipe, you were introduced to the `cv::Mat` data structure.
    As mentioned, this is a key component of the library. It is used to manipulate
    images and matrices (in fact, an image is a matrix from a computational and mathematical
    point of view). Since you will be using this data structure extensively in your
    application development processes, it is imperative that you become familiar with
    it. Notably, in this recipe, you will learn that this data structure incorporates
    an elegant memory management mechanism.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，你被介绍到了 `cv::Mat` 数据结构。正如提到的，这是库的关键组件。它用于操作图像和矩阵（实际上，从计算和数学的角度来看，图像是一个矩阵）。由于你将在应用程序开发过程中广泛使用此数据结构，因此熟悉它是至关重要的。值得注意的是，在这个菜谱中，你将了解到这个数据结构包含了一个优雅的内存管理机制。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s write the following test program that will allow us to test the different
    properties of the `cv::Mat` data structure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写以下测试程序，以便我们可以测试 `cv::Mat` 数据结构的各种属性：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run this program and take a look at the images it produces:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序并查看它产生的图像：
- en: '![How to do it...](img/image_01_007.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_01_007.jpg)'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `cv::Mat` data structure is essentially made up of two parts: a header
    and a data block. The header contains all of the information associated with the
    matrix (size, number of channels, data type, and so on). The previous recipe showed
    you how to access some of the attributes of this structure contained in its header
    (for example, by using `cols`, `rows`, or `channels`). The data block holds all
    the pixel values of an image. The header contains a pointer variable that points
    to this data block; it is the `data` attribute. An important property of the `cv::Mat`
    data structure is the fact that the memory block is only copied when explicitly
    requested for. Indeed, most operations will simply copy the `cv::Mat` header such
    that multiple objects will point to the same data block. This memory management
    model makes your applications more efficient while avoiding memory leaks, but
    its consequences need to be understood. The examples of this recipe illustrate
    this fact.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Mat` 数据结构本质上由两部分组成：一个头和一个数据块。头包含与矩阵相关的所有信息（大小、通道数、数据类型等）。前面的菜谱展示了如何访问该结构头中的一些属性（例如，使用
    `cols`、`rows` 或 `channels`）。数据块包含图像的所有像素值。头包含一个指向此数据块的指针变量；它是 `data` 属性。`cv::Mat`
    数据结构的一个重要特性是内存块仅在明确请求时才会被复制。确实，大多数操作只是简单地复制 `cv::Mat` 头部，这样多个对象将指向相同的数据块。这种内存管理模型使你的应用程序更高效，同时避免了内存泄漏，但需要理解其后果。本菜谱的示例说明了这一点。'
- en: 'By default, the `cv::Mat` objects have a zero size when they are created, but
    you can also specify an initial size as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`cv::Mat` 对象在创建时具有零大小，但你也可以指定一个初始大小，如下所示：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, you also need to specify the type of each matrix element-`CV_8U`
    here, which corresponds to 1-byte pixel (grayscale) images. The `U` letter here
    means it is unsigned. You can also declare signed numbers using `S`. For a color
    image, you would specify three channels (`CV_8UC3`). You can also declare integers
    (signed or unsigned) of size `16` and `32` (for example, `CV_16SC3`). You also
    have access to 32-bit and 64-bit floating-point numbers (for example, `CV_32F`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你还需要指定每个矩阵元素的类型-这里为 `CV_8U`，对应于 1 字节像素（灰度）图像。这里的 `U` 字母表示它是无符号的。你也可以使用
    `S` 声明有符号数字。对于彩色图像，你会指定三个通道（`CV_8UC3`）。你也可以声明大小为 `16` 和 `32` 的整数（例如，`CV_16SC3`）。你还可以访问
    32 位和 64 位浮点数（例如，`CV_32F`）。
- en: 'Each element of an image (or a matrix) can be composed of more than one value
    (for example, the three channels of a color image); therefore, OpenCV has introduced
    a simple data structure that is used when pixel values are passed to functions.
    This is the `cv::Scalar` structure, which is generally used to hold one or three
    values. For example, to create a color image initialized with red pixels, write
    the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图像（或矩阵）的每个元素可以由多个值组成（例如，彩色图像的三个通道）；因此，OpenCV 引入了一个简单的数据结构，用于在将像素值传递给函数时使用。这是
    `cv::Scalar` 结构，通常用于存储一个或三个值。例如，要创建一个用红色像素初始化的彩色图像，请编写以下代码：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Similarly, the initialization of the gray-level image could have also been done
    using this structure by writing `cv::Scalar(100)`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，灰度图像的初始化也可以通过编写 `cv::Scalar(100)` 来使用此结构完成。
- en: The image size often needs to be passed to functions as well. We have already
    mentioned that the `cols` and `rows` attributes can be used to get the dimensions
    of a `cv::Mat` instance. The size information can also be provided through the
    `cv::Size` structure that simply contains the height and width of the matrix.
    The `size()` method allows you to obtain the current matrix size. This is the
    format that is used in many methods where a matrix size must be specified.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图片大小通常也需要传递给函数。我们之前已经提到，可以使用`cols`和`rows`属性来获取`cv::Mat`实例的维度。大小信息也可以通过只包含矩阵高度和宽度的`cv::Size`结构来提供。`size()`方法允许你获取当前矩阵的大小。这种格式在许多需要指定矩阵大小的函数中都被使用。
- en: 'For example, an image could be created as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个图片可以创建如下：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The data block of an image can always be allocated or reallocated using the
    `create` method. When an image has already been previously allocated, its old
    content is deallocated first. For reasons of efficiency, if the new proposed size
    and type matches the already existing size and type, then no new memory allocation
    is performed:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`create`方法始终为图像的数据块分配或重新分配内存。当一个图像已经被之前分配时，其旧内容首先被释放。出于效率的考虑，如果新提议的大小和类型与已存在的类型和大小匹配，则不会执行新的内存分配：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When no more references point to a given `cv::Mat` object, the allocated memory
    is automatically released. This is very convenient because it avoids the common
    memory leak problems often associated with dynamic memory allocation in C++. This
    is a key mechanism in OpenCV (introduced in version 2) that is accomplished by
    having the `cv::Mat` class implement reference counting and shallow copy. Therefore,
    when an image is assigned to another one, the image data (that is, the pixels)
    is not copied; both images will point to the same memory block. This also applies
    to images either passed or returned by a value. A reference count is kept such
    that the memory will be released only when all the references to the image are
    destructed or assigned to another image:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多的引用指向给定的`cv::Mat`对象时，分配的内存会自动释放。这非常方便，因为它避免了与C++中动态内存分配通常相关的常见内存泄漏问题。这是OpenCV（从版本2开始引入）中的一个关键机制，通过`cv::Mat`类实现引用计数和浅拷贝来完成。因此，当一个图像被赋值给另一个图像时，图像数据（即像素）不会被复制；两个图像将指向相同的内存块。这也适用于通过值传递或返回的图像。保持引用计数，以便仅在所有对图像的引用都被销毁或赋值给另一个图像时才会释放内存：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Any transformation applied to one of the preceding images will also affect
    the other images. If you wish to create a deep copy of the content of an image,
    use the `copyTo` method. In this case, the `create` method is called on the destination
    image. Another method that produces a copy of an image is the `clone` method,
    which creates a new identical image as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面任何图像应用任何转换也会影响其他图像。如果你希望创建图像内容的深度副本，请使用`copyTo`方法。在这种情况下，`create`方法被调用在目标图像上。另一个生成图像副本的方法是`clone`方法，它创建一个如下所示的新相同图像：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the example of this recipe, we applied a transformation to `image3`. The
    other images also contain this image; some of them share the same image data,
    while others hold a copy of this image. Check the displayed images and find out
    which ones were affected by the `image3` transformation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱的示例中，我们对`image3`应用了转换。其他图片也包含这个图片；其中一些共享相同的数据，而其他则持有这个图片的副本。检查显示的图片，找出哪些受到了`image3`转换的影响。
- en: 'If you need to copy an image into another image that does not necessarily have
    the same data type, use the `convertTo` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将图片复制到另一个不一定具有相同数据类型的图片中，请使用`convertTo`方法：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, the source image is copied into a floating-point image. The
    method includes two optional parameters: a scaling factor and an offset. Note
    that both the images must, however, have the same number of channels.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，源图片被复制到一个浮点图片中。该方法包括两个可选参数：缩放因子和偏移量。请注意，然而，两个图片必须有相同数量的通道。
- en: 'The allocation model for the `cv::Mat` objects also allows you to safely write
    functions (or class methods) that return an image:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Mat`对象的分配模型还允许你安全地编写返回图像的函数（或类方法）：'
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can also call this function from our `main` function as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以如下从我们的`main`函数中调用这个函数：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we do this, the `gray` variable will then hold the image created by the function
    without extra memory allocation. Indeed, as we explained, only a shallow copy
    of the image will be transferred from the returned `cv::Mat` instance to the gray
    image. When the `ima` local variable goes out of scope, this variable is deallocated.
    However, since the associated reference counter indicates that its internal image
    data is being referred to by another instance (that is, the `gray` variable),
    its memory block is not released.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，`gray` 变量将保留由该函数创建的图像，而不需要额外的内存分配。确实，正如我们解释的那样，只有图像的浅拷贝将从返回的 `cv::Mat`
    实例传输到灰度图像。当 `ima` 局部变量超出作用域时，此变量将被释放。然而，由于相关的引用计数器指示其内部图像数据正被另一个实例（即 `gray` 变量）引用，其内存块不会被释放。
- en: 'It''s worth noting that in the case of classes, you should be careful and not
    return image class attributes. Here is an example of an error-prone implementation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在类的情况下，你应该小心，不要返回图像类属性。以下是一个容易出错的实现示例：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, if a function calls the method of this class, it obtains a shallow copy
    of the image attributes. If this copy is modified later, the `class` attribute
    will also be surreptitiously modified, which can affect the subsequent behavior
    of the class (and vice versa). This is a violation of the important principle
    of encapsulation in object-oriented programming. To avoid these kinds of errors,
    you should instead return a clone of the attribute.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果一个函数调用这个类的这个方法，它将获得图像属性的浅拷贝。如果稍后修改了这个拷贝，`class` 属性也将被秘密修改，这可能会影响类的后续行为（反之亦然）。这是违反面向对象编程中封装重要原则的行为。为了避免这些错误，你应该返回属性的克隆。
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: When you are manipulating the `cv::Mat` class, you will discover that OpenCV
    also includes several other related classes. It will be important for you to become
    familiar with them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你操作 `cv::Mat` 类时，你会发现 OpenCV 还包括几个其他相关类。了解它们将对你来说非常重要。
- en: The input and output arrays
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入和输出数组
- en: If you look at the OpenCV documentation, you will see that many methods and
    functions accept parameters of the `cv::InputArray` type as an input. This type
    is a simple proxy class introduced to generalize the concept of arrays in OpenCV
    and thus avoid the duplication of several versions of the same method or function
    with different input parameter types. It basically means that you can supply either
    a `cv::Mat` object or other compatible types as an argument. Since it is declared
    as an input array, you have the guarantee that your data structure will not be
    modified by the function. It is interesting to know that `cv::InputArray` can
    also be constructed from the popular `std::vector` class. This means that such
    objects can be used as input parameters to OpenCV methods and functions (however,
    never use this class inside your classes and functions). Other compatible types
    are `cv::Scalar` and `cv::Vec`; the latter structure will be presented in the
    next chapter. There is also a `cv::OutputArray` proxy class that is used to designate
    parameters that correspond to an image that is returned by a function or method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 OpenCV 文档，你会看到许多方法和函数接受 `cv::InputArray` 类型的参数作为输入。这是一个简单的代理类，用于泛化 OpenCV
    中数组的概念，从而避免重复多个具有不同输入参数类型的方法或函数的多个版本。这基本上意味着你可以提供 `cv::Mat` 对象或其他兼容类型作为参数。由于它被声明为输入数组，你可以保证你的数据结构不会被函数修改。有趣的是，`cv::InputArray`
    也可以从流行的 `std::vector` 类构建。这意味着这样的对象可以用作 OpenCV 方法或函数的输入参数（然而，永远不要在你的类和函数中使用这个类）。其他兼容类型是
    `cv::Scalar` 和 `cv::Vec`；后者结构将在下一章中介绍。还有一个 `cv::OutputArray` 代理类，用于指定与函数或方法返回的图像对应的参数。
- en: Manipulating small matrices
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作小矩阵
- en: 'When writing your applications, you might have to manipulate small matrices.
    You can then use the `cv::Matx` template class and its subclasses. For example,
    the following code declares a `3x3` matrix of double-precision floating-point
    numbers and a 3-element vector. These two are then multiplied together:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写你的应用程序时，你可能需要操作小矩阵。然后你可以使用 `cv::Matx` 模板类及其子类。例如，以下代码声明了一个 `3x3` 的双精度浮点数矩阵和一个
    3 元素向量。然后这两个相乘：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the usual math operators can be applied to these matrices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通常的数学运算符可以应用于这些矩阵。
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The complete OpenCV documentation can be found at [http://docs.opencv.org/](http://docs.opencv.org/)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的 OpenCV 文档可以在 [http://docs.opencv.org/](http://docs.opencv.org/) 找到
- en: '[Chapter 2](ch02.html "Chapter 2. Manipulating Pixels") , *Manipulating Pixels*,
    will show you how to efficiently access and modify the pixel values of an image
    represented by the `cv::Mat` class'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章. 操作像素")，*操作像素*，将向您展示如何高效地访问和修改由 `cv::Mat` 类表示的图像的像素值'
- en: The next recipe, *Defining regions of interest* , will explain how to define
    a region of interest inside an image
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个配方 *定义感兴趣区域* 将解释如何在图像内部定义感兴趣区域
- en: Defining regions of interest
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义感兴趣区域
- en: Sometimes, a processing function needs to be applied only to a portion of an
    image. OpenCV incorporates an elegant and simple mechanism to define a subregion
    in an image and manipulate it as a regular image. This recipe will teach you how
    to define a region of interest inside an image.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个处理函数只需要应用于图像的一部分。OpenCV 集成了定义图像子区域并像常规图像一样操作的一个优雅且简单的机制。这个配方将教会您如何在图像内部定义感兴趣区域。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Suppose we want to copy a small image onto a larger one. For example, let''s
    say we want to insert the following logo into our test image:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将一个小图像复制到一个大图像上。例如，让我们假设我们想要将以下标志插入到我们的测试图像中：
- en: '![Getting ready](img/image_01_008.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/image_01_008.jpg)'
- en: To do this, a **Region Of Interest** (**ROI**) can be defined over which the
    copy operation can be applied. As we will see, the position of the ROI will determine
    where the logo will be inserted in the image.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，可以在一个**感兴趣区域**（**ROI**）上定义复制操作。正如我们将看到的，ROI 的位置将决定标志将插入图像的位置。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first step consists of defining the ROI. Once defined, the ROI can be manipulated
    as a regular `cv::Mat` instance. The key is that the ROI is indeed a `cv::Mat`
    object that points to the same data buffer as its parent image and has a header
    that specifies the coordinates of the ROI. Inserting the logo is then accomplished
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义 ROI。一旦定义，ROI 就可以像常规的 `cv::Mat` 实例一样进行操作。关键是 ROI 确实是一个指向其父图像相同数据缓冲区的 `cv::Mat`
    对象，并且有一个头文件指定 ROI 的坐标。插入标志的操作如下：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, `image` is the destination image and `logo` is the logo image (of a smaller
    size). The following image is then obtained by executing the previous code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`image` 是目标图像，而 `logo` 是标志图像（尺寸较小）。执行前面的代码后，得到以下图像：
- en: '![How to do it...](img/image_01_009.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_01_009.jpg)'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: One way to define an ROI is to use a `cv::Rect` instance. As the name indicates,
    it describes a rectangular region by specifying the position of the upper-left
    corner (the first two parameters of the constructor) and the size of the rectangle
    (the width and height are given in the last two parameters). In our example, we
    used the size of the image and the size of the logo in order to determine the
    position where the logo would cover the bottom-right corner of the image. Obviously,
    the ROI should always be completely inside the parent image.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 ROI 的一种方法是通过使用一个 `cv::Rect` 实例。正如其名称所示，它通过指定左上角的位置（构造函数的前两个参数）和矩形的尺寸（宽度在最后两个参数中给出）来描述一个矩形区域。在我们的例子中，我们使用了图像的大小和标志的大小来确定标志将覆盖图像右下角的位置。显然，ROI
    应始终完全位于父图像内部。
- en: 'The ROI can also be described using row and column ranges. A range is a continuous
    sequence from a start index to an end index (excluding both). The `cv::Range`
    structure is used to represent this concept. Therefore, an ROI can be defined
    from two ranges; in our example, the ROI could have been equivalently defined
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ROI 也可以使用行和列的范围来描述。范围是从起始索引到结束索引（不包括两者）的连续序列。`cv::Range` 结构用来表示这个概念。因此，ROI 可以由两个范围定义；在我们的例子中，ROI
    可以等价地定义为以下内容：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, the `operator()` function of `cv ::Mat` returns another `cv::Mat`
    instance that can then be used in subsequent calls. Any transformation of the
    ROI will affect the original image in the corresponding area because the image
    and the ROI share the same image data. Since the definition of an ROI does not
    include the copying of data, it is executed in a constant amount of time, no matter
    the size of the ROI.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`cv::Mat` 的 `operator()` 函数返回另一个 `cv::Mat` 实例，然后可以在后续调用中使用。任何对 ROI 的转换都会影响原始图像的相应区域，因为图像和
    ROI 共享相同的图像数据。由于 ROI 的定义不包括数据的复制，它以恒定的时间执行，无论 ROI 的大小如何。
- en: 'If you want to define an ROI made up of some lines of an image, the following
    call can be used:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要定义由图像的一些行组成的ROI，可以使用以下调用：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similarly, for an ROI made up of some image columns, the following can be used:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于由一些图像列组成的ROI，可以使用以下方法：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The OpenCV methods and functions include many optional parameters that are not
    discussed in the recipes of this book. When you wish to use a function for the
    first time, you should always take the time to look at the documentation to learn
    more about the possible options that the function offers. One very common option
    is the possibility to define image masks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV的方法和函数包括许多在本书的食谱中未讨论的可选参数。当你第一次使用一个函数时，你应该花时间查看文档，以了解更多该函数提供的可能选项。一个非常常见的选项是定义图像掩码。
- en: Using image masks
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图像掩码
- en: 'Some OpenCV operations allow you to define a mask that will limit the applicability
    of a given function or method, which is normally supposed to operate on all the
    image pixels. A mask is an 8-bit image that should be nonzero at all locations
    where you want an operation to be applied. At the pixel locations that correspond
    to the zero values of the mask, the image is untouched. For example, the `copyTo`
    method can be called with a mask. We can use it here to copy only the white portion
    of the logo shown previously, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一些OpenCV操作允许你定义一个掩码，这将限制给定函数或方法的应用范围，这些函数或方法通常应该在所有图像像素上操作。掩码是一个8位图像，你应该在你想应用操作的所有位置上非零。在对应于掩码零值的像素位置，图像保持不变。例如，可以使用掩码调用`copyTo`方法。我们可以在这里使用它来复制之前显示的标志的白色部分，如下所示：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following image is obtained by executing the previous code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是通过执行前面的代码获得的：
- en: '![Using image masks](img/image_01_010.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![使用图像掩码](img/image_01_010.jpg)'
- en: The background of our logo was black (therefore, it had the value `0`); this
    is why it was easy to use it as both the copied image and the mask. Of course,
    you can define the mask of your choice in your application; most OpenCV pixel-based
    operations give you the opportunity to use masks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标志的背景是黑色的（因此，它的值是`0`）；这就是为什么它可以很容易地用作复制的图像和掩码。当然，你可以在你的应用程序中定义你选择的掩码；大多数基于像素的OpenCV操作都给你使用掩码的机会。
- en: See also
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `row` and `col` methods will be used in the *Scanning an image with neighbor
    access* recipe of [Chapter 2](ch02.html "Chapter 2. Manipulating Pixels") , *Manipulating
    Pixels*. These are a special case of the `rowRange` and `colRange` methods in
    which the start and end indexes are equal in order to define a single-line or
    single-column ROI.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`row`和`col`方法将在[第2章](ch02.html "第2章. 操作像素")的“使用邻接访问扫描图像”食谱中用到，*操作像素*。这些是`rowRange`和`colRange`方法的特殊情况，其中起始和结束索引相等，以定义单行或单列ROI。'
