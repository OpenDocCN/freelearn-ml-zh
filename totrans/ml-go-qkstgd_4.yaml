- en: Unsupervised Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无监督学习
- en: While the majority of machine learning problems involve labeled data, as we
    saw in the previous chapter, there is another important branch called **unsupervised
    learning**. This applies in situations where you may not have labels for the input
    data, and so the algorithm cannot work by trying to predict output labels from
    each input. Instead, unsupervised algorithms work by trying to spot patterns or
    structure in the input. It can be a useful technique when carrying out exploratory
    analysis on a large dataset with many different input variables. In this situation,
    it would be incredibly time-consuming to plot charts of all the different variables
    to try to spot patterns, so instead, unsupervised learning can be used to do this
    automatically.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数机器学习问题涉及标记数据，正如我们在上一章所看到的，还有一个重要的分支称为**无监督学习**。这适用于你可能没有输入数据标签的情况，因此算法不能通过尝试从每个输入预测输出标签来工作。相反，无监督算法通过尝试在输入中找到模式或结构来工作。当对具有许多不同输入变量的大型数据集进行探索性分析时，这可能是一种有用的技术。在这种情况下，绘制所有不同变量的图表以尝试发现模式将非常耗时，因此，可以使用无监督学习来自动完成这项工作。
- en: 'As humans, we are very familiar with this concept: much of what we do is never
    explicitly taught to us by someone else. Instead, we explore the world around
    us, looking for, and discovering, patterns. For this reason, unsupervised learning
    is of particular interest to researchers who are trying to develop systems for **general
    intelligence**: computers that can learn what they need independently^([1]).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们非常熟悉这个概念：我们做的许多事情从未被其他人明确地教给我们。相反，我们探索周围的世界，寻找并发现模式。因此，无监督学习对试图开发**通用智能**系统的研究人员特别感兴趣：能够独立学习所需知识的计算机^([1])。
- en: In this chapter, we are going to introduce two popular unsupervised algorithms
    and implement them in Go. First, we will use a **clustering algorithm** to separate
    a dataset into distinct groups without any guidance about what to look for. Then,
    we will use a technique called **principal component analysis** to compress a
    dataset by first finding hidden structures within it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍两种流行的无监督算法，并在Go语言中实现它们。首先，我们将使用**聚类算法**将数据集分割成不同的组，而不需要任何关于要寻找什么的指导。然后，我们将使用一种称为**主成分分析**的技术，通过首先在数据集中找到隐藏的结构来压缩数据集。
- en: This will just scratch the surface of what unsupervised learning is able to
    achieve. Some cutting-edge algorithms are able to allow computers to carry out
    tasks that normally require human creativity. One example worth looking at is
    NVIDIA's system for creating realistic pictures from sketches^([2]). You can also
    find code examples online for networks that can make realistic changes to how
    an image appears, for instance, turning horses into zebras, or oranges into apples^([3]).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对无监督学习能够实现的内容的表面触及。一些前沿算法能够使计算机执行通常需要人类创造力的任务。一个值得关注的例子是NVIDIA从草图创建逼真图片的系统^([2])。你还可以在网上找到可以改变图像外观的代码示例，例如，将马变成斑马，或将橙子变成苹果^([3])。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Clustering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类
- en: Principal component analysis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主成分分析
- en: Clustering
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类
- en: Clustering algorithms are designed to split a dataset up into groups. Once trained,
    any new data can be assigned to a group when it arrives. Suppose you are working
    with a dataset of customer information for an e-commerce store. You might use
    clustering to identify groups of customers, for example, business/private customers.
    This information can then be used to make decisions about how to best serve those
    customer types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类算法旨在将数据集分割成组。一旦训练完成，任何新数据在到达时都可以分配到相应的组中。假设你正在处理一个电子商务商店客户信息的数据集。你可能使用聚类来识别客户群体，例如，商业/私人客户。然后，可以使用这些信息来做出关于如何最好地服务这些客户类型的决策。
- en: You might also use clustering as a preparatory step before applying supervised
    learning. For example, a dataset of images may require manual labeling, which
    is often time-consuming and costly. If you can segment the dataset into groups
    with a clustering algorithm, then you may be able to save time by only labeling
    a fraction of the images, and then assuming that each cluster contains images
    with the same label.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在应用监督学习之前使用聚类作为预处理步骤。例如，图像数据集可能需要手动标记，这通常既耗时又昂贵。如果你可以使用聚类算法将数据集分割成组，那么你可能可以通过只标记部分图像来节省时间，并假设每个簇包含具有相同标签的图像。
- en: Clustering has also been applied to computer vision applications in autonomous
    vehicles, where it can be used to help a vehicle navigate on an unknown stretch
    of road. By clustering the data from the vehicles cameras, it is possible to identify
    which area of each incoming image contains the road on which the vehicle must
    drive^([4]).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类技术也被应用于自动驾驶汽车的计算机视觉应用中，它可以用来帮助车辆在未知路段上导航。通过聚类车辆摄像头的图像数据，可以识别出每个输入图像中包含车辆必须行驶的道路的区域^([4])。
- en: 'For our example, we are going to use a dataset containing measurements of different
    types of iris flower, which you can download using the `./download-iris.sh` script
    in the code repository. This data is often used to demonstrate supervised learning:
    you can use machine learning to classify the data according to the species of
    iris flower. In this case, however, we will not provide labels to the clustering
    algorithm, meaning that it has to identify clusters purely from the measurement
    data:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用一个包含不同类型鸢尾花测量数据的数据集，你可以使用代码仓库中的`./download-iris.sh`脚本来下载这个数据集。这个数据集通常用于演示监督学习：你可以使用机器学习来根据鸢尾花种类的特征对数据进行分类。然而，在这种情况下，我们不会向聚类算法提供标签，这意味着它必须纯粹从测量数据中识别聚类：
- en: 'First, load the data into Go, as we have done in previous examples:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像之前示例中那样将数据加载到Go中：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to prepare the data by splitting the species column from the
    rest of the data: this will only be used for the final assessment of the groups
    after clustering. To do this, use the `DataFrameToXYs` func from previous examples:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过从数据中分割物种列来准备数据：这只是为了在聚类后对组进行最终评估。为此，使用之前示例中的`DataFrameToXYs`函数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we can train an algorithm called **k-means** to try to split the dataset
    into three clusters. k-means works by initially choosing the middle (known as
    the **centroid**) of each cluster at random, and assigning each data point in
    the training set to its nearest centroid. It then iteratively updates the positions
    of each cluster, reassigning the data points at each step until it reaches convergence.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以训练一个名为**k-means**的算法来尝试将数据集分为三个聚类。k-means通过最初随机选择每个聚类的中间点（称为**质心**），并将训练集中的每个数据点分配到最近的质心来工作。然后它迭代地更新每个聚类的位置，在每一步重新分配数据点，直到达到收敛。
- en: '**k-means** is a simple algorithm and is fast to train, so it is a good starting
    point when clustering data. However, it does require you to specify how many clusters
    to find, which is not always obvious. Other clustering algorithms, such as DBSCAN,
    do not have this limitation.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**k-means** 是一个简单的算法，训练速度快，因此在聚类数据时是一个好的起点。然而，它确实需要你指定要找到多少个聚类，这并不总是显而易见的。其他聚类算法，如DBSCAN，没有这个限制。'
- en: 'Using the k-means implementation in goml, we can try to find three clusters
    within the data. Often, you may need to use trial and error to find out how many
    clusters to use—K. If you have lots of very small clusters after running k-means,
    then you probably need to reduce K:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用goml中的k-means实现，我们可以在数据中尝试找到三个聚类。通常，你可能需要通过试错来找出要使用多少个聚类——K。如果你在运行k-means后有很多非常小的聚类，那么你可能需要减少K：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have fitted the model to the data, we can generate a prediction from
    it; that is, find out which cluster each data point belongs to:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将模型拟合到数据上，我们就可以从中生成预测；也就是说，找出每个数据点属于哪个聚类：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we are able to plot the clusters using the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码绘制聚类图：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What this does is display the data using two of the input features, `Sepal
    width` and `Sepal length`, as shown in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的就是使用输入特征中的两个，`花瓣宽度`和`花瓣长度`，来显示数据，如下面的图所示：
- en: '![](img/f936c844-bdf7-4f9f-87a7-0531cad7c1e5.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f936c844-bdf7-4f9f-87a7-0531cad7c1e5.png)'
- en: 'The shape of each point is set according to the iris species, while the color
    is set by the output of k-means, that is, which cluster the algorithm has assigned
    each data point to. What we can now see is that the clusters match the species
    of each iris almost exactly: k-means has been able to subdivide the data into
    three distinct groups that correspond to the different species.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个点的形状是根据鸢尾花种类设置的，而颜色是由k-means的输出设置的，即算法将每个数据点分配到哪个聚类。我们现在可以看到，聚类几乎完全匹配每个鸢尾花的种类：k-means已经能够将数据细分为三个对应不同种类的不同组。
- en: While k-means works very well in this case, you might find that you need to
    use a different algorithm on your own datasets. The scikit-learn library for Python
    comes with a useful demonstration of which algorithms work best on different types
    of dataset^([5]). You might also find that it is helpful to prepare your data
    in some way; for example, normalize it or apply a non-linear transformation to
    it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 k-means 在这个案例中效果很好，但你可能会发现需要在你的数据集上使用不同的算法。Python 的 scikit-learn 库提供了一个有用的演示，说明了哪些算法在不同类型的数据集上效果最佳^([5])。你也可能会发现，以某种方式准备你的数据是有帮助的；例如，对其进行归一化或对其应用非线性变换。
- en: Principal component analysis
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主成分分析
- en: '**Principal component analysis** (**PCA**) is a way to reduce the number of
    dimensions in a dataset. We can think of it as a way of compressing a dataset.
    Suppose you have 100 different variables in your dataset. It may be the case that
    many of these variables are correlated with each other. If this is the case, then
    it is possible to explain most of the variation in the data by combining variables
    to build a smaller set of data. PCA performs this task: it tries to find linear
    combinations of your input variables, and reports how much variation is explained
    by each combination.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**主成分分析** (**PCA**) 是一种降低数据集维度的方法。我们可以将其视为压缩数据集的一种方式。假设你的数据集中有 100 个不同的变量。可能的情况是，这些变量中的许多是相互关联的。如果是这样，那么通过组合变量来构建一个较小的数据集，就有可能解释数据中的大部分变化。PCA
    执行这项任务：它试图找到输入变量的线性组合，并报告每个组合解释了多少变化。'
- en: 'PCA is a method for reducing the dimensions in a dataset: in effect, summarizing
    it so that you can focus on the most important features, which explain most of
    the variation in the dataset.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PCA 是一种降低数据集维度的方法：实际上，通过总结它，你可以专注于最重要的特征，这些特征解释了数据集中大部分的变化。
- en: 'PCA can be useful for machine learning in two ways:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PCA 在机器学习中有两种用途：
- en: It can be a useful preprocessing step before applying a supervised learning
    method. After running PCA on your data, you may discover, for instance, that 95%
    of the variation is explained by only a handful of variables. You can use this
    knowledge to reduce the number of variables in your input data, which means that
    your subsequent model will train much faster.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用监督学习方法之前，它可能是一个有用的预处理步骤。在运行 PCA 后，你可能会发现，例如，95% 的变化仅由少数几个变量解释。你可以使用这些知识来减少输入数据中的变量数量，这意味着你的后续模型将训练得更快。
- en: It can also be helpful when visualizing a dataset prior to building a model.
    If your data has more than three variables, it can be very hard to visualize it
    on a graph and understand what patterns it contains. PCA lets you transform the
    data so that you can plot just the most important aspects of it.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建模型之前可视化数据集时，它也可能很有帮助。如果你的数据有超过三个变量，在图表上可视化它并理解它包含的图案可能非常困难。PCA 允许你转换数据，以便你只需绘制数据的最重要方面。
- en: 'For our example, we are going to use PCA to visualize the iris dataset. Currently,
    this has four input features: petal width, petal length, sepal width, and sepal
    length. Using PCA, we can reduce this down to two variables, which we can then
    visualize easily on a scatter plot.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用 PCA 来可视化鸢尾花数据集。目前，这个数据集有四个输入特征：花瓣宽度、花瓣长度、萼片宽度和萼片长度。使用 PCA，我们可以将其减少到两个变量，然后我们可以轻松地在散点图上可视化它们。
- en: 'Start by loading the sepal data as before, and normalizing it as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先像之前一样加载花瓣数据，并按以下方式对其进行归一化：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to convert the data into a matrix format. The `gonum` library
    has a `mat64` type that we can use for this purpose:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将数据转换为矩阵格式。`gonum` 库有一个 `mat64` 类型，我们可以用它来完成这个任务：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: PCA works by finding the **eigenvectors** and **eigenvalues** of the dataset.
    For this reason, most software libraries need the data to be in a matrix structure,
    so that standard linear algebra routines such as **blas** and **lapack** can be
    used to do the calculations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PCA 通过寻找数据集的 **特征向量** 和 **特征值** 来工作。因此，大多数软件库需要数据以矩阵结构存在，以便可以使用标准线性代数例程，如 **blas**
    和 **lapack** 来进行计算。
- en: 'Now, we can make use of gonum''s `stat` package for the PCA implementation:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以利用 gonum 的 `stat` 包来实现 PCA：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gives us two variables: `components`, which is a matrix telling us how
    to map the original variables to the new components; and `variances`, which tells
    us how much variance is explained by each component. If we print out the variance
    in each component, we can see that the first two explain 96% of the entire dataset
    (component 1 to 73%, and component 2 to 23%):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了两个变量：`components`，这是一个矩阵，告诉我们如何将原始变量映射到新成分；以及`variances`，它告诉我们每个成分解释了多少方差。如果我们打印出每个成分的方差，我们可以看到前两个成分解释了整个数据集的96%（成分1解释了73%，成分2解释了23%）：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we can transform the data into the new components, and keep the first
    two so that we can use them for visualization:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将数据转换成新的成分，并保留前两个，以便我们可以用于可视化：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following diagram shows each data point according to the first two principle
    components, while the colors indicate which iris species each one belongs to.
    We can now see that the three groups form distinct bands along the first component,
    which we could not have easily seen when plotting the four original input features
    against one another:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了每个数据点根据前两个主成分，而颜色表示每个数据点属于哪种鸢尾花物种。现在我们可以看到，三个组沿着第一个成分形成了明显的带状区域，这在将四个原始输入特征相互绘制时我们不容易看到：
- en: '![](img/8e4e724c-c63c-4871-95ce-1d20bbf7ac30.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e4e724c-c63c-4871-95ce-1d20bbf7ac30.png)'
- en: 'You could now try training a supervised learning model to use the first two
    PCA features to predict the iris species: compare its performance against a model
    trained on all four input features.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以尝试训练一个监督学习模型，使用前两个PCA特征来预测鸢尾花物种：将其性能与在所有四个输入特征上训练的模型进行比较。
- en: Summary
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered two common techniques in unsupervised machine
    learning. Both are often used by data scientists for exploratory analysis, but
    can also form part of a data processing pipeline in a production system. You have
    learned how to train a clustering algorithm to divide data automatically into
    groups. This technique might be used to categorize newly registered customers
    on an e-commerce website, so that they can be served with personalized information.
    We also introduced principal component analysis as a means of compressing data,
    in other words, reducing its dimensionality. This may be used as a preprocessing
    step before running a supervised learning technique in order to reduce the size
    of the dataset.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了无监督机器学习中的两种常见技术。这两种技术通常被数据科学家用于探索性分析，但也可以作为生产系统中数据处理管道的一部分。你学习了如何训练聚类算法自动将数据分组。这项技术可能被用于对电子商务网站上新注册的客户进行分类，以便他们能够获得个性化的信息。我们还介绍了主成分分析作为压缩数据的方法，换句话说，降低其维度。这可以用作在运行监督学习技术之前的数据预处理步骤，以减少数据集的大小。
- en: In both cases, it is possible to make use of the `gonum` and `goml` libraries
    to build efficient implementations in Go with minimal code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，都可以利用`gonum`和`goml`库在Go语言中以最少的代码构建高效的实现。
- en: Further readings
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://deepmind.com/blog/unsupervised-learning/](https://deepmind.com/blog/unsupervised-learning/).
    Retrieved April 12, 2019.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://deepmind.com/blog/unsupervised-learning/](https://deepmind.com/blog/unsupervised-learning/).
    2019年4月12日检索。'
- en: '[https://blogs.nvidia.com/blog/2019/03/18/gaugan-photorealistic-landscapes-nvidia-research/](https://blogs.nvidia.com/blog/2019/03/18/gaugan-photorealistic-landscapes-nvidia-research/).
    Retrieved April 12, 2019.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://blogs.nvidia.com/blog/2019/03/18/gaugan-photorealistic-landscapes-nvidia-research/](https://blogs.nvidia.com/blog/2019/03/18/gaugan-photorealistic-landscapes-nvidia-research/).
    2019年4月12日检索。'
- en: '[https://github.com/junyanz/CycleGAN](https://github.com/junyanz/CycleGAN).
    Retrieved April 12, 2019.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://github.com/junyanz/CycleGAN](https://github.com/junyanz/CycleGAN).
    2019年4月12日检索。'
- en: '[http://robots.stanford.edu/papers/dahlkamp.adaptvision06.pdf](http://robots.stanford.edu/papers/dahlkamp.adaptvision06.pdf).
    Retrieved April 13, 2019.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://robots.stanford.edu/papers/dahlkamp.adaptvision06.pdf](http://robots.stanford.edu/papers/dahlkamp.adaptvision06.pdf).
    2019年4月13日检索。'
- en: '[https://scikit-learn.org/stable/modules/clustering.html#overview-of-clustering-methods](https://scikit-learn.org/stable/modules/clustering.html#overview-of-clustering-methods).
    Retrieved April 12, 2019.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://scikit-learn.org/stable/modules/clustering.html#overview-of-clustering-methods](https://scikit-learn.org/stable/modules/clustering.html#overview-of-clustering-methods).
    2019年4月12日检索。'
