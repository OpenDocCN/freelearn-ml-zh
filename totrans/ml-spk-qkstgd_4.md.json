["```py\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport findspark\nfindspark.init()\nfrom pyspark import SparkContext, SparkConf\nfrom pyspark.sql import SQLContext\nfrom pyspark.ml.feature import VectorAssembler\nfrom pyspark.ml.regression import LinearRegression\nfrom pyspark.ml.evaluation import RegressionEvaluator\n```", "```py\nbike_sharing_raw_df = pd.read_csv('<Path to CSV file>', \n   delimiter = '<delimiter character>')\nbike_sharing_raw_df.head()\n```", "```py\nbike_sharing_raw_df.plot.scatter(x = '<Independent Variable>', \n   y = '<Dependent Variable>')\n```", "```py\nconf = SparkConf().setMaster(\"spark://192.168.56.10:7077\")\n   .setAppName(\"Univariate Linear Regression - Bike Sharing\")\nsc = SparkContext(conf=conf)\nsqlContext = SQLContext(sc)\n```", "```py\nbike_sharing_df = sqlContext.read\n   .format('com.databricks.spark.csv')\n   .options(header = 'true', inferschema = 'true')\n   .load('Path to CSV file')\nbike_sharing_df.head(10)\nbike_sharing_df.printSchema()\n```", "```py\nbike_sharing_df.describe().toPandas().transpose()\n```", "```py\nbike_sharing_df.toPandas().plot.scatter(x='atemp', y='cnt')\n```", "```py\nunivariate_feature_column = 'atemp'\nunivariate_label_column = 'cnt'\nvector_assembler = VectorAssembler(\n   inputCols = [univariate_feature_column], \n   outputCol = 'features')\n```", "```py\nbike_sharing_features_df = vector_assembler\n   .transform(bike_sharing_df)\n   .select(['features', univariate_label_column])\nbike_sharing_features_df.head(10)\n```", "```py\ntrain_df, test_df = bike_sharing_features_df\n   .randomSplit([0.75, 0.25], seed=12345)\ntrain_df.count(), test_df.count()\n```", "```py\nlinear_regression = LinearRegression(featuresCol = 'features', \n   labelCol = univariate_label_column)\nlinear_regression_model = linear_regression.fit(train_df)\n```", "```py\nprint(\"Model Coefficients: \" + \n   str(linear_regression_model.coefficients))\nprint(\"Intercept: \" + str(linear_regression_model.intercept))\ntraining_summary = linear_regression_model.summary\nprint(\"RMSE: %f\" % training_summary.rootMeanSquaredError)\nprint(\"R-SQUARED: %f\" % training_summary.r2)\nprint(\"TRAINING DATASET DESCRIPTIVE SUMMARY: \")\ntrain_df.describe().show()\nprint(\"TRAINING DATASET RESIDUALS: \")\ntraining_summary.residuals.show()\n```", "```py\ntest_linear_regression_predictions_df = \n   linear_regression_model.transform(test_df)\ntest_linear_regression_predictions_df\n   .select(\"prediction\", univariate_label_column, \"features\")\n   .show(10)\n```", "```py\nlinear_regression_evaluator_rmse = RegressionEvaluator(\n   predictionCol = \"prediction\", \n   labelCol = univariate_label_column, metricName = \"rmse\")\nlinear_regression_evaluator_r2 = RegressionEvaluator(\n   predictionCol = \"prediction\", \n   labelCol = univariate_label_column, metricName = \"r2\")\nprint(\"RMSE on Test Data = %g\" % linear_regression_evaluator_rmse\n   .evaluate(test_linear_regression_predictions_df))\nprint(\"R-SQUARED on Test Data = %g\" % \n   linear_regression_evaluator_r2\n   .evaluate(test_linear_regression_predictions_df))\n```", "```py\ntest_summary = linear_regression_model.evaluate(test_df)\nprint(\"RMSE on Test Data = %g\" % test_summary.rootMeanSquaredError)\nprint(\"R-SQUARED on Test Data = %g\" % test_summary.r2)\n```", "```py\nsc.stop()\n```", "```py\nindependent_variables = ['season', 'yr', 'mnth', 'holiday', \n   'weekday', 'workingday', 'weathersit', 'temp', 'atemp', \n   'hum', 'windspeed']\ndependent_variable = ['cnt']\nbike_sharing_df = bike_sharing_df.select( independent_variables + \n   dependent_variable )\nfor i in bike_sharing_df.columns:\n   print( \"Correlation to CNT for \", \n      i, bike_sharing_df.stat.corr('cnt', i))\n```", "```py\nmultivariate_feature_columns = ['season', 'yr', 'mnth', \n   'temp', 'atemp']\nmultivariate_label_column = 'cnt'\nvector_assembler = VectorAssembler(inputCols = \n   multivariate_feature_columns, outputCol = 'features')\nbike_sharing_features_df = vector_assembler\n   .transform(bike_sharing_df)\n   .select(['features', multivariate_label_column])\n```", "```py\ntrain_df, test_df = bike_sharing_features_df\n   .randomSplit([0.75, 0.25], seed=12345)\ntrain_df.count(), test_df.count()\n```", "```py\nlinear_regression = LinearRegression(featuresCol = 'features', \n   labelCol = multivariate_label_column)\nlinear_regression_model = linear_regression.fit(train_df)\n```", "```py\nindexer = StringIndexer(inputCol = \"Classification\", \n   outputCol = \"label\").fit(breast_cancer_df)\nbreast_cancer_df = indexer.transform(breast_cancer_df)\n```", "```py\nfeature_columns = ['Age', 'BMI', 'Glucose', 'Insulin', 'HOMA', \n   'Leptin', 'Adiponectin', 'Resistin', 'MCP_1']\nlabel_column = 'label'\nvector_assembler = VectorAssembler(inputCols = feature_columns, \n   outputCol = 'features')\n```", "```py\nbreast_cancer_features_df = vector_assembler\n   .transform(breast_cancer_df)\n   .select(['features', label_column])\n```", "```py\nlogistic_regression = LogisticRegression(featuresCol = 'features', \n   labelCol = label_column)\nlogistic_regression_model = logistic_regression.fit(train_df)\n```", "```py\ntest_logistic_regression_predictions_df = logistic_regression_model\n   .transform(test_df)\ntest_logistic_regression_predictions_df.select(\"probability\", \n   \"rawPrediction\", \"prediction\", label_column, \"features\").show()\n```", "```py\ntest_summary = logistic_regression_model.evaluate(test_df)\nroc = test_summary.roc.toPandas()\nplt.plot(roc['FPR'],roc['TPR'])\nplt.ylabel('False Positive Rate')\nplt.xlabel('True Positive Rate')\nplt.title('ROC Curve')\nplt.show()\nevaluator_roc_area = BinaryClassificationEvaluator(\n   rawPredictionCol = \"rawPrediction\", labelCol = label_column, \n   metricName = \"areaUnderROC\")\nprint(\"Area Under ROC Curve on Test Data = %g\" %\n   evaluator_roc_area.evaluate(\n   test_logistic_regression_predictions_df))\n\nArea Under ROC Curve on Test Data = 0.859375 \n```", "```py\nN = test_logistic_regression_predictions_df.count()\ntrue_positives = test_logistic_regression_predictions_df\n   .filter( col(\"prediction\") == 1.0 )\n   .filter( col(\"label\") == 1.0 ).count()\ntrue_negatives = test_logistic_regression_predictions_df\n   .filter( col(\"prediction\") == 0.0 )\n   .filter( col(\"label\") == 0.0 ).count()\nfalse_positives = test_logistic_regression_predictions_df\n   .filter( col(\"prediction\") == 1.0 )\n   .filter( col(\"label\") == 0.0 ).count()\nfalse_negatives = test_logistic_regression_predictions_df\n   .filter( col(\"prediction\") == 0.0 )\n   .filter( col(\"label\") == 1.0 ).count()\n```", "```py\npredictions_and_label = test_logistic_regression_predictions_df\n   .select(\"prediction\", \"label\").rdd\nmetrics = MulticlassMetrics(predictions_and_label)\nprint(metrics.confusionMatrix())\n```", "```py\nschema = StructType([\n   StructField(\"party\", StringType()),\n   StructField(\"handicapped_infants\", StringType()),\n   StructField(\"water_project_cost_sharing\", StringType()),\n   ...\n])\n```", "```py\ncategorical_columns = ['handicapped_infants', \n   'water_project_cost_sharing', ...]\npipeline_stages = []\nfor categorial_column in categorical_columns:\n   string_indexer = StringIndexer(inputCol = categorial_column, \n      outputCol = categorial_column + 'Index')\n   encoder = OneHotEncoderEstimator(\n      inputCols = [string_indexer.getOutputCol()], \n      outputCols = [categorial_column + \"classVec\"])\n   pipeline_stages += [string_indexer, encoder]\n\nlabel_string_idx = StringIndexer(inputCol = 'party', \n   outputCol = 'label')\npipeline_stages += [label_string_idx]\nvector_assembler_inputs = [c + \"classVec\" for c \n   in categorical_columns]\nvector_assembler = VectorAssembler(\n   inputCols = vector_assembler_inputs, \n   outputCol = \"features\")\npipeline_stages += [vector_assembler]\n```", "```py\npipeline = Pipeline(stages = pipeline_stages)\npipeline_model = pipeline.fit(congressional_voting_df)\nlabel_column = 'label'\ncongressional_voting_features_df = pipeline_model\n   .transform(congressional_voting_df)\n   .select(['features', label_column, 'party'])\npd.DataFrame(congressional_voting_features_df.take(5), columns=congressional_voting_features_df.columns).transpose()\n```", "```py\ndecision_tree = DecisionTreeClassifier(featuresCol = 'features', \n   labelCol = label_column)\ndecision_tree_model = decision_tree.fit(train_df)\n```", "```py\nevaluator_roc_area = BinaryClassificationEvaluator(\n   rawPredictionCol = \"rawPrediction\", labelCol = label_column, \n   metricName = \"areaUnderROC\")\nprint(\"Area Under ROC Curve on Test Data = %g\" % evaluator_roc_area.evaluate(test_decision_tree_predictions_df))\n```", "```py\nprint(str(decision_tree_model.toDebugString))\n```", "```py\nrandom_forest = RandomForestClassifier(featuresCol = 'features', \n   labelCol = label_column, minInstancesPerNode = 5)\nrandom_forest_model = random_forest.fit(train_df)\n```", "```py\ntest_random_forest_predictions_df = random_forest_model\n   .transform(test_df)\nevaluator_rf_roc_area = BinaryClassificationEvaluator(\n   rawPredictionCol = \"rawPrediction\", labelCol = label_column,\n   metricName = \"areaUnderROC\")\nprint(\"Area Under ROC Curve on Test Data = %g\" % evaluator_rf_roc_area.evaluate(test_random_forest_predictions_df))\n```"]