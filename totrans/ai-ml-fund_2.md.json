["```py\n    def ai_move(board):\n        new_boards = all_moves_from_board(board, AI_SIGN)\n        for new_board in new_boards:\n        if game_won_by(new_board) == AI_SIGN:\n        return new_board\n        return choice(new_boards)\n    ```", "```py\n    game_loop()\n    ```", "```py\n    . X .\n    . . .\n    . . .\n    Enter row: 3\n    Enter column: 1\n    . X .\n    . . .\n    O . .\n\n    . X X\n    . . .\n    O . .\n\n    Enter row: 2\n    Enter column: 1\n\n    . X X\n    O . .\n    O . .\n\n    X X X\n    O . .\n    O . .\n    Game has been ended.\n    ```", "```py\n    def all_moves_from_board(board, sign):\n        move_list = []\n        for i, v in enumerate(board):\n            if v == EMPTY_SIGN:\n                new_board = board[:i] + sign + board[i+1:]\n                move_list.append(new_board)\n                if game_won_by(new_board) == AI_SIGN:\n                    return [new_board]\n        return move_list\n    ```", "```py\n    count_possibilities()\n    ```", "```py\n    step 0\\. Moves: 1\n    step 1\\. Moves: 9\n    step 2\\. Moves: 72\n    step 3\\. Moves: 504\n    step 4\\. Moves: 3024\n    step 5\\. Moves: 8525\n    step 6\\. Moves: 28612\n    step 7\\. Moves: 42187\n    step 8\\. Moves: 55888\n    First player wins: 32395\n    Second player wins: 23445\n    Draw 35544\n    Total 91344\n    ```", "```py\nabs(5-2) + abs(1-5) = 3 + 4 = 7\n```", "```py\n    def init_utility_matrix(board):\n        return [0 if cell == EMPTY_SIGN else -1 for cell in board]\n    def generate_add_score(utilities, i, j, k):\n        def add_score(points):\n            if utilities[i] >= 0:\n                utilities[i] += points\n            if utilities[j] >= 0:\n                utilities[j] += points\n            if utilities[k] >= 0:\n                utilities[k] += points\n        return add_score\n    ```", "```py\n    def utility_matrix(board):\n        utilities = init_utility_matrix(board)\n        for [i, j, k] in combo_indices:\n            add_score = generate_add_score(utilities, i, j, k)\n            triple = [board[i], board[j], board[k]]\n            if triple.count(EMPTY_SIGN) == 1:\n                if triple.count(AI_SIGN) == 2:\n                    add_score(1000)\n                elif triple.count(OPPONENT_SIGN) == 2:\n                    add_score(100)\n            elif triple.count(EMPTY_SIGN) == 2 and triple.count(AI_SIGN) == 1:\n                add_score(10)\n            elif triple.count(EMPTY_SIGN) == 3:\n                add_score(1)\n        return utilities\n    ```", "```py\n    def best_moves_from_board(board, sign):\n        move_list = []\n        utilities = utility_matrix(board)\n        max_utility = max(utilities)\n        for i, v in enumerate(board):\n            if utilities[i] == max_utility:\n                move_list.append(board[:i] + sign + board[i+1:])\n        return move_list\n    def all_moves_from_board_list(board_list, sign):\n        move_list = []\n        get_moves = best_moves_from_board if sign == AI_SIGN else all_moves_from_board\n        for board in board_list:\n            move_list.extend(get_moves(board, sign))\n        return move_list\n    ```", "```py\n    count_possibilities()\n    ```", "```py\n    step 0\\. Moves: 1\n    step 1\\. Moves: 1\n    step 2\\. Moves: 8\n    step 3\\. Moves: 24\n    step 4\\. Moves: 144\n    step 5\\. Moves: 83\n    step 6\\. Moves: 214\n    step 7\\. Moves: 148\n    step 8\\. Moves: 172\n    First player wins: 504\n    Second player wins: 12\n    Draw 91\n    Total 607\n    ```", "```py\n    size = (7, 9)\n    start = (5, 3)\n    end = (6, 9)\n    obstacles = {\n        (3, 4), (3, 5), (3, 6), (3, 7), (3, 8),\n        (4, 5),\n        (5, 5), (5, 7), (5, 9),\n        (6, 2), (6, 3), (6, 4), (6, 5), (6, 7),\n        (7, 7)\n    }\n    ```", "```py\n    def successors(state, visited_nodes):\n        (row, col) = state\n        (max_row, max_col) = size\n        succ_states = []\n        if row > 1:\n            succ_states += [(row-1, col)]\n        if col > 1:\n            succ_states += [(row, col-1)]\n        if row < max_row:\n            succ_states += [(row+1, col)]\n        if col < max_col:\n            succ_states += [(row, col+1)]\n        return [s for s in succ_states if s not in visited_nodes if s not in obstacles]\n    ```", "```py\n    import math\n    def initialize_costs(size, start):\n        (h, w) = size\n        costs = [[math.inf] * w for i in range(h)]\n        (x, y) = start\n        costs[x-1][y-1] = 0\n        return costs\n    def update_costs(costs, current_node, successor_nodes):\n        new_cost = costs[current_node[0]-1][current_node[1]-1] + 1\n        for (x, y) in successor_nodes:\n            costs[x-1][y-1] = min(costs[x-1][y-1], new_cost)\n    def bfs_tree(node):\n        nodes_to_visit = [node]\n        visited_nodes = []\n        costs = initialize_costs(size, start)\n        while len(nodes_to_visit) > 0:\n            current_node = nodes_to_visit.pop(0)\n            visited_nodes.append(current_node)\n            successor_nodes = successors(current_node, visited_nodes)\n            update_costs(costs, current_node, successor_nodes)\n            nodes_to_visit.extend(successor_nodes)\n        return costs\n    bfs_tree(start)\n    ```", "```py\n    [[6, 5, 4, 5, 6, 7, 8, 9, 10],\n    [5, 4, 3, 4, 5, 6, 7, 8, 9],\n    [4, 3, 2, inf, inf, inf, inf, inf, 10],\n    [3, 2, 1, 2, inf, 12, 13, 12, 11],\n    [2, 1, 0, 1, inf, 11, inf, 13, inf],\n    [3, inf, inf, inf, inf, 10, inf, 14, 15],\n    [4, 5, 6, 7, 8, 9, inf, 15, 16]]\n    ```", "```py\n    def bfs_tree_verbose(node):\n        nodes_to_visit = [node]\n        visited_nodes = []\n        costs = initialize_costs(size, start)\n        step_counter = 0\n        while len(nodes_to_visit) > 0:\n            step_counter += 1\n            current_node = nodes_to_visit.pop(0)\n            visited_nodes.append(current_node)\n    ```", "```py\n            successor_nodes = successors(current_node, visited_nodes)\n            update_costs(costs, current_node, successor_nodes)\n            nodes_to_visit.extend(successor_nodes)\n            if current_node == end:\n                print(\n                    'End node has been reached in ',\n                    step_counter, '\n                    steps'\n                )\n                return costs\n        return costs\n    bfs_tree_verbose(start)\n    ```", "```py\n    [[6, 5, 4, 5, 6, 7, 8, 9, 10],\n    [5, 4, 3, 4, 5, 6, 7, 8, 9],\n    [4, 3, 2, inf, inf, inf, inf, inf, 10],\n    [3, 2, 1, 2, inf, 12, 13, 12, 11],\n    [2, 1, 0, 1, inf, 11, inf, 13, inf],\n    [3, inf, inf, inf, inf, 10, inf, 14, 15],\n    [4, 5, 6, 7, 8, 9, inf, 15, 16]]\n    ```", "```py\nfrontier = [start], internal = {}\n# Initialize the costs matrix with each cell set to infinity.\n# Set the value of distance_from_start(start) to 0.\nwhile frontier is not empty:\n    # notice n has the lowest estimated total\n    # distance between start and end.\n    n = frontier.pop()\n    # We'll learn later how to reconstruct the shortest path\n    if n == end:\n        return the shortest path.\n    internal.add(n)\n    for successor s in succ(n):\n        if s in internal:\n            continue # The node was already examined\n        new_distance = distance_from_start(n) + distance(n, s)\n        if new_distance >= distance_from_start(s):\n            # This path is not better than the path we have\n            # already examined.\n            continue\n        if s is a member of frontier:\n            update the priority of s\n        else:\n            Add s to frontier.\n```", "```py\npath = [end_node], distance = get_distance_from_start( end_node )\nwhile the distance of the last element in the path is not 0:\n    for each neighbor of the last node in path:\n        new_distance = get_distance_from_start( neighbor )\n        if new_distance < distance:\n            add neighbor to path, and break out from the for loop\nreturn path\n```", "```py\n# Import heapq to access the priority queue\nimport heapq\n# Create a list to store the data\ndata = []\n# Use heapq.heappush to push (priorityInt, value) pairs to the queue\nheapq.heappush(data, (2, 'first item'))\nheapq.heappush(data, (1, 'second item'))\n# The tuples are stored in data in the order of ascending priority\n[(1, 'second item'), (2, 'first item')]\n# heapq.heappop pops the item with the lowest score from the queue\nheapq.heappop(data)\n```", "```py\n(1, 'second item')\n# data still contains the second item\ndata\n```", "```py\n[(2, 'first item')]\n```", "```py\nimport math\nimport heapq\nsize = (7, 9)\nstart = (5, 3)\nend = (6, 9)\nobstacles = {\n    (3, 4), (3, 5), (3, 6), (3, 7), (3, 8),\n    (4, 5),\n    (5, 5), (5, 7), (5, 9),\n    (6, 2), (6, 3), (6, 4), (6, 5), (6, 7),\n    (7, 7)\n}\n# Returns the successor nodes of State, excluding nodes in VisitedNodes\ndef successors(state, visited_nodes):\n    (row, col) = state\n    (max_row, max_col) = size\n    succ_states = []\n    if row > 1:\n        succ_states += [(row-1, col)]\n    if col > 1:\n        succ_states += [(row, col-1)]\n    if row < max_row:\n        succ_states += [(row+1, col)]\n    if col < max_col:\n        succ_states += [(row, col+1)]\n    return [s for s in succ_states if s not in visited_nodes if s not in obstacles]\n```", "```py\nimport math\ndef initialize_costs(size, start):\n    costs = [[math.inf] * 9 for i in range(7)]\n    (x, y) = start\n    costs[x-1][y-1] = 0\n    return costs\n```", "```py\nfrontier = []\ninternal = set()\nheapq.heappush(frontier, (0, start))\ncosts = initialize_costs(size, start)\n```", "```py\ndef distance_heuristic(node, goal):\n    (x, y) = node\n    (u, v) = goal\n    return math.sqrt(abs(x - u) ** 2 + abs(y - v) ** 2)\n```", "```py\ndef astar(start, end):\n    frontier = []\n    internal = set()\n    heapq.heappush(frontier, (0, start))\n    costs = initialize_costs(size, start)\n    def get_distance_from_start(node):\n        return costs[node[0] - 1][node[1] - 1]\n    def set_distance_from_start(node, new_distance):\n        costs[node[0] - 1][node[1] - 1] = new_distance\n    while len(frontier) > 0:\n        (priority, node) = heapq.heappop(frontier)\n```", "```py\n        if node == end:\n            return priority\n        internal.add(node)\n        successor_nodes = successors(node, internal)\n        for s in successor_nodes:\n            new_distance = get_distance_from_start(node) + 1\n            if new_distance < get_distance_from_start(s):\n                set_distance_from_start(s, new_distance)\n                # Filter previous entries of s\n                frontier = [n for n in frontier if s != n[1]]\n                heapq.heappush(frontier, (\n                    new_distance + distance_heuristic(s, end), s\n                )\n                )\nastar(start, end)\n15.0\n```", "```py\ndef astar_verbose(start, end):\n    frontier = []\n    internal = set()\n    heapq.heappush(frontier, (0, start))\n    costs = initialize_costs(size, start)\n    def get_distance_from_start(node):\n        return costs[node[0] - 1][node[1] - 1]\n    def set_distance_from_start(node, new_distance):\n        costs[node[0] - 1][node[1] - 1] = new_distance\n    steps = 0\n    while len(frontier) > 0:\n        steps += 1\n        print('step ', steps, '. frontier: ', frontier)\n        (priority, node) = heapq.heappop(frontier)\n        print(\n            'node ',\n            node,\n            'has been popped from frontier with priority',\n            priority\n        )\n        if node == end:\n            print('Optimal path found. Steps: ', steps)\n            print('Costs matrix: ', costs)\n            return priority\n        internal.add(node)\n        successor_nodes = successors(node, internal)\n        print('successor_nodes', successor_nodes)\n        for s in successor_nodes:\n            new_distance = get_distance_from_start(node) + 1\n            print(\n                's:',\n                s,\n                'new distance:',\n                new_distance,\n                ' old distance:',\n                get_distance_from_start(s)\n            )\n            if new_distance < get_distance_from_start(s):\n                set_distance_from_start(s, new_distance)\n                # Filter previous entries of s\n                frontier = [n for n in frontier if s != n[1]]\n                new_priority = new_distance + distance_heuristic(s, end)\n                heapq.heappush(frontier, (new_priority, s))\n                print(\n        'Node',\n        s,\n        'has been pushed to frontier with priority',\n        new_priority\n    )\n    print('Frontier', frontier)\n    print('Internal', internal)\n    print(costs)\nastar_verbose(start, end)\n```", "```py\nstep 1 . Frontier: [(0, (5, 3))]\nNode (5, 3) has been popped from Frontier with priority 0\nsuccessors [(4, 3), (5, 2), (5, 4)]\ns: (4, 3) new distance: 1 old distance: inf\nNode (4, 3) has been pushed to Frontier with priority 7.324555320336759\ns: (5, 2) new distance: 1 old distance: inf\nNode (5, 2) has been pushed to Frontier with priority 8.071067811865476\ns: (5, 4) new distance: 1 old distance: inf\nNode (5, 4) has been pushed to Frontier with priority 6.0990195135927845\nstep 2 . Frontier: [(6.0990195135927845, (5, 4)), (8.071067811865476, (5, 2)), (7.324555320336759, (4, 3))]\nNode (5, 4) has been popped from Frontier with priority 6.0990195135927845\nsuccessors [(4, 4)]\ns: (4, 4) new distance: 2 old distance: inf\nNode (4, 4) has been pushed to Frontier with priority 7.385164807134504\nâ€¦\nstep 42 . Frontier: [(15.0, (6, 8)), (15.60555127546399, (4, 6)), (15.433981132056603, (1, 1)), (15.82842712474619, (4, 7))]\nNode (6, 8) has been popped from Frontier with priority 15.0\nsuccessors [(7, 8), (6, 9)]\ns: (7, 8) new distance: 15 old distance: inf\nNode (7, 8) has been pushed to Frontier with priority 16.414213562373096\ns: (6, 9) new distance: 15 old distance: inf\nNode (6, 9) has been pushed to Frontier with priority 15.0\nstep 43 . Frontier: [(15.0, (6, 9)), (15.433981132056603, (1, 1)), (15.82842712474619, (4, 7)), (16.414213562373096, (7, 8)), (15.60555127546399, (4, 6))]\nNode (6, 9) has been popped from Frontier with priority 15.0\nOptimal path found. Steps: 43\n```", "```py\nCosts matrix: [[6, 5, 4, 5, 6, 7, 8, 9, 10], [5, 4, 3, 4, 5, 6, 7, 8, 9], [4, 3, 2, inf, inf, inf, inf, inf, 10], [3, 2, 1, 2, inf, 12, 13, 12, 11], [2, 1, 0, 1, inf, 11, inf, 13, inf], [3, inf, inf, inf, inf, 10, inf, 14, 15], [4, 5, 6, 7, 8, 9, inf, 15, inf]]\n```", "```py\ndef get_shortest_path(end_node):\n    path = [end_node]\n    distance = get_distance_from_start(end_node)\n    while distance > 0:\n        for neighbor in successors(path[-1], []):\n            new_distance = get_distance_from_start(neighbor)\n            if new_distance < distance:\n                path += [neighbor]\n                distance = new_distance\n                break # for\n    return path\n```", "```py\ndef astar_with_path(start, end):\n    frontier = []\n    internal = set()\n    heapq.heappush(frontier, (0, start))\n    costs = initialize_costs(size, start)\n    def get_distance_from_start(node):\n        return costs[node[0] - 1][node[1] - 1]\n    def set_distance_from_start(node, new_distance):\n        costs[node[0] - 1][node[1] - 1] = new_distance\n    def get_shortest_path(end_node):\n        path = [end_node]\n        distance = get_distance_from_start(end_node)\n        while distance > 0:\n            for neighbor in successors(path[-1], []):\n                new_distance = get_distance_from_start(neighbor)\n                if new_distance < distance:\n                    path += [neighbor]\n                    distance = new_distance\n                    break # for\n        return path\n    while len(frontier) > 0:\n        (priority, node) = heapq.heappop(frontier)\n        if node == end:\n            return get_shortest_path(end)\n        internal.add(node)\n        successor_nodes = successors(node, internal)\n        for s in successor_nodes:\n            new_distance = get_distance_from_start(node) + 1\n            if new_distance < get_distance_from_start(s):\n                set_distance_from_start(s, new_distance)\n                # Filter previous entries of s\n                frontier = [n for n in frontier if s != n[1]]\n                heapq.heappush(frontier, (\n                    new_distance + distance_heuristic(s, end), s\n                )\n                )\nastar_with_path( start, end )\n```", "```py\n[(6, 9),\n(6, 8),\n(5, 8),\n(4, 8),\n(4, 9),\n(3, 9),\n(2, 9),\n(2, 8),\n(2, 7),\n(2, 6),\n(2, 5),\n(2, 4),\n(2, 3),\n(3, 3),\n(4, 3),\n(5, 3)]\n```", "```py\npip install simpleai\n```", "```py\nfrom simpleai.search import SearchProblem, astar\n```", "```py\n    import math\n    from simpleai.search import SearchProblem, astar\n    class ShortestPath(SearchProblem):\n        def __init__(self, size, start, end, obstacles):\n            self.size = size\n            self.start = start\n            self.end = end\n    ```", "```py\n            self.obstacles = obstacles\n            super(ShortestPath, self).__init__(initial_state=self.start)\n        def actions(self, state):\n            (row, col) = state\n            (max_row, max_col) = self.size\n            succ_states = []\n            if row > 1:\n                succ_states += [(row-1, col)]\n            if col > 1:\n                succ_states += [(row, col-1)]\n            if row < max_row:\n                succ_states += [(row+1, col)]\n            if col < max_col:\n                succ_states += [(row, col+1)]\n            return [s for s in succ_states if s not in self._obstacles]\n        def result(self, state, action):\n            return action\n        def is_goal(self, state):\n            return state == end\n        def cost(self, state, action, new_state):\n            return 1\n        def heuristic(self, state):\n            (x, y) = state\n            (u, v) = self.end\n            return math.sqrt(abs(x-u) ** 2 + abs(y-v) ** 2)\n    size = (7, 9)\n    start = (5, 3)\n    end = (6, 9)\n    obstacles = {\n        (3, 4), (3, 5), (3, 6), (3, 7), (3, 8),\n        (4, 5),\n        (5, 5), (5, 7), (5, 9),\n        (6, 2), (6, 3), (6, 4), (6, 5), (6, 7),\n        (7, 7)\n    }\n    searchProblem = ShortestPath(Size, Start, End, Obstacles)\n    result = astar( searchProblem, graph_search=True )\n    result\n    Node <(6, 9)>\n    result.path()\n    [(None, (5, 3)),\n    ((4, 3), (4, 3)),\n    ((3, 3), (3, 3)),\n    ((2, 3), (2, 3)),\n    ((2, 4), (2, 4)),\n    ((2, 5), (2, 5)),\n    ((2, 6), (2, 6)),\n    ((2, 7), (2, 7)),\n    ((2, 8), (2, 8)),\n    ((2, 9), (2, 9)),\n    ((3, 9), (3, 9)),\n    ((4, 9), (4, 9)),\n    ((4, 8), (4, 8)),\n    ((5, 8), (5, 8)),\n    ((6, 8), (6, 8)),\n    ((6, 9), (6, 9))]\n    ```", "```py\ndef min_max( state, depth, is_maximizing):\n    if depth == 0 or is_end_state( state ):\n    &#9;return utility( state )\n    if is_maximizing:\n        utility = 0\n        for s in successors( state ):\n            score = MinMax( s, depth - 1, false )\n            utility = max( utility, score )\n        return utility\n    else\n        utility = infinity\n        for s in successors( state ):\n            score = MinMax( s, depth - 1, true )\n            utility = min( utility, score )\n        return utility\n```", "```py\ndef min_max(state, depth, is_maximizing, alpha, beta):\n    if depth == 0 or is_end_state(state):\n    &#9;return utility(state)\n    if is_maximizing:\n        utility = 0\n        for s in successors(state):\n            score = MinMax(s, depth - 1, false, alpha, beta)\n            utility = max(utility, score)\n        return utility\n    else\n```", "```py\n        utility = infinity\n        for s in successors(state):\n            score = MinMax(s, depth - 1, true, alpha, beta)\n            utility = min(utility, score)\n        return utility\n```", "```py\ndef min_max(state, depth, is_maximizing, alpha, beta):\n    if depth == 0 or is_end_state(state):\n    &#9;return utility(state)\n    if is_maximizing:\n        utility = 0\n        for s in successors(state):\n            score = MinMax(s, depth - 1, false, alpha, beta)\n            utility = max(utility, score)\n            alpha = max(alpha, score)\n            if beta <= alpha:\n                break\n        return utility\n    else\n        utility = infinity\n        for s in successors(state):\n            score = MinMax(s, depth - 1, true, alpha, beta)\n            utility = min(utility, score)\n        return utility\n```", "```py\ndef min_max(state, depth, is_maximizing, alpha, beta):\n    if depth == 0 or is_end_state( state ):\n    &#9;return utility(state)\n    if is_maximizing:\n        utility = 0\n```", "```py\n        for s in successors(state):\n            score = min_max(s, depth - 1, false, alpha, beta)\n            utility = max(utility, score)\n            alpha = max(alpha, score)\n            if beta <= alpha: break\n        return utility\n    else\n        utility = infinity\n        for s in successors(state):\n            score = min_max(s, depth - 1, true, alpha, beta)\n            utility = min(utility, score)\n            beta = min(beta, score)\n            if beta <= alpha: break\n        return utility\n```", "```py\nalpha = infinity\nbeta = -infinity\n```", "```py\ndef Negamax(state, depth, is_players_point_of_view):\n    if depth == 0 or is_end_state(state):\n        return utility(state, is_players_point_of_view)\n    utility = 0\n    for s in successors(state):\n        score = Negamax(s,depth-1,not is_players_point_of_view)\n    return score\n```", "```py\npip install easyai\n```", "```py\nfrom easyAI import TwoPlayersGame\nfrom easyAI.Player import Human_Player\nclass TicTacToe( TwoPlayersGame ):\n    \"\"\" The board positions are numbered as follows:\n            7 8 9\n            4 5 6\n            1 2 3\n    \"\"\"    \n    def __init__(self, players):\n        self.players = players\n        self.board = [0 for i in range(9)]\n        self.nplayer = 1 # player 1 starts.\n\n    def possible_moves(self):\n        return [i+1 for i,e in enumerate(self.board) if e==0]\n\n```", "```py\n    def make_move(self, move):\n        self.board[int(move)-1] = self.nplayer\n    def unmake_move(self, move): # optional method (speeds up the AI)\n        self.board[int(move)-1] = 0\n\n    def lose(self):\n        \"\"\" Has the opponent \"three in line ?\" \"\"\"\n        return any( [all([(self.board[c-1]== self.nopponent)\n                      for c in line])\n                      for line in [[1,2,3],[4,5,6],[7,8,9],\n                                   [1,4,7],[2,5,8],[3,6,9],\n                                   [1,5,9],[3,5,7]]])\n\n    def is_over(self):\n        return (self.possible_moves() == []) or self.lose()\n\n    def show(self):\n        print ('\\n'+'\\n'.join([\n                        ' '.join([['.','O','X'][self.board[3*j+i]]\n                        for i in range(3)])\n                 for j in range(3)]) )\n\n    def scoring(self):\n        return -100 if self.lose() else 0\n\nif __name__ == \"__main__\":\n\n    from easyAI import AI_Player, Negamax\n    ai_algo = Negamax(6)\n    TicTacToe( [Human_Player(),AI_Player(ai_algo)]).play()\n```"]