- en: Chapter 3. Image Filters and Morphological Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 图像滤波器和形态学算子
- en: After learning the basics of setting up OpenCV for Java and dealing with a graphical
    user interface, it is time to explore some of the core operators in image processing.
    Some of them come from signal processing and we call them filters, as they usually
    help you to get away with noise from images. It is important to know that several
    digital filters have their optical counterparts. Other operators play a useful
    role when dealing with binary images, such as the morphological operators, which
    will help you to isolate regions or glue some of them together. We will also cover,
    in detail, the famous **bucket fill tool**, which is very useful in segmentation.
    When dealing with large images, it is important to know how image pyramids can
    help you decrease your image size without losing important information and by
    achieving performance. We will finish this chapter with one of the simplest and
    most useful techniques for segmentation, which is applying a threshold to separate
    regions as well as studying a dynamic threshold that will not suffer much from
    lighting problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习设置OpenCV的Java基础和图形用户界面处理之后，现在是时候探索图像处理中的核心算子了。其中一些来自信号处理，我们称它们为滤波器，因为它们通常帮助您从图像中去除噪声。重要的是要知道，几种数字滤波器有它们的光学对应物。其他算子在处理二值图像时扮演着有用的角色，例如形态学算子，它可以帮助您隔离区域或将它们中的某些部分粘合在一起。我们还将详细介绍著名的**桶填充工具**，它在分割中非常有用。在处理大图像时，了解图像金字塔如何帮助您在不丢失重要信息的情况下减小图像大小并提高性能是很重要的。我们将以分割中最简单且最有用的技术之一结束本章，即应用阈值来分离区域，以及研究一个不会受到光照问题影响太多的动态阈值。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Smoothing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平滑
- en: Morphological operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形态学算子
- en: Flood filling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洪水填充
- en: Image pyramids
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像金字塔
- en: Thresholding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阈值化
- en: By the end of this chapter, you will be able to perform several filtering procedures
    over an image, such as removing noise, growing, shrinking and filling some areas,
    as well as deciding whether some pixels fit or not in accordance with a given
    criteria.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够对图像执行多个过滤过程，例如去除噪声、生长、收缩和填充某些区域，以及根据给定的标准判断某些像素是否适合。
- en: Smoothing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平滑
- en: 'Just like in one-dimensional signals, we are always susceptible to receiving
    some noise in our images and we generally apply some preprocessing filters to
    them before we perform our main work on the images. We can consider noise as a
    random variation of color or brightness information that is not present in the
    imaged object, which can take place undesirably due to a sensor and circuitry
    of a digital camera or scanner. This section uses the ideas of low-pass filter
    kernels to smoothen our images. These filters remove high frequency content, such
    as edges and noises, although some techniques allow edges not to be blurred. We
    will cover the four main image filters available in OpenCV: averaging, Gaussian,
    median filtering, and bilateral filtering.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在一维信号中一样，我们在图像中总是容易受到一些噪声的影响，在我们对图像进行主要工作之前，我们通常会对它们应用一些预处理滤波器。我们可以将噪声视为图像对象中不存在的颜色或亮度信息的随机变化，这可能是由于数码相机或扫描仪的传感器和电路的不理想造成的。本节使用低通滤波器核的思想来平滑我们的图像。这些滤波器移除了高频内容，如边缘和噪声，尽管一些技术允许边缘不被模糊。我们将介绍OpenCV中可用的四种主要图像滤波器：平均滤波、高斯滤波、中值滤波和双边滤波。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**2D Kernel** **Convolution** is a form of mathematical convolution. An output
    image is calculated by sweeping each of the pixels of a given image and applying
    a kernel operator to them, yielding an output pixel for each resulting operation.
    For instance, the kernel operator can be a 3 x 3 matrix of 1s divided by 9\. This
    way, each output pixel will be the average value of the 9 neighbor pixels for
    each pixel in the input image, yielding an average output image.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**二维核** **卷积**是一种数学卷积形式。输出图像是通过扫描给定图像的每个像素并对其应用核算子来计算的，为每个操作结果生成一个输出像素。例如，核算子可以是一个由1组成的3x3矩阵，除以9。这样，每个输出像素将是输入图像中每个像素的9个相邻像素的平均值，从而得到一个平均输出图像。'
- en: Averaging
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平均
- en: 'Most of the blurring techniques will use a 2D kernel convolution to filter
    images. The simplest idea is to have a 3 x 3 kernel that has a total of 9 pixels.
    Suppose we want to have the average value of 9 pixels, we will only need to add
    them and divide by 9\. This is accomplished by the convolution with the following
    kernel:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模糊技术将使用2D核卷积来过滤图像。最简单的方法是使用一个3 x 3的核，它总共有9个像素。假设我们想要9个像素的平均值，我们只需要将它们相加然后除以9。这是通过以下核的卷积来实现的：
- en: '![Averaging](img/3972OS_03_16.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![平均](img/3972OS_03_16.jpg)'
- en: 'In order to apply this transformation, we will use Imgproc''s `blur` function.
    Its syntax is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用此转换，我们将使用Imgproc的`blur`函数。其语法如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The parameters are, simply, the source image, destination, and the kernel size,
    which is as simple as `new Size(3.0, 3.0)` for our 3 x 3 kernel. You can optionally
    add the `Point` anchor parameter, shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 参数很简单，就是源图像、目标图像和核大小，对于我们的3 x 3核来说，就像`new Size(3.0, 3.0)`一样简单。你可以选择性地添加`Point`锚点参数，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding line will let you position the anchor as well as an `int borderType`
    integer variable outside the center point. This `borderType` parameter lets you
    define how you want the behavior when part of the kernel is inside and outside
    the image. Note that in the first row, the preceding kernel will look for values
    that will be on top of the row, so OpenCV will need to extrapolate them. There
    are a few options available to extrapolate borders. From the documentation, we
    have the following types of borders, all available from `Core` constants, for
    instance: `Core.BORDER_REPLICATE`. For example, consider `|` as one of the image
    borders and `abcdefgh` as pixel values:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行将允许你将锚点以及一个`int borderType`整数变量放置在中心点之外。这个`borderType`参数让你定义当核的一部分在图像内部和外部时，你希望的行为。请注意，在第一行，前一个核将寻找将位于行顶部的值，因此OpenCV需要对这些值进行外推。有一些选项可用于外推边界。根据文档，我们有以下类型的边界，所有这些都可以从`Core`常量中获取，例如：`Core.BORDER_REPLICATE`。例如，考虑`|`作为图像的一个边界，并将`abcdefgh`作为像素值：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The default value is `Core.BORDER_DEFAULT` that maps to `Core.BORDER_REFLECT_101`.
    For more information on how to use this function, look for the source code of
    this chapter''s `imageFilter` project. The following is a screenshot of the main
    application, which lets you try out each of these filters:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是`Core.BORDER_DEFAULT`，它映射到`Core.BORDER_REFLECT_101`。有关如何使用此函数的更多信息，请查找本章`imageFilter`项目的源代码。以下是该主应用的截图，它允许你尝试这些过滤器中的每一个：
- en: '![Averaging](img/3972OS_03_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![平均](img/3972OS_03_01.jpg)'
- en: Note that this application also provides some simple Gaussian noise, whose probability
    density function is equal to that of the normal distribution, to see the benefits
    of each filter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此应用程序还提供了一些简单的高斯噪声，其概率密度函数等于正态分布，以查看每个滤波器的优点。
- en: Gaussian
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高斯
- en: 'The idea behind Gaussian is the same as average filtering except for the fact
    that instead of using the same weight for each of the pixels, a two-dimensional
    Gaussian function is used for the kernel that gives the highest weightage to the
    pixel in the center. The following graph displays the behavior of a 2D Gaussian
    curve:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯背后的思想与平均滤波相同，只是对于每个像素不使用相同的权重，而是使用一个二维高斯函数作为核，该核给予中心像素最高的权重。以下图表显示了二维高斯曲线的行为：
- en: '![Gaussian](img/3972OS_03_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![高斯](img/3972OS_03_02.jpg)'
- en: 'In order to use this function, employ the following basic signature:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用此函数，请使用以下基本签名：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Mat src` and `Mat dst` parameters are straightforward since they describe
    the input and output images. The `Size ksize` parameter describes the kernel's
    width and height. Hence, if you want to set its size, this parameter must be positive
    and odd, so that the kernel can be symmetrical and have a center. In case you
    set the parameter to zero, the size will be calculated from `double sigmaX`. Sigma
    is its standard deviation, which is roughly *half width at half max* of the Gaussian
    value, which means that it is half the width of the Gaussian value when its height
    is half the highest Gaussian value. Optionally, you can also provide the fifth
    parameter as `sigmaY`, which is the standard deviation for the *y* axis. In case
    you don't use this parameter, `sigmaY` will be equal to `sigmaX`. Also, if both
    `sigmaX`, and `sigmaY` are zero, they are computed from the kernel's width and
    height. The `getGaussianKernel` function returns all the Gaussian coefficients
    in case they are required. A sixth parameter can also be given to the `GaussianBlur`
    function, which is how borders will behave. This parameters works just like the
    `int borderType` parameter from the *Averaging* section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat src`和`Mat dst`参数很简单，因为它们描述了输入和输出图像。`Size ksize`参数描述了核的宽度和高度。因此，如果你想设置其大小，此参数必须是正数且为奇数，以便核可以是对称的并且有中心。如果你将此参数设置为零，大小将根据`double
    sigmaX`计算。Sigma是其标准差，大约是高斯值的*半最大值宽度*，这意味着当其高度是最高高斯值的一半时，它是高斯值宽度的一半。可选地，你也可以提供第五个参数作为`sigmaY`，它是*y*轴的标准差。如果你不使用此参数，`sigmaY`将与`sigmaX`相等。此外，如果`sigmaX`和`sigmaY`都为零，它们将根据核的宽度和高度计算。`getGaussianKernel`函数在需要时返回所有高斯系数。`GaussianBlur`函数还可以提供一个第六个参数，这决定了边界的行为。此参数与*平均*部分中的`int
    borderType`参数的工作方式相同。'
- en: 'An example of how to use `GaussianBlur` can be taken from the sample `imageFilter`
    project from this chapter:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用`GaussianBlur`的示例可以取自本章的示例`imageFilter`项目：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding line sets sigma to `0` and makes the function calculate it from
    the kernel''s size by using the following formula:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行将sigma设置为`0`，并使函数通过以下公式根据核的大小来计算它：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `ksize` is the kernel's aperture size, which would be `3` for our example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ksize`是核的孔径大小，在我们的例子中将是`3`。
- en: Median filtering
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中值滤波
- en: 'Another idea to make a filter is to select the median pixel in a kernel instead
    of the mean value, which is to select the pixel that would be in the middle of
    a line of intensity-sorted pixels. This is accomplished by using the following
    function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 制作滤波器的另一个想法是选择核中的中值像素而不是平均值，这意味着选择位于强度排序像素行中间的像素。这是通过以下函数实现的：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Mat src` and `dst` parameters are the input and output images, respectively,
    while `int ksize` is the kernel's aperture size, which must be odd and greater
    than 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat src`和`dst`参数分别是输入和输出图像，而`int ksize`是核的孔径大小，它必须是奇数且大于1。'
- en: Sometimes, the image noise is very high and it can appear as large isolated
    outlier points, which would cause a noticeable average shift. In order to overcome
    these problems, a median filter can be used to ignore these outliers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，图像噪声非常高，它可能表现为大型的孤立异常点，这会导致平均值的明显偏移。为了克服这些问题，可以使用中值滤波器来忽略这些异常点。
- en: Bilateral filtering
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双边滤波
- en: 'While median, Gaussian, and averaging filters tend to smoothen noise and edges,
    the main advantage of using bilateral filtering is the fact that it will preserve
    them, since they present important information, such as, the boundary of a cell
    in some medical imaging, which should not be filtered out. The tricky part of
    this filter is that it considers both the spatial distance and pixel intensity
    difference when calculating the average, which means that it will not include
    pixels that have intensity differences above a given threshold when calculating
    the output image. Note the effect of bilateral filtering in a marble checkboard
    using the `imageFilter` sample project from this chapter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 median、Gaussian 和平均滤波器倾向于平滑噪声和边缘，但使用双边滤波的主要优点是它将保留它们，因为它们提供了重要的信息，例如，在医学成像中某些细胞边界的信息，这些信息不应该被过滤掉。这个滤波器的难点在于它在计算平均值时考虑了空间距离和像素强度差异，这意味着在计算输出图像时，它不会包括强度差异超过给定阈值的像素。注意本章的`imageFilter`示例项目在大理石棋盘上双边滤波的效果：
- en: '![Bilateral filtering](img/3972OS_03_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![双边滤波](img/3972OS_03_03.jpg)'
- en: 'The right-hand image shows a filtered marble while preserving the edges, something
    that does not happen when you use other filters. One of the drawbacks of this
    method is that soft texture details tend to be removed, like in the white square
    of the third line and second column of the previous image. The function signature
    is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧图像展示了在保留边缘的同时过滤后的弹珠，这是使用其他过滤器时不会发生的情况。这种方法的一个缺点是，软纹理细节往往会丢失，就像在上一张图片第三行第二列的白色方块中那样。函数签名如下：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While `Mat src` and `Mat dst` are the input and output images, respectively,
    the `int d` parameter is the diameter of the considered neighborhood. If it is
    non-positive, the diameter will be calculated from the `sigmaSpace` parameter.
    The filter sigma in color space is defined by the `double sigmaColor` parameter,
    which means that for higher values, farther colors in the neighborhood will be
    considered when calculating the output color of a pixel, creating a watercolor
    effect. `Double sigmaSpace` is the sigma value in the coordinate space, which
    means that as long as colors are not skipped because of `sigmaColor`, they will
    have pretty much the same average component as in Gaussian. Remember that the
    watercolor effect can be very useful as a first step when segmenting images. If
    you need control over the border type, the `int borderType` parameter can be added
    as the last one, like in the previous filters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Mat src`和`Mat dst`分别是输入和输出图像，`int d`参数是考虑的邻域直径。如果它是非正的，直径将根据`sigmaSpace`参数计算。颜色空间中的滤波器sigma由`double
    sigmaColor`参数定义，这意味着对于更高的值，在计算像素的输出颜色时，会考虑邻域中更远的颜色，从而产生水彩效果。`Double sigmaSpace`是坐标空间中的sigma值，这意味着只要由于`sigmaColor`而没有跳过颜色，它们将具有与高斯相当的平均成分。记住，水彩效果在图像分割的第一步时可能非常有用。如果您需要控制边界类型，可以将`int
    borderType`参数作为最后一个参数添加，就像在之前的过滤器中那样。
- en: When considering intensity differences to calculate the new average value of
    a pixel, another Gaussian function is used. Note that because of this additional
    step, bilateral filtering should be used with smaller kernel sizes (for instance,
    5) when dealing with real-time images, while a kernel of size 9 might be good
    enough for offline applications. Note that when using a 3 x 3 neighborhood for
    a kernel of size 3, only 9 pixels are verified in the convolution of each pixel.
    On the other hand, when using a kernel of size 9, 9 x 9 pixels are verified, which
    makes the algorithm search for around 81 pixels. This could take 9 times longer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑强度差异以计算像素的新平均值时，会使用另一个高斯函数。请注意，由于这个额外步骤，在处理实时图像时，应该使用较小的核大小（例如，5）进行双边滤波，而对于离线应用，大小为9的核可能已经足够。请注意，当使用3
    x 3邻域对大小为3的核进行卷积时，每个像素的卷积中只验证了9个像素。另一方面，当使用大小为9的核时，会验证9 x 9像素，这使得算法在搜索时大约需要9倍的时间。
- en: Morphological operators
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态学算子
- en: Some image operations are called morphological operations, since they change
    the shape of an underlying object. We will discuss erosion and dilation, which
    are some very useful morphological transformations in this section as well as
    some derived transformations. They usually appear in the context of isolating
    elements, removing noise, and joining distanced elements in an image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一些图像操作被称为形态学操作，因为它们会改变底层对象的形状。我们将讨论腐蚀和膨胀，这些是在本节中也非常有用的形态学变换，以及一些派生变换。它们通常出现在隔离元素、去除噪声和连接图像中距离较远的元素的情况下。
- en: 'These operators work through the convolution of a given kernel with the image.
    This kernel is described with an anchor point, which is the one that is probed
    against a region of pixels, depending on its shape:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算子通过将给定的核与图像进行卷积来工作。这个核通过一个锚点来描述，该锚点用于探测像素区域，这取决于其形状：
- en: '![Morphological operators](img/3972OS_03_17.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![形态学算子](img/3972OS_03_17.jpg)'
- en: The preceding image shows a bright region on the image, which we will call **A**.
    Note that the complement region is completely dark. Our kernel is made of a 3
    x 3 block with an anchor at its center, described as **B**. The **C** region is
    the result of applying the erosion morphological transformation over the image.
    Note that this operation takes place when you scan each pixel of the image, center
    the kernel anchor on each of these pixels, and then retrieve the local minimum
    over the kernel area. Note that erosion will reduce the bright areas.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了图像上的一个亮区，我们将称之为**A**。请注意，补区域是完全黑暗的。我们的内核由一个中心锚点的3 x 3块组成，描述为**B**。**C**区域是应用侵蚀形态学变换后的图像结果。请注意，这个操作发生在扫描图像的每个像素时，将内核锚点中心对准这些像素，然后在该内核区域内检索局部最小值。请注意，侵蚀会减少亮区。
- en: The opposite operation is called dilation and the difference between these two
    is that in dilation, instead of computing the local minimum over the kernel area
    it will compute the local maximum over that area. This operation will expand a
    bright region of 3 x 3 square blocked kernels.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的操作称为膨胀，这两种操作的区别在于，在膨胀中，它不是在内核区域内计算局部最小值，而是在该区域内计算局部最大值。这个操作将扩展一个3 x 3方形阻塞内核的亮区。
- en: 'In order to get a better picture of how these operators work, a good idea is
    to try the `morphology` project from this chapter''s source code. It is basically
    OpenCV''s official C++ `morphology2` example translated to Java with some minor
    GUI enhancements. Note that in case of multichannel images, each channel is processed
    independently. The following screenshot shows the running application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解这些算子的工作原理，一个不错的主意是尝试本章源代码中的`morphology`项目。它基本上是将OpenCV的官方C++ `morphology2`示例翻译成Java，并添加了一些小的GUI增强。请注意，在多通道图像的情况下，每个通道都是独立处理的。以下截图显示了正在运行的应用程序：
- en: '![Morphological operators](img/3972OS_03_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![形态学算子](img/3972OS_03_05.jpg)'
- en: Note that our kernel bounding box is 2 times the kernel size slider parameter
    plus 1, so, if the kernel size parameter is selected as 1, we will have a 3 x
    3 kernel bounding box. We also described our example in terms of a square kernel,
    but it could be of any shape, so the shape parameter is also there for us to choose
    from. In order to create these kernels easily, Imgproc's `getStructuringElement`
    function is used. This function will take the kernel's shape, its size, and zero
    indexed anchor position as its parameters. The kernel shape can be `Imgproc.CV_SHAPE_RECT`
    (for rectangles), `Imgproc.CV_SHAPE_ELLIPSE` (for ellipses), or `Imgproc.CV_SHAPE_CROSS`
    (for a cross-shaped kernel).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的内核边界框是内核大小滑块参数的两倍加1，因此，如果内核大小参数选择为1，我们将有一个3 x 3的内核边界框。我们还用平方内核的术语描述了我们的示例，但它可以是任何形状，因此形状参数也是我们可以选择的。为了轻松创建这些内核，我们使用了Imgproc的`getStructuringElement`函数。这个函数将接受内核的形状、大小和零索引锚点位置作为其参数。内核形状可以是`Imgproc.CV_SHAPE_RECT`（用于矩形）、`Imgproc.CV_SHAPE_ELLIPSE`（用于椭圆）或`Imgproc.CV_SHAPE_CROSS`（用于十字形内核）。
- en: 'We have put all image operations in the `ImageProcessor` class, which we will
    highlight in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有图像操作放入`ImageProcessor`类中，我们将在以下代码中突出显示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As all our methods create a kernel in the same way, we have extracted the `getKernelFromShape`
    method, which will simply call the `getStructuringElement` function with the size
    described in the preceding code. As we have a custom kernel, we will call the
    overloaded `Imgproc.erode` function with the input image, output image, and kernel
    as a third parameter. The following screenshot is a result of the erosion function
    over a given input image:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所有的方法都以相同的方式创建内核，我们已经提取了`getKernelFromShape`方法，它将简单地使用前面代码中描述的大小调用`getStructuringElement`函数。由于我们有一个自定义内核，我们将使用重载的`Imgproc.erode`函数，将输入图像、输出图像和内核作为第三个参数。以下截图是侵蚀函数在给定输入图像上的结果：
- en: '![Morphological operators](img/3972OS_03_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![形态学算子](img/3972OS_03_06.jpg)'
- en: 'Note that this operator is frequently used to remove speckle noise from an
    image, as it will be eroded to nothing, while larger regions that contain important
    information will practically not be affected. Note that smoothing filters will
    not completely remove speckle noise as they tend to decrease its amplitude. Also
    pay attention that these operations are sensitive to kernel size, so a size adjustment
    and some experimenting is required. We can also check out the result of applying
    dilation in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个算子经常被用来从图像中去除斑纹噪声，因为它会被腐蚀至无，而包含重要信息的较大区域实际上不会受到影响。请注意，平滑滤波器不会完全去除斑纹噪声，因为它们倾向于降低其幅度。此外，请注意，这些操作对核大小敏感，因此需要进行大小调整和一些实验。我们还可以查看以下截图中应用膨胀的结果：
- en: '![Morphological operators](img/3972OS_03_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![形态学算子](img/3972OS_03_07.jpg)'
- en: Note that besides making areas thicker, the dilate morphological transformation
    is also very useful in searching for connected components, which are large regions
    of similar pixel intensity. It might be necessary when a large region is broken
    into smaller ones because of shadows, noise, or other effects, as can be seen
    in the lower part of the image in the preceding screenshot. Applying dilation
    will make them link together to a bigger element.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了使区域变厚外，膨胀形态学变换在搜索连接组件（像素强度相似的大区域）方面也非常有用。当由于阴影、噪声或其他效果将大区域分割成更小的区域时，可能需要这样做。如前一个截图中的图像底部所示。应用膨胀将使它们连接成一个更大的元素。
- en: 'We also derived morphological transformations, which are **open** and **close**.
    Open is defined by erosion followed by a dilation, while in a close operation,
    the dilation happens first. The following is a screenshot of an open transform:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还推导出了形态学变换，即**开**和**闭**。开是通过腐蚀后跟膨胀来定义的，而在闭合操作中，膨胀先发生。以下是一个开变换的截图：
- en: '![Morphological operators](img/3972OS_03_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![形态学算子](img/3972OS_03_08.jpg)'
- en: 'This operation is generally used while counting regions from a binary image.
    For example, we might use it to separate regions that are too near each other
    before counting them. Note that in the bottom part of our example, only larger
    areas have survived the operation while preserving the non-connectedness between
    the large areas that were apart. On the other hand, we can see the effects of
    applying the close operation to the same image, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作通常在从二值图像中计数区域时使用。例如，我们可能用它来在计数之前分离彼此过于接近的区域。请注意，在我们的示例底部，只有较大的区域在操作中幸存下来，同时保持了原本分离的大区域之间的非连通性。另一方面，我们可以看到将闭合操作应用于同一图像的效果，如下面的截图所示：
- en: '![Morphological operators](img/3972OS_03_09.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![形态学算子](img/3972OS_03_09.jpg)'
- en: Check whether this tends to connect nearby regions. Depending on the kernel
    size, it might be useful in connected component algorithms to reduce segments
    generated by noise. Unlike erosion and dilation, both open and close morphological
    transformations tend to preserve the areas of their regions of interest.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这是否会连接邻近的区域。根据核大小，它可能在连接组件算法中用来减少由噪声生成的片段。与腐蚀和膨胀不同，开闭形态学变换倾向于保留其感兴趣区域的面积。
- en: Flood filling
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点填充
- en: Another very important algorithm for segmentation is flood fill, also known
    as region growing. Most of you who have already worked with popular computer graphic
    programs, such as Microsoft Paint or GIMP will have probably used the bucket fill
    or paint bucket tool, which fills an area with a color. Although it might look
    like a very simple algorithm at first sight, it has a very interesting implementation
    and has several parameters that can make it work well to segment images.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的分割算法是浮点填充，也称为区域增长。你们中已经使用过流行计算机图形程序的人，比如Microsoft Paint或GIMP，可能已经使用过桶填充或画桶工具，它用颜色填充一个区域。尽管乍一看这可能看起来是一个非常简单的算法，但它有一个非常有趣的实现，并且有几个参数可以使它很好地分割图像。
- en: The idea behind the algorithm is to check for connected components, which are
    the areas with similar color or brightness, starting from a given point—the so-called
    seed point—and then examining this particular point's neighbors. These can include
    either 4 (north, south, east, and west) or 8 neighbors (north, north-east, east,
    south-east, south, south-west, west, and north-west) that check for a condition
    and then recursively, call the same procedure on each of the neighbors in case
    they have passed that condition. It will, naturally, add that point to the given
    connected component in case the condition is true. We generally seek for pixels
    that are either like the seed point or like their neighbor points, depending on
    which mode of flood fill will operate. We call it a fixed range when pixels are
    compared against the seed point and we call it a floating range when pixels are
    compared against neighbor pixels. This condition also accepts lower difference
    *loDiff* and higher difference *upDiff* parameters, which enter in the condition
    according to the *src(x',y') – loDiff < src (x,y) < src(x',y') + upDiff* equation.
    In this equation, *src(x,y)* is the value of the pixel at the *x*, *y* coordinates
    that are tested to check whether it belongs to the same domain as the seed point,
    while *src(x',y')* is the value of one of the pixels that is already known to
    belong to that component in case of a grayscale image operating in a floating
    range. In case we have a fixed range flood fill, the equation turns into *src(seed.x,seed.y)
    – loDiff < src (x,y) < src(seed.x,seed.y) + upDiff*, where *seed.x* and *seed.y*
    are the seed's coordinates. Also note that in case of a colored image, each of
    the pixel's components are tested against the condition, while *loDiff* and *highDiff*
    are tridimensional scalars. All in all, a new pixel will be added to the domain
    in case its brightness or color is close enough to one of its neighbors that already
    belongs to the connected component in case of a floating range flood fill or close
    enough to the seed's properties in the case of a fixed range one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 算法背后的思想是从一个给定的点——所谓的种子点——开始，检查连接组件，即具有相似颜色或亮度的区域，然后检查这个特定点的邻居。这些邻居可以是4个（北、南、东和西）或8个（北、东北、东、东南、南、西南、西和西北），它们会检查一个条件，然后递归地，对每个满足条件的邻居执行相同的程序。如果条件为真，它自然会将该点添加到给定的连接组件中。我们通常寻找与种子点或其邻居点相似的像素，这取决于哪种洪水填充模式将运行。我们称像素与种子点比较时为固定范围，而像素与邻居像素比较时为浮动范围。此条件还接受较低差异*loDiff*和较高差异*upDiff*参数，这些参数根据*src(x',y')
    – loDiff < src (x,y) < src(x',y') + upDiff*方程进入条件。在这个方程中，*src(x,y)*是测试的*x*，*y*坐标处的像素值，以检查它是否属于与种子点相同的域，而*src(x',y')*是在浮动范围中操作的灰度图像中已知属于该组件的像素之一。如果我们有一个固定范围的洪水填充，方程变为*src(seed.x,seed.y)
    – loDiff < src (x,y) < src(seed.x,seed.y) + upDiff*，其中*seed.x*和*seed.y*是种子点的坐标。此外，请注意，在彩色图像的情况下，每个像素的分量都会与条件进行比较，而*loDiff*和*highDiff*是三维标量。总的来说，如果新像素的亮度或颜色足够接近其邻居之一，该邻居已属于连接组件，或者在浮动范围洪水填充的情况下足够接近种子点的属性，则该像素将被添加到域中。
- en: 'The flood fill''s signature is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 洪水填充的签名如下：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Mat image` parameter is the input/output `Mat` containing the image to
    perform the flood fill, while `Mat mask` is a single channel 8-bit mat 2 rows
    taller and 2 columns wider than `Mat image`, for performance reasons. The `Point
    seedpoint` parameter contains the coordinates of the seed point, while `Rect rect`
    is an output rectangle with the smallest bounding box that contains the segmented
    area. The `Scalar loDiff` and `upDiff` parameters are discussed in the preceding
    condition. The `int flags` parameter contains options for the operating mode of
    the algorithm. The source code containing a *façade* class for the `floodFill`
    method is available in the `floodfill` project in this chapter. The following
    is a screenshot of the application:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat image`参数是要执行洪水填充的图像的输入/输出`Mat`，而`Mat mask`是一个比`Mat image`高2行、宽2列的单通道8位矩阵，出于性能考虑。`Point
    seedpoint`参数包含种子点的坐标，而`Rect rect`是一个输出矩形，包含分割区域的最小边界框。`Scalar loDiff`和`upDiff`参数在先前的条件中已讨论。`int
    flags`参数包含算法操作模式的选项。包含`floodFill`方法*门面*类的源代码可在本章的`floodfill`项目中找到。以下是该应用的截图：'
- en: '![Flood filling](img/3972OS_03_10.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![洪水填充](img/3972OS_03_10.jpg)'
- en: On the left-hand side of the preceding screenshot, there is a `JLabel` like
    the one explained in [Chapter 2](ch02.html "Chapter 2. Handling Matrices, Files,
    Cameras, and GUIs"), *Handling Matrices, Files, Cameras, and GUIs*, used to load
    images, but this one has `MouseListener` that sends the captured clicks to the
    `FloodFillFacade` class. On the right-hand side of the preceding screenshot, the
    mask is shown in case the **Mask** radio button is turned on. The algorithm operation
    mode is chosen through the `Range radio` buttons, which will be relative (checks
    the conditions against neighbors), fixed (the condition is probed against the
    seed), or null (when `loDiff` and `hiDiff` are both zero). A radio button for
    connectivity is also available for 4 or 8 neighbors, while the lower and upper
    thresholds refer to the `loDiff` and `hiDiff` parameters, respectively.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图左侧，有一个类似于[第2章](ch02.html "第2章. 处理矩阵、文件、摄像头和GUIs")中解释的`JLabel`，用于加载图像，但这个有一个`MouseListener`，它会将捕获的点击发送到`FloodFillFacade`类。在前面截图的右侧，当**Mask**单选按钮被选中时，会显示掩码。算法操作模式是通过`Range
    radio`按钮选择的，可以是相对的（检查邻居的条件）、固定的（条件与种子点比较）或空的（当`loDiff`和`hiDiff`都为零时）。还有一个用于4或8个邻居的连通性单选按钮，而下限和上限阈值分别对应于`loDiff`和`hiDiff`参数。
- en: 'While most fields from `FloodFillFacade` are just `getters` and `setters`,
    the flag configuration is something that you need to pay attention to. Note that
    a *façade* is just an object that creates a simplified interface to a larger part
    of code, making it easier to use. Here are some important pieces of `FloodFillFacade`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`FloodFillFacade`的大多数字段只是`getters`和`setters`，但标志配置是你需要注意的事情。请注意，*门面*只是一个创建对更大部分代码的简化接口的对象，使其更容易使用。以下是`FloodFillFacade`的一些重要部分：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, firstly, `newVal` is created as the new color that is to be filled in
    the connected component. Java random classes are used to generate the color and
    in case it's a grayscale image, it is converted to grayscale. Then, we set the
    `lowerDifference` and `higherDifference` scalars, which will be used in accordance
    with the equations described previously. Then, the `flags` variable is defined.
    Note that connectivity is set on lower bits, while `newMaskVal` is shifted to
    the left 8 times. This parameter is the color used to fill the mask in case it's
    being used. Then, in case a fixed range is required for flood fill, its flag is
    set. We are then able to chose from the masked or unmasked version of flood fill.
    Pay attention to `new Mat()`, which is passed when does not use a mask. Observe
    that the `seedPoint` parameter is built from the given coordinates from our `MouseListener`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先，创建`newVal`作为要填充到连通组件中的新颜色。使用Java随机类生成颜色，如果是灰度图像，则将其转换为灰度。然后，我们设置`lowerDifference`和`higherDifference`标量，它们将根据之前描述的方程使用。然后，定义`flags`变量。请注意，连通性设置在低位，而`newMaskVal`向左移动8位。此参数是在使用掩码时用于填充掩码的颜色。然后，如果需要固定范围的洪水填充，则设置其标志。然后，我们可以从掩码或未掩码的洪水填充版本中进行选择。注意`new
    Mat()`，当不使用掩码时传递。观察`seedPoint`参数是由我们的`MouseListener`提供的坐标构建的。
- en: Image pyramids
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像金字塔
- en: Image pyramids are simply a collection of images obtained by downsampling an
    original image, so that each image is one-fourth the area of its predecessor.
    It is mainly used in image segmentation, since it can generate a very meaningful
    representation of the image in low resolution, so that a time consuming algorithm
    can run on it. This makes it easy for us to map this result back to a higher resolution
    image in the pyramid and makes it possible to refine the results there. Besides,
    an approximation to a Laplacian, by means of difference of Gaussians, can be generated.
    Note that a Laplacian image is the one that will show its edges.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图像金字塔简单来说是由对原始图像进行下采样得到的一系列图像集合，使得每个图像的面积是其前一个图像的四分之一。它主要应用于图像分割，因为它可以在低分辨率下生成非常具有意义的图像表示，从而使得耗时算法可以在其上运行。这使得我们能够将此结果映射回金字塔中的更高分辨率图像，并使得在那里细化结果成为可能。此外，通过高斯差分可以生成拉普拉斯近似。请注意，拉普拉斯图像是会显示其边缘的图像。
- en: 'In order to produce the downsample image, which we will call the layer `i+1`
    in the Gaussian pyramid (`Gi+1`), we first convolve `Gi` with a Gaussian kernel,
    just like in Gaussian filtering, followed by removing every even numbered row
    and column. Then, we yield an image with one quarter of the area of the above
    layer. Averaging before downsampling is important because this way, information
    from odd numbered columns and rows gets captured. The function to get a downsampled
    image has the following signature:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成下采样图像，我们将其称为高斯金字塔中的 `i+1` 层（`Gi+1`），我们首先使用高斯核对 `Gi` 进行卷积，就像在高斯滤波中一样，然后移除所有偶数行和列。然后，我们得到一个面积是上一层四分之一的图像。在下采样之前进行平均很重要，因为这样可以从奇数行和列中捕获信息。获取下采样图像的函数具有以下签名：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Mat src` and `Mat dst` parameters are the input and output images. Note
    that the output image will have a width of `(src.width+1)/2` and a height of `(src.height+1)/2`,
    where `/` denotes an integer division. You should be careful when working with
    odd dimensions, since an upsampled image generated from a downsampled one will
    not have the same dimensions. Take for instance, an 11 x 11 image. When you use
    `pyrDown`, it will become a 6 x 6 image. In case you upsample it, it will become
    a 12 x 12 image, so you can''t add or subtract it from the original image. Note
    that when using `pyrDown`, a 5 x 5 Gaussian kernel is used. In case you want,
    the `pyrDown` function is overloaded with the `Size dstsize` and `int borderType`
    properties. The `dstsize` property will allow you to define the output image size,
    but you must satisfy the following conditions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat src` 和 `Mat dst` 参数是输入和输出图像。请注意，输出图像的宽度将是 `(src.width+1)/2`，高度是 `(src.height+1)/2`，其中
    `/` 表示整数除法。当处理奇数维度时，你应该小心，因为从下采样图像生成的上采样图像将不具有相同的维度。以一个 11 x 11 的图像为例。当你使用 `pyrDown`
    时，它将变成一个 6 x 6 的图像。如果你对其进行上采样，它将变成一个 12 x 12 的图像，因此你不能将其添加或从原始图像中减去。请注意，当使用 `pyrDown`
    时，使用了一个 5 x 5 的高斯核。如果你想，`pyrDown` 函数通过 `Size dstsize` 和 `int borderType` 属性进行了重载。`dstsize`
    属性将允许你定义输出图像大小，但你必须满足以下条件：'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This means that you won't have much freedom when deciding the output image size.
    Also, `borderType` follows the same considerations as those are given in the *Smoothing*
    section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在决定输出图像大小时，你不会有太多的自由度。此外，`borderType` 与 *平滑* 部分中给出的考虑相同。
- en: 'On the other hand, the `pyrUp` function will upsample an image and then blur
    it. First, it will inject zero rows and columns on even locations and then, it
    convolve with the same kernel from the pyramid down operation. Note that `pyrDown`
    is a transformation that loses information, so `pyrUp` won''t be able to recover
    the original image. Its usage is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`pyrUp` 函数将上采样一个图像然后对其进行模糊处理。首先，它将在偶数位置注入零行和列，然后与从金字塔下操作中相同的核进行卷积。请注意，`pyrDown`
    是一种会丢失信息的转换，因此 `pyrUp` 无法恢复原始图像。其用法如下：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also, its parameters are just like the `pyrDown` parameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它的参数与 `pyrDown` 参数类似。
- en: 'In case you want to build the Laplacian, just note that it can be achieved
    by using the following equation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想构建拉普拉斯算子，请注意这可以通过以下方程实现：
- en: '![Image pyramids](img/3972OS_03_18.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图像金字塔](img/3972OS_03_18.jpg)'
- en: '`UP` is the upsampling operation and `⊗G5` is the convolution with a 5 x 5
    Gaussian kernel. Since `pyrUp` has already been implemented as an upsampling followed
    by a Gaussian blurring, all we need to do is downsample the original image, upsample
    it, and then subtract it from the original image. This can be accomplished by
    using the following code, as it appears in this chapter''s `imagePyramid` sample:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`UP` 是上采样操作，`⊗G5` 是与 5 x 5 高斯核的卷积。由于 `pyrUp` 已经实现为上采样后跟高斯模糊，我们所需做的只是对原始图像进行下采样，然后上采样，最后从原始图像中减去它。这可以通过以下代码实现，如本章的
    `imagePyramid` 示例所示：'
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we assume that `image` is the image we are working on.
    Be careful when upsampling and then subtracting an image, since if the original
    image dimension is odd, they will have different dimensions. The `Core.subtract`
    function simply subtracts one image from another, as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们假设 `image` 是我们正在处理的图像。在上采样并从图像中减去时，请小心，因为如果原始图像的维度是奇数，它们的维度将不同。`Core.subtract`
    函数简单地从一个图像中减去另一个图像，如下面的截图所示：
- en: '![Image pyramids](img/3972OS_03_11.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图像金字塔](img/3972OS_03_11.jpg)'
- en: In order to see some code working with pyramids, consider checking out this
    chapter's `imagePyramid` project. The preceding screenshot shows the application
    running the Laplacian filter. Also, play with the buttons to get a feeling of
    how pyramids work.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到一些使用金字塔的代码示例，请考虑查看本章的 `imagePyramid` 项目。前面的截图显示了正在运行拉普拉斯滤波器的应用程序。还可以通过按钮来感受金字塔的工作方式。
- en: Thresholding
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阈值处理
- en: One of the simplest methods of segmenting a grayscale image is using the threshold
    technique. It will basically set pixels below a given value as belonging to the
    interested object and the other pixels as not being part of it. Although it might
    suffer from illumination issues as well as problems that arise from variation
    inside the object, this can be enough when segmenting text in a page scan for
    OCR or to find a checkboard when calibrating the camera. Besides, some more interesting
    approaches, such as the adaptive threshold, can also yield good results in images
    that suffer from non-homogeneous lightning.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将灰度图像分割的最简单方法之一是使用阈值技术。它基本上会将低于给定值的像素视为感兴趣的对象的一部分，而将其他像素视为不属于它的一部分。尽管它可能受到光照问题以及物体内部变化引起的问题的影响，但在对页面扫描中的文本进行OCR或校准相机时寻找棋盘图案时，这可能是足够的。此外，一些更有趣的方法，如自适应阈值，也可以在受非均匀光照影响的图像中产生良好的结果。
- en: 'Basic thresholding is accomplished by means of Imgproc''s `threshold` function,
    whose signature is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基本阈值化是通过 Imgproc 的 `threshold` 函数实现的，其签名如下：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Mats src` and `dst` parameters are the input and output matrices, while
    `thresh` is the level used to threshold the image. double maxval is only used
    in the `Binary` and `Binary_Inv` modes and this will be explained in the following
    table. The `type` are Imgproc''s constants used to describe the thresholding type,
    as in the following table, when tested in the next condition, the source pixel
    value is greater than the given threshold:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mats src` 和 `dst` 参数是输入和输出矩阵，而 `thresh` 是用于阈值化图像的级别。`maxval` 只在 `Binary` 和
    `Binary_Inv` 模式下使用，这将在以下表格中解释。`type` 是用于描述阈值化类型的 Imgproc 常量，如下表所示，当在下一个条件下测试时，源像素值大于给定的阈值：'
- en: '| Thresholding type | Output when true | Output when false |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 阈值类型 | 当为真时的输出 | 当为假时的输出 |'
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `CV_THRESH_BINARY` | `maxval` | `0` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `CV_THRESH_BINARY` | `maxval` | `0` |'
- en: '| `CV_THRESH_BINARY_INV` | `0` | `maxval` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `CV_THRESH_BINARY_INV` | `0` | `maxval` |'
- en: '| `CV_THRESH_BINARY` | `threshold` | `source value` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `CV_THRESH_BINARY` | `threshold` | `source value` |'
- en: '| `CV_TOZERO` | `source value` | `0` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `CV_TOZERO` | `source value` | `0` |'
- en: '| `CV_TOZERO_INV` | `0` | `source value` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `CV_TOZERO_INV` | `0` | `source value` |'
- en: 'The following diagram will help you to easily understand the preceding table:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将帮助您轻松理解前面的表格：
- en: '![Thresholding](img/3972OS_03_12.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![阈值处理](img/3972OS_03_12.jpg)'
- en: 'When thresholding, it is important to experiment with several values using,
    for instance, a slider bar. The sample project `threshold` from this chapter makes
    it really easy to change the function''s arguments and test the results. A screenshot
    of the project is shown as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行阈值处理时，通过例如滑动条等工具尝试几个不同的值是很重要的。本章中的示例项目 `threshold` 使得改变函数的参数和测试结果变得非常简单。以下展示了项目的截图：
- en: '![Thresholding](img/3972OS_03_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![阈值处理](img/3972OS_03_13.jpg)'
- en: Note that although the apple might pose a simple problem for segmentation, when
    applying the binary thresholding method, the apple is almost completely identified,
    except for the lighting spot above the middle line, which clearly has pixels above
    the 205 level, since they are almost pure white, which would be the 255 level.
    Besides, the shadow area under the apple is also identified as belonging to it.
    Aside from these minor problems, it is simple to use and will generally be part
    of one of the steps in any computer vision application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管苹果在分割时可能是一个简单的问题，但在应用二值阈值方法时，苹果几乎完全被识别，除了中间线上方的光照点，这些点的像素明显高于205级，因为它们几乎是纯白色，这将是255级。此外，苹果下方的阴影区域也被识别为属于它的一部分。除了这些小问题外，它使用简单，通常将是任何计算机视觉应用步骤中的一部分。
- en: 'Another interesting approach to this type of segmentation is related to the
    use of a dynamic threshold value. Instead of using a given value, the threshold
    is calculated as a mean of a square block around each pixel minus a given constant.
    This method is implemented in OpenCV through the `adaptiveThreshold` function,
    which has the following signature:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型分割的另一种有趣的方法与使用动态阈值值有关。而不是使用给定的值，阈值被计算为围绕每个像素的平方块的均值减去一个给定的常数。这种方法通过OpenCV中的`adaptiveThreshold`函数实现，该函数具有以下签名：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Mat src` and `dst` parameters are the input and output matrices, respectively.
    `Maxvalue` is used the same way as the ordinary threshold function, which is described
    in the preceding section. The adaptive method can either be `ADAPTIVE_THRESH_MEAN_C`
    or `ADAPTIVE_THRESH_GAUSSIAN_C`. The first one will calculate the mean as the
    pixel value sum divided by the number of pixels in the block, while the latter
    will use Gaussian weighting for the average. `BlockSize` is the square `blockSize`
    by the `blockSize` region used for the mean whose value must be odd and greater
    than 1\. The `C` constant is the value subtracted from the mean to compose the
    dynamic threshold. Note the result obtained for the same image with the adaptive
    threshold using `blocksize` of `13` and a constant `C` of `6`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat src`和`dst`参数分别是输入和输出矩阵。`Maxvalue`的使用方式与普通阈值函数相同，这在前面章节中有描述。自适应方法可以是`ADAPTIVE_THRESH_MEAN_C`或`ADAPTIVE_THRESH_GAUSSIAN_C`。前者将计算平均值作为块中像素值总和除以像素数，而后者将使用高斯加权平均。`BlockSize`是用于平均值的`blockSize`乘以`blockSize`的正方形区域，其值必须是奇数且大于1。`C`常数是从平均值中减去的值，用于组成动态阈值。注意使用`blocksize`为`13`和常数`C`为`6`时，对同一图像使用自适应阈值得到的结果：'
- en: '![Thresholding](img/3972OS_03_15.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![阈值](img/3972OS_03_15.jpg)'
- en: Note that the shadow area is now much better, although the irregular texture
    from the apple can cause other problems. The sample code uses a binary and `ADAPTIVE_THRESH_MEAN_C`
    adaptive thresholding, but changing it for Gaussian is just a matter of changing
    the type parameter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，阴影区域现在要好得多，尽管苹果的不规则纹理可能会引起其他问题。示例代码使用了二值和`ADAPTIVE_THRESH_MEAN_C`自适应阈值，但将其更改为高斯阈值只需更改类型参数。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explained the theory and practice of basic image processing operations
    that will be required in any computer vision project. We started with filters
    that work with simple average or using a Gaussian weighting as well as a median
    and discussed the interesting bilateral filter, which maintains edges. Then, we
    explored the important morphological operators, such as erosion, dilation, opening,
    and closing, which appear in the context of isolating elements, removing noise,
    and joining distanced elements in an image. We followed this with the well-known
    paint bucket operation through flood filling. Then, we explored time and processing
    saving image pyramids, which make segmentation faster in higher levels by decreasing
    the image area to one quarter in each layer. We finally explained the important
    image segmentation technique called thresholding and tested the adaptive thresholding
    as well.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了在任何计算机视觉项目中都需要的基本图像处理操作的原理和实践。我们首先讨论了使用简单平均或高斯加权的滤波器，以及中值滤波器，并讨论了有趣的双边滤波器，它保持了边缘。然后，我们探讨了重要的形态学算子，如腐蚀、膨胀、开运算和闭运算，这些算子在隔离元素、去除噪声和连接图像中距离较远的元素时出现。随后，我们通过洪水填充讨论了众所周知的油漆桶操作。然后，我们探讨了时间和处理节省的图像金字塔，通过在每个层中将图像面积减少到四分之一来加快分割速度。最后，我们解释了重要的图像分割技术——阈值，并测试了自适应阈值。
- en: In the next chapter, we will focus on important image transforms, which will
    allow us to find edges, lines, and circles in images. Then, you will learn stretch,
    shrink, warp, and rotate operations, which will be followed by the Fourier transform,
    which is a nice tool to change image from the spatial domain to the frequency
    domain. Finally, we will check out integral images, which boost some face-tracking
    algorithms.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注重要的图像变换，这将使我们能够在图像中找到边缘、线条和圆。然后，你将学习拉伸、收缩、扭曲和旋转操作，这将由傅里叶变换跟随，傅里叶变换是一种将图像从空间域转换为频率域的好工具。最后，我们将检查积分图像，它可以提高某些人脸跟踪算法。
