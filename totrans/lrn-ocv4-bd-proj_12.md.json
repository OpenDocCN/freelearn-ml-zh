["```py\n...\n#include <opencv2/core.hpp>\n#include <opencv2/dnn.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/highgui.hpp>\nusing namespace cv;\nusing namespace dnn;\n...\n```", "```py\n...\n int main(int argc, char** argv)\n {\n     // Load names of classes\n     string classesFile = \"coco.names\";\n     ifstream ifs(classesFile.c_str());\n     string line;\n     while (getline(ifs, line)) classes.push_back(line);\n     ...\n\n```", "```py\n...\n // Give the configuration and weight files for the model\n String modelConfiguration = \"yolov3.cfg\";\n String modelWeights = \"yolov3.weights\";\n// Load the network\nNet net = readNetFromDarknet(modelConfiguration, modelWeights);\n...\n```", "```py\n...\ninput= imread(argv[1]);\n// Stop the program if reached end of video\nif (input.empty()) {\n    cout << \"No input image\" << endl;\n    return 0;\n}\n// Create a 4D blob from a frame.\nblobFromImage(input, blob, 1/255.0, Size(inpWidth, inpHeight), Scalar(0,0,0), true, false);\n...\n\n```", "```py\n...\n//Sets the input to the network\nnet.setInput(blob);\n\n// Runs the forward pass to get output of the output layers\nvector<Mat> outs;\nnet.forward(outs, getOutputsNames(net));\n// Remove the bounding boxes with low confidence\npostprocess(input, outs);\n...\n```", "```py\n#include <opencv2/dnn.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/highgui.hpp>\n```", "```py\nusing namespace cv;\nusing namespace std;\nusing namespace cv::dnn;\n```", "```py\nconst size_t inWidth = 300;\nconst size_t inHeight = 300;\nconst double inScaleFactor = 1.0;\nconst Scalar meanVal(104.0, 177.0, 123.0);\n```", "```py\nconst char* params\n= \"{ help | false | print usage }\"\n\"{ proto | | model configuration (deploy.prototxt) }\"\n\"{ model | | model weights (res10_300x300_ssd_iter_140000.caffemodel) }\"\n\"{ camera_device | 0 | camera device number }\"\n\"{ video | | video or image for detection }\"\n\"{ opencl | false | enable OpenCL }\"\n\"{ min_confidence | 0.5 | min confidence }\";\n```", "```py\nint main(int argc, char** argv)\n{\n CommandLineParser parser(argc, argv, params);\n\n if (parser.get<bool>(\"help\"))\n {\n cout << about << endl;\n parser.printMessage();\n return 0;\n }\n```", "```py\n String modelConfiguration = parser.get<string>(\"proto\");\n String modelBinary = parser.get<string>(\"model\");\n\n //! [Initialize network]\n dnn::Net net = readNetFromCaffe(modelConfiguration, modelBinary);\n //! [Initialize network]\n```", "```py\nif (net.empty())\n {\n cerr << \"Can't load network by using the following files\" << endl;\n exit(-1);\n }\n```", "```py\n VideoCapture cap;\n if (parser.get<String>(\"video\").empty())\n {\n int cameraDevice = parser.get<int>(\"camera_device\");\n cap = VideoCapture(cameraDevice);\n if(!cap.isOpened())\n {\n cout << \"Couldn't find camera: \" << cameraDevice << endl;\n return -1;\n }\n }\n else\n {\n cap.open(parser.get<String>(\"video\"));\n if(!cap.isOpened())\n {\n cout << \"Couldn't open image or video: \" << parser.get<String>(\"video\") << endl;\n return -1;\n }\n }\n```", "```py\nfor(;;)\n {\n Mat frame;\n cap >> frame; // get a new frame from camera/video or read image\n\n if (frame.empty())\n {\n waitKey();\n break;\n }\n```", "```py\nMat inputBlob = blobFromImage(frame, inScaleFactor, Size(inWidth, inHeight), meanVal, false, false); \n```", "```py\n net.setInput(inputBlob, \"data\"); //set the network input\n Mat detection = net.forward(\"detection_out\"); //compute output\n Mat detectionMat(detection.size[2], detection.size[3], CV_32F, detection.ptr<float>());\n\n```", "```py\nfloat confidenceThreshold = parser.get<float>(\"min_confidence\");\n for(int i = 0; i < detectionMat.rows; i++)\n {\n float confidence = detectionMat.at<float>(i, 2);\n\n if(confidence > confidenceThreshold)\n {\n```", "```py\n int xLeftBottom = static_cast<int>(detectionMat.at<float>(i, 3) * frame.cols);\n int yLeftBottom = static_cast<int>(detectionMat.at<float>(i, 4) * frame.rows);\n int xRightTop = static_cast<int>(detectionMat.at<float>(i, 5) * frame.cols);\n int yRightTop = static_cast<int>(detectionMat.at<float>(i, 6) * frame.rows);\n\n Rect object((int)xLeftBottom, (int)yLeftBottom, (int)(xRightTop - xLeftBottom), (int)(yRightTop - yLeftBottom));\n\n rectangle(frame, object, Scalar(0, 255, 0));\n }\n }\n imshow(\"detections\", frame);\n if (waitKey(1) >= 0) break;\n}\n```"]