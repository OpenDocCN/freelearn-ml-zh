- en: Macros and Metaprogramming Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will discuss two of the most powerful facilities in the Julia
    programming language: macros and metaprogramming.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, metaprogramming is a technique for writing code that generates
    code—that''s why it has the prefix *meta*. It may sound esoteric, but it is a
    fairly common practice in many programming languages today. For example, C compiler
    uses a preprocessor to read source code and produce new source code, and then
    the new source code is compiled into a binary executable. For example, you can
    define a `MAX` macro, as in `#define MAX(a,b) ((a) > (b) ? (a) : (b))`, and this
    means that every time we use `MAX(a,b)`, it is replaced with `((a) > (b) ? (a)
    : (b))`. Note that `MAX(a,b)` is much easier to read than the longer form.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The history of metaprogramming is quite long. As far back as the 1970s, it was
    already popular among the LISP programming language community. Interestingly,
    the LISP language is designed in such a way that the source code is structured
    like data—for example, a function call in LISP looks like `(sumprod x y z)`, where
    the first element is the name of the function and the rest are arguments. Since
    it is really just a list of four symbols—`sumprod`, `x`, `y`, and `z`—we can take
    this code and manipulate it in any way—for example, we can expand it so it calculates
    both the sum and product of the numbers, so the generated code becomes `(list
    (+ x y z) (* x y z))`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wonder whether we can just write a function for that. The answer is,
    yes: in both of the examples that we just looked at, there is no need to use a
    metaprogramming technique. The examples were there only to illustrate how metaprogramming
    works. In general, we can say that metaprogramming is not needed 99% of the time;
    however, there is still that remaining 1% of cases where metaprogramming would
    be very useful. The first section will explore use cases where we would want to
    use metaprogramming.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn several metaprogramming facilities in Julia. The
    following topics will be covered in particular:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for metaprogramming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing macros
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generated functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for metaprogramming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of the chapter, we boldly claimed that metaprogramming is not
    needed 99% of the time. That is indeed not a made-up number. At the JuliaCon 2019
    conference, Professor Steven Johnson from MIT delivered a keynote speech regarding
    metaprogramming. He did some research about the Julia language's own source code.
    From his study, Julia version 1.1.0 contains 37,000 methods, 138 macros (0.4%),
    and 14 generated functions (0.04%). So metaprogramming code comprises less than
    1% of Julia's own implementation. While this is just one example of metaprogramming's
    role in one language, it is representative enough that even the smartest software
    engineers would not use metaprogramming most of the time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'So the next question is: When do you need to use metaprogramming techniques?
    Generally speaking, there are several reasons for using such techniques:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: They may allow a solution to be expressed more concisely and in a way that is
    easier to understand. Writing code without metaprogramming would otherwise look
    ugly and be difficult to comprehend.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may reduce the development time because the source code can be generated
    rather than written out; boilerplate code, especially, can be eliminated.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may improve performance because the code is spelled out rather than executed
    via other higher-level programming constructs, such as looping.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now look at some examples of how metaprogramming is used in the real
    world.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Measuring performance with the @time macro
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia comes with a useful macro called `@time`, which measures the time required
    to execute code. For example, to measure how long it takes to calculate the sum
    of 10 million random numbers, we can do the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79626f6a-ec00-4d63-8032-f414bbcc0024.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'The macro works by inserting code around the code that is being measured. The
    resulting code may look something like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The new code uses the `now()` function to take the current time. Then, it executes
    the user-provided code and captures the result. It takes the current time again,
    calculates the elapsed time, prints the timing information to the console, and
    then it returns the result.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Can this be done without metaprogramming? Perhaps we can give that a try. Let''s
    define a function called `timeit` as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To use this timing facility, we need to wrap the expression in a function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8f1db6b-774b-4099-8398-baaa18c3f2a8.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: This function works fairly well, but the problem is that we have to wrap the
    code in a separate function before we can measure its performance, which is a
    hugely inconvenient thing to do. Because of this, we can conclude that having
    a `@time` macro is more appropriate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Unrolling loops
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another use case of macros is to unroll loops into repeating code fragments.
    Loop unrolling is a performance optimization technique. The premise behind it
    is that there is always some overhead that is required to execute code in a loop.
    The reason is that, every time an iteration is finished, the loop must check for
    a condition and decide whether it should exit or continue with the next iteration.
    Now, if we know exactly how many times the loop needs to run the code, then we
    can *unroll* it by writing out the code in a repeated fashion.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的另一个用途是将循环展开成重复的代码片段。循环展开是一种性能优化技术。其背后的前提是执行循环代码总是需要一些开销。原因是，每次迭代完成后，循环必须检查条件并决定是否应该退出或继续下一次迭代。现在，如果我们确切知道循环需要运行多少次代码，那么我们可以通过以重复的方式编写代码来*展开*它。
- en: 'Consider a simple loop as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的循环如下：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can unroll the loop into three lines of code that do the exact same job:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将循环展开成三行代码，它们执行完全相同的工作：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But it would be quite a boring and mundane task to have to unroll loops manually.
    Furthermore, the amount of work grows linearly with the number of iterations required
    in the loop. With the help of `Unroll.jl`, we can define a function using the
    `@unroll` macro, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但手动展开循环将是一项相当无聊和枯燥的任务。此外，工作量会随着循环中所需的迭代次数线性增长。借助`Unroll.jl`，我们可以使用`@unroll`宏定义一个函数，如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code looks as clean as it should be, and the `@unroll` macro is inserted
    in front of the function as well as the `for` loop. First, we should check that
    the code works properly:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像应该的那样干净，`@unroll`宏被插入到函数以及`for`循环之前。首先，我们应该检查代码是否正常工作：
- en: '![](img/6616ec0d-2ed2-4231-8acc-b7b32bd53a40.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6616ec0d-2ed2-4231-8acc-b7b32bd53a40.png)'
- en: 'Now, we should question whether the `@unroll` macro actually did anything.
    A good way to check whether the loop was unrolled is to use the `@code_lowered`
    macro:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该质疑`@unroll`宏是否真的做了什么。检查循环是否展开的一个好方法是使用`@code_lowered`宏：
- en: '![](img/e54b3954-bdea-413c-9fe4-16a48708327d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e54b3954-bdea-413c-9fe4-16a48708327d.png)'
- en: The lowered code clearly contains three `println` statements rather than a single
    `for` loop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 降低后的代码明显包含三个`println`语句，而不是一个单独的`for`循环。
- en: What is lowered code? The Julia compiler must go through a series of processes
    before source code is compiled to binaries. The very first step is to parse the
    code into an **abstract syntax tree** (**AST**) format, which we will learn about
    in the next session. After that, it goes through a *lowering* process to expand
    the macros and convert the code into concrete execution steps.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是降低后的代码？Julia 编译器在将源代码编译成二进制文件之前必须经过一系列的过程。第一步是将代码解析成**抽象语法树**（**AST**）格式，我们将在下一节中学习。之后，它通过*降低*过程来展开宏并将代码转换为具体的执行步骤。
- en: Now that we have seen some examples and know the power of metaprogramming, we
    shall move forward and learn how to create these macros ourselves.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些示例并了解了元编程的力量，我们将继续学习如何自己创建这些宏。
- en: Working with expressions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表达式
- en: Julia represents the source code of any runnable program as a tree structure.
    This is called an **abstract syntax tree** (**AST**). It is referred to as *abstract*
    as the tree only captures the structure of the code rather than the real syntax.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 将任何可运行的程序的源代码表示为树结构。这被称为**抽象语法树**（**AST**）。它被称为*抽象的*，因为树只捕获代码的结构而不是真正的语法。
- en: 'For example, the expression `x + y` can be represented with a tree where the
    parent node identifies itself as a function call and the child nodes include the
    operator function `+` and the `x` and `y` arguments. The following is an implementation
    of this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`x + y`可以用一个树来表示，其中父节点标识自己为函数调用，子节点包括运算符函数`+`和`x`、`y`参数。以下是其实现：
- en: '![](img/63989de7-d8b6-4b30-9fde-8c4e264f696c.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63989de7-d8b6-4b30-9fde-8c4e264f696c.png)'
- en: 'The slightly more complex expression `x + 2y + 1` would look like the following
    diagram. While it was written with two addition operators, the expression is parsed
    into a single function call to the `+` function, for which it takes three arguments—`x`,
    `2y`, and `1`. Because `2y` is itself an expression, it can be seen as a subtree
    of the main abstract syntax tree:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 略微复杂一些的表达式`x + 2y + 1`看起来如下所示。虽然它使用了两个加法运算符，但表达式被解析为对`+`函数的单个函数调用，它接受三个参数——`x`、`2y`和`1`。因为`2y`本身也是一个表达式，它可以看作是主抽象语法树的子树：
- en: '![](img/a8f1f88d-4ee8-498b-a969-4c8e4bf5330e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8f1f88d-4ee8-498b-a969-4c8e4bf5330e.png)'
- en: The Julia compiler must first parse source code into an abstract syntax tree,
    and then it can perform additional transformations and analysis, such as expanding
    macros, type checking, type inference, and eventually translating the code into
    machine code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Julia编译器必须首先将源代码解析成抽象语法树，然后才能执行额外的转换和分析，例如宏展开、类型检查、类型推断，最终将代码转换成机器码。
- en: Experimenting with the parser
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试解析器
- en: 'Because the abstract syntax tree is just a data structure, we can examine it
    directly within the Julia REPL environment. Let''s just start with a simple expression: `x
    + y`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为抽象语法树只是一个数据结构，我们可以在Julia的REPL环境中直接检查它。让我们从一个简单的表达式开始：`x + y`：
- en: '![](img/8186f498-fee4-46b5-93c4-b870de13cd62.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8186f498-fee4-46b5-93c4-b870de13cd62.png)'
- en: In Julia, every expression is represented as an `Expr` object. We can create
    an `Expr` object by just parsing a string with the `Meta.parse` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，每个表达式都表示为一个`Expr`对象。我们可以通过使用`Meta.parse`函数解析一个字符串来创建一个`Expr`对象。
- en: 'Here, the expression object is displayed with a syntax that resembles the original
    source code so that it is easier to read. We can confirm that the object has the
    type of `Expr` as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，表达式对象以类似于原始源代码的语法显示，以便更容易阅读。我们可以确认该对象具有`Expr`类型如下：
- en: '![](img/2f61ebe7-8d7c-4ab5-8a0d-f27bb6e5e280.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f61ebe7-8d7c-4ab5-8a0d-f27bb6e5e280.png)'
- en: 'In order to view the abstract syntax tree, we can use the `dump` function to
    print the structure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看抽象语法树，我们可以使用`dump`函数来打印结构：
- en: '![](img/cbfb4302-ee10-46ec-baaf-64cbdd3b0141.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbfb4302-ee10-46ec-baaf-64cbdd3b0141.png)'
- en: In Julia, every expression is represented by a head node and an array of arguments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，每个表达式都由一个头节点和参数数组表示。
- en: In this case, the head node contains just a `call` symbol. The `args` array
    contains the `+` operator and two variables, `x` and `y`. Note that everything
    here is a symbol—that's OK because we are examining the source code itself, which
    is understandably just a tree of symbols.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，头节点只包含一个`call`符号。`args`数组包含`+`运算符和两个变量，`x`和`y`。请注意，这里的一切都是一个符号——这是可以的，因为我们正在检查源代码本身，它本质上只是一个符号的树。
- en: Since we have had so much fun here, let's try a few other expressions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里玩得很开心，让我们尝试几个其他的表达式。
- en: Single-variable expressions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单变量表达式
- en: 'One of the simplest expressions is just a reference to a variable. You can
    try to parse a numeric or string literal and see what it returns:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个最简单的表达式只是一个变量的引用。你可以尝试解析一个数字或字符串字面量，看看它返回什么：
- en: '![](img/1943fdfd-f8d9-4f34-9e8c-af4e356514f2.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1943fdfd-f8d9-4f34-9e8c-af4e356514f2.png)'
- en: Function calls with keyword arguments
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带关键字参数的函数调用
- en: 'Let''s try something a little more complex. We will examine a function call
    that takes a single positional argument and two keyword arguments. Here, we use
    triple quotes around the code so that we can handle the double quotes inside it
    properly:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个稍微复杂一些的例子。我们将检查一个函数调用，它接受一个位置参数和两个关键字参数。在这里，我们使用三引号包围代码，以便正确处理其中的双引号：
- en: '![](img/0e81cd68-ad62-44e1-a766-8823d216d42f.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e81cd68-ad62-44e1-a766-8823d216d42f.png)'
- en: Note that a function call has the `call` symbol as the head node of the expression.
    Also, the keyword arguments are represented as subexpressions, each with a head
    node of `kw` and a two-element array for the name and value of the argument.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数调用以`call`符号作为表达式的头节点。此外，关键字参数表示为子表达式，每个子表达式都有一个头节点`kw`和一个包含参数名称和值的两个元素数组。
- en: Nested functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: 'We may wonder how Julia parses code when functions are nested. We can pick
    a simple example here that takes the sine of `x+1` and then takes the cosine of
    the result. The abstract syntax tree is shown as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会好奇当函数嵌套时，Julia是如何解析代码的。这里我们可以选择一个简单的例子，它计算`x+1`的正弦值，然后计算结果的余弦值。抽象语法树如下所示：
- en: '![](img/3bf61837-89ac-4f12-9b51-05f080dd5def.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bf61837-89ac-4f12-9b51-05f080dd5def.png)'
- en: Here, we can clearly see the tree structure. The outermost function, `cos`,
    contains a single argument, which is an expression node with a call to the `sin`
    function. This expression in turn contains a single argument, which is another
    expression node with a call to the `+` operator function with two arguments—the
    `x` variable and a value of `1`. Now, let's continue with our work on expressions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以清楚地看到树结构。最外层的函数`cos`包含一个参数，它是一个调用`sin`函数的表达式节点。这个表达式反过来包含一个参数，它是一个调用带有两个参数的`+`运算符函数的表达式节点——`x`变量和值为`1`。现在，让我们继续我们的表达式工作。
- en: Constructing expression objects manually
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动构建表达式对象
- en: As an expression is just a data structure, we can easily construct them programmatically.
    Understanding how to do this is essential for metaprogramming, which involves
    creating new code structures on the fly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表达式只是一个数据结构，我们可以很容易地通过编程方式构建它们。理解如何做到这一点对于元编程至关重要，元编程涉及在运行时创建新的代码结构。
- en: 'The `Expr` constructor has the following signature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expr`构造函数有以下签名：'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The head node always carries a symbol. The arguments just contain whatever
    the head node expects—for example, the simple expression `x + y` can be created
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 头部节点总是携带一个符号。参数只包含头部节点期望的内容——例如，简单的表达式`x + y`可以创建如下：
- en: '![](img/5f5bb0a3-13ab-4c7c-ba4e-233f519f08f2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f5bb0a3-13ab-4c7c-ba4e-233f519f08f2.png)'
- en: 'Of course, we can always create a nested expression if we want to:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们想的话，我们总是可以创建一个嵌套表达式：
- en: '![](img/0938942b-66a5-4fb1-a623-f01b023c2e55.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0938942b-66a5-4fb1-a623-f01b023c2e55.png)'
- en: 'At this point, you may wonder whether there is an easier way to create expressions
    without having to construct `Expr` objects manually.  For sure, it can be done
    as shown below:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你可能想知道是否有更简单的方法来创建表达式，而无需手动构建`Expr`对象。当然，可以像下面这样做到：
- en: '![](img/c2579b8b-162f-4294-8eab-9b4540a7ab02.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2579b8b-162f-4294-8eab-9b4540a7ab02.png)'
- en: 'Basically, we can wrap any expression with `:(` on the left and `)` on the
    right. The code that sits inside will not be evaluated, but will instead be parsed
    into an expression object; however, this way of quoting only works with a single
    expression—if you try to do this with multiple expressions, an error will be displayed,
    as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们可以用左边的`:(`和右边的`)`将任何表达式包裹起来。代码块内的代码将不会被评估，而是被解析为一个表达式对象；然而，这种引用方式只适用于单个表达式——如果你尝试用多个表达式这样做，将会显示错误，如下面的代码所示：
- en: '![](img/f7d55f45-9cd4-4003-bc18-c9f59b614cf5.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7d55f45-9cd4-4003-bc18-c9f59b614cf5.png)'
- en: 'It does not work because multiple expressions should be wrapped with `begin`
    and `end` keywords. So it would be fine if we entered the following code block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不行的，因为多个表达式应该用`begin`和`end`关键字包裹。所以如果我们输入以下代码块会更好：
- en: '![](img/0a4102ef-4edd-4e15-b44b-c2fd311d2446.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a4102ef-4edd-4e15-b44b-c2fd311d2446.png)'
- en: The result is a little interesting. As you can see, the code is now wrapped
    within a `quote/end` block rather than a `begin/end` block. It actually makes
    sense because a quoted expression is being displayed rather than the original
    source code. Remember, this is the abstract syntax tree rather than the original
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 结果有点有趣。正如你所见，代码现在被包裹在一个`quote/end`块中，而不是`begin/end`块中。这实际上是有道理的，因为显示的是引用的表达式而不是原始源代码。记住，这是抽象语法树而不是原始代码。
- en: 'It also turns out that `quote/end` can be used directly to create expressions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明`quote/end`可以直接用来创建表达式：
- en: '![](img/b85ff5b5-02db-46bc-a44a-985c8dd178a5.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b85ff5b5-02db-46bc-a44a-985c8dd178a5.png)'
- en: We have now learned how to parse source code into an expression object. Next,
    we will look into more complex expressions so that we are more familiar with the
    basic code structure of Julia programs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何将源代码解析为表达式对象。接下来，我们将探讨更复杂的表达式，以便我们更熟悉Julia程序的基本代码结构。
- en: Playing with more complex expressions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转更复杂的表达式
- en: As we said before, any valid Julia program can be represented as an abstract
    syntax tree. Now that we have the building blocks to create expression objects,
    let's examine a few more constructs and see what expression objects look like
    for more complex programs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，任何有效的Julia程序都可以表示为一个抽象语法树。现在我们已经有了创建表达式对象的构建块，让我们考察一些更多的结构，看看更复杂程序的表达式对象是什么样的。
- en: Assignment
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值
- en: 'We will see how it works for assignments first. Consider the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看赋值是如何工作的。考虑以下代码：
- en: '![](img/8c32beb4-b5b1-49e3-a440-ba7fc4608b27.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c32beb4-b5b1-49e3-a440-ba7fc4608b27.png)'
- en: From the preceding code, we can see that the variable assignment has a head
    node of `=` and two arguments—the variable to be assigned (`x`, in this case)
    and another expression object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到变量赋值有一个`=`的头部节点和两个参数——要赋值的变量（在这个例子中是`x`）和另一个表达式对象。
- en: Code blocks
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码块
- en: A code block is enclosed by the `begin` and `end` keywords. Let's examine what
    the abstract syntax tree looks like.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块由`begin`和`end`关键字包围。让我们看看抽象语法树是什么样子的。
- en: '![](img/925b6634-edb5-4819-a66a-af1bdd69944c.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/925b6634-edb5-4819-a66a-af1bdd69944c.png)'
- en: The head node just contains a `block` symbol. When there are multiple lines
    in the block, the abstract syntax tree also includes line number nodes. In this
    example, there is a `LineNumberNode` with line 2 preceding the first call to `println`.
    Likewise, there is another `LineNumberNode` with line 3 preceding the second call
    to `println`. The `LineNumberNode` nodes do not do anything, but they are useful
    for stack traces and debugging.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点只包含一个 `block` 符号。当块中有多行时，抽象语法树也包括行号节点。在这个例子中，有一个 `LineNumberNode` 在 `println`
    的第一次调用之前，行号为 2。同样，还有一个 `LineNumberNode` 在 `println` 的第二次调用之前，行号为 3。`LineNumberNode`
    节点不做任何事情，但它们对于堆栈跟踪和调试很有用。
- en: Conditional
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件
- en: 'Next up, we''ll explore conditional constructs, such as `if-else-end`. Refer
    to the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索条件结构，如 `if-else-end`。参考以下代码：
- en: '![](img/3d2b3253-89b5-45d3-91bf-2e2346c730fd.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d2b3253-89b5-45d3-91bf-2e2346c730fd.png)'
- en: The head node contains the `if` symbol. There are three arguments—an expression
    for the condition, a block expression when the condition is satisfied, and another
    block expression when the condition is not satisfied.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点包含 `if` 符号。有三个参数——一个表示条件的表达式，一个当条件满足时的块表达式，以及一个当条件不满足时的另一个块表达式。
- en: Loop
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'We will now move on to looping constructs. Consider a simple `for` loop, as
    follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向循环结构。考虑一个简单的 `for` 循环，如下所示：
- en: '![](img/2130fa5b-520d-47a8-b2b9-7b1235351fc7.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2130fa5b-520d-47a8-b2b9-7b1235351fc7.png)'
- en: 'The head node contains a `for` symbol. There are two arguments: the first one
    contains the expression about the loop and the second one contains a block expression.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点包含 `for` 符号。有两个参数：第一个包含关于循环的表达式，第二个包含一个块表达式。
- en: Function definition
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数定义
- en: 'Next, we will see the structure for a function definition. Consider the following
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到函数定义的结构。考虑以下代码：
- en: '![](img/414fcd55-6739-42d1-9f8c-a73f24b18e03.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/414fcd55-6739-42d1-9f8c-a73f24b18e03.png)'
- en: The head node contains a `function` symbol. Then, the first argument contains
    a `call` expression with the arguments. The second argument is just a block expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点包含 `function` 符号。然后，第一个参数包含一个带有参数的 `call` 表达式。第二个参数只是一个块表达式。
- en: The call expression may seem a little odd because we have seen a similar expression
    object when a function is being called. This is normal because we are currently
    working at the syntax level. The syntax for function definition is indeed quite
    similar to the function call itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 调用表达式可能看起来有点奇怪，因为我们之前在函数被调用时见过类似的表达式对象。这是正常的，因为我们目前处于语法层面。函数定义的语法确实与函数调用本身非常相似。
- en: By now, we have seen enough examples. There are obviously many more code constructs
    that we have not explored. You are encouraged to use the same technique to examine
    other code structures. Understanding how the abstract syntax tree is structured
    is essential to writing good metaprogramming code. Next, we will see how we can
    evaluate these expressions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经看到了足够的例子。显然，还有许多我们没有探索的代码结构。我们鼓励您使用相同的技巧来检查其他代码结构。理解抽象语法树的结构对于编写良好的元编程代码至关重要。接下来，我们将看到如何评估这些表达式。
- en: Evaluating expressions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估表达式
- en: We have looked at creating expression objects in great detail. But how are they
    useful? Remember that an expression object is just an abstract syntax tree representation
    of a Julia program. At this point, we can ask the compiler to continue translating
    the expression into executable code and then run the program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细地探讨了创建表达式对象的过程。但它们有什么用呢？记住，表达式对象只是 Julia 程序的抽象语法树表示。在这个阶段，我们可以要求编译器继续将表达式转换为可执行代码，然后运行程序。
- en: 'Expression objects can be evaluated by calling the `eval` function. Essentially,
    the Julia compiler will go through the rest of the compilation process and run
    the program. Now, let''s start a fresh, new REPL and run the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式对象可以通过调用 `eval` 函数来评估。本质上，Julia 编译器将完成剩余的编译过程并运行程序。现在，让我们启动一个新的、全新的 REPL
    并运行以下代码：
- en: '![](img/17f873d7-2181-40ed-8f15-3561552c254c.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17f873d7-2181-40ed-8f15-3561552c254c.png)'
- en: 'Clearly, it''s just a simple assignment. We can see that the `x` variable is
    now defined in the current environment:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这只是一个简单的赋值操作。我们可以看到，`x` 变量现在在当前环境中被定义了：
- en: '![](img/2f939154-52d6-4c29-9ac6-2aa74aa1b8ab.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f939154-52d6-4c29-9ac6-2aa74aa1b8ab.png)'
- en: 'Note that the evaluation of the expression actually happens in the global scope.
    We can prove this by running `eval` from within a function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表达式的评估实际上是在全局范围内进行的。我们可以通过在函数内部运行 `eval` 来证明这一点：
- en: '![](img/9c9b4f79-5bb2-49fb-95b0-ce8203eca8ca.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c9b4f79-5bb2-49fb-95b0-ce8203eca8ca.png)'
- en: This is not an unimportant observation! At first glance, we may have expected
    the `y` variable to be assigned inside the `foo` function; however, the variable
    assignment happened in the global scope instead, so the `y `variable was defined
    in the current environment as a side-effect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一项无关紧要的观察！乍一看，我们可能预计 `y` 变量将在 `foo` 函数内部被分配；然而，变量分配实际上是在全局范围内发生的，因此 `y` 变量作为副作用在当前环境中被定义。
- en: More precisely, the expression is evaluated in the current module. Since we
    are testing in the REPL, the evaluation was done in the current module, called
    `Main`. The expression is designed as such because `eval` is commonly used for
    code generation, which can be useful in defining variables or functions within
    the module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，表达式是在当前模块中评估的。由于我们在 REPL 中进行测试，评估是在名为 `Main` 的当前模块中完成的。表达式被设计成这样，因为 `eval`
    通常用于代码生成，这在定义模块内的变量或函数时可能很有用。
- en: Next, we will learn how to create expression objects more easily.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何更轻松地创建表达式对象。
- en: Interpolating variables in expressions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式中的变量插值
- en: 'It is quite simple to construct expressions from a quote block. But what if
    we want to dynamically create expressions? This can be done using *interpolation*,
    which allows us to insert variable values into the expression object with an easy
    syntax. Interpolation in an expression is very similar to the way that variables
    can be interpolated in a string. The following screenshot shows an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从引号块中构造表达式非常简单。但如果我们想动态创建表达式怎么办？这可以通过 *插值* 实现，它允许我们使用简单的语法将变量值插入到表达式对象中。表达式中的插值与变量可以在字符串中插值的方式非常相似。下面的截图显示了示例：
- en: '![](img/a7ee7ac3-b5bb-4833-bb32-5c414bc69998.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7ee7ac3-b5bb-4833-bb32-5c414bc69998.png)'
- en: 'As expected, the value of `2` is correctly substituted in the expression. Note
    that `splatting` is also supported, as shown below:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`2` 的值在表达式中被正确替换。请注意，`splatting` 也得到了支持，如下所示：
- en: '![](img/75b2ee1c-6976-4c3b-adb1-22cb55363682.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75b2ee1c-6976-4c3b-adb1-22cb55363682.png)'
- en: 'We must make sure that the variable that includes the `splatting` operator
    is interpolated in this case. If we had forgotten to put the parentheses around `v...`,
    then we would have had a very different result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保包含散列操作符的变量在这种情况下被插值。如果我们忘记在 `v...` 周围放置括号，那么我们会得到一个非常不同的结果：
- en: '![](img/9255e775-c7f4-4b94-87a4-984720944cd3.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9255e775-c7f4-4b94-87a4-984720944cd3.png)'
- en: Here, splatting does not actually occur during interpolation into the expression.
    Instead, the splatting operator now becomes part of the expression, so splatting
    will not occur until the expression is evaluated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，散列操作实际上并没有在表达式插值过程中发生。相反，散列操作符现在成为表达式的一部分，因此散列操作将不会发生，直到表达式被评估。
- en: The order of precedence in an expression such as `$v...` is somewhat unclear.
    Is the `v` variable bound to the interpolation operation before or after the splatting
    operation? In a situation like this, it is best to use parentheses around whatever
    we want to interpolate. As we want the interpolation to happen fully, the syntax
    should be `$(v...)`. In situations where splatting needs to happen at runtime,
    we could write `$(v)...` instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在如 `$v...` 这样的表达式中，优先级顺序有些不清楚。`v` 变量是在散列操作之前还是之后绑定到插值操作的？在这种情况下，最好在我们想要插值的内容周围使用括号。因为我们希望插值完全发生，语法应该是
    `$(v...)`。在需要运行时进行散列操作的情况下，我们可以写成 `$(v)...`。
- en: Interpolation is an important concept for writing macros. We will see more of
    its usage later in this chapter. Next, we will see how to handle construct expressions
    with symbol values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是编写宏的重要概念。我们将在本章后面看到更多关于它的用法。接下来，我们将看到如何处理具有符号值的表达式。
- en: Using QuoteNode for symbols
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 QuoteNode 为符号构造表达式
- en: 'Symbols are quite special when they appear in expressions. They may appear
    in the head node of an expression object—for example, the `=` symbol in a variable
    assignment expression. They may also appear in the arguments of an expression
    object, in which case they would represent a variable:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 符号在表达式中出现时非常特殊。它们可能出现在表达式对象的头部节点中——例如，变量赋值表达式中的 `=` 符号。它们也可能出现在表达式对象的参数中，在这种情况下，它们将代表一个变量：
- en: '![](img/1c7ec2aa-3be8-4c3f-ac06-4e424e1c7886.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c7ec2aa-3be8-4c3f-ac06-4e424e1c7886.png)'
- en: 'Since symbols are already used to represent variables, how would we assign
    an actual symbol to a variable? To figure out how this works, we can use the same
    trick that we have learned so far—using the `dump` function to examine the expression
    object for such a statement:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于符号已经用来表示变量，我们如何将一个实际的符号赋给一个变量呢？为了弄清楚这是如何工作的，我们可以使用我们迄今为止学到的一个技巧——使用 `dump`
    函数来检查表达式对象中的此类语句：
- en: '![](img/a6c583b4-4c64-4073-98fa-4fe8ceba0885.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6c583b4-4c64-4073-98fa-4fe8ceba0885.png)'
- en: 'As we can see, an actual symbol must be enclosed in a `QuoteNode` object. Now
    that we know what is needed, we should try to interpolate an actual symbol into
    an expression object. The way to achieve this is to create a `QuoteNode` object
    manually and use the interpolation technique as usual:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，一个实际的符号必须被包含在 `QuoteNode` 对象中。现在我们知道了需要什么，我们应该尝试将一个实际的符号插值到表达式对象中。实现这一目标的方法是手动创建一个
    `QuoteNode` 对象，并像往常一样使用插值技术：
- en: '![](img/275de7a3-11a7-409e-abc3-af1a49d9f12d.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/275de7a3-11a7-409e-abc3-af1a49d9f12d.png)'
- en: 'A common mistake is when you forget to create `QuoteNode`. In this case, the
    expression object will misinterpret the symbol and treat it as a variable reference.
    Obviously, the result is very different, and it will not work properly:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是忘记创建 `QuoteNode`。在这种情况下，表达式对象将错误地解释符号，并将其视为变量引用。显然，结果非常不同，并且它将无法正常工作：
- en: '![](img/0512ee43-2e07-4147-8a89-43eaec212d3f.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0512ee43-2e07-4147-8a89-43eaec212d3f.png)'
- en: Not using `QuoteNode` would generate code that assigns the value of one variable
    to another. In this case, the variable `x` will be assigned with a value from
    variable `hello`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 `QuoteNode` 会生成将一个变量的值赋给另一个变量的代码。在这种情况下，变量 `x` 将被赋予来自变量 `hello` 的一个值。
- en: Understanding how `QuoteNode` works is essential creating expressions on the
    fly. It is common for programmers to interpolate symbols into an existing expression.
    So next, we will look at how to work with nested expressions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `QuoteNode` 的工作原理对于动态创建表达式至关重要。程序员将符号插值到现有表达式中是很常见的。因此，接下来我们将探讨如何处理嵌套表达式。
- en: Interpolating in nested expressions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在嵌套表达式中进行插值
- en: It is possible to have a quoted expression that contains another quoted expression.
    This is not a very common practice, unless the programmer needs to write meta-metaprograms.
    Nonetheless, we should still learn about how to interpolate in such a situation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能存在一个包含另一个引用表达式的引用表达式。除非程序员需要编写元元程序，否则这不是一个常见的做法。尽管如此，我们仍然应该了解如何在这样的情况下进行插值。
- en: 'First, let''s recap what a single-level expression looks like:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下单层表达式的样子：
- en: '![](img/b444be5d-ede6-48ae-b0c6-4812746ec43a.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b444be5d-ede6-48ae-b0c6-4812746ec43a.png)'
- en: 'We can wrap the quoted expression with another quote block in order to see
    what the structure of a nested expression looks like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将引用表达式包裹在另一个引用块中来查看嵌套表达式的结构：
- en: '![](img/66fd29be-2aae-47aa-b9cb-66c5b7922161.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66fd29be-2aae-47aa-b9cb-66c5b7922161.png)'
- en: 'Now, let''s try to interpolate in such an expression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在这样的表达式中进行插值：
- en: '![](img/66f6f2ba-72a7-42cd-81cc-55044b3cb6c1.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66f6f2ba-72a7-42cd-81cc-55044b3cb6c1.png)'
- en: 'As we can see, the `2` value did not get into the expression. The expression
    structure is also entirely different from what we had expected. The solution is
    to just interpolate the variable twice instead by using two `$` signs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`2` 值并没有进入表达式。表达式的结构也完全不同于我们预期的。解决方案是只需通过使用两个 `$` 符号将变量插值两次：
- en: '![](img/a5e4a9dc-2791-420c-add4-66a44d7b29cb.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5e4a9dc-2791-420c-add4-66a44d7b29cb.png)'
- en: In general, it is probably not much fun to interpolate more than one-level deep
    as the logic becomes difficult to work out. It can be useful, however, if you
    need to generate code for macros. I would definitely not suggest that you go more
    than two-levels deep and write meta-meta-metaprograms!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，插值超过一层深度可能不是很有趣，因为逻辑变得难以处理。然而，如果你需要为宏生成代码，这可能是有用的。我绝对不建议你超过两层深度并编写元元元程序！
- en: By now, you should be more familiar with, and comfortable working with, expressions.
    From the Julia REPL, it is quite easy to see how an expression is structured as
    represented as an `Expr` object. You should be able to construct new expressions
    and interpolate values inside; these are essential skills that will be required
    for metaprogramming.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look into a powerful metaprogramming feature in
    Julia—macros.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Developing macros
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how source code is represented as abstract syntax trees,
    we can start doing more interesting things by writing macros. In this section,
    we will learn what macros are and how to work with them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: What are macros?
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Macros are functions that accept expressions, manipulate them, and return a
    new expression. This is best understood with a diagram:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4271853-2e8b-4a47-bd13-28ecf8126b60.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: As we know, expressions are just abstract syntax tree representations of source
    code. So the macro facility in Julia allows you to take any source code and generate
    new source code. The resulting expression is then executed as if the source code
    was written directly in place.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may wonder why we cannot use regular functions to achieve
    the same thing. Why could we not write a function that takes expressions, generates
    a new expression, and then executes the resulting expression?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main reasons:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Macro expansion happens during compilation. This means that the macro is only
    executed once from where it is used—for example, when a macro is called from a
    function, the macro is executed at the time that the function is defined so that
    the function can be compiled.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting expression from a macro can be executed within the current scope.
    At runtime, there is no other way to execute any dynamic code within the function
    itself because the function, by definition, is already compiled. So, the only
    way to evaluate any expression is to do so in the global scope.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a better understanding of how macros
    work and how they differ from functions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: As we now understand what macros are, we will now continue our journey by writing
    our first macro.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first macro
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are defined in a similar way to how functions are defined, except that
    the `macro` keyword is used instead of the `function` keyword.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also keep in mind that a macro must return expressions. Let''s create
    our first macro. This macro returns an expression object that contains a `for`
    loop, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Invoking the macro is as easy as calling it with the `@` prefix. Refer to the
    following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b105cfd-4a31-4b85-b470-e9881e4bcb9f.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: 'Unlike functions, macros may be called without using parentheses. So we can
    just do the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43c8a997-9b9a-4fbc-90f8-d1ed60c47f33.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: '*Fantastic!* We have now written our first macro. While it does not look very
    exciting, because the code being generated is just a static piece of code, we
    have learned how to define macros and run them.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to pass arguments to macros.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Passing literal arguments
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like functions, macros can also take arguments. In fact, taking an argument
    is the most common occurrence for a macro. The simplest type of argument is literals,
    such as numbers, symbols, and strings.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to utilize these arguments in the returned expression, we can use
    the interpolation technique that we learned in the last section. Consider the
    following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `hello` macro takes a single argument, `n`, which is interpolated into
    the expression when the macro is run. As before, we can just invoke the macro
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e76e0851-af2d-4280-8c53-ee71cb64a788.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'As we learned earlier, parentheses are not required, so we can also call the
    macro as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39aae576-f8b8-446e-ba2d-4a4729444b62.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: You can try a similar exercise with string or symbol arguments. Passing literals
    is easy to understand because it works in the same way as functions. But there
    is indeed a subtle difference between macros and functions, which we will discuss
    in detail in the following section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Passing expression arguments
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to emphasize that macro arguments are passed as expressions
    rather than values. It may look confusing for beginners because macros are invoked
    similarly to functions, but the behavior is completely different.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure that we fully understand what this means. When calling a function
    with a variable, the value of the variable is passed into the function. Consider
    the following sample code for a `showme` function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f84cffba-eb41-4aaa-a648-3f09ece404b1.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create a `@showme` macro that does nothing but display the argument
    in the console. We can then compare the results with the preceding code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7cf9700-6cee-4fda-8a7c-7b0964b53d18.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: As we can see, the results from running a macro are totally different than those
    we get from calling a function. The function argument `x` really only sees an
    expression from where the macro was called. From the diagram at the beginning
    of this section, we can see that macros are supposed to take in expressions and
    return a single expression as a result. They do not know the value of the arguments
    as they work at the syntax level.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in the next section, expressions can even be manipulated when
    the macro is run. Let's go!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the macro expansion process
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By convention, every macro must return an expression. The process of taking
    one or more expressions and returning a new one is called **macro expansion**.
    Sometimes, it helps to see the expression being returned without actually running
    the code. We can use the `@macroexpand` macro for that purpose. Let''s try to
    use it for the `@hello` macro that we defined earlier in this section:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/289780c8-b7d0-4570-924a-9099604360f9.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'There are several things to note from this output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The `i` variable was renamed rather oddly: `#67#i`. This is done by the Julia
    compiler to ensure *hygiene*, which we will discuss later in this chapter. Macro
    hygiene is an important characteristic to keep in mind so that the code being
    generated does not conflict with other code.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comment was inserted into the loop that contains source file and line number
    information. This is a useful part of the expression when a debugger is used.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function call to `println` is bound to the one in the current environment,
    `Main`. This make sense because `println` is part of the `Core` package and is
    automatically brought into scope for every Julia program.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So when does macro expansion happen? Let's go over that next.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Timing of macro expansion
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the REPL, any macro is expanded as soon as we invoke it. Interestingly, when
    a function containing the macro is defined, the macro is expanded as part of the
    function definition process.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in action by developing a simple `@identity` macro that returns
    whatever expression is passed into it. Right before the expression is returned,
    we just `dump` the object to the screen. The code for the `@identity` macro is
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since this macro returns the same expression that was passed, it should end
    up executing the original source code that follows the macro.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a function that uses the `@identity` macro:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffe1dd38-680b-4965-a37f-c859e78a5b51.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Clearly, the compiler has figured out that the macro is being used in the definition
    of the `foo` function and, in order to compile the `foo` function, it must understand
    what the `@identity` macro does. So it expanded the macro and baked that into
    the function definition. During the macro expansion process, the expression was
    displayed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the `@code_lowered` macro against the `foo` function, we can see
    that the expanded code is now in the body of the `foo` function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7815efe2-61fe-478f-9a07-a9abfb5319a2.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: During development, the programmer may change the definitions of functions,
    macros, and so on frequently. Because macros are expanded when functions are defined,
    it is important to redefine the function again if any of the macros being used
    have been changed; otherwise, the function may continue to use the code generated
    from the prior macro definition.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The `@macroexpand` utility is an indispensable tool for developing macros, and
    in particular, is most useful for debugging purposes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will try to be a little more creative by manipulating expressions in
    macros.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating expressions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are powerful because they allow expressions to be manipulated during
    the macro expansion process. This is a tremendously useful technique, especially
    for code generation and designing domain-specific languages. Let's go over some
    examples to get a taste of what is possible.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – Making a new expression
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a simple one. Suppose that we want to create a macro called
    `@squared` that takes an expression and just squares it. In other words, if we
    run `@squared(x)`, then it should be translated into `x * x`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At first glance, it seems to work fine when we run it from the REPL:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0497020c-1f39-47af-a3da-366abf4482ef.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'But this macro has a problem with the execution context. The best way to illustrate
    the problem is by defining a function that uses the macro. So let''s define a `foo`
    function, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when we call the function, we get the following error:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0481fc86-f878-46b4-867e-4aee1e845c32.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Why is that? It is because, during the macro expansion, the `x` symbol refers
    to the variable in the module rather than the local variable in the `foo` function.
    We can confirm this by using the `@code_lowered` macro:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/500c7a34-0f8b-4747-8811-56f00eed2e5e.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Obviously, our intention was to square the local `x` variable rather than `Main.x`.
    The easy fix to this problem is to use the `esc` function during interpolation
    in order to place the expression directly in the syntax tree without letting the
    compiler resolve it. The following is how it can be done:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since the macro was expanded earlier, before `foo` was defined, we need to
    define the `foo` function once again, as follows, for this updated macro to take
    effect. Alternatively, you can start a new REPL and define the `@squared` macro
    and `foo` function again. Here we go:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cb9a817-8915-4ea2-ba6b-2cb0e2158dc5.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: The `foo` function works correctly now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: From this example, we have learned how to create a new expression using the
    interpolation technique. We have also learned that the interpolated variable needs
    to be escaped using the `esc` function to avoid it being resolved by the compiler
    to the global scope.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 - Tweaking the abstract syntax tree
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we want to design a macro called `@compose_twice` that takes a simple
    function call expression and calls the same function again with the result—for
    example, if we run `@compose_twice sin(x)`, then it should be translated to `sin(sin(x))`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write the macro, let''s first get familiar with the abstract syntax
    tree of the expression:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/664d8b6d-80b2-459e-bbfe-9ae14e9ac4d2.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'How does it look for `sin(sin(x))`? Refer to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e9871e0-6b20-4997-8674-ee2e84f80a5d.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: No surprise here. The second argument of the top-level call is just another
    expression that looks like what we saw previously.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the macro as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first two `@assert` statements are used to ensure that the expression represents
    a function call that takes a single argument. As we want to replace the argument
    with a similar expression, we just make a copy of the current expression object
    and assign it to `ex.args[2]`. The macro then returns the resulting expression
    for evaluation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that the macro is working correctly:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ed701a3-07c2-4ca7-a172-b20b41a87a65.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: As you can see, we can translate the source code by manipulating the abstract
    syntax tree directly rather than interpolating variables into a nice-looking expression.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: By now, you can probably appreciate the power of metaprogramming. Compared to
    using interpolation, manipulating an expression directly is not as easy to understand
    because the resulting expression is not represented in the code; however, the
    ability to manipulate expressions provides the ultimate flexibility in translating
    source code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will go over an important feature of metaprogramming—macro hygiene.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Understanding macro hygiene
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macro hygiene refers to the ability to keep macro-generated code clean. It is
    referred to as hygiene because the generated code does not get polluted by other
    parts of the code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that many other programming languages do not provide such a guarantee.
    The following is a C program that contains a macro called `SWAP`, which is used
    to exchange the value of two variables:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, running this C program yields an incorrect result:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c89d315-9273-4b0a-b9a1-6a032a9c5cc6.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: It did not swap the `a` and `temp` variables properly because the `temp` variable is
    also used as a temporary variable in the body of the macro.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to Julia. Consider the following macro, which just runs an `ex` expression and
    repeats it `n` times:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since the `times` variable is used in the returned expression, what would happen
    if the same variable name is already used in the call site? Let''s try this sample
    code, which defines a `times` variable before the macro call and prints the value
    of the same variable after the macro call:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the macro expander took it literally, then the `times` variable would be
    modified to `3` after the macro call; however, we can see it working properly
    in the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69356a2f-70f7-4981-98df-dcc7d1f77cc5.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'It works because the macro system is able to maintain hygiene by renaming the
    `times` variable to something different so that there is no conflict. Where is
    the magic? Well, let''s take a look at the expanded code using `@macroexpand`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07a64213-e13d-4060-aa22-8546322f2124.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the `times` variable has turned into `#44#times`. The
    loop variable `i` has also turned into `#45#i`. These variable names are dynamically
    generated by the compiler to ensure that macro-generated code does not conflict
    with other user-written code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Macro hygiene is an essential feature for macros to function correctly. There
    is nothing that the programmer needs to do: Julia automatically provides the guarantee.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into a different kind of macro that powers nonstandard string
    literals.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Developing nonstandard string literals
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a special kind of macro for defining nonstandard string literals, which
    look like a literal string but instead a macro is called when it is referenced.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example would be Julia''s regular expression literal—for example, `r"^hello"`.
    It is not a standard string literal because of the `r` prefix in front of the
    double quote. Let''s first check the data type of such a literal. We can see that a `Regex` object
    is created from the string:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66d4c40a-9654-4c61-84c8-74f090383aad.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: We can also create our own nonstandard string literals. Let's try to work through
    a fun example together here.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that, for development purposes, we want to conveniently create sample
    data frames with different types of columns. The syntax for doing so is a little
    bit tedious:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91855e88-e2b9-40e7-8e6d-758a223a67c0.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: Imagine that we occasionally need to create tens of columns with different data
    types. The code for creating such a data frame would be very long, and as a programmer,
    I would be extremely bored typing that all out. So we could design a string literal
    so that it contains the specification for constructing such a data frame—let's
    call it a `ndf` (numerical data frame) literal.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The specification on `ndf` just needs to encode the desired number of rows and
    column types. For instance, the literal `ndf"100000:f64,i16"` can be used to represent
    the preceding sample data frame, where 100,000 rows are needed, with two columns
    labeled as the `Float64` and `Int16` columns.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this feature, we just define a macro called `@ndf_str`. The macro
    takes a string literal and creates the desired data frame accordingly. The following
    is one way to implement the macro:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first few lines parse the string and determine the number of rows (`n`),
    as well as the types of the columns (`types`). Then, a dictionary called `mappings`
    is created to map the shorthand to the corresponding numeric types. The column
    names and types are generated from the type and mapping data. Finally, it calls
    the `DataFrame` constructor and returns the result.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the macro defined, we can easily create new data frames, as
    follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26cacfc8-c5ab-431b-977a-b38b526a1447.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: Nonstandard string literals can be quite useful in certain cases. We can see
    a string specification as a mini domain-specific language that is encoded in the
    string. As long as the string specification is well defined, it can make the code
    a lot shorter and more concise.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the `ndf_str` macro returns a regular `DataFrame`
    object rather than an expression object, as it would normally do with macros.
    This is perfectly fine because the final `DataFrame` object will be returned as-is.
    You may think of an evaluation of a constant as just the constant itself. We can
    just return a value rather than an expression here because the returned value
    does not involve any variables from the call site or from the module.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: A curious mind might ask - why can't we just create a regular function for this?
    We can certainly do that for this dummy example. However, using a string literal
    could improve performance in some cases.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we use the Regex string literal in a function, the `Regex`
    object is created at compile-time and so it is executed only once. If we use the `Regex`
    constructor instead, then the object would be created every single time the function
    is called.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We have now concluded the topic of macros. We learned how to create macros by
    taking expressions and generating a new expression. We used the `@macroexpand`
    macro to debug the macro expansion process. We also learned how to handle macro
    hygiene. Finally, we took a look at nonstandard string literals and created our
    own using a macro.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at another metaprogramming facility called generated functions,
    which can be used to solve a different kind of problem than what regular macros
    can handle.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Using generated functions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explained how to create macros that return expression objects.
    Since macros work at the syntax level, they can manipulate code only by examining
    how it *looks*. However, Julia is a dynamic system where data types are determined
    at runtime. For that reason, Julia provides the ability to create **generated
    functions**, which allow you to examine data types for a function call and return
    an expression, just like macros. When an expression is returned, it will be evaluated
    at the call site.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why generated functions are needed, let''s revisit how macros
    work. Let''s say we have created a macro that doubles the value of its arguments.
    It would look like the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: No matter what expression we pass into this macro, it would just blindly rewrite
    the code so it doubles the original expression. Suppose that one day, a super-duper
    piece of software is developed that lets us calculate twice the amount of a floating-point
    number quickly. In this case, we may want the system to switch to that function
    for floating-point numbers only, instead of using the standard multiplication
    operator.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'So our first attempt might be to try something as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But unfortunately, it is impossible for macros to do this. Why? Again, macros
    only have access to the abstract syntax tree. This is at the earlier part of the
    compilation pipeline and there is no type information available. The `ex` variable in
    the preceding code is merely an expression object. This problem can be solved
    with generated functions. Keep on reading!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Defining generated functions
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generated functions** are functions that are prefixed by `@generated` at
    the function definition. These functions can return expression objects, just like
    macros. For example, we can define the `doubled` function as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s quickly run a test and make sure that it works:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5743d747-3b23-4e65-beaa-ba7d94f060cf.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: The code works beautifully, as expected.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: So defining generated functions is quite similar to defining macros. In both
    cases, we can create an expression object and return it, and we can expect the
    expression to be evaluated properly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: We have not, however, exercised the full power of generated functions yet. Next,
    we will look at how data type information can be made available and how it can
    be used within generated functions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Examining generated function arguments
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important point to remember is that arguments of generated functions contain
    data types, not actual values. The following is a visual representation of how
    generated functions work:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/567af354-7dcc-46c4-991b-c74c16cc9f4c.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: This is in sharp contrast to functions, which accept arguments as values. It
    is also different from macros, which accept arguments as expressions. Here, generated
    functions accept arguments as data types. It may seem a little strange, but let's
    do a simple experiment to confirm that this is indeed the case.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: For this experiment, we will define the `doubled` function again by displaying
    the argument on screen before returning the expression.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's test the function again.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65ba16c7-91c2-41d3-aac9-61f02d5be2ba.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
- en: As it is shown, the value of argument `x` is `Int64` rather than `2` during
    the execution of the generated function. Furthermore, when the function is called
    again, it no longer shows the value of `x`. This is because the function is now
    compiled after the first call.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if we run it again with a different type:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/149b0d49-32bb-4144-8244-80e6b45e9b7e.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: The compiler has kicked in again and compiled a new version based upon the type
    of `Float64`. So, technically speaking, we now have two versions of the `doubled`
    function for each type of argument.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: You may have realized that the behavior of generated functions is similar to
    that of regular functions when it comes to specialization. The difference is that
    we have a chance to manipulate the abstract syntax tree right before the compilation
    happens.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new generated function, we can now take advantage of the hypothetical
    super-duper software by switching over to the faster `double_super_duper` function
    whenever the data type of the argument is a subtype of `AbstractFloat`, as shown
    in the following code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using generated functions, we can specialize the function depending on the type
    of the argument. When the type is `AbstractFloat`, the function will resort to
    the `double_super_duper(x)` rather than the `2 *x` expression.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the official Julia language reference manual, care must be taken
    when developing generated functions. The exact limitations are beyond of the scope
    of this book. You are highly encouraged to refer to the manual if you need to
    write generated functions for your software.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Generated functions are a useful tool to deal with cases that macros are unable
    to handle. Specifically, during the macro expansion process, there is no information
    about the types of the argument. Generated functions allow us to get a little
    closer to the heart of the compilation process. With the additional knowledge
    about argument types, we are more flexible when it comes to handling different
    situations.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: As a metaprogramming tool, macros are used much more extensively than generated
    functions. Nevertheless, it is nice to know that both tools are available.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how Julia parses expressions into an abstract syntax
    tree structure. We learned that expressions can be created and evaluated programmatically.
    We also learned how to interpolate variables into quoted expressions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Then, we jumped into the topic of macros, which are used to dynamically create
    new code. We learned that macro arguments are expressions rather than values,
    and learned how to create new expressions from macros. We had fun creating macros
    that manipulate the abstract syntax tree to deal with some interesting use cases.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at generated functions, which can be used to generate code
    based on the type of the function arguments. We learned how generated functions
    can be useful for a hypothetical use case.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: We have now concluded the introductory part of the book regarding the Julia
    programming language. In the next chapter, we will start looking at design patterns
    related to code reusability.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two ways we can use to quote expressions so that the code can be
    manipulated later?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what environment does the `eval` function execute code?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you interpolate physical symbols into quoted expressions so that they
    are not misinterpreted as source code?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the naming convention for a macro that defines nonstandard string literals?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When do you use the `esc` function?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are generated functions different from macros?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you debug macros?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
