- en: Macros and Metaprogramming Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏和元编程技术
- en: 'This chapter will discuss two of the most powerful facilities in the Julia
    programming language: macros and metaprogramming.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论Julia编程语言中最强大的两个功能：宏和元编程。
- en: 'In a nutshell, metaprogramming is a technique for writing code that generates
    code—that''s why it has the prefix *meta*. It may sound esoteric, but it is a
    fairly common practice in many programming languages today. For example, C compiler
    uses a preprocessor to read source code and produce new source code, and then
    the new source code is compiled into a binary executable. For example, you can
    define a `MAX` macro, as in `#define MAX(a,b) ((a) > (b) ? (a) : (b))`, and this
    means that every time we use `MAX(a,b)`, it is replaced with `((a) > (b) ? (a)
    : (b))`. Note that `MAX(a,b)` is much easier to read than the longer form.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '简而言之，元编程是一种编写生成代码的代码的技术——这就是为什么它有前缀*meta*。这可能听起来很神秘，但它是今天许多编程语言中相当常见的实践。例如，C编译器使用预处理器来读取源代码并生成新的源代码，然后新的源代码被编译成二进制可执行文件。例如，你可以定义一个`MAX`宏，如下所示`#define
    MAX(a,b) ((a) > (b) ? (a) : (b))`，这意味着每次我们使用`MAX(a,b)`时，它都会被替换为`((a) > (b) ? (a)
    : (b))`。请注意，`MAX(a,b)`比更长的形式更容易阅读。'
- en: The history of metaprogramming is quite long. As far back as the 1970s, it was
    already popular among the LISP programming language community. Interestingly,
    the LISP language is designed in such a way that the source code is structured
    like data—for example, a function call in LISP looks like `(sumprod x y z)`, where
    the first element is the name of the function and the rest are arguments. Since
    it is really just a list of four symbols—`sumprod`, `x`, `y`, and `z`—we can take
    this code and manipulate it in any way—for example, we can expand it so it calculates
    both the sum and product of the numbers, so the generated code becomes `(list
    (+ x y z) (* x y z))`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程的历史相当悠久。早在20世纪70年代，它就已经在LISP编程语言社区中流行起来。有趣的是，LISP语言的设计方式使得源代码的结构类似于数据——例如，LISP中的函数调用看起来像`(sumprod
    x y z)`，其中第一个元素是函数的名称，其余的是参数。由于它实际上只是一个包含四个符号的列表——`sumprod`、`x`、`y`和`z`——我们可以以任何方式操作这段代码——例如，我们可以扩展它以计算数字的和与积，因此生成的代码变为`(list
    (+ x y z) (* x y z))`。
- en: 'You may wonder whether we can just write a function for that. The answer is,
    yes: in both of the examples that we just looked at, there is no need to use a
    metaprogramming technique. The examples were there only to illustrate how metaprogramming
    works. In general, we can say that metaprogramming is not needed 99% of the time;
    however, there is still that remaining 1% of cases where metaprogramming would
    be very useful. The first section will explore use cases where we would want to
    use metaprogramming.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我们是否可以只为这个目的编写一个函数。答案是，是的：在我们刚刚查看的两个例子中，没有必要使用元编程技术。这些例子只是为了说明元编程是如何工作的。一般来说，我们可以这样说，99%的时间不需要元编程；然而，仍然有那剩下的1%的情况，元编程会非常有用。第一部分将探讨我们想要使用元编程的场景。
- en: 'In this chapter, we will learn several metaprogramming facilities in Julia. The
    following topics will be covered in particular:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Julia语言中的几个元编程功能。特别是以下内容将被涵盖：
- en: Understanding the need for metaprogramming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解元编程的需求
- en: Working with expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与表达式一起工作
- en: Developing macros
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发宏
- en: Using generated functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成的函数
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源代码位于[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04)。
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在Julia 1.3.0环境中进行了测试。
- en: Understanding the need for metaprogramming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解元编程的需求
- en: At the beginning of the chapter, we boldly claimed that metaprogramming is not
    needed 99% of the time. That is indeed not a made-up number. At the JuliaCon 2019
    conference, Professor Steven Johnson from MIT delivered a keynote speech regarding
    metaprogramming. He did some research about the Julia language's own source code.
    From his study, Julia version 1.1.0 contains 37,000 methods, 138 macros (0.4%),
    and 14 generated functions (0.04%). So metaprogramming code comprises less than
    1% of Julia's own implementation. While this is just one example of metaprogramming's
    role in one language, it is representative enough that even the smartest software
    engineers would not use metaprogramming most of the time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们大胆地宣称99%的时间不需要元编程。这确实不是一个虚构的数字。在2019年的 JuliaCon 会议中，麻省理工学院的史蒂文·约翰逊教授就元编程发表了主题演讲。他对
    Julia 语言的源代码进行了一些研究。从他的研究中，Julia 版本 1.1.0 包含了37,000个方法，138个宏（0.4%），以及14个生成函数（0.04%）。因此，元编程代码仅占
    Julia 自身实现的不到1%。虽然这只是元编程在一种语言中作用的例子，但它足以说明即使是最高明的软件工程师也不会经常使用元编程。
- en: 'So the next question is: When do you need to use metaprogramming techniques?
    Generally speaking, there are several reasons for using such techniques:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以下一个问题是：何时需要使用元编程技术？一般来说，使用这些技术有几个原因：
- en: They may allow a solution to be expressed more concisely and in a way that is
    easier to understand. Writing code without metaprogramming would otherwise look
    ugly and be difficult to comprehend.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们可能允许以更简洁和更易于理解的方式表达解决方案。如果不使用元编程编写代码，代码看起来会很丑陋，难以理解。
- en: It may reduce the development time because the source code can be generated
    rather than written out; boilerplate code, especially, can be eliminated.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可能会减少开发时间，因为源代码可以生成而不是手动编写；尤其是样板代码可以被消除。
- en: It may improve performance because the code is spelled out rather than executed
    via other higher-level programming constructs, such as looping.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可能会提高性能，因为代码是直接编写的而不是通过其他高级编程结构（如循环）执行。
- en: We will now look at some examples of how metaprogramming is used in the real
    world.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看看一些在现实世界中如何使用元编程的例子。
- en: Measuring performance with the @time macro
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @time 宏来衡量性能
- en: 'Julia comes with a useful macro called `@time`, which measures the time required
    to execute code. For example, to measure how long it takes to calculate the sum
    of 10 million random numbers, we can do the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 内置了一个有用的宏 `@time`，它可以测量执行代码所需的时间。例如，为了测量计算一千万个随机数之和所需的时间，我们可以这样做：
- en: '![](img/79626f6a-ec00-4d63-8032-f414bbcc0024.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79626f6a-ec00-4d63-8032-f414bbcc0024.png)'
- en: 'The macro works by inserting code around the code that is being measured. The
    resulting code may look something like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 宏通过在要测量的代码周围插入代码来工作。生成的代码可能看起来像以下这样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The new code uses the `now()` function to take the current time. Then, it executes
    the user-provided code and captures the result. It takes the current time again,
    calculates the elapsed time, prints the timing information to the console, and
    then it returns the result.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码使用 `now()` 函数来获取当前时间。然后，它执行用户提供的代码并捕获结果。它再次获取当前时间，计算经过的时间，将计时信息打印到控制台，然后返回结果。
- en: 'Can this be done without metaprogramming? Perhaps we can give that a try. Let''s
    define a function called `timeit` as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否可以不使用元编程来完成？也许我们可以尝试一下。让我们定义一个名为 `timeit` 的函数，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To use this timing facility, we need to wrap the expression in a function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个计时功能，我们需要将表达式包裹在一个函数中。
- en: '![](img/d8f1db6b-774b-4099-8398-baaa18c3f2a8.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8f1db6b-774b-4099-8398-baaa18c3f2a8.png)'
- en: This function works fairly well, but the problem is that we have to wrap the
    code in a separate function before we can measure its performance, which is a
    hugely inconvenient thing to do. Because of this, we can conclude that having
    a `@time` macro is more appropriate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数工作得相当好，但问题是我们在测量其性能之前必须将代码包裹在一个单独的函数中，这是一件非常不方便的事情。正因为如此，我们可以得出结论，拥有一个 `@time`
    宏更为合适。
- en: Unrolling loops
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开循环
- en: Another use case of macros is to unroll loops into repeating code fragments.
    Loop unrolling is a performance optimization technique. The premise behind it
    is that there is always some overhead that is required to execute code in a loop.
    The reason is that, every time an iteration is finished, the loop must check for
    a condition and decide whether it should exit or continue with the next iteration.
    Now, if we know exactly how many times the loop needs to run the code, then we
    can *unroll* it by writing out the code in a repeated fashion.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的另一个用途是将循环展开成重复的代码片段。循环展开是一种性能优化技术。其背后的前提是执行循环代码总是需要一些开销。原因是，每次迭代完成后，循环必须检查条件并决定是否应该退出或继续下一次迭代。现在，如果我们确切知道循环需要运行多少次代码，那么我们可以通过以重复的方式编写代码来*展开*它。
- en: 'Consider a simple loop as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的循环如下：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can unroll the loop into three lines of code that do the exact same job:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将循环展开成三行代码，它们执行完全相同的工作：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But it would be quite a boring and mundane task to have to unroll loops manually.
    Furthermore, the amount of work grows linearly with the number of iterations required
    in the loop. With the help of `Unroll.jl`, we can define a function using the
    `@unroll` macro, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但手动展开循环将是一项相当无聊和枯燥的任务。此外，工作量会随着循环中所需的迭代次数线性增长。借助`Unroll.jl`，我们可以使用`@unroll`宏定义一个函数，如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code looks as clean as it should be, and the `@unroll` macro is inserted
    in front of the function as well as the `for` loop. First, we should check that
    the code works properly:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像应该的那样干净，`@unroll`宏被插入到函数以及`for`循环之前。首先，我们应该检查代码是否正常工作：
- en: '![](img/6616ec0d-2ed2-4231-8acc-b7b32bd53a40.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6616ec0d-2ed2-4231-8acc-b7b32bd53a40.png)'
- en: 'Now, we should question whether the `@unroll` macro actually did anything.
    A good way to check whether the loop was unrolled is to use the `@code_lowered`
    macro:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该质疑`@unroll`宏是否真的做了什么。检查循环是否展开的一个好方法是使用`@code_lowered`宏：
- en: '![](img/e54b3954-bdea-413c-9fe4-16a48708327d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e54b3954-bdea-413c-9fe4-16a48708327d.png)'
- en: The lowered code clearly contains three `println` statements rather than a single
    `for` loop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 降低后的代码明显包含三个`println`语句，而不是一个单独的`for`循环。
- en: What is lowered code? The Julia compiler must go through a series of processes
    before source code is compiled to binaries. The very first step is to parse the
    code into an **abstract syntax tree** (**AST**) format, which we will learn about
    in the next session. After that, it goes through a *lowering* process to expand
    the macros and convert the code into concrete execution steps.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是降低后的代码？Julia 编译器在将源代码编译成二进制文件之前必须经过一系列的过程。第一步是将代码解析成**抽象语法树**（**AST**）格式，我们将在下一节中学习。之后，它通过*降低*过程来展开宏并将代码转换为具体的执行步骤。
- en: Now that we have seen some examples and know the power of metaprogramming, we
    shall move forward and learn how to create these macros ourselves.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些示例并了解了元编程的力量，我们将继续学习如何自己创建这些宏。
- en: Working with expressions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表达式
- en: Julia represents the source code of any runnable program as a tree structure.
    This is called an **abstract syntax tree** (**AST**). It is referred to as *abstract*
    as the tree only captures the structure of the code rather than the real syntax.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 将任何可运行的程序的源代码表示为树结构。这被称为**抽象语法树**（**AST**）。它被称为*抽象的*，因为树只捕获代码的结构而不是真正的语法。
- en: 'For example, the expression `x + y` can be represented with a tree where the
    parent node identifies itself as a function call and the child nodes include the
    operator function `+` and the `x` and `y` arguments. The following is an implementation
    of this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`x + y`可以用一个树来表示，其中父节点标识自己为函数调用，子节点包括运算符函数`+`和`x`、`y`参数。以下是其实现：
- en: '![](img/63989de7-d8b6-4b30-9fde-8c4e264f696c.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63989de7-d8b6-4b30-9fde-8c4e264f696c.png)'
- en: 'The slightly more complex expression `x + 2y + 1` would look like the following
    diagram. While it was written with two addition operators, the expression is parsed
    into a single function call to the `+` function, for which it takes three arguments—`x`,
    `2y`, and `1`. Because `2y` is itself an expression, it can be seen as a subtree
    of the main abstract syntax tree:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 略微复杂一些的表达式`x + 2y + 1`看起来如下所示。虽然它使用了两个加法运算符，但表达式被解析为对`+`函数的单个函数调用，它接受三个参数——`x`、`2y`和`1`。因为`2y`本身也是一个表达式，它可以看作是主抽象语法树的子树：
- en: '![](img/a8f1f88d-4ee8-498b-a969-4c8e4bf5330e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8f1f88d-4ee8-498b-a969-4c8e4bf5330e.png)'
- en: The Julia compiler must first parse source code into an abstract syntax tree,
    and then it can perform additional transformations and analysis, such as expanding
    macros, type checking, type inference, and eventually translating the code into
    machine code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Julia编译器必须首先将源代码解析成抽象语法树，然后才能执行额外的转换和分析，例如宏展开、类型检查、类型推断，最终将代码转换成机器码。
- en: Experimenting with the parser
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试解析器
- en: 'Because the abstract syntax tree is just a data structure, we can examine it
    directly within the Julia REPL environment. Let''s just start with a simple expression: `x
    + y`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为抽象语法树只是一个数据结构，我们可以在Julia的REPL环境中直接检查它。让我们从一个简单的表达式开始：`x + y`：
- en: '![](img/8186f498-fee4-46b5-93c4-b870de13cd62.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8186f498-fee4-46b5-93c4-b870de13cd62.png)'
- en: In Julia, every expression is represented as an `Expr` object. We can create
    an `Expr` object by just parsing a string with the `Meta.parse` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，每个表达式都表示为一个`Expr`对象。我们可以通过使用`Meta.parse`函数解析一个字符串来创建一个`Expr`对象。
- en: 'Here, the expression object is displayed with a syntax that resembles the original
    source code so that it is easier to read. We can confirm that the object has the
    type of `Expr` as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，表达式对象以类似于原始源代码的语法显示，以便更容易阅读。我们可以确认该对象具有`Expr`类型如下：
- en: '![](img/2f61ebe7-8d7c-4ab5-8a0d-f27bb6e5e280.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f61ebe7-8d7c-4ab5-8a0d-f27bb6e5e280.png)'
- en: 'In order to view the abstract syntax tree, we can use the `dump` function to
    print the structure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看抽象语法树，我们可以使用`dump`函数来打印结构：
- en: '![](img/cbfb4302-ee10-46ec-baaf-64cbdd3b0141.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbfb4302-ee10-46ec-baaf-64cbdd3b0141.png)'
- en: In Julia, every expression is represented by a head node and an array of arguments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，每个表达式都由一个头节点和参数数组表示。
- en: In this case, the head node contains just a `call` symbol. The `args` array
    contains the `+` operator and two variables, `x` and `y`. Note that everything
    here is a symbol—that's OK because we are examining the source code itself, which
    is understandably just a tree of symbols.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，头节点只包含一个`call`符号。`args`数组包含`+`运算符和两个变量，`x`和`y`。请注意，这里的一切都是一个符号——这是可以的，因为我们正在检查源代码本身，它本质上只是一个符号的树。
- en: Since we have had so much fun here, let's try a few other expressions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里玩得很开心，让我们尝试几个其他的表达式。
- en: Single-variable expressions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单变量表达式
- en: 'One of the simplest expressions is just a reference to a variable. You can
    try to parse a numeric or string literal and see what it returns:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个最简单的表达式只是一个变量的引用。你可以尝试解析一个数字或字符串字面量，看看它返回什么：
- en: '![](img/1943fdfd-f8d9-4f34-9e8c-af4e356514f2.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1943fdfd-f8d9-4f34-9e8c-af4e356514f2.png)'
- en: Function calls with keyword arguments
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带关键字参数的函数调用
- en: 'Let''s try something a little more complex. We will examine a function call
    that takes a single positional argument and two keyword arguments. Here, we use
    triple quotes around the code so that we can handle the double quotes inside it
    properly:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个稍微复杂一些的例子。我们将检查一个函数调用，它接受一个位置参数和两个关键字参数。在这里，我们使用三引号包围代码，以便正确处理其中的双引号：
- en: '![](img/0e81cd68-ad62-44e1-a766-8823d216d42f.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e81cd68-ad62-44e1-a766-8823d216d42f.png)'
- en: Note that a function call has the `call` symbol as the head node of the expression.
    Also, the keyword arguments are represented as subexpressions, each with a head
    node of `kw` and a two-element array for the name and value of the argument.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数调用以`call`符号作为表达式的头节点。此外，关键字参数表示为子表达式，每个子表达式都有一个头节点`kw`和一个包含参数名称和值的两个元素数组。
- en: Nested functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: 'We may wonder how Julia parses code when functions are nested. We can pick
    a simple example here that takes the sine of `x+1` and then takes the cosine of
    the result. The abstract syntax tree is shown as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会好奇当函数嵌套时，Julia是如何解析代码的。这里我们可以选择一个简单的例子，它计算`x+1`的正弦值，然后计算结果的余弦值。抽象语法树如下所示：
- en: '![](img/3bf61837-89ac-4f12-9b51-05f080dd5def.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bf61837-89ac-4f12-9b51-05f080dd5def.png)'
- en: Here, we can clearly see the tree structure. The outermost function, `cos`,
    contains a single argument, which is an expression node with a call to the `sin`
    function. This expression in turn contains a single argument, which is another
    expression node with a call to the `+` operator function with two arguments—the
    `x` variable and a value of `1`. Now, let's continue with our work on expressions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以清楚地看到树结构。最外层的函数`cos`包含一个参数，它是一个调用`sin`函数的表达式节点。这个表达式反过来包含一个参数，它是一个调用带有两个参数的`+`运算符函数的表达式节点——`x`变量和值为`1`。现在，让我们继续我们的表达式工作。
- en: Constructing expression objects manually
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动构建表达式对象
- en: As an expression is just a data structure, we can easily construct them programmatically.
    Understanding how to do this is essential for metaprogramming, which involves
    creating new code structures on the fly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表达式只是一个数据结构，我们可以很容易地通过编程方式构建它们。理解如何做到这一点对于元编程至关重要，元编程涉及在运行时创建新的代码结构。
- en: 'The `Expr` constructor has the following signature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expr`构造函数有以下签名：'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The head node always carries a symbol. The arguments just contain whatever
    the head node expects—for example, the simple expression `x + y` can be created
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 头部节点总是携带一个符号。参数只包含头部节点期望的内容——例如，简单的表达式`x + y`可以创建如下：
- en: '![](img/5f5bb0a3-13ab-4c7c-ba4e-233f519f08f2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f5bb0a3-13ab-4c7c-ba4e-233f519f08f2.png)'
- en: 'Of course, we can always create a nested expression if we want to:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们想的话，我们总是可以创建一个嵌套表达式：
- en: '![](img/0938942b-66a5-4fb1-a623-f01b023c2e55.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0938942b-66a5-4fb1-a623-f01b023c2e55.png)'
- en: 'At this point, you may wonder whether there is an easier way to create expressions
    without having to construct `Expr` objects manually.  For sure, it can be done
    as shown below:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你可能想知道是否有更简单的方法来创建表达式，而无需手动构建`Expr`对象。当然，可以像下面这样做到：
- en: '![](img/c2579b8b-162f-4294-8eab-9b4540a7ab02.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2579b8b-162f-4294-8eab-9b4540a7ab02.png)'
- en: 'Basically, we can wrap any expression with `:(` on the left and `)` on the
    right. The code that sits inside will not be evaluated, but will instead be parsed
    into an expression object; however, this way of quoting only works with a single
    expression—if you try to do this with multiple expressions, an error will be displayed,
    as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们可以用左边的`:(`和右边的`)`将任何表达式包裹起来。代码块内的代码将不会被评估，而是被解析为一个表达式对象；然而，这种引用方式只适用于单个表达式——如果你尝试用多个表达式这样做，将会显示错误，如下面的代码所示：
- en: '![](img/f7d55f45-9cd4-4003-bc18-c9f59b614cf5.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7d55f45-9cd4-4003-bc18-c9f59b614cf5.png)'
- en: 'It does not work because multiple expressions should be wrapped with `begin`
    and `end` keywords. So it would be fine if we entered the following code block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不行的，因为多个表达式应该用`begin`和`end`关键字包裹。所以如果我们输入以下代码块会更好：
- en: '![](img/0a4102ef-4edd-4e15-b44b-c2fd311d2446.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a4102ef-4edd-4e15-b44b-c2fd311d2446.png)'
- en: The result is a little interesting. As you can see, the code is now wrapped
    within a `quote/end` block rather than a `begin/end` block. It actually makes
    sense because a quoted expression is being displayed rather than the original
    source code. Remember, this is the abstract syntax tree rather than the original
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 结果有点有趣。正如你所见，代码现在被包裹在一个`quote/end`块中，而不是`begin/end`块中。这实际上是有道理的，因为显示的是引用的表达式而不是原始源代码。记住，这是抽象语法树而不是原始代码。
- en: 'It also turns out that `quote/end` can be used directly to create expressions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明`quote/end`可以直接用来创建表达式：
- en: '![](img/b85ff5b5-02db-46bc-a44a-985c8dd178a5.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b85ff5b5-02db-46bc-a44a-985c8dd178a5.png)'
- en: We have now learned how to parse source code into an expression object. Next,
    we will look into more complex expressions so that we are more familiar with the
    basic code structure of Julia programs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何将源代码解析为表达式对象。接下来，我们将探讨更复杂的表达式，以便我们更熟悉Julia程序的基本代码结构。
- en: Playing with more complex expressions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转更复杂的表达式
- en: As we said before, any valid Julia program can be represented as an abstract
    syntax tree. Now that we have the building blocks to create expression objects,
    let's examine a few more constructs and see what expression objects look like
    for more complex programs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，任何有效的Julia程序都可以表示为一个抽象语法树。现在我们已经有了创建表达式对象的构建块，让我们考察一些更多的结构，看看更复杂程序的表达式对象是什么样的。
- en: Assignment
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值
- en: 'We will see how it works for assignments first. Consider the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看赋值是如何工作的。考虑以下代码：
- en: '![](img/8c32beb4-b5b1-49e3-a440-ba7fc4608b27.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c32beb4-b5b1-49e3-a440-ba7fc4608b27.png)'
- en: From the preceding code, we can see that the variable assignment has a head
    node of `=` and two arguments—the variable to be assigned (`x`, in this case)
    and another expression object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到变量赋值有一个`=`的头部节点和两个参数——要赋值的变量（在这个例子中是`x`）和另一个表达式对象。
- en: Code blocks
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码块
- en: A code block is enclosed by the `begin` and `end` keywords. Let's examine what
    the abstract syntax tree looks like.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块由`begin`和`end`关键字包围。让我们看看抽象语法树是什么样子的。
- en: '![](img/925b6634-edb5-4819-a66a-af1bdd69944c.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/925b6634-edb5-4819-a66a-af1bdd69944c.png)'
- en: The head node just contains a `block` symbol. When there are multiple lines
    in the block, the abstract syntax tree also includes line number nodes. In this
    example, there is a `LineNumberNode` with line 2 preceding the first call to `println`.
    Likewise, there is another `LineNumberNode` with line 3 preceding the second call
    to `println`. The `LineNumberNode` nodes do not do anything, but they are useful
    for stack traces and debugging.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点只包含一个 `block` 符号。当块中有多行时，抽象语法树也包括行号节点。在这个例子中，有一个 `LineNumberNode` 在 `println`
    的第一次调用之前，行号为 2。同样，还有一个 `LineNumberNode` 在 `println` 的第二次调用之前，行号为 3。`LineNumberNode`
    节点不做任何事情，但它们对于堆栈跟踪和调试很有用。
- en: Conditional
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件
- en: 'Next up, we''ll explore conditional constructs, such as `if-else-end`. Refer
    to the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索条件结构，如 `if-else-end`。参考以下代码：
- en: '![](img/3d2b3253-89b5-45d3-91bf-2e2346c730fd.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d2b3253-89b5-45d3-91bf-2e2346c730fd.png)'
- en: The head node contains the `if` symbol. There are three arguments—an expression
    for the condition, a block expression when the condition is satisfied, and another
    block expression when the condition is not satisfied.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点包含 `if` 符号。有三个参数——一个表示条件的表达式，一个当条件满足时的块表达式，以及一个当条件不满足时的另一个块表达式。
- en: Loop
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'We will now move on to looping constructs. Consider a simple `for` loop, as
    follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向循环结构。考虑一个简单的 `for` 循环，如下所示：
- en: '![](img/2130fa5b-520d-47a8-b2b9-7b1235351fc7.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2130fa5b-520d-47a8-b2b9-7b1235351fc7.png)'
- en: 'The head node contains a `for` symbol. There are two arguments: the first one
    contains the expression about the loop and the second one contains a block expression.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点包含 `for` 符号。有两个参数：第一个包含关于循环的表达式，第二个包含一个块表达式。
- en: Function definition
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数定义
- en: 'Next, we will see the structure for a function definition. Consider the following
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到函数定义的结构。考虑以下代码：
- en: '![](img/414fcd55-6739-42d1-9f8c-a73f24b18e03.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/414fcd55-6739-42d1-9f8c-a73f24b18e03.png)'
- en: The head node contains a `function` symbol. Then, the first argument contains
    a `call` expression with the arguments. The second argument is just a block expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点包含 `function` 符号。然后，第一个参数包含一个带有参数的 `call` 表达式。第二个参数只是一个块表达式。
- en: The call expression may seem a little odd because we have seen a similar expression
    object when a function is being called. This is normal because we are currently
    working at the syntax level. The syntax for function definition is indeed quite
    similar to the function call itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 调用表达式可能看起来有点奇怪，因为我们之前在函数被调用时见过类似的表达式对象。这是正常的，因为我们目前处于语法层面。函数定义的语法确实与函数调用本身非常相似。
- en: By now, we have seen enough examples. There are obviously many more code constructs
    that we have not explored. You are encouraged to use the same technique to examine
    other code structures. Understanding how the abstract syntax tree is structured
    is essential to writing good metaprogramming code. Next, we will see how we can
    evaluate these expressions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经看到了足够的例子。显然，还有许多我们没有探索的代码结构。我们鼓励您使用相同的技巧来检查其他代码结构。理解抽象语法树的结构对于编写良好的元编程代码至关重要。接下来，我们将看到如何评估这些表达式。
- en: Evaluating expressions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估表达式
- en: We have looked at creating expression objects in great detail. But how are they
    useful? Remember that an expression object is just an abstract syntax tree representation
    of a Julia program. At this point, we can ask the compiler to continue translating
    the expression into executable code and then run the program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细地探讨了创建表达式对象的过程。但它们有什么用呢？记住，表达式对象只是 Julia 程序的抽象语法树表示。在这个阶段，我们可以要求编译器继续将表达式转换为可执行代码，然后运行程序。
- en: 'Expression objects can be evaluated by calling the `eval` function. Essentially,
    the Julia compiler will go through the rest of the compilation process and run
    the program. Now, let''s start a fresh, new REPL and run the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式对象可以通过调用 `eval` 函数来评估。本质上，Julia 编译器将完成剩余的编译过程并运行程序。现在，让我们启动一个新的、全新的 REPL
    并运行以下代码：
- en: '![](img/17f873d7-2181-40ed-8f15-3561552c254c.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17f873d7-2181-40ed-8f15-3561552c254c.png)'
- en: 'Clearly, it''s just a simple assignment. We can see that the `x` variable is
    now defined in the current environment:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这只是一个简单的赋值操作。我们可以看到，`x` 变量现在在当前环境中被定义了：
- en: '![](img/2f939154-52d6-4c29-9ac6-2aa74aa1b8ab.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f939154-52d6-4c29-9ac6-2aa74aa1b8ab.png)'
- en: 'Note that the evaluation of the expression actually happens in the global scope.
    We can prove this by running `eval` from within a function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表达式的评估实际上是在全局范围内进行的。我们可以通过在函数内部运行 `eval` 来证明这一点：
- en: '![](img/9c9b4f79-5bb2-49fb-95b0-ce8203eca8ca.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c9b4f79-5bb2-49fb-95b0-ce8203eca8ca.png)'
- en: This is not an unimportant observation! At first glance, we may have expected
    the `y` variable to be assigned inside the `foo` function; however, the variable
    assignment happened in the global scope instead, so the `y `variable was defined
    in the current environment as a side-effect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一项无关紧要的观察！乍一看，我们可能预计 `y` 变量将在 `foo` 函数内部被分配；然而，变量分配实际上是在全局范围内发生的，因此 `y` 变量作为副作用在当前环境中被定义。
- en: More precisely, the expression is evaluated in the current module. Since we
    are testing in the REPL, the evaluation was done in the current module, called
    `Main`. The expression is designed as such because `eval` is commonly used for
    code generation, which can be useful in defining variables or functions within
    the module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，表达式是在当前模块中评估的。由于我们在 REPL 中进行测试，评估是在名为 `Main` 的当前模块中完成的。表达式被设计成这样，因为 `eval`
    通常用于代码生成，这在定义模块内的变量或函数时可能很有用。
- en: Next, we will learn how to create expression objects more easily.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何更轻松地创建表达式对象。
- en: Interpolating variables in expressions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式中的变量插值
- en: 'It is quite simple to construct expressions from a quote block. But what if
    we want to dynamically create expressions? This can be done using *interpolation*,
    which allows us to insert variable values into the expression object with an easy
    syntax. Interpolation in an expression is very similar to the way that variables
    can be interpolated in a string. The following screenshot shows an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从引号块中构造表达式非常简单。但如果我们想动态创建表达式怎么办？这可以通过 *插值* 实现，它允许我们使用简单的语法将变量值插入到表达式对象中。表达式中的插值与变量可以在字符串中插值的方式非常相似。下面的截图显示了示例：
- en: '![](img/a7ee7ac3-b5bb-4833-bb32-5c414bc69998.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7ee7ac3-b5bb-4833-bb32-5c414bc69998.png)'
- en: 'As expected, the value of `2` is correctly substituted in the expression. Note
    that `splatting` is also supported, as shown below:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`2` 的值在表达式中被正确替换。请注意，`splatting` 也得到了支持，如下所示：
- en: '![](img/75b2ee1c-6976-4c3b-adb1-22cb55363682.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75b2ee1c-6976-4c3b-adb1-22cb55363682.png)'
- en: 'We must make sure that the variable that includes the `splatting` operator
    is interpolated in this case. If we had forgotten to put the parentheses around `v...`,
    then we would have had a very different result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保包含散列操作符的变量在这种情况下被插值。如果我们忘记在 `v...` 周围放置括号，那么我们会得到一个非常不同的结果：
- en: '![](img/9255e775-c7f4-4b94-87a4-984720944cd3.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9255e775-c7f4-4b94-87a4-984720944cd3.png)'
- en: Here, splatting does not actually occur during interpolation into the expression.
    Instead, the splatting operator now becomes part of the expression, so splatting
    will not occur until the expression is evaluated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，散列操作实际上并没有在表达式插值过程中发生。相反，散列操作符现在成为表达式的一部分，因此散列操作将不会发生，直到表达式被评估。
- en: The order of precedence in an expression such as `$v...` is somewhat unclear.
    Is the `v` variable bound to the interpolation operation before or after the splatting
    operation? In a situation like this, it is best to use parentheses around whatever
    we want to interpolate. As we want the interpolation to happen fully, the syntax
    should be `$(v...)`. In situations where splatting needs to happen at runtime,
    we could write `$(v)...` instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在如 `$v...` 这样的表达式中，优先级顺序有些不清楚。`v` 变量是在散列操作之前还是之后绑定到插值操作的？在这种情况下，最好在我们想要插值的内容周围使用括号。因为我们希望插值完全发生，语法应该是
    `$(v...)`。在需要运行时进行散列操作的情况下，我们可以写成 `$(v)...`。
- en: Interpolation is an important concept for writing macros. We will see more of
    its usage later in this chapter. Next, we will see how to handle construct expressions
    with symbol values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是编写宏的重要概念。我们将在本章后面看到更多关于它的用法。接下来，我们将看到如何处理具有符号值的表达式。
- en: Using QuoteNode for symbols
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 QuoteNode 为符号构造表达式
- en: 'Symbols are quite special when they appear in expressions. They may appear
    in the head node of an expression object—for example, the `=` symbol in a variable
    assignment expression. They may also appear in the arguments of an expression
    object, in which case they would represent a variable:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 符号在表达式中出现时非常特殊。它们可能出现在表达式对象的头部节点中——例如，变量赋值表达式中的 `=` 符号。它们也可能出现在表达式对象的参数中，在这种情况下，它们将代表一个变量：
- en: '![](img/1c7ec2aa-3be8-4c3f-ac06-4e424e1c7886.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c7ec2aa-3be8-4c3f-ac06-4e424e1c7886.png)'
- en: 'Since symbols are already used to represent variables, how would we assign
    an actual symbol to a variable? To figure out how this works, we can use the same
    trick that we have learned so far—using the `dump` function to examine the expression
    object for such a statement:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于符号已经用来表示变量，我们如何将一个实际的符号赋给一个变量呢？为了弄清楚这是如何工作的，我们可以使用我们迄今为止学到的一个技巧——使用 `dump`
    函数来检查表达式对象中的此类语句：
- en: '![](img/a6c583b4-4c64-4073-98fa-4fe8ceba0885.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6c583b4-4c64-4073-98fa-4fe8ceba0885.png)'
- en: 'As we can see, an actual symbol must be enclosed in a `QuoteNode` object. Now
    that we know what is needed, we should try to interpolate an actual symbol into
    an expression object. The way to achieve this is to create a `QuoteNode` object
    manually and use the interpolation technique as usual:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，一个实际的符号必须被包含在 `QuoteNode` 对象中。现在我们知道了需要什么，我们应该尝试将一个实际的符号插值到表达式对象中。实现这一目标的方法是手动创建一个
    `QuoteNode` 对象，并像往常一样使用插值技术：
- en: '![](img/275de7a3-11a7-409e-abc3-af1a49d9f12d.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/275de7a3-11a7-409e-abc3-af1a49d9f12d.png)'
- en: 'A common mistake is when you forget to create `QuoteNode`. In this case, the
    expression object will misinterpret the symbol and treat it as a variable reference.
    Obviously, the result is very different, and it will not work properly:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是忘记创建 `QuoteNode`。在这种情况下，表达式对象将错误地解释符号，并将其视为变量引用。显然，结果非常不同，并且它将无法正常工作：
- en: '![](img/0512ee43-2e07-4147-8a89-43eaec212d3f.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0512ee43-2e07-4147-8a89-43eaec212d3f.png)'
- en: Not using `QuoteNode` would generate code that assigns the value of one variable
    to another. In this case, the variable `x` will be assigned with a value from
    variable `hello`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 `QuoteNode` 会生成将一个变量的值赋给另一个变量的代码。在这种情况下，变量 `x` 将被赋予来自变量 `hello` 的一个值。
- en: Understanding how `QuoteNode` works is essential creating expressions on the
    fly. It is common for programmers to interpolate symbols into an existing expression.
    So next, we will look at how to work with nested expressions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `QuoteNode` 的工作原理对于动态创建表达式至关重要。程序员将符号插值到现有表达式中是很常见的。因此，接下来我们将探讨如何处理嵌套表达式。
- en: Interpolating in nested expressions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在嵌套表达式中进行插值
- en: It is possible to have a quoted expression that contains another quoted expression.
    This is not a very common practice, unless the programmer needs to write meta-metaprograms.
    Nonetheless, we should still learn about how to interpolate in such a situation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能存在一个包含另一个引用表达式的引用表达式。除非程序员需要编写元元程序，否则这不是一个常见的做法。尽管如此，我们仍然应该了解如何在这样的情况下进行插值。
- en: 'First, let''s recap what a single-level expression looks like:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下单层表达式的样子：
- en: '![](img/b444be5d-ede6-48ae-b0c6-4812746ec43a.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b444be5d-ede6-48ae-b0c6-4812746ec43a.png)'
- en: 'We can wrap the quoted expression with another quote block in order to see
    what the structure of a nested expression looks like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将引用表达式包裹在另一个引用块中来查看嵌套表达式的结构：
- en: '![](img/66fd29be-2aae-47aa-b9cb-66c5b7922161.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66fd29be-2aae-47aa-b9cb-66c5b7922161.png)'
- en: 'Now, let''s try to interpolate in such an expression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在这样的表达式中进行插值：
- en: '![](img/66f6f2ba-72a7-42cd-81cc-55044b3cb6c1.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66f6f2ba-72a7-42cd-81cc-55044b3cb6c1.png)'
- en: 'As we can see, the `2` value did not get into the expression. The expression
    structure is also entirely different from what we had expected. The solution is
    to just interpolate the variable twice instead by using two `$` signs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`2` 值并没有进入表达式。表达式的结构也完全不同于我们预期的。解决方案是只需通过使用两个 `$` 符号将变量插值两次：
- en: '![](img/a5e4a9dc-2791-420c-add4-66a44d7b29cb.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5e4a9dc-2791-420c-add4-66a44d7b29cb.png)'
- en: In general, it is probably not much fun to interpolate more than one-level deep
    as the logic becomes difficult to work out. It can be useful, however, if you
    need to generate code for macros. I would definitely not suggest that you go more
    than two-levels deep and write meta-meta-metaprograms!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，插值超过一层深度可能不是很有趣，因为逻辑变得难以处理。然而，如果你需要为宏生成代码，这可能是有用的。我绝对不建议你超过两层深度并编写元元元程序！
- en: By now, you should be more familiar with, and comfortable working with, expressions.
    From the Julia REPL, it is quite easy to see how an expression is structured as
    represented as an `Expr` object. You should be able to construct new expressions
    and interpolate values inside; these are essential skills that will be required
    for metaprogramming.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对表达式更加熟悉，并且能够舒适地与之工作。从Julia的REPL中，很容易看到表达式是如何作为`Expr`对象来表示的结构的。你应该能够构造新的表达式并在其中插值值；这些是进行元编程所必需的基本技能。
- en: In the next section, we will look into a powerful metaprogramming feature in
    Julia—macros.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Julia中一个强大的元编程特性——宏。
- en: Developing macros
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发宏
- en: Now that we understand how source code is represented as abstract syntax trees,
    we can start doing more interesting things by writing macros. In this section,
    we will learn what macros are and how to work with them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了源代码是如何表示为抽象语法树的，我们可以通过编写宏来开始做一些更有趣的事情。在本节中，我们将学习宏是什么以及如何与之工作。
- en: What are macros?
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏是什么？
- en: 'Macros are functions that accept expressions, manipulate them, and return a
    new expression. This is best understood with a diagram:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是接受表达式、操作它们并返回新表达式的函数。这最好通过一个图表来理解：
- en: '![](img/f4271853-2e8b-4a47-bd13-28ecf8126b60.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4271853-2e8b-4a47-bd13-28ecf8126b60.png)'
- en: As we know, expressions are just abstract syntax tree representations of source
    code. So the macro facility in Julia allows you to take any source code and generate
    new source code. The resulting expression is then executed as if the source code
    was written directly in place.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，表达式只是源代码的抽象语法树表示。因此，Julia中的宏功能允许你取任何源代码并生成新的源代码。然后，生成的表达式就像源代码直接在原地编写一样被执行。
- en: At this point, you may wonder why we cannot use regular functions to achieve
    the same thing. Why could we not write a function that takes expressions, generates
    a new expression, and then executes the resulting expression?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道为什么我们不能使用常规函数来实现相同的事情。为什么我们不能编写一个接受表达式、生成新表达式然后执行结果的函数？
- en: 'There are two main reasons:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要原因：
- en: Macro expansion happens during compilation. This means that the macro is only
    executed once from where it is used—for example, when a macro is called from a
    function, the macro is executed at the time that the function is defined so that
    the function can be compiled.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏扩展发生在编译期间。这意味着宏只从它被使用的地方执行一次——例如，当宏从一个函数中调用时，宏是在函数定义时执行的，以便函数可以被编译。
- en: The resulting expression from a macro can be executed within the current scope.
    At runtime, there is no other way to execute any dynamic code within the function
    itself because the function, by definition, is already compiled. So, the only
    way to evaluate any expression is to do so in the global scope.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏生成的表达式可以在当前作用域内执行。在运行时，由于函数本身已经编译，没有其他方法可以在函数内部执行任何动态代码。所以，评估任何表达式的唯一方法是在全局作用域内进行。
- en: By the end of this chapter, you should have a better understanding of how macros
    work and how they differ from functions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对宏的工作原理以及它们与函数的不同之处有更好的理解。
- en: As we now understand what macros are, we will now continue our journey by writing
    our first macro.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在已经理解了宏是什么，我们将继续我们的旅程，编写我们的第一个宏。
- en: Writing our first macro
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个宏
- en: Macros are defined in a similar way to how functions are defined, except that
    the `macro` keyword is used instead of the `function` keyword.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的定义方式与函数的定义方式类似，只是使用`macro`关键字而不是`function`关键字。
- en: 'We should also keep in mind that a macro must return expressions. Let''s create
    our first macro. This macro returns an expression object that contains a `for`
    loop, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该记住，一个宏必须返回表达式。让我们创建我们的第一个宏。这个宏返回一个包含`for`循环的表达式对象，如下所示：
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Invoking the macro is as easy as calling it with the `@` prefix. Refer to the
    following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 调用宏就像用`@`前缀调用它一样简单。请参考以下代码：
- en: '![](img/6b105cfd-4a31-4b85-b470-e9881e4bcb9f.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b105cfd-4a31-4b85-b470-e9881e4bcb9f.png)'
- en: 'Unlike functions, macros may be called without using parentheses. So we can
    just do the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数不同，宏可以在不使用括号的情况下调用。所以我们可以这样做：
- en: '![](img/43c8a997-9b9a-4fbc-90f8-d1ed60c47f33.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43c8a997-9b9a-4fbc-90f8-d1ed60c47f33.png)'
- en: '*Fantastic!* We have now written our first macro. While it does not look very
    exciting, because the code being generated is just a static piece of code, we
    have learned how to define macros and run them.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*太棒了!* 我们现在已经编写了我们的第一个宏。虽然它看起来并不非常令人兴奋，因为生成的代码只是一段静态的代码，但我们已经学会了如何定义宏并运行它们。'
- en: Next, we will learn how to pass arguments to macros.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何向宏传递参数。
- en: Passing literal arguments
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递字面量参数
- en: Just like functions, macros can also take arguments. In fact, taking an argument
    is the most common occurrence for a macro. The simplest type of argument is literals,
    such as numbers, symbols, and strings.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，宏也可以接受参数。实际上，接受参数是宏最常见的用法。最简单的参数类型是字面量，例如数字、符号和字符串。
- en: 'In order to utilize these arguments in the returned expression, we can use
    the interpolation technique that we learned in the last section. Consider the
    following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在返回的表达式中利用这些参数，我们可以使用我们在上一节中学到的插值技术。考虑以下代码：
- en: '[PRE7]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `hello` macro takes a single argument, `n`, which is interpolated into
    the expression when the macro is run. As before, we can just invoke the macro
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello`宏接受一个参数，`n`，当宏运行时，这个参数会被插入到表达式中。像之前一样，我们可以这样调用宏：'
- en: '![](img/e76e0851-af2d-4280-8c53-ee71cb64a788.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e76e0851-af2d-4280-8c53-ee71cb64a788.png)'
- en: 'As we learned earlier, parentheses are not required, so we can also call the
    macro as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，括号不是必需的，因此我们也可以这样调用宏：
- en: '![](img/39aae576-f8b8-446e-ba2d-4a4729444b62.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39aae576-f8b8-446e-ba2d-4a4729444b62.png)'
- en: You can try a similar exercise with string or symbol arguments. Passing literals
    is easy to understand because it works in the same way as functions. But there
    is indeed a subtle difference between macros and functions, which we will discuss
    in detail in the following section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用字符串或符号参数尝试类似的练习。传递字面量很容易理解，因为它与函数的工作方式相同。但宏和函数之间确实存在细微的差别，我们将在下一节中详细讨论。
- en: Passing expression arguments
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递表达式参数
- en: It is important to emphasize that macro arguments are passed as expressions
    rather than values. It may look confusing for beginners because macros are invoked
    similarly to functions, but the behavior is completely different.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调，宏参数是以表达式而不是值的形式传递的。对于初学者来说，这可能会看起来有些混乱，因为宏的调用方式与函数相似，但行为完全不同。
- en: 'Let''s make sure that we fully understand what this means. When calling a function
    with a variable, the value of the variable is passed into the function. Consider
    the following sample code for a `showme` function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们完全理解这意味着什么。当用一个变量调用一个函数时，变量的值会被传递到函数中。考虑以下`showme`函数的示例代码：
- en: '![](img/f84cffba-eb41-4aaa-a648-3f09ece404b1.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f84cffba-eb41-4aaa-a648-3f09ece404b1.png)'
- en: 'Now, let''s create a `@showme` macro that does nothing but display the argument
    in the console. We can then compare the results with the preceding code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`@showme`宏，它除了在控制台显示参数外，不做任何事情。然后我们可以将结果与前面的代码进行比较：
- en: '![](img/a7cf9700-6cee-4fda-8a7c-7b0964b53d18.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7cf9700-6cee-4fda-8a7c-7b0964b53d18.png)'
- en: As we can see, the results from running a macro are totally different than those
    we get from calling a function. The function argument `x` really only sees an
    expression from where the macro was called. From the diagram at the beginning
    of this section, we can see that macros are supposed to take in expressions and
    return a single expression as a result. They do not know the value of the arguments
    as they work at the syntax level.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，运行宏的结果与调用函数得到的结果完全不同。函数参数`x`实际上只看到了宏被调用处的表达式。从本节开头的图中，我们可以看到宏应该接受表达式并返回一个单一的表达式作为结果。它们在语法层面上工作，不知道参数的值。
- en: As we will see in the next section, expressions can even be manipulated when
    the macro is run. Let's go!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在下一节中将要看到的，当宏运行时，表达式甚至可以被操作。让我们开始吧！
- en: Understanding the macro expansion process
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解宏展开过程
- en: 'By convention, every macro must return an expression. The process of taking
    one or more expressions and returning a new one is called **macro expansion**.
    Sometimes, it helps to see the expression being returned without actually running
    the code. We can use the `@macroexpand` macro for that purpose. Let''s try to
    use it for the `@hello` macro that we defined earlier in this section:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，每个宏都必须返回一个表达式。从一个或多个表达式取值并返回一个新的表达式的过程被称为**宏展开**。有时，看到返回的表达式而不实际运行代码是有帮助的。我们可以使用`@macroexpand`宏来达到这个目的。让我们尝试使用它来处理我们在这节中之前定义的`@hello`宏：
- en: '![](img/289780c8-b7d0-4570-924a-9099604360f9.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/289780c8-b7d0-4570-924a-9099604360f9.png)'
- en: 'There are several things to note from this output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，有几个需要注意的事项：
- en: The `i` variable was renamed rather oddly: `#67#i`. This is done by the Julia
    compiler to ensure *hygiene*, which we will discuss later in this chapter. Macro
    hygiene is an important characteristic to keep in mind so that the code being
    generated does not conflict with other code.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`变量被非常奇怪地重命名为`#67#i`。这是Julia编译器为了确保*卫生性*而做的，我们将在本章后面讨论。宏的卫生性是一个需要记住的重要特性，以确保生成的代码不会与其他代码冲突。'
- en: A comment was inserted into the loop that contains source file and line number
    information. This is a useful part of the expression when a debugger is used.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包含源文件和行号信息的循环中插入了一条注释。当使用调试器时，这是表达式的一个有用部分。
- en: The function call to `println` is bound to the one in the current environment,
    `Main`. This make sense because `println` is part of the `Core` package and is
    automatically brought into scope for every Julia program.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`println`的函数调用绑定到当前环境中的`Main`。这很有意义，因为`println`是`Core`包的一部分，并且对于每个Julia程序都会自动引入作用域。
- en: So when does macro expansion happen? Let's go over that next.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，宏展开何时发生？让我们接下来讨论这个问题。
- en: Timing of macro expansion
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏展开的时机
- en: In the REPL, any macro is expanded as soon as we invoke it. Interestingly, when
    a function containing the macro is defined, the macro is expanded as part of the
    function definition process.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中，任何宏在我们调用它时都会立即展开。有趣的是，当定义包含宏的函数时，宏作为函数定义过程的一部分被展开。
- en: 'We can see this in action by developing a simple `@identity` macro that returns
    whatever expression is passed into it. Right before the expression is returned,
    we just `dump` the object to the screen. The code for the `@identity` macro is
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过开发一个简单的返回传递给它的任何表达式的`@identity`宏来看到这一点。在表达式返回之前，我们只是将对象`dump`到屏幕上。`@identity`宏的代码如下：
- en: '[PRE8]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since this macro returns the same expression that was passed, it should end
    up executing the original source code that follows the macro.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个宏返回了传递给它的相同的表达式，它最终应该执行宏后面的原始源代码。
- en: 'Now, let''s define a function that uses the `@identity` macro:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个使用`@identity`宏的函数：
- en: '![](img/ffe1dd38-680b-4965-a37f-c859e78a5b51.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ffe1dd38-680b-4965-a37f-c859e78a5b51.png)'
- en: Clearly, the compiler has figured out that the macro is being used in the definition
    of the `foo` function and, in order to compile the `foo` function, it must understand
    what the `@identity` macro does. So it expanded the macro and baked that into
    the function definition. During the macro expansion process, the expression was
    displayed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，编译器已经发现宏被用于`foo`函数的定义中，为了编译`foo`函数，它必须理解`@identity`宏的作用。因此，它展开了宏，并将其嵌入到函数定义中。在宏展开过程中，表达式被显示出来。
- en: 'If we use the `@code_lowered` macro against the `foo` function, we can see
    that the expanded code is now in the body of the `foo` function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对`foo`函数使用`@code_lowered`宏，我们可以看到展开的代码现在位于`foo`函数的主体中：
- en: '![](img/7815efe2-61fe-478f-9a07-a9abfb5319a2.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7815efe2-61fe-478f-9a07-a9abfb5319a2.png)'
- en: During development, the programmer may change the definitions of functions,
    macros, and so on frequently. Because macros are expanded when functions are defined,
    it is important to redefine the function again if any of the macros being used
    have been changed; otherwise, the function may continue to use the code generated
    from the prior macro definition.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，程序员可能会频繁地更改函数、宏等的定义。因为宏在定义函数时会被展开，所以如果使用的任何宏被更改，重新定义函数就很重要；否则，函数可能会继续使用先前宏定义生成的代码。
- en: The `@macroexpand` utility is an indispensable tool for developing macros, and
    in particular, is most useful for debugging purposes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`@macroexpand`实用工具是开发宏不可或缺的工具，特别是对于调试目的非常有用。'
- en: Next, we will try to be a little more creative by manipulating expressions in
    macros.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试通过在宏中操作表达式来更加有创意。
- en: Manipulating expressions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作表达式
- en: Macros are powerful because they allow expressions to be manipulated during
    the macro expansion process. This is a tremendously useful technique, especially
    for code generation and designing domain-specific languages. Let's go over some
    examples to get a taste of what is possible.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 宏之所以强大，是因为它们允许在宏展开过程中操作表达式。这是一种非常有用的技术，尤其是在代码生成和设计领域特定语言时。让我们通过一些示例来了解可能实现的内容。
- en: Example 1 – Making a new expression
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 1 – 创建新的表达式
- en: 'Let''s start with a simple one. Suppose that we want to create a macro called
    `@squared` that takes an expression and just squares it. In other words, if we
    run `@squared(x)`, then it should be translated into `x * x`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始。假设我们想要创建一个名为 `@squared` 的宏，它接受一个表达式并将其平方。换句话说，如果我们运行 `@squared(x)`，那么它应该被翻译成
    `x * x`：
- en: '[PRE9]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At first glance, it seems to work fine when we run it from the REPL:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，当我们从 REPL 运行它时，它似乎工作得很好：
- en: '![](img/0497020c-1f39-47af-a3da-366abf4482ef.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0497020c-1f39-47af-a3da-366abf4482ef.png)'
- en: 'But this macro has a problem with the execution context. The best way to illustrate
    the problem is by defining a function that uses the macro. So let''s define a `foo`
    function, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个宏在执行上下文方面存在问题。最好的说明问题的方式是定义一个使用该宏的函数。所以让我们定义一个 `foo` 函数，如下所示：
- en: '[PRE10]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when we call the function, we get the following error:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们调用该函数时，我们得到以下错误：
- en: '![](img/0481fc86-f878-46b4-867e-4aee1e845c32.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0481fc86-f878-46b4-867e-4aee1e845c32.png)'
- en: 'Why is that? It is because, during the macro expansion, the `x` symbol refers
    to the variable in the module rather than the local variable in the `foo` function.
    We can confirm this by using the `@code_lowered` macro:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？这是因为，在宏展开期间，`x` 符号指的是模块中的变量，而不是 `foo` 函数中的局部变量。我们可以通过使用 `@code_lowered`
    宏来确认这一点：
- en: '![](img/500c7a34-0f8b-4747-8811-56f00eed2e5e.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/500c7a34-0f8b-4747-8811-56f00eed2e5e.png)'
- en: 'Obviously, our intention was to square the local `x` variable rather than `Main.x`.
    The easy fix to this problem is to use the `esc` function during interpolation
    in order to place the expression directly in the syntax tree without letting the
    compiler resolve it. The following is how it can be done:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的意图是平方局部 `x` 变量，而不是 `Main.x`。解决这个问题的一个简单方法是，在插值时使用 `esc` 函数，以便将表达式直接放入语法树中，而不让编译器解析它。以下是如何做到这一点的方法：
- en: '[PRE11]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since the macro was expanded earlier, before `foo` was defined, we need to
    define the `foo` function once again, as follows, for this updated macro to take
    effect. Alternatively, you can start a new REPL and define the `@squared` macro
    and `foo` function again. Here we go:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宏是在 `foo` 定义之前展开的，我们需要再次定义 `foo` 函数，如下所示，以便这个更新的宏生效。或者，您也可以启动一个新的 REPL，并再次定义
    `@squared` 宏和 `foo` 函数。下面是操作步骤：
- en: '![](img/6cb9a817-8915-4ea2-ba6b-2cb0e2158dc5.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cb9a817-8915-4ea2-ba6b-2cb0e2158dc5.png)'
- en: The `foo` function works correctly now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `foo` 函数工作正常了。
- en: From this example, we have learned how to create a new expression using the
    interpolation technique. We have also learned that the interpolated variable needs
    to be escaped using the `esc` function to avoid it being resolved by the compiler
    to the global scope.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们学习了如何使用插值技术创建新的表达式。我们还了解到，插值变量需要使用 `esc` 函数进行转义，以避免编译器将其解析为全局作用域。
- en: Example 2 - Tweaking the abstract syntax tree
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 2 - 调整抽象语法树
- en: Let's say we want to design a macro called `@compose_twice` that takes a simple
    function call expression and calls the same function again with the result—for
    example, if we run `@compose_twice sin(x)`, then it should be translated to `sin(sin(x))`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要设计一个名为 `@compose_twice` 的宏，它接受一个简单的函数调用表达式，并再次以结果调用相同的函数——例如，如果我们运行 `@compose_twice
    sin(x)`，那么它应该被翻译成 `sin(sin(x))`。
- en: 'Before we write the macro, let''s first get familiar with the abstract syntax
    tree of the expression:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写宏之前，让我们首先熟悉一下表达式的抽象语法树：
- en: '![](img/664d8b6d-80b2-459e-bbfe-9ae14e9ac4d2.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/664d8b6d-80b2-459e-bbfe-9ae14e9ac4d2.png)'
- en: 'How does it look for `sin(sin(x))`? Refer to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`sin(sin(x))` 的样子如何？请参考以下内容：'
- en: '![](img/7e9871e0-6b20-4997-8674-ee2e84f80a5d.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e9871e0-6b20-4997-8674-ee2e84f80a5d.png)'
- en: No surprise here. The second argument of the top-level call is just another
    expression that looks like what we saw previously.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜。顶层调用的第二个参数只是另一个看起来与我们之前看到的样子一样的表达式。
- en: 'We can write the macro as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式编写宏：
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first two `@assert` statements are used to ensure that the expression represents
    a function call that takes a single argument. As we want to replace the argument
    with a similar expression, we just make a copy of the current expression object
    and assign it to `ex.args[2]`. The macro then returns the resulting expression
    for evaluation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个 `@assert` 语句用于确保表达式代表一个接受单个参数的函数调用。由于我们想用类似的表达式替换参数，我们只需复制当前表达式对象并将其分配给
    `ex.args[2]`。然后宏返回用于评估的结果表达式。
- en: 'We can verify that the macro is working correctly:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证宏是否工作正常：
- en: '![](img/7ed701a3-07c2-4ca7-a172-b20b41a87a65.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ed701a3-07c2-4ca7-a172-b20b41a87a65.png)'
- en: As you can see, we can translate the source code by manipulating the abstract
    syntax tree directly rather than interpolating variables into a nice-looking expression.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以通过直接操作抽象语法树来转换源代码，而不是将变量插值到看起来很棒的表达式中。
- en: By now, you can probably appreciate the power of metaprogramming. Compared to
    using interpolation, manipulating an expression directly is not as easy to understand
    because the resulting expression is not represented in the code; however, the
    ability to manipulate expressions provides the ultimate flexibility in translating
    source code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经体会到了元编程的强大之处。与使用插值相比，直接操作表达式并不容易理解，因为生成的表达式并没有在代码中表示；然而，操作表达式的能力为转换源代码提供了最大的灵活性。
- en: Next up, we will go over an important feature of metaprogramming—macro hygiene.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍元编程的一个重要特性——宏的卫生性。
- en: Understanding macro hygiene
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解宏的卫生性
- en: Macro hygiene refers to the ability to keep macro-generated code clean. It is
    referred to as hygiene because the generated code does not get polluted by other
    parts of the code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的卫生性指的是保持宏生成代码清洁的能力。它被称为卫生性，因为生成的代码不会受到其他代码部分的影响。
- en: 'Note that many other programming languages do not provide such a guarantee.
    The following is a C program that contains a macro called `SWAP`, which is used
    to exchange the value of two variables:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到许多其他编程语言并不提供这样的保证。以下是一个包含名为`SWAP`的宏的 C 程序，该宏用于交换两个变量的值：
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, running this C program yields an incorrect result:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行这个 C 程序会产生一个错误的结果：
- en: '![](img/8c89d315-9273-4b0a-b9a1-6a032a9c5cc6.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c89d315-9273-4b0a-b9a1-6a032a9c5cc6.png)'
- en: It did not swap the `a` and `temp` variables properly because the `temp` variable is
    also used as a temporary variable in the body of the macro.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有正确地交换`a`和`temp`变量，因为`temp`变量也在宏的主体中用作临时变量。
- en: 'Let''s go back to Julia. Consider the following macro, which just runs an `ex` expression and
    repeats it `n` times:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 Julia。考虑以下宏，它只是运行一个`ex`表达式，并重复`n`次：
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since the `times` variable is used in the returned expression, what would happen
    if the same variable name is already used in the call site? Let''s try this sample
    code, which defines a `times` variable before the macro call and prints the value
    of the same variable after the macro call:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`times`变量用于返回的表达式中，如果调用点已经使用了相同的变量名，会发生什么？让我们尝试以下示例代码，它在宏调用之前定义了一个`times`变量，并在宏调用之后打印相同变量的值：
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the macro expander took it literally, then the `times` variable would be
    modified to `3` after the macro call; however, we can see it working properly
    in the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果宏展开器将其字面地处理，那么在宏调用之后`times`变量将被修改为`3`；然而，我们可以在以下代码中看到它正常工作：
- en: '![](img/69356a2f-70f7-4981-98df-dcc7d1f77cc5.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69356a2f-70f7-4981-98df-dcc7d1f77cc5.png)'
- en: 'It works because the macro system is able to maintain hygiene by renaming the
    `times` variable to something different so that there is no conflict. Where is
    the magic? Well, let''s take a look at the expanded code using `@macroexpand`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它之所以能工作，是因为宏系统能够通过将`times`变量重命名为不同的名称来保持卫生性，从而避免冲突。魔法在哪里？让我们通过使用`@macroexpand`查看展开的代码：
- en: '![](img/07a64213-e13d-4060-aa22-8546322f2124.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07a64213-e13d-4060-aa22-8546322f2124.png)'
- en: Here, we can see that the `times` variable has turned into `#44#times`. The
    loop variable `i` has also turned into `#45#i`. These variable names are dynamically
    generated by the compiler to ensure that macro-generated code does not conflict
    with other user-written code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`times`变量已经变成了`#44#times`。循环变量`i`也变成了`#45#i`。这些变量名是由编译器动态生成的，以确保宏生成的代码不会与其他用户编写的代码冲突。
- en: 'Macro hygiene is an essential feature for macros to function correctly. There
    is nothing that the programmer needs to do: Julia automatically provides the guarantee.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的卫生性是宏正确运行的一个基本特性。程序员不需要做任何事情：Julia 自动提供保证。
- en: Next, we will look into a different kind of macro that powers nonstandard string
    literals.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一种不同类型的宏，它为非标准字符串字面量提供动力。
- en: Developing nonstandard string literals
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发非标准字符串字面量
- en: There is a special kind of macro for defining nonstandard string literals, which
    look like a literal string but instead a macro is called when it is referenced.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的宏用于定义非标准字符串字面量，它们看起来像字面量字符串，但在引用时实际上会调用一个宏。
- en: 'A good example would be Julia''s regular expression literal—for example, `r"^hello"`.
    It is not a standard string literal because of the `r` prefix in front of the
    double quote. Let''s first check the data type of such a literal. We can see that a `Regex` object
    is created from the string:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好例子是 Julia 的正则表达式字面量——例如，`r"^hello"`。由于双引号前的 `r` 前缀，它不是一个标准的字符串字面量。让我们首先检查这种字面量的数据类型。我们可以看到，从字符串创建了一个
    `Regex` 对象：
- en: '![](img/66d4c40a-9654-4c61-84c8-74f090383aad.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66d4c40a-9654-4c61-84c8-74f090383aad.png)'
- en: We can also create our own nonstandard string literals. Let's try to work through
    a fun example together here.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建自己的非标准字符串字面量。让我们在这里一起尝试一个有趣的例子。
- en: 'Suppose that, for development purposes, we want to conveniently create sample
    data frames with different types of columns. The syntax for doing so is a little
    bit tedious:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，为了开发目的，我们想要方便地创建具有不同类型列的样本数据帧。这样做的方法有点繁琐：
- en: '![](img/91855e88-e2b9-40e7-8e6d-758a223a67c0.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91855e88-e2b9-40e7-8e6d-758a223a67c0.png)'
- en: Imagine that we occasionally need to create tens of columns with different data
    types. The code for creating such a data frame would be very long, and as a programmer,
    I would be extremely bored typing that all out. So we could design a string literal
    so that it contains the specification for constructing such a data frame—let's
    call it a `ndf` (numerical data frame) literal.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们偶尔需要创建具有不同数据类型的数十列。创建此类数据帧的代码会非常长，作为一个程序员，我会在输入所有这些时感到极其无聊。因此，我们可以设计一个字符串字面量，使其包含构建此类数据帧的规范——让我们称它为
    `ndf`（数值数据帧）字面量。
- en: The specification on `ndf` just needs to encode the desired number of rows and
    column types. For instance, the literal `ndf"100000:f64,i16"` can be used to represent
    the preceding sample data frame, where 100,000 rows are needed, with two columns
    labeled as the `Float64` and `Int16` columns.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndf` 的规范只需编码所需的行数和列类型。例如，字面量 `ndf"100000:f64,i16"` 可以用来表示前面的样本数据帧，其中需要 100,000
    行，有两列分别标记为 `Float64` 和 `Int16` 列。'
- en: 'To implement this feature, we just define a macro called `@ndf_str`. The macro
    takes a string literal and creates the desired data frame accordingly. The following
    is one way to implement the macro:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，我们只需定义一个名为 `@ndf_str` 的宏。该宏接受一个字符串字面量并相应地创建所需的数据帧。以下是一种实现宏的方法：
- en: '[PRE16]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first few lines parse the string and determine the number of rows (`n`),
    as well as the types of the columns (`types`). Then, a dictionary called `mappings`
    is created to map the shorthand to the corresponding numeric types. The column
    names and types are generated from the type and mapping data. Finally, it calls
    the `DataFrame` constructor and returns the result.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行解析字符串并确定行数（`n`），以及列的类型（`types`）。然后，创建一个名为 `mappings` 的字典来将缩写映射到相应的数值类型。列名和类型从类型和映射数据生成。最后，它调用
    `DataFrame` 构造函数并返回结果。
- en: 'Now that we have the macro defined, we can easily create new data frames, as
    follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了宏，我们可以轻松地创建新的数据帧，如下所示：
- en: '![](img/26cacfc8-c5ab-431b-977a-b38b526a1447.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26cacfc8-c5ab-431b-977a-b38b526a1447.png)'
- en: Nonstandard string literals can be quite useful in certain cases. We can see
    a string specification as a mini domain-specific language that is encoded in the
    string. As long as the string specification is well defined, it can make the code
    a lot shorter and more concise.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 非标准字符串字面量在特定情况下非常有用。我们可以将字符串规范视为编码在字符串中的迷你领域特定语言。只要字符串规范定义良好，它可以使代码更短、更简洁。
- en: You may have noticed that the `ndf_str` macro returns a regular `DataFrame`
    object rather than an expression object, as it would normally do with macros.
    This is perfectly fine because the final `DataFrame` object will be returned as-is.
    You may think of an evaluation of a constant as just the constant itself. We can
    just return a value rather than an expression here because the returned value
    does not involve any variables from the call site or from the module.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`ndf_str` 宏返回一个常规的 `DataFrame` 对象，而不是通常宏会返回的表达式对象。这是完全可以的，因为最终的 `DataFrame`
    对象将按原样返回。你可能认为常量的评估只是常量本身。我们在这里可以只返回一个值而不是表达式，因为返回的值不涉及调用点或模块中的任何变量。
- en: A curious mind might ask - why can't we just create a regular function for this?
    We can certainly do that for this dummy example. However, using a string literal
    could improve performance in some cases.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好奇的头脑可能会问——为什么我们不能只为这个例子创建一个常规函数呢？我们当然可以为此虚拟示例做这件事。然而，使用字符串字面量在某些情况下可能会提高性能。
- en: For example, when we use the Regex string literal in a function, the `Regex`
    object is created at compile-time and so it is executed only once. If we use the `Regex`
    constructor instead, then the object would be created every single time the function
    is called.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们在一个函数中使用正则表达式字符串字面量时，`Regex`对象是在编译时创建的，因此它只执行一次。如果我们使用`Regex`构造函数，那么对象会在每次函数调用时创建。
- en: We have now concluded the topic of macros. We learned how to create macros by
    taking expressions and generating a new expression. We used the `@macroexpand`
    macro to debug the macro expansion process. We also learned how to handle macro
    hygiene. Finally, we took a look at nonstandard string literals and created our
    own using a macro.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经结束了关于宏的主题。我们学习了如何通过取表达式并生成一个新的表达式来创建宏。我们使用了`@macroexpand`宏来调试宏展开过程。我们还学习了如何处理宏的卫生问题。最后，我们查看了一下非标准字符串字面量，并使用宏创建了我们的自定义字符串字面量。
- en: Next, we will look at another metaprogramming facility called generated functions,
    which can be used to solve a different kind of problem than what regular macros
    can handle.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨另一个元编程功能，称为生成函数，它可以用来解决常规宏无法处理的不同类型的问题。
- en: Using generated functions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成函数
- en: So far, we have explained how to create macros that return expression objects.
    Since macros work at the syntax level, they can manipulate code only by examining
    how it *looks*. However, Julia is a dynamic system where data types are determined
    at runtime. For that reason, Julia provides the ability to create **generated
    functions**, which allow you to examine data types for a function call and return
    an expression, just like macros. When an expression is returned, it will be evaluated
    at the call site.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了如何创建返回表达式对象的宏。由于宏在语法级别工作，它们只能通过检查代码的外观来操作代码。然而，Julia是一个在运行时确定数据类型的动态系统。因此，Julia提供了创建**生成函数**的能力，这允许你检查函数调用的数据类型并返回一个表达式，就像宏一样。当表达式返回时，它将在调用位置被评估。
- en: 'To understand why generated functions are needed, let''s revisit how macros
    work. Let''s say we have created a macro that doubles the value of its arguments.
    It would look like the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么需要生成函数，让我们回顾一下宏是如何工作的。假设我们创建了一个宏，它将它的参数值加倍。它看起来会像以下这样：
- en: '[PRE17]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: No matter what expression we pass into this macro, it would just blindly rewrite
    the code so it doubles the original expression. Suppose that one day, a super-duper
    piece of software is developed that lets us calculate twice the amount of a floating-point
    number quickly. In this case, we may want the system to switch to that function
    for floating-point numbers only, instead of using the standard multiplication
    operator.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们传递给这个宏的什么表达式，它都会盲目地重写代码，使其加倍原始表达式。假设有一天，开发了一个超级无敌的软件，可以让我们快速计算浮点数的两倍。在这种情况下，我们可能希望系统只为浮点数切换到该函数，而不是使用标准的乘法运算符。
- en: 'So our first attempt might be to try something as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一次尝试可能是尝试以下内容：
- en: '[PRE18]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But unfortunately, it is impossible for macros to do this. Why? Again, macros
    only have access to the abstract syntax tree. This is at the earlier part of the
    compilation pipeline and there is no type information available. The `ex` variable in
    the preceding code is merely an expression object. This problem can be solved
    with generated functions. Keep on reading!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，宏无法做到这一点。为什么？再次，宏只能访问抽象语法树。这是编译管道的早期部分，没有类型信息可用。前面代码中的`ex`变量仅仅是一个表达式对象。这个问题可以通过生成函数来解决。继续阅读！
- en: Defining generated functions
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义生成函数
- en: '**Generated functions** are functions that are prefixed by `@generated` at
    the function definition. These functions can return expression objects, just like
    macros. For example, we can define the `doubled` function as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成函数**是在函数定义前带有`@generated`前缀的函数。这些函数可以返回表达式对象，就像宏一样。例如，我们可以定义`doubled`函数如下：'
- en: '[PRE19]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s quickly run a test and make sure that it works:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速运行一个测试，确保它工作：
- en: '![](img/5743d747-3b23-4e65-beaa-ba7d94f060cf.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5743d747-3b23-4e65-beaa-ba7d94f060cf.png)'
- en: The code works beautifully, as expected.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 代码运行得非常完美，正如预期的那样。
- en: So defining generated functions is quite similar to defining macros. In both
    cases, we can create an expression object and return it, and we can expect the
    expression to be evaluated properly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义生成函数与定义宏非常相似。在两种情况下，我们都可以创建一个表达式对象并返回它，并且我们可以期望表达式被正确评估。
- en: We have not, however, exercised the full power of generated functions yet. Next,
    we will look at how data type information can be made available and how it can
    be used within generated functions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有充分发挥生成函数的全部威力。接下来，我们将探讨如何使数据类型信息可用，以及如何在生成函数中使用它。
- en: Examining generated function arguments
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查生成函数参数
- en: 'An important point to remember is that arguments of generated functions contain
    data types, not actual values. The following is a visual representation of how
    generated functions work:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要观点是，生成函数的参数包含数据类型，而不是实际值。以下是如何生成函数工作的视觉表示：
- en: '![](img/567af354-7dcc-46c4-991b-c74c16cc9f4c.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/567af354-7dcc-46c4-991b-c74c16cc9f4c.png)'
- en: This is in sharp contrast to functions, which accept arguments as values. It
    is also different from macros, which accept arguments as expressions. Here, generated
    functions accept arguments as data types. It may seem a little strange, but let's
    do a simple experiment to confirm that this is indeed the case.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这与接受作为值的参数的函数形成鲜明对比。它也与接受作为表达式的参数的宏不同。在这里，生成函数接受参数作为数据类型。这可能会显得有些奇怪，但让我们做一个简单的实验来确认这确实如此。
- en: For this experiment, we will define the `doubled` function again by displaying
    the argument on screen before returning the expression.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，我们将再次通过在返回表达式之前在屏幕上显示参数来定义`doubled`函数。
- en: '[PRE20]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's test the function again.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次测试这个函数。
- en: '![](img/65ba16c7-91c2-41d3-aac9-61f02d5be2ba.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65ba16c7-91c2-41d3-aac9-61f02d5be2ba.png)'
- en: As it is shown, the value of argument `x` is `Int64` rather than `2` during
    the execution of the generated function. Furthermore, when the function is called
    again, it no longer shows the value of `x`. This is because the function is now
    compiled after the first call.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，在生成函数执行过程中，参数`x`的值是`Int64`而不是`2`。此外，当函数再次被调用时，它不再显示`x`的值。这是因为函数现在在第一次调用后被编译。
- en: 'Now, let''s see what happens if we run it again with a different type:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们用不同的类型再次运行会发生什么：
- en: '![](img/149b0d49-32bb-4144-8244-80e6b45e9b7e.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/149b0d49-32bb-4144-8244-80e6b45e9b7e.png)'
- en: The compiler has kicked in again and compiled a new version based upon the type
    of `Float64`. So, technically speaking, we now have two versions of the `doubled`
    function for each type of argument.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器再次启动，并基于`Float64`的类型编译了一个新版本。从技术上讲，我们现在为每种参数类型都有两个版本的`doubled`函数。
- en: You may have realized that the behavior of generated functions is similar to
    that of regular functions when it comes to specialization. The difference is that
    we have a chance to manipulate the abstract syntax tree right before the compilation
    happens.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到，生成函数在专业化方面与常规函数的行为相似。区别在于我们有在编译发生之前操作抽象语法树的机会。
- en: 'With this new generated function, we can now take advantage of the hypothetical
    super-duper software by switching over to the faster `double_super_duper` function
    whenever the data type of the argument is a subtype of `AbstractFloat`, as shown
    in the following code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的生成函数，我们现在可以利用假设的超级软件，通过切换到更快的`double_super_duper`函数来利用它，只要参数的数据类型是`AbstractFloat`的子类型，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using generated functions, we can specialize the function depending on the type
    of the argument. When the type is `AbstractFloat`, the function will resort to
    the `double_super_duper(x)` rather than the `2 *x` expression.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成函数，我们可以根据参数的类型来专门化函数。当类型是`AbstractFloat`时，函数将回退到`double_super_duper(x)`而不是`2
    *x`表达式。
- en: As mentioned in the official Julia language reference manual, care must be taken
    when developing generated functions. The exact limitations are beyond of the scope
    of this book. You are highly encouraged to refer to the manual if you need to
    write generated functions for your software.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如官方Julia语言参考手册中所述，在开发生成函数时必须谨慎。确切的限制超出了本书的范围。如果您需要为您的软件编写生成函数，强烈建议您查阅手册。
- en: Generated functions are a useful tool to deal with cases that macros are unable
    to handle. Specifically, during the macro expansion process, there is no information
    about the types of the argument. Generated functions allow us to get a little
    closer to the heart of the compilation process. With the additional knowledge
    about argument types, we are more flexible when it comes to handling different
    situations.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 生成函数是处理宏无法处理的案例的有用工具。具体来说，在宏展开过程中，没有关于参数类型的信息。生成函数使我们能够更接近编译过程的核心。有了关于参数类型的额外知识，我们在处理不同情况时更加灵活。
- en: As a metaprogramming tool, macros are used much more extensively than generated
    functions. Nevertheless, it is nice to know that both tools are available.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 作为元编程工具，宏的使用比生成函数广泛得多。然而，了解这两种工具都可用是很好的。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how Julia parses expressions into an abstract syntax
    tree structure. We learned that expressions can be created and evaluated programmatically.
    We also learned how to interpolate variables into quoted expressions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Julia如何将表达式解析为抽象语法树结构。我们了解到表达式可以通过编程方式创建和评估。我们还学习了如何将变量插入到引号表达式。
- en: Then, we jumped into the topic of macros, which are used to dynamically create
    new code. We learned that macro arguments are expressions rather than values,
    and learned how to create new expressions from macros. We had fun creating macros
    that manipulate the abstract syntax tree to deal with some interesting use cases.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了宏的主题，宏用于动态创建新代码。我们了解到宏参数是表达式而不是值，并学习了如何从宏中创建新表达式。我们享受着创建宏来操作抽象语法树以处理一些有趣的用例。
- en: Finally, we looked at generated functions, which can be used to generate code
    based on the type of the function arguments. We learned how generated functions
    can be useful for a hypothetical use case.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了生成函数，这些函数可以根据函数参数的类型生成代码。我们学习了生成函数在假设用例中的有用之处。
- en: We have now concluded the introductory part of the book regarding the Julia
    programming language. In the next chapter, we will start looking at design patterns
    related to code reusability.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了关于Julia编程语言入门部分的书籍。在下一章，我们将开始探讨与代码重用相关的设计模式。
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the two ways we can use to quote expressions so that the code can be
    manipulated later?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪两种方式来引用表达式，以便稍后可以操作代码？
- en: In what environment does the `eval` function execute code?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么环境下`eval`函数执行代码？
- en: How do you interpolate physical symbols into quoted expressions so that they
    are not misinterpreted as source code?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何将物理符号插入到引号表达式中，以便它们不会被误解释为源代码？
- en: What is the naming convention for a macro that defines nonstandard string literals?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义非标准字符串字面量的宏的命名约定是什么？
- en: When do you use the `esc` function?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在什么时候使用`esc`函数？
- en: How are generated functions different from macros?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成函数与宏有什么不同？
- en: How do you debug macros?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何调试宏？
