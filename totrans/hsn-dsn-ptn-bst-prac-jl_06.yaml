- en: Macros and Metaprogramming Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will discuss two of the most powerful facilities in the Julia
    programming language: macros and metaprogramming.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, metaprogramming is a technique for writing code that generates
    code—that''s why it has the prefix *meta*. It may sound esoteric, but it is a
    fairly common practice in many programming languages today. For example, C compiler
    uses a preprocessor to read source code and produce new source code, and then
    the new source code is compiled into a binary executable. For example, you can
    define a `MAX` macro, as in `#define MAX(a,b) ((a) > (b) ? (a) : (b))`, and this
    means that every time we use `MAX(a,b)`, it is replaced with `((a) > (b) ? (a)
    : (b))`. Note that `MAX(a,b)` is much easier to read than the longer form.'
  prefs: []
  type: TYPE_NORMAL
- en: The history of metaprogramming is quite long. As far back as the 1970s, it was
    already popular among the LISP programming language community. Interestingly,
    the LISP language is designed in such a way that the source code is structured
    like data—for example, a function call in LISP looks like `(sumprod x y z)`, where
    the first element is the name of the function and the rest are arguments. Since
    it is really just a list of four symbols—`sumprod`, `x`, `y`, and `z`—we can take
    this code and manipulate it in any way—for example, we can expand it so it calculates
    both the sum and product of the numbers, so the generated code becomes `(list
    (+ x y z) (* x y z))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wonder whether we can just write a function for that. The answer is,
    yes: in both of the examples that we just looked at, there is no need to use a
    metaprogramming technique. The examples were there only to illustrate how metaprogramming
    works. In general, we can say that metaprogramming is not needed 99% of the time;
    however, there is still that remaining 1% of cases where metaprogramming would
    be very useful. The first section will explore use cases where we would want to
    use metaprogramming.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn several metaprogramming facilities in Julia. The
    following topics will be covered in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generated functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of the chapter, we boldly claimed that metaprogramming is not
    needed 99% of the time. That is indeed not a made-up number. At the JuliaCon 2019
    conference, Professor Steven Johnson from MIT delivered a keynote speech regarding
    metaprogramming. He did some research about the Julia language's own source code.
    From his study, Julia version 1.1.0 contains 37,000 methods, 138 macros (0.4%),
    and 14 generated functions (0.04%). So metaprogramming code comprises less than
    1% of Julia's own implementation. While this is just one example of metaprogramming's
    role in one language, it is representative enough that even the smartest software
    engineers would not use metaprogramming most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the next question is: When do you need to use metaprogramming techniques?
    Generally speaking, there are several reasons for using such techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: They may allow a solution to be expressed more concisely and in a way that is
    easier to understand. Writing code without metaprogramming would otherwise look
    ugly and be difficult to comprehend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may reduce the development time because the source code can be generated
    rather than written out; boilerplate code, especially, can be eliminated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may improve performance because the code is spelled out rather than executed
    via other higher-level programming constructs, such as looping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now look at some examples of how metaprogramming is used in the real
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring performance with the @time macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia comes with a useful macro called `@time`, which measures the time required
    to execute code. For example, to measure how long it takes to calculate the sum
    of 10 million random numbers, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79626f6a-ec00-4d63-8032-f414bbcc0024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The macro works by inserting code around the code that is being measured. The
    resulting code may look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The new code uses the `now()` function to take the current time. Then, it executes
    the user-provided code and captures the result. It takes the current time again,
    calculates the elapsed time, prints the timing information to the console, and
    then it returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can this be done without metaprogramming? Perhaps we can give that a try. Let''s
    define a function called `timeit` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To use this timing facility, we need to wrap the expression in a function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8f1db6b-774b-4099-8398-baaa18c3f2a8.png)'
  prefs: []
  type: TYPE_IMG
- en: This function works fairly well, but the problem is that we have to wrap the
    code in a separate function before we can measure its performance, which is a
    hugely inconvenient thing to do. Because of this, we can conclude that having
    a `@time` macro is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Unrolling loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another use case of macros is to unroll loops into repeating code fragments.
    Loop unrolling is a performance optimization technique. The premise behind it
    is that there is always some overhead that is required to execute code in a loop.
    The reason is that, every time an iteration is finished, the loop must check for
    a condition and decide whether it should exit or continue with the next iteration.
    Now, if we know exactly how many times the loop needs to run the code, then we
    can *unroll* it by writing out the code in a repeated fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can unroll the loop into three lines of code that do the exact same job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But it would be quite a boring and mundane task to have to unroll loops manually.
    Furthermore, the amount of work grows linearly with the number of iterations required
    in the loop. With the help of `Unroll.jl`, we can define a function using the
    `@unroll` macro, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The code looks as clean as it should be, and the `@unroll` macro is inserted
    in front of the function as well as the `for` loop. First, we should check that
    the code works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6616ec0d-2ed2-4231-8acc-b7b32bd53a40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we should question whether the `@unroll` macro actually did anything.
    A good way to check whether the loop was unrolled is to use the `@code_lowered`
    macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e54b3954-bdea-413c-9fe4-16a48708327d.png)'
  prefs: []
  type: TYPE_IMG
- en: The lowered code clearly contains three `println` statements rather than a single
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: What is lowered code? The Julia compiler must go through a series of processes
    before source code is compiled to binaries. The very first step is to parse the
    code into an **abstract syntax tree** (**AST**) format, which we will learn about
    in the next session. After that, it goes through a *lowering* process to expand
    the macros and convert the code into concrete execution steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen some examples and know the power of metaprogramming, we
    shall move forward and learn how to create these macros ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Working with expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia represents the source code of any runnable program as a tree structure.
    This is called an **abstract syntax tree** (**AST**). It is referred to as *abstract*
    as the tree only captures the structure of the code rather than the real syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the expression `x + y` can be represented with a tree where the
    parent node identifies itself as a function call and the child nodes include the
    operator function `+` and the `x` and `y` arguments. The following is an implementation
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63989de7-d8b6-4b30-9fde-8c4e264f696c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The slightly more complex expression `x + 2y + 1` would look like the following
    diagram. While it was written with two addition operators, the expression is parsed
    into a single function call to the `+` function, for which it takes three arguments—`x`,
    `2y`, and `1`. Because `2y` is itself an expression, it can be seen as a subtree
    of the main abstract syntax tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8f1f88d-4ee8-498b-a969-4c8e4bf5330e.png)'
  prefs: []
  type: TYPE_IMG
- en: The Julia compiler must first parse source code into an abstract syntax tree,
    and then it can perform additional transformations and analysis, such as expanding
    macros, type checking, type inference, and eventually translating the code into
    machine code.
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with the parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because the abstract syntax tree is just a data structure, we can examine it
    directly within the Julia REPL environment. Let''s just start with a simple expression: `x
    + y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8186f498-fee4-46b5-93c4-b870de13cd62.png)'
  prefs: []
  type: TYPE_IMG
- en: In Julia, every expression is represented as an `Expr` object. We can create
    an `Expr` object by just parsing a string with the `Meta.parse` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the expression object is displayed with a syntax that resembles the original
    source code so that it is easier to read. We can confirm that the object has the
    type of `Expr` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f61ebe7-8d7c-4ab5-8a0d-f27bb6e5e280.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to view the abstract syntax tree, we can use the `dump` function to
    print the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbfb4302-ee10-46ec-baaf-64cbdd3b0141.png)'
  prefs: []
  type: TYPE_IMG
- en: In Julia, every expression is represented by a head node and an array of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the head node contains just a `call` symbol. The `args` array
    contains the `+` operator and two variables, `x` and `y`. Note that everything
    here is a symbol—that's OK because we are examining the source code itself, which
    is understandably just a tree of symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have had so much fun here, let's try a few other expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Single-variable expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the simplest expressions is just a reference to a variable. You can
    try to parse a numeric or string literal and see what it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1943fdfd-f8d9-4f34-9e8c-af4e356514f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Function calls with keyword arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try something a little more complex. We will examine a function call
    that takes a single positional argument and two keyword arguments. Here, we use
    triple quotes around the code so that we can handle the double quotes inside it
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e81cd68-ad62-44e1-a766-8823d216d42f.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that a function call has the `call` symbol as the head node of the expression.
    Also, the keyword arguments are represented as subexpressions, each with a head
    node of `kw` and a two-element array for the name and value of the argument.
  prefs: []
  type: TYPE_NORMAL
- en: Nested functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may wonder how Julia parses code when functions are nested. We can pick
    a simple example here that takes the sine of `x+1` and then takes the cosine of
    the result. The abstract syntax tree is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bf61837-89ac-4f12-9b51-05f080dd5def.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can clearly see the tree structure. The outermost function, `cos`,
    contains a single argument, which is an expression node with a call to the `sin`
    function. This expression in turn contains a single argument, which is another
    expression node with a call to the `+` operator function with two arguments—the
    `x` variable and a value of `1`. Now, let's continue with our work on expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing expression objects manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an expression is just a data structure, we can easily construct them programmatically.
    Understanding how to do this is essential for metaprogramming, which involves
    creating new code structures on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Expr` constructor has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The head node always carries a symbol. The arguments just contain whatever
    the head node expects—for example, the simple expression `x + y` can be created
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f5bb0a3-13ab-4c7c-ba4e-233f519f08f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, we can always create a nested expression if we want to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0938942b-66a5-4fb1-a623-f01b023c2e55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, you may wonder whether there is an easier way to create expressions
    without having to construct `Expr` objects manually.  For sure, it can be done
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2579b8b-162f-4294-8eab-9b4540a7ab02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Basically, we can wrap any expression with `:(` on the left and `)` on the
    right. The code that sits inside will not be evaluated, but will instead be parsed
    into an expression object; however, this way of quoting only works with a single
    expression—if you try to do this with multiple expressions, an error will be displayed,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7d55f45-9cd4-4003-bc18-c9f59b614cf5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It does not work because multiple expressions should be wrapped with `begin`
    and `end` keywords. So it would be fine if we entered the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a4102ef-4edd-4e15-b44b-c2fd311d2446.png)'
  prefs: []
  type: TYPE_IMG
- en: The result is a little interesting. As you can see, the code is now wrapped
    within a `quote/end` block rather than a `begin/end` block. It actually makes
    sense because a quoted expression is being displayed rather than the original
    source code. Remember, this is the abstract syntax tree rather than the original
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also turns out that `quote/end` can be used directly to create expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b85ff5b5-02db-46bc-a44a-985c8dd178a5.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now learned how to parse source code into an expression object. Next,
    we will look into more complex expressions so that we are more familiar with the
    basic code structure of Julia programs.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with more complex expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said before, any valid Julia program can be represented as an abstract
    syntax tree. Now that we have the building blocks to create expression objects,
    let's examine a few more constructs and see what expression objects look like
    for more complex programs.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will see how it works for assignments first. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c32beb4-b5b1-49e3-a440-ba7fc4608b27.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding code, we can see that the variable assignment has a head
    node of `=` and two arguments—the variable to be assigned (`x`, in this case)
    and another expression object.
  prefs: []
  type: TYPE_NORMAL
- en: Code blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A code block is enclosed by the `begin` and `end` keywords. Let's examine what
    the abstract syntax tree looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/925b6634-edb5-4819-a66a-af1bdd69944c.png)'
  prefs: []
  type: TYPE_IMG
- en: The head node just contains a `block` symbol. When there are multiple lines
    in the block, the abstract syntax tree also includes line number nodes. In this
    example, there is a `LineNumberNode` with line 2 preceding the first call to `println`.
    Likewise, there is another `LineNumberNode` with line 3 preceding the second call
    to `println`. The `LineNumberNode` nodes do not do anything, but they are useful
    for stack traces and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up, we''ll explore conditional constructs, such as `if-else-end`. Refer
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d2b3253-89b5-45d3-91bf-2e2346c730fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The head node contains the `if` symbol. There are three arguments—an expression
    for the condition, a block expression when the condition is satisfied, and another
    block expression when the condition is not satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now move on to looping constructs. Consider a simple `for` loop, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2130fa5b-520d-47a8-b2b9-7b1235351fc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The head node contains a `for` symbol. There are two arguments: the first one
    contains the expression about the loop and the second one contains a block expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Function definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will see the structure for a function definition. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/414fcd55-6739-42d1-9f8c-a73f24b18e03.png)'
  prefs: []
  type: TYPE_IMG
- en: The head node contains a `function` symbol. Then, the first argument contains
    a `call` expression with the arguments. The second argument is just a block expression.
  prefs: []
  type: TYPE_NORMAL
- en: The call expression may seem a little odd because we have seen a similar expression
    object when a function is being called. This is normal because we are currently
    working at the syntax level. The syntax for function definition is indeed quite
    similar to the function call itself.
  prefs: []
  type: TYPE_NORMAL
- en: By now, we have seen enough examples. There are obviously many more code constructs
    that we have not explored. You are encouraged to use the same technique to examine
    other code structures. Understanding how the abstract syntax tree is structured
    is essential to writing good metaprogramming code. Next, we will see how we can
    evaluate these expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at creating expression objects in great detail. But how are they
    useful? Remember that an expression object is just an abstract syntax tree representation
    of a Julia program. At this point, we can ask the compiler to continue translating
    the expression into executable code and then run the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expression objects can be evaluated by calling the `eval` function. Essentially,
    the Julia compiler will go through the rest of the compilation process and run
    the program. Now, let''s start a fresh, new REPL and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17f873d7-2181-40ed-8f15-3561552c254c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clearly, it''s just a simple assignment. We can see that the `x` variable is
    now defined in the current environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f939154-52d6-4c29-9ac6-2aa74aa1b8ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the evaluation of the expression actually happens in the global scope.
    We can prove this by running `eval` from within a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c9b4f79-5bb2-49fb-95b0-ce8203eca8ca.png)'
  prefs: []
  type: TYPE_IMG
- en: This is not an unimportant observation! At first glance, we may have expected
    the `y` variable to be assigned inside the `foo` function; however, the variable
    assignment happened in the global scope instead, so the `y `variable was defined
    in the current environment as a side-effect.
  prefs: []
  type: TYPE_NORMAL
- en: More precisely, the expression is evaluated in the current module. Since we
    are testing in the REPL, the evaluation was done in the current module, called
    `Main`. The expression is designed as such because `eval` is commonly used for
    code generation, which can be useful in defining variables or functions within
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to create expression objects more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating variables in expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is quite simple to construct expressions from a quote block. But what if
    we want to dynamically create expressions? This can be done using *interpolation*,
    which allows us to insert variable values into the expression object with an easy
    syntax. Interpolation in an expression is very similar to the way that variables
    can be interpolated in a string. The following screenshot shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7ee7ac3-b5bb-4833-bb32-5c414bc69998.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, the value of `2` is correctly substituted in the expression. Note
    that `splatting` is also supported, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75b2ee1c-6976-4c3b-adb1-22cb55363682.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We must make sure that the variable that includes the `splatting` operator
    is interpolated in this case. If we had forgotten to put the parentheses around `v...`,
    then we would have had a very different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9255e775-c7f4-4b94-87a4-984720944cd3.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, splatting does not actually occur during interpolation into the expression.
    Instead, the splatting operator now becomes part of the expression, so splatting
    will not occur until the expression is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: The order of precedence in an expression such as `$v...` is somewhat unclear.
    Is the `v` variable bound to the interpolation operation before or after the splatting
    operation? In a situation like this, it is best to use parentheses around whatever
    we want to interpolate. As we want the interpolation to happen fully, the syntax
    should be `$(v...)`. In situations where splatting needs to happen at runtime,
    we could write `$(v)...` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation is an important concept for writing macros. We will see more of
    its usage later in this chapter. Next, we will see how to handle construct expressions
    with symbol values.
  prefs: []
  type: TYPE_NORMAL
- en: Using QuoteNode for symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symbols are quite special when they appear in expressions. They may appear
    in the head node of an expression object—for example, the `=` symbol in a variable
    assignment expression. They may also appear in the arguments of an expression
    object, in which case they would represent a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c7ec2aa-3be8-4c3f-ac06-4e424e1c7886.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since symbols are already used to represent variables, how would we assign
    an actual symbol to a variable? To figure out how this works, we can use the same
    trick that we have learned so far—using the `dump` function to examine the expression
    object for such a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6c583b4-4c64-4073-98fa-4fe8ceba0885.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, an actual symbol must be enclosed in a `QuoteNode` object. Now
    that we know what is needed, we should try to interpolate an actual symbol into
    an expression object. The way to achieve this is to create a `QuoteNode` object
    manually and use the interpolation technique as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/275de7a3-11a7-409e-abc3-af1a49d9f12d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A common mistake is when you forget to create `QuoteNode`. In this case, the
    expression object will misinterpret the symbol and treat it as a variable reference.
    Obviously, the result is very different, and it will not work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0512ee43-2e07-4147-8a89-43eaec212d3f.png)'
  prefs: []
  type: TYPE_IMG
- en: Not using `QuoteNode` would generate code that assigns the value of one variable
    to another. In this case, the variable `x` will be assigned with a value from
    variable `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how `QuoteNode` works is essential creating expressions on the
    fly. It is common for programmers to interpolate symbols into an existing expression.
    So next, we will look at how to work with nested expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating in nested expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to have a quoted expression that contains another quoted expression.
    This is not a very common practice, unless the programmer needs to write meta-metaprograms.
    Nonetheless, we should still learn about how to interpolate in such a situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s recap what a single-level expression looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b444be5d-ede6-48ae-b0c6-4812746ec43a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can wrap the quoted expression with another quote block in order to see
    what the structure of a nested expression looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66fd29be-2aae-47aa-b9cb-66c5b7922161.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try to interpolate in such an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66f6f2ba-72a7-42cd-81cc-55044b3cb6c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the `2` value did not get into the expression. The expression
    structure is also entirely different from what we had expected. The solution is
    to just interpolate the variable twice instead by using two `$` signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5e4a9dc-2791-420c-add4-66a44d7b29cb.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, it is probably not much fun to interpolate more than one-level deep
    as the logic becomes difficult to work out. It can be useful, however, if you
    need to generate code for macros. I would definitely not suggest that you go more
    than two-levels deep and write meta-meta-metaprograms!
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be more familiar with, and comfortable working with, expressions.
    From the Julia REPL, it is quite easy to see how an expression is structured as
    represented as an `Expr` object. You should be able to construct new expressions
    and interpolate values inside; these are essential skills that will be required
    for metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look into a powerful metaprogramming feature in
    Julia—macros.
  prefs: []
  type: TYPE_NORMAL
- en: Developing macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how source code is represented as abstract syntax trees,
    we can start doing more interesting things by writing macros. In this section,
    we will learn what macros are and how to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: What are macros?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Macros are functions that accept expressions, manipulate them, and return a
    new expression. This is best understood with a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4271853-2e8b-4a47-bd13-28ecf8126b60.png)'
  prefs: []
  type: TYPE_IMG
- en: As we know, expressions are just abstract syntax tree representations of source
    code. So the macro facility in Julia allows you to take any source code and generate
    new source code. The resulting expression is then executed as if the source code
    was written directly in place.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may wonder why we cannot use regular functions to achieve
    the same thing. Why could we not write a function that takes expressions, generates
    a new expression, and then executes the resulting expression?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Macro expansion happens during compilation. This means that the macro is only
    executed once from where it is used—for example, when a macro is called from a
    function, the macro is executed at the time that the function is defined so that
    the function can be compiled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting expression from a macro can be executed within the current scope.
    At runtime, there is no other way to execute any dynamic code within the function
    itself because the function, by definition, is already compiled. So, the only
    way to evaluate any expression is to do so in the global scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a better understanding of how macros
    work and how they differ from functions.
  prefs: []
  type: TYPE_NORMAL
- en: As we now understand what macros are, we will now continue our journey by writing
    our first macro.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are defined in a similar way to how functions are defined, except that
    the `macro` keyword is used instead of the `function` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also keep in mind that a macro must return expressions. Let''s create
    our first macro. This macro returns an expression object that contains a `for`
    loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking the macro is as easy as calling it with the `@` prefix. Refer to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b105cfd-4a31-4b85-b470-e9881e4bcb9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unlike functions, macros may be called without using parentheses. So we can
    just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43c8a997-9b9a-4fbc-90f8-d1ed60c47f33.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Fantastic!* We have now written our first macro. While it does not look very
    exciting, because the code being generated is just a static piece of code, we
    have learned how to define macros and run them.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to pass arguments to macros.
  prefs: []
  type: TYPE_NORMAL
- en: Passing literal arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like functions, macros can also take arguments. In fact, taking an argument
    is the most common occurrence for a macro. The simplest type of argument is literals,
    such as numbers, symbols, and strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to utilize these arguments in the returned expression, we can use
    the interpolation technique that we learned in the last section. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hello` macro takes a single argument, `n`, which is interpolated into
    the expression when the macro is run. As before, we can just invoke the macro
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e76e0851-af2d-4280-8c53-ee71cb64a788.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we learned earlier, parentheses are not required, so we can also call the
    macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39aae576-f8b8-446e-ba2d-4a4729444b62.png)'
  prefs: []
  type: TYPE_IMG
- en: You can try a similar exercise with string or symbol arguments. Passing literals
    is easy to understand because it works in the same way as functions. But there
    is indeed a subtle difference between macros and functions, which we will discuss
    in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Passing expression arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to emphasize that macro arguments are passed as expressions
    rather than values. It may look confusing for beginners because macros are invoked
    similarly to functions, but the behavior is completely different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure that we fully understand what this means. When calling a function
    with a variable, the value of the variable is passed into the function. Consider
    the following sample code for a `showme` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f84cffba-eb41-4aaa-a648-3f09ece404b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create a `@showme` macro that does nothing but display the argument
    in the console. We can then compare the results with the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7cf9700-6cee-4fda-8a7c-7b0964b53d18.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the results from running a macro are totally different than those
    we get from calling a function. The function argument `x` really only sees an
    expression from where the macro was called. From the diagram at the beginning
    of this section, we can see that macros are supposed to take in expressions and
    return a single expression as a result. They do not know the value of the arguments
    as they work at the syntax level.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in the next section, expressions can even be manipulated when
    the macro is run. Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the macro expansion process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By convention, every macro must return an expression. The process of taking
    one or more expressions and returning a new one is called **macro expansion**.
    Sometimes, it helps to see the expression being returned without actually running
    the code. We can use the `@macroexpand` macro for that purpose. Let''s try to
    use it for the `@hello` macro that we defined earlier in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/289780c8-b7d0-4570-924a-9099604360f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are several things to note from this output:'
  prefs: []
  type: TYPE_NORMAL
- en: The `i` variable was renamed rather oddly: `#67#i`. This is done by the Julia
    compiler to ensure *hygiene*, which we will discuss later in this chapter. Macro
    hygiene is an important characteristic to keep in mind so that the code being
    generated does not conflict with other code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comment was inserted into the loop that contains source file and line number
    information. This is a useful part of the expression when a debugger is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function call to `println` is bound to the one in the current environment,
    `Main`. This make sense because `println` is part of the `Core` package and is
    automatically brought into scope for every Julia program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So when does macro expansion happen? Let's go over that next.
  prefs: []
  type: TYPE_NORMAL
- en: Timing of macro expansion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the REPL, any macro is expanded as soon as we invoke it. Interestingly, when
    a function containing the macro is defined, the macro is expanded as part of the
    function definition process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in action by developing a simple `@identity` macro that returns
    whatever expression is passed into it. Right before the expression is returned,
    we just `dump` the object to the screen. The code for the `@identity` macro is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since this macro returns the same expression that was passed, it should end
    up executing the original source code that follows the macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a function that uses the `@identity` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffe1dd38-680b-4965-a37f-c859e78a5b51.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, the compiler has figured out that the macro is being used in the definition
    of the `foo` function and, in order to compile the `foo` function, it must understand
    what the `@identity` macro does. So it expanded the macro and baked that into
    the function definition. During the macro expansion process, the expression was
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the `@code_lowered` macro against the `foo` function, we can see
    that the expanded code is now in the body of the `foo` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7815efe2-61fe-478f-9a07-a9abfb5319a2.png)'
  prefs: []
  type: TYPE_IMG
- en: During development, the programmer may change the definitions of functions,
    macros, and so on frequently. Because macros are expanded when functions are defined,
    it is important to redefine the function again if any of the macros being used
    have been changed; otherwise, the function may continue to use the code generated
    from the prior macro definition.
  prefs: []
  type: TYPE_NORMAL
- en: The `@macroexpand` utility is an indispensable tool for developing macros, and
    in particular, is most useful for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will try to be a little more creative by manipulating expressions in
    macros.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are powerful because they allow expressions to be manipulated during
    the macro expansion process. This is a tremendously useful technique, especially
    for code generation and designing domain-specific languages. Let's go over some
    examples to get a taste of what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – Making a new expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a simple one. Suppose that we want to create a macro called
    `@squared` that takes an expression and just squares it. In other words, if we
    run `@squared(x)`, then it should be translated into `x * x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, it seems to work fine when we run it from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0497020c-1f39-47af-a3da-366abf4482ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But this macro has a problem with the execution context. The best way to illustrate
    the problem is by defining a function that uses the macro. So let''s define a `foo`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we call the function, we get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0481fc86-f878-46b4-867e-4aee1e845c32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Why is that? It is because, during the macro expansion, the `x` symbol refers
    to the variable in the module rather than the local variable in the `foo` function.
    We can confirm this by using the `@code_lowered` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/500c7a34-0f8b-4747-8811-56f00eed2e5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Obviously, our intention was to square the local `x` variable rather than `Main.x`.
    The easy fix to this problem is to use the `esc` function during interpolation
    in order to place the expression directly in the syntax tree without letting the
    compiler resolve it. The following is how it can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the macro was expanded earlier, before `foo` was defined, we need to
    define the `foo` function once again, as follows, for this updated macro to take
    effect. Alternatively, you can start a new REPL and define the `@squared` macro
    and `foo` function again. Here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cb9a817-8915-4ea2-ba6b-2cb0e2158dc5.png)'
  prefs: []
  type: TYPE_IMG
- en: The `foo` function works correctly now.
  prefs: []
  type: TYPE_NORMAL
- en: From this example, we have learned how to create a new expression using the
    interpolation technique. We have also learned that the interpolated variable needs
    to be escaped using the `esc` function to avoid it being resolved by the compiler
    to the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 - Tweaking the abstract syntax tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we want to design a macro called `@compose_twice` that takes a simple
    function call expression and calls the same function again with the result—for
    example, if we run `@compose_twice sin(x)`, then it should be translated to `sin(sin(x))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write the macro, let''s first get familiar with the abstract syntax
    tree of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/664d8b6d-80b2-459e-bbfe-9ae14e9ac4d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'How does it look for `sin(sin(x))`? Refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e9871e0-6b20-4997-8674-ee2e84f80a5d.png)'
  prefs: []
  type: TYPE_IMG
- en: No surprise here. The second argument of the top-level call is just another
    expression that looks like what we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first two `@assert` statements are used to ensure that the expression represents
    a function call that takes a single argument. As we want to replace the argument
    with a similar expression, we just make a copy of the current expression object
    and assign it to `ex.args[2]`. The macro then returns the resulting expression
    for evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that the macro is working correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ed701a3-07c2-4ca7-a172-b20b41a87a65.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we can translate the source code by manipulating the abstract
    syntax tree directly rather than interpolating variables into a nice-looking expression.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you can probably appreciate the power of metaprogramming. Compared to
    using interpolation, manipulating an expression directly is not as easy to understand
    because the resulting expression is not represented in the code; however, the
    ability to manipulate expressions provides the ultimate flexibility in translating
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will go over an important feature of metaprogramming—macro hygiene.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding macro hygiene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macro hygiene refers to the ability to keep macro-generated code clean. It is
    referred to as hygiene because the generated code does not get polluted by other
    parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that many other programming languages do not provide such a guarantee.
    The following is a C program that contains a macro called `SWAP`, which is used
    to exchange the value of two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, running this C program yields an incorrect result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c89d315-9273-4b0a-b9a1-6a032a9c5cc6.png)'
  prefs: []
  type: TYPE_IMG
- en: It did not swap the `a` and `temp` variables properly because the `temp` variable is
    also used as a temporary variable in the body of the macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to Julia. Consider the following macro, which just runs an `ex` expression and
    repeats it `n` times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `times` variable is used in the returned expression, what would happen
    if the same variable name is already used in the call site? Let''s try this sample
    code, which defines a `times` variable before the macro call and prints the value
    of the same variable after the macro call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the macro expander took it literally, then the `times` variable would be
    modified to `3` after the macro call; however, we can see it working properly
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69356a2f-70f7-4981-98df-dcc7d1f77cc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It works because the macro system is able to maintain hygiene by renaming the
    `times` variable to something different so that there is no conflict. Where is
    the magic? Well, let''s take a look at the expanded code using `@macroexpand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07a64213-e13d-4060-aa22-8546322f2124.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the `times` variable has turned into `#44#times`. The
    loop variable `i` has also turned into `#45#i`. These variable names are dynamically
    generated by the compiler to ensure that macro-generated code does not conflict
    with other user-written code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macro hygiene is an essential feature for macros to function correctly. There
    is nothing that the programmer needs to do: Julia automatically provides the guarantee.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into a different kind of macro that powers nonstandard string
    literals.
  prefs: []
  type: TYPE_NORMAL
- en: Developing nonstandard string literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a special kind of macro for defining nonstandard string literals, which
    look like a literal string but instead a macro is called when it is referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example would be Julia''s regular expression literal—for example, `r"^hello"`.
    It is not a standard string literal because of the `r` prefix in front of the
    double quote. Let''s first check the data type of such a literal. We can see that a `Regex` object
    is created from the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66d4c40a-9654-4c61-84c8-74f090383aad.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also create our own nonstandard string literals. Let's try to work through
    a fun example together here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that, for development purposes, we want to conveniently create sample
    data frames with different types of columns. The syntax for doing so is a little
    bit tedious:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91855e88-e2b9-40e7-8e6d-758a223a67c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Imagine that we occasionally need to create tens of columns with different data
    types. The code for creating such a data frame would be very long, and as a programmer,
    I would be extremely bored typing that all out. So we could design a string literal
    so that it contains the specification for constructing such a data frame—let's
    call it a `ndf` (numerical data frame) literal.
  prefs: []
  type: TYPE_NORMAL
- en: The specification on `ndf` just needs to encode the desired number of rows and
    column types. For instance, the literal `ndf"100000:f64,i16"` can be used to represent
    the preceding sample data frame, where 100,000 rows are needed, with two columns
    labeled as the `Float64` and `Int16` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this feature, we just define a macro called `@ndf_str`. The macro
    takes a string literal and creates the desired data frame accordingly. The following
    is one way to implement the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines parse the string and determine the number of rows (`n`),
    as well as the types of the columns (`types`). Then, a dictionary called `mappings`
    is created to map the shorthand to the corresponding numeric types. The column
    names and types are generated from the type and mapping data. Finally, it calls
    the `DataFrame` constructor and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the macro defined, we can easily create new data frames, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26cacfc8-c5ab-431b-977a-b38b526a1447.png)'
  prefs: []
  type: TYPE_IMG
- en: Nonstandard string literals can be quite useful in certain cases. We can see
    a string specification as a mini domain-specific language that is encoded in the
    string. As long as the string specification is well defined, it can make the code
    a lot shorter and more concise.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the `ndf_str` macro returns a regular `DataFrame`
    object rather than an expression object, as it would normally do with macros.
    This is perfectly fine because the final `DataFrame` object will be returned as-is.
    You may think of an evaluation of a constant as just the constant itself. We can
    just return a value rather than an expression here because the returned value
    does not involve any variables from the call site or from the module.
  prefs: []
  type: TYPE_NORMAL
- en: A curious mind might ask - why can't we just create a regular function for this?
    We can certainly do that for this dummy example. However, using a string literal
    could improve performance in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we use the Regex string literal in a function, the `Regex`
    object is created at compile-time and so it is executed only once. If we use the `Regex`
    constructor instead, then the object would be created every single time the function
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: We have now concluded the topic of macros. We learned how to create macros by
    taking expressions and generating a new expression. We used the `@macroexpand`
    macro to debug the macro expansion process. We also learned how to handle macro
    hygiene. Finally, we took a look at nonstandard string literals and created our
    own using a macro.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at another metaprogramming facility called generated functions,
    which can be used to solve a different kind of problem than what regular macros
    can handle.
  prefs: []
  type: TYPE_NORMAL
- en: Using generated functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explained how to create macros that return expression objects.
    Since macros work at the syntax level, they can manipulate code only by examining
    how it *looks*. However, Julia is a dynamic system where data types are determined
    at runtime. For that reason, Julia provides the ability to create **generated
    functions**, which allow you to examine data types for a function call and return
    an expression, just like macros. When an expression is returned, it will be evaluated
    at the call site.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why generated functions are needed, let''s revisit how macros
    work. Let''s say we have created a macro that doubles the value of its arguments.
    It would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: No matter what expression we pass into this macro, it would just blindly rewrite
    the code so it doubles the original expression. Suppose that one day, a super-duper
    piece of software is developed that lets us calculate twice the amount of a floating-point
    number quickly. In this case, we may want the system to switch to that function
    for floating-point numbers only, instead of using the standard multiplication
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'So our first attempt might be to try something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But unfortunately, it is impossible for macros to do this. Why? Again, macros
    only have access to the abstract syntax tree. This is at the earlier part of the
    compilation pipeline and there is no type information available. The `ex` variable in
    the preceding code is merely an expression object. This problem can be solved
    with generated functions. Keep on reading!
  prefs: []
  type: TYPE_NORMAL
- en: Defining generated functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generated functions** are functions that are prefixed by `@generated` at
    the function definition. These functions can return expression objects, just like
    macros. For example, we can define the `doubled` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly run a test and make sure that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5743d747-3b23-4e65-beaa-ba7d94f060cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The code works beautifully, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: So defining generated functions is quite similar to defining macros. In both
    cases, we can create an expression object and return it, and we can expect the
    expression to be evaluated properly.
  prefs: []
  type: TYPE_NORMAL
- en: We have not, however, exercised the full power of generated functions yet. Next,
    we will look at how data type information can be made available and how it can
    be used within generated functions.
  prefs: []
  type: TYPE_NORMAL
- en: Examining generated function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important point to remember is that arguments of generated functions contain
    data types, not actual values. The following is a visual representation of how
    generated functions work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/567af354-7dcc-46c4-991b-c74c16cc9f4c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is in sharp contrast to functions, which accept arguments as values. It
    is also different from macros, which accept arguments as expressions. Here, generated
    functions accept arguments as data types. It may seem a little strange, but let's
    do a simple experiment to confirm that this is indeed the case.
  prefs: []
  type: TYPE_NORMAL
- en: For this experiment, we will define the `doubled` function again by displaying
    the argument on screen before returning the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's test the function again.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65ba16c7-91c2-41d3-aac9-61f02d5be2ba.png)'
  prefs: []
  type: TYPE_IMG
- en: As it is shown, the value of argument `x` is `Int64` rather than `2` during
    the execution of the generated function. Furthermore, when the function is called
    again, it no longer shows the value of `x`. This is because the function is now
    compiled after the first call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if we run it again with a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/149b0d49-32bb-4144-8244-80e6b45e9b7e.png)'
  prefs: []
  type: TYPE_IMG
- en: The compiler has kicked in again and compiled a new version based upon the type
    of `Float64`. So, technically speaking, we now have two versions of the `doubled`
    function for each type of argument.
  prefs: []
  type: TYPE_NORMAL
- en: You may have realized that the behavior of generated functions is similar to
    that of regular functions when it comes to specialization. The difference is that
    we have a chance to manipulate the abstract syntax tree right before the compilation
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new generated function, we can now take advantage of the hypothetical
    super-duper software by switching over to the faster `double_super_duper` function
    whenever the data type of the argument is a subtype of `AbstractFloat`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using generated functions, we can specialize the function depending on the type
    of the argument. When the type is `AbstractFloat`, the function will resort to
    the `double_super_duper(x)` rather than the `2 *x` expression.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the official Julia language reference manual, care must be taken
    when developing generated functions. The exact limitations are beyond of the scope
    of this book. You are highly encouraged to refer to the manual if you need to
    write generated functions for your software.
  prefs: []
  type: TYPE_NORMAL
- en: Generated functions are a useful tool to deal with cases that macros are unable
    to handle. Specifically, during the macro expansion process, there is no information
    about the types of the argument. Generated functions allow us to get a little
    closer to the heart of the compilation process. With the additional knowledge
    about argument types, we are more flexible when it comes to handling different
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: As a metaprogramming tool, macros are used much more extensively than generated
    functions. Nevertheless, it is nice to know that both tools are available.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how Julia parses expressions into an abstract syntax
    tree structure. We learned that expressions can be created and evaluated programmatically.
    We also learned how to interpolate variables into quoted expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we jumped into the topic of macros, which are used to dynamically create
    new code. We learned that macro arguments are expressions rather than values,
    and learned how to create new expressions from macros. We had fun creating macros
    that manipulate the abstract syntax tree to deal with some interesting use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at generated functions, which can be used to generate code
    based on the type of the function arguments. We learned how generated functions
    can be useful for a hypothetical use case.
  prefs: []
  type: TYPE_NORMAL
- en: We have now concluded the introductory part of the book regarding the Julia
    programming language. In the next chapter, we will start looking at design patterns
    related to code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two ways we can use to quote expressions so that the code can be
    manipulated later?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what environment does the `eval` function execute code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you interpolate physical symbols into quoted expressions so that they
    are not misinterpreted as source code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the naming convention for a macro that defines nonstandard string literals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When do you use the `esc` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are generated functions different from macros?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you debug macros?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
