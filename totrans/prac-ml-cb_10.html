<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Neural Networks"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Neural Networks</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Modeling S&amp;P 500</li><li class="listitem" style="list-style-type: disc">Measuring the unemployment rate</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec49"/>Introduction</h1></div></div></div><p>
<span class="strong"><strong>Neural networks</strong></span>: A neural network is a sorted triple <span class="inlinemediaobject"><img src="graphics/image_10_001.jpg" alt="Introduction"/></span> where <span class="inlinemediaobject"><img src="graphics/image_10_002.jpg" alt="Introduction"/></span> is the set of a neuron, and <span class="inlinemediaobject"><img src="graphics/image_10_003.jpg" alt="Introduction"/></span> is a set <span class="inlinemediaobject"><img src="graphics/image_10_004.jpg" alt="Introduction"/></span> whose elements are called connections between neuron <span class="inlinemediaobject"><img src="graphics/image_10_005.jpg" alt="Introduction"/></span> and neuron <span class="inlinemediaobject"><img src="graphics/image_10_006.jpg" alt="Introduction"/></span>The function <span class="inlinemediaobject"><img src="graphics/image_10_007.jpg" alt="Introduction"/></span> defines the weights, where <span class="inlinemediaobject"><img src="graphics/image_10_008.jpg" alt="Introduction"/></span> is the weight of the connection between neuron <span class="inlinemediaobject"><img src="graphics/image_10_009.jpg" alt="Introduction"/></span> and neuron <span class="inlinemediaobject"><img src="graphics/image_10_010.jpg" alt="Introduction"/></span>. Data is transferred between neurons via connections, with the connecting weight being either excitatory or inhibitory.</p></div></div>
<div class="section" title="Modelling SP 500"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec50"/>Modelling SP 500</h1></div></div></div><p>The value of the stocks of the 500 largest corporations by market capitalization listed on the New York Stock Exchange or Nasdaq Composite is measured by the S&amp;P 500. Standard &amp; Poor's provides a quick look at the movement of the stock market and economy on the basis of stock prices. The S&amp;P 500 index is the most popular measure used by the financial media and professionals. The S&amp;P 500 index is calculated by taking the sum of the adjusted market capitalization of all S&amp;P 500 stocks and then dividing it with an index divisor developed by Standard &amp; Poor's. The divisor is adjusted when there are stock splits, special dividends, or spinoffs that could affect the value of the index. The divisor ensures that these non-economic factors do not affect the index.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec62"/>Getting ready</h2></div></div></div><p>In order to model the S&amp;P 500 index using neural networks, we shall be using a dataset collected from the <code class="literal">GSPC</code> dataset.</p><div class="section" title="Step 1 - collecting and describing data"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec156"/>Step 1 - collecting and describing data</h3></div></div></div><p>The dataset to be used is the <code class="literal">GSPC</code> daily closing stock value between January 1, 2009 and January 1, 2014. This dataset is freely available on <a class="ulink" href="https://www.yahoo.com/">https://www.yahoo.com/</a>, from which we shall be downloading the data.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec63"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring data"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec157"/>Step 2 - exploring data</h3></div></div></div><p>First, the following packages need to be loaded:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("quantmod")</strong></span>
<span class="strong"><strong>    &gt; install.packages("neuralnet")</strong></span>
<span class="strong"><strong>    &gt; library(quantmod)</strong></span>
<span class="strong"><strong>    &gt; library(neuralnet)</strong></span>
</pre><p>Let's download the data. We will begin by marking the start and the end dates for the desired time period.</p><p>The <code class="literal">as.Date()</code> function is used to convert the character representation and objects of the <code class="literal">Date</code> class, which represents calendar dates.</p><p>The start date for the dataset is stored in <code class="literal">startDate</code>, which represents a character vector representation of the calendar date. The format for this representation is YYYY-MM-DD:</p><pre class="programlisting">
<span class="strong"><strong>&gt; startDate = as.Date("2009-01-01")</strong></span>
</pre><p>The end date for the dataset is stored in <code class="literal">endDate</code>, which represents the character vector representation of the calendar date. The format for this representation is YYYY-MM-DD:</p><pre class="programlisting">
<span class="strong"><strong>&gt; endDate = as.Date("2014-01-01")</strong></span>
</pre><p>Loading the data using the <code class="literal">getSymbols()</code> function: The function loads data from multiple sources, either local or remote. <code class="literal">GSPC</code> is the character vector that specifies the name of the symbol to be loaded. <code class="literal">src = yahoo</code> specifies the sourcing method:</p><pre class="programlisting">
<span class="strong"><strong>&gt; getSymbols("^GSPC", src="yahoo", from=startDate, to=endDate)</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_10_011.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div class="section" title="Step 3 - calculating the indicators"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec158"/>Step 3 - calculating the indicators</h3></div></div></div><p>Calculating the relative strength index: This is a ratio between the recent upward price movements and the absolute price movement. The <code class="literal">RSI()</code> function is used to calculate the <span class="strong"><strong>Relative Strength Index</strong></span>. The <code class="literal">GSPC</code> data frame is used as a price series. <code class="literal">n = 3</code> represents the number of periods for moving averages. The result is then stored in the <code class="literal">relativeStrengthIndex3</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; relativeStrengthIndex3 &lt;- RSI(Op(GSPC),n=3)</strong></span>
</pre><p>Exploring the summary of the change in prices: The <code class="literal">summary()</code> function is used for this. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">relativeStrengthIndex3</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(relativeStrengthIndex3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_012.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>The <code class="literal">EMA()</code> function uses the <code class="literal">GSPC</code> symbol as a price series. <code class="literal">n = 5</code> represents the time period to average over. The result is then stored in the <code class="literal">exponentialMovingAverage5</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; exponentialMovingAverage5 &lt;- EMA(Op(GSPC),n=5)</strong></span>
</pre><p>Printing the <code class="literal">exponentialMovingAverage5</code> data frame: The <code class="literal">head()</code> function returns the first part of the <code class="literal">exponentialMovingAverage5</code> data frame. The <code class="literal">exponentialMovingAverage5</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(exponentialMovingAverage5)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_013.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Exploring the summary of the change in prices. For this, the <code class="literal">summary()</code> function is used. This function provides a range of descriptive statistics to produce result summaries of the <code class="literal">exponentialMovingAverage5</code> data frame.</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(exponentialMovingAverage5)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_014.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Calculating the difference between the exponential opening price for <code class="literal">GSPC</code> and <code class="literal">exponentialMovingAverage5</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; exponentialMovingAverageDiff &lt;- Op(GSPC) - exponentialMovingAverage5</strong></span>
</pre><p>Now let's print the <code class="literal">exponentialMovingAverageDiff</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">exponentialMovingAverageDiff</code> data frame. The <code class="literal">exponentialMovingAverageDiff</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; head(exponentialMovingAverageDiff)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_015.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Exploring the summary of the change in prices: For this, the <code class="literal">summary()</code> function is used. This function provides a range of descriptive statistics to produce result summaries of the <code class="literal">exponentialMovingAverageDiff</code> data frame.</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(exponentialMovingAverageDiff)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_016.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>We will now compare the fast-moving average of a <code class="literal">GSPC</code> series with a slow-moving average for the <code class="literal">GSPC</code> series. To do this, <code class="literal">GSPC</code> is passed as the price matrix. <code class="literal">fast = 12</code> represents periods for the fast-moving average, <code class="literal">slow = 26</code> represents periods for the slow-moving average, and <code class="literal">signal = 9</code> represents the signal for the moving average:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MACD &lt;- MACD(Op(GSPC),fast = 12, slow = 26, signal = 9)</strong></span>
</pre><p>Printing the <code class="literal">MACD</code> data frame: The <code class="literal">tail()</code> function returns the last part of the <code class="literal">MACD</code> data frame. The <code class="literal">MACD</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; tail(MACD)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_017.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Exploring the summary of the change in prices with the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(MACD)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_018.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Next, we will grab the signal line to use as an indicator. The result is stored in the <code class="literal">MACDsignal</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; MACDsignal &lt;- MACD[,2]</strong></span>
</pre><p>Calculating the <span class="strong"><strong>Bollinger Bands</strong></span>: Theyare range-bound indicators that calculate the standard deviation from the moving average. Bollinger Bands operate under the logic that a currency pair's price is most likely to gravitate towards its average; thus when it strays too far, say two standard deviations away, it will fall back to its moving average. The <code class="literal">BBands()</code> function is used to calculate Bollinger Bands. <code class="literal">GSPC</code> is passed as an object and <code class="literal">n=20</code> indicates the number of periods for the moving average. <code class="literal">sd=2</code> indicates two standard deviations:</p><pre class="programlisting">
<span class="strong"><strong>&gt; BollingerBands &lt;- BBands(Op(GSPC),n=20,sd=2)</strong></span>
</pre><p>Now let's print the <code class="literal">BollingerBands</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; tail(BollingerBands)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_019.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Exploring the summary of the change in prices:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(BollingerBands)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_020.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Now let's grab the signal line from <code class="literal">BollingerBands</code> to use as an indicator:</p><pre class="programlisting">
<span class="strong"><strong>&gt; PercentageChngpctB &lt;- BollingerBands[,4]</strong></span>
</pre><p>Printing the <code class="literal">PercentageChngpctB</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; tail(PercentageChngpctB)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_021.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Exploring the summary of this change in <code class="literal">PercentageChngpctB</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(PercentageChngpctB)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_022.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Finding the difference between the closing and opening prices:</p><pre class="programlisting">
<span class="strong"><strong>&gt; Price &lt;- Cl(GSPC)-Op(GSPC)</strong></span>
</pre><p>Printing the <code class="literal">price</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; tail(Price)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_023.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Combining the <code class="literal">relativeStrengthIndex3</code>, <code class="literal">expMvAvg5Cross</code>, <code class="literal">MACDsignal</code>, and <code class="literal">PercentageChngpctB</code>, <code class="literal">Price</code> data frames: the result is then stored in the <code class="literal">DataSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; DataSet &lt;- data.frame(relativeStrengthIndex3, expMvAvg5Cross, MACDsignal, PercentageChngpctB, Price)</strong></span>
</pre><p>Exploring the internal structure of the <code class="literal">DataSet</code> data frame: The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">DataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>&gt; str(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_024.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Calculating the indicators, creating the dataset, and removing the points:</p><pre class="programlisting">
<span class="strong"><strong>&gt; DataSet &lt;- DataSet[-c(1:33),]</strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">DataSet</code> data frame: The <code class="literal">dim()</code> function returns the dimension of the <code class="literal">DataSet</code> frame. The <code class="literal">DataSet</code> data frame is passed as an input parameter. The result clearly states that there are 1,176 rows of data and 5 columns:</p><pre class="programlisting">
<span class="strong"><strong>&gt; dim(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_025.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Naming the columns: The <code class="literal">c()</code> function is used to combine the arguments into vectors:</p><pre class="programlisting">
<span class="strong"><strong>&gt; colnames(DataSet) &lt;- c("RSI3","EMAcross","MACDsignal","BollingerB","Price")</strong></span>
</pre><p>Exploring the dimensions of the <code class="literal">DataSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; str(DataSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_026.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p></div><div class="section" title="Step 4 - preparing data for model building"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec159"/>Step 4 - preparing data for model building</h3></div></div></div><p>Normalizing the dataset to be bound between 0 and 1:</p><pre class="programlisting">
<span class="strong"><strong>&gt; Normalized &lt;- function(x) {(x-min(x))/(max(x)-min(x))}</strong></span>
</pre><p>Calling the function to normalize the dataset:</p><pre class="programlisting">
<span class="strong"><strong>&gt; NormalizedData &lt;- as.data.frame(lapply(DataSet,Normalized))</strong></span>
</pre><p>Printing the <code class="literal">NormalizedData</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; tail(NormalizedData)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_027.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p><p>Building the training dataset: Data elements from <code class="literal">1:816</code> in the <code class="literal">NormalizedData</code> data frame will be used as the training dataset. The training dataset shall be stored in <code class="literal">TrainingSet</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; TrainingSet &lt;- NormalizedData[1:816,]</strong></span>
</pre><p>Exploring the dimension of the <code class="literal">TrainingSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; dim(TrainingSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_028.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p><p>Exploring the summary of the change in <code class="literal">TrainingSet</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(TrainingSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_029.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p><p>Building the testing dataset: Data elements from <code class="literal">817:1225</code> in the <code class="literal">NormalizedData</code> data frame will be used as the training dataset. This testing dataset shall be stored in <code class="literal">TestSet</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; TestSet &lt;- NormalizedData[817:1225 ,]</strong></span>
</pre><p>Exploring the dimension of the <code class="literal">TrainingSet</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; dim(TestSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_030.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p><p>Exploring the summary of the change in <code class="literal">TestSet</code>:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(TestSet)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_031.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p></div><div class="section" title="Step 5 - building the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec160"/>Step 5 - building the model</h3></div></div></div><p>Building the neural network: The <code class="literal">neuralnet()</code> function trains neural networks using a back-propagation algorithm without weight backtrackings. <code class="literal">Price~RSI3+EMAcross+MACDsignal+BollingerB</code> is a description of the model to be fitted. <code class="literal">data=TrainingSet</code> is the data frame containing the variables specified in the formula. <code class="literal">hidden=c(3,3)</code> specifies the number of hidden neurons (vertices) in each layer. <code class="literal">learningrate=.001</code> signifies the learning rate used by the back-propagation algorithm. <code class="literal">algorithm="backprop"</code> refers to the back propagation algorithm:</p><pre class="programlisting">
<span class="strong"><strong>&gt; nn1 &lt;- neuralnet(Price~RSI3+EMAcross+MACDsignal+BollingerB,data=TrainingSet, hidden=c(3,3), learningrate=.001,algorithm="backprop")</strong></span>
</pre><p>Plotting the neural network:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(nn1)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_032.jpg" alt="Step 5 - building the model"/></div><p>
</p></div></div></div>
<div class="section" title="Measuring the unemployment rate"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec51"/>Measuring the unemployment rate</h1></div></div></div><p>The unemployment rate is defined as the percentage of the total labor force that is unemployed, but actively seeking employment and willing to work. As defined by the <span class="strong"><strong>International Labor Organization </strong></span>(<span class="strong"><strong>ILO</strong></span>), an unemployed person is someone who is actively looking for work but does not have a job. The unemployment rate is a measure of the number of people who are both jobless <span class="emphasis"><em>and </em></span>looking for a job.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec64"/>Getting ready</h2></div></div></div><p>In order to perform a measurement of the unemployment rate using neural networks, we shall be using a dataset collected on the unemployment rate in Wisconsin.</p><div class="section" title="Step 1 - collecting and describing data"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec161"/>Step 1 - collecting and describing data</h3></div></div></div><p>For this, we will be using a CSV dataset titled <code class="literal">FRED-WIUR.csv</code>. There are 448 rows of data. There are two numeric variables as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Value</code></li></ul></div><p>This dataset shows the unemployment rate in Wisconsin between January 1, 1976 and April 1, 2013.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec65"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div class="section" title="Step 2 - exploring data"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec162"/>Step 2 - exploring data</h3></div></div></div><p>First, the following packages need to be loaded:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; install.packages("forecast ")</strong></span>
<span class="strong"><strong>    &gt; install.packages("lmtest") </strong></span>
<span class="strong"><strong>    &gt; install.packages("caret ")</strong></span>
<span class="strong"><strong>    &gt; library(forecast)</strong></span>
<span class="strong"><strong>    &gt; library(lmtest)</strong></span>
<span class="strong"><strong>    &gt; library(caret)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Version info: Code for this page was tested in R version 3.3.0</p></div></div><p>Let's explore the data and understand the relationships among the variables. We'll begin by importing the CSV data file named <code class="literal">FRED-WIUR.csv</code>. We will be saving the data to the <code class="literal">ud</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ud &lt;- read.csv("d:/FRED-WIUR.csv", colClasses=c('Date'='Date'))</strong></span>
</pre><p>Printing the <code class="literal">ud</code> data frame: The <code class="literal">tail()</code> function returns the last part of the <code class="literal">ud</code> data frame. The <code class="literal">ud</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<span class="strong"><strong>&gt; tail(ud)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_033.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Naming the columns: The <code class="literal">c()</code> function is used to combine the arguments into vectors:</p><pre class="programlisting">
<span class="strong"><strong>&gt; colnames(ud) &lt;- c('date', 'rate')</strong></span>
</pre><p>The <code class="literal">as.Date()</code> function is used to convert the character representation and objects of the <code class="literal">Date</code> class, which represents calendar dates:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ud$date &lt;- as.Date(ud$date)</strong></span>
</pre><p>Exploring the summary of unemployment data: For this, the <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">ud</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary (ud)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_034.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Now let's create base data from rows 1 to 436:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ud.b &lt;- ud[1:436,]</strong></span>
</pre><p>Exploring the summary of the base unemployment data. For this, the <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">ud.b</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(ud.b)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_035.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Now let's create the test data from rows 437 to 448:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ud.p &lt;- ud[437:448,]</strong></span>
</pre><p>Exploring the summary of the test unemployment data:</p><pre class="programlisting">
<span class="strong"><strong>&gt; summary(ud.p)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_036.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Creating the base time series data from 1976: <code class="literal">ts()</code> as a function creates time series objects. <code class="literal">ud.b$rate</code> represents the vector of observed time series values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ud.ts &lt;- ts(ud.b$rate, start=c(1976, 1), frequency=12)</strong></span>
</pre><p>Printing the value of the <code class="literal">ud.ts</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ud.ts</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_037.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Creating the test time series data: The <code class="literal">ts()</code> function creates time series objects. <code class="literal">ud.b$rate</code> represents the vector of observed time series values:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ud.p.ts &lt;- ts(ud.p$rate, start=c(2012, 5), frequency=12)</strong></span>
</pre><p>Printing the value of the <code class="literal">ud.ts</code> data frame:</p><pre class="programlisting">
<span class="strong"><strong>&gt; ud.ts</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_038.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Plotting the base time series data:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot.ts(ud.ts)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_039.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>Plotting the test time series data:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot.ts(ud.p.ts)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_040.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div class="section" title="Step 3 - preparing and verifying the models"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec163"/>Step 3 - preparing and verifying the models</h3></div></div></div><p>Calculating the mean of the base time series dataset. The <code class="literal">meanf()</code> function returns forecasts and prediction intervals for an <span class="strong"><strong>i.i.d</strong></span> model applied on the <code class="literal">ud.ts</code> dataset. <code class="literal">12</code> indicates the period for forecasting:</p><pre class="programlisting">
<span class="strong"><strong>&gt; mean &lt;- meanf(ud.ts, 12)</strong></span>
</pre><p>Forecasting and predicting the intervals for a random walk with a drift base time series. The <code class="literal">rwf()</code> function forecasts and returns for a random walk performed on the time series <code class="literal">ud.ts</code>. The parameter <code class="literal">12</code> indicates the period for forecasting:</p><pre class="programlisting">
<span class="strong"><strong>&gt; forecast_randomwalk &lt;- rwf(ud.ts, 12)</strong></span>
</pre><p>Forecasting and predicting intervals for a random walk from an ARIMA(0,0,0)(0,1,0)m base time series: The <code class="literal">snaive()</code> function forecasts and returns results for an ARIMA(0,0,0)(0,1,0)m performed on the time series <code class="literal">ud.ts</code>. The parameter <code class="literal">12</code> indicates the period for forecasting:</p><pre class="programlisting">
<span class="strong"><strong>&gt; forecast_arima &lt;- snaive(ud.ts, 12)</strong></span>
</pre><p>Forecasting and predicting the drift for the base time series. The <code class="literal">rwf()</code> function forecasts and returns for a random walk performed on the time series <code class="literal">ud.ts</code>. The parameter <code class="literal">12</code> indicates the period for forecasting. <code class="literal">drift=T</code> is a logical flag that fits a random walk with the drift model:</p><pre class="programlisting">
<span class="strong"><strong>&gt; drift &lt;- rwf(ud.ts, 12, drift=T)</strong></span>
</pre><p>Next, we will prepare linear fit models for the base time series data for trend. The <code class="literal">tslm()</code> function fits linear models to the <code class="literal">ud.ts</code> time series. <code class="literal">ud.ts~trend</code> is the formula that indicates that the trend components have to be taken into consideration:</p><pre class="programlisting">
<span class="strong"><strong>&gt; m1 &lt;- tslm(ud.ts~trend)</strong></span>
</pre><p>Preparing the linear fit models for the base time series data for trend and seasonality: The <code class="literal">tslm()</code> function fits linear models to <code class="literal">ud.ts</code> time series. <code class="literal">ud.ts~trend+season</code> is the formula that indicates that the trend and seasonality components have to be taken into consideration:</p><pre class="programlisting">
<span class="strong"><strong>&gt; m2 &lt;- tslm(ud.ts~trend+season)</strong></span>
</pre><p>
<code class="literal">residuals()</code> is a generic function that extracts model residuals from object <code class="literal">m1</code> after returned after fitting models for the base time series data for trend.</p><pre class="programlisting">
<span class="strong"><strong>&gt; residual_1 &lt;- residuals(m1)</strong></span>
</pre><p>Plotting the residual model:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(residual_1, ylab="Residuals",xlab="Year", title("Residual - Trends"), col = "red")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_041.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>Now let's look at how to estimate the <code class="literal">autocovariance</code> function. <code class="literal">residual_1</code> is the univariate numeric time series object:</p><pre class="programlisting">
<span class="strong"><strong>&gt; acf(residual_1, main="ACF of residuals")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_042.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>
<code class="literal">residuals()</code> is a generic function that extracts model residuals from object <code class="literal">m2</code> after returned after fitting models for base time series data for trend.</p><pre class="programlisting">
<span class="strong"><strong>&gt; residual_2 &lt;- residuals(m2)</strong></span>
</pre><p>Ploting the residual model:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(residual_2, ylab="Residuals",xlab="Year",title("Residual - Trends + Seasonality"), col = "red")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_043.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><pre class="programlisting">
<span class="strong"><strong>&gt; acf(residual_2, main="ACF of residuals")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_044.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>The Durbin-Watson test is performed to find out if the residuals from a linear regression or multiple regressions are independent. The hypotheses usually considered in the Durbin-Watson test are as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_045.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_046.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>The test statistics are given as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_047.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>In this equation, <span class="inlinemediaobject"><img src="graphics/image_10_048.jpg" alt="Step 3 - preparing and verifying the models"/></span>, <span class="inlinemediaobject"><img src="graphics/image_10_049.jpg" alt="Step 3 - preparing and verifying the models"/></span>is the observed value of for individual <span class="inlinemediaobject"><img src="graphics/image_10_050.jpg" alt="Step 3 - preparing and verifying the models"/></span>, and <span class="inlinemediaobject"><img src="graphics/image_10_051.jpg" alt="Step 3 - preparing and verifying the models"/></span> is the predicted value of for individual <span class="inlinemediaobject"><img src="graphics/image_10_052.jpg" alt="Step 3 - preparing and verifying the models"/></span>.</p><p>The value of <span class="inlinemediaobject"><img src="graphics/image_10_053.jpg" alt="Step 3 - preparing and verifying the models"/></span> decreases as the serial correlations increase. The upper and lower critical values, <span class="inlinemediaobject"><img src="graphics/image_10_054.jpg" alt="Step 3 - preparing and verifying the models"/></span> and <span class="inlinemediaobject"><img src="graphics/image_10_055.jpg" alt="Step 3 - preparing and verifying the models"/></span>, have been tabulated for different values of <span class="inlinemediaobject"><img src="graphics/image_10_056.jpg" alt="Step 3 - preparing and verifying the models"/></span>--the number of explanatory variables and <span class="inlinemediaobject"><img src="graphics/image_10_057.jpg" alt="Step 3 - preparing and verifying the models"/></span>:</p><p>If <span class="inlinemediaobject"><img src="graphics/image_10_058.jpg" alt="Step 3 - preparing and verifying the models"/></span> reject <span class="inlinemediaobject"><img src="graphics/image_10_059.jpg" alt="Step 3 - preparing and verifying the models"/></span>
</p><p>If <span class="inlinemediaobject"><img src="graphics/image_10_060.jpg" alt="Step 3 - preparing and verifying the models"/></span> do not reject <span class="inlinemediaobject"><img src="graphics/image_10_061.jpg" alt="Step 3 - preparing and verifying the models"/></span>
</p><p>If <span class="inlinemediaobject"><img src="graphics/image_10_062.jpg" alt="Step 3 - preparing and verifying the models"/></span> the test is inconclusive.</p><p>Performing the Durbin-Watson test on linear fit models for the base time series data for trend:</p><pre class="programlisting">
<span class="strong"><strong>&gt; dwtest(m1, alt="two.sided")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_063.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>Performing the Durbin-Watson test on linear fit models for the base time series data for trend and seasonality:</p><pre class="programlisting">
<span class="strong"><strong>    &gt; dwtest(m2, alt="two.sided")</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_064.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>Decomposing the base data time series into period, seasonal, trend, and irregular components using LOESS:</p><pre class="programlisting">
<span class="strong"><strong>&gt; m3 &lt;- stl(ud.ts, s.window='periodic')</strong></span>
</pre><p>Plotting the decomposed base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(m3)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_065.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>Performing the exponential smoothing state space model for the base data time series. The <code class="literal">ets()</code> function returns the <code class="literal">ets</code> model on the <code class="literal">ud.ts</code> time series. <code class="literal">ZZZ - "Z"</code> signifies an automatic selection. The first letter denotes the error type, the second letter denotes the trend type, and the third letter denotes the season type:</p><pre class="programlisting">
<span class="strong"><strong>&gt; m4 &lt;- ets(ud.ts, model='ZZZ')</strong></span>
</pre><p>Plotting the exponential smoothing state space model for the base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(m4)</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_066.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>Returning the order of a univariate ARIMA for the base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; m5 &lt;- auto.arima(ud.ts)</strong></span>
</pre><p>Ploting the univariate ARIMA for the base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(forecast(m5, h=12))</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_067.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>Building the feed-forward neural network model: The <code class="literal">nnetar()</code> function builds the feed-forward neural network with a single hidden layer and lagged inputs for forecasting the base data univariate time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; m6 &lt;- nnetar(ud.ts)</strong></span>
</pre><p>Printing the values of the feed-forward neural network model:</p><pre class="programlisting">
<span class="strong"><strong>&gt; m6</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_068.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>Plotting the feed-forward neural network model:</p><pre class="programlisting">
<span class="strong"><strong>&gt; plot(forecast(m6, h=12))</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_069.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p></div><div class="section" title="Step 4 - forecasting and testing the accuracy of the models built"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec164"/>Step 4 - forecasting and testing the accuracy of the models built</h3></div></div></div><p>Testing the accuracy of the mean value of the base data time series with the test data time series. The <code class="literal">accuracy()</code> function returns the range of summary measures of the forecast accuracy. <code class="literal">ud.p.ts</code> is the test data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a1 &lt;- accuracy(mean, ud.p.ts)</strong></span>
</pre><p>Testing the accuracy of the forecasted and predicted base data time series with a drift:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a2 &lt;- accuracy(forecast_randomwalk, ud.p.ts)</strong></span>
</pre><p>Testing the accuracy of the forecasted and predicted base data time series with an ARIMA(0,0,0)(0,1,0)m:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a3 &lt;- accuracy(forecast_arima, ud.p.ts)</strong></span>
</pre><p>Testing the accuracy of the drift of the base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a4 &lt;- accuracy(drift, ud.p.ts)</strong></span>
</pre><p>Combining the results in a table:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a.table &lt;- rbind(a1, a2, a3, a4)</strong></span>
</pre><p>Printing the result:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a.table</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_070.jpg" alt="Step 4 - forecasting and testing the accuracy of the models built"/></div><p>
</p><p>Forecasting the linear fit models for the base time series data for trend. <code class="literal">h=12</code> indicates the period of forecasting:</p><pre class="programlisting">
<span class="strong"><strong>&gt; f1 &lt;- forecast(m1, h=12)</strong></span>
</pre><p>Forecasting the linear fit models for the base time series data for trend and seasonality:</p><pre class="programlisting">
<span class="strong"><strong>&gt; f2 &lt;- forecast(m2, h=12)</strong></span>
</pre><p>Forecasting the decomposed base data time series into period, seasonal, trend, and irregular components using LOESS:</p><pre class="programlisting">
<span class="strong"><strong>&gt; f3 &lt;- forecast(m3, h=12)</strong></span>
</pre><p>Forecasting the exponential smoothing state space model for the base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; f4 &lt;- forecast(m4, h=12)</strong></span>
</pre><p>Forecasting the ordered univariate ARIMA for the base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; f5 &lt;- forecast(m5, h=12)</strong></span>
</pre><p>Forecasting the feed-forward neural network model with a single hidden layer:</p><pre class="programlisting">
<span class="strong"><strong>&gt; f6 &lt;- forecast(m6, h=12)</strong></span>
</pre><p>Testing the accuracy of the forecasted linear fit models for the base time series data for trend:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a5 &lt;- accuracy(f1, ud.p.ts)</strong></span>
</pre><p>Testing the accuracy of the forecasted linear fit models for the base time series data for trend and seasonality:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a6 &lt;- accuracy(f2, ud.p.ts)</strong></span>
</pre><p>Testing the accuracy of the forecasted decomposed base data time series into period, seasonal, trend, and irregular components using LOESS:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a7 &lt;- accuracy(f3, ud.p.ts)</strong></span>
</pre><p>Testing the accuracy of the forecasted exponential smoothing state space model for the base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a8 &lt;- accuracy(f4, ud.p.ts)</strong></span>
</pre><p>Testing the accuracy of the forecasted ordered univariate ARIMA for the base data time series:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a9 &lt;- accuracy(f5, ud.p.ts)</strong></span>
</pre><p>Testing the accuracy of the forecasted feed-forward neural network model with a single hidden layer:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a10 &lt;- accuracy(f6, ud.p.ts)</strong></span>
</pre><p>Combining the results in a table:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a.table.1 &lt;- rbind(a5, a6, a7, a8, a9, a10)</strong></span>
</pre><p>Printing the result:</p><pre class="programlisting">
<span class="strong"><strong>&gt; a.table.1</strong></span>
</pre><p>The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_071.jpg" alt="Step 4 - forecasting and testing the accuracy of the models built"/></div><p>
</p></div></div></div></body></html>