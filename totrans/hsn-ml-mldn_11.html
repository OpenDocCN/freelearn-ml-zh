<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using ML.NET with .NET Core and Forecasting</h1>
                </header>
            
            <article>
                
<p>Now that we have completed our deep dive into the various groups of algorithms ML.NET offers, we will begin to explore integrating ML.NET into a production application over the next few chapters. In this chapter, we will deep dive into a .NET Core console application building on the structure defined in previous chapters with a focus on hardening and error handling. The application we will be building uses forecasting to predict stock prices based on a series of trends. By the end of this chapter, you should have a firm grasp of designing and coding a production-grade .NET Core application with ML.NET.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Breaking down the .NET Core application architecture</li>
<li>Creating the forecasting application</li>
<li>Exploring additional production application enhancements</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking down the .NET Core application architecture</h1>
                </header>
            
            <article>
                
<p>As<span> </span>mentioned in<span> </span><a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">Chapter 1</a>, <em>Getting Started with Machine Learning and ML.NET,</em><span> .NET Core 3.x is the preferred platform for using ML.NET due to the optimization done in the 3.0 release. In addition, .NET Core provides a singular coding framework to target Linux, macOS, and Windows, as noted in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-619 image-border" src="assets/ea346e36-c0a4-4e3e-9056-f9501455b5e4.png" style="width:17.75em;height:8.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">.NET Core architecture</h1>
                </header>
            
            <article>
                
<p>From its inception in 2016, the underlying goals of .NET Core have been to provide rapid updates and feature parity with (<span>the </span>previously Windows-only) Microsoft .NET Framework. Over time and versions, the gap has gotten smaller by simply adding the APIs that were missing<span>, using additional NuGet packages</span>. One such example of this is <kbd>Microsoft.Windows.Compatibility</kbd> that provides 20,000 APIs not found in the Core framework including registry access, drawing, and Windows Permission Model access. This approach keeps the framework light and cross-platform but does introduce some design patterns to help you to develop your platform-specific applications.</p>
<p>Take, for instance, a Windows Desktop application that uses ML.NET to provide an <strong>Intrusion Detection System</strong> (<strong>IDS</strong>). A simple approach would be to write all of the code in a .NET Core <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) application. However, this would tie you to Windows only without doing major refactoring. A better approach would be to create a .NET Core class library that contains all platform-agnostic code and then creates abstract classes or interfaces to implement the platform-specific code inside your platform application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">.NET Core targets</h1>
                </header>
            
            <article>
                
<p>As mentioned previously, .NET Core offers a single framework to target Windows, macOS, and Linux. However, this doesn't just apply to console applications as we have used throughout this book. Recent work in .NET Core 3 has provided the ability to port existing .NET Framework WPF and Windows Forms applications to .NET Core 3, thereby enabling applications that rely on potentially years-old frameworks to use the latest .NET Core advancements. In addition, web applications that previously used ASP.NET can be migrated over to ASP.NET Core (ASP.NET WebForms does not currently have a migration path).</p>
<p>Another benefit of .NET Core targeting is the ability to compile with the <kbd>--self-contained</kbd> flag. This flag compiles your application or library and then bundles all necessary .NET Core framework files. This allows you to deploy your application without a .NET prerequisite during install. This does make your overall build output larger, but in a customer scenario, a ~100MB increase far outweighs the deployment hurdles of prerequisites.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">.NET Core future</h1>
                </header>
            
            <article>
                
<p>You might wonder what the future of .NET Framework, Mono, and .NET Core is. Fortunately, Microsoft, at the time of this writing, has confirmed that all existing frameworks will be migrated into a singular framework simply called .NET 5. Previously, when making a decision on which framework to use, certain trade-offs were guaranteed. Hence, taking the benefits of each framework and unifying them for the first time will eliminate these trade-offs entirely. Take, for instance, Mono's <strong>Ahead-Of-Time</strong> (<strong>AOT</strong>) compilation or Xamarin's cross-platform UI support, which can be utilized inside an existing .NET Core 3.x application based on the information released.</p>
<div class="packt_infobox">A preview of .NET 5 is expected in the first half of 2020, with a production release in November 2020.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the stock price estimator application</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the application we will be creating is a stock price estimator. Given a set of stock prices across days, weeks, or years, the forecasting algorithm will internally identify trending patterns. Unlike previous chapters, the application will be architected to be plugged into a production pipeline.</p>
<p>As with previous chapters, the completed project code, sample dataset, and project files can be downloaded from: <a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08">https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the project architecture</h1>
                </header>
            
            <article>
                
<p>Building upon the project architecture and code we created in previous chapters, the architecture we will be exploring in this chapter further enhances the architecture to be more structured and thereby more usable for an end user.</p>
<p>Like in some of the previous chapters, an additional NuGet package—<kbd>Microsoft.ML.TimeSeries</kbd>—is required to utilize the forecasting functionality in ML.NET. Version 1.3.1 is used in both the included example on GitHub and throughout this chapter's deep dive.</p>
<p>In the following screenshot, you will find the Visual Studio Solution Explorer view of the project. There are several new additions to the solution to facilitate the production use case we are targeting. We will review in detail each of the new files shown in the solution screenshot here later on in this chapter:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-620 image-border" src="assets/fa567181-ad7a-4d3d-b62c-265416c722f1.png" style="width:16.75em;height:32.08em;"/></p>
<p>The<span> </span><kbd>sampledata.csv</kbd> file contains 24 rows of stock prices. Feel free to adjust the data to fit your own observations or to adjust the trained model. Here is a snippet of the data:</p>
<div>
<pre>33<br/>34<br/>301<br/>33<br/>44<br/>299<br/>40<br/>50<br/>400<br/>60<br/>76<br/>500</pre></div>
<p>Each of these rows contains the stock price value we will populate into a <kbd>StockPrices</kbd> class object that we will review later on in this chapter.</p>
<p>In addition to this, we added the <kbd>testdata.csv</kbd> file that contains additional data points to test the newly trained model<span> </span>against and evaluate it. Here is a snippet of the data inside of <kbd>testdata.csv</kbd>:</p>
<pre>10<br/>25<br/>444<br/>9<br/>11<br/>333<br/>4<br/>3<br/>500</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the code</h1>
                </header>
            
            <article>
                
<p>For this application, as noted in the previous section, we are building on top of the work<span> </span>completed in previous chapters. However, for this chapter, we will be changing every file to support production use cases. For each file changed from previous chapters, we will review the changes made and the reasoning behind these changes.</p>
<p>Classes and enumerations that were changed or added are as follows:</p>
<ul>
<li><kbd>ProgramActions</kbd></li>
<li><kbd>CommandLineParser</kbd></li>
<li><kbd>BaseML</kbd></li>
<li><kbd>StockPrediction</kbd></li>
<li><kbd>StockPrices</kbd></li>
<li><kbd>Predictor</kbd></li>
<li><kbd>Trainer</kbd></li>
<li><kbd>ProgramArguments</kbd></li>
<li><kbd>Program</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ProgramActions enumeration</h1>
                </header>
            
            <article>
                
<p>The following <kbd>ProgramActions</kbd> enumeration has been added to the solution to facilitate the use of a strongly typed and structured path for handling various actions the program performs:</p>
<pre>namespace chapter08.Enums<br/>{<br/>    public enum ProgramActions<br/>    {<br/>        TRAINING,<br/>        PREDICT<br/>    }<br/>}</pre>
<p>In the case of this application, we only have two actions—<kbd>Training</kbd> and <kbd>Predicting</kbd>. However, as shown in previous chapters, you might also have a feature extraction step or maybe provide an evaluation step. This design pattern allows flexibility while also removing the <strong>magic strings</strong> problem mentioned at the beginning of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The CommandLineParser class</h1>
                </header>
            
            <article>
                
<p>The <kbd>CommandLineParser</kbd> class provides a program-agnostic parser for handling command-line arguments. In previous chapters, we were manually parsing the indexes and mapping those values to arguments. On the other hand, this approach creates a flexible, easy-to-maintain and structured response object that maps arguments directly to the properties. Let's now dive into the class:</p>
<ol>
<li>First,<span> we define the function prototype:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">public static T ParseArguments&lt;T&gt;(string[] args) </pre>
<p style="padding-left: 60px">The use of generics (that is, <kbd>T</kbd>) creates a flexible approach to making this method unconstrained to just this application.</p>
</div>
<ol start="2">
<li>Next, we test for <kbd>null</kbd> arguments:</li>
</ol>
<div>
<pre style="padding-left: 60px">if (args == null)<br/>{<br/>    throw new ArgumentNullException(nameof(args));<br/>}</pre></div>
<ol start="3">
<li><span>Then, we test for empty arguments and let the user know default values are going to be used instead of failing, as in previous chapters:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">if (args.Length == 0)<br/>{<br/>    Console.WriteLine("No arguments passed in - using defaults");<br/><br/>    return Activator.CreateInstance&lt;T&gt;();<br/>}</pre></div>
<ol start="4">
<li>After null and empty checks are performed, we then perform a multiple of two checks since all arguments are pairs:</li>
</ol>
<pre style="padding-left: 60px">if (args.Length % 2 != 0)<br/>{<br/>    throw new ArgumentException($"Arguments must be in pairs, there were {args.Length} passed in");<br/>}</pre>
<ol start="5">
<li>Continuing, we then create an object of the <kbd>T</kbd><strong> </strong>type using the <kbd>Activator.CreateInstance</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">var argumentObject = Activator.CreateInstance&lt;T&gt;();</pre>
<p style="padding-left: 60px">Ensure that, when creating class objects, the constructor has no arguments as this call would throw an exception if so. If you create an object with constructor parameters and without a parameterless constructor, use the overload of <kbd>Activator.CreateInstance</kbd> and pass in the required parameters.</p>
<ol start="6">
<li>Next, we utilize reflection to grab all of the properties of the <kbd>T</kbd> type:</li>
</ol>
<pre style="padding-left: 60px">var properties = argumentObject.GetType().GetProperties();</pre>
<ol start="7">
<li>Now that we have both the generic object created and the properties of that object, we then loop through each of the argument key/value pairs and set the property in the object:</li>
</ol>
<pre style="padding-left: 60px">for (var x = 0; x &lt; args.Length; x += 2)<br/>{<br/>    var property = properties.FirstOrDefault(a =&gt; a.Name.Equals(args[x], StringComparison.CurrentCultureIgnoreCase));<br/><br/>    if (property == null)<br/>    {<br/>        Console.WriteLine($"{args[x]} is an invalid argument");<br/><br/>        continue;<br/>    }<br/><br/>    if (property.PropertyType.IsEnum)<br/>    {<br/>        property.SetValue(argumentObject, Enum.Parse(property.PropertyType, args[x + 1], true));<br/>    }<br/>    else<br/>    {<br/>        property.SetValue(argumentObject, args[x + 1]);<br/>    }<br/>}</pre>
<p>Note the special case for the <kbd>IsEnum</kbd> function to handle our previously covered <kbd>ProgramActions</kbd> enumeration. Since a string value cannot be automatically converted to an enumeration, we needed to handle the string-to-enumeration conversion specifically with the <kbd>Enum.Parse</kbd> method. As written, the enumeration handler is generic if you add more enumerations to the <kbd>T</kbd><span> </span><span>type</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The BaseML class</h1>
                </header>
            
            <article>
                
<p>The <kbd>BaseML</kbd> class for this application has been streamlined to simply instantiate the <kbd>MLContext</kbd> object:</p>
<pre>using Microsoft.ML;<br/><br/>namespace chapter08.ML.Base<br/>{<br/>    public class BaseML<br/>    {<br/>        protected readonly MLContext MlContext;<br/><br/>        protected BaseML()<br/>        {<br/>            MlContext = new MLContext(2020);<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The StockPrediction class</h1>
                </header>
            
            <article>
                
<p>The <kbd>StockPrediction</kbd> class is the container for our prediction values, as defined here:</p>
<pre>namespace chapter08.ML.Objects<br/>{<br/>    public class StockPrediction<br/>    {<br/>        public float[] StockForecast { get; set; }<br/><br/>        public float[] LowerBound { get; set; }<br/><br/>        public float[] UpperBound { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>StockForecast</kbd> property will hold our predicted stock values based on the model training and submitted value to the prediction engine. The <kbd>LowerBound</kbd> and <kbd>UpperBound</kbd> values hold the lowest and highest estimated values respectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The StockPrices class</h1>
                </header>
            
            <article>
                
<p>The <kbd>StockPrices</kbd> class contains our single floating-point value holding the stock price. To keep the code cleaner when populating the values, a constructor accepting the stock price value has been added:</p>
<pre>using Microsoft.ML.Data;<br/><br/>namespace chapter08.ML.Objects<br/>{<br/>    public class StockPrices<br/>    {<br/>        [LoadColumn(0)]<br/>        public float StockPrice;<br/><br/>        public StockPrices(float stockPrice)<br/>        {<br/>            StockPrice = stockPrice;<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Predictor class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Predictor</kbd> class, in comparison to previous chapters, has been streamlined and adapted to support forecasting:</p>
<ol>
<li>First,<span> we adjust the <kbd>Predict</kbd> method to accept the newly defined <kbd>ProgramArguments</kbd> class object:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">public void Predict(ProgramArguments arguments)   </pre></div>
<ol start="2">
<li>Next, we update the model <kbd>file.Exists</kbd> check to utilize the <kbd>arguments</kbd> object:</li>
</ol>
<div>
<pre style="padding-left: 60px">if (!File.Exists(arguments.ModelFileName))<br/>{<br/>    Console.WriteLine($"Failed to find model at {arguments.ModelFileName}");<br/><br/>    return;<br/>}</pre></div>
<ol start="3">
<li><span>Similarly, we also update the prediction filename reference to the utilize the <kbd>arguments</kbd> object</span><span>:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">if (!File.Exists(arguments.PredictionFileName))<br/>{<br/>    Console.WriteLine($"Failed to find input data at {arguments.PredictionFileName}");<br/><br/>    return;<br/>}</pre></div>
<ol start="4">
<li>Next, we also modify the model open call to utilize the <kbd>arguments</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">using (var stream = new FileStream(Path.Combine(AppContext.BaseDirectory, arguments.ModelFileName), FileMode.Open, FileAccess.Read, FileShare.Read))<br/>{<br/>    mlModel = MlContext.Model.Load(stream, out _);<br/>}</pre>
<ol start="5">
<li>We then create the Time Series Engine object with our <kbd>StockPrices</kbd> and <kbd>StockPrediction</kbd> types:</li>
</ol>
<pre style="padding-left: 60px">var predictionEngine = mlModel.CreateTimeSeriesEngine&lt;StockPrices, StockPrediction&gt;(MlContext);</pre>
<ol start="6">
<li>Next, we read the stock price prediction file into a string array:</li>
</ol>
<pre style="padding-left: 60px">var stockPrices = File.ReadAllLines(arguments.PredictionFileName);</pre>
<ol start="7">
<li>Lastly, we iterate through each input, call the prediction engine, and display the estimated values:</li>
</ol>
<pre style="padding-left: 60px">foreach (var stockPrice in stockPrices)<br/>{<br/>    var prediction = predictionEngine.Predict(new StockPrices(Convert.ToSingle(stockPrice)));<br/><br/>    Console.WriteLine($"Given a stock price of ${stockPrice}, the next 5 values are predicted to be: " +<br/>                      $"{string.Join(", ", prediction.StockForecast.Select(a =&gt; $"${Math.Round(a)}"))}");<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Trainer class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Trainer</kbd> class, akin to the <kbd>Predictor</kbd> class, received both streamlining and changes to account for the ML.NET forecasting algorithm:</p>
<ol>
<li>First,<span> update the function prototype to take the <kbd>ProgramArguments</kbd> object:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">public void Train(ProgramArguments arguments)     </pre></div>
<ol start="2">
<li>Next, we update the training file check to utilize the <kbd>argument</kbd> object:</li>
</ol>
<div>
<pre style="padding-left: 60px">if (!File.Exists(arguments.TrainingFileName))<br/>{<br/>    Console.WriteLine($"Failed to find training data file ({arguments.TrainingFileName})");<br/><br/>    return;<br/>}</pre></div>
<ol start="3">
<li>Similarly, we then update the testing file check to utilize the <kbd>argument</kbd> object:</li>
</ol>
<div>
<pre style="padding-left: 60px">if (!File.Exists(arguments.TestingFileName))<br/>{<br/>    Console.WriteLine($"Failed to find test data file ({arguments.TestingFileName})");<br/><br/>    return;<br/>}</pre></div>
<ol start="4">
<li>Next, we load the <kbd>StockPrices</kbd> values from the training file:</li>
</ol>
<pre style="padding-left: 60px">var dataView = MlContext.Data.LoadFromTextFile&lt;StockPrices&gt;(arguments.TrainingFileName);</pre>
<ol start="5">
<li>We then create the <kbd>Forecasting</kbd> object and utilize the <kbd>nameof</kbd><strong> </strong>C# feature to avoid magic string references:</li>
</ol>
<pre style="padding-left: 60px">var model = MlContext.Forecasting.ForecastBySsa(<br/>    outputColumnName: nameof(StockPrediction.StockForecast),<br/>    inputColumnName: nameof(StockPrices.StockPrice), <br/>    windowSize: 7, <br/>    seriesLength: 30, <br/>    trainSize: 24, <br/>    horizon: 5,<br/>    confidenceLevel: 0.95f,<br/>    confidenceLowerBoundColumn: nameof(StockPrediction.LowerBound),<br/>    confidenceUpperBoundColumn: nameof(StockPrediction.UpperBound));</pre>
<p style="padding-left: 60px">The input and output column name references are as we have seen in previous chapters. The <kbd>windowSize</kbd> property is the duration between the data points in the training set. For this application, we are using <kbd>7</kbd> to indicate a week's duration. The <kbd>seriesLength</kbd><strong> </strong>property indicates the total duration of the dataset in this case. The <kbd>horizon</kbd> property indicates how many predicted values should be calculated when the model is run. In our case, we are asking for <kbd>5</kbd> predicted values.</p>
<ol start="6">
<li>Lastly, we transform the model with the training data, call the <kbd>CreateTimeSeriesEngine</kbd> method, and write the model to disk:</li>
</ol>
<pre style="padding-left: 60px">var transformer = model.Fit(dataView);<br/><br/>var forecastEngine = transformer.CreateTimeSeriesEngine&lt;StockPrices, StockPrediction&gt;(MlContext);<br/><br/>forecastEngine.CheckPoint(MlContext, arguments.ModelFileName);<br/><br/>Console.WriteLine($"Wrote model to {arguments.ModelFileName}");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ProgramArguments class</h1>
                </header>
            
            <article>
                
<p>This new class, as referred to earlier in this section, provides the one-to-one mapping of arguments to properties used throughout the application:</p>
<ol>
<li>First,<span> we define the properties that map directly to the command-line arguments:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">public ProgramActions Action { get; set; }<br/><br/>public string TrainingFileName { get; set; }<br/><br/>public string TestingFileName { get; set; }<br/><br/>public string PredictionFileName { get; set; }<br/><br/>public string ModelFileName { get; set; }</pre></div>
<ol start="2">
<li>Lastly, we populate default values for the properties:</li>
</ol>
<div>
<pre style="padding-left: 60px">public ProgramArguments()<br/>{<br/>    ModelFileName = "chapter8.mdl";<br/><br/>    PredictionFileName = @"..\..\..\Data\predict.csv";<br/><br/>    TrainingFileName = @"..\..\..\Data\sampledata.csv";<br/><br/>    TestingFileName = @"..\..\..\Data\testdata.csv";<br/>}</pre></div>
<p>Unlike previous chapters, if any property was not set as expected, the program would fail. This is fine for the developer experience; however, in the real world, end users will more than likely attempt to just run the application without any parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Program class</h1>
                </header>
            
            <article>
                
<p>Inside the <kbd>Program</kbd> class, the code has been simplified to utilize the new <kbd>CommandLineParser</kbd> class discussed earlier in this chapter. With the use of the <kbd>CommandLineParser</kbd> class, all of the actions have been switched to utilize strongly-typed enumerations:</p>
<ol>
<li>First, while relatively simplistic, clearing the screen of any previous run data is an improved UX:</li>
</ol>
<div>
<pre style="padding-left: 60px">Console.Clear();</pre></div>
<ol start="2">
<li>We then use our new <kbd>CommandLineParser</kbd> class and associated <kbd>ParseArguments</kbd> method to create a strongly-typed argument object:</li>
</ol>
<div>
<pre style="padding-left: 60px">var arguments = CommandLineParser.ParseArguments&lt;ProgramArguments&gt;(args);</pre></div>
<ol start="3">
<li>We then can use a simplified and strongly typed switch case to handle our two actions:</li>
</ol>
<div>
<pre style="padding-left: 60px">switch (arguments.Action)<br/>{<br/>    case ProgramActions.PREDICT:<br/>        new Predictor().Predict(arguments);<br/>        break;<br/>    case ProgramActions.TRAINING:<br/>        new Trainer().Train(arguments);<br/>        break;<br/>    default:<br/>        Console.WriteLine($"Unhandled action {arguments.Action}");<br/>        break;<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p><span>To run the application, the process is nearly identical to the</span><span> </span><span>sample application in </span><span><a href="8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml">Chapter 3</a>, <em>Regression Model</em>, with the addition of passing in the test dataset when training:</span></p>
<ol>
<li>Running the application without any arguments to train the model, we use the following step:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS chapter08\bin\Debug\netcoreapp3.0&gt; .\chapter08.exe</strong><br/>No arguments passed in - using defaults<br/>Wrote model to chapter8.mdl</pre></div>
<ol start="2">
<li>Running the application to make predicitons based on the included prediction data<span>, we use the following step</span>:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS chapter08\bin\Debug\netcoreapp3.0&gt; .\chapter08.exe action predict</strong><br/>Given a stock price of $101, the next 5 values are predicted to be: $128, $925, $140, $145, $1057<br/>Given a stock price of $102, the next 5 values are predicted to be: $924, $138, $136, $1057, $158<br/>Given a stock price of $300, the next 5 values are predicted to be: $136, $134, $852, $156, $150<br/>Given a stock price of $40, the next 5 values are predicted to be: $133, $795, $122, $149, $864<br/>Given a stock price of $30, the next 5 values are predicted to be: $767, $111, $114, $837, $122<br/>Given a stock price of $400, the next 5 values are predicted to be: $105, $102, $676, $116, $108<br/>Given a stock price of $55, the next 5 values are predicted to be: $97, $594, $91, $103, $645<br/>Given a stock price of $69, the next 5 values are predicted to be: $557, $81, $87, $605, $90<br/>Given a stock price of $430, the next 5 values are predicted to be: $76, $78, $515, $84, $85</pre></div>
<p>Feel free to modify the values and see how the prediction changes based on the dataset that the model was trained on. A few areas of experimentation from this point might be to do the following:</p>
<ul>
<li>Tweak the hyperparameters reviewed in the <kbd>Trainer</kbd> class, such as the <kbd>windowSize</kbd>, <kbd>seriesLength</kbd>, or <kbd>horizon</kbd> properties, to see how accuracy is affected.</li>
<li>Add significantly more data points—this may utilize a data feed of your favorite stock you watch.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring additional production application enhancements</h1>
                </header>
            
            <article>
                
<p>Now that we have completed our deep dive, there are a couple of additional elements to possibly further enhance the application. A few ideas are discussed here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging</h1>
                </header>
            
            <article>
                
<p>Logging utilizing NLog (<a href="https://nlog-project.org/">https://nlog-project.org/</a>) or a similar open source project is highly recommended as your application complexity increases. This will allow you to log to a file, console, or third-party logging solution such as Loggly at varying levels. For instance, if you deploy this application to a customer, breaking down the error level to at least Debug, Warning, and Error will be helpful when debugging issues remotely.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing Reflection further</h1>
                </header>
            
            <article>
                
<p>As noted earlier in this section to create flexibility and adaptability, we utilized <kbd>Reflection</kbd> to parse the command-line arguments. You could take this a step further and replace the switch case statement/standard flow in the <kbd>Program</kbd> class with an entirely reflection-based approach, meaning for every action defined in the application, it could inherit from an abstract <kbd>BaseAction</kbd> class and at runtime, based on the argument, call the appropriate class. For every new action, simply adding a new entry to the <kbd>ProgramActions</kbd> enumeration and then defining a class with that enumeration would be all that is required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing a database</h1>
                </header>
            
            <article>
                
<p>In a real-world scenario, the data provided to run predictions will more than likely come from a database. This database, whether it is a <span>Postgres</span>, SQL Server, or <span>SQLite </span>database (to name a few), can be accessed with Microsoft's Entity Framework Core or with ML.NET's built-in database loader method—<kbd><span>CreateDatabaseLoader</span></kbd><span>. This loader is akin to how we have loaded data from enumerable or text files with the extra steps of injecting SQL queries. </span></p>
<p><span>In a production scenario, given Entity Framework Core's performance and ability to use LINQ instead of plaintext over ML.NET's implementation (at the time of this writing), I would recommend using Entity Framework if database sources are utilized.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, we have deep-dived into what goes into a production-ready .NET Core application architecture using the work performed in previous chapters as a foundation. We also created a brand new stock price estimator using the forecasting algorithm in ML.NET. Lastly, we discussed some ways to further enhance a .NET Core application (and production applications in general).</p>
<p>In the next chapter, we will deep dive into creating a production-file-classification web application using ML.NET's binary classification and ASP.NET Core's framework.</p>


            </article>

            
        </section>
    </body></html>