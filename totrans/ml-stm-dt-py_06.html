<html><head></head><body>
		<div id="_idContainer055">
			<h1 id="_idParaDest-84"><em class="italic"><a id="_idTextAnchor083"/>Chapter 4</em>: Online Learning with River</h1>
			<p>In this and the coming three chapters, you will learn how to work with a library for online machine learning called River. Online machine learning is a part of machine learning in which models are designed in such a way that they can update their learned model on the reception of any new data point.</p>
			<p>Online machine learning is the opposite of offline machine learning, which is the regular machine learning that you are probably already aware of. In general, in machine learning, a model will try to learn a mathematical rule that can perform a certain task. This task is learned on the basis of a number of data points. The mathematics behind these tasks is based on statistics and algorithmics.</p>
			<p>In this chapter, you will discover how to work with online machine learning, and you will discover multiple types of online machine learning. You will go more in depth into the differences between online and offline machine learning. You will also see how to build online machine learning models using River in Python.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>What is online machine learning?</li>
				<li>River for online learning</li>
				<li>A super simple example with River</li>
				<li>A second example with River</li>
			</ul>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>You can find all the code for this book on GitHub at the following link: <a href="https://github.com/PacktPublishing/Machine-Learning-for-Streaming-Data-with-Python">https://github.com/PacktPublishing/Machine-Learning-for-Streaming-Data-with-Python</a>. If you are not yet familiar with Git and GitHub, the easiest way to download the notebooks and code samples is the following:</p>
			<ol>
				<li>Go to the link of the repository.</li>
				<li>Go to the green <strong class="bold">Code</strong> button.</li>
				<li>Select <strong class="bold">Download ZIP</strong>.</li>
			</ol>
			<p>When you download the ZIP file, unzip it in your local environment, and you will be able to access the code through your preferred Python editor.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Python environment</h2>
			<p>To follow along with this book, you can download the code in the repository and execute it using your preferred Python editor.</p>
			<p>If you are not yet familiar with Python environments, I would advise you to check out Anaconda (<a href="https://www.anaconda.com/products/individual">https://www.anaconda.com/products/individual</a>), which comes with the Jupyter Notebook and JupyterLabs, which are both great for executing notebooks. It also comes with Spyder and VSCode for editing scripts and programs.</p>
			<p>If you have difficulty installing Python or the associated programs on your machine, you can check out Google Colab (<a href="https://colab.research.google.com/">https://colab.research.google.com/</a>) or Kaggle Notebooks (<a href="https://www.kaggle.com/code">https://www.kaggle.com/code</a>), which both allow you to run Python code in online notebooks for free, without any setup to do.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code in the book will generally use Colab and Kaggle notebooks with Python version 3.7.13 and you can set up your own environment to mimic this. </p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>What is online machine learning?</h1>
			<p>In machine learning, the <a id="_idIndexMarker225"/>most common way to train a model is to do a single training pass. The general steps in this approach are as follows:</p>
			<ol>
				<li value="1">Data preparation.</li>
				<li>Create a train-test split.</li>
				<li>Do model benchmarking and hyperparameter tuning.</li>
				<li>Select the best model.</li>
				<li>Move this model to production.</li>
			</ol>
			<p>This approach is called <strong class="bold">offline learning</strong>.</p>
			<p>With streaming data, you can<a id="_idIndexMarker226"/> often use this type of model very well. You can build the model once, deploy it, and use it for predicting your input stream. You can probably track the performance metrics of your model, and when the performance starts to change, you can do an update or <a id="_idIndexMarker227"/>retraining of your model, deploy the new version, and let it set in the production environment as long as it works.</p>
			<p>Online machine learning is a branch of machine learning that contains models that work very differently. They do not learn a full dataset at once, but rather, update the learned model (the decision rules for prediction) through sequential steps. Using such an approach, you can automatically update your model that is in production; it continues to learn on new data.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>How is online learning different from regular learning?</h2>
			<p>The practice of <a id="_idIndexMarker228"/>building online learning systems takes a different angle at the machine learning problem than the offline machine learning approach. With<a id="_idIndexMarker229"/> offline learning, there is a real possibility to test what a model has learned, whereas, for online learning systems, this can change at any moment.</p>
			<p>For some use cases, it is impossible to use offline learning. An example is forecasting use cases. In general, for forecasting, you predict a value in the future. To do so, you use the most recent data available to train and retrain your model. In many forecasting applications, machine learning models are retrained every time a new forecast must be predicted.</p>
			<p>Outlier detection is another example where offline learning can be less appropriate. If your model does not integrate each new data point, these data points cannot be used as reference cases against new values. This can be solved through offline learning as well, but online learning may be the more appropriate solution to tackle this use case.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Advantages of online learning</h2>
			<p>Online learning has<a id="_idIndexMarker230"/> two main advantages:</p>
			<ul>
				<li>The first main advantage is that online learning algorithms can be updated. They can, therefore, learn in multiple passes. This way, a big dataset does not have to pass at once in a model but can be passed in multiple steps. This is a big advantage when the datasets are large, or when the computing resources are limited.</li>
				<li>The second advantage of online learning is that an online model can adapt to newer processes when updating: it is less fixed. Therefore, where an offline model can become <a id="_idIndexMarker231"/>obsolete when data trends change slightly over time, an online model can adapt to these changes and remain performant.</li>
			</ul>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Challenges of online learning</h2>
			<p>However, there are also <a id="_idIndexMarker232"/>disadvantages to using online learning.</p>
			<p>First, the concept is less widespread, and it will be a bit harder to find model implementations and documentation for online learning use cases.</p>
			<p>Second, and more important, online learning has a risk of models learning things that you don't want them to learn or things that are wrong. With offline learning, you have much more control to validate what a model learns before pushing it to a production environment, whereas when pushing online learning to production environments, it may well continue to learn and decrease in performance due to the updates that it has learned.</p>
			<p>Now that you understand the concept of online learning, let's now discover multiple types of online learning.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Types of online learning</h2>
			<p>Although there is<a id="_idIndexMarker233"/> no clearly defined distinction in types of online machine learning, it is good to consider at least the following three terms: incremental learning, adaptive learning, and reinforcement learning.</p>
			<h3>Incremental learning</h3>
			<p><strong class="bold">Incremental learning</strong> methods are models that can be updated with a single observation at a time. As described <a id="_idIndexMarker234"/>previously, one of the main added <a id="_idIndexMarker235"/>values of online machine learning is this, as this is something that is not possible with standard offline learning.</p>
			<h3>Adaptive learning</h3>
			<p>Just updating the model, however, may not be enough for the second important added value of online<a id="_idIndexMarker236"/> learning that was cited before. If you want a model to adapt well to more recent data, you will have to choose an <strong class="bold">adaptive</strong> online learning method. These <a id="_idIndexMarker237"/>methods deal well with any situation that would need a model to adapt, for example, new trends that appear in the underlying data before people even become aware of them.</p>
			<h3>Reinforcement learning</h3>
			<p><strong class="bold">Reinforcement learning</strong> is not necessarily considered a subfield of online learning. Although the approach of<a id="_idIndexMarker238"/> reinforcement learning is different than the previously cited online learning approaches, it can be used for the <a id="_idIndexMarker239"/>same business problems. It is, therefore, important to learn about reinforcement learning as well. It will be covered in more depth in a later chapter. In the coming section, you will see how to use the River package in Python to build online machine learning models.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Using River for online learning</h1>
			<p>In this section, you <a id="_idIndexMarker240"/>will discover the River library for online learning. River is a Python library that is made specifically for online machine learning. Its code base is a <a id="_idIndexMarker241"/>result of the combination of the <strong class="source-inline">creme</strong> and the <strong class="source-inline">scikit-multiflow</strong> libraries. The goal of River is to become the go-to library for machine learning on streaming data.</p>
			<p>In this example, you'll see how to train an online model on a well-known dataset. The steps that you will take throughout this example are the following:</p>
			<ol>
				<li value="1">Import the data.</li>
				<li>Reclassify the data to obtain a binary classification problem.</li>
				<li>Fit an online model for binary classification.</li>
				<li>Improve the<a id="_idIndexMarker242"/> model evaluation using a train-test split.</li>
				<li>Fit an online multiclass <a id="_idIndexMarker243"/>classification model using one-vs-rest.</li>
			</ol>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Training an online model with River</h2>
			<p>For this example, you <a id="_idIndexMarker244"/>will use the well-known iris dataset. You can download it from the UCI machine learning repository, but you can also use the following <a id="_idIndexMarker245"/>code to download it directly into pandas.</p>
			<p>The steps to get to our goal are as follows:</p>
			<ol>
				<li value="1">Importing the data</li>
				<li>Reclassifying the data into a binary problem</li>
				<li>Converting the data into a suitable input format</li>
				<li>Learning the model one data point at a time</li>
				<li>Evaluating the model</li>
			</ol>
			<p>We will get started using the following steps:</p>
			<ol>
				<li value="1">We will first import the dataset as seen here:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-1</p>
			<p class="source-code">#iris dataset classification example</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">colnames = ['sepal_length','sepal_width','petal_length','petal_width','class']</p>
			<p class="source-code">data = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', names=colnames)</p>
			<p class="source-code">data.head()</p>
			<p>The dataset looks as follows:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B18335_04_001.jpg" alt="Figure 4.1 – The iris dataset&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – The iris dataset</p>
			<p>The iris dataset is very commonly used, mainly in tutorials and examples. The dataset contains a <a id="_idIndexMarker246"/>number of observations of three different iris species, a type of flower. For each flower, you have the length <a id="_idIndexMarker247"/>and width of specific parts of the plant. You can use the four variables to predict the species of iris.</p>
			<ol>
				<li value="2">For this first model, you will need to convert the class column into a binary column, as you will use the <strong class="source-inline">LogisticRegression</strong> model from River, which does not support multiclass:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-2</p>
			<p class="source-code">data['setosa'] = data['class'] == 'Iris-setosa'</p>
			<p class="source-code">data['setosa']</p>
			<p>This results in the following output:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B18335_04_002.jpg" alt="Figure 4.2 – The series with Boolean data type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – The series with Boolean data type</p>
			<ol>
				<li value="3">As a next step, we will write code to loop through the data to simulate a streaming data<a id="_idIndexMarker248"/> input. The <strong class="source-inline">X</strong> data should be in dictionary format, and <strong class="source-inline">y</strong> can be string, int, or<a id="_idIndexMarker249"/> Boolean. In the following code, you see a loop that stops after the first iteration, so that it prints one <strong class="source-inline">X</strong> and one <strong class="source-inline">y</strong>:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-3</p>
			<p class="source-code"># convert to streaming dataset</p>
			<p class="source-code">for i,row in data.sample(1).iterrows():</p>
			<p class="source-code">    X = row[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']]</p>
			<p class="source-code">    X = X.to_dict()</p>
			<p class="source-code">    </p>
			<p class="source-code">    y = row['setosa']</p>
			<p class="source-code">    </p>
			<p class="source-code">    print(X)</p>
			<p class="source-code">    print(y)</p>
			<p class="source-code">    break</p>
			<p>You can see that <strong class="source-inline">X</strong> has to be in a dictionary format, which is relatively uncommon for those <a id="_idIndexMarker250"/>who are familiar with offline learning. Then, <strong class="source-inline">y</strong> can be either Boolean, a string, or an int. This will look as follows:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B18335_04_003.jpg" alt="Figure 4.3 – The x and y inputs for the model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – The x and y inputs for the model</p>
			<ol>
				<li value="4">Now, let's fit the model one by one. It is important to add <strong class="source-inline">.sample(frac=1)</strong> to avoid getting the data in order. If you do not add this, the model would first receive all the data from <a id="_idIndexMarker251"/>one class and then from the other classes. The model has a hard time dealing with that, so a random order should be introduced using the sample function:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-4</p>
			<p class="source-code">!pip install river</p>
			<p class="source-code">from river import linear_model</p>
			<p class="source-code">model =  linear_model.LogisticRegression()</p>
			<p class="source-code">for i,row in data.sample(frac=1).iterrows():</p>
			<p class="source-code">    X = row[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']]</p>
			<p class="source-code">    X = X.to_dict()</p>
			<p class="source-code">    y = row['setosa']</p>
			<p class="source-code">        </p>
			<p class="source-code">    model.learn_one(X, y)</p>
			<ol>
				<li value="5">Let's see how the predictions can be made on the training data. You can use <strong class="source-inline">predict_many</strong> to predict <a id="_idIndexMarker252"/>on a data frame, or else you can use <strong class="source-inline">predict_one</strong>:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-5</p>
			<p class="source-code">preds = model.predict_many(data[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']])</p>
			<p class="source-code">print(preds)</p>
			<p>The result looks as follows:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B18335_04_004.jpg" alt="Figure 4.4 – The 150 Boolean observations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – The 150 Boolean observations</p>
			<ol>
				<li value="6">You can use the <strong class="source-inline">scikit-learn</strong> accuracy score to estimate the training accuracy of<a id="_idIndexMarker253"/> this model:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-6</p>
			<p class="source-code">from sklearn.metrics import accuracy_score</p>
			<p class="source-code">accuracy_score(data['setosa'], preds)</p>
			<p>The obtained training accuracy, in this case, is <strong class="source-inline">1</strong>, indicating that the model has perfectly learned the training data. Although the model has learned perfect prediction on the data that it has seen during the learning process, it is unlikely that the performance would be as good on new, unseen data points. In the next section, we will improve our model evaluation so that we avoid having overestimated performance metrics.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Improving the model evaluation</h2>
			<p>In the first example, there was no real relearning and updating.</p>
			<p>In this example, we will<a id="_idIndexMarker254"/> update and track the accuracy throughout the learning process. You will also see how to keep a training and separate test set. You can use each data point for learning once it arrives, and you will use the updated model for the prediction of the next data point to arrive. This more closely resembles a streaming use case.</p>
			<p>The steps to get there are as follows:</p>
			<ol>
				<li value="1">Train-test split.</li>
				<li>Fit the model on the training data.</li>
				<li>Check out the learning curve.</li>
				<li>Compute performance metrics on the test data.</li>
			</ol>
			<p>We will get started as follows:</p>
			<ol>
				<li value="1">Let's start with a stratified train-test split on the data:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-7</p>
			<p class="source-code"># add a stratified train test split</p>
			<p class="source-code">from sklearn.model_selection import train_test_split</p>
			<p class="source-code">train,test = train_test_split(data, stratify =data['setosa'])</p>
			<ol>
				<li value="2">You can now redo the same learning loop as before but on the training data. You can see that there is a list called <strong class="source-inline">correct</strong> to track how the learning has gone over time:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-8</p>
			<p class="source-code">from river import linear_model,metrics</p>
			<p class="source-code">model =  linear_model.LogisticRegression()</p>
			<p class="source-code">correct = []</p>
			<p class="source-code">for i,row in train.sample(frac=1).iterrows():</p>
			<p class="source-code">    X = row[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']]</p>
			<p class="source-code">    X = X.to_dict()</p>
			<p class="source-code">    </p>
			<p class="source-code">    y = row['setosa']</p>
			<p class="source-code">    </p>
			<p class="source-code">    model.predict_one(X)</p>
			<p class="source-code">    correct.append(y == model.predict_one(X))</p>
			<p class="source-code">    </p>
			<p class="source-code">    model.learn_one(X,y)</p>
			<ol>
				<li value="3">Let's plot the cumulative sum of <strong class="source-inline">correct</strong> scores over time, to see whether the model learned <a id="_idIndexMarker255"/>well from the beginning, or whether the model had fewer errors at the end of the learning curve:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-9</p>
			<p class="source-code"># this model is learning quite stable from the start</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">plt.plot(np.cumsum(correct))</p>
			<p>You can see that the learning curve is quite linear; the accuracy stays more or less constant over time. It would have been expected to see an improvement in accuracy over time (more<a id="_idIndexMarker256"/> correct responses over time, with an exponential-like curve) if the ml was actually improving with training. You can check out the learning curve in the following graph:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B18335_04_005.jpg" alt="Figure 4.5 – The learning curve&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – The learning curve</p>
			<ol>
				<li value="4">Finally, let's compute the accuracy on the test score to see how well the model generates out-of-sample data:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-10</p>
			<p class="source-code"># model was not so good on out of sample</p>
			<p class="source-code">accuracy_score(test['setosa'],model.predict_many(test[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']]))</p>
			<p>The score that this obtained is <strong class="source-inline">0.94</strong>, which is slightly lower than the <strong class="source-inline">1.0</strong> obtained on the train set. This teaches us that the model learned quite well.</p>
			<p>In the coming chapters, you'll see more tricks and tools that can help improve models and accuracy.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Building a multiclass classifier using one-vs-rest</h2>
			<p>In the previous <a id="_idIndexMarker257"/>example, you have seen how to build a binary classifier. To do this, you reclassified the target variable into <em class="italic">setosa-vs-rest</em>. However, you would want to build one model that allows you to do all of the three classes at the <a id="_idIndexMarker258"/>same time. This can be done using River's <strong class="source-inline">OneVsRest</strong> classifier. Let's now see an example of this:</p>
			<ol>
				<li value="1">You can start with the same train-test split as before, except that now, you can stratify on the class:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-11</p>
			<p class="source-code"># add a stratified train test split</p>
			<p class="source-code">from sklearn.model_selection import train_test_split</p>
			<p class="source-code">train,test = train_test_split(data, stratify =data['class'])</p>
			<ol>
				<li value="2">You then fit the model on the training data. The code is almost the same, except that you use <strong class="source-inline">OneVsRestClassifier</strong> around the call to <strong class="source-inline">LogisticRegression</strong>:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-12</p>
			<p class="source-code">from river import linear_model,metrics,multiclass</p>
			<p class="source-code">model =  multiclass.OneVsRestClassifier(linear_model.LogisticRegression())</p>
			<p class="source-code">correct = []</p>
			<p class="source-code">for i,row in train.sample(frac=1).iterrows():</p>
			<p class="source-code">    X = row[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']]</p>
			<p class="source-code">    X = X.to_dict()</p>
			<p class="source-code">    </p>
			<p class="source-code">    y = row['class']</p>
			<p class="source-code">    </p>
			<p class="source-code">    model.predict_one(X)</p>
			<p class="source-code">    correct.append(y == model.predict_one(X))</p>
			<p class="source-code">    model.learn_one(X,y)</p>
			<ol>
				<li value="3">When looking at the<a id="_idIndexMarker259"/> learning over time, you <a id="_idIndexMarker260"/>can see that the model has started learning better after around 40 observations. Before 40 observations, it had much fewer correct predictions than after:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-13</p>
			<p class="source-code"># this model predicts better after 40 observations</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">plt.plot(np.cumsum(correct))</p>
			<p>The plot looks as follows. It clearly has a less steep slope in the first 40 observations and accuracy improves after that:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B18335_04_006.jpg" alt="Figure 4.6 – A better learning curve&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – A better learning curve</p>
			<ol>
				<li value="4">You can again use <strong class="source-inline">predict_many</strong> to see whether the predictions are any good. When <a id="_idIndexMarker261"/>doing <strong class="source-inline">predict</strong>, you will <a id="_idIndexMarker262"/>now not have <strong class="source-inline">True</strong>/<strong class="source-inline">False</strong>, but instead, have the string values of each of the iris types:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-14</p>
			<p class="source-code">model.predict_many(test[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']])</p>
			<p>This results in the following output:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B18335_04_007.jpg" alt="Figure 4.7 – The multiclass target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – The multiclass target</p>
			<ol>
				<li value="5">The test accuracy of the model can be computed using the following code:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 4-15</p>
			<p class="source-code"># model scores 0.63 on the test data</p>
			<p class="source-code">from sklearn.metrics import accuracy_score</p>
			<p class="source-code">accuracy_score(test['class'],model.predict_many(test[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']]))</p>
			<p>The model obtains an<a id="_idIndexMarker263"/> accuracy score of <strong class="source-inline">0.63</strong> on the<a id="_idIndexMarker264"/> test data.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Summary</h1>
			<p>In this chapter, you have learned the basics of online machine learning in both theory and practice. You have seen different types of online machine learning, including incremental, adaptive, and reinforcement learning. </p>
			<p>You have seen a number of advantages and disadvantages of online machine learning. Among other reasons, you may be almost obliged to refer to online methods if quick relearning is required. A disadvantage is that fewer methods are commonly available, as batch learning remains the industry standard for now.</p>
			<p>Finally, you have started practicing and implementing online machine learning through a Python example on the well-known iris dataset. </p>
			<p>In the coming chapter, you'll go much deeper into online machine learning, focusing on anomaly detection. You'll see how machine learning can be used to replace the fixed rule alerting system that was built in previous chapters. In the chapters after that, you'll learn more about online classification and regression using River with examples that continue the learnings from the iris classification model from the current chapter.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Further reading</h1>
			<ul>
				<li><em class="italic">UCI Machine Learning Repository</em>: <a href="https://archive.ics.uci.edu/ml/index.php">https://archive.ics.uci.edu/ml/index.php</a></li>
				<li>River ML: <a href="https://riverml.xyz/latest/">https://riverml.xyz/latest/</a></li>
				<li><em class="italic">Online Machine Learning</em>: <a href="https://en.wikipedia.org/wiki/Online_machine_learning">https://en.wikipedia.org/wiki/Online_machine_learning</a></li>
				<li><em class="italic">Incremental Learning</em>: <a href="https://en.wikipedia.org/wiki/Incremental_learning">https://en.wikipedia.org/wiki/Incremental_learning</a></li>
				<li><em class="italic">Reinforcement Learning</em>: <a href="https://en.wikipedia.org/wiki/Reinforcement_learning">https://en.wikipedia.org/wiki/Reinforcement_learning</a></li>
				<li>Logistic Regression: <a href="https://www.statisticssolutions.com/free-resources/directory-of-statistical-analyses/what-is-logistic-regression/">https://www.statisticssolutions.com/free-resources/directory-of-statistical-analyses/what-is-logistic-regression/</a></li>
				<li>One vs Rest: <a href="https://stats.stackexchange.com/questions/167623/understanding-the-one-vs-the-rest-classifier">https://stats.stackexchange.com/questions/167623/understanding-the-one-vs-the-rest-classifier</a></li>
				<li><em class="italic">Multiclass classification</em>: <a href="https://en.wikipedia.org/wiki/Multiclass_classification">https://en.wikipedia.org/wiki/Multiclass_classification</a></li>
				<li>scikit-learn metrics: <a href="https://scikit-learn.org/stable/modules/model_evaluation.html">https://scikit-learn.org/stable/modules/model_evaluation.html</a></li>
			</ul>
		</div>
	</body></html>