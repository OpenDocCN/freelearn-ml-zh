<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Modules, Packages, and Data Type Concepts</h1>
                </header>
            
            <article>
                
<p>This chapter discusses several organizational techniques for developing large-scale applications. Believe it or not, this is often something that is easily overlooked. When developing applications, we typically focus on building data types, functions, control flows, and so on. It is equally important, however, to organize the code properly so that it is clean and maintainable.</p>
<p>In the later part of this chapter, we will introduce Julia's type system. Data types are the most fundamental building blocks of any application. Julia's type system is one of its strongest features when compared to other programming languages. A solid understanding of the type system will enable us to achieve better designs.</p>
<p><span>The following topics will be covered in this chapter:</span></p>
<ul>
<li>The growing pains of developing applications</li>
<li>Working with namespaces, modules, and packages</li>
<li><span>Managing package dependencies</span></li>
<li>Designing abstract types and concrete types</li>
<li>Understanding parametric types</li>
<li>Converting between data types</li>
</ul>
<p>By the end of the chapter, you should know how to create your own packages, divide code into separate modules, and start creating new data types for your application.</p>
<p>Let's go!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code from this chapter is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter02">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter02</a>.</p>
<p>The code is tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The growing pains of developing applications</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"Start where you are. Use what you have. Do what you can. "</div>
<div class="packt_quote CDPAlignCenter CDPAlign">- Arthur Ashe</div>
<p class="CDPAlignLeft CDPAlign">Everyone's journey is different. Julia is a versatile, dynamic programming language that can be used in many interesting use cases. More specifically, you can use it to easily code and solve a problem without thinking too much about system architecture and design. This is often sufficient for small research projects; however, when a project becomes more critical to the business, or when you have to harden a proof of concept into a production environment, it requires better organization, architecture, and design so that the project or application can live longer and be more maintainable.</p>
<p class="CDPAlignLeft CDPAlign">What kinds of project do we typically deal with? Let's explore some examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data science projects</h1>
                </header>
            
            <article>
                
<p>A typical data science project starts with the idea of learning from a set of data and making a prediction. A lot of the upfront work goes into data collection, data cleaning, data analysis, and visualization. Then, data is further digested into features as inputs a machine learning model. The process up until this point is called <em>data engineering</em>. The data scientist then chooses one or more machine learning models and keeps on refining and tuning the model to arrive at a good level of accuracy for the predictive model. This process is called <em>model development</em>. When the model is ready for production, it is deployed and sometimes a frontend is created for the end user. The final process is referred to as <em>model deployment</em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The data engineering and model development processes can be interactive at the beginning, but they usually end up getting automated. That's because the process needs to be repeatable and the results have to be consistent. Data scientists may use a variety of tools during development, ranging from a number of Jupyter notebooks to a suite of related libraries and programs.</p>
<p>When a predictive model becomes production-ready, it can be deployed as a web service so that it can be used to make real-time predictions. At this point, the model needs to have a life cycle and be maintained, just like any other production software.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enterprise applications</h1>
                </header>
            
            <article>
                
<p>People developing enterprise applications have a different mindset. Unlike data science projects, software engineers typically know upfront what they need to build the system. They also know whether they have to live with certain assumptions and policies. For example, the technology stack may already be known when the project starts. Other factors that may already be familiar include the system architecture that will be used, which cloud vendor will be utilized, what database the application must integrate with, and so on.</p>
<p>Enterprise applications typically require a rich business domain object model. Data objects are created, manipulated, and transferred to different layers of the application. The system architecture may include a user interface, a middle tier, and a database backend.</p>
<p>Enterprise applications also tend to require a high level of integration with other systems. For example, a trading system used by an investment firm is typically hooked up to an accounting system, a trade-settlement system, a reporting system, and so on. As such, these applications are often designed to handle both <em>data at rest</em> (for example, data stored in a database) or <em>data in motion</em> (<span>for example,</span> data being streamed to another system). Furthermore, data movement may happen in real-time or as an overnight batch process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adapting to growth</h1>
                </header>
            
            <article>
                
<p>No matter what kind of application you develop, it should not be hard to recognize growing pains. </p>
<p>For a data science project, the following signs typically indicate a growth-related problem:</p>
<ul>
<li><q><q>"My notebook is getting too long. I often have to scroll up and down to understand what I have done before and what I'm doing now. There are too many variables created in between and I'm losing track of what they mean and how they are used."</q></q></li>
<li><q>"The data structure is too complex. I was working on a data frame and have transformed it in ten different ways. I have now lost track of which transformed version represents what, and why they were needed in the first place."</q></li>
<li><q>"I have saved a bunch of machine learning models on disk, and I'm losing track of how each one was trained and what assumptions were made for each of those models."</q></li>
<li><q>"I have too much code scattered across many notebooks. Some code is duplicated or tweaked for a slightly different purpose. I am unable to achieve consistent results."</q></li>
</ul>
<p>As for an enterprise application, similar symptoms may surface:</p>
<ul>
<li><q><em>"The application logic is too complicated, and there is a huge component performing too many functions."</em></q></li>
<li><q><em>"It's becoming difficult to add new features without breaking existing functions."</em></q></li>
<li><q><em>"It takes a lot of time for a new person to comprehend the code in this module and it seems that the same person has to relearn it again every now and then." </em></q></li>
</ul>
<p>It's not fun to handle unorganized code and data. If you find yourself uttering some of the preceding phrases, it may be a good time to rethink your strategy and start organizing your program properly.</p>
<p>Now, let's start our learning journey by organizing code better with Julia. As we are working at a high level, we will introduce the concept of namespaces, and we will go over how to create modules and packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with namespaces, modules, and packages</h1>
                </header>
            
            <article>
                
<p>The Julia ecosystem lives on a namespace; in fact, this is the only way we can keep things in order. Why do I say that? The reason is that namespaces are used to logically separate fragments of source code so that they can be developed independently without affecting each other. If I define a function in one namespace, I will still be able to define another function in a different namespace even though both functions have the same name. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In Julia, namespaces are created using modules and submodules. In order to manage distribution and dependencies, modules are generally organized as packages. There is a standard directory structure for Julia packages. Although the top level directory structure is well defined, the programmer still has a lot of freedom in organizing source files.</p>
<p><span>In this section, we will explore the following topics:</span></p>
<ul>
<li>Understanding and using namespaces </li>
<li>How to create modules and packages</li>
<li>How to create submodules</li>
<li>How to organize files in a module</li>
</ul>
<p>Let's learn about each in detail in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding namespaces</h1>
                </header>
            
            <article>
                
<p>What is a namespace? Let's try a real-life example.</p>
<p>Every language has its own set of words as defined in its dictionary. When people from different cultures talk to each other, they often end up in amusing situations. Consider these examples:</p>
<p><strong>Conversation 1</strong>:</p>
<ul>
<li>American: <em>Your pants look dirty. You should change them.</em></li>
<li>British: <em>Do you mean my trousers? My underpants are... quite clean and well!</em></li>
</ul>
<p><strong>Conversation 2</strong>:</p>
<ul>
<li>American: <em>These biscuits are yummy!</em></li>
<li>British: <em>Where? Where are the cookies...?</em></li>
</ul>
<p><strong>Conversation 3</strong>:</p>
<ul>
<li>American: <em>I want to get back in shape and have tried many trainers but none of them are good.</em></li>
<li>British: <em>Have you tried the new running ones from Nike? I found them comfortable enough for my daily jogging routines.</em></li>
</ul>
<p>In fact, you don't even need to be from a different culture to experience this problem. Sometimes the same word already has different meanings depending on the context. For example:</p>
<ul>
<li>Pool - swimming pool or a group of things?</li>
<li>Squash - the vegetable or the sport?</li>
<li>Current - electrical current or a flow of water?</li>
</ul>
<p>There is no way that we can enforce a single vocabulary across all domains because of ambiguities such as these. Fortunately, computer scientists are smart and long ago solved the problem as it pertains to their field: to distinguish two different meanings for a single word, we can just prefix the word with the respective context. Using the examples from the preceding list, we can qualify each word as follows:</p>
<ul>
<li><kbd>Facility.Pool</kbd> and <kbd>Grouping.Pool</kbd></li>
<li><kbd>Vegetable.Squash</kbd> and <kbd>Sport.Squash</kbd></li>
<li><kbd>Electricity.Current</kbd> and <kbd>Liquid.Current</kbd></li>
</ul>
<p>The prefix is known as a <strong>namespace</strong>. Now that the words are qualified with their respective namespaces, they are no longer<span> ambiguous and have a clear meaning.</span></p>
<p>In Julia, namespaces are created using modules, which we will learn about in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating modules and packages</h1>
                </header>
            
            <article>
                
<p>Modules are used to create new namespaces. In Julia, creating a module is as simple as wrapping your code around a module block, like so:</p>
<pre>module X<br/> # your code<br/>end</pre>
<p>In general, modules are created for the purpose of sharing and reuse, and the best way to achieve this is to organize code in Julia packages. A Julia package is a directory and file structure for maintaining module definitions, test scripts, documentation, and related data.</p>
<p><span>There is a standard directory structure and convention for Julia packages; however, it would be a hassle to manually configure a new program in the same structure every single time. Fortunately, there are some open source tools that automatically create the structure for a new package. Without officially endorsing any specific tool, I have chosen the <kbd>PkgTemplates</kbd> package for demonstration, as follows. </span></p>
<p>If you have not installed the <kbd>PkgTemplates</kbd> package before, it can be installed as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/177bd713-5ae8-47e5-ab7b-67e5ff272b4c.png" style="width:19.58em;height:4.58em;"/></p>
<p><span>Once it is installed, we can use it to create our sample module. The first step is to create a <kbd>Template</kbd> object, as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb89662a-b5ca-41e7-ae6a-a7a2de47d8b1.png" style="width:58.33em;height:25.00em;"/></p>
<p>Basically, the <kbd>template</kbd> object contains some default values that will be used to create new packages. Then, creating a new package is easy as calling the <kbd>generate</kbd> function.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/034a707f-5a03-497d-8f2f-27f698a6c75a.png" style="width:44.08em;height:46.17em;"/></p>
<div class="packt_tip">By default, the package generator creates the new directory in the <kbd>~/.julia/dev</kbd> folder, but it is customizable with the <kbd>dir</kbd> keyword argument of the <kbd>Template</kbd> object.</div>
<div>
<p>The <kbd>generate</kbd> command is used to create a new package called <kbd>Calculator</kbd>. It automatically creates a directory with the following package structure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/835fcfff-df65-4c60-aa95-ae1f86787a7f.png" style="width:25.33em;height:16.42em;"/></p>
</div>
<p>At this time, you can start editing the <kbd>Calculator.jl</kbd> file and replace the file contents with your own source code.</p>
<div class="packt_tip">If you are new to Julia, make sure that you check out the <kbd>Revise</kbd> package, which allows you to edit source code and have your working environment updated automatically. Your productivity using Julia will be increased by a factor of 10, guaranteed. </div>
<p>Let's work on the <kbd>Calculator</kbd> module by implementing some financial calculations. Over the course of this example, we will learn how to manage the accessibility of variables and functions from external clients. Our initial code is set up as follows:</p>
<pre># Calculator.jl<br/>module Calculator<br/><br/>export interest, rate<br/><br/>"""<br/> interest(amount, rate)<br/><br/>Calculate interest from an `amount` and interest rate of `rate`.<br/>"""<br/>function interest(amount, rate)<br/> return amount * (1 + rate)<br/>end<br/><br/>"""<br/> rate(amount, interest)<br/><br/>Calculate interest rate based on an `amount` and `interest`.<br/>"""<br/>function rate(amount, interest)<br/> return interest / amount<br/>end<br/><br/>end # module</pre>
<p>This code should be saved to the <kbd>Calculator.jl</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining functional behavior</h1>
                </header>
            
            <article>
                
<p><span>Our <kbd>Calculator</kbd> module defines two functions:</span></p>
<ul>
<li>The <kbd>interest</kbd> <span>function </span>is used to calculate the interest for a deposit amount, <kbd>amount</kbd>, with the specified interest rate, <kbd>rate</kbd>, for a full investment period.</li>
<li>The <kbd>rate</kbd> <span>function </span>is used to calculate the interest rate for which you can invest the deposit amount, <kbd>amount</kbd>, and receive the interest amount, <kbd>interest</kbd>.</li>
</ul>
<p>Remember that <em>interest</em> and <em>rate</em> may mean completely different things outside the context of Calculator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exporting functions</h1>
                </header>
            
            <article>
                
<p>Functions defined inside a module are not exposed to the outside world. To expose them, the<span> </span><kbd>interest</kbd><span> and </span><kbd>rate</kbd><span> functions can be exported using the <kbd>export</kbd> statement, so that users of this module can easily bring them into their own namespace:</span></p>
<pre>export interest, rate</pre>
<p>Once the functions are exported, they will be available in the client's scope where the module is loaded with the <kbd>using</kbd> keyword. Let's try to reference these functions from the Julia REPL before loading the module:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8d3547c1-2da3-459b-ba38-fa4348fb7395.png" style="width:24.83em;height:6.67em;"/></p>
<p>Because we have not loaded the <kbd>Calculator</kbd> package yet, neither <kbd>interest</kbd> nor <kbd>rate</kbd> is defined. Let's bring them in now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8fd33db8-3cc2-4e47-9f4a-8266bf7cb817.png" style="width:25.25em;height:9.58em;"/></p>
<p><span>When the </span><kbd>using</kbd><span> statement is executed, all symbols exported from the module are brought into the current namespace. From the Julia REPL, the current module is called <kbd>Main</kbd>, as shown in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b733c478-b700-461d-bcf0-98fc25ecf660.png" style="width:33.25em;height:6.83em;"/></p>
<p>It is possible for us to bring in a subset of the names by qualifying the <kbd>using</kbd> statement with specific names. Let's restart the Julia REPL and try again:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e97eb30f-7c68-4700-9719-a9fae5a37214.png" style="width:25.92em;height:10.00em;"/></p>
<p><span><span>In this case, only the <kbd>interest</kbd> function was brought into the <kbd>Main</kbd> module:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f2e18976-1d12-49a5-8efa-3dfc7af6f50d.png" style="width:36.00em;height:6.83em;"/></p>
<p>There are actually several ways to import names from another module into the current namespace. For the sake of simplicity, we can summarize them as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18043909-0fa4-4c6b-a480-5684bb7b8a64.png" style="width:42.08em;height:19.92em;"/></p>
<p>As you can see, there are four ways (namely, 1, 2, 4, and 5 in the preceding table) to bring the <kbd>interest</kbd> function into the current namespace. There are some subtleties in choosing between <kbd>using</kbd> and <kbd>import</kbd> statements. A good rule of thumb is to use the <kbd>using</kbd> statement when you are using the functionality, but choose the <kbd>import</kbd> statement when you need to extend the functionality from the module. Extending functions from another package is a key language feature of Julia, and you will learn more about that from various examples in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resolving conflicts</h1>
                </header>
            
            <article>
                
<p>The picture, however, is not always rosy. Let's imagine that the main program needs to use another module called <kbd>Rater</kbd>, which provides rating services for online books. In this scenario, the main program may try to take functions from both modules, as shown in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d613a4b5-acb6-4b92-9867-1c0497a68c1c.png" style="width:40.75em;height:19.17em;"/></p>
<p>But, <em>Houston, we have a problem!</em> The <kbd>rate</kbd> <span>function</span> was brought in from the <kbd>Calculator</kbd> module, but it happens to be in conflict with the other one from the <kbd>Rater</kbd> module. Julia automatically detects this conflict on first use, prints a warning, and, from then on, requires the programmer to use their fully qualified names to access either function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/411c28b3-6330-42cc-8014-97a9a8c37aea.png" style="width:41.00em;height:9.83em;"/></p>
<p>If you are not happy with this, especially the ugly-looking warning, then there is an alternative. First, you can ask yourself whether both <kbd>rate</kbd> functions are actually needed in the main program. If only one <kbd>rate</kbd> function is needed, then just bring one into scope so that there is no more conflict:</p>
<pre>using Calculator: interest<br/>using Rater: rate<br/><br/># Here, the rate function refers to the one defined in Rater module.</pre>
<p>From my experience, bringing specific names into the current namespace is indeed the best choice for most use cases. The reason for this is that it will be immediately obvious which functions you depend on. Such dependency is also self-documented in the code.</p>
<p class="mce-root"/>
<p>Occasionally, you may need to use both <kbd>rate</kbd> functions. In such cases, you can solve the problem by using the regular <kbd>import</kbd> statement:</p>
<pre>import Calculator<br/>import Rater<br/><br/>interest_rate = Calculator.rate(100.00, 3.5)<br/>rating = Rater.rate("Hands-On Design Patterns with Julia")</pre>
<p><span>This way, it only loads the packages and does not bring any name into the current namespace. You can now refer to both <kbd>rate</kbd> functions with their fully qualified names—that is, <kbd>Calculator.rate</kbd> and <kbd>Rater.rate</kbd>. After creating these modules, let's move on to see how to create submodules.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating submodules</h1>
                </header>
            
            <article>
                
<p>When a module becomes too large, it may make sense to split it into smaller parts so that it's easier to develop and maintain. One way to solve this problem is to<span> create submodules.</span></p>
<p><span>Creating submodules is convenient as they are just defined within the scope of the parent module. Let's say we organize the <kbd>Calculator</kbd> module with two submodules—<kbd>Mortgage</kbd> and <kbd>Banking</kbd>. These submodules can be defined in separate files and can be included directly into the parent module. Consider the following code:</span></p>
<pre># Calculator.jl<br/>module Calculator<br/><br/>include("Mortgage.jl")<br/>include("Banking.jl")<br/><br/>end # module</pre>
<p><span>Submodules, just like regular modules, are also defined using module blocks. </span>The source code for <kbd>Mortgage</kbd> looks just like a regular module definition:</p>
<pre># Mortgage.jl<br/>module Mortgage<br/><br/># mortgage related source code<br/><br/>end # module</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>Because the source code from <kbd>Mortgage</kbd> is included inside the </span><span><kbd>Calculator</kbd> module block, it forms a nested structure. </span><span>The usage of submodules is the same as that of any regular module, except that you have to reference them via the parent module. In this case, you'd use </span><kbd>Calculator.Mortgage</kbd> <span>or</span> <kbd>Calculator.Banking</kbd><span>.</span></p>
<p>Using submodules is an effective way to separate code for larger codebases. Next, we will go over how to organize source code in a module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing files in a module</h1>
                </header>
            
            <article>
                
<p>The source code for modules is typically organized as multiple source files. Although there is no hard and fast rule about how source files are organized, the following are useful guidelines:</p>
<ul>
<li><strong>Coupling</strong>: Highly coupled functions should be placed in the same file. Doing so allows less context switching when editing source files. For example, when you change the signature of a function, all callers of that function may need to be updated. Ideally, you would want to minimize the <em>blast radius</em> and not have to change many files.</li>
<li><strong>File size</strong>: Having more than a few hundred lines of code in a single file could be a warning sign. If the code inside the file is all tightly coupled, then it may be better to redesign the system to reduce coupling.</li>
<li><strong>Ordering</strong>:<em> </em>Julia loads the source files in the order in which you include them. As data types and utility functions are usually shared, it is better to save them in a <kbd>types.jl</kbd> and <kbd>utils.jl</kbd> file respectively and include them at the beginning of the module.</li>
</ul>
<p>Similarly, the same considerations apply when organizing test scripts.</p>
<p>By now, we have learned how to create new namespaces using modules and submodules. More conveniently, a module is organized in a package so that it can be reused from an application. Once we have created multiple packages, it is unavoidable that they may have to depend on each other. It is important that we know how to handle these dependencies properly; this will be our primary topic in the next section.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing package dependencies</h1>
                </header>
            
            <article>
                
<p>The Julia ecosystem has a rich set of open source packages. When packages are designed with a single objective, they can be reused more easily; however, working with a large codebase is not an easy task because it is more likely to depend on third-party packages. It takes a considerable amount of time and effort for a developer to maintain and manage these dependencies in order to avoid <em>dependency hell.</em></p>
<p>It is important to understand that dependencies exist not just between packages, but also between specific versions of packages. Luckily, the Julia language has strong support for semantic versioning, which can help solve a lot of problems.</p>
<p>In this section, we will cover the following topics:</p>
<ul>
<li>Understanding the semantic versioning scheme</li>
<li>Specifying dependencies for Julia packages</li>
<li>Avoiding circular dependencies</li>
</ul>
<p>Now, let's take a quick look at the semantic versioning scheme.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the semantic versioning scheme</h1>
                </header>
            
            <article>
                
<p><span>Semantic versioning (<a href="https://semver.org/">https://semver.org/</a>) is a scheme developed by Tom Preston-Werner, most famously known as the co-founder and CTO of GitHub. Semantic versioning serves a very specific purpose, which is to provide the meaning—that is, the semantics—of version number changes.</span></p>
<p>When we use a third-party package and it is upgraded, how do we know whether our application needs to be updated? What kind of risk are we taking if we just upgrade the dependent package without doing any testing with our own application? </p>
<p>Before semantic versioning, it was almost always a guess. A more diligent and risk-averse developer, however, would at least examine the release notes of the dependent package, try to figure out whether there are any breaking changes, then take proper actions.</p>
<p>Here, we will quickly summarize how semantic versioning works. First of all, a version number is constructed using the following components:</p>
<pre>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</pre>
<p class="mce-root"/>
<p>If we wish, the version number can be followed by a release tag and a build number at the end:</p>
<pre>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;pre-release&gt;+&lt;build&gt;</pre>
<p>Every part of the version number reveals a meaning:</p>
<ul>
<li>The <kbd>major</kbd> release number, when changed, means that a major change has been introduced in this release that is incompatible with the previous release. It is highly risky for applications to <span>incorporate</span> the new release as existing functions will likely break.</li>
<li>The <kbd>minor</kbd> release number, <span>when changed, means that there are nonbreaking enhancements in this release. It is moderately risky for applications to incorporate the new release because previous functions should, at least in theory, continue to work as they are.</span></li>
<li><span>The </span><kbd>patch </kbd><span>release number, </span><span>when changed, means that there are nonbreaking bug fixes in this release. The risk is low for applications to incorporate the new release.</span></li>
<li>The <kbd>pre-release</kbd> tag, when present, indicates a pre-release candidate, such as alpha, beta, or <strong>release candidates</strong> (<strong>RCs</strong>). The release is considered unstable and applications should never use it in a production environment.</li>
<li>The <kbd>build</kbd> tag is considered to be meta information and can be ignored.</li>
</ul>
<p>Note that semantic versioning is only useful when all packages use it properly. S<span>emantic versioning is like a common language that package developers can use to easily indicate the impact of their changes when making new releases.</span></p>
<p>The Julia package ecosystem encourages semantic versioning. Next, we will take a look at how the Julia package manager, <kbd>Pkg</kbd>, handles dependencies using semantic versioning.</p>
<div class="packt_tip packt_infobox">While Julia encourages semantic versioning, many open source packages still have a pre-1.0 version number, even though they can be quite stable for production use. A major version number of zero is special—it basically means that every new release is breaking.<br/>
<br/>
As the Julia language matures, more package authors will mark their packages as 1.0, and the situation regarding package compatibility will get better over time.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying dependencies for Julia packages</h1>
                </header>
            
            <article>
                
<p><span>We can tell when a package depends on another by examining the <kbd>using</kbd> or <kbd>import</kbd> keywords in the source files; however, the Julia runtime environment is designed to be more explicit by tracking the dependencies. Such information is stored in the <kbd>Project.toml</kbd> file in the package directory. In addition, a <kbd>Manifest.toml</kbd> file in the same directory contains more information about the complete dependency tree. These files are written in the TOML file format. Although it is easy enough to edit these files by hand, the <kbd>Pkg</kbd> package manager's <strong>command-line interface</strong> (<strong>CLI</strong>) could be used to manage dependencies more easily.</span></p>
<p>To add a new dependent package, you just need to carry out the following steps:</p>
<ol>
<li>Start the Julia REPL.</li>
<li>Enter <kbd>Pkg</kbd> mode by pressing the <kbd>]</kbd> key.</li>
<li>Activate the project environment using the <kbd>activate</kbd> command.</li>
<li>Add the dependent package using the <kbd>add</kbd> command.</li>
</ol>
<p>For example, let's add the <kbd>SaferIntegers</kbd> package to our <kbd>Calculator</kbd> package as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e8c5fc8f-485e-42e0-a194-598c14a5c072.png" style="width:27.08em;height:27.92em;"/></p>
<p>Let's first examine the contents of the <kbd>Project.toml</kbd> file, as shown in the following screenshot. The funny-looking hash code <kbd>88634af6-177f-5301-88b8-7819386cfa38</kbd> represents the <strong><span>universal unique identifier</span></strong> (<strong>UUID</strong>) of the <kbd>SaferIntegers</kbd> package. <span>Note that there is no version number specified for the <kbd>SaferIntegers</kbd> package, even though we know version 2.5.0 was installed from the preceding output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/778c2259-af10-43c5-99e8-e53da5bf2a96.png" style="width:39.08em;height:28.92em;"/></p>
<p>The <kbd>Manifest.toml</kbd> file contains the complete dependency tree of the package. First, we find the following section regarding our <kbd>SaferIntegers</kbd> dependency:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/60ef38e3-b502-4fd8-8ebc-1b217dd07336.png" style="width:42.50em;height:8.75em;"/></p>
<p>Note that the <kbd>SaferIntegers</kbd> package now has a specific version. <kbd>2.5.0</kbd>, in the manifest file. Why? It's because the manifest is designed to capture the exact version information for all directly dependent <em>and</em> indirectly dependent packages. A second observation is that officially bundled packages, such as <kbd>Serialization</kbd>, <kbd>Sockets</kbd>, and <kbd>Test</kbd>, do not carry version numbers:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7d0528b9-751f-476d-b2fd-1d2edb42a5b5.png" style="width:40.50em;height:13.67em;"/></p>
<p><span>These packages do not have version numbers because they are always released with the Julia binary. Their actual versions are pretty much determined by the specific Julia version.</span></p>
<p>It is important to realize that neither <kbd>Project.toml</kbd> and <kbd>Manifest.toml</kbd> contains any versioning compatibility information, even though we know version 2.5.0 of <kbd>SaferInteger</kbd> was installed. To specify compatibility constraints, we can manually edit the <kbd>Project.toml</kbd> file using the semantic versioning scheme. For example, if we know that <kbd>Calculator</kbd> is compatible with <kbd>SaferIntegers</kbd> version 1.1.1 and later, then we can add this requirement to the <kbd>[compat]</kbd> section of the <kbd>Project.toml</kbd> file, as follows:</p>
<pre>[compat]<br/>SaferIntegers = "1.1.1"</pre>
<p>This compatibility setting provides the necessary information for the Julia package manager to ensure that at least <kbd>SaferIntegers</kbd> version 1.1.1 is installed in order to use the <kbd>Calculator</kbd> package. Since the package manager is sensitive to semantic versioning, the preceding setting means that <kbd>Calculator</kbd> can work with all versions of <kbd>SaferIntegers</kbd> from 1.1.1 to the latest 1.<em>x</em>.<em>y</em> version, right up to 2.0. In mathematical notation, the range of compatible versions is [1.1.1, 2.0.0), where 2.0.0 is excluded.</p>
<p>Now, what if <kbd>SaferIntegers</kbd> is improved and the package owner decides to release 2.0.0? Well, because the major version number has advanced from 1 to 2, we have to expect breaking changes. If we don't do anything, the latest version, 2.0.0, will never be installed in the <kbd>Calculator</kbd> environment because we specifically implemented an exclusive upper bound of 2.0.0.</p>
<p class="mce-root"/>
<p>Let's say that, after thorough examination and testing, we conclude that <kbd>Calculator</kbd> is not affected by any breaking changes from <kbd>SaferIntegers</kbd> 2.0.0. In that case, we can just make a small change to our <kbd>Project.toml</kbd> file, as follows:</p>
<pre>[compat]<br/>SaferIntegers = "1.1.1, 2"</pre>
<p>This line specifies the <em>union</em> of these two compatible version ranges:</p>
<ul>
<li>The <kbd>1.1.1</kbd> <span>specification </span>indicates that the package is compatible with <kbd>SaferIntegers</kbd> versions [1.1.1, 2.0.0]</li>
<li>The <kbd>2.0</kbd> <span>specification </span>indicates that the package is compatible with <span><kbd>SaferIntegers</kbd> versions [2.0.0, 3.0.0]</span></li>
</ul>
<p>Such information is important. If the <kbd>Calculator</kbd> package is used by someone who has an environment pinned to <kbd>SaferIntegers</kbd> version 1.1.1, then we know that <kbd>Calculator</kbd> is still compatible in that environment and can be loaded in it.</p>
<p>The package manager is actually very flexible, and it implements a few more version-specifier formats. You can refer to <span>of </span><span><kbd>Pkg</kbd></span> reference manual<span> </span>for more information (<a href="https://julialang.github.io/Pkg.jl/v1/compatibility/#Version-specifier-format-1">https://julialang.github.io/Pkg.jl/v1/compatibility/#Version-specifier-format-1</a>).</p>
<p>It is important to specify compatibility between packages. By using the <kbd>Pkg</kbd> interface and editing the <kbd>Project.toml</kbd> file manually, we can manage dependencies properly, and the package manager will help us maintain the working environment in working order.</p>
<p>However, sometimes, we may run into tricky dependency issues—for example, circular dependencies. We will look at how to handle such situations next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding circular dependencies</h1>
                </header>
            
            <article>
                
<p>Circular dependencies are problematic. To understand why, consider the following example.</p>
<p>Let's say we have five packages (A, B, C, D, and E) with the following dependencies:</p>
<ul>
<li>A depends on B and C</li>
<li>C depends on D and E</li>
<li>E depends on A</li>
</ul>
<p class="mce-root"/>
<p>To illustrate these graphically, we can create a diagram where we can use an arrow notation to indicate dependencies between components. The direction of the arrow indicates the direction of the dependency.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e342d9b-ae0c-4d31-898c-90aa805106e9.png" style="width:13.83em;height:13.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What's the problem?</h1>
                </header>
            
            <article>
                
<p><span>Clearly there is a cycle, as A depends on C, C depends on E, and E depends on A. What is the problem with a cycle like this? Say that you have to make a change in package C that is supposed to be</span> backward-compatible. To properly test the system with this change, we must make sure that C continues to have proper functionality given its dependencies. Now, if we trace this down the dependency chain, we must test C with D and E, and as E depends on A, we must include A as well. Now that A is included, we must include B and C. Because of the cycle, we now have to test all of the packages!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How do we fix this?</h1>
                </header>
            
            <article>
                
<p><span>The <em>acyclic dependency principle</em> states that dependencies between packages must be a <strong>directed acyclic graph</strong> (<strong>DAG</strong>)—that is, the dependency graph must have no cycle. If we do see a cycle in the graph, then it is</span> a sign of a design problem. </p>
<p class="CDPAlignLeft CDPAlign">When we encounter such a problem, we must refactor the code so that the specific dependent function is moved to a separate package. In this example, suppose that there's some code in package A that is used by the package internally and also used by package E. This dependency is basically E -&gt; A.</p>
<p>We can then take this code and move it to a new package F. After this change, packages A and E would both depend on package F, effectively removing the cyclic dependency:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bace0bad-d9f9-42a8-96f2-5f798342b34a.png" style="width:15.67em;height:13.83em;"/></p>
<p>After this refactoring, when we make changes to C, we can just test the package with its dependencies, which would be D, E, and F only. Packages A and B can both be excluded.</p>
<p>In this section, we learned how to leverage semantic versioning to clearly communicate the impact of new versions of a package. We can use the <kbd>Project.toml</kbd> file to specify the compatibility of the current package with its dependent packages. We also reviewed a technique for resolving circular dependencies.</p>
<p>Now we know this, we will look into how to design and develop data types in Julia.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing abstract and concrete types</h1>
                </header>
            
            <article>
                
<p>Julia's type system is the foundation of many of its language features, such as multiple dispatches. In this section, we will learn about both abstract types and concrete types, how to design and use them, and how they are different from other mainstream object-oriented programming languages.</p>
<p>In this section, we will cover the following topics:</p>
<ul>
<li>Designing abstract types</li>
<li>Designing concrete types</li>
<li>Understanding <kbd>isa</kbd> and <kbd>&lt;:</kbd> operators</li>
<li>Understanding the difference between abstract and concrete types</li>
</ul>
<p>Let's first take a look at abstract types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing abstract types</h1>
                </header>
            
            <article>
                
<p>Similar to many other objected-oriented programming languages, Julia supports a hierarchy of abstract types. Abstract types are typically used to model real-world data concepts; for example, an <kbd>Animal</kbd> could be an abstract type for a cat or dog, and a <kbd>Vehicle</kbd> can be an abstract type for a car, truck, or bus. Being able to group types together and give the group a single name allows Julia programmers to apply generic code that is common to those types.</p>
<p><span>Abstract types are often conveniently defined in a type hierarchy for a specific domain. We can describe the relationship between abstract types as</span> <em>parent–child</em><span>, or more technically, an </span><em>is-a-subtype-of</em> <span>relationship. The terminology for the parent type and child type is <em>supertype</em> and <em>subtype</em> respectively.</span></p>
<p>A unique feature of Julia's design, unlike the majority of other languages, is that abstract types are defined without any fields. For this reason, abstract types do not specify how data is actually stored in the memory. It may seem somewhat restrictive at first glance, but as we learn more about Julia, it will seem more natural when used in this design. As a result, abstract types are used solely to model behaviors for a set of objects rather than to specify how data is stored.</p>
<div class="packt_infobox">The Rectangle and Square object model is a classic example of how things can break down when an abstract type is allowed to define data fields. Suppose that we were able to define a Rectangle with <kbd>width</kbd> and <kbd>height</kbd> fields. A Square is a kind of Rectangle, so intuitively, we should be able to model Square as a subtype of Rectangle. But we soon get into trouble because a square does not need two fields to store the length of its sides; we should rather use a single <kbd>side length</kbd> field instead. Therefore, inheriting fields from supertypes makes no sense in this case. We will discuss this case with more details in <a href="97049a94-ad30-452a-bbb0-296d9438c886.xhtml">Chapter 12</a>, <em>Inheritance and Variance</em>.</div>
<p>In the following sections, we will work through an example of building an abstract type hierarchy.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A personal asset type hierarchy example</h1>
                </header>
            
            <article>
                
<p>Let's say we are building a financial application that keeps track of a user's wealth, which may include various types of asset. The following diagram shows a hierarchy of abstract types and their parent–child relationship. In this design, an Asset <span>may be a Property, an Investment, or just Cash types. A Property can be a House or an Apartment. An Investment could be FixedIncome or Equity. As a convention, in order to indicate that they are abstract types rather than concrete types, we have chosen to italicize their names in the boxes:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b7da5c2a-c584-4a21-9b10-7f1a79716530.png" style="width:42.67em;height:18.08em;"/></p>
<p>To create an abstract type hierarchy, we can use the following code:</p>
<pre>abstract type Asset end<br/><br/>abstract type Property &lt;: Asset end<br/>abstract type Investment &lt;: Asset end<br/>abstract type Cash &lt;: Asset end<br/><br/>abstract type House &lt;: Property end<br/>abstract type Apartment &lt;: Property end<br/><br/>abstract type FixedIncome &lt;: Investment end<br/>abstract type Equity &lt;: Investment end</pre>
<p>The<span> </span><kbd>&lt;:</kbd><span> </span><span>symbol represents an</span><span> </span><span><em>is-a-subtype-of</em></span><span> </span><span>relationship. So, the <kbd>Property</kbd> type is a subtype of <kbd>Asset</kbd>, the <kbd>Equity</kbd> type is a subtype of <kbd>Investment</kbd>, and so on.</span></p>
<p>While the <span><kbd>Asset</kbd> </span>abstract type seems to be at the top level of the hierarchy in reality, it also has a supertype called <kbd>Any</kbd>, which is implicit when no supertype is specified and an abstract type is defined. The <kbd>Any</kbd> code phrase is the top-level supertype in Julia.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigating the type hierarchy</h1>
                </header>
            
            <article>
                
<p><span>Julia provides some convenient functions to navigate the type hierarchy. To find the subtypes of an existing type, we can use the <kbd>subtypes</kbd> function:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/46c834e8-6832-49ec-a7e2-66dec5643acb.png" style="width:14.33em;height:6.92em;"/></p>
<p><span>Similarly, to find the supertype of an existing type, we can use the</span> <kbd>supertype</kbd> <span>function.</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/870c1fbb-1100-4662-bdce-4cd1780f0767.png" style="width:16.67em;height:3.42em;"/></p>
<p>Sometimes, it's convenient to see the complete hierarchy in a tree format. Julia comes with no standard function that we can use to achieve this, but we can <span>easily</span><span> create one ourselves using a recursion technique, as follows: </span></p>
<pre># Display the entire type hierarchy starting from the specified `roottype`<br/>function subtypetree(roottype, level = 1, indent = 4)<br/>    level == 1 &amp;&amp; println(roottype)<br/>    for s in subtypes(roottype)<br/>       println(join(fill(" ", level * indent)) * string(s))<br/>       subtypetree(s, level + 1, indent)<br/>    end<br/>end</pre>
<p><span>This function can be quite convenient for new Julia users. In fact, I have the code saved in my <kbd>startup.jl</kbd> file so that it is loaded into the REPL automatically.</span></p>
<div class="packt_tip">The <kbd>startup.jl</kbd> file is a <span>user-customized</span> script that is located in the <kbd>$HOME/.julia/config</kbd> directory. It can be used to store any code or functions that the user wants to run every time the REPL is started. </div>
<p>We can now display the personal asset type hierarchy easily, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1512d6f8-9ade-4901-8631-6c4cfce05b6b.png" style="width:16.17em;height:13.08em;"/></p>
<p>Note that this function can only display a hierarchy of types that have already been loaded into memory. Now that we have defined abstract types, we should be able to associate functions with them. Let's do that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining functions for abstract types</h1>
                </header>
            
            <article>
                
<p>So far, all we have done is create a hierarchy of related concepts. With that limited knowledge, we can still define some functions to model behaviors. But how is this useful when we have no concrete data elements? When dealing with abstract types, we could just focus on specific behavior and the possible interaction between them. Let's continue with the example and see what kinds of function we can add.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Descriptive functions</h1>
                </header>
            
            <article>
                
<p><span>Although it does not sound very interesting, we can define functions that are solely based on the type itself:</span></p>
<pre># simple functions on abstract types<br/>describe(a::Asset) = "Something valuable"<br/>describe(e::Investment) = "Financial investment"<br/>describe(e::Property) = "Physical property"</pre>
<p>Now, if we ever call <kbd>describe</kbd> with a data element that has a supertype of <kbd>Property</kbd>, then the description method for <kbd>Property</kbd> will be invoked accordingly. As we did not define any description function with the <kbd>Cash</kbd> type, when <kbd>describe</kbd> is called with a <kbd>Cash</kbd> data element it will return the description from the higher-level type, <kbd>Asset</kbd>.</p>
<div class="packt_tip packt_infobox">Because we have not defined any concrete types yet, we cannot prove the claim here that the <kbd>describe</kbd> function for a <kbd>Cash</kbd> object will resort to the <kbd>describe(a::Asset) </kbd>method<span>. As it is a simple thing to do, I encourage the reader to do this as an exercise after reading this chapter. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional behavior</h1>
                </header>
            
            <article>
                
<p>The reason to have a hierarchy is to create an abstraction about common behaviors for types. For example, the <kbd>Apartment</kbd> and <kbd>House</kbd> types have the same supertype, <kbd>Property</kbd>. This is intentional because they both represent some kind of physical dwelling at a certain location. So, we can define a function for any <kbd>Property</kbd> as follows:</p>
<pre>"""<br/> location(p::Property) <br/><br/>Returns the location of the property as a tuple of (latitude, longitude).<br/>"""<br/>location(p::Property) = error("Location is not defined in the concrete type")</pre>
<p>You may ask, <em>What have we done?</em> We have just implemented a function that does nothing but return an error! Well, believe it or not, defining this function actually serves several purposes:</p>
<ul>
<li>It makes it clear that any concrete subtype of<span> </span><kbd>Property</kbd><span> </span>must implement the<span> </span><kbd>location</kbd><span> </span>function.</li>
<li>At runtime, if the <kbd>location</kbd> function is not defined for the respective concrete type, then this particular function will be called and a reasonable error will be thrown so that the programmer can correct the bug.</li>
<li>The document string right above the function definition contains a useful description that concrete subtypes of <kbd>Property</kbd> <span>should implement.</span></li>
</ul>
<p>Alternatively, we can define an empty function instead:</p>
<pre>"""<br/> location(p::Property) <br/><br/>Returns the location of the property as a tuple of (latitude, longitude).<br/>"""<br/>function location(p::Property) end</pre>
<p><span>What is the difference between an empty function and one that throws an error? For this empty function, there will be no runtime error if the concrete type does not implement this function.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interaction between objects</h1>
                </header>
            
            <article>
                
<p>It is also useful to define interactions between abstract types. Now that we know that every <kbd>Property</kbd> should have a location, we can define a function that calculates the walking distance between any two properties, as follows:</p>
<pre>function walking_disance(p1::Property, p2::Property)<br/>    loc1 = location(p1)<br/>    loc2 = location(p2)<br/>    return abs(loc1.x - loc2.x) + abs(loc1.y - loc2.y)<br/>end</pre>
<p>The logic completely lives in the abstract types! We have not even defined any concrete types, and yet we are able to develop generic code that works for any concrete subtypes of <kbd>Property</kbd> going forward.</p>
<p>The power of the Julia language allows us to define these behaviors at this <span>level of </span><span>abstraction. For a moment, let's imagine what we would have to do if we were not allowed to define functions at this level and could only implement logic with specific concrete types. In this case, we would have to define a separate</span> <kbd>walking_distance</kbd> <span>function for every combination of different types of properties. It would be too mundane and boring for programmers!</span></p>
<p>Now that we understand how abstract types work, let's continue our journey and take a look at how to create concrete types in Julia.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing concrete types</h1>
                </header>
            
            <article>
                
<p>A concrete type is used to define how data is organized. In Julia, there are two kinds of concrete type:</p>
<ul>
<li>Primitive type</li>
<li>Composite type</li>
</ul>
<p>Primitive types carry pure bits. Julia's <kbd>Base</kbd> package comes with a variety of primitive types—signed/unsigned integers that are 8-, 16-, 32-, 64-, or 128-bits wide. Currently, Julia only supports primitive types with numbers of bits that are multiples of 8. For example, it is possible to define a 256-bit integer type (32 bytes) if we have a use case that requires very large integers. How to do this is outside the scope of this book. If you feel that this is an interesting project, you can consult Julia's source code on GitHub and see how existing primitive types are implemented. The Julia language is indeed largely written in Julia itself!</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Composite types are defined by a set of named fields. Grouping fields into a single type allows easier reasoning, sharing, and manipulation. Composite types may be designated a specific supertype or defaulted to <kbd>Any</kbd>. Fields can also be annotated with their own types, if you wish, and types can be either abstract or concrete. When type information is absent for fields, they default to <kbd>Any</kbd>, which means that the field can hold objects of any type.</p>
<p>We will focus on composite types in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing composite types</h1>
                </header>
            
            <article>
                
<p>Composite types are defined with the <kbd>struct</kbd> keyword. Let's carry on the example from the preceding abstract type section and continue building our personal asset type hierarchy. We will now create a concrete type called <kbd>Stock</kbd> as a subtype of <kbd>Equity</kbd>. To keep things simple, we will just represent a stock as a trading symbol and the name of the company:</p>
<pre>struct Stock &lt;: Equity<br/>    symbol::String<br/>    name::String<br/>end</pre>
<p class="CDPAlignLeft CDPAlign">We can instantiate a composite type using the standard constructor, which just takes all the fields as an argument:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/545e24c6-ce93-4e1c-b2f9-686f0dd99ca2.png" style="width:28.92em;height:3.58em;"/></p>
<p>Now, since <kbd>Stock</kbd> is a subtype of <kbd>Equity</kbd>, which is a subtype of <kbd>Investment</kbd>, which in turn is a subtype of <kbd>Asset</kbd>, we should obey the <em>contract</em> that we set forth earlier by defining the <kbd>describe</kbd> function:</p>
<pre>function describe(s::Stock)<br/>    return s.symbol * "(" * s.name * ")"<br/>end</pre>
<p>The <kbd>describe</kbd> function just returns a string representation of the stock with both the trading symbol and company name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutability</h1>
                </header>
            
            <article>
                
<p>Composite types are by default immutable. This means that their fields are not changeable after the object is created. Immutability is a good thing as it eliminates surprises when system behavior changes unexpectedly because of data modification. We can easily prove that the concrete <kbd>Stock</kbd> <span>type</span><span> that </span><span>we created in the last section is immutable:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4f1204bf-2ab9-42db-9062-f702f1ff2902.png" style="width:37.42em;height:2.75em;"/></p>
<p>That's great! Now, the immutability <span>guarantee</span><span> </span><span>actually stops at the field level. If the type contains a field and the field's own type is mutable, then changing the underlying data is allowed. Let's try a different example by creating a new composite type called</span> <kbd>BasketOfStocks</kbd><span>, which is used to hold a vector (that is, a one-dimensional array) of stocks and the reason that we are holding them:</span></p>
<pre>struct BasketOfStocks<br/>    stocks::Vector{Stock}<br/>    reason::String<br/>end</pre>
<p>Let's just create an object for testing:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d66f128-0e67-49d1-98a0-fd4dad278a33.png" style="width:45.58em;height:10.83em;"/></p>
<p><span>As we already know, </span><kbd>BasketOfStocks</kbd><span> is an immutable type, so we cannot change any of the fields in it; h</span>owever, let's see if we can take away one of the stocks from the <kbd>stocks</kbd> field:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d506cfe-1b10-4719-991e-ebf2fbe83fca.png" style="width:41.75em;height:7.50em;"/></p>
<p>Here, we just call the <kbd>pop!</kbd> function directly on the <kbd>stocks</kbd> object, and it will happily take away half of the presents for my wife! Let me repeat—the immutability guarantee does not have any effect on the underlying fields. </p>
<p>This behavior is by design. The programmer should be cautious about making any assumptions about immutability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutability</h1>
                </header>
            
            <article>
                
<p>In some situations, we may actually want an object to be mutable. The immutability constraint can be removed easily by just adding the <kbd>mutable</kbd> keyword in front of the type definition. To make the <kbd>Stock</kbd> type mutable, we do the following:</p>
<pre>mutable struct Stock &lt;: Equity<br/>    symbol::String<br/>    name::String<br/>end</pre>
<p>Now let's try to update the <kbd>name</kbd> field in a hypothetical case where Apple changes its company name:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4dc50ddf-bca3-47e9-ac35-e09e0ecbdb12.png" style="width:29.42em;height:12.42em;"/></p>
<p>The <kbd>name</kbd> field has been updated as we wish. Note that, when a type is declared mutable, all of its fields become mutable. So, in this case, we would be allowed to change the symbol as well. Depending on the situation, such behavior may or may not be desirable. In <a href="6b565339-641f-444c-ad42-f8ff7998001b.xhtml">Chapter 8</a>, <em>Robustness Patterns</em>, we will go over some design patterns that we can use to build a more robust solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutable or immutable?</h1>
                </header>
            
            <article>
                
<p>As you can see, mutable objects seem more flexible and give us good performance. But if that's the case, then why wouldn't we want everything to be mutable by default? There are a couple of reasons:</p>
<ul>
<li><span>Immutable objects are easier to handle. Because the data in the object is fixed and never changes, a function that operates on these objects will always return consistent results. That is a very nice property to have because there are no surprises. And if we build a function that caches calculation results from such objects, the cache will always be good and return consistent results.</span></li>
<li><span>Mutable objects are more difficult to work with in a multi-threaded application. Let's say that a function is reading from a mutable object, but the content of the object is modified by another function from a different thread. Then the current function may produce incorrect results. In order to ensure consistency, the programmer must use a locking technique to synchronize the read/write operations to the object. Having to handle such a concurrent situation makes the code more complex and difficult to test.</span></li>
</ul>
<p>On the other hand, mutability could be useful for high-performance use cases because memory allocation is a relatively expensive operation. We can reduce the system overhead by reusing allocated memory over and over again.</p>
<p>All things considered, immutable objects are usually the better choice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supporting multiple types using Union types</h1>
                </header>
            
            <article>
                
<p>Sometimes, we need to support multiple types in a field. This can be done using a <kbd>Union</kbd> type, which is defined as a type that can accept any specified types. To define a <kbd>Union</kbd> type, we can just enclose the types within curly braces after the <kbd>Union</kbd> keyword. For example, the <kbd>Union</kbd> type of <kbd>Int64</kbd> and <kbd>BigInt</kbd> can be defined as follows:</p>
<pre>Union{Int64,BigInt}</pre>
<p>These <kbd>Union</kbd> types are quite useful when you need to incorporate data types that come from different data type hierarchies. Let's extend our personal asset example further. For instance, say that we need to incorporate some exotic items into our data model, which may include things such as art pieces, antiques, paintings, and so on. These new concepts may have already been modeled with a different type hierarchy, as follows:</p>
<pre>abstract type Art end<br/><br/>struct Painting &lt;: Art<br/>    artist::String<br/>    title::String<br/>end</pre>
<p>As it turns out, my wife likes to collect paintings, and so I can just generalize the <kbd>BasketOfStock</kbd> type as <kbd>BasketOfThings</kbd>, as follows:</p>
<pre>struct BasketOfThings<br/> things::Vector{Union{Painting,Stock}}<br/> reason::String<br/>end</pre>
<p>The things inside the vector can be <kbd>Stock</kbd> or <kbd>Painting</kbd>. Remember that Julia is a strongly typed language, and it is important that the compiler knows what kinds of data type can fit into an existing field. Let's see how it works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6bf242c2-9abf-4aaf-9e6a-6d3cdda92221.png" style="width:42.58em;height:17.50em;"/></p>
<p>To create a vector that contains either <kbd>Painting</kbd> or <kbd>Stock</kbd>, we just specify the element type of the array in front of the square brackets, as in <kbd>Union{Painting,Stock}[stock, monalisa]</kbd>.</p>
<p>The syntax for <kbd>Union</kbd> types can be very verbose, especially when there are more than two types, so it is quite common for a constant to be defined with a meaningful name that represents the <kbd>Union</kbd> type: </p>
<pre>const Thing = Union{Painting,Stock}<br/><br/>struct BasketOfThings<br/>    thing::Vector{Thing}<br/>    reason::String<br/>end</pre>
<p>As you can see, <kbd>Thing</kbd> is much easier to read than <kbd>Union{<span>Painting,</span>Stock}</kbd>. Another benefit is that the <kbd>Union</kbd> type may be referenced in many parts of the source code. When we need to add more types later—for instance, an <kbd>Antique</kbd> type—then we only need to change it in one place, which is the definition of <kbd>Thing</kbd>. This means that the code can be maintained more easily.</p>
<p class="mce-root">In this section, although we have chosen to use concrete types such as <kbd>Stock</kbd> and <kbd>Painting</kbd> for our example, there is no reason why we cannot use abstract types such as <kbd>Asset</kbd> and <kbd>Art</kbd> for the <kbd>Union</kbd> type.</p>
<div class="packt_tip">Another common usage of the <kbd>Union</kbd> type is to incorporate <kbd>Nothing</kbd> as a valid value for a field. This can be achieved by declaring a field with the <kbd>Union{T,Nothing} </kbd>type<span>, where</span> <kbd>T</kbd> <span>is the real data type that we want to use. In that case, the field can be assigned with a real value or just</span> <kbd>Nothing</kbd><span>.</span></div>
<p>Next, we will continue to learn how to work with type operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with type operators</h1>
                </header>
            
            <article>
                
<p>Julia's data types are first-class citizens themselves. This means that you can assign them to variables, pass them to functions, and manipulate them in various ways. We will take a look at two commonly used operators in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The isa operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>isa</kbd> operator can be used to determine whether a value is a subtype of a type. For example, look at the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/65d7f375-620b-46fc-a9fb-0a0facbcce16.png" style="width:13.42em;height:11.67em;"/></p>
<p>Let me explain each of these results:</p>
<ul>
<li>The number <kbd>1</kbd> is an instance of the <kbd>Int</kbd> type, so it returns <kbd>true</kbd>.</li>
<li>Because <kbd>Float64</kbd> is a different concrete type, it returns <kbd>false</kbd>.</li>
<li>Because <kbd>Int</kbd> is a subtype of <kbd>Signed</kbd>, which is a subtype of <kbd>Integer</kbd>, which is a subtype of <kbd>Real</kbd>, it returns <kbd>true</kbd>.</li>
</ul>
<p>The <kbd>isa</kbd> operator could be useful for checking types in a function that accepts generic type arguments. For example, if the function can only work with <kbd>Real</kbd> numbers, then it may throw an error when a <kbd>Complex</kbd> value is passed by accident.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The &lt;: operator</h1>
                </header>
            
            <article>
                
<p>The <em>is-a-subtype-of</em> operator, <kbd>&lt;:</kbd>, is used to determine whether a type is a subtype of another type. Taking the third example from the preceding section, we can check whether <kbd>Int</kbd> is indeed a subtype of <kbd>Real</kbd> as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f1e081da-8d13-4fe2-8da1-0f2d9adf8a34.png" style="width:12.08em;height:3.25em;"/></p>
<p>Sometimes the developer may be confused about the usage of the <kbd>isa</kbd> and <kbd>&lt;:</kbd> operators because they are very similar. We can keep in mind that <kbd>isa</kbd> checks a <em>value</em> against a type, and <kbd>&lt;:</kbd> checks a <em>type</em> against another type. The document string for these operators is actually quite helpful. From the Julia REPL, type a <kbd>?</kbd> character and enter the operator to find the documentation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/59b3c143-4d6f-491b-9347-d4fbc226f65c.png" style="width:61.67em;height:34.58em;"/></p>
<p>As it turns out, both <kbd>isa</kbd> and <kbd>&lt;:</kbd> are just functions, but they can also be used as infix operators. </p>
<p>These operators are quite useful for type-checking purposes; for example, we can throw an exception from a constructor function if the arguments being passed do not have the right types. They can also be used to execute different logic dynamically based upon the types being passed to a function.</p>
<p>Abstract types and concrete types are the fundamental building blocks for data types in Julia. It may be worth looking at a quick summary of the differences between them. Next, we will look at specific details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Differences between abstract and concrete types</h1>
                </header>
            
            <article>
                
<p>Having discussed abstract types and concrete types, you may <span>be wondering</span> how they differ from each other. We can summarize their differences in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<thead>
<tr>
<td><strong>Property</strong></td>
<td><strong>Abstract Type</strong></td>
<td><strong>Concrete Type</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td>Has a supertype?</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Allows subtypes?</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Contains data fields?</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>First class?</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Can be part of a <kbd>Union</kbd> type?</td>
<td>Yes</td>
<td>
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>For abstract types, we can build a hierarchy of types. The top-level type is just <kbd>Any</kbd>. Abstract types cannot contain any data fields as they are used to represent concepts rather than data storage. Abstract types are first-class, meaning that they can be stored and passed around, and there are functions that work with them—<span>for example, the</span> <kbd>isa</kbd> and <kbd>&lt;:</kbd> operators. </p>
<p>A concrete type is associated with an abstract type as a supertype. If the supertype is not specified, then it is assumed to be <kbd>Any</kbd>. A concrete type does not allow subtypes. This means that every concrete type must be final, and would be a leaf node in a type hierarchy. Concrete types are also first class, just like abstract types.</p>
<p>Both abstract types and concrete types can be <span>referred to</span> in a <kbd>Union</kbd> type.</p>
<p><span>What we just mentioned may be surprising to p</span><span>eople who come from an object-oriented programming background. </span><span>First, you may wonder why concrete types do not allow subtypes. Second, you may wonder why abstract types can't be defined with fields. This design is actually intentional and was debated heavily by the core Julia development team. The debate is related to behavioral inheritance versus structural inheritance, which will be discussed in <a href="97049a94-ad30-452a-bbb0-296d9438c886.xhtml">Chapter 12</a>, <em>Inheritance and Variance</em>.</span></p>
<p>Now, let's switch gear and go over the parametric type feature of the Julia language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with parametric types</h1>
                </header>
            
            <article>
                
<p>One of the most powerful features of the Julia language is the ability to parameterize types. It is actually quite difficult to find any Julia package that does not use this feature. Parametric types allow the software designer to generalize types, and let the Julia runtime automatically compile to the concrete version based on the specified parameters.</p>
<p class="mce-root"/>
<p>Let's take a look at how this works with composite and abstract types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with parametric composite types</h1>
                </header>
            
            <article>
                
<p>When designing composite types, we should assign each field a type. Oftentimes, we don't really care exactly what those types are, as long as the type provides the functionality that we want. </p>
<p>A classic example would be numeric types. The concept of numbers is simple: basically the same as we were taught in elementary school. In practice, many numeric types are implemented in computer systems because of the different physical storage and representations of data. </p>
<p>By default, Julia ships with the following numeric types; concrete types are darker:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed69deaa-7703-4d91-9dd5-072bd38fe537.png" style="width:51.33em;height:27.42em;"/></p>
<p>Do you remember when we designed a composite type to represent a stock in an investment portfolio earlier in this chapter? Let's revisit that example here:</p>
<pre>struct Stock &lt;: Equity<br/>    symbol::String<br/>    name::String<br/>end</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If I have to hold some stocks in my brokerage account, then I should also keep track of the number of shares that I own. To do this, I can define a new type called <kbd>StockHolding</kbd>, as follows:</p>
<pre>struct StockHolding<br/>    stock::Stock<br/>    quantity::Int<br/>end</pre>
<p>The <kbd>Int</kbd> data type is by default aliased to either <kbd>Int64</kbd> or <kbd>Int32</kbd>, depending on whether you are using the 64-bit or 32-bit version of Julia. This seems reasonable just to get started, but what if we need to support fractional shares for a different use case? In that case, we can just change the type of <kbd>quantity</kbd> to <kbd>Float64</kbd>:</p>
<pre>struct StockHolding<br/>    stock::Stock<br/>    quantity::Float64<br/>end</pre>
<p>We basically widen the type of <kbd>quantity</kbd> field to a type that supports both integer and floating-point values. It may be a reasonable approach, but if we need to support both <kbd>Int</kbd> and <kbd>Float64</kbd> types, then we would have to maintain two slightly different types. Sadly, if we do create two different types, then it becomes a maintenance nightmare.</p>
<p>To make it more flexible, we can redesign the <kbd>StockHolding</kbd> type with a parameter:</p>
<pre>struct StockHolding{T} <br/>    stock::Stock<br/>    quantity::T<br/>end</pre>
<p>The symbol <kbd>T</kbd> inside the curly braces is called a <em>type parameter</em>. It serves as a placeholder that can be used as a type in any of the fields.</p>
<p>Now, we have the best of both worlds. The <kbd>StockHolding{Int}</kbd> type refers to the type that contains a <kbd>quantity</kbd> field of the <kbd>Int</kbd> <span>type</span><span>. Likewise, the</span> <kbd>StockHolding{Float64}</kbd> <span>refers to the type that contains a</span> <kbd>quantity</kbd> <span>field of the</span> <kbd>Float64</kbd> <span>type</span><span>. </span></p>
<p>In practice, the <span><kbd>T</kbd> </span>type parameter can only be a numeric type, so we could further qualify <kbd>T</kbd> as any subtype of <kbd>Real</kbd>:</p>
<pre>struct StockHolding{T &lt;: Real} <br/>    stock::Stock<br/>    quantity::T<br/>end</pre>
<p class="mce-root"/>
<p>Here's how we read this—<em>the</em> <kbd>StockHolding</kbd> <em>type contains a stock and a quantity of the </em><kbd>T</kbd> <em>type that is a subtype of</em> <kbd>Real</kbd><span>. The second part of the sentence is important; it means that we can create a new</span> <kbd>StockHolding</kbd><span> with the type of </span><kbd>quantity</kbd> <span>as <kbd>Float16</kbd>, <kbd>Float32</kbd>, <kbd>Float64</kbd>, <kbd>Int8</kbd>, <kbd>Int16</kbd>, <kbd>Int32</kbd>, and so on.</span></p>
<p>Let's try instantiating the <kbd>StockHolding</kbd> object with different kinds of type parameter, such as <kbd>Int</kbd>, <kbd>Float64</kbd>, and <kbd>Rational</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/481f7308-e43e-4b20-86e5-12f09c65965f.png" style="width:37.75em;height:12.67em;"/></p>
<p>We can see that different <kbd>StockHolding{T}</kbd> types are created automatically according to the argument that was passed to the constructor.</p>
<p><span>Another use of parametric types is to enforce the consistency of field types. Suppose that </span><span>we want to design another kind of stock-holding object to track the price and market value of the holding. Let's call it <kbd>StockHolding2</kbd> to avoid confusion with the preceding one. The following is what it looks like:</span></p>
<pre>struct StockHolding2{T &lt;: Real, P &lt;: AbstractFloat} <br/>    stock::Stock<br/>    quantity::T<br/>    price::P<br/>    marketvalue::P<br/>end</pre>
<p>Knowing that the type for <kbd>quantity</kbd> may not be the same as the type for <kbd>price</kbd> and <kbd>marketvalue</kbd>, we have added a new type parameter, <kbd>P</kbd>. Now, we can instantiate a <kbd>StockHolding2</kbd> object that contains an integer quantity while having floating-point values for price and market value fields:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/debf66c0-e43e-44a2-a70c-0dc844f8b4d0.png" style="width:42.08em;height:3.33em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>Note that the type is <kbd>StockHolding2{Int64, Float64}</kbd>, as shown in the preceding screenshot. In this case, the type parameter <kbd>T</kbd> is <kbd>Int64</kbd> and the parameter <kbd>P</kbd> is <kbd>Float64</kbd>. </span></p>
<p><span>As we declared that both the <kbd>price</kbd> and <kbd>marketvalue</kbd> fields must be of the same type, <kbd>P</kbd>, does Julia enforce this rule for us? Let's give it a try:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a65ab845-d29f-49cc-a4a8-8eb6448603ee.png" style="width:37.08em;height:9.58em;"/></p>
<p><em>Yes, it does!</em> We correctly received an error because we passed a <kbd>Float64</kbd> value for <kbd>price</kbd>, but an <kbd>Int64</kbd> for <kbd>marketvalue</kbd>. Let's take a closer look at the error message, which revealed what the system expects. The closest candidate function for <kbd>StockHolding2</kbd> takes a <kbd>P</kbd> <span>type</span><span> </span><span>for the third and fourth arguments, where</span> <kbd>P</kbd> <span>is any subtype of</span> <kbd>AbstractFloat</kbd><span>. Because</span> <kbd>In64</kbd> <span>is not a subtype of</span> <kbd>AbstractFloat</kbd><span>, there is no match and so an error was thrown. </span></p>
<p>Parametric types can be abstract as well. We will go over this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with parametric abstract types</h1>
                </header>
            
            <article>
                
<p><span>Abstract types can be enhanced i</span>n the same way that composite types can be parameterized. Let's continue with the preceding example. Suppose that we want to build an abstract type called <kbd>Holding</kbd> that keeps track of a <kbd>P</kbd> <span>type</span><span> </span><span>that is used by its subtypes. We can code it as follows:</span></p>
<pre>abstract type Holding{P} end</pre>
<p>Then, every subtype of <kbd>Holding{P}</kbd> must also take a  <kbd>P</kbd> <span>t</span><span>ype parameter</span><span>. As an example, we can create two new types —</span><kbd>StockHolding3{T,P}</kbd> <span>and</span> <kbd>CashHolding{P}</kbd><span>:</span></p>
<pre>struct StockHolding3{T, P} &lt;: Holding{P}</pre>
<pre><br/> stock::Stock<br/> quantity::T<br/> price::P<br/> marketvalue::P<br/>end<br/><br/>struct CashHolding{P} &lt;: Holding{P}<br/> currency::String<br/> amount::P<br/> marketvalue::P<br/>end</pre>
<p>We can examine how these types are related as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18a9dd07-410b-4a41-a02a-b4a485ef45a2.png" style="width:34.83em;height:3.25em;"/></p>
<p>Let's create a new <kbd>StockHolding3</kbd> object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/41285d50-bf70-4fac-a6e1-4455b4b3895e.png" style="width:47.00em;height:7.00em;"/></p>
<p><span>As expected, the <kbd>certificate_in_the_safe</kbd> object is a subtype of </span><kbd>Holding{Float64}</kbd>.</p>
<p>Note that, when a type is parameterized, each variation is considered as a separate type that is unrelated to the others, except that they have a common supertype. As an example, <kbd>Holding{Int}</kbd> is a different type from <kbd>Holding{Float64}</kbd>, but they are both subtypes of <kbd>Holding</kbd>. Let's quickly prove this to ourselves:</p>
<p> </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6371c808-59b0-463e-ba85-59b974c893e8.png" style="width:22.50em;height:7.42em;"/></p>
<p>In summary, Julia comes with a very rich type system that a programmer can use to reason how each type relates to other types. Abstract types allow us to define behaviors in a hierarchy of relationships, and concrete types are used to define how data is stored. Parametric types are used to extend existing types to variations of field types. All of these language constructs allow the programmer to model data and behavior effectively.</p>
<p>Next, we will look into data type conversions and how they apply to functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conversion between data types</h1>
                </header>
            
            <article>
                
<p><span>We often need to convert data from one type to another in order to leverage existing library functions. A great working example would be the standard numerical data types. It is a common use case to convert a piece of date from an integer to a floating-point number in most mathematical functions.</span></p>
<p>In this section, we will learn about how data type conversion is performed in Julia. As it turns out, data type conversions are expected to be implemented explicitly; however, a set of rules has been implemented so that some conversions are automatically invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing simple data type conversion</h1>
                </header>
            
            <article>
                
<p>There are two ways to convert a value from one data type to another. The obvious choice is to construct a new object from an existing value. For example, we can construct a <kbd>Float64</kbd> object from a rational number as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fbf568bb-125b-42cc-af66-b9c3d1011b10.png" style="width:13.67em;height:3.33em;"/></p>
<p>Another way is to use the <kbd>convert</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7d6cb216-8e5b-4ee5-b537-343c21953ebf.png" style="width:19.92em;height:3.33em;"/></p>
<p>Either way works fine. There is an advantage from using the <kbd>convert</kbd> function when considering performance optimization, as we will explain later in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Beware of lossy conversions</h1>
                </header>
            
            <article>
                
<p><span>When it comes to conversion, it is important to consider whether the conversion is lossless or lossy. In general, it is expected that data type conversion is lossless, which means that, when you convert from one type to another and back, you get the same value.</span></p>
<p><span>Because of the numerical representation of floating-point numbers, such perfect conversion is not always possible. For example, let's try to c</span><span>onvert</span><span> </span><kbd>1//3</kbd><span> </span><span>to</span><span> </span><kbd>Float64</kbd><span> </span><span>and then convert it back to</span><span> </span><kbd>Rational</kbd><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b944aeed-5ed8-4231-8af0-40dea9469ebf.png" style="width:30.08em;height:7.17em;"/></p>
<p>Because of a rounding error, it is not possible to reconstruct <kbd>1//3</kbd> after it was converted to a <kbd>Float64</kbd> type. The problem is not restricted to the <kbd>Rational</kbd> type. We can easily break this again by converting the value from an <kbd>Int64</kbd> to a <kbd>Float64</kbd> and back, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/015472e3-fb61-42d6-8c91-77ce98cc730f.png" style="width:30.42em;height:7.25em;"/></p>
<p>We can see that there is a loss of precision here. While we may not be very satisfied with these results, there is really not much that we can do here as long as we use the <kbd>Float64</kbd> type. The <kbd>Float64</kbd> type is implemented according to the IEEE 754 floating-point specification, and it is expected to carry precision errors. If you need more precision, you can use <kbd>BigFloat</kbd> instead, which solves this particular problem:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc94641d-6994-4e4a-aa7d-23590048ec62.png" style="width:34.67em;height:3.50em;"/></p>
<p>When handling floating-point values, we should be cautious about precision issues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding numeric type conversions</h1>
                </header>
            
            <article>
                
<p>Julia does not <span>automatically </span>perform conversion on data types for safety reasons. Every conversion must be explicitly defined by the programmer. </p>
<p>To make it easier for everyone, Julia <span>already</span><span> contains conversion functions for numeric types by default. For instance, you can find this interesting piece of code </span><span>from the <kbd>Base</kbd> package</span><span>:</span></p>
<pre>convert(::Type{T}, x::T) where {T&lt;:Number} = x<br/>convert(::Type{T}, x::Number) where {T&lt;:Number} = T(x)</pre>
<p class="mce-root"/>
<p>Both functions take the first argument of the <kbd>Type{T}</kbd> <span>type,</span><span> where</span> <kbd>T</kbd> <span>is a subtype of</span> <kbd>Number</kbd><span>. Valid values include all standard numeric types, such as</span> <kbd>Int64</kbd><span>,</span> <kbd>Int32</kbd><span>,</span> <kbd>Float64</kbd><span>,</span> <kbd>Float32</kbd><span>, and so on.</span></p>
<p>Let's try to understand these two functions further:</p>
<ul>
<li>The first function says that it's as easy as returning the argument <kbd>x</kbd> itself when we want to convert <kbd>x</kbd> from the <kbd>T</kbd> type and to the <kbd>T</kbd> type (the same type) as long as <kbd>T</kbd> is a subtype of <kbd>Number</kbd>. This can be considered a performance optimization because there is really no need to do any conversion when the target type is the same as the input.</li>
<li>The second function is a little more interesting. In order to convert <kbd>x</kbd>, which is a subtype of <kbd>Number</kbd>, to type <kbd>T</kbd>, which is also a subtype of <kbd>Number</kbd>, it just calls the constructor of the <kbd>T</kbd> type with <kbd>x</kbd>. In other words, this function can handle the conversion of any <kbd>Number</kbd> type to another type that is a subtype of <kbd>Number</kbd>.</li>
</ul>
<p>You may wonder why we don't just use the constructor in the first place. This is because the <kbd>convert</kbd> function is designed to be invoked automatically for various common use cases. As you can see from what we looked at previously, this extra indirection also allows us to bypass the constructor when conversion is unnecessary.</p>
<p>When does <kbd>convert</kbd> get called? The answer is that Julia does not automatically do that, except for a few scenarios. We will explore these scenarios in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reviewing the rules for automatic conversion</h1>
                </header>
            
            <article>
                
<p>As data type conversion is a fairly standard operation, Julia is designed to automatically call the <kbd>convert</kbd> function in the following scenarios:</p>
<ol>
<li>Assigning a value to an array converts the value to the array's element type.</li>
<li>Assigning a value to a field of an object converts the value to the declared type of the field.</li>
<li>Constructing an object with <kbd>new</kbd><span> </span>converts the value to the object's declared field type.</li>
<li>Assigning a value to a variable with a declared type converts the value to that type</li>
<li>A function with a declared return type converts its return value to that type.</li>
<li>Passing a value to<span> <kbd>ccall</kbd></span><span> </span>converts the value to the corresponding argument type.</li>
</ol>
<p>Let's confirm that these are indeed working as advertised.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 1: Assigning a value to an array</h1>
                </header>
            
            <article>
                
<p>In the following example, assigning the <kbd>1</kbd> <span>value </span>to a <kbd>Float64</kbd> array would convert the former into a floating-point value, <kbd>1.0</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1dea2c68-d2ee-42cb-99c7-2715fa241ec1.png" style="width:15.83em;height:17.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 2: Assigning a value to a field of an object</h1>
                </header>
            
            <article>
                
<p>In the following example, the <kbd>Foo</kbd> <span>struct </span>accepts a <kbd>Float64</kbd> field. When the field is assigned a value of <kbd>2</kbd>, it is converted to <kbd>2.0</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3d131da0-5931-403d-b326-ca428f788a07.png" style="width:15.75em;height:16.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 3: Constructing an object with the new function </h1>
                </header>
            
            <article>
                
<p>In the following example, the <kbd>Foo</kbd> constructor automatically converts <kbd>1</kbd> to <kbd>1.0</kbd> when creating the <kbd>Foo</kbd> object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8105a156-8030-40f9-9a7f-8b503350c50e.png" style="width:16.67em;height:9.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 4: Assigning to a variable that has a declared type</h1>
                </header>
            
            <article>
                
<p>In the following example, the local variable <kbd>x</kbd> is declared as a <kbd>Float64</kbd> type. When it is assigned the <kbd>1</kbd> value, it is converted to <kbd>1.0</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dedf63f0-4e75-4ede-b457-c0157334d8da.png" style="width:27.75em;height:11.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 5: Function has a declared return type</h1>
                </header>
            
            <article>
                
<p>In the following example, the <kbd><span>foo</span></kbd> function is declared to return a <kbd>Float64</kbd> value. Even though the <kbd>return</kbd> statement says <kbd>1</kbd>, it is converted to <kbd>1.0</kbd> before it is returned:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1e667993-c8ba-49ba-bade-fa8f21030db4.png" style="width:20.67em;height:9.08em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 6: Passing a value to ccall</h1>
                </header>
            
            <article>
                
<p>In the following example, the <kbd>exp</kbd> function from the C library is used to calculate the exponent of a number. It expects a <kbd>Float64</kbd> value as an argument, so when the value of <kbd>2</kbd> is passed to <kbd>ccall</kbd>, it is converted to <kbd>2.0</kbd> before being passed to the C function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/20fc4eaa-ee41-437e-a192-5f2a61730f26.png" style="width:32.17em;height:3.00em;"/></p>
<p>All that is good, but something seems to be missing. What about the most common use case: passing an argument to a function? Wouldn't it be called if Julia auto-converts the arguments as well? The answer may be a little surprising. Let's look at this in more detail in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the rules for function dispatches</h1>
                </header>
            
            <article>
                
<p>Julia is a strongly typed language, which means that the programmer has to be very clear about the types being passed around. A function can only be called (also known as dispatched) when the types of its arguments are matched properly. A proper match can be defined as one that matches exactly (same type) or when the argument being passed is a subtype of what is expected in the function's signature.</p>
<p>To illustrate this, let's create a function that doubles the value of its argument of the <kbd>AbstractFloat </kbd><span>type</span><span>. We will use our <kbd>subtypetree</kbd> utility function</span> <span>to quickly find out its subtypes:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0914d4c3-d9f0-4530-9ce4-0e59adb27ef7.png" style="width:38.42em;height:17.33em;"/></p>
<p>What happens if we pass an integer to the function? Well, it doesn't work too well:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c9dab163-8585-4866-91fe-0dcdef913ba3.png" style="width:29.33em;height:2.58em;"/></p>
<p>Naively, we may think that the system should auto-convert the argument to <kbd>Float64</kbd> and then double the value. Well, it does not. It is not a conversion issue. To get that effect, we could obviously write another function that takes an <kbd>Int</kbd> argument, then converts it to <kbd>Float64</kbd>, and calls the original function. But the code would look exactly the same, and it's a duplication of effort. This problem can be solved by just writing the function more generically:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1c90dabc-789b-4b96-9784-b5cccfab5487.png" style="width:19.75em;height:9.08em;"/></p>
<p>If we feel that the argument has to be a <kbd>Number</kbd>, then we can restrict it again as such:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88d30233-35fd-4f07-a172-2010d57b28ee.png" style="width:20.75em;height:12.92em;"/></p>
<p>What we choose to do here depends on how flexible we want the function to be. The benefit of specifying an abstract type, such as <kbd>Number</kbd>, is that we feel sure the function will work well for any type that implements the behavior set down by <kbd>Number</kbd>. On the other hand, if we leave it as untyped in the function definition, then we open up the possibility for other objects to be passed to the function as long as the <kbd>*</kbd> operator is defined.</p>
<p>In this section, we have learned about how data type conversion can be performed in Julia. In certain scenarios, Julia can also automatically convert numeric types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started discussing the importance of organizing source code for larger applications. We explored in detail how to establish namespaces and how to implement them using modules and submodules. To manage package dependencies, we introduced the concept of semantic versioning and learned how to use it properly with Julia's package manager.</p>
<p>Then, we went over the details of how to design an abstract type hierarchy and define functions for abstract types. We also discussed concrete types and the concepts of immutability and mutability. We demonstrated how to use union types when working with data types from different abstract type hierarchies. We looked at two common operators (<kbd>isa</kbd> and <em>is-a-subtype-of</em>) for data types. To further reuse data types, we introduced parametric types and looked at how they apply to both concrete types and abstract types.</p>
<p>Finally, we looked at the <kbd>convert</kbd> function in Julia and how it is invoked automatically under certain circumstances. We learned how Julia’s function dispatch works and how to make a function more flexible by accepting broader abstract types in its arguments.</p>
<p>At this point, you should have a good understanding about how to organize code and designing your own data types.</p>
<p>In the next chapter, we will look at how to define application behavior using functions and Julia's multiple-dispatch facility.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p><span>Go through the following questions t</span>o test your understanding of the subjects in this chapter.  The answers are provided at the back of the book:</p>
<ol>
<li>How do we create a new namespace?</li>
<li>How do we expose the functions of a module to the outside world?</li>
<li>How do we reference the proper function when the same function name is exported from different packages?</li>
<li>When do we separate code into multiple modules?</li>
<li>Why is semantic versioning important in managing package dependencies?</li>
<li>How is defining functional behavior for abstract types useful?</li>
<li>When should we make a type mutable?</li>
<li>How are parametric types useful?</li>
</ol>


            </article>

            
        </section>
    </body></html>