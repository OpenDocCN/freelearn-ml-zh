- en: Chapter 8.  Building Real-Time Recommendations with Neo4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world we live in is a big, interconnected place. Anything and everything
    that exists in this world is connected together in some way. Relationships and
    connections exist among the entities that inhabit this world.
  prefs: []
  type: TYPE_NORMAL
- en: The human brain tries to store or extract information in the form of networks
    and relations. Perhaps this is a more optimal way of representing data, so that
    storing and retrieval of information is fast and efficient. What if we have a
    system that works in a similar way. We can use graphs; they are a systematic and
    methodical approach to representing data.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move ahead with this chapter it is essential to understand the background
    and necessity of graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Credit for the concept behind the graph theory is given to the 18^(th) Century
    mathematician, Leonhard Euler, who solved the age-old problem known as The Bridges
    of Konigsberg, which is essentially a pathfinding problem. Although we won't look
    further at this problem, I suggest that readers attempt to understand how Euler
    has come up with a new paradigm approach in understanding and solving the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs are found everywhere in today's world and are one of the most efficient
    and natural ways of working with data.
  prefs: []
  type: TYPE_NORMAL
- en: Graph can represent how two or more real world entities, represented as nodes,
    are connected to each other. We also learn how each of them are related to the
    other, and how this helps to communicate information in a  fast, efficient , visual way.
    Since graph systems allow us to express anything in an expressive, structured
    way, we can apply these systems across domains such as social networks, medicine,
    science and technology and many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand graph representation, we can take an example of networking
    on Facebook. Let us assume there are three friends **John**, **Paul** and **Krish**,
    connected on Facebook. JOHN-KRISH are mutual friends, PAUL-KRISH are mutual friends
    and PAUL is `**FriendOf**`  of JOHN. How do we represent this information? Take
    a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building Real-Time Recommendations with Neo4j](img/image00419.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Don't we feel that the above representation is one of the  most efficient and
    natural ways of representing data and its relations? In the previous diagram,
    JOHN-KRISH-PAUL are *Nodes* representing User entities, and `FriendOf` arrows
    are edges which represents the *relationships* between the Nodes. We can also
    store the demographic details of User Nodes - such as age and details of relationship
     (such as FriendSince) - as *Properties* in the Graphs. By applying Graph Theory
    concepts we can find similar Users in a Network or suggest new Friends to Users
    within the Friends Network. We shall learn about more on this in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: Discerning different graph databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph databases have revolutionized the way people discover new products and
    share information with one another. In the human mind, we remember people, things,
    places, and so on, as graphs, relations, and networks. When we try to fetch information
    from these networks we go directly to the required connection or graph and fetch
    information accurately. In a similar fashion, graph databases allow us to store
    the users and product information in graphs as nodes and edges (relations). Searching
    a graph database is fast.
  prefs: []
  type: TYPE_NORMAL
- en: A graph database is a type of NoSQL database that uses graph theory to store,
    map and query relationships. Graph databases excel at managing highly connected
    data and managing complex queries. They are mainly used for analyzing the interconnections
    between data. Here, the priority is given to relations, so that we don't have
    to bother with the foreign keys, as in the case of SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Graph databases mainly consist of nodes and edges, wherein nodes represent the
    entities and edges the relations between them. The edges are directed lines or
    arrows that connect the nodes. In the preceding diagram, the circles are the nodes
    that represent the entities, and the lines connecting the nodes are called the
    edges - these represent relationships. The orientation of arrows follows the flow
    of information. By presenting all nodes and links of the graph, it helps users
    get a global view of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Neo4j, FlockDB, AllegroGraph, GraphDB, and InfiniteGraph are some of the graph
    databases available. Let us have a look at Neo4j, one of the most popular among
    them, made by Neo Technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neo4j is so popular because of its strength, swiftness and scalability. It
    is mainly implemented in Scala and Java. It is available in both the community
    and enterprise editions. The enterprise edition has the same features as the community
    one, with additional features like enterprise-grade availability, management and
    scale-up and scale-out capabilities. In the case of RDBMS, the performance degrades
    exponentially as the number of relations increases, whereas in Neo4j it is linear.
    The following image shows the various graph databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discerning different graph databases](img/image00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Labeled property graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the introduction section, we have seen an example of a Social Network representation
    of three friends. This graph representation of data which contains directed connections
    between entities/nodes, relationships between nodes, and properties associated
    with nodes and relationships is called a **labeled property graph data model**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A labeled property graph data model has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Graph contains nodes and relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes may contain properties (key-value pairs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes may be labeled with one or more labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships are named and directed, and always have a start and end node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships may also contain properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listed concepts are explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraphDB core concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following list enumerates all the elements of a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes**: Nodes are the fundamental unit of a graph. Nodes are the vertices
    in the graph. It mostly refers to the main object that is being referred. Nodes
    can contains labels and properties. From the story, we can pull three different
    objects and make three nodes. Two of those are for friends and the other one is
    for the movie.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Labels**: Labels are the way to differentiate between the same kinds of objects.
    Labels are generally given to each node with similar characteristics. Nodes can
    have more than one label. In the example story, we gave labels of **PERSON** and
    **MOVIE**. This optimized the graph traversal and also helped in logically querying
    the model efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationships**: Relationships are the edge between two nodes. They can be
    unidirectional and bidirectional. They can also contain the property for which
    the relationship is being created. Relationships are named and directed, and always
    have a start and end node. For example, there is a relationship of *Friend Of*
    between two friends. This shows the connection between different nodes. There
    is also a relation of *Has Watched* between each of the friends with the movie
    node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties**: Properties are key value pairs. Properties can be used for
    both nodes and relationships. They are used to save the details about a particular
    node or relationship. In the example, the Person node has the properties of name
    and age. These properties are used to distinguish different nodes. Relation Has
    Watched also has the properties of date and rating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following diagram, **JOHN**, **KRISH**, and **PAUL** are nodes that
    are mapped as User labels. Also, observe the edges that show relations. Both nodes
    and relations can have properties to further describe them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding GraphDB core concepts](img/image00421.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Neo4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Neo4j is an open-source Graph Database implemented in Java and Scala. Neo4j
    implements labeled property graph model efficiently. Like any other database,
    Neo4j provides ACID transactions, runtime fail-over and cluster support, allowing
    it for developing production ready applications. This graph database architecture
    is designed for efficient data storage and faster traversal between Nodes and
    relations. To work with the data for storing, retrievals and traversal, we use
    **CYPHER query language** which is Neo4j's query language based on patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Cypher query language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypher is the query language for Neo4j that follows SQL-like queries. It is
    a declarative query language that focuses on what to retrieve from the graph,
    rather than how to retrieve it. We know that Neo4j property graphs consist of
    nodes and relationships; though these nodes and relationships are the basic building
    blocks, the real power of a graph database is to identify the underlying patterns
    that exist between nodes and relationships. This pattern extraction capability
    of graph databases, such as Neo4j, helps us to perform complex operations very
    quickly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Neo4j's Cypher query language is based on patterns. These patterns are used
    for matching underlying graph structures so that we may make use of patterns for
    further processing, such as building recommendation engines, in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of extracting patterns using a Cypher query is shown later. The
    following Cypher query matches all *friendof* patterns between pairs of users
    and returns them as a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cypher query language](img/image00422.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Cypher query basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we go into building recommendations using Neo4j, let us look into the
    basics of Cypher query. As we mentioned earlier, Cypher is the query language
    for Neo4j that follows SQL-like queries. Being a declarative language, Cypher
    focuses on what to retrieve from the graph rather than how to retrieve it. The
    key principles and capabilities of Cypher are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cypher matches key patterns between nodes and relationships in the graph to
    extract information from the graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cypher has many capabilities similar to SQL such as create, delete, and update.
    These operations are applied to nodes and relationships to fetch information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing and constraints similar to SQL are also present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypher uses pairs of parentheses `()` or pairs of parenthesis with text inside
    to represent nodes. Furthermore, we can assign labels, and properties of nodes
    are given as key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example to understand the concept better. In the following
    queries, node is represented using `()` or `(user)`, label is represented with
    `u`, `(u:user)` and properties of the node are assigned with key-value pairs as
    `(u:user{name:''Toby''})` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Relationship syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypher uses `-[]->` to represent relationships between two nodes. These relationships
    allow developers to represent complex relations between nodes, making them easier
    to read or understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, a `friendof` relationship is established between two
    user nodes and the relationship is having property `since:2016`.
  prefs: []
  type: TYPE_NORMAL
- en: Building your first graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we saw the node syntax and relationship syntax, let us practice what
    we have learned so far by creating a Facebook social network graph similar to
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your first graph](img/image00423.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to create the above graph, we need following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create 3 nodes Person with labels JOHN, PAUL, KRISH
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create relationships between 3 Nodes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display results used with all the patterns
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the `CREATE` clause to create graph elements such as nodes and relations.
    The below example shows us how to create a single node Person labeled as john
    and having the property name:`JOHN`. When we run the below query in Neo4j browser,
    we get the graph as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating nodes](img/image00424.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RETURN clause helps to return the result set, namely Node - PERSON
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of just creating one node, we can create multiple nodes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier code will create three nodes, and Person labelled `JOHN`, `PAUL`, `KRISH`.
    Let''s see what we have created so far; to see the results we have to use `MATCH`
    clause. `MATCH` clause will check for the required patterns and return the retrieved
    patterns using `RETURN` clause. In the below query, `MATCH` will look for patterns
    such as Person nodes with labels names `k`,`p`,`j` and their corresponding labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating nodes](img/image00425.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With creation of nodes we are half done. Now, let's complete the remaining portion
    by creating relations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions for creating relationships are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the nodes from the database using the `MATCH` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the required relationships between the `Persons` using the `CREATE` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following query, we are extracting all the `Person` nodes and then creating
    relationships called `FRIENDOF` between the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the result displayed when we run the earlier
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating relationships](img/image00426.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have created all the required nodes and relationships. To see what we
    have achieved, run the following query, which displays Nodes and relationships
    between the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating relationships](img/image00427.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Setting properties to relations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final step is to set properties to node labels and relationships, and is
    explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `SET` clause to set the properties. For setting properties to relations
    we need to follow two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract all the relations , `FRIENDOF`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SET` clause to set the properties to these relations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, we set the properties to the relation `FRIENDOF`
    between `KRISH` and `PAUL` with the property `friendsince` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Setting properties to relations](img/image00428.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous query , `()-[]->` pattern extracts relation `Krish` is `friendOfPaul`
    and `() <- [] -` pattern extracts relation `Paul` is `friendOf` of `Krish.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s display the results so far as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The following diagram shows the nodes, relationships and properties added in
    the previous query.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting properties to relations](img/image00429.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram we can see that for `KRISH` and `PAUL` the property
    for the `FRIENDOF` relation has been set as `friendsince`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can set the properties to the nodes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Setting properties to relations](img/image00430.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s verify the results here using the following query, which displays nodes,
    relationships, labels, properties to nodes, and relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Setting properties to relations](img/image00431.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Loading data from csv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we created nodes, relationships, and properties manually.
    Most of the time, we create nodes by loading data from csv files. To achieve this,
    we use the `LOAD CSV` command readily available in Neo4j, to load data into the
    Neo4j browser.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the dataset we will be using for this section
    which contains user-movie-rating data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading data from csv](img/image00432.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Query below to load csv data given below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding query:'
  prefs: []
  type: TYPE_NORMAL
- en: The **HEADERS** keyword allows us to ask the query engine to consider the first
    row as header information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **WITH** keyword is similar to the return keyword; it separate portions
    of the query explicitly and allows us to define which values or variables we should
    carry forward to the next parts of the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **AS** keyword is used to create an alias name to variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run the above query, two things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CSV** data will be loaded to the graph database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **RETURN** clause will display the loaded data, as shown in the following
    screenshot:![Loading data from csv](img/image00433.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neo4j Windows installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how to install Neo4j for Windows. We can download
    the Neo4j Windows installer from the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://neo4j.com/download/](https://neo4j.com/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neo4j Windows installation](img/image00434.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the installer is downloaded, click on the installer to get the following
    screen to proceed with installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neo4j Windows installation](img/image00435.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After successful installation, start the Neo4j Community Edition. For the first
    time you will see the following screen, asking you to choose a directory to store
    the graph database, and then click on **Start**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neo4j Windows installation](img/image00436.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case we have chosen the default directory where the `graphdb` database
    is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After we click the start button, as shown in the preceding screenshot, start Neo4j
    will be started and will be displayed as below. We are now ready to start working
    on Neo4j.
  prefs: []
  type: TYPE_NORMAL
- en: '![Neo4j Windows installation](img/image00437.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have started Neo4j, we can access it from the browser by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:7474`'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Neo4j on the Linux platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we learn about downloading and installing Neo4j on the CentOS
    Linux platform.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Neo4j
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can download the latest version of the Neo4j 3 Linux source file from the
    Neo4j home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://Neo4J.com/](https://neo4j.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Download Neo4J** button on the page shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading Neo4j](img/image00438.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively you can download it directly from the following URL:[http://info.Neo4J.com/download-thanks.html?edition=community&release=3.0.6&flavour=unix&_ga=1.171681440.1829638272.1475574249](http://info.neo4j.com/download-thanks.html?edition=community&release=3.0.6&flavour=unix&_ga=1.171681440.1829638272.1475574249)
  prefs: []
  type: TYPE_NORMAL
- en: 'This will download a `tar` file - `Neo4J-community-3.0.6-unix.tar.gz` as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading Neo4j](img/image00439.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can find the developer resources at [https://Neo4J.com/developer/get-started/](https://Neo4J.com/developer/get-started/)
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Neo4j
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extract the `tar` file and you will get a folder called `Neo4J-community-3.0.6`
    containing the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Neo4j](img/image00440.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Starting Neo4j from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you install Java 8 in your PC, as Neo4j 3.0 version requires Java
    8\. Check the Neo4j requirements before you install.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed Java 8 then we can go ahead and run our Neo4j instance,
    but before that, let us set the `Neo4J` path in the `bashrc` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We Start the `Neo4j` in command line using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Starting Neo4j from the command line](img/image00441.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can observe that the Neo4j has been started and we can access the graph `dbcapabilites`
    from the browser at `http://localhost:7474/`
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first time, running Neo4j in the browser requires you to set the **Username**
    and **Password**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting Neo4j from the command line](img/image00442.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have set the credentials it will redirect to the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting Neo4j from the command line](img/image00443.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are using it for the first time, spend some time on the browser to get
    acquainted with its features and explore the different options available on the
    left-hand panel. Enter the following command in the browser to display the connection
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Starting Neo4j from the command line](img/image00444.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Building recommendation engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to generate collaborative filtering recommendations
    using three approaches. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple count of co-rated movies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Euclidean distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cosine similarity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I would like to highlight a point at this junction. In earlier chapters, we
    learnt that for building recommendation engines using heuristic approaches, we
    used similarity calculations such as Euclidean distance/cosine distance. It is
    not necessary to use only these approaches; we are free to choose our own way
    of computing the closeness or extracting the similarity between two users just
    by simple counts as well, for example, similarity between two users can be extracted
    just by counting the number of the same movies two users have co-rated. If more
    movies have been co-rated by two users then we may assume that they are similar
    to each other. If the count of co-rated movies between two people is less then
    we may assume that their tastes are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'This assumption is taken to build our first recommendation engine and is explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For building a collaborative movie recommendation engine, we will build a system
    based on past movie rating behavior of users. The steps we follow can be summarized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data into an environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extracting relations and extracting similarity between users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recommendation step
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loading data into Neo4j
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though we have multiple ways of loading data into Neo4j, we use the `Load CSV`
    option to import the data into the browser tool. The following diagram shows the
    workflow of the process of loading the CSV process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading data into Neo4j](img/image00445.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The dataset we use for this section is the small sample data set containing
    Users-Movies-ratings, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading data into Neo4j](img/image00446.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s load the MovieLens data into the Neo4j browser tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now let's create Users and Movies as nodes and the ratings given by Users to
    Movies as the relations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MERGE` clause will find the query patterns in the data, and if it doesn''t
    find any it will create one. In the following example below, first it look for
    a User Node (pattern) and then creates one if it doesn''t exist. Since we have
    just loaded the data into GraphDB, we need to create nodes and establish relationships.
    Following code will first looks for the mentioned nodes and relationships; if
    not found it will create new nodes and relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the previous query, nodes, relationships, and properties will be
    created as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading data into Neo4j](img/image00447.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we shall understand each line one by one to make our understanding more
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Merge will create `USER` Node from `UserID` columns from the original data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `With` command will take the `User` node and line object to the next part
    of the query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create `Movie` Node using `MERGE` and `line.ItemId` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We carry forward the Movie, User nodes, and line object to the next part of
    the query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a relation between `USER` node and `MOVIE` node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have loaded the data into Neo4j, we can visualize the movie ratings
    data with users, movies and ratings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the following image, all users are created in green color, and movies are
    created in red color. We can also see the relationships as arrows with directions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading data into Neo4j](img/image00448.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Generating recommendations using Neo4j
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now created all the required graphs for building our first recommendation
    engine using Neo4j. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following query `COUNT()` function will count the number of instances,
    `collect()` will.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot will return movie recommendations to the sample user
    `''TOBY''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following query shows the recommendations made to Toby when we run the
    earlier query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating recommendations using Neo4j](img/image00449.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The concept behind making recommendations in the previous query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract pair of users who have rated the same movies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the count of commonly rated movies by each pair of users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The higher the commonly rated movie count, the more similar two users are to
    each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final step is to extract all the movies which similar users have rated,
    but which have not been rated by the active user, and suggest these new movies
    as recommendations to the active user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand the query we just saw step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: In line one, for each user (say `USER1`) who has rated a movie (say `MOVIE1`),
    select all the users (say `USER2`) who have also rated `MOVIE1`. For this `USER2`,
    also extract other movies rated by him, apart from `MOVIE1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line two, we carry similar users (`u1`,`u2`), calculating the count of co-rated
    movies by `u1`,`u2`, and extracting shared/co-rated movies by `u1`,`u2` to the
    next part of the query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line three, we now apply a filter where we choose those movies that are not
    being rated by `u1` and the count of co-rated movies greater than two.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line 4 we return new movies rated by similar users to `u1` as recommendations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative filtering using the Euclidean distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how to build recommendation engines using a
    simple count-based approach for identifying similar users, and then we chose movies
    from similar users which the active user has not rated or recommended.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, instead of computing the similarity between two users based
    on the simple count of co-rated movies, let us make use of the rating information
    and calculate the Euclidean distance, to come up with the similarity score.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following cypher query will generate recommendations for the user, Toby,
    based on the Euclidean similarity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to extract co-rated users by movies and calculate the Euclidean
    distance between co-rated users as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this code we are using `reduce()` and `extract()` to calculate the Euclidean
    distance. In order to apply mathematical calculations, we have changed the values
    to floating point numbers using the `float()` function in the following query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To see the Euclidean distance values between pairs of users, run the below
    query:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Collaborative filtering using the Euclidean distance](img/image00450.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the second step, we calculate the Euclidean distance using the formula *sqrt(sum((R1-R2)*(R1-R2)))*,
    where *R1* is the rating given by `Toby` for a `movie1` and *R2* is the other
    co-rated user''s rating for the same `movie1`, and we take the top three similar
    users, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is to suggest or recommend non-rated movies from the top three
    similar users to `Toby` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Collaborative filtering using the Euclidean distance](img/image00451.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let us explain the preceding query in detail as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we explained in the first step, we extract co-rated movies by users along
    with their ratings as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, Toby has rated three movies: Snakes on a Planet, Superman Returns,
    and You Me and Dupree. Now we have to extract other common users who have co-rated
    the same three movies as Toby. For this, we use the following query:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Collaborative filtering using the Euclidean distance](img/image00452.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The second step is to calculate the Euclidean distance between the ratings
    given to each co-rated movie by the other users, to the movies of Toby, and this
    is calculated using the following query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding query, we create and merge new relationships between each of
    the co-rated users to show the distance between two users, using the MERGE clause.
    Also, we set the property of the relationship as EUCSIM (which represents the
    Euclidean distance between each of the co-rated users) using the SET clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have created new relations and set the values of the similarity
    distances, let us view the results as given by the following query:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the similarity value for Toby with other users:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Collaborative filtering using the Euclidean distance](img/image00453.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The final step is to predict the non-rated movies by Toby, and then recommend
    the top-rating predicted items. To achieve this, we employ the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the movies rated by similar users to Toby, but not rated by Toby himself
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the ratings given for all the non-rated movies and average them, to predict
    the ratings that Toby might give to these movies.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the sorted results as per the predicted rating, in descending order.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve this, use the following query:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Collaborative filtering using the Euclidean distance](img/image00454.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let us understand the recommendations query line-by-line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following query fetches the patterns of all the users who are similar to
    Toby, and all the movies rated by similar users, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WHERE NOT` clause will filter out all the movies that have been rated
    by similar users but not by Toby, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Movies, similarity values and ratings given by the co-users are passed to the
    next part of the query using the `WITH` clause and the results are ordered by
    descending similarity value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After sorting the results based on the similarity values, we further allow
    values, such as movie name and ratings, to the next part of the query using the
    `WITH` clause, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the main step for recommending movies to Toby, predicting the ratings
    for non-rated movies by Toby by taking the average of movie ratings by similar
    users to Toby, and using the `REDUCE` clause, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we sort the final results and return the top movies to Toby as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Collaborative filtering using Cosine similarity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen recommendations based on simple count and Euclidean distances
    for identifying similar users, let us use Cosine similarity to calculate the similarity
    between users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following query is used to create a new relation called similarity between
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![Collaborative filtering using Cosine similarity](img/image00455.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us explore the similarity values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![Collaborative filtering using Cosine similarity](img/image00456.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We calculate the similar users for Toby as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the active user Toby, let us display the similarity values with respect
    to other users as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The following image displays the results by running the previous Cypher query;
    the results show the similarity value for Toby, with respect to other users.
  prefs: []
  type: TYPE_NORMAL
- en: '![Collaborative filtering using Cosine similarity](img/image00457.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let us start our recommendations of movies to Toby. The recommendation
    process is very similar to what we have done in the previous approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract movies rated by similar users to Toby but not rated by Toby himself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the ratings given for all the non-rated movies and average them to predict
    the ratings that Toby might give to these movies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the sorted results as per the predicted rating, in descending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![Collaborative filtering using Cosine similarity](img/image00458.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kudos! We have created recommendation engines using the Neo4j graph database.
    Let us recap what we have learned in this chapter. We started the chapter by giving
    a very brief introduction to graphs and graph databases. We covered a very short
    introduction to the core Neo4j graph database concepts such as the labeled property
    graph model, Nodes, Labels, Relationships, Cypher query language, Patterns, Node
    syntax, and Relationship Syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We also touched upon Cypher clauses that are useful in building recommendations,
    such as `MATCH` ,`CREATE` ,`LOADCSV` ,`RETURN` ,`AS` ,and `WITH`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we moved onto installation and setting up Neo4j from the browser tool in
    the Windows and Linux platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Once the entire working environment was setup to build our recommendation engines,
    we chose sample movie ratings data and implemented three types of collaborative
    filtering, such as simple distance based, Euclidean similarity based, and Cosine
    similarity based recommendations. In the next chapter, we will be exploring Mahout,
    a machine learning library available on Hadoop, for building scalable recommender
    systems.
  prefs: []
  type: TYPE_NORMAL
