- en: Chapter 8.  Building Real-Time Recommendations with Neo4j
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用Neo4j构建实时推荐
- en: The world we live in is a big, interconnected place. Anything and everything
    that exists in this world is connected together in some way. Relationships and
    connections exist among the entities that inhabit this world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活的世界是一个庞大且相互联系的地方。这个世界上存在的任何事物都以某种方式相互连接。居住在这个世界中的实体之间存在关系和联系。
- en: The human brain tries to store or extract information in the form of networks
    and relations. Perhaps this is a more optimal way of representing data, so that
    storing and retrieval of information is fast and efficient. What if we have a
    system that works in a similar way. We can use graphs; they are a systematic and
    methodical approach to representing data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 人类大脑试图以网络和关系的形式存储或提取信息。这可能是一种更优的数据表示方式，以便信息的存储和检索既快又高效。如果我们有一个以类似方式工作的系统会怎样。我们可以使用图；它们是表示数据的一种系统性和方法性的方法。
- en: Before we move ahead with this chapter it is essential to understand the background
    and necessity of graphs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续本章内容之前，理解图的概念的背景和必要性是至关重要的。
- en: Credit for the concept behind the graph theory is given to the 18^(th) Century
    mathematician, Leonhard Euler, who solved the age-old problem known as The Bridges
    of Konigsberg, which is essentially a pathfinding problem. Although we won't look
    further at this problem, I suggest that readers attempt to understand how Euler
    has come up with a new paradigm approach in understanding and solving the problem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图论背后的概念归功于18世纪的数学家莱昂哈德·欧拉，他解决了被称为柯尼斯堡桥问题这一古老的难题，这本质上是一个路径查找问题。尽管我们不会进一步探讨这个问题，但我建议读者尝试理解欧拉是如何提出一种新的范式方法来理解和解决这个问题的。
- en: Graphs are found everywhere in today's world and are one of the most efficient
    and natural ways of working with data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图在当今世界的各个方面都有所体现，并且是处理数据最有效和最自然的方式之一。
- en: Graph can represent how two or more real world entities, represented as nodes,
    are connected to each other. We also learn how each of them are related to the
    other, and how this helps to communicate information in a  fast, efficient , visual way.
    Since graph systems allow us to express anything in an expressive, structured
    way, we can apply these systems across domains such as social networks, medicine,
    science and technology and many more.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以表示两个或更多现实世界实体（作为节点）如何相互连接。我们还学习到它们如何相互关联，以及这如何有助于以快速、高效、直观的方式传递信息。由于图系统允许我们以表达性和结构化的方式表达任何事物，因此我们可以将这些系统应用于社交网络、医学、科学技术等多个领域。
- en: 'To better understand graph representation, we can take an example of networking
    on Facebook. Let us assume there are three friends **John**, **Paul** and **Krish**,
    connected on Facebook. JOHN-KRISH are mutual friends, PAUL-KRISH are mutual friends
    and PAUL is `**FriendOf**`  of JOHN. How do we represent this information? Take
    a look at the following diagram:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解图表示，我们可以以Facebook上的社交网络为例。让我们假设有三个朋友**John**、**Paul**和**Krish**在Facebook上相互连接。JOHN-KRISH是互为朋友，PAUL-KRISH是互为朋友，PAUL是**John**的`**FriendOf**`。我们如何表示这些信息？请看以下图表：
- en: '![Building Real-Time Recommendations with Neo4j](img/image00419.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![使用Neo4j构建实时推荐](img/image00419.jpeg)'
- en: Don't we feel that the above representation is one of the  most efficient and
    natural ways of representing data and its relations? In the previous diagram,
    JOHN-KRISH-PAUL are *Nodes* representing User entities, and `FriendOf` arrows
    are edges which represents the *relationships* between the Nodes. We can also
    store the demographic details of User Nodes - such as age and details of relationship
     (such as FriendSince) - as *Properties* in the Graphs. By applying Graph Theory
    concepts we can find similar Users in a Network or suggest new Friends to Users
    within the Friends Network. We shall learn about more on this in later sections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们难道不觉得上述表示是表示数据和其关系最有效和最自然的方式之一吗？在先前的图表中，JOHN-KRISH-PAUL是代表用户实体的*节点*，而`FriendOf`箭头是表示节点之间*关系*的边。我们还可以将用户节点的人口统计细节（如年龄和关系的细节，如FriendSince）作为图中的*属性*存储。通过应用图论概念，我们可以在网络中找到类似用户，或者在朋友网络中向用户推荐新朋友。我们将在后面的章节中了解更多关于这方面的内容。
- en: Discerning different graph databases
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分不同的图数据库
- en: Graph databases have revolutionized the way people discover new products and
    share information with one another. In the human mind, we remember people, things,
    places, and so on, as graphs, relations, and networks. When we try to fetch information
    from these networks we go directly to the required connection or graph and fetch
    information accurately. In a similar fashion, graph databases allow us to store
    the users and product information in graphs as nodes and edges (relations). Searching
    a graph database is fast.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库彻底改变了人们发现新产品和相互分享信息的方式。在人类大脑中，我们以图、关系和网络的形式记住人、事物、地点等。当我们尝试从这些网络中获取信息时，我们会直接前往所需的连接或图，并准确获取信息。以类似的方式，图数据库允许我们将用户和产品信息以节点和边（关系）的形式存储在图中。搜索图数据库的速度很快。
- en: A graph database is a type of NoSQL database that uses graph theory to store,
    map and query relationships. Graph databases excel at managing highly connected
    data and managing complex queries. They are mainly used for analyzing the interconnections
    between data. Here, the priority is given to relations, so that we don't have
    to bother with the foreign keys, as in the case of SQL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库是一种使用图论来存储、映射和查询关系的NoSQL数据库。图数据库在管理高度连接的数据和管理复杂查询方面表现出色。它们主要用于分析数据之间的相互关系。在这里，我们优先考虑关系，因此我们不必像在SQL中那样担心外键。
- en: Graph databases mainly consist of nodes and edges, wherein nodes represent the
    entities and edges the relations between them. The edges are directed lines or
    arrows that connect the nodes. In the preceding diagram, the circles are the nodes
    that represent the entities, and the lines connecting the nodes are called the
    edges - these represent relationships. The orientation of arrows follows the flow
    of information. By presenting all nodes and links of the graph, it helps users
    get a global view of the structure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库主要由节点和边组成，其中节点代表实体，边代表它们之间的关系。在先前的图中，圆圈是代表实体的节点，连接节点的线条称为边 - 这些代表关系。箭头的方向遵循信息的流动。通过展示图中的所有节点和链接，它帮助用户获得结构的全局视图。
- en: Neo4j, FlockDB, AllegroGraph, GraphDB, and InfiniteGraph are some of the graph
    databases available. Let us have a look at Neo4j, one of the most popular among
    them, made by Neo Technology.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j、FlockDB、AllegroGraph、GraphDB和InfiniteGraph是一些可用的图数据库。让我们看看Neo4j，这是其中最受欢迎的之一，由Neo
    Technology制作。
- en: 'Neo4j is so popular because of its strength, swiftness and scalability. It
    is mainly implemented in Scala and Java. It is available in both the community
    and enterprise editions. The enterprise edition has the same features as the community
    one, with additional features like enterprise-grade availability, management and
    scale-up and scale-out capabilities. In the case of RDBMS, the performance degrades
    exponentially as the number of relations increases, whereas in Neo4j it is linear.
    The following image shows the various graph databases:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j之所以如此受欢迎，是因为它的强大、快速和可扩展性。它主要用Scala和Java实现。它提供社区版和企业版。企业版具有与社区版相同的功能，还增加了企业级可用性、管理和扩展能力。在关系型数据库管理系统中，随着关系数量的增加，性能呈指数级下降，而在Neo4j中则是线性的。以下图像显示了各种图数据库：
- en: '![Discerning different graph databases](img/image00420.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![区分不同的图数据库](img/image00420.jpeg)'
- en: Labeled property graph
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签属性图
- en: In the introduction section, we have seen an example of a Social Network representation
    of three friends. This graph representation of data which contains directed connections
    between entities/nodes, relationships between nodes, and properties associated
    with nodes and relationships is called a **labeled property graph data model**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍部分，我们看到了一个三个朋友的社会网络表示的例子。这种包含实体/节点之间的有向连接、节点之间的关系以及与节点和关系关联的属性的图数据表示称为**标签属性图数据模型**。
- en: 'A labeled property graph data model has the following properties:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 标签属性图数据模型具有以下特性：
- en: Graph contains nodes and relationships
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图包含节点和关系
- en: Nodes may contain properties (key-value pairs)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点可以包含属性（键值对）
- en: Nodes may be labeled with one or more labels
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点可以标记一个或多个标签
- en: Relationships are named and directed, and always have a start and end node
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系被命名且具有方向性，并且始终有一个起始节点和一个结束节点
- en: Relationships may also contain properties
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系也可能包含属性
- en: Listed concepts are explained in the following section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的概念将在以下章节中解释。
- en: Understanding GraphDB core concepts
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解GraphDB核心概念
- en: 'The following list enumerates all the elements of a graph:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表列举了图的所有元素：
- en: '**Nodes**: Nodes are the fundamental unit of a graph. Nodes are the vertices
    in the graph. It mostly refers to the main object that is being referred. Nodes
    can contains labels and properties. From the story, we can pull three different
    objects and make three nodes. Two of those are for friends and the other one is
    for the movie.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：节点是图的基本单元。节点是图中的顶点。它主要指的是被引用的主要对象。节点可以包含标签和属性。从故事中，我们可以提取三个不同的对象并创建三个节点。其中两个是朋友，另一个是电影。'
- en: '**Labels**: Labels are the way to differentiate between the same kinds of objects.
    Labels are generally given to each node with similar characteristics. Nodes can
    have more than one label. In the example story, we gave labels of **PERSON** and
    **MOVIE**. This optimized the graph traversal and also helped in logically querying
    the model efficiently.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：标签是用来区分相同类型对象的方式。标签通常被赋予具有相似特征的每个节点。节点可以有多个标签。在示例故事中，我们给出了**PERSON**和**MOVIE**的标签。这优化了图遍历，并有助于高效地逻辑查询模型。'
- en: '**Relationships**: Relationships are the edge between two nodes. They can be
    unidirectional and bidirectional. They can also contain the property for which
    the relationship is being created. Relationships are named and directed, and always
    have a start and end node. For example, there is a relationship of *Friend Of*
    between two friends. This shows the connection between different nodes. There
    is also a relation of *Has Watched* between each of the friends with the movie
    node.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系**：关系是两个节点之间的边。它们可以是单向的也可以是双向的。它们还可以包含创建关系时使用的属性。关系是有名称和方向的，并且始终有一个起始节点和一个结束节点。例如，两个朋友之间存在“Friend
    Of”的关系。这显示了不同节点之间的连接。每个朋友与电影节点之间也存在“Has Watched”的关系。'
- en: '**Properties**: Properties are key value pairs. Properties can be used for
    both nodes and relationships. They are used to save the details about a particular
    node or relationship. In the example, the Person node has the properties of name
    and age. These properties are used to distinguish different nodes. Relation Has
    Watched also has the properties of date and rating.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：属性是键值对。属性可以用于节点和关系。它们用于保存有关特定节点或关系的详细信息。在示例中，Person节点具有姓名和年龄属性。这些属性用于区分不同的节点。关系“Has
    Watched”也有日期和评分属性。'
- en: 'In the following diagram, **JOHN**, **KRISH**, and **PAUL** are nodes that
    are mapped as User labels. Also, observe the edges that show relations. Both nodes
    and relations can have properties to further describe them:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，**JOHN**、**KRISH**和**PAUL**是映射为用户标签的节点。同时，观察显示关系的边。节点和关系都可以有属性来进一步描述它们：
- en: '![Understanding GraphDB core concepts](img/image00421.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![理解GraphDB核心概念](img/image00421.jpeg)'
- en: Neo4j
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Neo4j
- en: Neo4j is an open-source Graph Database implemented in Java and Scala. Neo4j
    implements labeled property graph model efficiently. Like any other database,
    Neo4j provides ACID transactions, runtime fail-over and cluster support, allowing
    it for developing production ready applications. This graph database architecture
    is designed for efficient data storage and faster traversal between Nodes and
    relations. To work with the data for storing, retrievals and traversal, we use
    **CYPHER query language** which is Neo4j's query language based on patterns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j是一个用Java和Scala实现的开源图数据库。Neo4j高效地实现了标签属性图模型。像任何其他数据库一样，Neo4j提供ACID事务、运行时故障转移和集群支持，使其能够开发生产就绪的应用程序。这种图数据库架构旨在高效存储数据并加快节点和关系之间的遍历。为了处理存储、检索和遍历数据，我们使用**CYPHER查询语言**，这是基于模式的Neo4j查询语言。
- en: Cypher query language
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CYPHER查询语言
- en: Cypher is the query language for Neo4j that follows SQL-like queries. It is
    a declarative query language that focuses on what to retrieve from the graph,
    rather than how to retrieve it. We know that Neo4j property graphs consist of
    nodes and relationships; though these nodes and relationships are the basic building
    blocks, the real power of a graph database is to identify the underlying patterns
    that exist between nodes and relationships. This pattern extraction capability
    of graph databases, such as Neo4j, helps us to perform complex operations very
    quickly and efficiently.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher 是 Neo4j 的查询语言，它遵循类似 SQL 的查询。它是一种声明性查询语言，专注于从图中检索什么，而不是如何检索它。我们知道 Neo4j
    属性图由节点和关系组成；尽管这些节点和关系是基本构建块，但图数据库的真实力量在于识别节点和关系之间存在的底层模式。这种图数据库（如 Neo4j）的模式提取能力帮助我们非常快速和高效地执行复杂操作。
- en: Neo4j's Cypher query language is based on patterns. These patterns are used
    for matching underlying graph structures so that we may make use of patterns for
    further processing, such as building recommendation engines, in our case.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 的 Cypher 查询语言基于模式。这些模式用于匹配底层图结构，以便我们可以利用模式进行进一步处理，例如在我们的案例中构建推荐引擎。
- en: 'An example of extracting patterns using a Cypher query is shown later. The
    following Cypher query matches all *friendof* patterns between pairs of users
    and returns them as a graph:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 Cypher 查询提取模式的示例。以下 Cypher 查询匹配用户对之间的所有 *friendof* 模式，并将它们作为图返回：
- en: '![Cypher query language](img/image00422.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Cypher 查询语言](img/image00422.jpeg)'
- en: Cypher query basics
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cypher 查询基础
- en: 'Before we go into building recommendations using Neo4j, let us look into the
    basics of Cypher query. As we mentioned earlier, Cypher is the query language
    for Neo4j that follows SQL-like queries. Being a declarative language, Cypher
    focuses on what to retrieve from the graph rather than how to retrieve it. The
    key principles and capabilities of Cypher are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Neo4j 构建推荐之前，让我们先了解一下 Cypher 查询的基础。正如我们之前提到的，Cypher 是 Neo4j 的查询语言，它遵循类似
    SQL 的查询。作为一种声明性语言，Cypher 专注于从图中检索什么，而不是如何检索。Cypher 的关键原则和能力如下：
- en: Cypher matches key patterns between nodes and relationships in the graph to
    extract information from the graph.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 在图中的节点和关系之间匹配关键模式，以从图中提取信息。
- en: Cypher has many capabilities similar to SQL such as create, delete, and update.
    These operations are applied to nodes and relationships to fetch information.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 具有许多与 SQL 类似的特性，如创建、删除和更新。这些操作应用于节点和关系以获取信息。
- en: Indexing and constraints similar to SQL are also present.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 SQL 类似的索引和约束也存在于其中。
- en: Node syntax
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点语法
- en: Cypher uses pairs of parentheses `()` or pairs of parenthesis with text inside
    to represent nodes. Furthermore, we can assign labels, and properties of nodes
    are given as key-value pairs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher 使用成对的括号 `()` 或带有文本的成对括号来表示节点。此外，我们可以分配标签，节点的属性作为键值对给出。
- en: 'Look at the following example to understand the concept better. In the following
    queries, node is represented using `()` or `(user)`, label is represented with
    `u`, `(u:user)` and properties of the node are assigned with key-value pairs as
    `(u:user{name:''Toby''})` :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，帮助你更好地理解概念。在以下查询中，节点使用 `()` 或 `(user)` 表示，标签使用 `u`、`(u:user)`，节点的属性则通过键值对分配，例如
    `(u:user{name:'Toby'})`：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Relationship syntax
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系语法
- en: Cypher uses `-[]->` to represent relationships between two nodes. These relationships
    allow developers to represent complex relations between nodes, making them easier
    to read or understand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher 使用 `-[]->` 来表示两个节点之间的关系。这些关系允许开发者表示节点之间的复杂关系，使它们更容易阅读或理解。
- en: 'Let us look at the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看以下示例：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, a `friendof` relationship is established between two
    user nodes and the relationship is having property `since:2016`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在两个用户节点之间建立了 `friendof` 关系，并且该关系具有属性 `since:2016`。
- en: Building your first graph
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建你的第一个图
- en: 'Now that we saw the node syntax and relationship syntax, let us practice what
    we have learned so far by creating a Facebook social network graph similar to
    the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了节点语法和关系语法，让我们通过创建一个类似于以下图表的 Facebook 社交网络图来练习我们到目前为止所学的内容：
- en: '![Building your first graph](img/image00423.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![构建你的第一个图](img/image00423.jpeg)'
- en: 'In order to create the above graph, we need following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建上述图，我们需要以下步骤：
- en: Create 3 nodes Person with labels JOHN, PAUL, KRISH
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 3 个节点 Person，标签为 JOHN、PAUL、KRISH
- en: Create relationships between 3 Nodes
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CREATE`子句在3个节点之间创建关系
- en: Set properties
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置属性
- en: Display results used with all the patterns
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有模式显示结果
- en: Creating nodes
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建节点
- en: 'We use the `CREATE` clause to create graph elements such as nodes and relations.
    The below example shows us how to create a single node Person labeled as john
    and having the property name:`JOHN`. When we run the below query in Neo4j browser,
    we get the graph as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`CREATE`子句来创建图元素，如节点和关系。以下示例展示了如何创建一个标记为`john`的单个节点Person，并具有属性名称`JOHN`。当我们运行以下查询在Neo4j浏览器中时，我们得到以下截图所示的图：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Creating nodes](img/image00424.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![创建节点](img/image00424.jpeg)'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The RETURN clause helps to return the result set, namely Node - PERSON
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`RETURN`子句有助于返回结果集，即节点 - 人员'
- en: 'Instead of just creating one node, we can create multiple nodes as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以创建一个节点，还可以按照以下方式创建多个节点：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Earlier code will create three nodes, and Person labelled `JOHN`, `PAUL`, `KRISH`.
    Let''s see what we have created so far; to see the results we have to use `MATCH`
    clause. `MATCH` clause will check for the required patterns and return the retrieved
    patterns using `RETURN` clause. In the below query, `MATCH` will look for patterns
    such as Person nodes with labels names `k`,`p`,`j` and their corresponding labels:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 早期代码将创建三个节点，标记为`JOHN`、`PAUL`、`KRISH`的人员。让我们看看我们到目前为止创建了什么；为了查看结果，我们必须使用`MATCH`子句。`MATCH`子句将查找模式，如具有标签名称`k`、`p`、`j`的人员节点及其相应的标签：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Creating nodes](img/image00425.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建节点](img/image00425.jpeg)'
- en: Creating relationships
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建关系
- en: With creation of nodes we are half done. Now, let's complete the remaining portion
    by creating relations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建节点，我们已经完成了一半。现在，让我们通过创建关系来完成剩余部分。
- en: 'Instructions for creating relationships are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建关系的说明如下：
- en: Extract the nodes from the database using the `MATCH` clause
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`MATCH`子句从数据库中提取节点
- en: Create the required relationships between the `Persons` using the `CREATE` clause
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CREATE`子句在`Persons`之间创建所需的关系
- en: 'In the following query, we are extracting all the `Person` nodes and then creating
    relationships called `FRIENDOF` between the nodes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下查询中，我们正在提取所有`Person`节点，然后在节点之间创建名为`FRIENDOF`的关系：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the result displayed when we run the earlier
    query:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行先前查询时的结果：
- en: '![Creating relationships](img/image00426.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![创建关系](img/image00426.jpeg)'
- en: 'Now we have created all the required nodes and relationships. To see what we
    have achieved, run the following query, which displays Nodes and relationships
    between the nodes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有必要的节点和关系。为了查看我们取得了什么成果，运行以下查询，该查询显示节点和节点之间的关系：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Creating relationships](img/image00427.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![创建关系](img/image00427.jpeg)'
- en: Setting properties to relations
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置关系的属性
- en: 'The final step is to set properties to node labels and relationships, and is
    explained as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是设置节点标签和关系的属性，具体说明如下：
- en: 'We use the `SET` clause to set the properties. For setting properties to relations
    we need to follow two steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`SET`子句来设置属性。对于设置关系的属性，我们需要遵循两个步骤：
- en: Extract all the relations , `FRIENDOF`
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取所有关系，`FRIENDOF`
- en: Use the `SET` clause to set the properties to these relations
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SET`子句将这些关系的属性设置为这些关系
- en: 'In the following example, we set the properties to the relation `FRIENDOF`
    between `KRISH` and `PAUL` with the property `friendsince` as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将属性设置为`KRISH`和`PAUL`之间的`FRIENDOF`关系，属性`friendsince`如下所示：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Setting properties to relations](img/image00428.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![设置关系的属性](img/image00428.jpeg)'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous query , `()-[]->` pattern extracts relation `Krish` is `friendOfPaul`
    and `() <- [] -` pattern extracts relation `Paul` is `friendOf` of `Krish.`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的查询中，`()-[]->`模式提取关系`Krish`是`friendOfPaul`，而`() <- [] -`模式提取关系`Paul`是`Krish`的`friendOf`。
- en: 'Let''s display the results so far as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式显示到目前为止的结果：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following diagram shows the nodes, relationships and properties added in
    the previous query.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了在先前查询中添加的节点、关系和属性。
- en: '![Setting properties to relations](img/image00429.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![设置关系的属性](img/image00429.jpeg)'
- en: In the preceding diagram we can see that for `KRISH` and `PAUL` the property
    for the `FRIENDOF` relation has been set as `friendsince`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到对于`KRISH`和`PAUL`，`FRIENDOF`关系的属性已设置为`friendsince`。
- en: 'Similarly, we can set the properties to the nodes as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将属性设置为节点，如下所示：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Setting properties to relations](img/image00430.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![设置关系的属性](img/image00430.jpeg)'
- en: 'Let''s verify the results here using the following query, which displays nodes,
    relationships, labels, properties to nodes, and relationships:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下查询来验证结果，该查询显示节点、关系、标签、节点属性和关系属性：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Setting properties to relations](img/image00431.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![设置关系的属性](img/image00431.jpeg)'
- en: Loading data from csv
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从csv加载数据
- en: In the previous section, we created nodes, relationships, and properties manually.
    Most of the time, we create nodes by loading data from csv files. To achieve this,
    we use the `LOAD CSV` command readily available in Neo4j, to load data into the
    Neo4j browser.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们手动创建了节点、关系和属性。大多数时候，我们通过从csv文件加载数据来创建节点。为了实现这一点，我们使用Neo4j浏览器中现成的`LOAD
    CSV`命令来加载数据。
- en: The following screenshot shows the dataset we will be using for this section
    which contains user-movie-rating data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本节将使用的数据集，其中包含用户电影评分数据。
- en: '![Loading data from csv](img/image00432.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![从csv加载数据](img/image00432.jpeg)'
- en: 'Query below to load csv data given below:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询用于加载以下csv数据：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding query:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的查询中：
- en: The **HEADERS** keyword allows us to ask the query engine to consider the first
    row as header information
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HEADERS** 关键字允许我们要求查询引擎将第一行视为标题信息'
- en: The **WITH** keyword is similar to the return keyword; it separate portions
    of the query explicitly and allows us to define which values or variables we should
    carry forward to the next parts of the query
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WITH** 关键字与返回关键字类似；它明确地分隔查询的部分，并允许我们定义应该将哪些值或变量携带到查询的下一部分'
- en: The **AS** keyword is used to create an alias name to variables
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AS** 关键字用于为变量创建别名'
- en: 'When we run the above query, two things happen:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述查询时，会发生两件事：
- en: '**CSV** data will be loaded to the graph database'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSV** 数据将被加载到图数据库'
- en: The **RETURN** clause will display the loaded data, as shown in the following
    screenshot:![Loading data from csv](img/image00433.jpeg)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RETURN** 子句将显示加载的数据，如下截图所示：![从csv加载数据](img/image00433.jpeg)'
- en: Neo4j Windows installation
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Neo4j Windows安装
- en: 'In this section, we will see how to install Neo4j for Windows. We can download
    the Neo4j Windows installer from the following URL:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何为Windows安装Neo4j。我们可以从以下URL下载Neo4j Windows安装程序：
- en: '[https://neo4j.com/download/](https://neo4j.com/download/)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://neo4j.com/download/](https://neo4j.com/download/)'
- en: '![Neo4j Windows installation](img/image00434.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Neo4j Windows安装](img/image00434.jpeg)'
- en: 'Once the installer is downloaded, click on the installer to get the following
    screen to proceed with installation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下载安装程序后，点击安装程序以获取以下屏幕，继续进行安装：
- en: '![Neo4j Windows installation](img/image00435.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Neo4j Windows安装](img/image00435.jpeg)'
- en: 'After successful installation, start the Neo4j Community Edition. For the first
    time you will see the following screen, asking you to choose a directory to store
    the graph database, and then click on **Start**:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，启动Neo4j社区版。第一次您将看到以下屏幕，要求您选择一个目录来存储图数据库，然后点击**启动**：
- en: '![Neo4j Windows installation](img/image00436.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Neo4j Windows安装](img/image00436.jpeg)'
- en: 'In our case we have chosen the default directory where the `graphdb` database
    is created as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们选择了默认目录，其中创建了`graphdb`数据库，如下所示：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After we click the start button, as shown in the preceding screenshot, start Neo4j
    will be started and will be displayed as below. We are now ready to start working
    on Neo4j.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 点击前面的截图中的启动按钮后，Neo4j将被启动，并显示如下。我们现在可以开始使用Neo4j工作了。
- en: '![Neo4j Windows installation](img/image00437.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Neo4j Windows安装](img/image00437.jpeg)'
- en: 'Now that we have started Neo4j, we can access it from the browser by using:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了Neo4j，我们可以通过以下方式从浏览器访问它：
- en: '`http://localhost:7474`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:7474`'
- en: Installing Neo4j on the Linux platform
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux平台上安装Neo4j
- en: In this section we learn about downloading and installing Neo4j on the CentOS
    Linux platform.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在CentOS Linux平台上下载和安装Neo4j。
- en: Downloading Neo4j
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载Neo4j
- en: 'We can download the latest version of the Neo4j 3 Linux source file from the
    Neo4j home page:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从Neo4j主页下载Neo4j 3 Linux源文件的最新版本：
- en: '[https://Neo4J.com/](https://neo4j.com/)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://Neo4J.com/](https://neo4j.com/)'
- en: 'Click on the **Download Neo4J** button on the page shown as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 点击以下显示的页面上的**下载Neo4J**按钮：
- en: '![Downloading Neo4j](img/image00438.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![下载Neo4j](img/image00438.jpeg)'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively you can download it directly from the following URL:[http://info.Neo4J.com/download-thanks.html?edition=community&release=3.0.6&flavour=unix&_ga=1.171681440.1829638272.1475574249](http://info.neo4j.com/download-thanks.html?edition=community&release=3.0.6&flavour=unix&_ga=1.171681440.1829638272.1475574249)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以直接从以下URL下载：[http://info.Neo4J.com/download-thanks.html?edition=community&release=3.0.6&flavour=unix&_ga=1.171681440.1829638272.1475574249](http://info.neo4j.com/download-thanks.html?edition=community&release=3.0.6&flavour=unix&_ga=1.171681440.1829638272.1475574249)
- en: 'This will download a `tar` file - `Neo4J-community-3.0.6-unix.tar.gz` as shown
    in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载一个`tar`文件 - `Neo4J-community-3.0.6-unix.tar.gz`，如下截图所示：
- en: '![Downloading Neo4j](img/image00439.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![下载Neo4j](img/image00439.jpeg)'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can find the developer resources at [https://Neo4J.com/developer/get-started/](https://Neo4J.com/developer/get-started/)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[https://Neo4J.com/developer/get-started/](https://Neo4J.com/developer/get-started/)找到开发者资源
- en: Setting up Neo4j
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Neo4j
- en: 'Extract the `tar` file and you will get a folder called `Neo4J-community-3.0.6`
    containing the following files:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 解压`tar`文件，你将得到一个名为`Neo4J-community-3.0.6`的文件夹，其中包含以下文件：
- en: '![Setting up Neo4j](img/image00440.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![设置Neo4j](img/image00440.jpeg)'
- en: Starting Neo4j from the command line
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令行启动Neo4j
- en: Make sure you install Java 8 in your PC, as Neo4j 3.0 version requires Java
    8\. Check the Neo4j requirements before you install.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在你的电脑上安装了Java 8，因为Neo4j 3.0版本需要Java 8。在安装之前检查Neo4j的要求。
- en: 'Once you have installed Java 8 then we can go ahead and run our Neo4j instance,
    but before that, let us set the `Neo4J` path in the `bashrc` file as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了Java 8，我们就可以继续运行我们的Neo4j实例，但在那之前，让我们按照以下方式在`bashrc`文件中设置`Neo4J`路径：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We Start the `Neo4j` in command line using the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令在命令行中启动`Neo4j`：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Starting Neo4j from the command line](img/image00441.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![从命令行启动Neo4j](img/image00441.jpeg)'
- en: We can observe that the Neo4j has been started and we can access the graph `dbcapabilites`
    from the browser at `http://localhost:7474/`
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到Neo4j已经启动，并且我们可以从浏览器在`http://localhost:7474/`访问图`dbcapabilites`。
- en: 'For the first time, running Neo4j in the browser requires you to set the **Username**
    and **Password**:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次在浏览器中运行Neo4j需要你设置**用户名**和**密码**：
- en: '![Starting Neo4j from the command line](img/image00442.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![从命令行启动Neo4j](img/image00442.jpeg)'
- en: 'Once we have set the credentials it will redirect to the following page:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了凭证，它将重定向到以下页面：
- en: '![Starting Neo4j from the command line](img/image00443.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![从命令行启动Neo4j](img/image00443.jpeg)'
- en: 'If you are using it for the first time, spend some time on the browser to get
    acquainted with its features and explore the different options available on the
    left-hand panel. Enter the following command in the browser to display the connection
    details:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次使用它，请在浏览器上花些时间熟悉其功能并探索左侧面板上的不同选项。在浏览器中输入以下命令以显示连接详情：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Starting Neo4j from the command line](img/image00444.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![从命令行启动Neo4j](img/image00444.jpeg)'
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Building recommendation engines
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建推荐引擎
- en: 'In this section, we will learn how to generate collaborative filtering recommendations
    using three approaches. They are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用三种方法生成协同过滤推荐。具体如下：
- en: A simple count of co-rated movies
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对共同评分的电影进行简单计数
- en: Euclidean distance
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧几里得距离
- en: Cosine similarity
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余弦相似度
- en: I would like to highlight a point at this junction. In earlier chapters, we
    learnt that for building recommendation engines using heuristic approaches, we
    used similarity calculations such as Euclidean distance/cosine distance. It is
    not necessary to use only these approaches; we are free to choose our own way
    of computing the closeness or extracting the similarity between two users just
    by simple counts as well, for example, similarity between two users can be extracted
    just by counting the number of the same movies two users have co-rated. If more
    movies have been co-rated by two users then we may assume that they are similar
    to each other. If the count of co-rated movies between two people is less then
    we may assume that their tastes are different.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在此处强调一个观点。在早期章节中，我们了解到在构建使用启发式方法的推荐引擎时，我们使用了如欧几里得距离/余弦距离等相似度计算。并不一定只能使用这些方法；我们可以自由选择自己的方式来计算两个用户之间的接近度或提取相似度，例如，可以通过简单计数来提取两个用户之间的相似度，例如，可以通过计算两个用户共同评分的相同电影的数量来提取两个用户之间的相似度。如果两个用户共同评分的电影更多，那么我们可以假设他们彼此相似。如果两个人共同评分的电影数量较少，那么我们可以假设他们的品味不同。
- en: 'This assumption is taken to build our first recommendation engine and is explained
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个假设是为了构建我们的第一个推荐引擎，以下进行解释：
- en: 'For building a collaborative movie recommendation engine, we will build a system
    based on past movie rating behavior of users. The steps we follow can be summarized
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个基于用户过去电影评分行为的协同电影推荐引擎，我们将构建一个系统，其步骤可以总结如下：
- en: Loading data into an environment
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据加载到环境中
- en: Extracting relations and extracting similarity between users
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取关系和提取用户之间的相似度
- en: Recommendation step
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推荐步骤
- en: Loading data into Neo4j
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据加载到Neo4j
- en: 'Though we have multiple ways of loading data into Neo4j, we use the `Load CSV`
    option to import the data into the browser tool. The following diagram shows the
    workflow of the process of loading the CSV process:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有多种将数据加载到Neo4j的方法，但我们使用 `Load CSV` 选项将数据导入浏览器工具。以下图表显示了加载CSV过程的流程：
- en: '![Loading data into Neo4j](img/image00445.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![将数据加载到Neo4j](img/image00445.jpeg)'
- en: 'The dataset we use for this section is the small sample data set containing
    Users-Movies-ratings, as shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中使用的数据集是包含用户-电影-评分的小样本数据集，如下截图所示：
- en: '![Loading data into Neo4j](img/image00446.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![将数据加载到Neo4j](img/image00446.jpeg)'
- en: 'Let''s load the MovieLens data into the Neo4j browser tool as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将MovieLens数据加载到Neo4j浏览器工具中，如下所示：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now let's create Users and Movies as nodes and the ratings given by Users to
    Movies as the relations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建用户和电影作为节点，以及用户对电影给出的评分作为关系。
- en: 'The `MERGE` clause will find the query patterns in the data, and if it doesn''t
    find any it will create one. In the following example below, first it look for
    a User Node (pattern) and then creates one if it doesn''t exist. Since we have
    just loaded the data into GraphDB, we need to create nodes and establish relationships.
    Following code will first looks for the mentioned nodes and relationships; if
    not found it will create new nodes and relationships:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERGE` 子句将在数据中查找查询模式，如果没有找到，它将创建一个。在以下示例中，首先查找用户节点（模式），如果不存在，则创建一个。由于我们刚刚将数据加载到GraphDB中，我们需要创建节点并建立关系。以下代码将首先查找提到的节点和关系；如果没有找到，它将创建新的节点和关系：'
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we run the previous query, nodes, relationships, and properties will be
    created as shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的查询时，节点、关系和属性将创建如下截图所示：
- en: '![Loading data into Neo4j](img/image00447.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![将数据加载到Neo4j](img/image00447.jpeg)'
- en: Now, we shall understand each line one by one to make our understanding more
    clear.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐行理解，以使我们的理解更加清晰。
- en: 'Merge will create `USER` Node from `UserID` columns from the original data:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERGE` 将从原始数据的 `UserID` 列创建 `USER` 节点：'
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `With` command will take the `User` node and line object to the next part
    of the query as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`With` 命令将 `User` 节点和行对象带到查询的下一部分，如下所示：'
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we will create `Movie` Node using `MERGE` and `line.ItemId` object as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `MERGE` 和 `line.ItemId` 对象创建 `Movie` 节点，如下所示：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We carry forward the Movie, User nodes, and line object to the next part of
    the query as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将电影、用户节点和行对象带到查询的下一部分，如下所示：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We create a relation between `USER` node and `MOVIE` node as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个关系，将 `USER` 节点与 `MOVIE` 节点连接，如下所示：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we have loaded the data into Neo4j, we can visualize the movie ratings
    data with users, movies and ratings as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据加载到Neo4j中，我们可以如下可视化电影评分数据，包括用户、电影和评分：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the following image, all users are created in green color, and movies are
    created in red color. We can also see the relationships as arrows with directions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，所有用户以绿色创建，电影以红色创建。我们还可以看到以箭头表示的带有方向的关联关系。
- en: '![Loading data into Neo4j](img/image00448.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![将数据加载到Neo4j](img/image00448.jpeg)'
- en: Generating recommendations using Neo4j
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Neo4j生成推荐
- en: We have now created all the required graphs for building our first recommendation
    engine using Neo4j. Let's get started.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了构建我们第一个推荐引擎所需的全部图，让我们开始吧。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the following query `COUNT()` function will count the number of instances,
    `collect()` will.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下查询中，`COUNT()` 函数将计算实例的数量，`collect()` 将。
- en: 'The following screenshot will return movie recommendations to the sample user
    `''TOBY''`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图将返回对样本用户 `'TOBY'` 的电影推荐：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following query shows the recommendations made to Toby when we run the
    earlier query:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询显示了在运行早期查询时对Toby做出的推荐：
- en: '![Generating recommendations using Neo4j](img/image00449.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![使用Neo4j生成推荐](img/image00449.jpeg)'
- en: 'The concept behind making recommendations in the previous query is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上一查询中推荐背后的概念如下：
- en: Extract pair of users who have rated the same movies
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取评分相同电影的用户对
- en: Take the count of commonly rated movies by each pair of users
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取每对用户共同评分电影的计数
- en: The higher the commonly rated movie count, the more similar two users are to
    each other
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共同评分电影的数量越多，两个用户之间的相似度就越高
- en: The final step is to extract all the movies which similar users have rated,
    but which have not been rated by the active user, and suggest these new movies
    as recommendations to the active user
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一步是从所有相似用户已评分但活跃用户未评分的电影中提取所有电影，并将这些新电影作为推荐提供给活跃用户。
- en: 'Let''s understand the query we just saw step by step:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地理解我们刚才看到的查询：
- en: In line one, for each user (say `USER1`) who has rated a movie (say `MOVIE1`),
    select all the users (say `USER2`) who have also rated `MOVIE1`. For this `USER2`,
    also extract other movies rated by him, apart from `MOVIE1`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一行，对于每个已评分电影（例如`MOVIE1`）的用户（例如`USER1`），选择所有也评分了`MOVIE1`的用户（例如`USER2`）。对于这个`USER2`，也提取他除`MOVIE1`之外评分的其他电影。
- en: In line two, we carry similar users (`u1`,`u2`), calculating the count of co-rated
    movies by `u1`,`u2`, and extracting shared/co-rated movies by `u1`,`u2` to the
    next part of the query.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二行，我们携带相似用户(`u1`,`u2`)，计算`u1`,`u2`共同评分电影的计数，并将`u1`,`u2`共同评分的电影提取到查询的下一部分。
- en: In line three, we now apply a filter where we choose those movies that are not
    being rated by `u1` and the count of co-rated movies greater than two.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三行，我们现在应用一个过滤器，选择那些未被`u1`评分且共同评分电影计数大于两的电影。
- en: In line 4 we return new movies rated by similar users to `u1` as recommendations.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第4行，我们返回`u1`由相似用户评分的新电影作为推荐。
- en: Collaborative filtering using the Euclidean distance
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用欧几里得距离进行协同过滤
- en: In the previous section, we saw how to build recommendation engines using a
    simple count-based approach for identifying similar users, and then we chose movies
    from similar users which the active user has not rated or recommended.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用简单的基于计数的简单方法构建推荐引擎来识别相似用户，然后我们从相似用户中选择活跃用户未评分或推荐的电影。
- en: In this section, instead of computing the similarity between two users based
    on the simple count of co-rated movies, let us make use of the rating information
    and calculate the Euclidean distance, to come up with the similarity score.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不再基于简单的共同评分电影计数来计算两个用户之间的相似度，而是利用评分信息并计算欧几里得距离，以得出相似度得分。
- en: 'The following cypher query will generate recommendations for the user, Toby,
    based on the Euclidean similarity:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Cypher查询将根据欧几里得相似度为用户Toby生成推荐：
- en: 'The first step is to extract co-rated users by movies and calculate the Euclidean
    distance between co-rated users as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是通过电影提取共同评分用户并计算共同评分用户之间的欧几里得距离，如下所示：
- en: '[PRE26]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this code we are using `reduce()` and `extract()` to calculate the Euclidean
    distance. In order to apply mathematical calculations, we have changed the values
    to floating point numbers using the `float()` function in the following query.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用`reduce()`和`extract()`来计算欧几里得距离。为了应用数学计算，我们使用以下查询中的`float()`函数将值转换为浮点数。
- en: 'To see the Euclidean distance values between pairs of users, run the below
    query:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看用户对之间的欧几里得距离值，请运行以下查询：
- en: '[PRE27]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Collaborative filtering using the Euclidean distance](img/image00450.jpeg)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用欧几里得距离进行协同过滤](img/image00450.jpeg)'
- en: 'In the second step, we calculate the Euclidean distance using the formula *sqrt(sum((R1-R2)*(R1-R2)))*,
    where *R1* is the rating given by `Toby` for a `movie1` and *R2* is the other
    co-rated user''s rating for the same `movie1`, and we take the top three similar
    users, as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，我们使用公式*sqrt(sum((R1-R2)*(R1-R2)))*计算欧几里得距离，其中*R1*是`Toby`为`movie1`给出的评分，而*R2*是其他共同评分用户对同一`movie1`的评分，我们选择前三个相似用户，如下所示：
- en: '[PRE28]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final step is to suggest or recommend non-rated movies from the top three
    similar users to `Toby` as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是向Toby推荐或建议来自前三个相似用户的未评分电影，如下所示：
- en: '[PRE29]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Collaborative filtering using the Euclidean distance](img/image00451.jpeg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用欧几里得距离进行协同过滤](img/image00451.jpeg)'
- en: 'Let us explain the preceding query in detail as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释前面的查询如下：
- en: 'As we explained in the first step, we extract co-rated movies by users along
    with their ratings as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在第一步中解释的那样，我们提取了用户共同评分的电影及其评分，如下所示：
- en: 'In our example, Toby has rated three movies: Snakes on a Planet, Superman Returns,
    and You Me and Dupree. Now we have to extract other common users who have co-rated
    the same three movies as Toby. For this, we use the following query:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的例子中，Toby已经评了三部电影：《星球上的蛇》、《超人归来》和《你、我、杜普雷》。现在我们必须提取其他共同用户，他们与Toby共同评了这三部电影。为此，我们使用以下查询：
- en: '[PRE30]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Collaborative filtering using the Euclidean distance](img/image00452.jpeg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用欧几里得距离的协同过滤](img/image00452.jpeg)'
- en: 'The second step is to calculate the Euclidean distance between the ratings
    given to each co-rated movie by the other users, to the movies of Toby, and this
    is calculated using the following query:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是计算其他用户对每个共同评分电影的评分与Toby电影的欧几里得距离，这通过以下查询计算：
- en: '[PRE31]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding query, we create and merge new relationships between each of
    the co-rated users to show the distance between two users, using the MERGE clause.
    Also, we set the property of the relationship as EUCSIM (which represents the
    Euclidean distance between each of the co-rated users) using the SET clause.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的查询中，我们使用MERGE子句创建并合并了每个共同评分用户之间的关系，以显示两个用户之间的距离。此外，我们使用SET子句将关系的属性设置为EUCSIM（表示每个共同评分用户之间的欧几里得距离）。
- en: 'Now that we have created new relations and set the values of the similarity
    distances, let us view the results as given by the following query:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经创建了新的关系并设置了相似度距离的值，让我们查看以下查询给出的结果：
- en: '[PRE32]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following screenshot shows the similarity value for Toby with other users:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了Toby与其他用户的相似度值：
- en: '![Collaborative filtering using the Euclidean distance](img/image00453.jpeg)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用欧几里得距离的协同过滤](img/image00453.jpeg)'
- en: 'The final step is to predict the non-rated movies by Toby, and then recommend
    the top-rating predicted items. To achieve this, we employ the following steps:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是预测Toby未评分的电影，然后推荐评分最高的预测项目。为此，我们采取以下步骤：
- en: Extract the movies rated by similar users to Toby, but not rated by Toby himself
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取与Toby相似的用户评分的电影，但不是Toby自己评分的电影
- en: Take the ratings given for all the non-rated movies and average them, to predict
    the ratings that Toby might give to these movies.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有未评分电影的评分取平均值，以预测Toby可能对这些电影给出的评分。
- en: Display the sorted results as per the predicted rating, in descending order.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照预测的评分，以降序显示排序后的结果。
- en: 'To achieve this, use the following query:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要实现这一点，请使用以下查询：
- en: '[PRE33]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Collaborative filtering using the Euclidean distance](img/image00454.jpeg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用欧几里得距离的协同过滤](img/image00454.jpeg)'
- en: 'Let us understand the recommendations query line-by-line as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行理解推荐查询，如下所示：
- en: 'The following query fetches the patterns of all the users who are similar to
    Toby, and all the movies rated by similar users, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询检索了与Toby相似的所有用户及其相似用户评分的所有电影，如下所示：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `WHERE NOT` clause will filter out all the movies that have been rated
    by similar users but not by Toby, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE NOT`子句将过滤掉所有被类似用户评分但未被Toby评分的电影，如下所示：'
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Movies, similarity values and ratings given by the co-users are passed to the
    next part of the query using the `WITH` clause and the results are ordered by
    descending similarity value as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将共同用户给出的电影、相似度值和评分传递到查询的下一部分，并按降序相似度值排序，如下所示：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After sorting the results based on the similarity values, we further allow
    values, such as movie name and ratings, to the next part of the query using the
    `WITH` clause, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 根据相似度值对结果进行排序后，我们进一步允许将电影名称和评分等值添加到查询的下一部分，如下所示：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is the main step for recommending movies to Toby, predicting the ratings
    for non-rated movies by Toby by taking the average of movie ratings by similar
    users to Toby, and using the `REDUCE` clause, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是向Toby推荐电影的主要步骤，通过取与Toby相似的用户的电影评分的平均值，并使用`REDUCE`子句预测未评分电影的评分，如下所示：
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we sort the final results and return the top movies to Toby as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们排序最终结果，并按如下方式返回给Toby的顶级电影：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Collaborative filtering using Cosine similarity
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用余弦相似度的协同过滤
- en: Now that we have seen recommendations based on simple count and Euclidean distances
    for identifying similar users, let us use Cosine similarity to calculate the similarity
    between users.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了基于简单计数和欧几里得距离来识别相似用户的推荐，让我们使用余弦相似度来计算用户之间的相似度。
- en: 'The following query is used to create a new relation called similarity between
    users:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询用于创建一个名为相似度的新关系：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Collaborative filtering using Cosine similarity](img/image00455.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![使用余弦相似度进行协同过滤](img/image00455.jpeg)'
- en: 'Let us explore the similarity values as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式探索相似度值：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Collaborative filtering using Cosine similarity](img/image00456.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![使用余弦相似度进行协同过滤](img/image00456.jpeg)'
- en: 'We calculate the similar users for Toby as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按以下方式计算Toby的相似用户：
- en: 'For the active user Toby, let us display the similarity values with respect
    to other users as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于活跃用户Toby，让我们显示与其他用户之间的相似度值，如下所示：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The following image displays the results by running the previous Cypher query;
    the results show the similarity value for Toby, with respect to other users.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了运行上一个Cypher查询的结果；结果显示了Toby与其他用户之间的相似度值。
- en: '![Collaborative filtering using Cosine similarity](img/image00457.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![使用余弦相似度进行协同过滤](img/image00457.jpeg)'
- en: 'Now let us start our recommendations of movies to Toby. The recommendation
    process is very similar to what we have done in the previous approach, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始为Toby推荐电影。推荐过程与之前的方法非常相似，如下所示：
- en: Extract movies rated by similar users to Toby but not rated by Toby himself
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取与Toby相似但Toby本人未评分的电影
- en: Take the ratings given for all the non-rated movies and average them to predict
    the ratings that Toby might give to these movies
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有未评分电影的评分取平均值，以预测Toby可能对这些电影给出的评分
- en: Display the sorted results as per the predicted rating, in descending order
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按预测评分降序显示排序结果
- en: 'We use the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Collaborative filtering using Cosine similarity](img/image00458.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![使用余弦相似度进行协同过滤](img/image00458.jpeg)'
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Kudos! We have created recommendation engines using the Neo4j graph database.
    Let us recap what we have learned in this chapter. We started the chapter by giving
    a very brief introduction to graphs and graph databases. We covered a very short
    introduction to the core Neo4j graph database concepts such as the labeled property
    graph model, Nodes, Labels, Relationships, Cypher query language, Patterns, Node
    syntax, and Relationship Syntax.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经使用Neo4j图形数据库创建了推荐引擎。让我们回顾一下本章学到的内容。我们本章开始时简要介绍了图和图数据库。我们简要介绍了Neo4j图形数据库的核心概念，如标记属性图模型、节点、标签、关系、Cypher查询语言、模式、节点语法和关系语法。
- en: We also touched upon Cypher clauses that are useful in building recommendations,
    such as `MATCH` ,`CREATE` ,`LOADCSV` ,`RETURN` ,`AS` ,and `WITH`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了在构建推荐时有用的Cypher子句，例如`MATCH`、`CREATE`、`LOADCSV`、`RETURN`、`AS`和`WITH`。
- en: Then we moved onto installation and setting up Neo4j from the browser tool in
    the Windows and Linux platforms.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向Windows和Linux平台上的浏览器工具中的Neo4j的安装和设置。
- en: Once the entire working environment was setup to build our recommendation engines,
    we chose sample movie ratings data and implemented three types of collaborative
    filtering, such as simple distance based, Euclidean similarity based, and Cosine
    similarity based recommendations. In the next chapter, we will be exploring Mahout,
    a machine learning library available on Hadoop, for building scalable recommender
    systems.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦整个工作环境设置完毕以构建我们的推荐引擎，我们选择了样本电影评分数据并实现了三种类型的协同过滤，如基于简单距离、基于欧几里得相似度和基于余弦相似度的推荐。在下一章中，我们将探索Hadoop上可用的机器学习库Mahout，用于构建可扩展的推荐系统。
