- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a Backend with Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say Web API, it’s an application programming interface we develop that’s
    meant for the client to consume. Said API uses HTTP to communicate. A browser
    can use a Web API to expose data and functionality to other browsers and applications.
  prefs: []
  type: TYPE_NORMAL
- en: When developing a Web API, you can use any programming language and framework
    you want. Regardless of the chosen tech, there are things you always need to consider,
    like data storage, security, authentication, authorization, documentation, testing,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: It’s with this understanding of what things we need to consider that we can
    use an AI assistant to help us build a backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about Web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Web API with Python and Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use our AI assistant to answer questions, suggest code, and create documentation
    and tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Business domain: e-commerce'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will keep working on our e-commerce example in this chapter. This time,
    the focus is on the API. The API lets you read and write data that’s important
    in the e-commerce domain. What’s important to keep in mind as you develop this
    API is that there are a couple of important aspects to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical domains: It’s beneficial to divide up your app into different logical
    domains. Within the context of e-commerce, that usually translates to products,
    orders, invoices, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What part of the business should handle each logical domain?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Products**: Maybe there’s a dedicated team. It’s common for the same team
    to also manage all types of discounts and campaigns that might occur.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoices and payment**: There’s usually a dedicated team that takes care
    of how the user can pay for things, for example, via credit cards, invoices, and
    other methods.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory**: You need to have a certain amount of goods in stock. How do
    you know how much? You need to work with business analysts or data folk to make
    correct forecasts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem and data domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve already mentioned a few different logical domains around products, orders,
    invoices, and so on. The problems you’ll have in this domain are generally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading and writing: What data do you wish to read or write (or maybe both)?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will users access your data (all of it or maybe there will be filters applied
    to limit the output)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access and roles: You can expect that different roles will need to have access
    to your system. An administrator role should probably have access to most of the
    data, whereas a logged-in user should only be able to see the part of the data
    that belongs to them. This is not something we will address in this chapter, but
    it’s something you should consider when you build out this API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature breakdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand that there are both business problems as well as data
    problems, we need to start to identify the features that we need. Once we get
    to this level of detail, it should be easier to come up with specific prompts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to do this feature breakdown is as follows – for example, for products:'
  prefs: []
  type: TYPE_NORMAL
- en: Read all products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read products given a filter: Usually, you won’t want to read all products
    but maybe all products of a certain category, or maybe even limit it to a specific
    value such as 10 products or 20 products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Search for products: You should support the user looking for specific products,
    usually via a category, name, or perhaps part of a certain campaign.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve detailed information on a specific product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m sure there are more features for products, but now you have an idea of what
    granular detail you should have before you continue building the API.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will see how we use both Copilot Chat and the in-editor
    mode. We will start with the Chat mode as it’s quite useful for situations where
    you want to generate starter code. It’s also quite efficient in that it lets you
    select certain lines of code and lets you update only those based on a prompt.
    Examples of the latter could be when you want to improve such code. You will see
    this use case later in the chapter when we improve a route to read from a database
    instead of reading static data from a list. There will also be cases in this chapter
    where we use the in-editor mode. This is the recommended approach when you’re
    actively typing the code and want to make smaller tweaks. In this chapter, we
    will use the “Exploratory prompt pattern” as described in *Chapter 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a Web API is a great way to ensure our front-end application has access
    to the data and functionality it needs to read and write data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expectations of a Web API are:'
  prefs: []
  type: TYPE_NORMAL
- en: It is accessible over the web.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It leverages HTTP protocol and HTTP verbs such as `GET`, `POST`, `PUT`, `DELETE`,
    and others to communicate intentions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What language and framework should you pick?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we already decided we will use Python and Flask. But why? What
    criteria do we use to pick a language and framework?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use any language and framework you want, but here are some criteria
    to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: What languages and frameworks do you know?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are they easy to learn?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do they have a large community?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are they free and open source?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How often are they updated?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do they have good documentation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do they have good tooling?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the criteria to consider.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for picking Python and Flask is that they check many of the above
    boxes (so does the Express framework for Node.js, but the objective here is to
    just show how you can build a Web API using an AI assistant, so feel free to use
    whatever web framework you prefer). Also, the point of this book is to show how
    an AI assistant can help us build a backend; with what prompts and how and the
    framework and language is not the focus.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the Web API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you plan your Web API, you should consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What data do you want to expose? For example, products and orders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What functionality do you want to expose? For example, reading order data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will you structure your Web API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security and authentication: You need to determine not only what areas of your
    app should require the user to log in but also what parts should be restricted
    to specific user types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage and database: Common choices are, for example, MySQL and Postgres.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the above points as a checklist when you plan your Web API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Web API with Python and Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key insight to working with an AI assistant is that we can use it to generate
    code, *but* we need to have a good understanding of the problem domain and the
    solution domain. This means that we should know how to create a Web API with Python
    and Flask before we ask our AI assistant to help us. Can we create it without
    an AI assistant? Yes, but we risk getting stuck and not knowing what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: So, how much knowledge are we talking about? If you know Python in general and
    how to build a Web API in any language, you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Create a new project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need to create a new project. If you know Python, you know using a
    virtual environment is a good idea as it isolates the project from other Python
    projects on your computer. Using a virtual environment is not required but is
    recommended as different versions of Python and packages can cause issues.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so we know we need a virtual environment. How do we create one? Let’s
    rely on our AI assistant to help us remember the syntax. For the prompt below,
    you can either open a text file or use the chat functionality in GitHub Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: How do I create a virtual environment for Python?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: The in-editor experience, typing a prompt in an open text file, prefers you
    to use `q:` at the start of a sentence. If you use the Chat functionality, there’s
    no need to add `q:`.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is on the same row as `a:`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the output can look in an `app.py` file containing both the prompt
    and the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To use the command the AI assistant responded with, we would need to open a
    terminal, paste the command, and run it.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you need enough conceptual knowledge to know that you need to
    activate the virtual environment to use it. But again, let’s ask the AI assistant
    to help us.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: How do I activate a virtual environment for Python in Windows?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are on a Mac or Linux, change the above prompt to reflect your operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Install Flask'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The conceptual knowledge you need to have is that you can install packages –
    in this case, Flask – using `pip`. Let’s ask the AI assistant to help us. Keep
    working with your `app.py` file and add your prompt as another comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: How do I install Flask with pip?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `app.py` should now look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you’re using your AI tool to get quick answers on how to do something, it’s
    up to you if you want to clear the text file from questions and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Great, we now know how to install Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Create an entry point'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create an entry point for our Web API. This is the file that will
    be executed when we run our Web API. For Python, you usually name this file `app.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Create a Flask app'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we have our project, we’ve installed Flask, and we have an entry
    point file, but the application is not a Flask application yet, so let’s create
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s ask the AI assistant to help us.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: How do I create a Flask app?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, keep typing your questions as comments prepended with a `q:` in your
    open text file. Here’s the response from your latest prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: We’re not getting much back from the AI assistant. But we know we need to import
    Flask. Let’s improve the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: How do I create a Flask app with a default route and a “hello” route?
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you’ll see an improved prompt response. The prompt contains more explicit
    instructions to create routes and logical areas in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have some starting code for our Flask app.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s focus on the use case for our Web API – e-commerce.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use case: a Web API for an e-commerce site'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in this book, we’ve taken you through the process of building a front-end
    application for an e-commerce site. We used an AI assistant to help us with the
    front-end application. Now, we will build a Web API for the e-commerce site.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we used an AI assistant to help us create a Flask app.
    Now, we will use the AI assistant to help us create a Web API for an e-commerce
    site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Create a Web API for an e-commerce site'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s plan this task first. Based on previous chapters, the e-commerce site
    has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product catalog**: Containing the products we aim to sell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shopping cart**: With a shopping cart, we can add products to the cart, remove
    products from the cart, and update the quantity of products in the cart. Once
    we’re happy with the products in the cart, we can check out and have the products
    paid for and shipped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A checkout process**: In the checkout process, we need to collect payment
    information and shipping information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the above information in mind, let’s craft a prompt for our AI assistant.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Show me code to create a Flask Web API that includes routes for a product catalog,
    shopping cart, and checkout process.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we have some starting code for our Web API, but we need to improve
    it in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to return JSON instead of text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to add code to read and write to a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to add tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to document the Web API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 2: Return JSON instead of text'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON is a common format for data. It’s a format that is easy to read and write
    for both humans and machines. To use JSON in Python, we need to import the `json`
    package. The method we will use is `jsonify()`, which is a method that will convert
    a Python dictionary to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can use `jsonify()` in our Web API. For this operation, we
    can keep using the AI assistant as prompt comments in the code, or we can use
    GitHub Copilot’s Chat feature (this is a separate extension of GitHub Copilot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the latter. To use GitHub Copilot’s Chat feature (refer to this link
    for updated install instructions: [https://docs.github.com/en/copilot/github-copilot-chat/using-github-copilot-chat-in-your-ide](https://docs.github.com/en/copilot/github-copilot-chat/using-github-copilot-chat-in-your-ide)),
    we need to select the code we want to improve and click the chat icon on the left
    side of Visual Studio Code (if you are using the default orientation, where the
    icons are placed vertically – it depends what other extensions you have installed).
    Here’s the icon to look for. Ensure the GitHub Copilot Chat extension has been
    correctly installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chat icon for GitHub Copilot](img/B21232_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Chat icon for GitHub Copilot'
  prefs: []
  type: TYPE_NORMAL
- en: Once we click the **Chat** icon, and the code selected, we can start chatting
    with GitHub Copilot. Let’s ask GitHub Copilot to help us return JSON instead of
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the following prompt to the chat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Add code to respond with JSON for all routes.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prompt in Copilot chat window](img/B21232_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Prompt in Copilot chat window'
  prefs: []
  type: TYPE_NORMAL
- en: The chat functionality generates an answer consisting of code including the
    `jsonify()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Copilot chat response](img/B21232_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Copilot Chat response'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code generated by GitHub Copilot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Add code to read and write to a database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, so we have a Web API that returns JSON. Now, we need to add code to read
    and write to a database. Let’s use the chat feature again to help us with this
    task.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Add code to read and write to a database and apply it to all our routes.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code we end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we get quite a lot of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Code to connect to a database – in this case, we get a connection to the common
    SQLite database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that creates a table and even reads from it in the `/products` route, but
    we don’t get code to write to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t get code to read and write to the other routes either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the code above, we realize it’s a good start, but there are things
    we’d like to improve, so we will change the prompt to address the shortcomings.
    We need the prompt to ensure all routes read their data from a database, not just
    one.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can either adjust the code ourselves, knowing that most of the code is
    in place, or try to adjust the prompt. Let’s try the latter.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Add code to read and write to a database and apply it to all our routes.
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The improved prompt made the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Added database code to the `/checkout` and `/cart` routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three routes read from the products table, which is incorrect. That’s something
    we need to address in an upcoming prompt. The great news is that we can just tell
    Copilot Chat what the problem is with a prompt and expect the AI assistant to
    change the code accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above code is better than our very first prompt but has issues still.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could try to adjust the prompt in Copilot Chat, but let’s fall back on
    our other approach – namely, prompts in the code. To add these prompts, put your
    cursor in the code and add the prompt as a comment. Here are some prompts we added:'
  prefs: []
  type: TYPE_NORMAL
- en: '*# create tables*: We’re repeating the comment we have already used, but because
    Copilot is now aware of all the routes, it does a better job this time, suggesting
    three database tables should be created rather than just the `products` one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*# add product to cart, productId and quantity in body, create cart if needed,
    else update*: This prompt is detailed as it asks what information should be added
    to each cart entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*# product catalog* and *# shopping cart* are also repeated prompts (we remove
    the old prompt, and retype it to toggle a new suggestion). This time, we get Copilot
    to suggest the correct database tables to read from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note below how we reshape the code with various prompts in the code as comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Is this code good enough or do we need to adjust it further?
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s definitely room for improvement and here’s what you should be looking
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: The code is not DRY (Don’t Repeat Yourself); we have a lot of duplicate code.
    We can solve this by creating a function that takes a query and returns the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization are missing. We should add this to the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation is missing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is not secure. We should add some security measures, especially when
    it comes to the database. As developers, having some knowledge of how to secure
    code, we can use prepared statements to prevent SQL injection attacks and also
    validate the data that we receive from the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 4: Improve the code'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to improve the code is to use the code that we have as a starting
    point and first just try to run it. We can then see what errors we get and what
    we need to fix.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we work on architecture and design and separate the code into different
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we add authentication and authorization and security measures.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s run the code. We need to set the Flask variable `FLASK_APP` to `app.py`
    and then run the app.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Windows, you need to use `set` instead of `export` to set the
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The app is working! We can now go to `http://localhost:5000` and see the message
    **Hello World!**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going to `/products`, `/cart`, and `/checkout` also works, but we don’t have
    any data in the database yet. Let’s add some data to the database. By inserting
    the above code at the top of the file and running the app again, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you rerun the app and go to `/products`, you should see the products
    that we added as the following JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Refactor the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Great – lots of progress so far! Now let’s refactor the code and make it more
    DRY (Don’t Repeat Yourself, a term for ensuring we don’t duplicate code too much).
    We can use Copilot to help us with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide it with the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Improve the code by separating the database parts into a separate module db.py
    and expose the functions as follows: get_products, get_cart, add_to_cart, checkout.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: We get two responses, one for the `db.py` file and one for the `app.py` file.
    Let’s start with the `db.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: We need to improve the above code a bit, as it’s using an open connection to
    the database. We should close the connection after we are done with it. Ensure
    you add code to close the connection after the commit. Also, ensure per route
    that you open and close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: This looks good. Let’s add it to our project. We can create a new file called
    `db.py` and copy the code into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see what it suggested for the `app.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it has separated the database code into the `db.py` file and
    has also added the imports for the `db.py` file. Let’s copy this code into our
    `app.py` file and replace its content.
  prefs: []
  type: TYPE_NORMAL
- en: Does it work? Let’s run the app and see. It runs without any errors, and we
    get JSON output when we go to `/products`, `/cart`, and `/checkout`. If you want,
    you can also make a `POST` request to `/cart` to write cart content – great!
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Document the API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use Copilot Chat to help us document the API. Let’s provide it with
    the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Document the API using Swagger. The API should have the following endpoints:
    GET /products, GET /cart, POST /cart/add, POST /checkout.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[End of prompt]**'
  prefs: []
  type: TYPE_NORMAL
- en: Swagger or OpenAPI standard is a way to document your API routes. These route
    specifications can then be visualized, and you get a quick overview of what your
    API can do. Additionally, there’s something called Swagger UI, a web page that
    not only lets you see what routes you have in your API but you can make requests
    and more, to ensure the API is working as it should.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output, which involves both code and documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Prompt response]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**[End of response]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'And it tells us to create the following files and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let’s create these files manually and copy the content into them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s missing is installing the `flassger` Swagger library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to `http://localhost:5000/apidocs/` and you should see Swagger UI.
  prefs: []
  type: TYPE_NORMAL
- en: '![API doc generated by Swagger](img/B21232_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: API doc generated by Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: You should verify that the API works as expected by interacting with generated
    docs and ensure the routes generate the expected output.
  prefs: []
  type: TYPE_NORMAL
- en: It’s definitely possible to keep improving at this point but take a moment to
    realize how much we created with only prompts and a few lines of code. We have
    a working API with a database and documentation. We can now focus on improving
    the code and adding more features.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the suggested assignment for this chapter: A good assignment would be
    to add more features to the API, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new endpoint to get a single product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new endpoint to remove a product from the cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new endpoint to update the quantity of a product in the cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can solve this by just adding the above to Copilot Chat as prompts and see
    what it generates. Expect both the code and documentation to change.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the solution to this assignment in the GitHub repository: [https://github.com/PacktPublishing/AI-Assisted-Software-Development-with-GitHub-Copilot-and-ChatGPT/tree/main/08](https://github.com/PacktPublishing/AI-Assisted-Software-Development-with-GitHub-Copilot-and-ChatGPT/tree/main/08)'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improve this API by adding more features. You can use Copilot Chat to help you
    with this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to plan out our API. Then we looked at how
    we can choose Python and Flask for the job but stressed the importance of having
    contextual knowledge on how to actually build a Web API. In general, you should
    always know how to do something before you ask an AI assistant to help you with
    it, at least at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: Then we ended up crafting prompts for the AI assistant to help us with the Web
    API. We ended up working with our e-commerce site and created a Web API to serve
    it.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we discussed how to improve the code and add more features to the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to improve our app by adding artificial
    intelligence to it.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/aicode](https://packt.link/aicode)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code510410532445718281.png)'
  prefs: []
  type: TYPE_IMG
